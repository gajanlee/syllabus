Each axis of RSM corresponds to a concept tree as depicted in Fig.6.6. For an RSM of dimensionality d, an RSM of dimensionality d's schema consists of d concept trees. By forest-to-tree transformation, we can construct a binary tree of an RSM of dimensionality d. By labeling each left edge with bit 0 and each right edge with bit 1, we encode all axes and concepts into bit strings by combining all the bits in all axes and concepts's root-to-node paths. Fig. 6.5 demonstrates the genera-tion of an RSM schema tree from the resource space in Fig. 6.4.  
Theorem 6.1.	 Let s1 be the bit string of axis X and s2 be the bit string of concept C. C is a concept in axis X if and only if s10 is the prefix of s2. 
Proof.	The proof consists of the following two parts:  
(=>) In the construction process of RSM schema tree, if C is a concept in X, C corresponding node in RSM schema tree is in the left subtree of X corresponding node. Therefore, s10 is the prefix of s2. 
(<=) If s10 is the prefix of s2, C’s corresponding node in RSM schema tree is in the left subtree of X’s corresponding node. Hence C’s is a concept in X.   
Theorem 6.2.	 Let s1 be the bit string of concept C1 and s2 be the bit string of concept C2. concept C2 is a sibling concept of concept C1 if and only if s1=s2(1+) or s2=s1(1+), where 1+ is a regular expression representing a sequence of one or more 1. 
Proof.	The proof consists of the following two parts:  
(=>) Since C2 is a sibling concept of C1, there are only sibling concepts between them. In terms of them's bit strings, s1=s2(1+) or s2=s1(1+). 
(<=) Without loss of generality, we just examine the case s1=s2(1+). Since bit 1 represents one sibling concept is passed over and bit 0 represents one time of concept refinement, C2 is a sibling concept of C1.  
Theorem 6.3.	 Let s1 be the bit string of concept C1 and s2 be the bit string of concept C2.  concept C2 is the parent concept of s1 if and only if s1 equals s20(1*), where 1* is a regular expression representing a sequence of zero or more 1. 
Proof.	The proof consists of the following two parts: 
(=>)  Suppose C2 is the parent of C1. If C1 is the first child (or 0th) of C2, then C1 equals s20 which can be easily inferred from the construction pro-cess of RSM schema tree. If C1 is the ith child of C2, then C1 equals s20(1+) where the number of 1 is i. Therefore, C1 equals s20(1*). 
(<=) From the construction process of RSM schema tree, we know 0 rep-resents one time of concept refinement and 1 represents one sibling con-cept is passed over. Therefore, if s1 equals s20(1*), only one time of con-cept refinement occurs. So C2 is the parent of C1.  
Theorem 6.4.	 Let s1 be the bit string of concept C1 and s2 be the bit string of s2. s2 is the ancestor concept of s1 if and only if s20 is the prefix of s1. 
Proof.	The proof consists of the following two parts: 
(=>) If C2 is the parent concept of C1, then C1 equals s20 or s20(1+) by Theorem 6.2. Therefore, s20 is the prefix of C1 in this case. Otherwise, one child C3 of C2 is the ancestor concept of C1. Let s3 be the bit string of one child C3 of C2. From the construction process of RSM schema tree, we know that s20 is the prefix of one child C3 of C2 and that one child C3 of C2 is the prefix of C1. Therefore, s20 is the prefix of C1. 
(<=) If s20 is the prefix of s1, s1 must be at least one time of concept re-finement of C2. Hence C2 is the ancestor concept of s1.  
Since the shortest path between two concepts in the concept tree re-flects the distance between two concepts in the concept tree and two concepts in the concept tree's common ancestor, we define the semantic distance as follows. 
Definition 6.1.	Semantic distance dist(C1, C2) between two concepts C1 and C2 in the same axis X is the length of the shortest path between two concepts C1 and C2 in the multi-way concept tree of X.  
Fig. 6.6 depicts the multi-way concept tree of axis X(C1(C11, C12, C13), C2(C21, C22)).  dist(·, ·) defines the semantic closeness between concepts in the same tree. For example, dist(C12, C21) is 4 since the shortest path from C12 to C21 is C12→C1→X→C2→C21. 
Theorem 6.5.	dist(·, ·) is a metric function. 
Proof.	For any three concepts C1, C2, C3 in axis X, dist(·, ·) satisfies the following properties:  
1.	dist(C1, C2)≥ 0, since the path length is always a non-negative inte-ger. 
2.	dist(C1, C2) = 0 if and only if C1 = C2, since the length of the shortest path is 0 if and only if two concepts actually are the same. 
3.	dist(C1, C2) = dist(C2, C1), since the path between two concepts has no direction. 
4.	dist(C1, C2) + dist(C2, C3)≥dist(C1, C3). Given C1 and C3, C1→C2→C3 is a path from C1 to C3.  a path from C1 to C3 must be no shorter than the shortest path from C1 to C3. Therefore, dist(C1, C2) satisfies the triangle inequali-ty.  
There are two most commonly used bit string operators, notated as fol-lows. 
1.	lcp(s0, s1,..., sk-1) is the longest common prefix of the input bit strings s0, s1,..., and sk-1.  
2.	s.cutTail(s’) represents cutting the bit string s’ from the tail of bit string s. s’ can also be in format of a regular expression.  
Theorem 6.6. Let C be the nearest common ancestor of concepts C0, C1, C2, ..., and Ck-1. s is the bit string of C. si is the bit string of Ci. Then s= lcp(s0, s1,..., sk-1).cutTail(01*) holds. 
Proof.	We first confine k to be 2. Without loss of generality, we consider the case in Fig. 6.7. C is the nearest common ancestor of C0 and C1. C0 precedes C1 in the preorder traverse of RSM schema tree. C’ is the child of C and the ancestor of C0. Let s’ be the bit string of C’. Therefore, s’ is the longest common prefix of C0 and C1, and s’= s0(1*). So s’=s’.cutTail(01*) holds, where  01* is a regular expression representing zero or more 1. So s’=lcp(s0, s1).cutTail(01*) holds. Proof.	We first confine k to be 2. Without loss of generality, we consider the case in Fig. 6.7. C is the nearest common ancestor of C0 and C1. C0 precedes C1 in the preorder traverse of RSM schema tree. C’ is the child of C and the ancestor of C0. Let s’ be the bit string of C’. Therefore, s’ is the longest common prefix of C0 and C1, and s’= s0(1*). So s’=s’.cutTail(01*) holds, where  01* is a regular expression representing zero or more 1. So s’=lcp(s0, s1).cutTail(01*) holds. 
In case of k > 2, let C’ be the child of C and the ancestor of the con-cept Ci. the con-cept Ci is the first concept among C0, C1, C2, ..., and Ck-1 in the pre-order traverse of the RSM schema tree. By the same reasoning, we can conclude s=lcp(s0, s1,..., sk-1).cutTail(01*).  
Theorem 6.7.	 Suppose concept C1 and C2 are in the same axis X. s1 is the bit string of concept C1. s2 is the bit string of C2. C2 is concept C1 and C2's nearest common ancestor in the concept tree of X. s is the bit string of C. Then dist(C1, C2) = zeroCount(s1’) + zeroCount(s2’), where s=lcp(s1, s2), concept C1=ss1’, s2=ss2’, and zeroCount(str) is the number of 0 in the bit string str. 
Proof.	Since bit 0 represents one time of concept refinement, the num-ber of 0 in s1’ is equal to the shortest path between C1 and C, and the number of 0 in s2’ is equal to the shortest path between C1 and C. Since the shortest path between C1 and C is the concatenation of the shortest path between C1 and C C and the shortest path from C to C1, dist(C1, C1) = zero-Count(s1’) + zeroCount(s2’).  
By Theorem 6.7, we can calculate the semantic distance between any two concepts given any two concepts's bit strings. Theorem 6.5 shows that the seman-tic distance function is a metric function.  
According to Theorem 6.1 to 6.4, all hierarchy semantics can be de-termined just according to concepts’ bit strings, which include ancestor-descendant relationship, parent-child relationship, sibling relationship, and concept-in-axis relationship. Therefore, it is enough to only store the bit strings of axes and concepts rather than the schema tree.  File file_schema depicted in Fig. 6.8 is on this purpose.  
Using RSM schema tree, all hierarchy semantics between concepts are encoded into bit strings. By certain rules of computation on given con-cepts’ bit strings, given con-cepts’ bit strings's semantics can be exposed. RSM schema tree plays the role of interface between the above logical resource space and the underlying physical storage space which is a multidimensional bit string space.  
One remaining problem in RSM schema tree is that a bit string may be extremely long even up to a linear order of the number of axis concepts. It is mainly caused by the magnitude of the number of sibling nodes. As known to us, the number of concept refinements is rather small in appli-cations, say, less than 32 levels, which is confined by people’s recogni-tion ability. Hence the depth of concept hierarchy tree is limited in appli-cations. However, the number of a concept’s children can be quite large. For example, there are 193 countries in the world. In RSM schema tree, it requires 192 consecutive “1” bits appended to the bit string of concept world to represent the last country.  
We propose a compressed encoding method to set an upper bound for the length of concepts’ bit strings. a compressed encoding method to set an upper bound for the length of concepts’ bit strings works as follows. Given a bit string, retrieve the first 7 bits. If a bit string contains at least one 0, pack a bit string with a byte by setting the first bit as 1. Otherwise, read more bits until 0 appears or the number of 1 bit adds up to 120. In either case, pack the number of count-ed 1 bits with a byte by setting the first bit as 0. Proceed with the above process until the residual bit number is no more than seven. Some pack-ing bits are necessary when the residual bit number is less than seven.  
Take the bit string 1101011－1111111－1111111－1110111－0101 in format of 7-bit segments as an example. The first 7-bit segment is packed in byte 11101011. Since The first 7-bit segment comprises seven 1, more bits are consumed until 0 appears. The counted number of 1 bit is 17 whose binary value is 00010001 which is treated as the second packing byte. The next 7-bit segment is 0111010. The next 7-bit segment is packed in byte 10111010. Now the residual bits are a single 1. We append successive 000000 to align successive 000000's length with seven. Then we set the first bit of successive 000000's packing byte as 1. So we get the third packing byte 11000000. At last, we append one more byte which records the length of the residual bits at the previous step. one more byte which records the length of the residual bits at the previous step's first bit is set as 0. Therefore, the final byte sequence is 11101011－00010001－10111010－11000000－00000001.  More 1 bits does the original bit string have, more efficiency is our compressed en-coding approach. Algorithm compressCode describes the above ap-proach in detail.   Take the bit string 1101011－1111111－1111111－1110111－0101 in format of 7-bit segments as an example. The first 7-bit segment is packed in byte 11101011. Since The first 7-bit segment comprises seven 1, more bits are consumed until 0 appears. The counted number of 1 bit is 17 whose binary value is 00010001 which is treated as the second packing byte. The next 7-bit segment is 0111010. The next 7-bit segment is packed in byte 10111010. Now the residual bits are a single 1. We append successive 000000 to align successive 000000's length with seven. Then we set the first bit of successive 000000's packing byte as 1. So we get the third packing byte 11000000. At last, we append one more byte which records the length of the residual bits at the previous step. one more byte which records the length of the residual bits at the previous step's first bit is set as 0. Therefore, the final byte sequence is 11101011－00010001－10111010－11000000－00000001.  More 1 bits does the original bit string have, more efficiency is our compressed en-coding approach. Algorithm compressCode describes the above ap-proach in detail.   
The following theorem gives an estimation of the byte number after compression.  
Theorem 6.8.	 Assume the depth of concept hierarchy is at most D and the maximal number of any concept’s children is at most 127c, where c is a constant. Then, the number of bytes after compression is at most D(1+c). 
Proof.	One time of concept refinement incurs one 0 bit, so one byte needs to preserve this information during bit string compression. Since the maximal number of child of any concept is 127c at most, c bytes are enough to represent all 1 bits incurred by sibling concepts of the same parent concept. Therefore, 1+c bytes are enough to go down one level in the axis’s concept tree. Because the concept hierarchy depth is D at most, the byte number after compression is D(1+c) at most.  
It is easy to decode a compressed bit string to the original. Each time decode one byte. Examine the first bit of one byte. If the first bit of the byte is 1, the left seven bits belongs to the original bit string. If the first bit of the byte is 0, recover a number of 1 bits which is equal to the value of one byte. The above process is carried out until only two bytes are left. The value of the second one is the number of packing bits in the first bit of the byte. So it is also convenient to recover the original information. In fact, we do not need to fully recover all the in-formation since most of the time we just compare or do partial calcula-tion upon their bit strings.  