Contents Preface vii PART		sequential	A Database Systems	1-1
A Database Systems		sequential	The Main Principles Functionalities Complexity	1-1
The Main Principles Functionalities Complexity	and	conjunctive	Diversity Past	1-1
Diversity Past	and	conjunctive	Future Ties	1-1
Future Ties	with	constraint	This Book Bibliographic Notes	1-1
This Book Bibliographic Notes		sequential	Theoretical Background Some Basics Languages	1-1
Theoretical Background Some Basics Languages		sequential	Computability	1-1
Computability	and	conjunctive	Complexity Basics	1-1
Complexity Basics	from	constraint	Logic	1-1
Logic		sequential	The Relational Model	1-1
The Relational Model		sequential	The Structure	1-1
The Structure	of	constraint	the Relational Model	1-1
the Relational Model	versus	constraint	Unnamed Perspectives Conventional	1-1
the Relational Model	Named	action	Unnamed Perspectives Conventional	1-1
Unnamed Perspectives Conventional	versus	constraint	Logic Programming Perspectives	1-1
Logic Programming Perspectives		sequential	Notation Bibliographic Notes xiii	1-1
xiv Contents PART B BASICS		sequential	RELATIONAL QUERY LANGUAGES	2-1
Contents		sequential	The Chase Bibliographic Notes Exercises Inclusion Dependency Inclusion Dependency	3-1
The Chase Bibliographic Notes Exercises Inclusion Dependency Inclusion Dependency	in	constraint	Isolation Finite	3-1
Isolation Finite	versus	constraint	Infinite Implication Nonaxiomatizability	3-1
Infinite Implication Nonaxiomatizability	of	constraint	fd	3-1
fd		sequential	s	3-1
s	+	sequential	ind	3-1
ind		sequential	Restricted Kinds The Chase Revisited Bibliographic Notes	3-1
Restricted Kinds The Chase Revisited Bibliographic Notes	of	constraint	Inclusion Dependency Bibliographic Notes Exercises	3-1
Inclusion Dependency Bibliographic Notes Exercises		sequential	Exercises Design	3-1
Exercises Design	and	conjunctive	Dependencies	3-1
Dependencies		sequential	Semantic Data Models	3-1
Semantic Data Models		sequential	Normal Forms Universal Relation Assumption Bibliographic Notes Exercises PART D DATALOG	3-1
Normal Forms Universal Relation Assumption Bibliographic Notes Exercises PART D DATALOG	AND	conjunctive	RECURSION Datalog Syntax	3-1
RECURSION Datalog Syntax	of	constraint	Datalog Model	3-1
Datalog Model		sequential	Theoretic Semantics	3-1
Theoretic Semantics		sequential	Fixpoint Semantics	3-1
Fixpoint Semantics		sequential	Proof	3-1
Proof		sequential	Theoretic Approach	3-1
Theoretic Approach		sequential	Static Program Analysis	3-1
Static Program Analysis		sequential	Bibliographic Notes Exercises Evaluation Datalog Seminaive Evaluation	3-1
Bibliographic Notes Exercises Evaluation Datalog Seminaive Evaluation	of	constraint	Top -Down Techniques Magic	3-1
xvi Contents		sequential	Two Improvements Bibliographic Notes Exercises	4-1
Two Improvements Bibliographic Notes Exercises		sequential	Recursion	4-1
Recursion	and	conjunctive	Negation Calculus	4-1
Negation Calculus	+	sequential	Fixpoint Datalog	4-1
Fixpoint Datalog	with	constraint	Negation Equivalence Recursion	4-1
Negation Equivalence Recursion	in	constraint	Practical Languages	4-1
Practical Languages		sequential	Bibliographic Notes	4-1
Bibliographic Notes		sequential	Exercises Negation	4-1
Exercises Negation	in	constraint	Datalog	4-1
Datalog	Well Founded	action	The Basic Problem Stratified Semantics Semantics Expressive Power Negation	4-1
The Basic Problem Stratified Semantics Semantics Expressive Power Negation	as	constraint	Failure	4-1
Failure	in	constraint	Brief Bibliographic Notes Exercises PART E EXPRESSIVENESS	4-1
Brief Bibliographic Notes Exercises PART E EXPRESSIVENESS	AND	conjunctive	COMPLEXITY	4-1
Contents xvii Whileuty		sequential	An Untyped Extension PART F FINALE	5-1
An Untyped Extension PART F FINALE	of	constraint	Bibliographic Notes Exercises	5-1
An Untyped Extension PART F FINALE	while	constraint	Bibliographic Notes Exercises	5-1
Bibliographic Notes Exercises		sequential	Incomplete Information Warm	5-1
Incomplete Information Warm	Up	constraint	Weak Representation Systems Conditional Tables	5-1
Weak Representation Systems Conditional Tables		sequential	The Complexity	5-1
The Complexity	of	constraint	Nulls Other Approaches	5-1
Nulls Other Approaches		sequential	Bibliographic Notes Exercises Complex Values Complex Value Databases The Algebra The Calculus Examples Equivalence	5-1
Bibliographic Notes Exercises Complex Values Complex Value Databases The Algebra The Calculus Examples Equivalence		sequential	Theorems	5-1
Theorems		sequential	Fixpoint	5-1
Fixpoint	and	conjunctive	Deduction	5-1
Deduction		sequential	Expressive Power	5-1
Expressive Power	and	conjunctive	Complexity	5-1
Complexity		sequential	Notes	5-1
Notes		sequential	Exercises Object Databases Informal Presentation Formal Definition	5-1
Exercises Object Databases Informal Presentation Formal Definition	of	constraint	an OODB Model Languages	5-1
an OODB Model Languages	for	constraint	OODB Queries Languages	5-1
OODB Queries Languages	for	constraint	Methods	5-1
Methods		sequential	Further Issues	5-1
Further Issues	for	constraint	OODBs Bibliographic Notes Exercises Dynamic Aspects Update Languages	5-1
OODBs Bibliographic Notes Exercises Dynamic Aspects Update Languages		sequential	Transactional Schemas Updating Views	5-1
Transactional Schemas Updating Views	and	conjunctive	Databases	5-1
Databases	Updating	action	Incomplete Information	5-1
xviii Contents Exercises Bibliography Symbol Index Index		sequential	Databases	6-1
Databases	and	conjunctive	Constraints	6-1
Constraints		sequential	Temporal Bibliographic Notes	6-1
I	thought	attribute	this	7-1
I	was	attribute	a theory book	7-1
Vittorio	but	conjunctive	good theory	8-1
good theory	needs	action	the big picture	8-1
Sergio		sequential	what	9-1
what		sequential	you	9-1
you	Besides will tell	action	your grandfather	9-1
your grandfather		sequential	he	9-1
he	when asks	action	what	9-1
what		sequential	you	9-1
you	study	action	<B>	9-1
Riccardo		sequential	Riccardo	10-1
Computers	in	constraint	almost all aspects	11-1
Computers	are now used	action	almost all aspects	11-1
almost all aspects	of	constraint	human activity	11-1
One	of	constraint	their main uses	11-2
their main uses	to	constraint	information	11-2
their main uses	is	attribute	information	11-2
their main uses	manage	action	information	11-2
information		sequential	which	11-2
which	in	constraint	some cases	11-2
some cases	involves	action	data	11-2
some cases	simply holding	action	data	11-2
data	for	constraint	future retrieval	11-2
future retrieval	in	constraint	other cases	11-2
future retrieval	and	conjunctive	other cases	11-2
other cases	as	constraint	the backbone	11-2
other cases	serving	action	the backbone	11-2
the backbone	for	constraint	the life cycle	11-2
the backbone	managing	action	the life cycle	11-2
the life cycle	of	constraint	engineering	11-2
the life cycle	or	conjunctive	engineering	11-2
engineering		sequential	complex processes	11-2
A large amount	of	constraint	data	11-3
data	in	constraint	a computer	11-3
data	stored	action	a computer	11-3
a computer	is called	action	a database	11-3
The basic software		sequential	that	11-4
that	supports	action	the management	11-4
the management	of	constraint	this data	11-4
this data	is called	action	a database management system	11-4
a database management system		sequential	dbms	11-4
The dbms	by	constraint	a body	11-5
The dbms	and	conjunctive	a body	11-5
The dbms	is typically accompanied	attribute	large	11-5
a body	of	constraint	application software	11-5
application software		sequential	that	11-5
that	and	conjunctive	the stored information	11-5
that	accesses	action	the stored information	11-5
that	modifies	action	the stored information	11-5
The primary focus	in	constraint	this book	11-6
this book	to	constraint	part	11-6
this book	is	attribute	part	11-6
this book	present	action	part	11-6
part	of	constraint	the theory	11-6
the theory	underlying	action	the design	11-6
the design	and	conjunctive	use	11-6
use	of	constraint	these systems	11-6
This preliminary chapter	briefly reviews	action	the field	11-7
the field	of	constraint	database systems	11-7
database systems	to	constraint	the larger context	11-7
database systems	indicate	action	the larger context	11-7
the larger context		sequential	that	11-7
that	to	constraint	this theory	11-7
that	has led	action	this theory	11-7
The Main Principles Database systems	as	constraint	mediators	12-1
The Main Principles Database systems	can be viewed	action	mediators	12-1
mediators	between	constraint	human beings	12-1
human beings		sequential	who	12-1
who	to	constraint	data	12-1
who	want	action	data	12-1
who	use	action	data	12-1
data	and	conjunctive	physical devices	12-1
physical devices		sequential	that	12-1
that	hold	action	it	12-1
it	see	action	Fig	12-1
<B>		sequential	<B>	12-2
Early database management	on	constraint	explicit usage	12-3
Early database management	was based	action	explicit usage	12-3
explicit usage	of	constraint	file systems	12-3
file systems	and	conjunctive	customized application software	12-3
<B>		sequential	principles	12-4
principles	and	conjunctive	mechanisms	12-4
mechanisms	were developed	action	that	12-4
that	insulated	action	database users	12-4
database users	from	constraint	the details	12-4
the details	of	constraint	the physical implementation	12-4
<B>	In	constraint	the late 1960s	12-5
the late 1960s		sequential	the first major step	12-5
the first major step	in	constraint	this direction	12-5
this direction	was	attribute	the development	12-5
the development	of	constraint	three level	12-5
three level		sequential	architecture	12-5
This architecture	separated	action	database functionalities	12-6
database functionalities	into	constraint	levels	12-6
database functionalities	and	conjunctive	levels	12-6
<B>	See	action	Fig	12-7
1.2		sequential	1.2	12-8
The three views	represent	action	various ways	12-9
various ways	of	constraint	the database	12-9
various ways	at	constraint	the database	12-9
various ways	looking	action	the database	12-9
the database		sequential	multirelations	12-9
multirelations		sequential	universal relation interface	12-9
universal relation interface	and	conjunctive	graphical interface	12-9
The separation	of	constraint	the logical definition	13-1
the logical definition	of	constraint	data	13-1
data	from	constraint	its physical implementation	13-1
its physical implementation	to	constraint	the field	13-1
its physical implementation	is	attribute	central	13-1
the field	of	constraint	databases	13-1
One	of	constraint	the major research directions	13-2
the major research directions	in	constraint	the field	13-2
the field	been	action	has the development	13-2
has the development	and	conjunctive	study	13-2
study	of	constraint	abstract models	13-2
study	oriented	action	abstract models	13-2
abstract models	and	conjunctive	interfaces	13-2
interfaces	for	constraint	the structure	13-2
interfaces	specifying	action	the structure	13-2
the structure	of	constraint	stored data	13-2
stored data	for	constraint	it	13-2
stored data	and	conjunctive	it	13-2
stored data	manipulating	action	it	13-2
These models	permit	action	the user	13-3
the user	to	constraint	a logical representation	13-3
the user	on	constraint	a logical representation	13-3
the user	concentrate	action	a logical representation	13-3
a logical representation	of	constraint	data	13-3
data		sequential	that	13-3
that	or	conjunctive	vision	13-3
that	resembles	attribute	his	13-3
vision	of	constraint	the reality	13-3
the reality	by	constraint	the data	13-3
the reality	modeled	action	the data	13-3
the data	than	constraint	the physical representation	13-3
Database Systems DBMS		sequential	Database Systems DBMS	14-1
<B>	include	action	primarily a data definition language	14-2
primarily a data definition language		sequential	DDL	14-2
DDL	for	constraint	the structural aspects	14-2
DDL	specifying	action	the structural aspects	14-2
the structural aspects	of	constraint	the data	14-2
the data	and	conjunctive	a data manipulation language	14-2
a data manipulation language		sequential	DML	14-2
DML	for	constraint	it	14-2
DML	and	conjunctive	it	14-2
DML	accessing	action	it	14-2
DML	updating	action	it	14-2
The separation	of	constraint	the logical	14-3
the logical	from	constraint	the physical	14-3
the physical	in	constraint	an extraordinary increase	14-3
the physical	has resulted	action	an extraordinary increase	14-3
an extraordinary increase	in	constraint	database usability	14-3
database usability	and	conjunctive	programmer productivity	14-3
The separation	of	constraint	the levels	15-1
The separation	and	conjunctive	the levels	15-1
the levels	of	constraint	a database system	15-1
a database system	is usually called	action	the data independence principle	15-1
<B>	is	attribute	arguably the most important distinction	15-2
arguably the most important distinction	between	constraint	file systems	15-2
file systems	and	conjunctive	database systems	15-2
The second separation	in	constraint	the architecture	16-1
the architecture	between	constraint	levels	16-1
the architecture	and	conjunctive	levels	16-1
levels	is	attribute	also important	16-1
It	permits	action	different perspectives	16-2
different perspectives	or	conjunctive	views	16-2
views	on	constraint	the database	16-2
the database		sequential	that	16-2
that	to	constraint	specific needs	16-2
that	are tailored	action	specific needs	16-2
Views	hide	action	irrelevant information	16-3
irrelevant information	and	conjunctive	data	16-3
irrelevant information	restructure	action	data	16-3
data		sequential	that	16-3
that	is retained	action	<B>	16-3
Such views	as	constraint	the case	16-4
Such views	in	constraint	the case	16-4
Such views	be	attribute	may simple	16-4
the case	of	constraint	automatic teller machines	16-4
automatic teller machines	as	constraint	the case	16-4
automatic teller machines	in	constraint	the case	16-4
automatic teller machines	or	conjunctive	the case	16-4
the case	of	constraint	computer	16-4
computer	aided	action	design systems	16-4
External Level View		sequential	1 View 2	17-1
1 View 2		sequential	View	17-1
View		sequential	3 Logical Level Physical Level	17-1
3 Logical Level Physical Level		sequential	Figure	17-1
Figure		sequential	1.2	17-1
1.2		sequential	Three level	17-1
Three level		sequential	architecture	17-1
architecture	of	constraint	database systems	17-1
database systems		sequential	Functionalities Modern dbms	17-1
Functionalities Modern dbms	include	action	a broad array	17-1
a broad array	of	constraint	functionalities	17-1
functionalities	from	constraint	<B>	17-1
functionalities	to	constraint	<B>	17-1
functionalities	ranging	attribute	the very physical	17-1
Some functionalities		sequential	database recovery	17-2
database recovery	by	constraint	almost all users	17-2
database recovery	can largely be ignored	action	almost all users	17-2
Others	among	constraint	even the most physical ones	17-3
even the most physical ones		sequential	indexing	17-3
indexing	to	constraint	application programmers	17-3
indexing	are presented	action	application programmers	17-3
application programmers	in	constraint	abstracted ways	17-3
The primary functionalities	of	constraint	dbms	18-1
dbms	as	constraint	<B>	18-1
dbms	are	attribute	<B>	18-1
dbms	follows	action	<B>	18-1
<B>	By	constraint	we	18-2
we	that	constraint	the data	18-2
we	mean	action	the data	18-2
the data	to	constraint	main memory	18-2
the data	in	constraint	main memory	18-2
the data	is	attribute	too big	18-2
the data	fit	action	main memory	18-2
an essential task	of	constraint	these systems	18-3
these systems	is	attribute	Thus the management	18-3
Thus the management	of	constraint	secondary storage	18-3
secondary storage		sequential	which	18-3
which	involves	action	an array	18-3
an array	of	constraint	techniques	18-3
techniques		sequential	indexing	18-3
indexing		sequential	clustering	18-3
clustering	and	conjunctive	resource	18-3
resource		sequential	allocation	18-3
Persistence		sequential	Data	19-1
Data	be	attribute	should persistent	19-1
it	should survive	action	the termination	19-1
the termination	of	constraint	a particular database application	19-1
a particular database application	so that	constraint	it	19-1
it	may be reused later	action	<B>	19-1
<B>	is	attribute	a clear divergence	19-2
a clear divergence	from	constraint	standard programming	19-2
standard programming	in	constraint	which	19-2
which		sequential	a data structure	19-2
a data structure	in	constraint	a file	19-2
a data structure	must be coded	action	a file	19-2
a file	to	constraint	the execution	19-2
a file	beyond	constraint	the execution	19-2
a file	live	action	the execution	19-2
the execution	of	constraint	an application	19-2
Persistent programming languages		sequential	persistent C++	19-3
persistent C++	to	constraint	this limitation	19-3
persistent C++	are now emerging	action	this limitation	19-3
persistent C++	overcome	action	this limitation	19-3
this limitation	of	constraint	programming languages	19-3
Database Systems Concurrency control		sequential	Data	20-1
Data	is shared	action	<B>	20-1
The system	must support	action	simultaneous access	20-2
simultaneous access	to	constraint	shared information	20-2
shared information	in	constraint	a harmonious environment	20-2
a harmonious environment		sequential	that	20-2
that	controls	action	access conflicts	20-2
access conflicts	and	conjunctive	a coherent database state	20-2
access conflicts	presents	action	a coherent database state	20-2
a coherent database state	to	constraint	each user	20-2
<B>	to	constraint	important notions	20-3
<B>	has led	action	important notions	20-3
important notions		sequential	transaction	20-3
transaction	and	conjunctive	serializability	20-3
serializability	to	constraint	techniques	20-3
serializability	and	conjunctive	techniques	20-3
techniques		sequential	two phase	20-3
two phase		sequential	locking	20-3
locking		sequential	that	20-3
that	ensure	action	serializability	20-3
Data protection		sequential	Data protection	21-1
Integrity checking mechanisms	on	constraint	inconsistencies	21-2
Integrity checking mechanisms	focus	action	inconsistencies	21-2
Integrity checking mechanisms	preventing	action	inconsistencies	21-2
inconsistencies	in	constraint	the stored data	21-2
the stored data	for	constraint	example	21-2
the stored data	resulting	action	example	21-2
example	from	constraint	faulty update requests	21-2
Database recovery	and	conjunctive	back	21-3
back	up	constraint	protocols	21-3
protocols	against	constraint	hardware failures	21-3
protocols	guard	action	hardware failures	21-3
hardware failures	by	constraint	snapshots	21-3
hardware failures	primarily maintaining	action	snapshots	21-3
snapshots	of	constraint	previous database states	21-3
previous database states	and	conjunctive	logs	21-3
logs	of	constraint	transactions	21-3
transactions	in	constraint	progress	21-3
security control mechanisms	Finally prevent	action	classes	21-4
classes	of	constraint	users	21-4
users	from	constraint	sensitive information	21-4
users	and	conjunctive	sensitive information	21-4
users	or	conjunctive	sensitive information	21-4
users	accessing	action	sensitive information	21-4
users	changing	action	sensitive information	21-4
Human machine		sequential	interface	22-1
<B>	encompasses	action	DDLs	22-2
DDLs	and	conjunctive	DMLs	22-2
DMLs	both	conjunctive	a traditional linear format	22-2
DMLs	including	attribute	those	22-2
DMLs	having	action	a traditional linear format	22-2
a traditional linear format	and	conjunctive	the emerging visual interfaces	22-2
the emerging visual interfaces	in	constraint	fourth generation	22-2
the emerging visual interfaces	incorporated	action	fourth generation	22-2
the emerging visual interfaces	so called	action	fourth generation	22-2
fourth generation		sequential	languages	22-2
Graphically based tools	for	constraint	database installation	22-3
database installation	and	conjunctive	design	22-3
design	are	attribute	popular	22-3
Distribution		sequential	Distribution	23-1
<B>	within	constraint	Even a local enterprise	23-2
Even a local enterprise		sequential	it	23-2
it	to	constraint	interrelated information	23-2
it	is	attribute	common	23-2
it	find	action	interrelated information	23-2
interrelated information	across	constraint	several databases	23-2
interrelated information	spread	action	several databases	23-2
several databases	for	constraint	historical reasons	23-2
several databases	either	conjunctive	historical reasons	23-2
historical reasons	to	constraint	each database	23-2
historical reasons	or	conjunctive	each database	23-2
historical reasons	keep	action	each database	23-2
each database	within	constraint	manageable size	23-2
These databases	by	constraint	different systems	23-3
These databases	may be supported	action	different systems	23-3
different systems		sequential	interoperability	23-3
interoperability	on	constraint	distinct models	23-3
interoperability	and	conjunctive	distinct models	23-3
interoperability	based	action	distinct models	23-3
distinct models		sequential	heterogeneity	23-3
The task	of	constraint	transparent access	23-4
The task	providing	action	transparent access	23-4
transparent access	to	constraint	multiple systems	23-4
multiple systems	is	attribute	a major research topic	23-4
a major research topic	of	constraint	the 1990s	23-4
Compilation	and	conjunctive	optimization	24-1
<B>	or	conjunctive	one compilation steps	24-2
<B>	usually involves	attribute	more	24-2
one compilation steps	and	conjunctive	intensive optimization	24-2
intensive optimization	so that	constraint	performance	24-2
performance	by	constraint	the convenience	24-2
performance	is not degraded	action	the convenience	24-2
the convenience	of	constraint	more friendly interfaces	24-2
the convenience	using	action	more friendly interfaces	24-2
<B>	of	constraint	these features	25-1
these features	concern	action	primarily the physical data level	25-1
primarily the physical data level		sequential	concurrency control	25-1
concurrency control		sequential	recovery	25-1
recovery	and	conjunctive	secondary storage management	25-1
Others		sequential	optimization	25-2
optimization	across	constraint	the three levels	25-2
optimization	are spread	action	the three levels	25-2
Database theory	and	conjunctive	database models	26-1
database models	on	constraint	primarily the description	26-1
database models	have focused	action	primarily the description	26-1
primarily the description	of	constraint	data	26-1
data	on	constraint	querying facilities	26-1
data	and	conjunctive	querying facilities	26-1
The support	for	constraint	application software	26-2
The support	designing	action	application software	26-2
application software		sequential	which	26-2
which	often constitutes	action	a large component	26-2
a large component	of	constraint	databases	26-2
databases	in	constraint	the field	26-2
the field	by	constraint	the database research community	26-2
the field	has generally been overlooked	action	the database research community	26-2
<B>	In	constraint	relational systems applications	26-3
relational systems applications	in	constraint	C	26-3
relational systems applications	can be written	action	C	26-3
C	with	constraint	embedded SQL	26-3
C	and	conjunctive	embedded SQL	26-3
C	extended	action	embedded SQL	26-3
embedded SQL		sequential	the standard relational query language	26-3
the standard relational query language		sequential	commands	26-3
commands	for	constraint	the database	26-3
commands	accessing	action	the database	26-3
there	Unfortunately is	action	a significant distance	26-4
a significant distance	between	constraint	the paradigms	26-4
the paradigms	of	constraint	C	26-4
C	and	conjunctive	SQL	26-4
<B>	to	constraint	a certain extent	26-5
<B>	can be said	action	a certain extent	26-5
a certain extent	about	constraint	fourth generation	26-5
fourth generation		sequential	languages	26-5
Modern approaches	to	constraint	application programmer productivity	26-6
Modern approaches	improving	action	application programmer productivity	26-6
application programmer productivity	or	conjunctive	databases	26-6
application programmer productivity	object oriented	attribute	active	26-6
databases	are being investigated	action	<B>	26-6
Complexity	and	conjunctive	Diversity	27-1
Examples	of	constraint	this variety	27-2
this variety	include	attribute	the following	27-2
Users		sequential	Application programmers	28-1
Application programmers	and	conjunctive	software	28-1
software		sequential	customer service representatives	28-1
customer service representatives		sequential	secre-taries	28-1
secre-taries		sequential	database administrators	28-1
database administrators		sequential	computer gurus	28-1
computer gurus		sequential	other databases	28-1
other databases		sequential	expert systems	28-1
expert systems		sequential	<B>	28-1
Logical models		sequential	Logical models	29-1
Platforms		sequential	Variations	30-1
Variations	in	constraint	host programming languages	30-1
host programming languages		sequential	computing hardware	30-1
computing hardware	and	conjunctive	operating systems	30-1
operating systems		sequential	secondary storage devices	30-1
secondary storage devices	including	action	conventional disks	30-1
conventional disks		sequential	optical disks	30-1
optical disks		sequential	tape	30-1
tape		sequential	networks	30-1
networks		sequential	<B>	30-1
<B>	Both	conjunctive	the quality	31-1
the quality	and	conjunctive	quantity	31-1
quantity	of	constraint	variety	31-1
variety	compounds	action	the complexity	31-1
the complexity	of	constraint	modern dbms	31-1
modern dbms		sequential	which	31-1
which	to	constraint	diversity	31-1
which	attempt	attribute	as much	31-1
which	support	attribute	as much	31-1
diversity	as	constraint	<B>	31-1
<B>	and	conjunctive	Future	32-1
<B>	provide	action	some logical organization	33-1
some logical organization	of	constraint	data	33-1
data	in	constraint	graphs	33-1
graphs	and	conjunctive	trees	33-1
trees	but	conjunctive	these representations	33-1
these representations	closely mirror	action	the physical storage	33-1
the physical storage	of	constraint	the data	33-1
the DMLs	for	constraint	they	33-2
the DMLs	because	constraint	they	33-2
the DMLs	are	attribute	Furthermore primitive	33-2
they	on	constraint	primarily navigation	33-2
they	focus	action	primarily navigation	33-2
primarily navigation	through	constraint	the physically stored data	33-2
<B>	In	constraint	the 1970s	34-1
the 1970s		sequential	Codd	34-1
Codd		sequential	relational model	34-1
relational model	revolutionized	action	the field	34-1
<B>	In	constraint	this model	34-2
this model		sequential	humans	34-2
humans	view	action	the data	34-2
the data	as	constraint	relations	34-2
the data	in	constraint	relations	34-2
the data	organized	action	relations	34-2
relations		sequential	tables	34-2
tables	and	conjunctive	more languages	34-2
more languages	for	constraint	data access	34-2
more languages	are provided	action	data access	34-2
Indexes	and	conjunctive	other mechanisms	34-3
other mechanisms	for	constraint	the interconnection	34-3
other mechanisms	maintaining	action	the interconnection	34-3
the interconnection	between	constraint	data	34-3
data	from	constraint	users	34-3
data	are largely hidden	action	users	34-3
The approach	as	constraint	implementation	34-4
The approach	became	action	implementation	34-4
The approach	increasingly accepted	action	implementation	34-4
implementation	and	conjunctive	optimization	34-4
optimization		sequential	techniques	34-4
techniques	could provide	action	reasonable response times	34-4
reasonable response times	in	constraint	spite	34-4
spite	of	constraint	the distance	34-4
the distance	between	constraint	data organization	34-4
the distance	and	conjunctive	data organization	34-4
The relational model	also provided	action	the initial basis	34-5
the initial basis	for	constraint	the development	34-5
the development	of	constraint	a mathematical investigation	34-5
a mathematical investigation	of	constraint	databases	34-5
databases	because	constraint	it	34-5
it	largely bridges	action	the gap	34-5
the gap	between	constraint	data modeling	34-5
data modeling	and	conjunctive	mathematical logic	34-5
Database Systems		sequential	Historically dbms	35-1
Historically dbms		sequential	s	35-1
s	toward	constraint	business applications	35-1
s	were biased	action	business applications	35-1
business applications	and	conjunctive	the relational model	35-1
the relational model	best fitted	action	the needs	35-1
<B>		sequential	the requirements	35-2
the requirements	for	constraint	the management	35-2
the management	of	constraint	large shared amounts	35-2
large shared amounts	of	constraint	data	35-2
data	in	constraint	a variety	35-2
data	were also felt	action	a variety	35-2
a variety	of	constraint	fields	35-2
fields		sequential	computer	35-2
computer	aided	action	design	35-2
design	and	conjunctive	expert systems	35-2
These new applications	in	constraint	terms	35-3
These new applications	require	attribute	more	35-3
terms	of	constraint	structures	35-3
structures	than	constraint	relations	35-3
relations		sequential	control	35-3
control		sequential	more dynamic environments	35-3
more dynamic environments	and	conjunctive	intelligence	35-3
intelligence		sequential	incorporation	35-3
incorporation	of	constraint	knowledge	35-3
They	have generated	action	research	35-4
research	and	conjunctive	developments	35-4
developments	at	constraint	the border	35-4
the border	of	constraint	other fields	35-4
the most important developments	are	attribute	Object	36-1
Object	oriented	action	Perhaps the following databases	36-1
<B>	In	constraint	addition	37-1
addition	to	constraint	richer logical data structures	37-1
addition	providing	action	richer logical data structures	37-1
richer logical data structures		sequential	they	37-1
they	permit	action	the incorporation	37-1
the incorporation	of	constraint	behavioral information	37-1
behavioral information	into	constraint	the database schema	37-1
<B>	to	constraint	better interfaces	37-2
<B>	leads	action	better interfaces	37-2
better interfaces	and	conjunctive	a more modular perspective	37-2
a more modular perspective	on	constraint	application software	37-2
application software	in	constraint	it	37-2
application software	and	conjunctive	it	37-2
it	improves	action	the programmer	37-2
the programmer		sequential	productivity	37-2
<B>	and	conjunctive	databases	38-1
The hope	to	constraint	mechanisms	38-2
The hope	is	attribute	mechanisms	38-2
The hope	provide	action	mechanisms	38-2
mechanisms		sequential	that	38-2
that	support	action	an abstract view	38-2
an abstract view	of	constraint	some aspects	38-2
some aspects	of	constraint	information processing	38-2
information processing	to	constraint	the abstract view	38-2
the abstract view	of	constraint	data	38-2
data	by	constraint	logical data models	38-2
data	provided	action	logical data models	38-2
This processing	in	constraint	the form	38-3
This processing	is generally represented	action	the form	38-3
the form	of	constraint	rules	38-3
rules	from	constraint	the control mechanism	38-3
rules	and	conjunctive	the control mechanism	38-3
rules	separated	action	the control mechanism	38-3
the control mechanism	for	constraint	the rules	38-3
the control mechanism	used	action	the rules	38-3
the control mechanism	applying	action	the rules	38-3
These two directions	are	attribute	catalysts	39-1
catalysts	for	constraint	significant new developments	39-1
significant new developments	in	constraint	the database field	39-1
Ties	with	constraint	This Book	40-1
The principal one		sequential	which	40-2
which	is	attribute	the focus	40-2
the focus	of	constraint	this book	40-2
this book	concerns	action	those topics	40-2
those topics		sequential	that	40-2
that	within	constraint	the layers	40-2
that	and	conjunctive	the layers	40-2
that	can meaningfully be discussed	attribute	logical	40-2
<B>		sequential	which	40-3
which	has	action	a different flavor	40-3
a different flavor	in	constraint	this book	40-3
a different flavor	and	conjunctive	this book	40-3
a different flavor	is not discussed	action	this book	40-3
this book	is	attribute	the elegant theory	40-3
the elegant theory	of	constraint	concurrency control	40-3
The majority	of	constraint	this book	41-1
this book	to	constraint	the study	41-1
this book	is devoted	action	the study	41-1
the study	of	constraint	the relational model	41-1
<B>	In	constraint	relational query languages	41-2
relational query languages	and	conjunctive	language primitives	41-2
language primitives		sequential	recursion	41-2
recursion	in	constraint	depth	41-2
recursion	are studied	action	depth	41-2
The theory	of	constraint	dependencies	42-1
dependencies		sequential	which	42-1
which	provides	action	the formal foundation	42-1
the formal foundation	of	constraint	integrity constraints	42-1
integrity constraints	is also covered	action	<B>	42-1
<B>	In	constraint	the last part	42-2
the last part	of	constraint	the book	42-2
the book		sequential	we	42-2
we	consider	action	more recent topics	42-2
more recent topics		sequential	whose theory	42-2
whose theory	is generally less well developed	action	object	42-2
whose theory	including	action	object	42-2
object	oriented	action	databases	42-2
databases	and	conjunctive	behavioral aspects	42-2
behavioral aspects	of	constraint	databases	42-2
<B>	By	constraint	its nature	43-1
its nature		sequential	theoretical investigation	43-1
theoretical investigation	requires	action	the careful articulation	43-1
the careful articulation	of	constraint	all assumptions	43-1
<B>	to	constraint	a focus	43-2
<B>	leads	action	a focus	43-2
a focus	on	constraint	abstract simplified models	43-2
abstract simplified models	of	constraint	much more complex practical situations	43-2
<B>	For	constraint	example	43-3
example		sequential	one focus	43-3
one focus	in	constraint	the early part	43-3
the early part	of	constraint	this book	43-3
this book	on	constraint	conjunctive queries	43-3
this book	is	attribute	conjunctive queries	43-3
<B>	form	action	the core	44-1
the core	of	constraint	select	44-1
select	from	constraint	the clause	44-1
the clause	of	constraint	the standard language	44-1
the standard language	in	constraint	database systems	44-1
database systems		sequential	SQL	44-1
SQL	and	conjunctive	perhaps the most important class	44-1
SQL	are	attribute	perhaps the most important class	44-1
perhaps the most important class	of	constraint	queries	44-1
queries	from	constraint	a practical standpoint	44-1
the conjunctive queries	However ignore	action	important practical components	44-2
important practical components	of	constraint	SQL	44-2
SQL		sequential	arithmetic operations	44-2
<B>	Speaking more generally	action	database theory	45-1
database theory	on	constraint	specific areas	45-1
database theory	has focused rather narrowly	action	specific areas	45-1
specific areas		sequential	that	45-1
that	to	constraint	theoretical investigation	45-1
that	are	attribute	amenable	45-1
Considerable effort	toward	constraint	the expressive power	45-2
Considerable effort	has been directed	action	the expressive power	45-2
the expressive power	and	conjunctive	complexity	45-2
complexity	of	constraint	query languages	45-2
complexity	both	conjunctive	query languages	45-2
query languages	and	conjunctive	dependencies	45-2
dependencies	in	constraint	which	45-2
which		sequential	close ties	45-2
close ties	with	constraint	mathematical logic	45-2
mathematical logic	and	conjunctive	complexity theory	45-2
complexity theory	could be exploited	action	<B>	45-2
<B>	On	constraint	the Bibliographic Notes other hand	45-3
the Bibliographic Notes other hand		sequential	little theory	45-3
little theory	in	constraint	connection	45-3
little theory	has emerged	action	connection	45-3
connection	with	constraint	physical query optimization	45-3
physical query optimization	in	constraint	which	45-3
which		sequential	it	45-3
it	to	constraint	a small handful	45-3
it	is	attribute	much more difficult	45-3
it	isolate	action	a small handful	45-3
a small handful	of	constraint	crucial features	45-3
crucial features	upon	constraint	which	45-3
which		sequential	a meaningful theoretical investigation	45-3
a meaningful theoretical investigation	can be based	action	<B>	45-3
Other fundamental topics	are only now receiving	action	attention	45-4
attention	in	constraint	database theory	45-4
database theory		sequential	the behavioral aspects	45-4
the behavioral aspects	of	constraint	databases	45-4
Theoretical research	in	constraint	computer science	46-1
computer science	by	constraint	the practical phenomena	46-1
computer science	both	conjunctive	the practical phenomena	46-1
computer science	is driven	action	the practical phenomena	46-1
the practical phenomena		sequential	that	46-1
that		sequential	it	46-1
it	by	constraint	rigor	46-1
it	and	conjunctive	rigor	46-1
it	and	conjunctive	rigor	46-1
it	is modeling	attribute	aesthetic	46-1
<B>	Although	constraint	practical motivations	46-2
practical motivations	are touched on	action	this text	46-2
this text	on	constraint	primarily the mathematical view	46-2
this text	dwells	action	primarily the mathematical view	46-2
primarily the mathematical view	of	constraint	databases	46-2
databases	and	conjunctive	many concepts	46-2
databases	presents	action	many concepts	46-2
many concepts	and	conjunctive	techniques	46-2
techniques		sequential	that	46-2
that	have not yet found	action	their place	46-2
their place	in	constraint	practical systems	46-2
<B>	For	constraint	instance	46-3
instance	in	constraint	connection	46-3
connection	with	constraint	query optimization	46-3
query optimization	about	constraint	the heuristics	46-3
query optimization	is said	action	the heuristics	46-3
the heuristics		sequential	that	46-3
that	play	action	such an important role	46-3
such an important role	in	constraint	current database systems	46-3
the homomorphism theorem	for	constraint	conjunctive queries	46-4
conjunctive queries	in	constraint	detail	46-4
conjunctive queries	However is presented	action	detail	46-4
detail		sequential	this elegant result	46-4
this elegant result	highlights	action	the essential nature	46-4
the essential nature	of	constraint	conjunctive queries	46-4
The text	also provides	action	a framework	46-5
a framework	for	constraint	a broad range	46-5
a framework	analyzing	action	a broad range	46-5
a broad range	of	constraint	abstract query languages	46-5
abstract query languages	of	constraint	which	46-5
which	by	constraint	the development	46-5
which	either	conjunctive	the development	46-5
which	or	conjunctive	the development	46-5
which	are motivated	action	the development	46-5
which	have influenced	action	the development	46-5
the development	of	constraint	practical languages	46-5
<B>	With	constraint	respect	47-1
respect	to	constraint	the larger field	47-1
the larger field	of	constraint	database systems	47-1
database systems		sequential	we	47-1
we	hope	action	this book	47-1
this book	will serve	action	a dual purpose	47-1
a dual purpose	to	constraint	database system practitioners	47-1
a dual purpose	to	constraint	database system practitioners	47-1
a dual purpose	1 explain	action	database system practitioners	47-1
database system practitioners	of	constraint	the underlying principles	47-1
the underlying principles	and	conjunctive	characteristics	47-1
characteristics	of	constraint	the systems	47-1
the systems		sequential	they	47-1
they	to	constraint	the curiosity	47-1
they	or	conjunctive	the curiosity	47-1
they	and	conjunctive	the curiosity	47-1
they	use	action	the curiosity	47-1
they	build	action	the curiosity	47-1
they	2 arouse	action	the curiosity	47-1
the curiosity	of	constraint	theoreticians	47-1
theoreticians	reading	action	this book	47-1
this book	to	constraint	database systems	47-1
this book	learn	action	database systems	47-1
database systems	how are actually created	action	<B>	47-1
Bibliographic Notes		sequential	Bibliographic Notes	48-1
<B>		sequential	A bibliography	48-2
A bibliography	on	constraint	databases	48-2
databases	in	constraint	Kam81	48-2
databases	is given	action	Kam81	48-2
A good introduction	to	constraint	the field	48-3
the field	in	constraint	KS91	48-3
the field	may be found	action	KS91	48-3
KS91	whereas	constraint	Ull88	48-3
Ull88		sequential	Ull89b	48-3
Ull89b	in	constraint	depth	48-3
Ull89b	provides	attribute	more	48-3
depth		sequential	a presentation	48-3
The relational model	in	constraint	Cod70	49-1
The relational model	is introduced	action	Cod70	49-1
The first text	on	constraint	the logical level	49-2
the logical level	of	constraint	database theory	49-2
database theory	is	attribute	Mai83	49-2
More recent texts	on	constraint	the subject	49-3
the subject	include	action	PBGG89	49-3
PBGG89		sequential	which	49-3
which	on	constraint	aspects	49-3
which	focuses	action	aspects	49-3
aspects	of	constraint	relational database theory	49-3
relational database theory		sequential	Tha91	49-3
Tha91		sequential	which	49-3
which	covers	action	portions	49-3
portions	of	constraint	dependency theory	49-3
dependency theory	and	conjunctive	Ull88	49-3
Ull88		sequential	Ull89b	49-3
Ull89b		sequential	which	49-3
which	both	conjunctive	aspects	49-3
which	and	conjunctive	aspects	49-3
which	covers	attribute	practical	49-3
aspects	of	constraint	the field	49-3
The reader	to	constraint	the excellent survey	49-4
The reader	is also referred	action	the excellent survey	49-4
the excellent survey	of	constraint	relational database theory	49-4
relational database theory	in	constraint	Kan88	49-4
Kan88		sequential	which	49-4
which	forms	action	a chapter	49-4
a chapter	of	constraint	the Handbook	49-4
the Handbook	of	constraint	Theoretical Computer Science	49-4
Database concurrency control	in	constraint	Pap86	50-1
Database concurrency control	is presented	action	Pap86	50-1
Pap86		sequential	BHG87	50-1
Deductive databases	in	constraint	Bid91a	50-2
Deductive databases	are covered	action	Bid91a	50-2
Bid91a		sequential	CGT90	50-2
Collections	of	constraint	papers	50-3
papers	on	constraint	this topic	50-3
this topic	in	constraint	<B>	50-3
this topic	can be found	action	<B>	50-3
we	to	constraint	the real stuff	51-1
we	Will ever get	action	the real stuff	51-1
Vittorio		sequential	Vittorio	52-1
Riccardo		sequential	Riccardo	53-1
Sergio		sequential	Sergio	54-1
Thischaptergivesabriefreviewofthemaintheoreticaltoolsandresultsthatareusedin		sequential	this volume	55-1
It	that	constraint	the reader	55-2
It	is assumed	action	the reader	55-2
the reader	has	action	a degree	55-2
a degree	of	constraint	maturity	55-2
maturity	and	conjunctive	familiarity	55-2
familiarity	with	constraint	mathematics	55-2
mathematics	and	conjunctive	theoretical computer science	55-2
The review	with	constraint	some basics	55-3
The review	begins	action	some basics	55-3
some basics	from	constraint	set theory	55-3
set theory	including	action	graphs	55-3
graphs		sequential	trees	55-3
trees	and	conjunctive	lattices	55-3
<B>		sequential	several topics	55-4
several topics	from	constraint	automata	55-4
automata	and	conjunctive	complexity	55-4
complexity		sequential	theory	55-4
theory	are discussed	action	finite state automata	55-4
theory	including	action	finite state automata	55-4
finite state automata		sequential	Turing machines	55-4
Turing machines		sequential	computability	55-4
computability	and	conjunctive	complexity theories	55-4
complexity theories	and	conjunctive	context	55-4
context		sequential	languages	55-4
basic mathematical logic	and	conjunctive	some remarks	55-5
basic mathematical logic	Finally is surveyed	action	some remarks	55-5
some remarks	are made	action	the specializing assumptions	55-5
some remarks	concerning	action	the specializing assumptions	55-5
the specializing assumptions	in	constraint	database theory	55-5
the specializing assumptions	typically made	action	database theory	55-5
Some Basics		sequential	Some Basics	56-1
<B>	For	constraint	example	57-1
example	if	constraint	Z	57-1
Z	is	attribute	a set	57-1
a set		sequential	inclusion	57-1
inclusion		sequential	⊆	57-1
⊆	is	attribute	a binary relation	57-1
a binary relation	over	constraint	the power set P	57-1
the power set P		sequential	Z	57-1
Z	of	constraint	Z	57-1
Z	over	constraint	also the finitary power set	57-1
Z	and	conjunctive	also the finitary power set	57-1
also the finitary power set		sequential	Pfin	57-1
Pfin		sequential	Z	57-1
Z	of	constraint	Z	57-1
Z		sequential	the set	57-1
the set	of	constraint	all finite subsets	57-1
all finite subsets	of	constraint	Z	57-1
<B>	as	constraint	sets	57-2
<B>	Viewed	action	sets	57-2
sets		sequential	the binary relation	57-2
the binary relation		sequential	≤	57-2
≤	on	constraint	the set	57-2
the set		sequential	N	57-2
N	of	constraint	nonnegative integers	57-2
nonnegative integers	properly contains	action	the relation	57-2
the relation	on	constraint	N	57-2
We	also have	action	occasion	58-1
occasion	to	constraint	n-ary relations	58-1
occasion	study	action	n-ary relations	58-1
n-ary relations	over	constraint	a set S	58-1
a set S	are	attribute	subsets	58-1
subsets	of	constraint	Sn	58-1
Sn		sequential	the cross product	58-1
the cross product	of	constraint	S	58-1
S	with	constraint	itself	58-1
itself	n	conjunctive	times	58-1
<B>	Indeed provide	action	one	58-2
one	of	constraint	the starting points	58-2
the starting points	of	constraint	the relational model	58-2
<B>	Let	action	E	59-1
E	and	conjunctive	E′	59-1
E′	be	attribute	equivalence relations	59-1
equivalence relations	on	constraint	a nonempty set	59-1
a nonempty set		sequential	S. E	59-1
S. E	is	attribute	a refinement	59-1
a refinement	of	constraint	E′	59-1
E′	if	constraint	E	59-1
E		sequential	⊆ E′	59-1
<B>	In	constraint	this case	59-2
this case	for	constraint	each x ∈ S	59-2
each x ∈ S		sequential	we	59-2
we	have	action	x E	59-2
x E		sequential	⊆	59-2
⊆		sequential	x	59-2
<B>	For	constraint	any set Z	60-1
any set Z		sequential	the relation ⊆	60-1
the relation ⊆	over	constraint	P	60-1
P		sequential	Z	60-1
Z	is	attribute	a partially ordered set	60-1
<B>	If	constraint	the cardinality	60-2
the cardinality		sequential	Z|	60-2
Z|	of	constraint	Z	60-2
Z	than	constraint	1	60-2
Z	is	attribute	greater	60-2
1	is	attribute	not a total order	60-2
<B>	on	constraint	N	60-3
N	is	attribute	a total order	60-3
<B>	If	constraint	S	61-1
S		sequential	R	61-1
R	is	attribute	a partially ordered set	61-1
a partially ordered set		sequential	a topological sort	61-1
a topological sort	of	constraint	S	61-1
S	to	constraint	R	61-1
R	is	attribute	a binary relation R′	61-1
a binary relation R′	on	constraint	S	61-1
S	is	attribute	a total order	61-1
a total order		sequential	R′ ⊇ R.	61-1
<B>	Let	action	R	62-1
R	be	attribute	a binary relation	62-1
a binary relation	over	constraint	S	62-1
S	and	conjunctive	P	62-1
P	be	attribute	a set	62-1
a set	of	constraint	properties	62-1
properties	of	constraint	binary relations	62-1
The P- closure	of	constraint	R	62-2
R	is	attribute	the smallest binary relation R′	62-2
the smallest binary relation R′		sequential	that	62-2
that		sequential	R′ ⊇ R	62-2
R′ ⊇ R	and	conjunctive	R′	62-2
R′	of	constraint	the properties	62-2
R′	satisfies	attribute	all	62-2
the properties	in	constraint	P	62-2
P	if	constraint	a unique binary relation	62-2
a unique binary relation	having	action	this specification	62-2
this specification	exists	action	<B>	62-2
<B>	For	constraint	example	62-3
example		sequential	it	62-3
it	to	constraint	the transitive closure	62-3
it	is	attribute	common	62-3
it	form	action	the transitive closure	62-3
the transitive closure	of	constraint	a binary relation	62-3
a binary relation	or	conjunctive	the closure	62-3
a binary relation	and	conjunctive	the closure	62-3
the closure	of	constraint	a binary relation	62-3
<B>	In	constraint	many cases	62-4
many cases		sequential	a closure	62-4
a closure	can be constructed	action	a recursive procedure	62-4
a closure	using	action	a recursive procedure	62-4
<B>	For	constraint	example	62-5
example	given	action	binary relation	62-5
binary relation		sequential	R	62-5
R		sequential	the transitive closure	62-5
the transitive closure		sequential	R+	62-5
R+	of	constraint	R	62-5
R	as	constraint	<B>	62-5
R	can be obtained	action	<B>	62-5
R	follows	action	<B>	62-5
<B>	For	constraint	an arbitrary binary relation R	63-1
an arbitrary binary relation R	and	conjunctive	the closure	63-1
the closure	of	constraint	R	63-1
R	and	conjunctive	an equivalence relation	63-1
R	is	attribute	an equivalence relation	63-1
R	exists	action	an equivalence relation	63-1
There	is	attribute	a close relationship	64-1
a close relationship	between	constraint	binary relations	64-1
binary relations	and	conjunctive	graphs	64-1
The definitions	and	conjunctive	notation	64-2
notation	for	constraint	graphs	64-2
graphs	for	constraint	their application	64-2
graphs	presented here	action	their application	64-2
graphs	have been targeted	action	their application	64-2
their application	in	constraint	this book	64-2
<B>	directed	action	A graph	64-3
A graph	is	attribute	a pair	64-3
a pair		sequential	G	64-3
G	=	sequential	V	64-3
V		sequential	E	64-3
E		sequential	V	64-3
V	is	attribute	where a finite set	64-3
where a finite set	of	constraint	vertexes	64-3
vertexes	and	conjunctive	E ⊆ V	64-3
E ⊆ V	×	constraint	V	64-3
<B>	In	constraint	some cases	64-4
some cases		sequential	we	64-4
we	define	action	a graph	64-4
a graph	by	constraint	a set E	64-4
a graph	presenting	action	a set E	64-4
a set E	of	constraint	edges	64-4
edges	in	constraint	this case	64-4
this case		sequential	it	64-4
it	that	constraint	the vertex set	64-4
it	is understood	action	the vertex set	64-4
the vertex set	is	attribute	the set	64-4
the set	of	constraint	endpoints	64-4
endpoints	of	constraint	elements	64-4
elements	of	constraint	E	64-4
Theoretical Background path	and	conjunctive	n 2	65-1
<B>	If	constraint	G	65-2
G	has	action	a cycle	65-2
a cycle	from	constraint	v	65-2
v		sequential	G	65-2
G	has	action	a proper cycle	65-2
a proper cycle	from	constraint	v. A graph	65-2
v. A graph		sequential	G	65-2
G	=	sequential	V	65-2
V		sequential	E	65-2
E	if	constraint	it	65-2
E	is	attribute	acyclic	65-2
it	has	action	no cycles	65-2
no cycles	if	constraint	the transitive closure	65-2
no cycles	or	conjunctive	the transitive closure	65-2
the transitive closure	of	constraint	E	65-2
E	is	attribute	equivalently irreflexive	65-2
<B>	Let	action	G	66-1
G	=	sequential	V	66-1
V		sequential	E	66-1
E	be	attribute	a graph	66-1
Two vertexes		sequential	u	66-2
u		sequential	v	66-2
v	if	constraint	there	66-2
v	are connected	action	there	66-2
there	is	attribute	an undirected path	66-2
an undirected path	in	constraint	G	66-2
G	from	constraint	u	66-2
u	to	constraint	v	66-2
v	and	conjunctive	they	66-2
they	if	constraint	there	66-2
they	are strongly connected	action	there	66-2
there	are	attribute	directed paths	66-2
directed paths	from	constraint	u	66-2
u	to	constraint	v	66-2
v	from	constraint	v	66-2
v	and	conjunctive	v	66-2
v	to	constraint	u	66-2
<B>	connected	action	A component	66-3
A component	of	constraint	G	66-3
G	is	attribute	an equivalence class	66-3
an equivalence class	of	constraint	V	66-3
V	under	constraint	connectedness	66-3
A graph	if	constraint	it	66-4
A graph	is connected	action	it	66-4
it	has	action	exactly one component	66-4
it	connected	action	exactly one component	66-4
The graph		sequential	M	67-1
M		sequential	L	67-1
L	of	constraint	Parisian metro stations	67-1
Parisian metro stations	and	conjunctive	nonstop links	67-1
nonstop links	between	constraint	them	67-1
them	is strongly connected	action	<B>	67-1
The graph		sequential	a	67-2
a		sequential	b	67-2
b		sequential	c	67-2
c		sequential	d }	67-2
d }		sequential	e	67-2
e		sequential	a	67-2
a		sequential	b	67-2
b		sequential	b	67-2
b		sequential	b	67-2
b		sequential	c	67-2
c		sequential	c	67-2
c		sequential	d	67-2
d		sequential	d	67-2
d		sequential	e	67-2
e		sequential	e	67-2
e		sequential	c	67-2
c		sequential	}	67-2
}	but	conjunctive	<B>	67-2
}	is connected	action	<B>	67-2
}	not strongly connected	action	<B>	67-2
The distance d	of	constraint	a two nodes	68-1
a two nodes		sequential	a b	68-1
a b	in	constraint	a graph	68-1
a graph	is	attribute	b the length	68-1
b the length	of	constraint	the shortest path	68-1
the shortest path	to	constraint	a b	68-1
the shortest path	connecting	action	a b	68-1
a b		sequential	d	68-1
d		sequential	a b	68-1
a b	=	sequential	∞	68-1
∞	if	constraint	<B>	68-1
∞	to	constraint	<B>	68-1
∞	is not connected	action	<B>	68-1
The diameter	of	constraint	a graph G	68-2
a graph G	is	attribute	the maximum finite distance	68-2
the maximum finite distance	between	constraint	two nodes	68-2
two nodes	in	constraint	G	68-2
<B>	Given	action	a forest	69-1
a forest		sequential	removal	69-1
removal	of	constraint	one edge	69-1
one edge	increases	action	the number	69-1
the number	of	constraint	connected components	69-1
connected components	by	constraint	exactly one	69-1
<B>	In	constraint	we	70-1
we	on	constraint	directed graphs	70-1
we	shall focus	action	directed graphs	70-1
directed graphs	but	conjunctive	there	70-1
there	will be	action	occasions	70-1
occasions	to	constraint	undirected graphs	70-1
occasions	use	action	undirected graphs	70-1
An undirected graph	is	attribute	a pair G	70-2
a pair G		sequential	V	70-2
V		sequential	E	70-2
E		sequential	V	70-2
V	is	attribute	where a finite set	70-2
where a finite set	of	constraint	vertexes	70-2
vertexes	and	conjunctive	E	70-2
E	is	attribute	a set	70-2
a set	of	constraint	two element	70-2
two element		sequential	subsets	70-2
subsets	of	constraint	V	70-2
V	again called	action	edges	70-2
The notions	of	constraint	path	70-3
path	to	constraint	undirected graphs	70-3
path	and	conjunctive	undirected graphs	70-3
path	connected	action	undirected graphs	70-3
path	generalize	action	undirected graphs	70-3
undirected graphs	in	constraint	the natural fashion	70-3
We	shall have	action	occasions	71-1
occasions	to	constraint	the vertexes	71-1
occasions	label	action	the vertexes	71-1
the vertexes	or	conjunctive	edges	71-1
edges	of	constraint	a graph	71-1
edges	or	conjunctive	a graph	71-1
edges	directed	attribute	undirected	71-1
<B>	For	constraint	example	71-2
example		sequential	a labeling	71-2
a labeling	of	constraint	the vertexes	71-2
the vertexes	of	constraint	a graph G	71-2
a graph G		sequential	V	71-2
V		sequential	E	71-2
E	with	constraint	label set L	71-2
label set L	is	attribute	function	71-2
function		sequential	a λ	71-2
a λ		sequential	V → L	71-2
<B>	Let	action	G	72-1
G	=	sequential	V	72-1
V		sequential	E	72-1
E	and	conjunctive	G′	72-1
G′	=	sequential	V	72-1
V		sequential	′	72-1
′		sequential	E′	72-1
E′	be	attribute	two directed graphs	72-1
A function h		sequential	V	72-2
V	→	sequential	V	72-2
V	is	attribute	a homomorphism	72-2
a homomorphism	from	constraint	G	72-2
G	to	constraint	G′	72-2
G′	if	constraint	each pair	72-2
G′	for	constraint	each pair	72-2
each pair		sequential	u	72-2
u		sequential	v	72-2
v		sequential	∈ V	72-2
∈ V		sequential	u	72-2
u		sequential	v	72-2
v		sequential	∈ E	72-2
∈ E	implies	action	h	72-2
h		sequential	u	72-2
u		sequential	h	72-2
h		sequential	v	72-2
v		sequential	∈ E′	72-2
The function		sequential	h	72-3
h	is	attribute	an isomorphism	72-3
an isomorphism	from	constraint	G	72-3
G	to	constraint	G′	72-3
G′	if	constraint	h	72-3
h	is	attribute	a one one	72-3
a one one	onto	constraint	mapping	72-3
mapping	from	constraint	V	72-3
V	to	constraint	V ′	72-3
V ′		sequential	h	72-3
h	is	attribute	a homomorphism	72-3
a homomorphism	from	constraint	G	72-3
G	to	constraint	G′	72-3
G′	and	conjunctive	h−1	72-3
h−1	is	attribute	a homomorphism	72-3
a homomorphism	from	constraint	G′	72-3
G′	to	constraint	G	72-3
<B>	Consider	action	the graph	73-1
the graph		sequential	G	73-1
G	=	sequential	a	73-1
a		sequential	b	73-1
b		sequential	c	73-1
c		sequential	d	73-1
d		sequential	e	73-1
e		sequential	}	73-1
}		sequential	a	73-1
a		sequential	b	73-1
b		sequential	b	73-1
b		sequential	b	73-1
b		sequential	c	73-1
c		sequential	b	73-1
b		sequential	d	73-1
d		sequential	b	73-1
b		sequential	e	73-1
e		sequential	c	73-1
c		sequential	d	73-1
d		sequential	d	73-1
d		sequential	e	73-1
e		sequential	e	73-1
e		sequential	c	73-1
c		sequential	}	73-1
There	are	attribute	three automorphisms	73-2
three automorphisms	on	constraint	G	73-2
G		sequential	1 the identity	73-2
1 the identity		sequential	the function	73-2
the function		sequential	that	73-2
that	maps	action	c	73-2
c	to	constraint	d	73-2
d		sequential	d	73-2
d	to	constraint	e	73-2
e		sequential	e	73-2
e	to	constraint	c	73-2
c	and	conjunctive	a b	73-2
c	leaves	action	a b	73-2
a b	and	conjunctive	the function	73-2
a b	fixed	action	the function	73-2
the function		sequential	that	73-2
that	maps	action	c	73-2
c	to	constraint	e	73-2
e		sequential	d	73-2
d	to	constraint	c	73-2
c		sequential	3 e	73-2
3 e	to	constraint	b	73-2
3 e	and	conjunctive	b	73-2
3 e	d	attribute	a	73-2
3 e	leaves	attribute	a	73-2
b	fixed	action	<B>	73-2
<B>	Let	action	S	74-1
S	be	attribute	a set	74-1
A permutation	of	constraint	S	74-2
S	is	attribute	one	74-2
one	onto	constraint	function	74-2
function		sequential	a one ρ	74-2
a one ρ		sequential	S → S.	74-2
S → S.	Suppose	action	that x1	74-2
<B>	.	sequential	<B>	74-3
<B>	.	sequential	<B>	74-4
xn	is	attribute	an arbitrary fixed listing	74-5
an arbitrary fixed listing	of	constraint	the elements	74-5
the elements	of	constraint	S	74-5
S	without	constraint	repeats	74-5
there	Then is	action	one	74-6
one		sequential	a natural one correspondence	74-6
a natural one correspondence	between	constraint	permutations	74-6
permutations		sequential	ρ	74-6
ρ	on	constraint	S	74-6
S	and	conjunctive	listings xi	74-6
<B>	.	sequential	<B>	74-7
<B>	.	sequential	<B>	74-8
<B>	x	sequential	1	74-9
1	in	constraint	elements	74-9
1	of	constraint	elements	74-9
elements	of	constraint	S	74-9
S	without	constraint	repeats	74-9
A permutation ρ′	from	constraint	permutation ρ	74-10
A permutation ρ′	is derived	action	permutation ρ	74-10
permutation ρ	by	constraint	an exchange	74-10
an exchange	if	constraint	the listings	74-10
the listings	to	constraint	ρ	74-10
the listings	corresponding	action	ρ	74-10
ρ	except	constraint	some positions	74-10
ρ	at	constraint	some positions	74-10
ρ	and	conjunctive	some positions	74-10
ρ	ρ′ agree everywhere	action	some positions	74-10
some positions		sequential	i	74-10
i	and	conjunctive	i	74-10
i	+	sequential	1	74-10
1		sequential	the values	74-10
the values	where are exchanged	action	<B>	74-10
<B>	Given	action	two permutations	74-11
two permutations		sequential	ρ	74-11
ρ	from	constraint	ρ	74-11
ρ	and	conjunctive	ρ	74-11
ρ	can be derived	action	ρ	74-11
ρ	using	action	a finite sequence	74-11
a finite sequence	of	constraint	exchanges	74-11
Languages		sequential	Computability	75-1
Computability	and	conjunctive	Complexity	75-1
A general reference	for	constraint	this area	75-2
this area	is	attribute	LP81	75-2
References	on	constraint	automata theory	75-3
automata theory	and	conjunctive	languages	75-3
languages	for	constraint	instance	75-3
languages	include	action	instance	75-3
instance		sequential	the chapters	75-3
the chapters		sequential	BB91	75-3
BB91		sequential	Per91	75-3
Per91	of	constraint	Lee91	75-3
Lee91	and	conjunctive	the books	75-3
the books		sequential	Gin66	75-3
Gin66		sequential	Har78	75-3
References	on	constraint	complexity	75-4
complexity	include	action	the chapter	75-4
the chapter		sequential	Joh91	75-4
Joh91	of	constraint	Lee91	75-4
Lee91	and	conjunctive	the books	75-4
the books		sequential	GJ79	75-4
GJ79		sequential	Pap94	75-4
<B>	#	sequential	a finite set	76-1
<B>	be	attribute	a finite set	76-1
<B>	Let	action	a finite set	76-1
a finite set	called	action	an alphabet	76-1
A word	over	constraint	a finite sequence a 1	76-2
A word	alphabet #	sequential	a finite sequence a 1	76-2
A word	is	attribute	a finite sequence a 1	76-2
<B>	.	sequential	<B>	76-3
<B>	.	sequential	<B>	76-4
<B>	where ∈ #	sequential	1	76-5
<B>	ai	action	1	76-5
1		sequential	≤	76-5
≤		sequential	i	76-5
i	n	conjunctive	<B>	76-5
i	n	conjunctive	<B>	76-5
i	≥ 0	sequential	<B>	76-5
The length	of	constraint	w	76-6
w	=	sequential	<B>	76-6
<B>	.	sequential	<B>	76-7
<B>	.	sequential	<B>	76-8
an denoted |w|	is	attribute	n	76-9
The empty word		sequential	n	77-1
n	=	sequential	0	77-1
0	by	constraint	<B>	77-1
0	is denoted	action	<B>	77-1
The concatenation	of	constraint	two words	77-2
two words		sequential	u	77-2
u	=	sequential	a 1	77-2
<B>	.	sequential	<B>	77-3
<B>	.	sequential	<B>	77-4
<B>	and	conjunctive	v	77-5
v	=	sequential	b1	77-5
<B>	.	sequential	<B>	77-6
<B>	.	sequential	<B>	77-7
bk	is	attribute	the word	77-8
the word		sequential	a 1	77-8
<B>	.	sequential	<B>	77-9
<B>	.	sequential	<B>	77-10
<B>		sequential	<B>	77-11
<B>	.	sequential	<B>	77-12
<B>	.	sequential	<B>	77-13
<B>	denoted	action	uv	77-14
The concatenation	of	constraint	u	77-15
u	with	constraint	itself	77-15
itself	n	conjunctive	times	77-15
times	is denoted	action	un	77-15
The set	of	constraint	all words	77-16
all words	over	constraint	∗	77-16
all words	by	constraint	∗	77-16
all words	#	sequential	∗	77-16
all words	#	sequential	∗	77-16
all words	is denoted	action	∗	77-16
A language	over	constraint	a subset	77-17
A language	#	sequential	a subset	77-17
A language	is	attribute	a subset	77-17
a subset	of	constraint	# ∗	77-17
<B>	For	constraint	example	77-18
example	if	constraint	a	77-18
example	#	sequential	a	77-18
example	=	sequential	a	77-18
a		sequential	b	77-18
b		sequential	}	77-18
}	{	sequential	anbn	77-18
anbn	n	conjunctive	}	77-18
anbn	≥ 0	sequential	}	77-18
}	is	attribute	a language	77-18
a language	over	constraint	<B>	77-18
a language	#	sequential	<B>	77-18
The concatenation	of	constraint	two languages	77-19
two languages		sequential	L	77-19
L	and	conjunctive	K	77-19
K	is	attribute	LK	77-19
LK	=	sequential	uv	77-19
uv		sequential	u ∈ L	77-19
u ∈ L		sequential	v ∈ K	77-19
v ∈ K		sequential	}	77-19
L	with	constraint	itself	77-20
L	concatenated	action	itself	77-20
itself	n	conjunctive	times	77-20
times	is denoted	action	Ln	77-20
Ln	and	conjunctive	L∗	77-20
L∗	=	sequential	n≥0 Ln	77-20
Finite Automata		sequential	Finite Automata	78-1
<B>	For	constraint	example	79-1
example		sequential	sequences	79-1
sequences	of	constraint	database events	79-1
database events	form	action	words	79-1
words	over	constraint	some alphabet	79-1
some alphabet	of	constraint	events	79-1
<B>		sequential	everything	79-2
everything	to	constraint	a sequence	79-2
everything	is mapped internally	action	a sequence	79-2
a sequence	of	constraint	bits	79-2
bits		sequential	which	79-2
which	is	attribute	nothing	79-2
nothing	but	constraint	a word	79-2
a word	over	constraint	alphabet	79-2
The notion	of	constraint	computable query	79-3
computable query	is also formalized	action	low level	79-3
computable query	using	action	low level	79-3
low level		sequential	a representation	79-3
a representation	of	constraint	a database	79-3
a database	as	constraint	a word	79-3
<B>	is	attribute	5 tuple	80-1
5 tuple		sequential	a S	80-1
a S	#	sequential	δ	80-1
δ		sequential	s0	80-1
s0		sequential	F	80-1
F		sequential	where Theoretical Background	80-1
<B>	For	constraint	example	81-1
example	let	action	M	81-1
M	be	attribute	the fsa	81-1
the fsa	with	constraint	<B>	81-1
This property	by	constraint	the pumping lemma	82-1
This property	is formalized	action	the pumping lemma	82-1
This property	so called	action	the pumping lemma	82-1
the pumping lemma	for	constraint	regular languages	82-1
<B>	Throughout	constraint	career	83-1
<B>	or	conjunctive	career	83-1
career		sequential	an employee	83-1
an employee	is first hired	action	any number	83-1
an employee	can be transferred	action	any number	83-1
any number	of	constraint	times	83-1
times	and	conjunctive	<B>	83-1
times	or	conjunctive	<B>	83-1
times	eventually quits	action	<B>	83-1
times	retires	action	<B>	83-1
times	is fired	action	<B>	83-1
The language		sequential	whose words	83-2
whose words	are	attribute	allowable sequences	83-2
allowable sequences	of	constraint	such events	83-2
such events	by	constraint	a regular expression	83-2
such events	can be specified	action	a regular expression	83-2
a regular expression	as	constraint	transfer	83-2
a regular expression	hire	action	transfer	83-2
transfer		sequential	∗	83-2
∗	quit	action	<B>	83-2
There	are	attribute	several important variations	84-1
several important variations	of	constraint	fsa	84-1
fsa		sequential	that	84-1
that	do not change	action	their power	84-1
that	accepting	action	their power	84-1
<B>	allows	action	the input	85-1
<B>	scanning	action	the input	85-1
the input	and	conjunctive	any number	85-1
any number	of	constraint	times	85-1
times	yielding	action	two way	85-1
Nondeterministic fsa		sequential	nfsa	86-1
nfsa	accept	action	the same set	86-1
the same set	of	constraint	languages	86-1
languages	as	constraint	fsa	86-1
the number	of	constraint	states	86-2
states	in	constraint	the equivalent deterministic fsa	86-2
the equivalent deterministic fsa	in	constraint	the number	86-2
the equivalent deterministic fsa	be	attribute	However may exponential	86-2
the number	of	constraint	states	86-2
states	of	constraint	the nondeterministic one	86-2
nondeterminism	as	constraint	a convenience	86-3
nondeterminism	Thus can be viewed	action	a convenience	86-3
a convenience	allowing	action	much more succinct specification	86-3
much more succinct specification	of	constraint	some regular languages	86-3
Machines	and	conjunctive	Computability Turing	87-1
Computability Turing		sequential	Turing machines	87-1
Turing machines		sequential	TMs	87-1
TMs	provide	action	the classical formalization	87-1
the classical formalization	of	constraint	computation	87-1
They	to	constraint	classical complexity theory	87-2
They	are also used	action	classical complexity theory	87-2
They	develop	action	classical complexity theory	87-2
Turing machines	like	constraint	fsa	87-3
Turing machines	are	attribute	fsa	87-3
fsa	except	constraint	symbols	87-3
fsa	that	constraint	symbols	87-3
symbols	can also be overwritten	action	the head	87-3
symbols	just read	action	the head	87-3
the head	in	constraint	either direction	87-3
the head	can move	action	either direction	87-3
either direction	and	conjunctive	the amount available	87-3
the amount available	of	constraint	tape	87-3
tape	is	attribute	infinite	87-3
a move	of	constraint	a TM	87-4
a TM	of	constraint	the current tape symbol	87-4
a TM	Thus consists	action	the current tape symbol	87-4
a TM	reading	action	the current tape symbol	87-4
the current tape symbol	overwriting	action	the symbol	87-4
the symbol	with	constraint	a new one	87-4
a new one	from	constraint	a specified finite tape alphabet	87-4
a specified finite tape alphabet	moving	action	the head	87-4
the head	or	conjunctive	state	87-4
the head	and	conjunctive	state	87-4
the head	left	attribute	right	87-4
the head	changing	action	state	87-4
<B>	Like	constraint	an fsa	87-5
an fsa		sequential	a TM	87-5
a TM	as	constraint	an acceptor	87-5
a TM	can be viewed	action	an acceptor	87-5
The language	by	constraint	a TM M	87-6
The language	accepted	action	a TM M	87-6
a TM M	denoted	action	L	87-6
L		sequential	M	87-6
M	of	constraint	the words	87-6
M	consists	action	the words	87-6
the words	w	constraint	input w	87-6
the words	that	constraint	input w	87-6
the words	on	constraint	input w	87-6
input w		sequential	M	87-6
M	in	constraint	an accepting state	87-6
M	halts	action	an accepting state	87-6
one	Alternatively can view	action	TM	87-7
TM	as	constraint	a generator	87-7
a generator	of	constraint	words	87-7
The TM	on	constraint	empty input	87-8
The TM	starts	action	empty input	87-8
<B>	To	constraint	some word	87-9
<B>	that	constraint	some word	87-9
<B>	indicate	action	some word	87-9
some word	of	constraint	interest	87-9
interest	has been generated	action	the TM	87-9
the TM	into	constraint	some specified state	87-9
the TM	goes	action	some specified state	87-9
some specified state	and	conjunctive	<B>	87-9
some specified state	continues	action	<B>	87-9
<B>	is	attribute	Typically a nonterminating computation	87-10
Typically a nonterminating computation	generating	action	an infinite language	87-10
The set	of	constraint	words	88-1
words	by	constraint	some TM M	88-1
words	so generated	action	some TM M	88-1
some TM M	is denoted	action	G	88-1
G		sequential	M	88-1
TMs	as	constraint	a function	88-2
TMs	Finally can also be viewed	action	a function	88-2
TMs	computing	action	a function	88-2
a function	from	constraint	input	88-2
input	to	constraint	output	88-2
A TM M	computes	action	a partial mapping f	88-3
a partial mapping f	from	constraint	# ∗	88-3
# ∗	to	constraint	# ∗	88-3
# ∗	if	constraint	∈	88-3
# ∗	for	constraint	∈	88-3
# ∗	w	constraint	∈	88-3
∈	#	sequential	each ∗	88-3
each ∗	if	constraint	w the domain	88-3
each ∗	in	constraint	w the domain	88-3
each ∗	is	attribute	w the domain	88-3
w the domain	of	constraint	f	88-3
f		sequential	M	88-3
M	on	constraint	input	88-3
M	1 halts	action	input	88-3
input	w	constraint	the tape	88-3
input	with	constraint	the tape	88-3
the tape	containing	action	the word f	88-3
the word f		sequential	w	88-3
w		sequential	M	88-3
M	on	constraint	input w	88-3
M	2 otherwise does not halt	action	input w	88-3
Church		sequential	thesis	89-1
thesis	that	constraint	any function	89-1
thesis	states	action	any function	89-1
any function	by	constraint	some reasonable computing device	89-1
some reasonable computing device	in	constraint	the aforementioned sense	89-1
some reasonable computing device	is	attribute	also computable	89-1
the definition	of	constraint	computability	89-2
computability	by	constraint	TMs	89-2
TMs	is	attribute	So robust	89-2
<B>	In	constraint	it	89-3
it	to	constraint	many variations	89-3
it	is	attribute	insensitive	89-3
many variations	in	constraint	the definition	89-3
the definition	of	constraint	TM	89-3
TM	allowing	action	multiple tapes	89-3
A particularly important variation	for	constraint	nondeterminism	89-4
A particularly important variation	allows	action	nondeterminism	89-4
nondeterminism	to	constraint	nondeterministic fsa	89-4
<B>	In	constraint	a nondeterministic TM	89-5
a nondeterministic TM		sequential	NTM	89-5
NTM		sequential	there	89-5
there	can be	action	a choice	89-5
a choice	of	constraint	moves	89-5
moves	at	constraint	each step	89-5
an NTM	Thus has	action	several possible computations	89-6
several possible computations	on	constraint	a given input	89-6
a given input	of	constraint	which	89-6
which	and	conjunctive	others	89-6
which	may be terminating	action	others	89-6
others		sequential	<B>	89-6
A word	w	constraint	an NTM M	89-7
A word	by	constraint	an NTM M	89-7
A word	is accepted	action	an NTM M	89-7
an NTM M	if	constraint	there	89-7
there	at	constraint	one computation	89-7
there	exists	attribute	least	89-7
one computation	of	constraint	M	89-7
M	on	constraint	an accepting state	89-7
M	w	constraint	an accepting state	89-7
M	in	constraint	an accepting state	89-7
M	halting	action	an accepting state	89-7
The machine	for	constraint	emptiness	90-1
The machine	can only test	action	emptiness	90-1
emptiness	of	constraint	each stack	90-1
Counter machines	can also define	action	all computable functions	90-2
<B>	and	conjunctive	An formulation	90-3
An formulation	of	constraint	this fact	90-3
this fact	that	constraint	the language	90-3
this fact	is	attribute	the language	90-3
the language	with	constraint	integer variables	90-3
integer variables		sequential	i	90-3
i		sequential	j	90-3
<B>	.	sequential	<B>	90-4
<B>	.	sequential	<B>	90-5
two instructions increment		sequential	i	90-6
i	and	conjunctive	decrement	90-6
decrement		sequential	i	90-6
i	and	conjunctive	a looping construct	90-6
a looping construct	while	constraint	i	90-6
i		sequential	0	90-6
0	> do	action	all computable functions	90-6
0	can define	action	all computable functions	90-6
all computable functions	on	constraint	the integers	90-6
we	in	constraint	functions	91-1
we	are	attribute	Of course often interested	91-1
functions	on	constraint	domains	91-1
domains	than	constraint	words	91-1
words		sequential	integers	91-1
integers	are	attribute	one example	91-1
<B>	To	constraint	the computability	91-2
<B>	about	constraint	the computability	91-2
<B>	talk	action	the computability	91-2
the computability	of	constraint	such functions	91-2
such functions	on	constraint	other domains	91-2
other domains		sequential	one	91-2
one	through	constraint	an encoding	91-2
one	goes	action	an encoding	91-2
an encoding	in	constraint	which	91-2
which		sequential	each element d	91-2
each element d	of	constraint	the domain	91-2
the domain	as	constraint	a word	91-2
the domain	is represented	action	a word	91-2
a word		sequential	Theoretical Background enc	91-2
Theoretical Background enc		sequential	d	91-2
d	on	constraint	some fixed finite alphabet	91-2
<B>	Given	action	that encoding	91-3
that encoding		sequential	it	91-3
it	that	constraint	f	91-3
it	is said	action	f	91-3
f	if	constraint	function enc	91-3
f	is	attribute	computable	91-3
function enc		sequential	f	91-3
f		sequential	the mapping enc	91-3
the mapping enc		sequential	d	91-3
d	to	constraint	enc	91-3
enc		sequential	f	91-3
f		sequential	d	91-3
d	is	attribute	computable	91-3
<B>	without	constraint	problems	91-4
<B>	often works	action	problems	91-4
problems	but	conjunctive	it	91-4
it	occasionally raises	action	tricky issues	91-4
tricky issues		sequential	that	91-4
that	in	constraint	a few places	91-4
that	are discussed	action	a few places	91-4
a few places	of	constraint	this book	91-4
this book	in	constraint	particularly Part	91-4
particularly Part		sequential	E	91-4
It	that	constraint	a language	92-1
It	can be shown	action	a language	92-1
a language	is	attribute	L	92-1
L		sequential	M	92-1
M	for	constraint	some acceptor TM M iff	92-1
some acceptor TM M iff		sequential	it	92-1
it	is	attribute	G	92-1
G		sequential	M	92-1
M	for	constraint	some generator TM M	92-1
<B>	iff	constraint	it	92-2
it	is	attribute	L	92-2
L		sequential	M	92-2
M	or	conjunctive	G	92-2
G		sequential	M	92-2
M	for	constraint	some TM M. L	92-2
some TM M. L	being	action	r.e	92-2
<B>	that	constraint	there	92-3
<B>	means	action	there	92-3
there	is	attribute	an algorithm	92-3
an algorithm		sequential	that	92-3
that	to	constraint	input	92-3
that	on	constraint	input	92-3
that	is guaranteed	action	input	92-3
that	say eventually	action	input	92-3
input	w	constraint	∈ L	92-3
input	if	constraint	∈ L	92-3
input	w	constraint	∈ L	92-3
∈ L	if	constraint	∈ L	92-3
∈ L	w	constraint	∈ L	92-3
∈ L	but	conjunctive	∈ L	92-3
∈ L	may run forever	action	∈ L	92-3
∈ L	if	constraint	it	92-3
it	stops	action	it	92-3
it	says	action	<B>	92-3
one	for	constraint	a word	93-1
one	if	constraint	a word	93-1
one	Thus can never know	attribute	sure	93-1
a word	in	constraint	not L	93-1
a word	is	attribute	not L	93-1
<B>	that	constraint	L	94-1
<B>	saying	action	L	94-1
L	that	constraint	there	94-1
L	is	attribute	recursive	94-1
L	means	action	there	94-1
there	is	attribute	an algorithm	94-1
an algorithm		sequential	that	94-1
that	in	constraint	finite time	94-1
that	always decides	action	finite time	94-1
finite time	whether	constraint	a given word	94-1
a given word	in	constraint	L	94-1
a given word	is	attribute	L	94-1
A language		sequential	whose complement	94-2
whose complement	is	attribute	r.e	94-2
<B>	is called	action	co-r.e	94-3
The following useful facts	can be shown	action	<B>	94-4
<B>		sequential	thing	95-1
thing		sequential	ma	95-1
ma		sequential	a- jigs	95-1
a- jigs	as	constraint	words	95-1
a- jigs	are encoded	action	words	95-1
words	over	constraint	some finite alphabet	95-1
The property	of	constraint	a widget	95-2
The property	being	action	a widget	95-2
a widget	is	attribute	decidable iff	95-2
decidable iff		sequential	the language	95-2
the language	of	constraint	words	95-2
words	encoding	action	widgets	95-2
widgets	is	attribute	recursive	95-2
We	mention	action	a few classical undecidable problems	96-1
The halting problem	if	constraint	a given TM M	96-2
The halting problem	asks	action	a given TM M	96-2
a given TM M	on	constraint	a specified input w	96-2
a given TM M	halts	action	a specified input w	96-2
it	that	constraint	some precise sense	97-1
it	in	constraint	some precise sense	97-1
it	More generally can be shown	action	some precise sense	97-1
some precise sense		sequential	all nontrivial questions	97-1
all nontrivial questions	about	constraint	TMs	97-1
TMs	by	constraint	Rice	97-1
TMs	are	attribute	undecidable	97-1
TMs	is formalized	action	Rice	97-1
Rice		sequential	theorem	97-1
A more concrete undecidable problem		sequential	which	97-2
which	in	constraint	proofs	97-2
which	is	attribute	useful	97-2
proofs	is	attribute	the Post correspondence problem	97-2
the Post correspondence problem		sequential	PCP	97-2
The input	to	constraint	the PCP	97-3
the PCP	of	constraint	two lists u1	97-3
the PCP	consists	action	two lists u1	97-3
<B>	.	sequential	<B>	97-4
<B>	.	sequential	<B>	97-5
un		sequential	v1	97-6
<B>	.	sequential	<B>	97-7
<B>	.	sequential	<B>	97-8
<B>	of	constraint	words	97-9
words	over	constraint	two symbols	97-9
words	with	constraint	two symbols	97-9
words	at	constraint	two symbols	97-9
words	some alphabet #	sequential	two symbols	97-9
A solution	to	constraint	the PCP	97-10
the PCP	is	attribute	a sequence	97-10
a sequence	of	constraint	indexes i1	97-10
<B>	.	sequential	<B>	97-11
<B>	.	sequential	<B>	97-12
ik		sequential	1	97-13
1		sequential	≤	97-13
≤		sequential	ij	97-13
ij	n	conjunctive	that ui	97-13
<B>	.	sequential	<B>	97-14
<B>	.	sequential	<B>	97-15
u	=	sequential	v	97-16
<B>	.	sequential	<B>	97-17
<B>	.	sequential	<B>	97-18
v		sequential	v	97-19
ik		sequential	i1	98-1
i1		sequential	ik	98-1
The question	of	constraint	interest	99-1
interest	whether	constraint	there	99-1
interest	is	attribute	there	99-1
there	is	attribute	a solution	99-1
a solution	to	constraint	the PCP	99-1
<B>	For	constraint	example	99-2
example	consider	action	the input	99-2
the input	to	constraint	the PCP problem	99-2
the PCP problem		sequential	u1 u2 u4 v1 v2 v3 v4 bbb bb babba	99-2
u1 u2 u4 v1 v2 v3 v4 bbb bb babba		sequential	u3	99-2
<B>	For	constraint	this input	100-1
this input		sequential	the PCP	100-1
the PCP	has	action	the solution	100-1
the solution		sequential	1	100-1
1		sequential	4	100-1
4		sequential	3	100-1
3		sequential	1	100-1
1	because	constraint	u1u4u3u1	100-1
u1u4u3u1	=	sequential	ababbaababa	100-1
ababbaababa	=	sequential	v1v4v3v1	100-1
<B>	Now consider	action	the input	101-1
the input	of	constraint	just u1	101-1
the input	consisting	action	just u1	101-1
just u1		sequential	u2	101-1
u2		sequential	u3	101-1
u3	and	conjunctive	v1	101-1
v1		sequential	v2	101-1
v2		sequential	v3	101-1
An easy case analysis	that	constraint	there	101-2
An easy case analysis	shows	action	there	101-2
there	is	attribute	no solution	101-2
no solution	to	constraint	the PCP	101-2
the PCP	for	constraint	this input	101-2
<B>	In	constraint	it	101-3
it	that	constraint	it	101-3
it	has been shown	action	it	101-3
it	whether	constraint	a given input	101-3
it	for	constraint	a given input	101-3
it	is	attribute	undecidable	101-3
a given input		sequential	there	101-3
there	exists	action	a solution	101-3
a solution	to	constraint	the PCP	101-3
The PCP	for	constraint	the undecidability	102-1
The PCP	is	attribute	particularly useful	102-1
The PCP	proving	action	the undecidability	102-1
the undecidability	of	constraint	other problems	102-1
The proof technique	of	constraint	the PCP	102-2
The proof technique	consists	action	the PCP	102-2
The proof technique	reducing	action	the PCP	102-2
the PCP	to	constraint	the problem	102-2
the problem	of	constraint	interest	102-2
<B>	For	constraint	example	102-3
example	suppose	action	we	102-3
we	in	constraint	the question	102-3
we	are	attribute	interested	102-3
the question	of	constraint	a given thing	102-3
the question	whether	constraint	a given thing	102-3
a given thing		sequential	ma	102-3
ma		sequential	jig	102-3
jig	is	attribute	a widget	102-3
The reduction	of	constraint	the PCP	103-1
the PCP	to	constraint	the widget problem	103-1
the widget problem	of	constraint	a computable mapping f	103-1
the widget problem	consists	action	a computable mapping f	103-1
the widget problem	finding	action	a computable mapping f	103-1
a computable mapping f		sequential	that	103-1
that	given	action	an input	103-1
an input		sequential	i	103-1
i	to	constraint	the PCP	103-1
the PCP	produces	action	thing	103-1
thing		sequential	ma	103-1
ma		sequential	jig	103-1
jig		sequential	a f	103-1
a f	that	constraint	f	103-1
f	is	attribute	i a widget iff	103-1
i a widget iff		sequential	the PCP	103-1
the PCP	has	action	a solution	103-1
a solution	for	constraint	i	103-1
<B>	If	constraint	one	103-2
one	can find	action	such a reduction	103-2
such a reduction	that	constraint	it	103-2
such a reduction	shows	action	it	103-2
it	if	constraint	a given thing	103-2
it	is	attribute	undecidable	103-2
a given thing		sequential	ma	103-2
ma		sequential	jig	103-2
jig	is	attribute	a widget	103-2
<B>	if	constraint	one	103-3
<B>	were	attribute	decidable	103-3
one	Indeed could find	action	an algorithm	103-3
an algorithm	for	constraint	the PCP	103-3
the PCP	Given	action	an input	103-3
an input		sequential	i	103-3
i	to	constraint	the PCP	103-3
the PCP	first construct	action	the thing	103-3
the thing		sequential	ma	103-3
ma		sequential	jig	103-3
jig		sequential	f	103-3
f	and	conjunctive	the algorithm	103-3
f	apply	action	the algorithm	103-3
the algorithm	if	constraint	f	103-3
the algorithm	deciding	action	f	103-3
f	is	attribute	i a widget	103-3
<B>	Because	constraint	we	103-4
we	that	constraint	the PCP	103-4
we	know	action	the PCP	103-4
the PCP	is	attribute	undecidable	103-4
the property	of	constraint	a widget	103-4
the property	being	action	a widget	103-4
a widget	be	attribute	can not decidable	103-4
any other known undecidable problem	in	constraint	place	103-5
any other known undecidable problem	Of course can be used	action	place	103-5
place	of	constraint	the PCP	103-5
Complexity	Suppose	action	a particular problem	104-1
a particular problem	is	attribute	solvable	104-1
<B>	Of course does not mean	action	the problem	104-2
the problem	has	action	a practical solution	104-2
a practical solution	because	constraint	it	104-2
it	to	constraint	it	104-2
it	be	attribute	may prohibitively expensive	104-2
it	solve	action	it	104-2
Complexity theory	studies	action	the difficulty	104-3
the difficulty	of	constraint	problems	104-3
Difficulty	to	constraint	some resources	104-4
Difficulty	is measured	action	some resources	104-4
some resources	of	constraint	interest	104-4
interest		sequential	usually time	104-4
usually time	and	conjunctive	space	104-4
the usual model	of	constraint	reference	104-5
reference	is	attribute	Again the TM	104-5
<B>	Suppose	action	L	104-6
L	is	attribute	a recursive language	104-6
a recursive language	by	constraint	a TM M	104-6
a recursive language	accepted	action	a TM M	104-6
a TM M		sequential	that	104-6
that	always halts	action	<B>	104-6
<B>	f	constraint	a function	104-7
<B>	be	attribute	a function	104-7
<B>	Let	action	a function	104-7
a function	on	constraint	positive integers	104-7
M	to	constraint	time	104-8
M	is said	action	time	104-8
M	use	action	time	104-8
time	by	constraint	f	104-8
time	bounded	action	f	104-8
f	if	constraint	every input	104-8
f	on	constraint	every input	104-8
every input	w	constraint	M	104-8
M	at	constraint	f	104-8
M	halts in	action	f	104-8
f		sequential	|w|	104-8
|w|		sequential	most steps	104-8
M	uses	action	space	104-9
space	by	constraint	f	104-9
space	bounded	action	f	104-9
f	if	constraint	the amount	104-9
the amount	of	constraint	tape	104-9
tape	by	constraint	M	104-9
tape	used	action	M	104-9
M	on	constraint	every input	104-9
every input	w	constraint	most f	104-9
every input	at	constraint	most f	104-9
every input	is	attribute	most f	104-9
most f		sequential	|w|	104-9
The set	of	constraint	recursive languages	104-10
recursive languages	by	constraint	TMs	104-10
recursive languages	accepted	action	TMs	104-10
TMs	using	action	time	104-10
time		sequential	space	104-10
space	by	constraint	f	104-10
space	bounded	action	f	104-10
f	is denoted	action	TIME	104-10
TIME		sequential	f	104-10
f		sequential	SPACE	104-10
SPACE		sequential	f	104-10
<B>	Let	action	F	104-11
F	be	attribute	a set	104-11
a set	of	constraint	functions	104-11
functions	on	constraint	positive integers	104-11
TIME		sequential	F	105-1
F	Then =	sequential	TIME	105-1
TIME		sequential	f	105-1
f	and	conjunctive	SPACE	105-1
SPACE		sequential	F	105-1
F	=	sequential	SPACE	105-1
SPACE		sequential	f	105-1
A particularly f ∈F f ∈F important class	of	constraint	bounding functions	105-2
bounding functions	is	attribute	the polynomials Poly	105-2
<B>	For	constraint	this class	105-3
this class		sequential	the following notation	105-3
the following notation	has emerged	action	TIME	105-3
TIME		sequential	Poly	105-3
Poly	is denoted	action	ptime	105-3
ptime	and	conjunctive	SPACE	105-3
SPACE		sequential	Poly	105-3
Poly	is denoted	action	pspace	105-3
Membership	in	constraint	the class ptime	106-1
the class ptime	as	constraint	tractability	106-1
the class ptime	to	constraint	tractability	106-1
the class ptime	is often regarded	attribute	synonymous	106-1
tractability	although	constraint	all situations	106-1
tractability	in	constraint	all situations	106-1
tractability	is	attribute	of course not reasonable	106-1
all situations	and	conjunctive	case	106-1
case	by	constraint	case	106-1
case		sequential	a judgment	106-1
a judgment	should be made	action	<B>	106-1
<B>	Besides	constraint	the polynomials	106-2
the polynomials		sequential	it	106-2
it	of	constraint	interest	106-2
it	is	attribute	interest	106-2
interest	to	constraint	lower bounds	106-2
interest	consider	action	lower bounds	106-2
lower bounds	like	constraint	logarithmic space	106-2
<B>	because	constraint	the input itself	106-3
the input itself	takes	action	more than logarithmic space	106-3
more than logarithmic space	to	constraint	a Theoretical Background separation	106-3
more than logarithmic space	write down	action	a Theoretical Background separation	106-3
a Theoretical Background separation	of	constraint	the input tape	106-3
the input tape	from	constraint	the tape	106-3
the tape	throughout	constraint	the computation	106-3
the tape	used	action	the computation	106-3
the computation	However must be made	action	<B>	106-3
the input	on	constraint	read	107-1
the input	Thus is given	action	read	107-1
read		sequential	a tape	107-1
a tape	and	conjunctive	a separate worktape	107-1
a separate worktape	is added	action	<B>	107-1
<B>	Now let	action	logspace	107-2
logspace	of	constraint	the recursive languages L	107-2
logspace	consist	action	the recursive languages L	107-2
the recursive languages L		sequential	that	107-2
that	by	constraint	some such TM	107-2
that	are accepted	action	some such TM	107-2
some such TM	on	constraint	input	107-2
some such TM	using	action	input	107-2
input	w	constraint	an amount	107-2
an amount	of	constraint	worktape	107-2
worktape	by	constraint	c × log	107-2
worktape	bounded	action	c × log	107-2
c × log		sequential	|w|	107-2
|w|	for	constraint	some constant c	107-2
hyp		sequential	0	108-1
0		sequential	n	108-1
n	n	conjunctive	Hyp	108-1
n	=	sequential	Hyp	108-1
Hyp	=	sequential	hyp	108-1
Hyp	{	sequential	hyp	108-1
hyp		sequential	i	108-1
i		sequential	i	108-1
i	≥	sequential	0 }	108-1
0 }		sequential	hyp	108-1
hyp		sequential	i+1	108-1
i+1		sequential	n	108-1
n	=	sequential	2 hyp i	108-1
2 hyp i		sequential	n	108-1
The elementary languages	in	constraint	TIME	109-1
The elementary languages	are	attribute	those	109-1
TIME		sequential	Hyp	109-1
<B>		sequential	<B>	110-1
An NTM	uses	action	time	110-2
time	by	constraint	f	110-2
time	bounded	action	f	110-2
f	if	constraint	all computations	110-2
all computations	on	constraint	input	110-2
input	w	constraint	f	110-2
input	after	constraint	f	110-2
input	at	constraint	f	110-2
input	halt	action	f	110-2
f		sequential	|w|	110-2
|w|		sequential	most steps	110-2
It	uses	action	space	110-3
space	by	constraint	f	110-3
space	bounded	action	f	110-3
f	if	constraint	all computations	110-3
all computations	on	constraint	input	110-3
input	w	constraint	f	110-3
input	at	constraint	f	110-3
input	use	action	f	110-3
f		sequential	|w|	110-3
|w|		sequential	most space	110-3
most space	that	constraint	termination	110-3
most space	note	action	termination	110-3
termination	is not required	action	<B>	110-3
The set	of	constraint	recursive languages	110-4
recursive languages	by	constraint	some NTM	110-4
recursive languages	accepted	action	some NTM	110-4
some NTM	using	action	time	110-4
time	by	constraint	a polynomial	110-4
time	bounded	action	a polynomial	110-4
a polynomial	is denoted	action	np	110-4
np	and	conjunctive	space	110-4
space	by	constraint	a polynomial	110-4
space	bounded	action	a polynomial	110-4
a polynomial	by	constraint	npspace	110-4
a polynomial	is denoted	action	npspace	110-4
<B>	Are	action	nondeterministic classes	110-5
nondeterministic classes	from	constraint	their deterministic counterparts	110-5
<B>	For	constraint	polynomial space	110-6
polynomial space		sequential	Savitch	110-6
Savitch		sequential	theorem	110-6
theorem	settles	action	the question	110-6
the question	by	constraint	pspace	110-6
the question	that	constraint	pspace	110-6
the question	showing	action	pspace	110-6
pspace		sequential	npspace	110-6
npspace		sequential	the theorem	110-6
the theorem	to	constraint	a much more general class	110-6
the theorem	actually applies	action	a much more general class	110-6
a much more general class	of	constraint	space bounds	110-6
<B>	For	constraint	time	110-7
time		sequential	things	110-7
things	are	attribute	more complicated	110-7
the question	of	constraint	ptime	110-8
the question	whether	constraint	ptime	110-8
ptime	equals	action	np	110-8
np	is	attribute	Indeed the most famous open problem	110-8
Indeed the most famous open problem	in	constraint	complexity theory	110-8
It	that	constraint	the two classes	110-9
It	is generally conjectured	action	the two classes	110-9
the two classes	are	attribute	distinct	110-9
The following inclusions	among	constraint	the complexity classes	111-1
The following inclusions	hold	action	the complexity classes	111-1
the complexity classes	described	action	logspace ⊆ ptime ⊆ np ⊆ pspace ⊂	111-1
Complexity classes	of	constraint	languages	112-1
languages	in	constraint	the same spirit	112-1
languages	can be extended	action	the same spirit	112-1
the same spirit	to	constraint	complexity classes	112-1
complexity classes	of	constraint	computable functions	112-1
we	at	constraint	the resources	112-2
we	Here look	action	the resources	112-2
the resources	to	constraint	the function	112-2
the resources	needed	action	the function	112-2
the resources	compute	action	the function	112-2
the function	or	conjunctive	the input word	112-2
the function	just accepting	action	the input word	112-2
the function	rejecting	action	the input word	112-2
<B>	Consider	action	some complexity class	113-1
some complexity class	say	action	C	113-1
C		sequential	TIME	113-1
TIME		sequential	F	113-1
Such a class	contains	action	all problems	113-2
all problems		sequential	that	113-2
that	in	constraint	time	113-2
that	can be solved	action	time	113-2
time	by	constraint	some function	113-2
time	bounded	action	some function	113-2
some function	in	constraint	F	113-2
<B>	is	attribute	an upper bound	113-3
an upper bound		sequential	C	113-3
C	and	conjunctive	some problems	113-3
C	so clearly contains	attribute	easy	113-3
the hard problems	from	constraint	the easy ones	113-4
the hard problems	How can be distinguished	action	the easy ones	113-4
<B>	by	constraint	the notion	113-5
<B>	is captured	action	the notion	113-5
the notion	of	constraint	completeness	113-5
completeness	of	constraint	a problem	113-5
a problem	in	constraint	a complexity class	113-5
The idea	as	constraint	<B>	113-6
The idea	is	attribute	<B>	113-6
The idea	follows	action	<B>	113-6
<B>	Let	action	L	113-7
L	and	conjunctive	K	113-7
K	be	attribute	languages	113-7
languages	in	constraint	C. L	113-7
C. L	to	constraint	K	113-7
C. L	is	attribute	reducible	113-7
K	if	constraint	there	113-7
there	is	attribute	a computable mapping that	113-7
a computable mapping that	f	constraint	∈ L iff f ∈ K	113-7
a computable mapping that	for	constraint	∈ L iff f ∈ K	113-7
a computable mapping that	each w	constraint	∈ L iff f ∈ K	113-7
a computable mapping that	w	constraint	∈ L iff f ∈ K	113-7
∈ L iff f ∈ K		sequential	w	113-7
<B>	if	constraint	the reduction	114-1
the reduction	f	constraint	we	114-1
the reduction	is	attribute	hard	114-1
we	Clearly do not have	action	an acceptance algorithm	114-1
an acceptance algorithm	in	constraint	C	114-1
the complexity	of	constraint	f	115-1
f	Therefore must be bounded	action	<B>	115-1
It	to	constraint	C	115-2
It	be	attribute	might tempting	115-2
It	use	action	C	115-2
C	as	constraint	the bound	115-2
<B>	However allows	action	all the work	115-3
all the work	of	constraint	L	115-3
all the work	solving	action	L	115-3
L	within	constraint	the reduction	115-3
the reduction		sequential	which	115-3
which	really makes	action	K	115-3
K		sequential	<B>	115-3
the definition	of	constraint	completeness	115-4
completeness	in	constraint	a class C	115-4
a class C	that	constraint	the complexity	115-4
a class C	Therefore requires	action	the complexity	115-4
the complexity	of	constraint	the reduction function	115-4
the reduction function	than	constraint	C	115-4
the reduction function	for	constraint	C	115-4
the reduction function	be	attribute	lower	115-4
We	mention	action	next a few problems	115-5
next a few problems		sequential	that	115-5
that	in	constraint	various classes	115-5
that	are	attribute	complete	115-5
One	of	constraint	the problems	116-1
One	best known	attribute	np complete	116-1
the problems	is	attribute	3 satisfiability	116-1
the problems	so called	action	3 satisfiability	116-1
3 satisfiability		sequential	3 SAT	116-1
3 SAT		sequential	the problem	116-1
The input	is	attribute	a propositional formula	116-2
a propositional formula	in	constraint	conjunctive normal form	116-2
conjunctive normal form	in	constraint	which	116-2
which		sequential	each conjunct	116-2
each conjunct	at	constraint	most three literals	116-2
each conjunct	has	action	most three literals	116-2
<B>	For	constraint	example	116-3
example		sequential	such an input	116-3
such an input	be	attribute	¬x1 ∨	116-3
¬x1 ∨	¬	sequential	x4	116-3
x4	¬	sequential	∨ x2	116-3
∨ x2		sequential	might ∧	116-3
might ∧	∨	sequential	x2	116-3
x2		sequential	∨ x4	116-3
∨ x4		sequential	x1 ∧	116-3
x1 ∧	¬	sequential	x4	116-3
x4		sequential	∨ x3	116-3
∨ x3	∨	sequential	¬x1	116-3
The question	whether	constraint	the formula	117-1
The question	is	attribute	the formula	117-1
the formula	is	attribute	satisfiable	117-1
<B>	For	constraint	example	117-2
example		sequential	the preceding formula	117-2
the preceding formula	with	constraint	the truth assignment	117-2
the preceding formula	is	attribute	satisfied	117-2
the truth assignment		sequential	ξ	117-2
ξ		sequential	x1	117-2
x1	=	sequential	ξ	117-2
ξ		sequential	x2	117-2
x2	=	sequential	ξ	117-2
ξ		sequential	x3	117-2
x3		sequential	ξ	117-2
ξ		sequential	x4	117-2
x4	=	sequential	<B>	117-2
<B>	See	action	Section 2.3	117-3
Section 2.3	for	constraint	the definitions	117-3
the definitions	of	constraint	propositional formula	117-3
propositional formula	and	conjunctive	notions	117-3
pspace		sequential	A useful problem	117-4
A useful problem	is	attribute	<B>	117-4
A useful problem	the following	action	<B>	117-4
The input	is	attribute	a quantified propositional formula	117-5
a quantified propositional formula		sequential	all variables	117-5
all variables	are quantified	action	<B>	117-5
The question	whether	constraint	the formula	117-6
The question	is	attribute	the formula	117-6
the formula	is	attribute	true	117-6
<B>	For	constraint	example	118-1
example		sequential	an input	118-1
an input	to	constraint	the problem	118-1
the problem	is	attribute	<B>	118-1
<B>	For	constraint	ptime completeness	119-1
ptime completeness		sequential	one	119-1
one	can use	action	a natural problem	119-1
a natural problem	to	constraint	context	119-1
context		sequential	grammars	119-1
grammars	defined next	action	<B>	119-1
The input	is	attribute	context	119-2
context		sequential	a grammar G	119-2
a grammar G	and	conjunctive	the question	119-2
the question	whether	constraint	L	119-2
the question	is	attribute	L	119-2
L		sequential	G	119-2
G	is	attribute	empty	119-2
Context Free Grammars		sequential	Context Free Grammars	120-1
Context		sequential	grammars	121-1
grammars		sequential	CFGs	121-1
CFGs	provide	action	different approach	121-1
different approach	to	constraint	a language	121-1
different approach	specifying	action	a language	121-1
a language		sequential	that	121-1
that	emphasizes	action	the generation	121-1
the generation	of	constraint	the words	121-1
the words	in	constraint	the language	121-1
the language		sequential	acceptance	121-1
<B>	into	constraint	an accepting mechanism	121-2
<B>	Nonetheless can be turned	action	an accepting mechanism	121-2
an accepting mechanism	by	constraint	<B>	121-2
an accepting mechanism	parsing	action	<B>	121-2
A CFG	is	attribute	4 tuple	121-3
4 tuple		sequential	a N	121-3
a N	#	sequential	S	121-3
S		sequential	P	121-3
P		sequential	where Theoretical Background	121-3
<B>	is called	action	context	122-1
context	if	constraint	it	122-1
it	is	attribute	L	122-1
L		sequential	G	122-1
G	for	constraint	some CFG G	122-1
L		sequential	G	123-1
G	is	attribute	Then the language	123-1
Then the language		sequential	anbn	123-1
anbn	n	conjunctive	}	123-1
anbn	≥ 0	sequential	}	123-1
<B>	For	constraint	example	123-2
example	is	attribute	a derivation	123-2
a derivation	of	constraint	a 2b2	123-2
a 2b2		sequential	S	123-2
S	⇒	sequential	aSb	123-2
aSb	⇒	sequential	a 2Sb2	123-2
a 2Sb2	⇒	sequential	a 2b2	123-2
The specification power	of	constraint	CFGs	124-1
CFGs	between	constraint	fsa	124-1
CFGs	of	constraint	fsa	124-1
CFGs	lies	attribute	that	124-1
fsa		sequential	s	124-1
s	of	constraint	TMs	124-1
s	and	conjunctive	TMs	124-1
all regular languages	are	attribute	context	124-2
context	and	conjunctive	context	124-2
context		sequential	all languages	124-2
all languages	are	attribute	recursive	124-2
The language		sequential	anbn	124-3
anbn	n	conjunctive	context	124-3
anbn	≥ 0	sequential	context	124-3
anbn	is	attribute	context	124-3
context	but	conjunctive	<B>	124-3
An example	of	constraint	a recursive language	124-4
a recursive language		sequential	that	124-4
that	is	attribute	context	124-4
context	is	attribute	anbncn	124-4
anbncn	n	conjunctive	0	124-4
anbncn	≥	sequential	0	124-4
0		sequential	}	124-4
The proof	uses	action	an extension	124-5
an extension	to	constraint	languages	124-5
languages	of	constraint	the pumping lemma	124-5
the pumping lemma	for	constraint	regular languages	124-5
We	also use	action	a similar technique	124-6
a similar technique	in	constraint	the proofs	124-6
a similar technique	of	constraint	the proofs	124-6
The most common use	of	constraint	CFGs	125-1
CFGs	in	constraint	the area	125-1
the area	of	constraint	databases	125-1
databases	to	constraint	certain objects	125-1
databases	is	attribute	certain objects	125-1
databases	view	action	certain objects	125-1
certain objects	as	constraint	CFGs	125-1
CFGs	and	conjunctive	un	125-1
CFGs	use	action	un	125-1
CFGs	known	action	un	125-1
un		sequential	decidability properties	125-1
decidability properties	about	constraint	CFGs	125-1
Some questions	about	constraint	CFGs	125-2
CFGs	to	constraint	1 emptiness	125-2
CFGs	known	attribute	decidable	125-2
CFGs	be	attribute	decidable	125-2
CFGs	are	attribute	1 emptiness	125-2
1 emptiness	is	attribute	L	125-2
L		sequential	G	125-2
G		sequential	<B>	125-2
<B>	and	conjunctive	2 finiteness	125-3
2 finiteness	is	attribute	L	125-3
L		sequential	G	125-3
G		sequential	<B>	125-3
Some undecidable questions	are	attribute	3 containment	125-4
3 containment	is	attribute	it	125-4
it	that	constraint	G1	125-4
G1		sequential	L ⊆ L	125-4
L ⊆ L		sequential	G2	125-4
Basics	from	constraint	Logic	126-1
It	as	constraint	the basis	126-2
It	serves	action	the basis	126-2
the basis	for	constraint	languages	126-2
languages	for	constraint	queries	126-2
queries		sequential	deductive databases	126-2
deductive databases	and	conjunctive	constraints	126-2
We	briefly review	action	the basic notions	126-3
the basic notions	and	conjunctive	notations	126-3
notations	of	constraint	mathematical logic	126-3
mathematical logic	and	conjunctive	some key differences	126-3
mathematical logic	mention	action	some key differences	126-3
some key differences	between	constraint	this logic	126-3
this logic	in	constraint	the specializations	126-3
this logic	and	conjunctive	the specializations	126-3
the specializations	in	constraint	database theory	126-3
the specializations	usually considered	action	database theory	126-3
The reader	to	constraint	EFT84	127-1
The reader	is referred	action	EFT84	127-1
EFT84		sequential	End72	127-1
End72	for	constraint	comprehensive introductions	127-1
comprehensive introductions	to	constraint	mathematical logic	127-1
mathematical logic	to	constraint	the chapter	127-1
mathematical logic	and	conjunctive	the chapter	127-1
the chapter		sequential	Apt91	127-1
Apt91	in	constraint	Lee91	127-1
Lee91	and	conjunctive	Llo87	127-1
Llo87	for	constraint	treatments	127-1
treatments	of	constraint	Herbrand models	127-1
Herbrand models	and	conjunctive	logic programming	127-1
Propositional Logic		sequential	Propositional Logic	128-1
<B>	For	constraint	we	128-2
we	assume	action	an infinite set	128-2
an infinite set	of	constraint	propositional variables	128-2
propositional variables	typically denoted	action	p	128-2
p		sequential	q	128-2
q		sequential	r	128-2
<B>	.	sequential	<B>	128-3
<B>	.	sequential	<B>	128-4
<B>	with	constraint	possibly subscripts	128-5
We	also permit	action	the special propositional constants	128-6
the special propositional constants	and	conjunctive	<B>	128-6
<B>	formed	action	propositional formulas	128-7
propositional formulas	from	constraint	the propositional variables	128-7
propositional formulas	are constructed	action	the propositional variables	128-7
the propositional variables	and	conjunctive	constants	128-7
constants	using	action	the unary connective negation	128-7
the unary connective negation		sequential	¬	128-7
¬	and	conjunctive	the binary connectives disjunction	128-7
the binary connectives disjunction		sequential	∨	128-7
∨		sequential	conjunction	128-7
conjunction		sequential	∧	128-7
∧		sequential	implication	128-7
implication		sequential	→	128-7
→	and	conjunctive	equivalence	128-7
equivalence	↔	sequential	<B>	128-7
<B>	For	constraint	example	128-8
example		sequential	p	128-8
p		sequential	p ∧	128-8
p ∧		sequential	¬q	128-8
¬q	and	conjunctive	p	128-8
p		sequential	∨ q	128-8
∨ q		sequential	→ p	128-8
→ p	are	attribute	propositional formulas	128-8
→ p	formed	action	propositional formulas	128-8
We	generally omit	action	parentheses	128-9
parentheses	if	constraint	a formula	128-9
parentheses	for	constraint	a formula	128-9
parentheses	not needed	action	a formula	128-9
parentheses	understanding	action	a formula	128-9
<B>	for	constraint	the variables	129-1
the variables	in	constraint	induction	129-1
the variables	by	constraint	induction	129-1
the variables	occurring	action	induction	129-1
the variables	is defined	action	induction	129-1
induction	on	constraint	the structure	129-1
the structure	of	constraint	the natural manner	129-1
the structure	in	constraint	the natural manner	129-1
<B>	For	constraint	example	129-2
<B>	If	constraint	ξ	130-1
ξ	=	sequential	we	130-1
we	that	constraint	ξ	130-1
we	say	action	ξ	130-1
ξ	that	constraint	ϕ	130-1
ξ	and	conjunctive	ϕ	130-1
ξ	is	attribute	true	130-1
ϕ	under	constraint	ξ	130-1
ϕ	is	attribute	true	130-1
ξ	for	constraint	<B>	130-1
ξ	and	conjunctive	<B>	130-1
<B>	makes	action	it	131-1
it		sequential	<B>	131-1
The formula		sequential	p	131-2
p		sequential	q	131-2
q	but	conjunctive	the formula	131-2
q	is	attribute	satisfiable	131-2
the formula		sequential	p ∧	131-2
p ∧		sequential	¬p	131-2
¬p	and	conjunctive	the formula	131-2
¬p	is	attribute	unsatisfiable	131-2
the formula		sequential	p	131-2
p		sequential	∨	131-2
∨		sequential	¬p	131-2
¬p	is	attribute	valid	131-2
<B>	For	constraint	example	132-1
example		sequential	p ∧	132-1
p ∧		sequential	p	132-1
p	→	sequential	q	132-1
q	|=	sequential	q	132-1
Many equivalences	for	constraint	propositional formulas	132-2
propositional formulas	are well known	action	<B>	132-2
<B>	For	constraint	example	132-3
<B>	that	constraint	the last equivalence	133-1
<B>	Observe	action	the last equivalence	133-1
the last equivalence	permits	action	us	133-1
us	to	constraint	∨	133-1
us	view	action	∨	133-1
∨	as	constraint	a polyadic connective	133-1
<B>	for	constraint	∧	133-2
<B>	holds	action	∧	133-2
First Order		sequential	Theoretical Background Logic	134-1
We	indicate	action	the main intuitions	134-2
the main intuitions	and	conjunctive	concepts	134-2
concepts	underlying	attribute	first	134-2
concepts	order	action	logic	134-2
logic	and	conjunctive	the primary specializations	134-2
logic	describe	action	the primary specializations	134-2
the primary specializations	for	constraint	database theory	134-2
the primary specializations	typically made	action	database theory	134-2
Precise definitions	of	constraint	needed portions	134-3
needed portions	of	constraint	order	134-3
order		sequential	logic	134-3
logic	in	constraint	Chapters 4	134-3
logic	are included	action	Chapters 4	134-3
Chapters 4	and	conjunctive	5	134-3
<B>		sequential	order	135-1
order		sequential	logic	135-1
logic	generalizes	action	propositional logic	135-1
propositional logic	in	constraint	several ways	135-1
<B>		sequential	propositional variables	135-2
propositional variables	by	constraint	predicate symbols	135-2
propositional variables	are replaced	action	predicate symbols	135-2
predicate symbols		sequential	that	135-2
that	over	constraint	n-ary relations	135-2
that	range	action	n-ary relations	135-2
n-ary relations	over	constraint	an underlying set	135-2
Variables	in	constraint	first order	135-3
Variables	are used	action	first order	135-3
first order		sequential	logic	135-3
logic	to	constraint	elements	135-3
logic	over	constraint	elements	135-3
logic	range	action	elements	135-3
elements	of	constraint	an abstract set	135-3
an abstract set	called	action	the universe	135-3
the universe	of	constraint	discourse	135-3
<B>	is realized	action	the quantifiers	135-4
<B>	using	action	the quantifiers	135-4
the quantifiers	and	conjunctive	<B>	135-4
<B>	In	constraint	addition	135-5
addition		sequential	function symbols	135-5
function symbols	into	constraint	the model	135-5
function symbols	are incorporated	action	the model	135-5
The most important definitions	to	constraint	order	135-6
The most important definitions	used	attribute	first	135-6
The most important definitions	formalize	attribute	first	135-6
order		sequential	logic	135-6
logic	are	attribute	order	135-6
order		sequential	language	135-6
language		sequential	interpretation	135-6
interpretation		sequential	logical implication	135-6
logical implication	and	conjunctive	provability	135-6
<B>		sequential	order	136-1
order		sequential	Each language L	136-1
Each language L	includes	action	a set	136-1
a set	of	constraint	variables	136-1
variables		sequential	the propositional connectives	136-1
the propositional connectives		sequential	the quantifiers	136-1
the quantifiers	and	conjunctive	∀	136-1
∀	and	conjunctive	punctuation symbols	136-1
punctuation symbols	and	conjunctive	<B>	136-1
The variation	in	constraint	order	136-2
order		sequential	languages	136-2
languages	from	constraint	the symbols	136-2
languages	stems	action	the symbols	136-2
the symbols		sequential	they	136-2
they	to	constraint	constants	136-2
they	include	action	constants	136-2
they	represent	action	constants	136-2
constants		sequential	predicates	136-2
predicates	and	conjunctive	functions	136-2
<B>		sequential	first order	136-3
first order		sequential	a language	136-3
a language	includes	action	<B>	136-3
<B>	In	constraint	some cases	137-1
some cases		sequential	we	137-1
we	also include	action	<B>	137-1
<B>	Let	action	L	138-1
L	be	attribute	first order	138-1
first order		sequential	a language	138-1
Terms	of	constraint	L	138-2
L	in	constraint	the natural fashion	138-2
L	are built	action	the natural fashion	138-2
the natural fashion	from	constraint	constants	138-2
constants		sequential	variables	138-2
variables	and	conjunctive	the function symbols	138-2
An atom	either	conjunctive	an expression	138-3
An atom	or	conjunctive	an expression	138-3
An atom	is	attribute	true	138-3
an expression	of	constraint	the form R	138-3
the form R		sequential	t1	138-3
<B>	.	sequential	<B>	138-4
<B>	.	sequential	<B>	138-5
tn		sequential	R	138-6
R	is	attribute	where an n-ary predicate symbol	138-6
where an n-ary predicate symbol	and	conjunctive	t1	138-6
<B>	.	sequential	<B>	138-7
<B>	.	sequential	<B>	138-8
tn	are	attribute	terms	138-9
Atoms	to	constraint	the propositional variables	138-10
Atoms	correspond	action	the propositional variables	138-10
the propositional variables	of	constraint	propositional logic	138-10
<B>	If	constraint	the equality symbol	138-11
the equality symbol	is included	action	atoms	138-11
atoms	include	action	expressions	138-11
expressions	of	constraint	the form	138-11
the form		sequential	t1 t2	138-11
The family	of	constraint	predicate calculus	138-12
The family	well formed	action	predicate calculus	138-12
predicate calculus		sequential	formulas	138-12
formulas	over	constraint	L	138-12
L	with	constraint	atoms	138-12
L	is defined	action	atoms	138-12
L	recursively starting	action	atoms	138-12
atoms	using	action	the Boolean connectives	138-12
the Boolean connectives	and	conjunctive	the quantifiers	138-12
the Boolean connectives	using	action	the quantifiers	138-12
the quantifiers	as	constraint	<B>	138-12
the quantifiers	follows	action	<B>	138-12
<B>	As with	constraint	the propositional case	138-13
the propositional case		sequential	parentheses	138-13
parentheses	from	constraint	the context	138-13
parentheses	are omitted	action	the context	138-13
parentheses	when understood	action	the context	138-13
<B>	In	constraint	addition	138-14
addition		sequential	∨	138-14
∨	and	conjunctive	∧	138-14
∧	as	constraint	polyadic connectives	138-14
∧	are viewed	action	polyadic connectives	138-14
A term	or	conjunctive	formula	138-15
formula	is	attribute	ground	138-15
ground	if	constraint	it	138-15
it	involves	action	no variables	138-15
Some examples	of	constraint	formulas	139-1
formulas	in	constraint	LN	139-1
LN	as	constraint	<B>	139-1
LN	are	attribute	<B>	139-1
LN	follows	action	<B>	139-1
The notion	of	constraint	the scope	140-1
the scope	of	constraint	quantifiers	140-1
quantifiers	of	constraint	occurrences	140-1
quantifiers	and	conjunctive	occurrences	140-1
quantifiers	and	conjunctive	occurrences	140-1
occurrences	of	constraint	variables	140-1
variables	in	constraint	formulas	140-1
formulas	is now defined	action	recursion	140-1
formulas	using	action	recursion	140-1
recursion	on	constraint	the structure	140-1
Each variable occurrence	in	constraint	an atom	140-2
an atom	is	attribute	free	140-2
<B>	If	constraint	1 ∨	140-3
<B>	ψ	sequential	1 ∨	140-3
<B>	is	attribute	1 ∨	140-3
1 ∨	ψ	sequential	2	140-3
2		sequential	an occurrence	140-3
an occurrence	of	constraint	variable x	140-3
variable x	in	constraint	it	140-3
variable x	if	constraint	it	140-3
variable x	ϕ	sequential	it	140-3
variable x	is	attribute	free	140-3
it	as	constraint	an occurrence	140-3
it	is	attribute	free	140-3
an occurrence	of	constraint	the other propositional connectives	140-3
an occurrence	to	constraint	the other propositional connectives	140-3
an occurrence	or	conjunctive	the other propositional connectives	140-3
an occurrence	and	conjunctive	the other propositional connectives	140-3
an occurrence	ψ 1	sequential	the other propositional connectives	140-3
an occurrence	ψ 2	sequential	the other propositional connectives	140-3
an occurrence	is extended	action	the other propositional connectives	140-3
<B>	If	constraint	an occurrence	140-4
<B>	is	attribute	an occurrence	140-4
an occurrence	of	constraint	variable x	140-4
variable x		sequential	y	140-4
y	in	constraint	the corresponding occurrence	140-4
y	if	constraint	the corresponding occurrence	140-4
y	ϕ	sequential	the corresponding occurrence	140-4
y	is	attribute	free	140-4
the corresponding occurrence	in	constraint	ψ	140-4
the corresponding occurrence	is	attribute	free	140-4
Each occurrence	of	constraint	y	140-5
y	in	constraint	<B>	140-5
y	ϕ	sequential	<B>	140-5
y	is bound	action	<B>	140-5
<B>	In	constraint	addition	140-6
addition		sequential	each occurrence	140-6
each occurrence	of	constraint	y in	140-6
y in		sequential	that	140-6
that	in	constraint	ψ	140-6
that	is	attribute	free	140-6
ψ	to	constraint	the scope	140-6
ψ	in	constraint	the scope	140-6
ψ	be	attribute	the scope	140-6
ψ	is said	action	the scope	140-6
the scope	of	constraint	∃y	140-6
∃y	at	constraint	the beginning	140-6
the beginning	of	constraint	ϕ	140-6
A sentence	is	attribute	a formula	140-7
A sentence	well formed	action	a formula	140-7
a formula		sequential	that	140-7
that	has	action	no free variable occurrences	140-7
<B>	Until	constraint	we	141-1
we	have not given	action	a meaning	141-1
a meaning	to	constraint	the symbols	141-1
the symbols	of	constraint	first order	141-1
first order		sequential	a language	141-1
a language	to	constraint	first order	141-1
a language	and	conjunctive	first order	141-1
first order		sequential	thereby formulas	141-1
<B>	with	constraint	the notion	141-2
<B>	is accomplished	action	the notion	141-2
the notion	of	constraint	interpretation	141-2
interpretation		sequential	which	141-2
which	to	constraint	the truth assignments	141-2
which	corresponds	action	the truth assignments	141-2
the truth assignments	of	constraint	the propositional case	141-2
Each interpretation	is	attribute	just one	141-3
just one	of	constraint	the many possible ways	141-3
the many possible ways	to	constraint	meaning	141-3
the many possible ways	give	action	meaning	141-3
meaning	to	constraint	a language	141-3
<B>	is	attribute	a nonempty set	142-1
a nonempty set	of	constraint	abstract elements	142-1
abstract elements	called	action	the universe	142-1
the universe	of	constraint	discourse	142-1
discourse	and	conjunctive	C	142-1
C		sequential	P	142-1
P	and	conjunctive	F	142-1
F	give	action	meanings	142-1
meanings	to	constraint	the sets	142-1
the sets	of	constraint	constant symbols	142-1
constant symbols		sequential	predicate symbols	142-1
predicate symbols	and	conjunctive	function symbols	142-1
<B>	For	constraint	example	143-1
example		sequential	C	143-1
C	is	attribute	a function	143-1
a function	from	constraint	the constant symbols	143-1
the constant symbols	into	constraint	U	143-1
U	and	conjunctive	P	143-1
P	maps	action	each n-ary predicate symbol p	143-1
each n-ary predicate symbol p	into	constraint	an n-ary relation	143-1
an n-ary relation	over	constraint	U	143-1
U		sequential	a subset	143-1
a subset	of	constraint	U n	143-1
It	for	constraint	two distinct constant symbols	143-2
It	is	attribute	possible	143-2
two distinct constant symbols	to	constraint	the same element	143-2
two distinct constant symbols	to	constraint	the same element	143-2
two distinct constant symbols	map	action	the same element	143-2
the same element	of	constraint	U	143-2
the equality symbol	When denoted	action	the meaning	144-1
the equality symbol	is included	action	the meaning	144-1
the meaning	with	constraint	it	144-1
the meaning	associated	action	it	144-1
it	so that	constraint	it	144-1
it	is restricted	action	it	144-1
it	enjoys	action	properties	144-1
properties	with	constraint	equality	144-1
properties	usually associated	action	equality	144-1
Two equivalent mechanisms	for	constraint	<B>	144-2
Two equivalent mechanisms	accomplishing	attribute	this	144-2
Two equivalent mechanisms	are described next	action	<B>	144-2
<B>	Let	action	I	145-1
I	be	attribute	an interpretation	145-1
an interpretation	for	constraint	language L.	145-1
language L.	As	constraint	a notational shorthand	145-1
a notational shorthand	if	constraint	c	145-1
c	is	attribute	a constant symbol	145-1
a constant symbol	in	constraint	L	145-1
L		sequential	we	145-1
we	use	action	cI	145-1
cI	to	constraint	the element	145-1
cI	denote	action	the element	145-1
the element	of	constraint	the universe	145-1
the universe	with	constraint	c	145-1
the universe	associated	action	c	145-1
c	by	constraint	I	145-1
<B>	in	constraint	the natural way	145-2
<B>	is extended	action	the natural way	145-2
the natural way	to	constraint	ground terms	145-2
ground terms	and	conjunctive	atoms	145-2
The usual interpretation	for	constraint	the language LN	146-1
the language LN	is	attribute	IN	146-1
IN		sequential	the universe	146-1
the universe	is	attribute	where N	146-1
where N		sequential	0	146-1
0	to	constraint	the number	146-1
0	is mapped	action	the number	146-1
the number		sequential	0	146-1
0		sequential	≤	146-1
≤	to	constraint	relation	146-1
≤	than	constraint	relation	146-1
≤	or	conjunctive	relation	146-1
≤	is mapped	attribute	the usual	146-1
relation		sequential	S	146-1
S	to	constraint	successor	146-1
S	is mapped	action	successor	146-1
successor	and	conjunctive	×	146-1
successor	and	conjunctive	×	146-1
×	to	constraint	addition	146-1
×	+ are mapped	action	addition	146-1
addition	and	conjunctive	multiplication	146-1
<B>	In	constraint	such cases	146-2
such cases		sequential	we	146-2
we	for	constraint	example	146-2
we	have	action	example	146-2
example		sequential	S	146-2
S		sequential	S	146-2
S		sequential	0	146-2
0	+	sequential	0	146-2
<B>	from	constraint	the function symbols	147-1
<B>	using	action	the function symbols	147-1
the function symbols	of	constraint	the language	147-1
<B>	because	constraint	the terms	147-2
<B>	is	attribute	a little	147-2
the terms	now play	action	a dual role	147-2
a dual role	as	constraint	terms	147-2
terms	from	constraint	components	147-2
terms	constructed	action	components	147-2
components	of	constraint	the language L	147-2
the language L	as	constraint	elements	147-2
the language L	and	conjunctive	elements	147-2
elements	of	constraint	the universe UL	147-2
The mapping C	maps	action	the constant symbol	147-3
the constant symbol		sequential	0	147-3
0	to	constraint	0	147-3
0		sequential	N	147-3
N	as	constraint	an element	147-3
N	ered	action	an element	147-3
an element	of	constraint	UL	147-3
<B>	Given	action	a term	147-4
a term		sequential	t	147-4
t	in	constraint	U	147-4
U		sequential	function	147-4
function		sequential	F	147-4
F		sequential	S	147-4
S		sequential	the maps t	147-4
the maps t	to	constraint	the term S	147-4
the term S		sequential	t	147-4
N Given terms		sequential	t1	148-1
t1	and	conjunctive	t2	148-1
t2		sequential	the function	148-1
the function		sequential	F	148-1
F	+	sequential	the pair	148-1
F	maps	action	the pair	148-1
the pair		sequential	t1	148-1
t1		sequential	t2	148-1
t2	to	constraint	the term	148-1
the term	+	sequential	t1	148-1
t1		sequential	t2	148-1
t2	and	conjunctive	the function F	148-1
the function F		sequential	×	148-1
×	is defined analogously	action	<B>	148-1
The set	of	constraint	ground atoms	149-1
ground atoms	of	constraint	LN	149-1
LN		sequential	the set	149-1
the set	of	constraint	atoms	149-1
atoms		sequential	that	149-1
that	do not contain	action	variables	149-1
variables	is sometimes called	action	the Herbrand base	149-1
the Herbrand base	of	constraint	LN	149-1
There	is	attribute	one	149-2
one		sequential	a natural one correspondence	149-2
Theoretical Background	between	constraint	interpretations	150-1
interpretations	of	constraint	LN	150-1
LN		sequential	that	150-1
that	extend	action	the Herbrand preinterpretation	150-1
the Herbrand preinterpretation	and	conjunctive	subsets	150-1
subsets	of	constraint	the Herbrand base	150-1
the Herbrand base	of	constraint	LN	150-1
One Herbrand interpretation	of	constraint	particular interest	150-2
particular interest	is	attribute	the one	150-2
the one		sequential	that	150-2
that	mimics	action	the usual interpretation	150-2
<B>	In	constraint	this interpretation	150-3
this interpretation	to	constraint	the set	150-3
this interpretation	maps	action	the set	150-3
this interpretation	≤	action	the set	150-3
the set		sequential	I	150-3
I		sequential	I	150-3
I		sequential	N	150-3
N		sequential	N	150-3
We	to	constraint	the notion	151-1
We	now turn	action	the notion	151-1
the notion	of	constraint	satisfaction	151-1
satisfaction	of	constraint	a formula	151-1
a formula	by	constraint	an interpretation	151-1
The definition	on	constraint	the structure	151-2
The definition	is	attribute	recursive	151-2
the structure	of	constraint	formulas	151-2
formulas	as	constraint	a result	151-2
a result		sequential	we	151-2
we	need	action	the notion	151-2
the notion	of	constraint	variable assignment	151-2
variable assignment	to	constraint	variables	151-2
variable assignment	accommodate	action	variables	151-2
variables	in	constraint	formulas	151-2
variables	occurring	attribute	free	151-2
<B>	Let	action	L	151-3
L	be	attribute	a language	151-3
a language	and	conjunctive	I	151-3
I		sequential	an interpretation	151-3
an interpretation	of	constraint	L	151-3
L	with	constraint	universe U	151-3
A variable assignment	for	constraint	formula	151-4
formula	is	attribute	a partial function µ	151-4
a partial function µ		sequential	variables	151-4
variables	of	constraint	L	151-4
L	→	sequential	U	151-4
U		sequential	whose domain	151-4
whose domain	includes	action	all variables	151-4
all variables	in	constraint	ϕ	151-4
<B>	For	constraint	terms	151-5
terms		sequential	t	151-5
t		sequential	t	151-5
t		sequential	I	151-5
I		sequential	µ	151-5
µ	denotes	action	the meaning	151-5
the meaning	to	constraint	t	151-5
the meaning	given	action	t	151-5
t	by	constraint	I	151-5
I	using	action	µ	151-5
µ	to	constraint	the free variables	151-5
µ	interpret	action	the free variables	151-5
<B>	In	constraint	addition	151-6
addition	if	constraint	µ	151-6
µ	is	attribute	a variable assignment	151-6
a variable assignment		sequential	x	151-6
x	is	attribute	a variable	151-6
a variable	and	conjunctive	u	151-6
u		sequential	∈ U	151-6
∈ U		sequential	µ	151-6
µ		sequential	x	151-6
x		sequential	/u	151-6
/u	denotes	action	the variable assignment	151-6
the variable assignment		sequential	that	151-6
that	to	constraint	µ	151-6
that	is	attribute	identical	151-6
µ	except	constraint	it	151-6
µ	that	constraint	it	151-6
it	maps	action	x	151-6
x	to	constraint	u	151-6
We	write	action	I	151-7
I		sequential	µ	151-7
µ	to	constraint	I	151-7
µ	that	constraint	I	151-7
µ	indicate	action	I	151-7
I	under	constraint	µ	151-7
I	satisfies	action	µ	151-7
<B>	on	constraint	the structure	151-8
<B>	is defined recursively	action	the structure	151-8
the structure	of	constraint	formulas	151-8
formulas	in	constraint	the natural fashion	151-8
<B>	To	constraint	the flavor	151-9
<B>	indicate	action	the flavor	151-9
the flavor	of	constraint	the definition	151-9
the definition		sequential	we	151-9
we	that	constraint	I	151-9
we	note	action	I	151-9
I		sequential	p	151-9
p		sequential	t1	151-9
<B>	.	sequential	<B>	151-10
<B>	.	sequential	<B>	151-11
tn		sequential	µ	151-12
µ	if	constraint	I	151-12
I		sequential	µ	151-12
µ		sequential	I	151-12
I		sequential	µ	151-12
µ	n	conjunctive	<B>	151-12
<B>	For	constraint	example	152-1
example		sequential	IN	152-1
IN		sequential	∀x∃y	152-1
∀x∃y		sequential	¬	152-1
¬		sequential	x	152-1
x	≈	sequential	y	152-1
y		sequential	∨	152-1
∨	x	sequential	≤ y	152-1
≤ y	IN	constraint	S	152-1
S		sequential	0	152-1
0		sequential	≤	152-1
≤		sequential	0	152-1
0	IN	constraint	∀y∀z	152-1
0	and	conjunctive	∀y∀z	152-1
∀y∀z		sequential	x ≈ y × z	152-1
x ≈ y × z	→	sequential	y	152-1
y		sequential	S	152-1
S		sequential	0	152-1
0		sequential	z ≈ S	152-1
z ≈ S		sequential	0	152-1
0		sequential	µ	152-1
µ		sequential	µ	152-1
µ		sequential	x	152-1
x	or	conjunctive	1 a prime number	152-1
x	is	attribute	1 a prime number	152-1
The set 7	if	constraint	it	153-1
The set 7	is	attribute	satisfiable	153-1
it	has	action	a model	153-1
Logical implication	and	conjunctive	equivalence	154-1
equivalence	to	constraint	the propositional case	154-1
equivalence	are now defined analogously	action	the propositional case	154-1
Sentence	logically implies	action	sentence ψ	154-2
sentence ψ	|=	sequential	ψ	154-2
sentence ψ	denoted	action	ψ	154-2
ψ	if	constraint	each interpretation	154-2
each interpretation		sequential	that	154-2
that	satisfies	action	ψ	154-2
that	also satisfies	action	ψ	154-2
There	are	attribute	many straightforward equivalences	154-3
many straightforward equivalences		sequential	e.g. ¬	154-3
e.g. ¬		sequential	¬ϕ	154-3
It	that	constraint	logical implication	155-1
It	is known	action	logical implication	155-1
logical implication	as	constraint	a decision problem	155-1
logical implication	considered	action	a decision problem	155-1
a decision problem	is	attribute	not recursive	155-1
One	of	constraint	the fundamental results	156-1
the fundamental results	of	constraint	mathematical logic	156-1
mathematical logic	is	attribute	the development	156-1
the development	of	constraint	effective procedures	156-1
effective procedures	for	constraint	logical equivalence	156-1
effective procedures	determining	action	logical equivalence	156-1
<B>	on	constraint	the notion	156-2
<B>	are based	action	the notion	156-2
the notion	of	constraint	proofs	156-2
proofs	and	conjunctive	they	156-2
they	provide	action	one way	156-2
one way	to	constraint	logical implication	156-2
one way	that	constraint	logical implication	156-2
one way	show	action	logical implication	156-2
logical implication	is	attribute	r.e	156-2
One style	of	constraint	proof	156-3
proof	to	constraint	Hilbert	156-3
proof	attributed	action	Hilbert	156-3
Hilbert	identifies	action	a family	156-3
a family	of	constraint	inference rules	156-3
inference rules	and	conjunctive	a family	156-3
a family	of	constraint	axioms	156-3
An example	of	constraint	an inference rule	156-4
an inference rule	is	attribute	modus ponens	156-4
modus ponens		sequential	which	156-4
which	that	constraint	formulas	156-4
which	from	constraint	formulas	156-4
which	states	action	formulas	156-4
formulas	and	conjunctive	we	156-4
formulas	→	sequential	we	156-4
we	may conclude	action	ψ	156-4
Examples	of	constraint	axioms	156-5
axioms	are	attribute	all tautologies	156-5
all tautologies	of	constraint	propositional logic	156-5
propositional logic	denotes	action	the formula	156-5
the formula	by	constraint	simultaneously t t	156-5
the formula	obtained	action	simultaneously t t	156-5
simultaneously t t	is	attribute	an arbitrary term	156-5
an arbitrary term	and	conjunctive	all occurrences	156-5
an arbitrary term	ϕxt replacing	action	all occurrences	156-5
all occurrences	of	constraint	ϕ	156-5
all occurrences	in	constraint	ϕ	156-5
ϕ	by	constraint	t	156-5
<B>	Given	action	a family	156-6
a family	of	constraint	inference rules	156-6
inference rules	and	conjunctive	axioms	156-6
axioms		sequential	a proof	156-6
a proof		sequential	that	156-6
that	set	action	7	156-6
7	of	constraint	sentences	156-6
sentences	implies	action	sentence	156-6
sentence	is	attribute	a finite sequence ψ0	156-6
a finite sequence ψ0	ψ	sequential	1	156-6
<B>	.	sequential	<B>	156-7
<B>	.	sequential	<B>	156-8
ψn	for	constraint	i	156-9
ψn	=	sequential	i	156-9
i		sequential	either ψi	156-9
either ψi	is	attribute	where an axiom	156-9
where an axiom	or	conjunctive	a member	156-9
a member	of	constraint	7	156-9
7	or	conjunctive	it	156-9
it	from	constraint	one	156-9
it	follows	action	one	156-9
one	of	constraint	the previous ψj	156-9
one	or	conjunctive	the previous ψj	156-9
the previous ψj	using	action	an inference rule	156-9
<B>	In	constraint	this case	156-10
this case		sequential	we	156-10
we	write	action	7 ⊢ ϕ	156-10
The soundness	and	conjunctive	completeness theorem	157-1
completeness theorem	of	constraint	Gödel	157-1
Gödel	that	constraint	modus ponens	157-1
Gödel	shows	action	modus ponens	157-1
Gödel	using	action	modus ponens	157-1
modus ponens	and	conjunctive	a specific set	157-1
a specific set	of	constraint	axioms	157-1
axioms		sequential	7 ϕ iff	157-1
7 ϕ iff		sequential	7 ⊢	157-1
7 ⊢	ϕ	sequential	<B>	157-1
This important link	between	constraint	the transfer	157-2
This important link	and	conjunctive	the transfer	157-2
This important link	permits	action	the transfer	157-2
the transfer	of	constraint	results	157-2
results	in	constraint	model theory	157-2
results	obtained	action	model theory	157-2
model theory		sequential	which	157-2
which	on	constraint	terpretations	157-2
which	in	constraint	terpretations	157-2
which	focuses primarily	action	terpretations	157-2
terpretations	and	conjunctive	models	157-2
models	and	conjunctive	proof theory	157-2
proof theory		sequential	which	157-2
which	on	constraint	primarily proofs	157-2
which	focuses	action	primarily proofs	157-2
<B>		sequential	a central issue	157-3
a central issue	in	constraint	the study	157-3
the study	of	constraint	relational database dependencies	157-3
relational database dependencies	see	action	Part	157-3
Part		sequential	C	157-3
C	been	action	has the search	157-3
has the search	for	constraint	sound	157-3
sound	and	conjunctive	proof systems	157-3
proof systems	for	constraint	subsets	157-3
subsets	of	constraint	order	157-3
order		sequential	logic	157-3
logic		sequential	that	157-3
that	to	constraint	natural families	157-3
that	correspond	action	natural families	157-3
natural families	of	constraint	constraints	157-3
model	and	conjunctive	proof	158-1
proof		sequential	The perspectives	158-1
The perspectives	to	constraint	two equivalent ways	158-1
The perspectives	lead	action	two equivalent ways	158-1
two equivalent ways	of	constraint	equality	158-1
two equivalent ways	incorporating	action	equality	158-1
equality	into	constraint	first order	158-1
first order		sequential	languages	158-1
<B>	Under	constraint	model	158-2
model		sequential	the approach	158-2
the approach		sequential	the equality predicate	158-2
the equality predicate	is given	action	the meaning	158-2
the meaning		sequential	u	158-2
u		sequential	u	158-2
u		sequential	u ∈ U }	158-2
u ∈ U }		sequential	normal equality	158-2
<B>	Under	constraint	proof	158-3
proof		sequential	the approach	158-3
the approach		sequential	a set	158-3
a set	of	constraint	equality axioms	158-3
equality axioms		sequential	EQL	158-3
EQL	is constructed	action	that	158-3
that	express	action	the intended meaning of	158-3
<B>	For	constraint	example	158-4
example		sequential	EQL	158-4
EQL	includes	action	the sentences	158-4
the sentences		sequential	∀x	158-4
∀x		sequential	y	158-4
y		sequential	z	158-4
z		sequential	x ≈ y ∧ y	158-4
<B>	that	constraint	the compactness theorem	159-1
<B>	although	constraint	the compactness theorem	159-1
<B>	Note	action	the compactness theorem	159-1
the compactness theorem	that	constraint	the 7	159-1
the compactness theorem	guarantees	action	the 7	159-1
the 7	in	constraint	the preceding paragraph	159-1
the preceding paragraph	has	action	a model	159-1
a model		sequential	that model	159-1
that model	is	attribute	not necessarily finite	159-1
7	Indeed may only have	action	infinite models	159-2
It	of	constraint	some solace	159-3
It	is	attribute	some solace	159-3
some solace	that	constraint	those infinite models	159-3
some solace	among	constraint	those infinite models	159-3
those infinite models		sequential	there	159-3
there	at	constraint	one	159-3
there	is surely	attribute	least	159-3
one		sequential	that	159-3
that	is	attribute	countable	159-3
whose elements	can be enumerated	action	a 1	159-3
a 1		sequential	a2	159-3
<B>	.	sequential	<B>	159-4
<B>	.	sequential	<B>	159-5
<B>	)	sequential	<B>	159-6
This technically useful result	is	attribute	Löwenheim	159-7
Löwenheim		sequential	Skolem	159-7
Skolem		sequential	the theorem	159-7
<B>	To	constraint	the compactness theorem	160-1
<B>	illustrate	action	the compactness theorem	160-1
the compactness theorem		sequential	we	160-1
we	that	constraint	there	160-1
we	show	action	there	160-1
there	is	attribute	no set 9	160-1
no set 9	of	constraint	sentences	160-1
sentences	defining	action	the notion	160-1
the notion	of	constraint	connectedness	160-1
connectedness	in	constraint	directed graphs	160-1
<B>	For	constraint	we	160-2
we	use	action	the language L	160-2
the language L	with	constraint	two constant symbols	160-2
two constant symbols	and	conjunctive	b	160-2
b	and	conjunctive	one binary relation symbol R	160-2
one binary relation symbol R		sequential	which	160-2
which	to	constraint	the edges	160-2
which	corresponds	action	the edges	160-2
the edges	of	constraint	a directed graph	160-2
<B>	In	constraint	addition	160-3
addition	because	constraint	we	160-3
we	with	constraint	first order	160-3
we	are working	action	first order	160-3
first order		sequential	general logic	160-3
general logic	both	conjunctive	graphs	160-3
general logic	and	conjunctive	graphs	160-3
graphs	may arise	action	<B>	160-3
<B>	that	constraint	9	160-4
<B>	Suppose now	action	9	160-4
9	is	attribute	a set	160-4
a set	of	constraint	sentences	160-4
sentences		sequential	that	160-4
that	states	action	that	160-4
that	and	conjunctive	b	160-4
b	that	constraint	there	160-4
b	are connected	action	there	160-4
there	is	attribute	a directed path	160-4
a directed path	from	constraint	a b	160-4
a directed path	to	constraint	a b	160-4
a b	in	constraint	R	160-4
<B>	#	sequential	σi	160-5
<B>	=	sequential	σi	160-5
<B>	Let	action	σi	160-5
σi		sequential	i	160-5
i	>	sequential	0	160-5
0		sequential	}	160-5
}		sequential	σi	160-5
σi	and	conjunctive	b	160-5
σi	where states	attribute	a	160-5
b	are	attribute	i	160-5
i	from	constraint	<B>	160-5
i	at least edges apart	attribute	each other	160-5
It	that	constraint	each finite subset ∪ #	161-1
It	is	attribute	clear	161-1
each finite subset ∪ #	of	constraint	9	161-1
9	is	attribute	satisfiable	161-1
<B>	By	constraint	the compactness theorem	161-2
the compactness theorem		sequential	second statement	161-2
second statement	that	constraint	it	161-2
second statement	9 ∪ #	sequential	it	161-2
second statement	implies	attribute	satisfiable	161-2
second statement	is	attribute	satisfiable	161-2
it	so has	action	a model	161-2
a model	say	action	I	161-2
<B>	In	constraint	I	161-3
I		sequential	there	161-3
there	is	attribute	no directed path	161-3
no directed path	between	constraint	the elements	161-3
the elements	of	constraint	the universe	161-3
the universe	by	constraint	b	161-3
the universe	and	conjunctive	b	161-3
the universe	identified	attribute	a	161-3
b	and	conjunctive	I	161-3
I	so |=	sequential	9	161-3
<B>	is	attribute	a contradiction	161-4
Specializations	to	constraint	Database Theory	162-1
The most obvious specialization	that	constraint	database theory	162-2
The most obvious specialization	is	attribute	database theory	162-2
database theory	on	constraint	the use	162-2
database theory	has not generally focused	action	the use	162-2
the use	of	constraint	functions	162-2
functions	on	constraint	data values	162-2
data values	as	constraint	a result	162-2
data values	and	conjunctive	a result	162-2
a result		sequential	it	162-2
it	generally omits	action	function symbols	162-2
function symbols	from	constraint	first order	162-2
first order		sequential	the languages	162-2
the languages	used	action	<B>	162-2
The two other fundamental specializations	are	attribute	the focus	162-3
the focus	on	constraint	finite models	162-3
finite models	and	conjunctive	the special use	162-3
the special use	of	constraint	constant symbols	162-3
Theoretical Background		sequential	Theoretical Background	163-1
The notion	of	constraint	logical implication	164-1
logical implication	for	constraint	finite interpretations |=fin	164-1
finite interpretations |=fin	to	constraint	the usual logical implication	164-1
finite interpretations |=fin	usually denoted	attribute	not equivalent	164-1
finite interpretations |=fin	is	attribute	not equivalent	164-1
<B>	by	constraint	the compactness theorem	164-2
<B>	is most easily seen	action	the compactness theorem	164-2
<B>	considering	action	the compactness theorem	164-2
<B>	Let	action	7	164-3
7	=	sequential	σi	164-3
σi		sequential	i	164-3
i	>	sequential	0	164-3
0		sequential	}	164-3
}		sequential	σi	164-3
σi	that	constraint	there	164-3
σi	where states	action	there	164-3
there	at	constraint	i distinct elements	164-3
there	are	attribute	least	164-3
i distinct elements	in	constraint	the universe	164-3
the universe	of	constraint	discourse	164-3
<B>	by	constraint	Then compactness	164-4
Then compactness		sequential	7	164-4
7	by	constraint	the definition	164-4
7	but	conjunctive	the definition	164-4
7	|=	sequential	the definition	164-4
the definition	of	constraint	finite interpretation	164-4
finite interpretation		sequential	7 |=fin	164-4
7 |=fin		sequential	<B>	164-4
The final specialization	of	constraint	database theory	165-1
database theory	concerns	action	assumptions	165-1
assumptions	about	constraint	the universe	165-1
assumptions	made	action	the universe	165-1
the universe	of	constraint	discourse	165-1
discourse	and	conjunctive	the use	165-1
the use	of	constraint	constant symbols	165-1
<B>	throughout	constraint	this book	165-2
<B>	of	constraint	this book	165-2
this book		sequential	we	165-2
we	Indeed use	action	a fixed countably infinite set	165-2
a fixed countably infinite set	of	constraint	constants	165-2
constants		sequential	denoted dom	165-2
denoted dom	for	constraint	domain elements	165-2
<B>		sequential	the focus	166-1
the focus	on	constraint	finite Herbrand interpretations	166-1
the focus	is	attribute	finite Herbrand interpretations	166-1
finite Herbrand interpretations	over	constraint	dom	166-1
<B>	In	constraint	distinct constants	167-1
<B>	for	constraint	distinct constants	167-1
distinct constants		sequential	c	167-1
c	and	conjunctive	c′	167-1
c′		sequential	all interpretations	167-1
all interpretations		sequential	that	167-1
that	are considered	attribute	satisfy	167-1
Most proofs	in	constraint	database theory	168-1
database theory	involving	action	first order	168-1
first order		sequential	the predicate calculus	168-1
the predicate calculus	on	constraint	model theory	168-1
the predicate calculus	are based	action	model theory	168-1
model theory	because of	constraint	primarily the emphasis	168-1
primarily the emphasis	on	constraint	finite models	168-1
finite models	because	constraint	the link	168-1
finite models	and	conjunctive	the link	168-1
the link	between	constraint	|=fin	168-1
|=fin	and	conjunctive	<B>	168-1
|=fin	does not hold	action	<B>	168-1
It	to	constraint	a mechanism	168-2
It	is	attribute	thus informative	168-2
It	identify	action	a mechanism	168-2
a mechanism	for	constraint	proof	168-2
a mechanism	using	action	proof	168-2
proof		sequential	traditional techniques	168-2
traditional techniques	within	constraint	the context	168-2
the context	of	constraint	database theory	168-2
<B>	For	constraint	this discussion	168-3
this discussion	consider	action	first order	168-3
first order		sequential	a language	168-3
a language	with	constraint	set dom	168-3
set dom	of	constraint	constant symbols	168-3
constant symbols	and	conjunctive	symbols	168-3
constant symbols	predicate	action	symbols	168-3
symbols		sequential	R1	168-3
<B>	.	sequential	<B>	168-4
<B>	.	sequential	<B>	168-5
Rn		sequential	Rn	168-6
<B>	As	constraint	Chapter 3	168-7
<B>	in	constraint	Chapter 3	168-7
<B>	will be seen	action	Chapter 3	168-7
Chapter 3		sequential	a database instance	168-7
a database instance	is	attribute	a finite Herbrand interpretation I	168-7
a finite Herbrand interpretation I	of	constraint	this language	168-7
<B>	Following	action	Rei84	168-8
Rei84	a family #	sequential	I	168-8
I	of	constraint	sentences	168-8
sentences	with	constraint	I	168-8
sentences	is associated	action	I	168-8
This family	includes	action	the axioms	168-9
the axioms	of	constraint	equality	168-9
equality	and	conjunctive	Atoms	168-9
equality	mentioned earlier	action	Atoms	168-9
Atoms		sequential	Ri	168-9
Ri	$	sequential	<B>	168-9
i Extension axioms	$ x	sequential	Ri	169-1
Ri	$ x	sequential	$ terms	169-1
Ri	↔	sequential	$ terms	169-1
Ri	$ x	sequential	$ terms	169-1
Ri	≈	sequential	$ terms	169-1
Ri	$ x	sequential	$ terms	169-1
Ri	≈	sequential	$ terms	169-1
Unique Name axioms		sequential	¬c	170-1
¬c		sequential	c′	170-1
c′	for	constraint	each distinct pair c	170-1
each distinct pair c		sequential	c′	170-1
c′	of	constraint	constants	170-1
constants	in	constraint	I	170-1
constants	occurring	action	I	170-1
Domain Closure axiom		sequential	∀x	171-1
∀x		sequential	x	171-1
x		sequential	c1	171-1
c1		sequential	∨	171-1
∨		sequential	x cn	171-1
x cn		sequential	c1	171-1
<B>	.	sequential	<B>	171-2
<B>	.	sequential	<B>	171-3
cn	is	attribute	a listing	171-4
a listing	of	constraint	all constants	171-4
all constants	in	constraint	I	171-4
all constants	occurring	action	I	171-4
The first two sets	of	constraint	sentences	172-1
sentences	of	constraint	an extended relational theory	172-1
an extended relational theory	express	action	the specific contents	172-1
the specific contents	of	constraint	the relations	172-1
the relations	predicate	action	symbols	172-1
symbols	of	constraint	I	172-1
the Extension sentences	that	constraint	not necessarily Herbrand	172-2
the Extension sentences	for	constraint	not necessarily Herbrand	172-2
the Extension sentences	Importantly ensure	action	not necessarily Herbrand	172-2
not necessarily Herbrand		sequential	any interpretation J satisfying	172-2
any interpretation J satisfying		sequential	# I	172-2
# I		sequential	an n-tuple	172-2
an n-tuple	in	constraint	RJ iff	172-2
an n-tuple	is	attribute	RJ iff	172-2
RJ iff		sequential	it	172-2
it	equals	action	one	172-2
one	of	constraint	the n-tuples	172-2
the n-tuples	in	constraint	RI	172-2
The Unique Name axiom	that	constraint	no pair	172-3
The Unique Name axiom	ensures	action	no pair	172-3
no pair	of	constraint	i i distinct constants	172-3
i i distinct constants	to	constraint	the same element	172-3
i i distinct constants	is mapped	action	the same element	172-3
the same element	in	constraint	the universe	172-3
the universe	of	constraint	J	172-3
J	and	conjunctive	the Domain Closure axiom	172-3
the Domain Closure axiom	that	constraint	each element	172-3
the Domain Closure axiom	ensures	action	each element	172-3
each element	of	constraint	the universe	172-3
the universe	of	constraint	J	172-3
J	in	constraint	I	172-3
J	equals	action	I	172-3
J	some constant occurring	action	I	172-3
<B>	For	constraint	all intents	172-4
all intents	and	conjunctive	purposes	172-4
purposes		sequential	any interpretation J	172-4
any interpretation J		sequential	that	172-4
that		sequential	models	172-4
models	to	constraint	I	172-4
models	# I	sequential	I	172-4
models	is	attribute	isomorphic	172-4
I		sequential	modulo	172-4
modulo	under	constraint	equivalence classes	172-4
modulo	condensing	action	equivalence classes	172-4
equivalence classes	by	constraint	≈J	172-4
equivalence classes	induced	action	≈J	172-4
the following link	with	constraint	conventional logical implication	172-5
conventional logical implication	Importantly now holds	action	<B>	172-5
The perspective	through	constraint	this connection	172-6
The perspective	obtained	action	this connection	172-6
this connection	with	constraint	logic	172-6
logic	to	constraint	the conventional relational model	172-6
logic	is	attribute	useful	172-6
logic	when attempting	action	the conventional relational model	172-6
logic	extend	action	the conventional relational model	172-6
the conventional relational model	to	constraint	incomplete information	172-6
the conventional relational model	incorporate	action	incomplete information	172-6
the conventional relational model	so called	action	incomplete information	172-6
incomplete information	as	constraint	Chapter 19	172-6
incomplete information	in	constraint	Chapter 19	172-6
incomplete information	discussed	action	Chapter 19	172-6
The Extension axioms	to	constraint	the intuition	173-1
The Extension axioms	correspond	action	the intuition	173-1
the intuition		sequential	that	173-1
that	if	constraint	it	173-1
that	a tuple $	sequential	it	173-1
it	in	constraint	R	173-1
it	is explicitly included	action	R	173-1
R	by	constraint	the database instance	173-1
A more general formulation	of	constraint	this intuition	173-2
this intuition	by	constraint	the closed world assumption	173-2
this intuition	is given	action	the closed world assumption	173-2
the closed world assumption		sequential	CWA	173-2
CWA		sequential	Rei78	173-2
<B>	In	constraint	its most general formulation	173-3
its most general formulation		sequential	the CWA	173-3
the CWA	is	attribute	an inference rule	173-3
an inference rule		sequential	that	173-3
that	in	constraint	proof	173-3
that	is used	action	proof	173-3
proof		sequential	contexts	173-3
<B>	of	constraint	sentences	173-4
<B>	a set #	sequential	sentences	173-4
<B>	Given	action	sentences	173-4
sentences	describing	attribute	possibly nonconventional	173-4
a database instance		sequential	the CWA	173-4
the CWA	that	constraint	one	173-4
the CWA	states	action	one	173-4
one	can infer	action	a negated atom R	173-4
a negated atom R	from	constraint	order	173-4
a negated atom R	$	sequential	order	173-4
a negated atom R	#	sequential	order	173-4
a negated atom R	using	attribute	first	173-4
order		sequential	conventional logic	173-4
<B>	In	constraint	the case	173-5
the case	#	sequential	where an extended relational theory	173-5
the case	is	attribute	where an extended relational theory	173-5
where an extended relational theory	gives	action	no added information	173-5
no added information	in	constraint	other contexts	173-5
no added information	but	conjunctive	other contexts	173-5
other contexts		sequential	deductive databases	173-5
deductive databases		sequential	it	173-5
it	does	action	<B>	173-5
The CWA	in	constraint	spirit	173-6
The CWA	is	attribute	related	173-6
spirit	to	constraint	the negation	173-6
the negation	as	constraint	failure rule	173-6
failure rule	of	constraint	Cla	173-6
Cla		sequential	78	173-6
What	is	attribute	a relation	174-1
Vittorio		sequential	Vittorio	175-1
Sergio		sequential	Sergio	176-1
Riccardo		sequential	Riccardo	177-1
The specification	of	constraint	structure	178-1
structure	and	conjunctive	constraints	178-1
constraints	is done	action	a data definition language	178-1
constraints	using	action	a data definition language	178-1
a data definition language		sequential	DDL	178-1
DDL	and	conjunctive	the specification	178-1
the specification	of	constraint	manipulation	178-1
manipulation	is done	action	a data manipulation language	178-1
manipulation	using	action	a data manipulation language	178-1
a data manipulation language		sequential	DML	178-1
The most prominent structures		sequential	that	178-2
that	for	constraint	databases	178-2
that	have been used	action	databases	178-2
databases	to	constraint	date	178-2
date	are	attribute	graphs	178-2
graphs	in	constraint	the network	178-2
the network	and	conjunctive	object	178-2
object	oriented	action	models	178-2
models		sequential	trees	178-2
trees	in	constraint	the hierarchical model	178-2
the hierarchical model	and	conjunctive	relations	178-2
relations	in	constraint	the relational model	178-2
DMLs	provide	action	two fundamental capabilities	179-1
two fundamental capabilities	to	constraint	the extraction	179-1
two fundamental capabilities	querying	action	the extraction	179-1
two fundamental capabilities	support	action	the extraction	179-1
the extraction	of	constraint	data	179-1
data	from	constraint	the current database	179-1
the current database	to	constraint	the modification	179-1
the current database	and	conjunctive	the modification	179-1
the current database	updating	action	the modification	179-1
the current database	support	action	the modification	179-1
the modification	of	constraint	the database state	179-1
There	is	attribute	a rich theory	180-1
a rich theory	on	constraint	the topic	180-1
the topic	of	constraint	relational databases	180-1
the topic	querying	action	relational databases	180-1
relational databases		sequential	that	180-1
that	includes	action	several languages	180-1
several languages	on	constraint	widely different paradigms	180-1
several languages	based	action	widely different paradigms	180-1
This theory	is	attribute	the focus	180-2
the focus	of	constraint	Parts B	180-2
Parts B		sequential	D	180-2
D	and	conjunctive	E	180-2
E	and	conjunctive	portions	180-2
portions	of	constraint	Part F	180-2
Part F	of	constraint	this book	180-2
The theory	of	constraint	database updates	180-3
database updates	has received	action	considerably less attention	180-3
considerably less attention	on	constraint	Part F	180-3
considerably less attention	in	constraint	Part F	180-3
considerably less attention	and	conjunctive	Part F	180-3
considerably less attention	is touched	action	Part F	180-3
The term relational model	is	attribute	actually rather vague	181-1
<B>	As	constraint	Codd	181-2
<B>	in	constraint	Codd	181-2
<B>	introduced	action	Codd	181-2
Codd		sequential	seminal article	181-2
seminal article		sequential	this term	181-2
this term	to	constraint	a specific data model	181-2
this term	refers	action	a specific data model	181-2
a specific data model	with	constraint	relations	181-2
relations	as	constraint	data structures	181-2
data structures		sequential	an algebra	181-2
an algebra	for	constraint	queries	181-2
an algebra	specifying	action	queries	181-2
queries	and	conjunctive	no mechanisms	181-2
no mechanisms	for	constraint	updates	181-2
no mechanisms	expressing	action	updates	181-2
updates	or	conjunctive	constraints	181-2
Subsequent articles	by	constraint	Codd	182-1
Codd	introduced	action	a second query language	182-1
a second query language	on	constraint	the predicate calculus	182-1
a second query language	based	action	the predicate calculus	182-1
the predicate calculus	of	constraint	order	182-1
order		sequential	logic	182-1
logic	to	constraint	the algebra	182-1
logic	to	constraint	the algebra	182-1
logic	showed	attribute	this	182-1
logic	be	attribute	equivalent	182-1
the algebra	and	conjunctive	the first integrity constraints	182-1
the algebra	introduced	action	the first integrity constraints	182-1
the first integrity constraints	for	constraint	the relational model	182-1
the relational model		sequential	functional dependencies	182-1
<B>		sequential	researchers	182-2
researchers	in	constraint	database systems	182-2
database systems	implemented	action	languages	182-2
languages	on	constraint	the algebra	182-2
languages	based	action	the algebra	182-2
the algebra	and	conjunctive	calculus	182-2
calculus	to	constraint	update operators	182-2
calculus	extended	action	update operators	182-2
calculus	include	action	update operators	182-2
update operators	to	constraint	practically motivated features	182-2
update operators	and	conjunctive	practically motivated features	182-2
update operators	include	action	practically motivated features	182-2
practically motivated features		sequential	arithmetic operators	182-2
arithmetic operators		sequential	aggregate operators	182-2
aggregate operators	and	conjunctive	sorting capabilities	182-2
Researchers	in	constraint	database theory	182-3
database theory	developed	action	a number	182-3
a number	of	constraint	variations	182-3
variations	on	constraint	the algebra	182-3
the algebra	and	conjunctive	calculus	182-3
calculus	with	constraint	varying expressive power	182-3
varying expressive power	and	conjunctive	the paradigm	182-3
varying expressive power	adapted	action	the paradigm	182-3
the paradigm	of	constraint	logic programming	182-3
logic programming	to	constraint	a third approach	182-3
logic programming	provide	action	a third approach	182-3
a third approach	to	constraint	relational databases	182-3
a third approach	querying	action	relational databases	182-3
The story	of	constraint	integrity constraints	182-4
integrity constraints	for	constraint	the relational model	182-4
the relational model	is	attribute	similar	182-4
The term relational model	to	constraint	the broad class	182-5
The term relational model	to	constraint	the broad class	182-5
The term relational model	has thus come	action	the broad class	182-5
The term relational model	refer	action	the broad class	182-5
the broad class	of	constraint	database models	182-5
database models		sequential	that	182-5
that	have	action	relations	182-5
relations	as	constraint	the data structure	182-5
the data structure	and	conjunctive	that	182-5
that	of	constraint	the query capabilities	182-5
that	or	conjunctive	the query capabilities	182-5
that	incorporate	attribute	some	182-5
the query capabilities		sequential	update capabilities	182-5
update capabilities	and	conjunctive	integrity constraints	182-5
integrity constraints		sequential	28	182-5
28	mentioned earlier	action	<B>	182-5
<B>	In	constraint	this book	182-6
this book		sequential	we	182-6
we	with	constraint	primarily the relational model	182-6
we	are	attribute	concerned	182-6
primarily the relational model	in	constraint	this broad sense	182-6
Relations	are	attribute	simple data structures	183-1
<B>	As	constraint	a result	183-2
a result		sequential	it	183-2
it	to	constraint	the conceptual underpinnings	183-2
it	is	attribute	easy	183-2
it	understand	action	the conceptual underpinnings	183-2
the conceptual underpinnings	of	constraint	the relational model	183-2
the relational model	thus making	action	relational databases	183-2
relational databases	to	constraint	a broad audience	183-2
a broad audience	of	constraint	end users	183-2
A second advantage	of	constraint	this simplicity	183-3
this simplicity	that	constraint	declarative languages	183-3
this simplicity	yet	conjunctive	declarative languages	183-3
this simplicity	is	attribute	clean	183-3
declarative languages	to	constraint	relations	183-3
declarative languages	can be used	action	relations	183-3
declarative languages	manipulate	action	relations	183-3
<B>	By	constraint	we	183-4
we	that	constraint	a query program	183-4
we	/	sequential	a query program	183-4
we	mean	action	a query program	183-4
a query program	in	constraint	high level	183-4
a query program	is specified	action	high level	183-4
high level		sequential	a manner	183-4
a manner	that	constraint	an efficient execution	183-4
a manner	and	conjunctive	an efficient execution	183-4
an efficient execution	of	constraint	the program	183-4
the program	to	constraint	exactly its specification	183-4
the program	does not have	action	exactly its specification	183-4
the program	follow	action	exactly its specification	183-4
the important practical issues	of	constraint	compilation	183-5
compilation	and	conjunctive	optimization	183-5
optimization	of	constraint	queries	183-5
queries	to	constraint	relational databases	183-5
queries	to	constraint	relational databases	183-5
queries	Thus had	action	relational databases	183-5
queries	be overcome	action	relational databases	183-5
queries	make	action	relational databases	183-5
relational databases		sequential	a reality	183-5
<B>	Because of	constraint	its simplicity	184-1
its simplicity		sequential	the relational model	184-1
the relational model	has provided	action	an excellent framework	184-1
an excellent framework	for	constraint	the first generation	184-1
the first generation	of	constraint	theoretical research	184-1
theoretical research	into	constraint	the properties	184-1
the properties	of	constraint	databases	184-1
Fundamental aspects	of	constraint	data manipulation	184-2
data manipulation	and	conjunctive	integrity constraints	184-2
integrity constraints	in	constraint	a context	184-2
integrity constraints	and	conjunctive	a context	184-2
integrity constraints	have been exposed	action	a context	184-2
integrity constraints	studied	action	a context	184-2
a context	in	constraint	which	184-2
which		sequential	the peculiarities	184-2
the peculiarities	of	constraint	the data model itself	184-2
the data model itself	have	action	relatively little impact	184-2
This research	provides	action	a strong foundation	184-3
a strong foundation	for	constraint	the study	184-3
the study	of	constraint	other database models	184-3
other database models	because	constraint	many theoretical issues	184-3
many theoretical issues	to	constraint	other models	184-3
other models	within	constraint	the relational model	184-3
other models	can be addressed effectively	action	the relational model	184-3
the relational model	because	constraint	it	184-3
the relational model	and	conjunctive	it	184-3
it	second provides	action	a variety	184-3
a variety	of	constraint	tools	184-3
tools		sequential	techniques	184-3
techniques	and	conjunctive	research directions	184-3
research directions		sequential	that	184-3
that	to	constraint	the other models	184-3
that	can be used	action	the other models	184-3
that	understand more deeply	action	the other models	184-3
<B>	In	constraint	this short chapter	185-1
this short chapter		sequential	we	185-1
we	present	action	formal definitions	185-1
formal definitions	for	constraint	the data structure	185-1
the data structure	of	constraint	the relational model	185-1
Theoretical research	on	constraint	the model	185-2
the model	out of	constraint	three different perspectives	185-2
the model	has grown	action	three different perspectives	185-2
three different perspectives		sequential	one	185-2
one	to	constraint	the natural usage	185-2
one	corresponding most closely	action	the natural usage	185-2
the natural usage	of	constraint	relations	185-2
relations	in	constraint	databases	185-2
databases	from	constraint	mathematical logic	185-2
databases	stemming	action	mathematical logic	185-2
mathematical logic	from	constraint	logic programming	185-2
mathematical logic	and	conjunctive	logic programming	185-2
mathematical logic	stemming	action	logic programming	185-2
<B>	Because	constraint	important benefits	185-3
<B>	of	constraint	important benefits	185-3
<B>	and	conjunctive	important benefits	185-3
<B>	provides	attribute	intuitive	185-3
important benefits		sequential	we	185-3
we	introduce	action	notation	185-3
notation		sequential	that	185-3
that	but	conjunctive	the formulations	185-3
that	encompasses	attribute	different	185-3
the formulations	of	constraint	them	185-3
the formulations	reflecting	attribute	each	185-3
The Structure	of	constraint	the Relational Model	186-1
We	introduce now	action	some informal terminology	187-1
some informal terminology	to	constraint	the intuition	187-1
some informal terminology	provide	action	the intuition	187-1
the intuition	behind	constraint	the formal definitions	187-1
the formal definitions		sequential	that	187-1
that	follow	action	<B>	187-1
Each table	is called	action	a relation	187-2
a relation	and	conjunctive	it	187-2
it	has	action	a name	187-2
a name		sequential	e.g. Movies	187-2
The columns	also have	action	names	187-3
names	called	action	attributes	187-3
attributes		sequential	e.g	187-3
e.g		sequential	Title	187-3
Each line	in	constraint	a table	187-4
a table	is	attribute	a tuple	187-4
a tuple	or	conjunctive	record	187-4
The entries	of	constraint	tuples	187-5
tuples	from	constraint	sets	187-5
tuples	are taken	action	sets	187-5
sets	of	constraint	constants	187-5
constants	called	action	domains	187-5
domains		sequential	that	187-5
that	for	constraint	example	187-5
that	include	action	example	187-5
example		sequential	the sets	187-5
the sets	of	constraint	integers	187-5
integers		sequential	strings	187-5
strings	and	conjunctive	Boolean values	187-5
we	between	constraint	the database schema	187-6
we	Finally distinguish	action	the database schema	187-6
the database schema		sequential	which	187-6
which	specifies	action	the structure	187-6
the structure	of	constraint	the database	187-6
the database	and	conjunctive	the database instance	187-6
the database instance		sequential	which	187-6
which	specifies	action	its actual content	187-6
<B>	to	constraint	the standard distinction	187-7
<B>	is	attribute	analogous	187-7
the standard distinction	between	constraint	type	187-7
type	and	conjunctive	value	187-7
value	in	constraint	programming languages	187-7
value	found	action	programming languages	187-7
programming languages		sequential	an 1 Pariscope	187-7
an 1 Pariscope	is	attribute	a weekly publication	187-7
a weekly publication		sequential	that	187-7
that	lists	action	the cultural events	187-7
the cultural events	in	constraint	Paris	187-7
the cultural events	occurring	action	Paris	187-7
Paris	and	conjunctive	environs	187-7
The Relational Model Movies		sequential	Title Director	188-1
Title Director		sequential	The Trouble	188-1
The Trouble	with	constraint	Harry Hitchcock Gwenn	188-1
Harry Hitchcock Gwenn		sequential	The Trouble	188-1
The Trouble	with	constraint	Harry Hitchcock Forsythe	188-1
Harry Hitchcock Forsythe		sequential	The Trouble	188-1
The Trouble	with	constraint	Harry Hitchcock MacLaine	188-1
Harry Hitchcock MacLaine		sequential	The Trouble	188-1
The Trouble	with	constraint	Harry Hitchcock Hitchcock Cries	188-1
Harry Hitchcock Hitchcock Cries	and	conjunctive	Whispers	188-1
Whispers		sequential	Bergman Cries	188-1
Bergman Cries	and	conjunctive	Whispers	188-1
Whispers		sequential	Bergman Ullman Location	188-1
Bergman Ullman Location		sequential	Sylwan Cries Bergman	188-1
Sylwan Cries Bergman	and	conjunctive	Whispers	188-1
Whispers		sequential	Thulin Cries	188-1
Thulin Cries	and	conjunctive	Whispers	188-1
Whispers		sequential	Bergman	188-1
Bergman		sequential	Theater Phone Number Gaumont Opéra Saint André des Arts Le Champo Georges V Les 7 Montparnassiens Pariscope Theater Title Schedule	188-1
Theater Phone Number Gaumont Opéra Saint André des Arts Le Champo Georges V Les 7 Montparnassiens Pariscope Theater Title Schedule		sequential	Gaumont Opéra Cries	188-1
Gaumont Opéra Cries	and	conjunctive	Whispers Saint André des Arts	188-1
Whispers Saint André des Arts		sequential	The Trouble	188-1
The Trouble	with	constraint	Harry Georges V	188-1
Harry Georges V		sequential	Cries	188-1
Cries	and	conjunctive	Whispers	188-1
Whispers		sequential	Les	188-1
Les		sequential	7 Montparnassiens Cries	188-1
7 Montparnassiens Cries	and	conjunctive	Whispers Figure	188-1
Whispers Figure		sequential	3.1	188-1
We	on	constraint	the formal definitions	189-1
We	now embark	action	the formal definitions	189-1
We	that	constraint	a countably infinite set att	189-2
We	assume	action	a countably infinite set att	189-2
a countably infinite set att	of	constraint	attributes	189-2
attributes	is fixed	action	<B>	189-2
<B>	For	constraint	a technical reason	189-3
a technical reason	shall become	attribute	apparent shortly	189-3
we	that	constraint	there	189-3
we	assume	action	there	189-3
there	is	attribute	a total order ≤att	189-3
a total order ≤att	on	constraint	att	189-3
a set U	of	constraint	attributes	189-4
attributes	When is listed	action	it	189-4
it	that	constraint	the elements	189-4
it	is assumed	action	the elements	189-4
the elements	of	constraint	U	189-4
U	are written	action	≤att	189-4
U	according to	action	≤att	189-4
≤att	unless	constraint	<B>	189-4
≤att	otherwise specified	action	<B>	189-4
<B>	For	constraint	the theoretical development	190-1
<B>	of	constraint	the theoretical development	190-1
the theoretical development		sequential	it	190-1
it	to	constraint	the same domain	190-1
it	suffices	action	the same domain	190-1
it	use	action	the same domain	190-1
the same domain	of	constraint	values	190-1
values	for	constraint	the attributes	190-1
values	of	constraint	the attributes	190-1
we	Thus now fix	action	a countably infinite set dom	190-2
a countably infinite set dom	from	constraint	att	190-2
att	called	action	the underlying domain	190-2
A constant	is	attribute	an element	190-3
an element	of	constraint	dom	190-3
different attributes	When should have	action	distinct domains	190-4
distinct domains		sequential	we	190-4
we	assume	action	a mapping Dom	190-4
a mapping Dom	on	constraint	att	190-4
att		sequential	Dom	190-4
Dom		sequential	A	190-4
A	is	attribute	where a set	190-4
where a set	called	action	the domain	190-4
the domain	of	constraint	A	190-4
We	assume	action	a countably infinite set relname	191-1
a countably infinite set relname	of	constraint	relation names	191-1
relation names	from	constraint	the previous sets	191-1
<B>	In	constraint	practice	191-2
practice		sequential	the structure	191-2
the structure	of	constraint	a table	191-2
a table	by	constraint	a relation name	191-2
a table	is given	action	a relation name	191-2
a relation name	and	conjunctive	a set	191-2
a set	of	constraint	attributes	191-2
<B>	To	constraint	the notation	191-3
<B>	simplify	action	the notation	191-3
the notation	in	constraint	the theoretical treatment	191-3
the theoretical treatment		sequential	we	191-3
we	now associate	action	a sort	191-3
a sort		sequential	finite set	191-3
finite set	of	constraint	attributes	191-3
attributes	to	constraint	each relation name	191-3
An analogous approach	in	constraint	logic	191-4
An analogous approach	is usually taken	action	logic	191-4
<B>	In	constraint	we	191-5
we	that	constraint	there	191-5
we	assume	action	there	191-5
there	is	attribute	a function sort	191-5
a function sort	from	constraint	relname	191-5
relname	to	constraint	Pfin	191-5
Pfin		sequential	att	191-5
att		sequential	the finitary powerset	191-5
the finitary powerset	of	constraint	att	191-5
att		sequential	the family	191-5
the family	of	constraint	finite subsets	191-5
finite subsets	of	constraint	att	191-5
It	that	constraint	sort	191-6
It	is assumed	action	sort	191-6
sort	has	action	the property	191-6
the property		sequential	that	191-6
that	for	constraint	each finite set U	191-6
each finite set U	of	constraint	attributes	191-6
attributes		sequential	sort −1	191-6
sort −1		sequential	U	191-6
U	is	attribute	infinite	191-6
<B>	allows	action	us	191-7
us	to	constraint	many relation names	191-7
us	as	constraint	many relation names	191-7
us	use	action	many relation names	191-7
many relation names	of	constraint	a given sort	191-7
a given sort	as	constraint	<B>	191-7
a given sort	desired	action	<B>	191-7
The sort	of	constraint	a relation name	191-8
a relation name	is	attribute	simply sort	191-8
simply sort		sequential	R	191-8
The arity	of	constraint	a relation name R	191-9
a relation name R	is	attribute	arity	191-9
arity		sequential	R	191-9
R	=	sequential	sort	191-9
sort		sequential	R	191-9
<B>	to	constraint	sort	192-1
<B>	that	constraint	sort	192-1
<B>	indicate	action	sort	192-1
sort		sequential	R	192-1
R	=	sequential	U	192-1
U	or	conjunctive	R	192-1
R		sequential	n	192-1
n	to	constraint	arity	192-1
n	that	constraint	arity	192-1
n	indicate	action	arity	192-1
arity		sequential	R	192-1
R	= n	sequential	<B>	192-1
<B>	might be written	action	R	192-2
R	=	sequential	R1	192-2
R1		sequential	U1	192-2
<B>	.	sequential	<B>	192-3
<B>	.	sequential	<B>	192-4
Rn		sequential	Un	192-5
Un	to	constraint	the relation schemas	192-5
Un	indicate	action	the relation schemas	192-5
the relation schemas	in	constraint	R	192-5
<B>	For	constraint	example	193-1
example		sequential	the database schema CINEMA	193-1
the database schema CINEMA	for	constraint	the database	193-1
the database	in	constraint	Fig	193-1
the database	shown	action	Fig	193-1
3.1	by	constraint	CINEMA	193-2
3.1	is defined	action	CINEMA	193-2
CINEMA	=	sequential	Movies	193-2
Movies		sequential	Location	193-2
Location		sequential	Pariscope	193-2
Pariscope		sequential	}	193-2
}		sequential	relation names	193-2
relation names		sequential	Movies	193-2
Movies		sequential	Location	193-2
Location	and	conjunctive	Pariscope	193-2
Pariscope	where have	action	the following sorts	193-2
the following sorts		sequential	sort	193-2
sort		sequential	Movies	193-2
Movies		sequential	sort	193-2
sort		sequential	Location	193-2
Location	=	sequential	Theater	193-2
Theater		sequential	Address	193-2
Address		sequential	Phone Number } sort	193-2
Phone Number } sort		sequential	Pariscope	193-2
Pariscope	=	sequential	Theater	193-2
Theater		sequential	Title	193-2
Title		sequential	Schedule	193-2
Schedule		sequential	}	193-2
We	often omit	action	commas	194-1
commas	and	conjunctive	set brackets	194-1
set brackets	in	constraint	sets	194-1
sets	of	constraint	attributes	194-1
<B>	For	constraint	example	194-2
example		sequential	we	194-2
we	may write	action	sort	194-2
sort		sequential	Pariscope	194-2
Pariscope		sequential	Theater Title Schedule	194-2
The formalism		sequential	that	195-1
that	for	constraint	the relational model	195-1
that	has emerged	action	the relational model	195-1
the relational model	because	constraint	it	195-1
the relational model	is	attribute	somewhat eclectic	195-1
it	with	constraint	several other areas	195-1
it	is intimately connected	action	several other areas	195-1
several other areas		sequential	that	195-1
that	have	action	their own terminology	195-1
their own terminology		sequential	logic	195-1
logic	and	conjunctive	logic	195-1
logic		sequential	programming	195-1
<B>	Because	constraint	the slightly different formalisms	195-2
the slightly different formalisms	are well entrenched	action	we	195-2
we	to	constraint	them	195-2
we	do not attempt	action	them	195-2
we	replace	action	them	195-2
them	with	constraint	a single unified notation	195-2
we	Instead will allow	action	the coexistence	195-3
the coexistence	of	constraint	the different notations	195-3
the different notations		sequential	the reader	195-3
the reader	should have	action	no difficulty	195-3
no difficulty	with	constraint	the minor variations	195-3
no difficulty	dealing	action	the minor variations	195-3
there	Thus will be	action	two forks	196-1
two forks	in	constraint	the road	196-1
the road		sequential	that	196-1
that	to	constraint	formulations	196-1
that	but	conjunctive	formulations	196-1
that	lead	attribute	different	196-1
formulations	of	constraint	the relational model	196-1
The first fork	in	constraint	the road	196-2
the road	to	constraint	the relational model	196-2
the road	defining	action	the relational model	196-2
the relational model	of	constraint	a philosophical nature	196-2
the relational model	is	attribute	a philosophical nature	196-2
<B>	Are	action	the attribute names	196-3
the attribute names	with	constraint	different relation columns	196-3
the attribute names	associated	action	different relation columns	196-3
different relation columns		sequential	<B>	196-3
<B>	versus	constraint	Unnamed Perspectives	197-1
<B>	Named	action	Unnamed Perspectives	197-1
<B>	Under	constraint	the unnamed The Relational Model perspective	197-2
the unnamed The Relational Model perspective		sequential	the specific attributes	197-2
the specific attributes	in	constraint	the sort	197-2
the sort	of	constraint	a relation name	197-2
a relation name	and	conjunctive	only the arity	197-2
a relation name	are ignored	action	only the arity	197-2
only the arity	of	constraint	a relation schema	197-2
a relation schema	to	constraint	query languages	197-2
a relation schema	is	attribute	available	197-2
<B>	In	constraint	the named perspective	198-1
the named perspective		sequential	it	198-1
it	to	constraint	tuples	198-1
it	is	attribute	natural	198-1
it	view	action	tuples	198-1
tuples	as	constraint	functions	198-1
a tuple	over	constraint	a finite set U	198-2
a finite set U	of	constraint	attributes	198-2
attributes	over	constraint	a relation schema R	198-2
attributes	or	conjunctive	a relation schema R	198-2
a relation schema R		sequential	U	198-2
U	is	attribute	a total mapping	198-2
a total mapping		sequential	More precisely u	198-2
More precisely u	from	constraint	U	198-2
U	to	constraint	dom	198-2
<B>	In	constraint	this case	198-3
this case		sequential	the sort	198-3
the sort	of	constraint	u	198-3
u	is	attribute	U	198-3
U	and	conjunctive	it	198-3
it	has	action	arity	198-3
arity		sequential	|U	198-3
Tuples	in	constraint	a linear syntax	199-1
Tuples	may be written	action	a linear syntax	199-1
a linear syntax	using	action	angle brackets	199-1
angle brackets	for	constraint	example	199-1
example		sequential	A	199-1
A		sequential	5	199-1
5		sequential	B	199-1
B		sequential	3	199-1
<B>	that	constraint	u	200-1
<B>	Suppose	action	u	200-1
u	is	attribute	a tuple	200-1
a tuple	over	constraint	U	200-1
<B>	As	constraint	mathematics	200-2
<B>	in	constraint	mathematics	200-2
mathematics		sequential	the value	200-2
the value	of	constraint	u	200-2
u	on	constraint	an attribute A	200-2
an attribute A	in	constraint	U	200-2
U	is denoted	action	u	200-2
u		sequential	A	200-2
<B>	so that	constraint	V ⊆ U	200-3
<B>	for	constraint	V ⊆ U	200-3
<B>	is extended	action	V ⊆ U	200-3
V ⊆ U		sequential	u	200-3
u		sequential	V	200-3
V	denotes	action	the tuple v such	200-3
the tuple v such	over	constraint	V	200-3
V		sequential	that	200-3
that		sequential	v	200-3
v		sequential	A	200-3
A	= A	sequential	u	200-3
u	for	constraint	each A ∈ V	200-3
each A ∈ V		sequential	u	200-3
u		sequential	V	200-3
V	=	sequential	u|V	200-3
u|V		sequential	the restriction	200-3
the restriction	of	constraint	the function	200-3
the function		sequential	u	200-3
u	to	constraint	V	200-3
<B>	With	constraint	the unnamed perspective	201-1
the unnamed perspective		sequential	it	201-1
it	to	constraint	a tuple	201-1
it	is	attribute	more natural	201-1
it	view	action	a tuple	201-1
a tuple	as	constraint	an element	201-1
an element	of	constraint	a Cartesian product	201-1
a tuple	is	attribute	More precisely an ordered n- tuple	201-2
More precisely an ordered n- tuple	n	conjunctive	0	201-2
More precisely an ordered n- tuple	≥	sequential	0	201-2
0	of	constraint	constants	201-2
constants		sequential	an element	201-2
an element	of	constraint	the Cartesian product domn	201-2
The arity	of	constraint	a tuple	201-3
a tuple	is	attribute	the number	201-3
the number	of	constraint	coordinates	201-3
coordinates		sequential	that	201-3
that		sequential	it	201-3
it	has	action	<B>	201-3
Tuples	in	constraint	this context	201-4
this context	with	constraint	angle brackets	201-4
this context	are also written	action	angle brackets	201-4
angle brackets		sequential	e.g. 5	201-4
e.g. 5		sequential	3	201-4
The ith coordinate	of	constraint	a tuple u	201-5
a tuple u	is denoted	action	u	201-5
u		sequential	i	201-5
<B>	If	constraint	relation name R	201-6
relation name R	has	action	arity	201-6
arity	n	conjunctive	a tuple	201-6
a tuple	over	constraint	R	201-6
R	is	attribute	a tuple	201-6
a tuple	with	constraint	arity arity	201-6
arity arity		sequential	R	201-6
<B>	Because of	constraint	the total order ≤att	202-1
the total order ≤att		sequential	there	202-1
there	is	attribute	a natural correspondence	202-1
a natural correspondence	between	constraint	the perspectives	202-1
a natural correspondence	and	conjunctive	the perspectives	202-1
a natural correspondence	named	attribute	unnamed	202-1
A tuple A1		sequential	a 1	202-2
a 1		sequential	A2	202-2
A2		sequential	a2	202-2
a2	as	constraint	a function	202-2
a2	defined	action	a function	202-2
a function	can be viewed	action	A1 ≤att A2	202-2
a function	assuming	action	A1 ≤att A2	202-2
A1 ≤att A2	as	constraint	an ordered tuple	202-2
an ordered tuple	with	constraint	A1	202-2
A1		sequential	1	202-2
1	as	constraint	a first component	202-2
a first component	and	conjunctive	A2	202-2
A2	a	sequential	2	202-2
2	as	constraint	a second one	202-2
<B>	Ignoring	action	the names	202-3
the names		sequential	this tuple	202-3
this tuple	as	constraint	the ordered tuple a2	202-3
this tuple	may simply be viewed	action	the ordered tuple a2	202-3
the ordered tuple a2		sequential	a 1	202-3
<B>		sequential	the ordered tuple t	202-4
the ordered tuple t	=	sequential	a 1	202-4
a 1		sequential	a2	202-4
a2	as	constraint	a function	202-4
a2	may be interpreted	action	a function	202-4
a function	over	constraint	the set	202-4
the set		sequential	1	202-4
1		sequential	2 }	202-4
2 }	of	constraint	integers	202-4
integers	with	constraint	t	202-4
t	i =	sequential	ai	202-4
ai	for	constraint	i	202-4
This correspondence	will allow	action	us	202-5
us	to	constraint	the distinction	202-5
us	blur	action	the distinction	202-5
the distinction	between	constraint	the two perspectives	202-5
the two perspectives	from	constraint	one	202-5
the two perspectives	and	conjunctive	one	202-5
the two perspectives	move freely	action	one	202-5
one	to	constraint	<B>	202-5
<B>	versus	constraint	Logic Programming Perspectives	203-1
This fork	concerns	action	relation	203-2
relation	and	conjunctive	database	203-2
database		sequential	instances	203-2
instances	and	conjunctive	it	203-2
instances	how are viewed	action	it	203-2
it	of	constraint	the perspective	203-2
it	is	attribute	essentially independent	203-2
the perspective	on	constraint	tuples	203-2
the perspective	taken	action	tuples	203-2
<B>	Under	constraint	the conventional perspective	203-3
the conventional perspective		sequential	relation	203-3
relation	or	conjunctive	relation	203-3
relation		sequential	a instance	203-3
a instance	of	constraint	a relation schema R	203-3
a instance	or	conjunctive	a relation schema R	203-3
a relation schema R		sequential	U	203-3
U	over	constraint	a finite set U	203-3
U	or	conjunctive	a finite set U	203-3
a finite set U	of	constraint	attributes	203-3
attributes	is	attribute	possibly empty	203-3
a finite set		sequential	I	203-3
I	of	constraint	tuples	203-3
tuples	with	constraint	sort	203-3
sort		sequential	U	203-3
<B>	In	constraint	this case	203-4
this case		sequential	I	203-4
I	has	action	sort U	203-4
sort U	and	conjunctive	arity	203-4
<B>	with	constraint	the conventional perspective	204-1
<B>	Continuing	action	the conventional perspective	204-1
the conventional perspective		sequential	a database instance	204-1
a database instance	of	constraint	database schema R	204-1
database schema R	is	attribute	a mapping	204-1
a mapping		sequential	I	204-1
I	with	constraint	domain R	204-1
domain R		sequential	I	204-1
I		sequential	R	204-1
R	is	attribute	a relation	204-1
a relation	over	constraint	R	204-1
R	for	constraint	each R ∈ R	204-1
The other perspective	for	constraint	defining instances	205-1
defining instances	from	constraint	logic programming	205-1
defining instances	stems	action	logic programming	205-1
This perspective	with	constraint	ordered tuple	205-2
This perspective	is used	action	ordered tuple	205-2
ordered tuple		sequential	primarily the perspective	205-2
primarily the perspective	on	constraint	tuples	205-2
tuples	and	conjunctive	we	205-2
we	on	constraint	<B>	205-2
we	so focus here	attribute	that	205-2
<B>	Let	action	R	205-3
R	be	attribute	a relation	205-3
a relation	with	constraint	arity	205-3
<B>	.	sequential	<B>	205-4
<B>	.	sequential	<B>	205-5
<B>	ai	action	∈ dom ∈	205-6
∈ dom ∈	for	constraint	i	205-6
i		sequential	1	205-6
1		sequential	n	205-6
<B>	If	constraint	u	205-7
u	=	sequential	a1	205-7
<B>	.	sequential	<B>	205-8
<B>	.	sequential	<B>	205-9
<B>		sequential	we	205-10
we	sometimes write	action	R	205-10
R		sequential	u	205-10
u	for	constraint	R	205-10
R		sequential	a 1	205-10
<B>	.	sequential	<B>	205-11
<B>	.	sequential	<B>	205-12
<B>		sequential	<B>	205-13
<B>	Under	constraint	logic	205-14
logic		sequential	programming	205-14
programming		sequential	the perspective	205-14
the perspective		sequential	a relation	205-14
a relation		sequential	instance	205-14
instance	over	constraint	R	205-14
R	is	attribute	a finite set	205-14
a finite set	of	constraint	facts	205-14
facts	over	constraint	R	205-14
The two perspectives	provide	action	alternative ways	206-1
alternative ways	of	constraint	the same data	206-1
alternative ways	describing essentially	action	the same data	206-1
<B>	For	constraint	instance	207-1
instance	that	constraint	sort	207-1
instance	assuming	action	sort	207-1
sort		sequential	R	207-1
R	=	sequential	AB	207-1
AB	and	conjunctive	sort	207-1
sort		sequential	S	207-1
<B>	Because	constraint	relations	208-1
relations	as	constraint	sets	208-1
relations	can be viewed	action	sets	208-1
sets		sequential	it	208-1
it	to	constraint	relations	208-1
it	is	attribute	natural	208-1
it	consider	action	relations	208-1
it	given	action	relations	208-1
relations	of	constraint	the same sort	208-1
the same sort		sequential	the standard set operations union	208-1
the standard set operations union		sequential	∪	208-1
∪		sequential	intersection	208-1
intersection		sequential	∩	208-1
∩	and	conjunctive	difference	208-1
difference	and	conjunctive	the standard set comparators ⊂	208-1
the standard set comparators ⊂		sequential	⊆	208-1
⊆	and	conjunctive	<B>	208-1
⊆	=	sequential	<B>	208-1
⊆	=	sequential	<B>	208-1
<B>	With	constraint	logic programming	208-2
logic programming		sequential	the perspective	208-2
the perspective	on	constraint	instances	208-2
instances		sequential	we	208-2
we	may also use	action	these operations	208-2
these operations	and	conjunctive	comparators	208-2
comparators	on	constraint	database instances	208-2
all topics	in	constraint	the theory	209-1
the theory	of	constraint	relational database	209-1
relational database	Essentially can be studied	action	a fixed choice	209-1
relational database	using	action	a fixed choice	209-1
a fixed choice	for	constraint	the two forks	209-1
there	However are	action	some cases	209-2
some cases	in	constraint	which	209-2
which		sequential	one perspective	209-2
one perspective	than	constraint	<B>	209-2
one perspective	or	conjunctive	<B>	209-2
one perspective	is	attribute	much more natural	209-2
one perspective	is	attribute	technically much more convenient	209-2
<B>	For	constraint	example	209-3
example	in	constraint	a context	209-3
a context	in	constraint	which	209-3
which		sequential	there	209-3
there	is	attribute	more than one relation	209-3
more than one relation		sequential	the named perspective	209-3
the named perspective	and	conjunctive	specification	209-3
the named perspective	permits	attribute	easy	209-3
specification	of	constraint	correspondences	209-3
correspondences	between	constraint	columns	209-3
columns	of	constraint	different relations	209-3
different relations	whereas	constraint	the unnamed perspective	209-3
the unnamed perspective	does not	action	<B>	209-3
<B>	As	constraint	Chapter 4	209-4
<B>	in	constraint	Chapter 4	209-4
<B>	will be seen	action	Chapter 4	209-4
Chapter 4	to	constraint	sets	209-4
Chapter 4	but	conjunctive	sets	209-4
Chapter 4	leads	attribute	different	209-4
sets	of	constraint	natural primitive algebra operators	209-4
natural primitive algebra operators	for	constraint	the two perspectives	209-4
A related example	concerns	action	those topics	209-5
those topics		sequential	that	209-5
that	involve	action	the association	209-5
the association	of	constraint	distinct domains	209-5
distinct domains	to	constraint	different relation columns	209-5
different relation columns		sequential	the named perspective	209-5
the named perspective	is	attribute	again more convenient	209-5
<B>	In	constraint	addition	209-6
addition	although	constraint	relational dependency theory	209-6
relational dependency theory	for	constraint	the unnamed perspective	209-6
relational dependency theory	can be developed	action	the unnamed perspective	209-6
the unnamed perspective		sequential	the motivation	209-6
the motivation	in	constraint	the named perspective	209-6
the motivation	is	attribute	much more natural	209-6
the motivation	when presented	action	the named perspective	209-6
<B>	during	constraint	the course	209-7
the course	of	constraint	this book	209-7
this book		sequential	the choice	209-7
the choice	of	constraint	perspective	209-7
perspective	during	constraint	a particular discussion	209-7
a particular discussion	by	constraint	primarily the convenience	209-7
a particular discussion	or	conjunctive	primarily the convenience	209-7
a particular discussion	Thus will be motivated	attribute	intuitive	209-7
primarily the convenience	by	constraint	one	209-7
primarily the convenience	offered	action	one	209-7
one	or	conjunctive	<B>	209-7
<B>	In	constraint	this book	210-1
this book		sequential	we	210-1
we	will need	action	an infinite set var	210-1
an infinite set var	of	constraint	variables	210-1
variables		sequential	that	210-1
that	to	constraint	elements	210-1
that	over	constraint	elements	210-1
that	will be used	action	elements	210-1
that	range	action	elements	210-1
elements	of	constraint	dom	210-1
We	generalize	action	the notion	210-2
the notion	of	constraint	tuple	210-2
tuple	to	constraint	variables	210-2
tuple	permit	action	variables	210-2
variables	in	constraint	coordinate positions	210-2
coordinate positions		sequential	a free tuple	210-2
a free tuple	over	constraint	U	210-2
U	or	conjunctive	R	210-2
R		sequential	U	210-2
U	under	constraint	the named perspective	210-2
U	is	attribute	the named perspective	210-2
the named perspective		sequential	a function u	210-2
a function u	from	constraint	U	210-2
U	to	constraint	var ∪ dom	210-2
An atom	over	constraint	R	210-3
R	is	attribute	an expression R	210-3
an expression R		sequential	e1	210-3
<B>	.	sequential	<B>	210-4
<B>	.	sequential	<B>	210-5
en		sequential	n	210-6
n	where =	sequential	arity	210-6
arity		sequential	R	210-6
R	and	conjunctive	The Relational Model ei	210-6
The Relational Model ei	is	attribute	term	210-6
term		sequential	ei ∈ var ∪ dom	210-6
ei ∈ var ∪ dom	for	constraint	i	210-6
i		sequential	∈	210-6
∈		sequential	1	210-6
1		sequential	n	210-6
<B>	Following	action	the terminology	210-7
the terminology	of	constraint	logic	210-7
logic	and	conjunctive	logic	210-7
logic		sequential	programming	210-7
programming		sequential	we	210-7
we	to	constraint	a fact	210-7
we	sometimes refer	action	a fact	210-7
a fact	as	constraint	a ground atom	210-7
Notation		sequential	Notation	211-1
<B>	.	sequential	<B>	211-2
<B>	.	sequential	<B>	211-3
<B>		sequential	R	211-4
R		sequential	t	211-4
t		sequential	R	211-4
R		sequential	e1	211-4
<B>	.	sequential	<B>	211-5
<B>	.	sequential	<B>	211-6
en		sequential	R	211-7
R		sequential	u	211-7
u		sequential	Relation instances	211-7
It	is	attribute	one	211-8
one	of	constraint	the rare cases	211-8
the rare cases	in	constraint	which	211-8
which		sequential	substantial theoretical development	211-8
substantial theoretical development	preceded	action	the implementation	211-8
the implementation	of	constraint	systems	211-8
The first proposal	to	constraint	predicate calculus	211-9
The first proposal	use	action	predicate calculus	211-9
predicate calculus	as	constraint	a query language	211-9
a query language	to	constraint	Kuhns	211-9
a query language	can be traced back	action	Kuhns	211-9
Kuhns		sequential	Kuh67	211-9
The relational model itself	by	constraint	Codd	211-10
The relational model itself	was introduced	action	Codd	211-10
Codd		sequential	Cod70	211-10
There	are	attribute	numerous commercial database systems	211-11
numerous commercial database systems	on	constraint	the relational model	211-11
numerous commercial database systems	based	action	the relational model	211-11
They	include	action	IBM	211-12
IBM		sequential	DBZ	211-12
DBZ		sequential	A+76	211-12
A+76		sequential	INGRES	211-12
INGRES		sequential	SWKH76	211-12
SWKH76	and	conjunctive	ORACLE	211-12
ORACLE		sequential	Ora89	211-12
Ora89		sequential	Informix	211-12
Informix	and	conjunctive	Sybase	211-12
Other data models	besides	constraint	the relational model	212-1
Other data models	and	conjunctive	the relational model	212-1
Other data models	have been proposed	action	the relational model	212-1
Other data models	implemented	action	the relational model	212-1
The most prominent ones	preceding	action	the relational model	213-1
the relational model	and	conjunctive	network	213-1
the relational model	are	attribute	hierarchical	213-1
network		sequential	the models	213-1
<B>	and	conjunctive	models	213-2
models	in	constraint	the books	213-2
models	are described	action	the books	213-2
the books		sequential	Nij76	213-2
Nij76		sequential	TL82	213-2
various models	extending	action	the relational model	213-3
the relational model	More recently have been proposed	action	<B>	213-3
They	include	action	semantic models	213-4
semantic models	see	action	the survey	213-4
the survey		sequential	HK87	213-4
HK87	and	conjunctive	object	213-4
object	oriented	action	models	213-4
models	see	action	the position paper	213-4
we	Shall start	action	queries	214-1
we	asking	action	queries	214-1
Sergio		sequential	Sergio	215-1
Riccardo		sequential	Riccardo	216-1
Vittorio		sequential	Vittorio	217-1
<B>	In	constraint	this chapter	218-1
this chapter		sequential	we	218-1
we	on	constraint	the study	218-1
we	embark	action	the study	218-1
the study	of	constraint	queries	218-1
queries	for	constraint	relational databases	218-1
relational databases		sequential	a rich topic	218-1
a rich topic		sequential	that	218-1
that	spans	action	a good part	218-1
a good part	of	constraint	this book	218-1
This chapter	on	constraint	a class	218-2
This chapter	but	conjunctive	a class	218-2
This chapter	and	conjunctive	a class	218-2
This chapter	focuses	attribute	limited	218-2
This chapter	commonly arising	action	a class	218-2
a class	of	constraint	queries	218-2
queries	called	action	conjunctive queries	218-2
Five equivalent versions	of	constraint	this query family	218-3
this query family	are presented here	action	one	218-3
one	from	constraint	calculus	218-3
one	of	constraint	calculus	218-3
calculus	and	conjunctive	datalog	218-3
datalog		sequential	the paradigms	218-3
the paradigms		sequential	two	218-3
two	from	constraint	the algebra paradigm	218-3
the algebra paradigm	and	conjunctive	a final one	218-3
a final one		sequential	that	218-3
that	has	action	a more visual form	218-3
<B>	In	constraint	the context	219-1
the context	of	constraint	conjunctive queries	219-1
conjunctive queries		sequential	the three nonalgebraic versions	219-1
the three nonalgebraic versions	as	constraint	minor syntactic variants	219-1
the three nonalgebraic versions	can be viewed	action	minor syntactic variants	219-1
minor syntactic variants	of	constraint	these similarities	219-1
minor syntactic variants	but	conjunctive	these similarities	219-1
these similarities	as	constraint	the languages	219-1
these similarities	diminish	action	the languages	219-1
the languages	to	constraint	negation	219-1
the languages	are generalized	action	negation	219-1
the languages	incorporate	action	negation	219-1
negation	and	conjunctive	recursion	219-1
negation	or	conjunctive	recursion	219-1
This chapter	also discusses	action	query composition	219-2
query composition	and	conjunctive	its interaction	219-2
its interaction	with	constraint	user views	219-2
user views	and	conjunctive	it	219-2
it	extends	action	conjunctive queries	219-2
conjunctive queries	in	constraint	a straightforward manner	219-2
a straightforward manner	to	constraint	union	219-2
a straightforward manner	incorporate	action	union	219-2
union	or	conjunctive	disjunction	219-2
The conjunctive queries	enjoy	action	several desirable properties	220-1
several desirable properties	for	constraint	example	220-1
several desirable properties	including	action	example	220-1
example		sequential	decidability	220-1
decidability	of	constraint	equivalence	220-1
equivalence	and	conjunctive	containment	220-1
These results	in	constraint	Chapter 6	220-2
These results	will be presented	action	Chapter 6	220-2
Chapter 6	in	constraint	which	220-2
which		sequential	a basic tool the Homomorphism Theorem	220-2
a basic tool the Homomorphism Theorem	is developed	action	<B>	220-2
<B>	of	constraint	these results	220-3
these results	to	constraint	conjunctive queries	220-3
these results	extend	action	conjunctive queries	220-3
conjunctive queries	with	constraint	union	220-3
<B>	In	constraint	the formal framework	221-1
the formal framework		sequential	that	221-1
that		sequential	we	221-1
we	in	constraint	this book	221-1
we	have developed	action	this book	221-1
this book		sequential	we	221-1
we	between	constraint	a query	221-1
we	distinguish	action	a query	221-1
a query		sequential	which	221-1
which	is	attribute	a syntactic object	221-1
a syntactic object	and	conjunctive	a query mapping	221-1
a query mapping		sequential	which	221-1
which	is	attribute	the function	221-1
the function	by	constraint	a query	221-1
the function	defined	action	a query	221-1
a query	under	constraint	a specified semantics	221-1
a query	interpreted	action	a specified semantics	221-1
we	However often blur	action	these two concepts	221-2
these two concepts		sequential	the meaning	221-2
the meaning	from	constraint	the context	221-2
the meaning	is	attribute	when clear	221-2
<B>	In	constraint	the relational model	221-3
the relational model		sequential	query mappings	221-3
query mappings	as	constraint	domain	221-3
query mappings	generally have	action	domain	221-3
domain		sequential	the family	221-3
the family	of	constraint	all instances	221-3
all instances	of	constraint	a specified relation	221-3
a specified relation	or	conjunctive	database schema	221-3
database schema	called	action	the input schema	221-3
the input schema	and	conjunctive	they	221-3
they	as	constraint	the family	221-3
they	have	action	the family	221-3
they	range	action	the family	221-3
the family	of	constraint	instances	221-3
instances	of	constraint	an output schema	221-3
an output schema		sequential	which	221-3
which	be	attribute	might a database schema	221-3
might a database schema	or	conjunctive	a relation schema	221-3
<B>	In	constraint	the latter case	221-4
the latter case		sequential	the relation name	221-4
the relation name	as	constraint	part	221-4
the relation name	may be specified	action	part	221-4
part	of	constraint	the syntax	221-4
the syntax	of	constraint	the query	221-4
the query	by	constraint	the context	221-4
the query	or	conjunctive	the context	221-4
the context	or	conjunctive	it	221-4
it	to	constraint	the discussion	221-4
it	be	attribute	may irrelevant	221-4
the discussion	at	constraint	<B>	221-4
the discussion	and	conjunctive	<B>	221-4
the discussion	thus not specified	attribute	all	221-4
We	that	constraint	a query	221-5
We	generally say	action	a query	221-5
a query		sequential	mapping	221-5
mapping	from	constraint	its input schema	221-5
mapping	or	conjunctive	its input schema	221-5
mapping	is	attribute	its input schema	221-5
its input schema	to	constraint	its output schema	221-5
<B>		sequential	two queries	221-6
two queries		sequential	q1	221-6
q1	and	conjunctive	q2	221-6
q2	over	constraint	R	221-6
R	are	attribute	equivalent	221-6
R	denoted	action	q1	221-6
q1	≡	sequential	q2	221-6
q2	if	constraint	they	221-6
they	have	action	the same output schema	221-6
the same output schema	and	conjunctive	q1	221-6
q1		sequential	I	221-6
I	=	sequential	q2	221-6
q2		sequential	I	221-6
I	for	constraint	each instance	221-6
each instance		sequential	I	221-6
I	over	constraint	R	221-6
This chapter	with	constraint	an informal discussion	222-1
This chapter	begins	action	an informal discussion	222-1
an informal discussion		sequential	that	222-1
that	introduces	action	a family	222-1
a family	of	constraint	simple queries	222-1
simple queries	and	conjunctive	one approach	222-1
simple queries	illustrates	action	one approach	222-1
one approach	to	constraint	them	222-1
one approach	expressing formally	action	them	222-1
Three versions	of	constraint	conjunctive queries	222-2
conjunctive queries	of	constraint	them	222-2
conjunctive queries	and	conjunctive	them	222-2
conjunctive queries	are introduced	attribute	all	222-2
them	have	action	a basis	222-2
a basis	in	constraint	logic	222-2
Then a brief 37 Conjunctive Queries		sequential	Then a brief 37 Conjunctive Queries	222-3
Which theaters	feature	action	Cries	223-1
Cries	and	conjunctive	Whispers	223-1
What	are	attribute	the address	224-1
the address	and	conjunctive	phone number	224-1
phone number	of	constraint	the Le Champo	224-1
<B>	List	action	the names	225-1
the names	and	conjunctive	addresses	225-1
addresses	of	constraint	theaters	225-1
theaters	featuring	action	a Bergman film	225-1
<B>	Is	action	a film	226-1
a film	by	constraint	Bergman	226-1
a film	directed	action	Bergman	226-1
Bergman	in	constraint	Paris	226-1
Bergman	playing	action	Paris	226-1
<B>	List	action	the pairs	227-1
the pairs	of	constraint	persons	227-1
persons	in	constraint	a movie	227-1
persons	directed	attribute	the second	227-1
a movie	and	conjunctive	<B>	227-1
<B>	List	action	the names	228-1
the names	of	constraint	directors	228-1
directors		sequential	who	228-1
who	in	constraint	a movie	228-1
who	have acted	action	a movie	228-1
a movie		sequential	they	228-1
they	directed	action	<B>	228-1
<B>	List	action	pairs	229-1
pairs	of	constraint	actors	229-1
actors		sequential	that	229-1
that	in	constraint	the same movie	229-1
that	acted	action	the same movie	229-1
<B>	On	constraint	any input	230-1
any input	produce	action	Coppola	230-1
Coppola	as	constraint	the answer	230-1
I	Where can see	action	Annie	231-1
Annie		sequential	Hall	231-1
Hall	or	conjunctive	Manhattan	231-1
What	are	attribute	the films	232-1
the films	with	constraint	Allen	232-1
Allen	as	constraint	actor	232-1
actor	or	conjunctive	director	232-1
What films	with	constraint	Allen	233-1
Allen	as	constraint	actor	233-1
actor	or	conjunctive	director	233-1
director	at	constraint	the Concorde	233-1
director	are currently featured	action	the Concorde	233-1
<B>	List	action	all movies	234-1
all movies		sequential	that	234-1
that	by	constraint	Hitchcock	234-1
that	were directed	action	Hitchcock	234-1
Hitchcock	or	conjunctive	that	234-1
that	at	constraint	the Rex	234-1
that	are currently playing	action	the Rex	234-1
<B>	List	action	all actors	235-1
all actors	and	conjunctive	director	235-1
director	of	constraint	the movie	235-1
the movie		sequential	Apocalypse Now	235-1
Apocalypse Now		sequential	Figure	235-1
Figure		sequential	4.1	235-1
4.1		sequential	Examples	235-1
Examples	of	constraint	conjunctive queries	235-1
conjunctive queries	of	constraint	which	235-1
which	require	action	union digression	235-1
union digression	to	constraint	query composition	235-1
union digression	is made	action	query composition	235-1
union digression	consider	action	query composition	235-1
query composition	and	conjunctive	database views	235-1
The algebraic perspectives	on	constraint	conjunctive queries	235-2
conjunctive queries	along	constraint	the theorem	235-2
conjunctive queries	with	constraint	the theorem	235-2
conjunctive queries	are given	action	the theorem	235-2
the theorem	showing	action	the equivalence	235-2
the equivalence	of	constraint	all five approaches	235-2
all five approaches	to	constraint	conjunctive queries	235-2
various forms	of	constraint	union	235-3
union	and	conjunctive	disjunction	235-3
disjunction	to	constraint	the conjunctive queries	235-3
disjunction	Finally are added	action	the conjunctive queries	235-3
<B>	Getting Started	action	<B>	236-1
<B>	to	constraint	conjunctive queries	236-2
<B>	following	action	conjunctive queries	236-2
<B>	correspond	action	conjunctive queries	236-2
Which theaters	feature	action	Cries	237-1
Cries	and	conjunctive	Whispers	237-1
What	are	attribute	the address	238-1
the address	and	conjunctive	phone number	238-1
phone number	of	constraint	the Le Champo	238-1
<B>	and	conjunctive	queries	239-1
queries	in	constraint	this section	239-1
queries	used	action	this section	239-1
this section	in	constraint	Fig	239-1
this section	are gathered	action	Fig	239-1
4.1		sequential	4.1	239-2
<B>	of	constraint	the queries	239-3
the queries	just given	action	calls	239-3
calls	for	constraint	information	239-3
calls	extracting	action	information	239-3
information	from	constraint	a single relation	239-3
<B>	In	constraint	contrast	239-4
contrast		sequential	queries	239-4
queries		sequential	4.4	239-4
4.4	through	constraint	4.7	239-4
4.7	involve	action	more than one relation	239-4
<B>	In	constraint	queries	240-1
queries		sequential	4.1	240-1
4.1		sequential	–4.4	240-1
–4.4	and	conjunctive	4.6–4.9	240-1
4.6–4.9		sequential	the database	240-1
the database	to	constraint	values	240-1
the database	is asked	action	values	240-1
the database	find	action	values	240-1
values	or	conjunctive	tuples	240-1
tuples	of	constraint	values	240-1
values	for	constraint	which	240-1
which		sequential	a certain pattern	240-1
a certain pattern	of	constraint	data	240-1
data	in	constraint	the database	240-1
data	holds	action	the database	240-1
the database	in	constraint	query	240-1
the database	and	conjunctive	query	240-1
query		sequential	4.5	240-1
4.5		sequential	the database	240-1
the database	whether	constraint	a certain pattern	240-1
the database	is asked	action	a certain pattern	240-1
a certain pattern	of	constraint	data	240-1
data	holds	action	<B>	240-1
We	that	constraint	the patterns	240-2
We	shall see	action	the patterns	240-2
the patterns	in	constraint	terms	240-2
the patterns	can be described simply	action	terms	240-2
terms	of	constraint	the existence	240-2
the existence	of	constraint	tuples	240-2
tuples		sequential	that	240-2
that	to	constraint	equality	240-2
that	by	constraint	equality	240-2
that	are connected	attribute	each other	240-2
equality	of	constraint	their coordinates	240-2
equality	of	constraint	their coordinates	240-2
<B>	On	constraint	the other hand	240-3
the other hand		sequential	queries	240-3
queries		sequential	4.10	240-3
4.10	through	constraint	4.14	240-3
4.14	in	constraint	this manner	240-3
4.14	can not be expressed	action	this manner	240-3
this manner	unless	constraint	some form	240-3
some form	of	constraint	disjunction	240-3
disjunction	or	conjunctive	union	240-3
union	is incorporated	action	<B>	240-3
Example		sequential	4.1.1	241-1
4.1.1	Consider	action	query	241-1
query		sequential	4.4	241-1
<B>		sequential	we	241-2
we	express	action	this query	241-2
this query	by	constraint	there	241-2
this query	that	constraint	there	241-2
this query	if	constraint	there	241-2
this query	stating	action	there	241-2
there	are respectively	action	tuples r1	241-2
tuples r1		sequential	r2	241-2
r2		sequential	r3	241-2
r3	in	constraint	relations Movies	241-2
relations Movies		sequential	Pariscope	241-2
Pariscope		sequential	Location	241-2
Location		sequential	the Director	241-2
the Director	in	constraint	r1	241-2
r1	is	attribute	Bergman	241-2
Bergman		sequential	we	241-2
we	want	action	Theater	241-2
Theater	and	conjunctive	Address	241-2
Address		sequential	the coordinates	241-2
the coordinates	from	constraint	tuple r3	241-2
<B>	In	constraint	this formulation	242-1
this formulation		sequential	we	242-1
we	essentially use	action	variables	242-1
variables		sequential	that	242-1
that	over	constraint	tuples	242-1
that	range	action	tuples	242-1
<B>	Although	constraint	the basis	242-2
<B>	is	attribute	the basis	242-2
the basis	of	constraint	the tuple calculus	242-2
the basis	so called	attribute	relational	242-2
the tuple calculus	see	action	Exercise 5.23	242-2
Exercise 5.23	in	constraint	the next chapter	242-2
the next chapter		sequential	the focus	242-2
the focus	of	constraint	most theoretical investigations	242-2
most theoretical investigations	on	constraint	has the domain calculus	242-2
most theoretical investigations	been	action	has the domain calculus	242-2
has the domain calculus		sequential	which	242-2
which	uses	action	variables	242-2
variables		sequential	that	242-2
that	over	constraint	constants	242-2
that	range	action	constants	242-2
constants		sequential	tuples	242-2
<B>	also reflects	action	the convention	242-3
the convention	in	constraint	the predicate calculus	242-3
the convention	followed	action	the predicate calculus	242-3
the predicate calculus	of	constraint	first order	242-3
first order		sequential	logic	242-3
we	Thus reformulate	action	the preceding query	242-4
the preceding query	as if	constraint	there	242-4
there	are	attribute	tuples xti	242-4
tuples xti		sequential	Bergman	242-4
Bergman		sequential	xac	242-4
xac		sequential	xth	242-4
xth		sequential	xti	242-4
xti		sequential	xs	242-4
xs	and	conjunctive	xth	242-4
xth		sequential	xad	242-4
xad		sequential	xp	242-4
xp	in	constraint	relations	242-4
relations		sequential	Movies	242-4
Movies		sequential	Pariscope	242-4
Pariscope	and	conjunctive	Location	242-4
Location	include	action	the tuple Theater	242-4
the tuple Theater		sequential	xth	242-4
xth		sequential	Address	242-4
Address	in	constraint	the answer	242-4
the answer		sequential	where xti	242-4
where xti		sequential	xac	242-4
<B>	.	sequential	<B>	242-5
<B>	.	sequential	<B>	242-6
<B>	are	attribute	variables	242-7
<B>	that	constraint	the equalities	242-8
<B>	Note	action	the equalities	242-8
the equalities	in	constraint	the first formulation	242-8
the equalities	specified	action	the first formulation	242-8
the first formulation	in	constraint	the second formulation	242-8
the first formulation	are achieved implicitly	action	the second formulation	242-8
the second formulation	through	constraint	multiple occurrences	242-8
multiple occurrences	of	constraint	variables	242-8
The translation	of	constraint	the syntax	243-1
The translation	into	constraint	the syntax	243-1
the syntax	of	constraint	conjunctive queries	243-1
the syntax	rule based	action	conjunctive queries	243-1
conjunctive queries	by	constraint	ans	243-1
conjunctive queries	is now obtained	action	ans	243-1
ans	for	constraint	answer	243-1
answer	is	attribute	a relation	243-1
a relation		sequential	<B>	243-1
The atom	to	constraint	the left	243-2
the left	of	constraint	<B>	243-2
The preceding rule	as	constraint	all variables	244-1
The preceding rule	to	constraint	all variables	244-1
The preceding rule	may be abbreviated	action	all variables	244-1
The preceding rule	is used	action	all variables	244-1
The preceding rule	replace	action	all variables	244-1
all variables		sequential	that	244-1
that	in	constraint	the rule	244-1
that	occur exactly once	action	the rule	244-1
Such variables	are sometimes called	attribute	anonymous	244-2
<B>	In	constraint	a conjunctive query	245-1
<B>	rule based	action	a conjunctive query	245-1
a conjunctive query	is	attribute	a single rule	245-1
a single rule		sequential	that	245-1
that	has	action	the form	245-1
the form	in	constraint	the preceding example	245-1
the form	illustrated	action	the preceding example	245-1
The semantics	with	constraint	conjunctive queries	245-2
The semantics	associated	action	conjunctive queries	245-2
The semantics	rule based	action	conjunctive queries	245-2
conjunctive queries	that	constraint	their interpretation	245-2
conjunctive queries	ensures	action	their interpretation	245-2
their interpretation	to	constraint	the more informal expressions	245-2
their interpretation	corresponds	action	the more informal expressions	245-2
the more informal expressions	in	constraint	the preceding example	245-2
the more informal expressions	given	action	the preceding example	245-2
Rule	based	action	conjunctive queries	245-3
conjunctive queries	as	constraint	the basic building block	245-3
conjunctive queries	can be viewed	action	the basic building block	245-3
the basic building block	for	constraint	datalog	245-3
datalog		sequential	a query language	245-3
a query language	on	constraint	logic programming	245-3
a query language	based	action	logic programming	245-3
logic programming		sequential	that	245-3
that	provides	action	an elegant syntax	245-3
an elegant syntax	for	constraint	recursion	245-3
an elegant syntax	expressing	action	recursion	245-3
Conjunctive Queries Movies		sequential	Title Director Bergman	246-1
Title Director Bergman		sequential	Pariscope Theater Title Schedule Location Theater Phone number P._Rex P._1 bd	246-1
Poissonnière Figure		sequential	4.2	246-2
4.2		sequential	paradigm	246-2
paradigm	in	constraint	this chapter	246-2
this chapter		sequential	we	246-2
we	illustrate	action	it	246-2
it	in	constraint	Fig	246-2
4.2	with	constraint	a query	246-3
a query	in	constraint	the syntax	246-3
a query	presented	action	the syntax	246-3
the syntax	of	constraint	the language	246-3
the language		sequential	Query	246-3
Query	By	constraint	Example	246-3
Example		sequential	QBE	246-3
QBE	see	action	also Chapter 7	246-3
The identifiers	with	constraint	a variables	246-4
The identifiers	starting	action	a variables	246-4
The identifiers	designate	action	a variables	246-4
a variables	and	conjunctive	P.	246-4
P.	indicates	action	what	246-4
what	to	constraint	<B>	246-4
what	output	action	<B>	246-4
<B>	Following	action	the convention	246-5
the convention	for	constraint	QBE	246-5
the convention	established	action	QBE	246-5
QBE		sequential	variable names	246-5
variable names	to	constraint	typical values	246-5
variable names	are chosen	action	typical values	246-5
variable names	reflect	action	typical values	246-5
typical values		sequential	that	246-5
that		sequential	they	246-5
they	might take	action	<B>	246-5
<B>	that	constraint	the coordinate entries	246-6
<B>	Note	action	the coordinate entries	246-6
the coordinate entries	left	action	blank	246-6
blank	in	constraint	terms	246-6
blank	correspond	action	terms	246-6
terms	of	constraint	the rule	246-6
the rule	to	constraint	distinct variables	246-6
the rule	given previously	action	distinct variables	246-6
distinct variables		sequential	that	246-6
that	in	constraint	the body	246-6
that	occur	action	the body	246-6
the body	in	constraint	the head	246-6
the body	and	conjunctive	the head	246-6
the body	do not occur	action	the head	246-6
the head	to	constraint	anonymous variables	246-6
The third version	of	constraint	conjunctive queries	247-1
conjunctive queries	in	constraint	this chapter	247-1
conjunctive queries	studied	action	this chapter	247-1
this chapter	is	attribute	a restriction	247-1
a restriction	of	constraint	the predicate calculus	247-1
the predicate calculus	as	constraint	the term conjunctive query	247-1
the predicate calculus	will be seen	action	the term conjunctive query	247-1
the term conjunctive query	from	constraint	this version	247-1
the term conjunctive query	stems	action	this version	247-1
<B>	and	conjunctive	The versions	247-2
The versions	in	constraint	nature	247-2
The versions	are	attribute	algebraic	247-2
nature		sequential	one	247-2
one	for	constraint	the unnamed perspective	247-2
the unnamed perspective	for	constraint	the named perspective	247-2
the unnamed perspective	and	conjunctive	the named perspective	247-2
<B>	Logic Based	action	Perspectives	248-1
<B>	After	constraint	the equivalence	248-2
<B>	showing	action	the equivalence	248-2
the equivalence	of	constraint	the three resulting query languages	248-2
the three resulting query languages		sequential	we	248-2
we	extend	action	them	248-2
them	by	constraint	a capability	248-2
them	incorporating	action	a capability	248-2
a capability	to	constraint	equality explicity	248-2
a capability	express	action	equality explicity	248-2
equality explicity	thereby yielding	action	a slightly more powerful family	248-2
a slightly more powerful family	of	constraint	languages	248-2
Rule	Based	action	Conjunctive Queries	249-1
<B>	As	constraint	rule	249-2
<B>	will be seen later	action	rule	249-2
rule	based	action	the paradigm	249-2
the paradigm	for	constraint	queries	249-2
the paradigm	is well suited	action	queries	249-2
the paradigm	specifying	action	queries	249-2
queries	from	constraint	database schemas	249-2
database schemas	to	constraint	database schemas	249-2
<B>	to	constraint	the comparison	249-3
<B>	facilitate	action	the comparison	249-3
the comparison	between	constraint	the different variants	249-3
the different variants	of	constraint	the conjunctive queries	249-3
the conjunctive queries		sequential	we	249-3
we	on	constraint	queries	249-3
we	However focus first	action	queries	249-3
we	rule based	action	queries	249-3
queries		sequential	whose targets	249-3
whose targets	are	attribute	relation schemas	249-3
We	adopt	action	the convention	249-4
the convention	of	constraint	the name	249-4
the convention	using	action	the name	249-4
the name	to	constraint	the name	249-4
the name	to	constraint	the name	249-4
the name	ans	conjunctive	the name	249-4
the name	refer	action	the name	249-4
the name	of	constraint	the target relation	249-4
the target relation	if	constraint	the name itself	249-4
the name itself	as	constraint	often the case	249-4
the name itself	is	attribute	unimportant	249-4
the name itself	is	attribute	often the case	249-4
often the case	with	constraint	relational queries	249-4
Definition		sequential	4.2.1	250-1
rule	based	action	A conjunctive query	250-2
A conjunctive query	over	constraint	R	250-2
R	is	attribute	an expression	250-2
an expression	of	constraint	the form	250-2
the form	n	conjunctive	where ≥ 0	250-2
where ≥ 0		sequential	R1	250-2
<B>	.	sequential	<B>	250-3
<B>	.	sequential	<B>	250-4
Rn	are	attribute	relation names	250-5
relation names	in	constraint	R	250-5
R	ans	conjunctive	a relation name	250-5
R	is	attribute	a relation name	250-5
a relation name	in	constraint	not R	250-5
not R	and	conjunctive	u	250-5
u		sequential	u1	250-5
<B>	.	sequential	<B>	250-6
<B>	.	sequential	<B>	250-7
un	are	attribute	free tuples	250-8
free tuples	either	conjunctive	variables	250-8
free tuples	may use	action	variables	250-8
variables	or	conjunctive	constants	250-8
<B>	that	constraint	v	250-9
<B>	if	constraint	v	250-9
<B>	Recall	action	v	250-9
v	=	sequential	x1	250-9
<B>	.	sequential	<B>	250-10
<B>	.	sequential	<B>	250-11
xm		sequential	R	250-12
R		sequential	v	250-12
v	is	attribute	a shorthand	250-12
a shorthand	for	constraint	R	250-12
R		sequential	x1	250-12
<B>	.	sequential	<B>	250-13
<B>	.	sequential	<B>	250-14
xm		sequential	xm	250-15
<B>	In	constraint	addition	250-16
addition		sequential	the tuples	250-16
the tuples		sequential	u	250-16
u		sequential	u1	250-16
<B>	.	sequential	<B>	250-17
<B>	.	sequential	<B>	250-18
un	must have	action	the appropriate arities	250-19
the appropriate arities		sequential	u	250-19
u	must have	action	arity	250-19
arity	of	constraint	ans	250-19
ans	and	conjunctive	ui	250-19
ui	must have	action	the arity	250-19
the arity	of	constraint	Ri	250-19
Ri	for	constraint	i	250-19
i		sequential	∈	250-19
∈		sequential	1	250-19
1		sequential	n	250-19
each variable	in	constraint	u	250-20
each variable	occurring	action	u	250-20
u	at	constraint	u1	250-20
u	in	constraint	u1	250-20
u	Finally must also occur	attribute	least	250-20
<B>	.	sequential	<B>	250-21
<B>	.	sequential	<B>	250-22
<B>		sequential	<B>	250-23
The set	of	constraint	variables	250-24
variables	in	constraint	q	250-24
variables	occurring	action	q	250-24
q	is denoted	action	var	250-24
var		sequential	q	250-24
Rule	based	action	conjunctive queries	251-1
conjunctive queries	are often more simply called	action	rules	251-1
<B>	In	constraint	the preceding rule	251-2
the preceding rule		sequential	the subexpression R1	251-2
the subexpression R1		sequential	u1	251-2
<B>	.	sequential	<B>	251-3
<B>	.	sequential	<B>	251-4
Rn		sequential	un	251-5
un	is	attribute	the body	251-5
the body	of	constraint	the rule	251-5
the rule	and	conjunctive	ans	251-5
ans		sequential	u	251-5
u	is	attribute	the head	251-5
The rule here	by	constraint	the definition	251-6
The rule here	is required	action	the definition	251-6
the definition	to	constraint	range	251-6
range	be restricted	action	each variable	251-6
each variable	in	constraint	the head	251-6
each variable	occurring	action	the head	251-6
the head	in	constraint	the body	251-6
the head	must also occur	action	the body	251-6
<B>	Although	constraint	this restriction	251-7
this restriction	in	constraint	the languages	251-7
this restriction	of	constraint	the languages	251-7
this restriction	is followed	attribute	most	251-7
the languages	on	constraint	the use	251-7
the languages	based	action	the use	251-7
the use	of	constraint	rules	251-7
rules		sequential	it	251-7
it	in	constraint	Chapter 18	251-7
it	will be relaxed	action	Chapter 18	251-7
a rule	of	constraint	a tool	252-1
a rule	as	constraint	a tool	252-1
a rule	Intuitively may be thought	action	a tool	252-1
a tool	for	constraint	new facts	252-1
a tool	deducing	action	new facts	252-1
<B>	If	constraint	one	252-2
one	can find	action	values	252-2
values	for	constraint	the variables such	252-2
the variables such	of	constraint	the rule	252-2
the rule		sequential	that	252-2
that		sequential	the body	252-2
the body	holds	action	one	252-2
one	may deduce	action	the head fact	252-2
This concept	of	constraint	values	252-3
values	for	constraint	the variables	252-3
the variables	in	constraint	the rules	252-3
the rules	by	constraint	the notion	252-3
the rules	is captured	action	the notion	252-3
the notion	of	constraint	valuation	252-3
<B>	to	constraint	identity	252-4
<B>	be	attribute	identity	252-4
<B>	is extended	action	identity	252-4
identity	on	constraint	dom	252-4
dom	to	constraint	free tuples	252-4
dom	and	conjunctive	free tuples	252-4
dom	extended	action	free tuples	252-4
dom	map	action	free tuples	252-4
free tuples	to	constraint	tuples	252-4
tuples	in	constraint	the natural fashion	252-4
We	now define	action	the semantics	253-1
the semantics	for	constraint	conjunctive queries	253-1
the semantics	rule based	action	conjunctive queries	253-1
<B>	Let	action	q	253-2
q	be	attribute	the query	253-2
the query	and	conjunctive	I	253-2
the query	given earlier	action	I	253-2
the query	let	action	I	253-2
I	be	attribute	an instance	253-2
an instance	of	constraint	R	253-2
The active domain	of	constraint	a database instance	254-1
a database instance		sequential	I	254-1
I	denoted	action	adom	254-1
adom		sequential	I	254-1
I	is	attribute	the set	254-1
the set	of	constraint	all constants	254-1
all constants	in	constraint	I	254-1
all constants	occurring	action	I	254-1
I	and	conjunctive	the active domain adom	254-1
the active domain adom		sequential	I	254-1
I	of	constraint	relation instance	254-1
relation instance		sequential	I	254-1
I	is defined analogously	action	<B>	254-1
<B>	In	constraint	addition	255-1
addition		sequential	the set	255-1
the set	of	constraint	constants	255-1
constants	in	constraint	query	255-1
constants	occurring	action	query	255-1
query		sequential	a q	255-1
a q	is denoted	action	adom	255-1
adom		sequential	q	255-1
We	use	action	adom	255-2
adom		sequential	q	255-2
q		sequential	I	255-2
I	as	constraint	an abbreviation	255-2
an abbreviation	for	constraint	adom	255-2
adom		sequential	q	255-2
q		sequential	∪ adom	255-2
∪ adom		sequential	I	255-2
<B>	Let	action	q	256-1
q	be	attribute	a rule	256-1
a rule	and	conjunctive	I	256-1
I		sequential	an input instance	256-1
an input instance	for	constraint	q	256-1
<B>	Because	constraint	q	256-2
q		sequential	range	256-2
range	is restricted	action	it	256-2
it	that	constraint	adom	256-2
it	is easily verified	action	adom	256-2
adom		sequential	q	256-2
q		sequential	I	256-2
I		sequential	⊆ adom	256-2
⊆ adom		sequential	q	256-2
q		sequential	I	256-2
I	see	action	Exercise 4.2	256-2
<B>	In	constraint	other words	256-3
other words		sequential	q	256-3
q		sequential	I	256-3
I	contains	action	only constants	256-3
only constants	in	constraint	q	256-3
only constants	occurring	action	q	256-3
q	in	constraint	I	256-3
q	or	conjunctive	I	256-3
<B>	In	constraint	q I	256-4
q I	and	conjunctive	it	256-4
q I	is	attribute	finite	256-4
it	is	attribute	so an instance	256-4
Such improvements	in	constraint	Chapter 6	257-1
Such improvements	are considered	action	Chapter 6	257-1
<B>	to	constraint	the intuition	258-1
<B>	Returning	action	the intuition	258-1
the intuition	under	constraint	the usual perspective	258-1
the usual perspective		sequential	a fundamental difference	258-1
a fundamental difference	between	constraint	the head	258-1
the head	and	conjunctive	body	258-1
body	of	constraint	a rule	258-1
a rule		sequential	R0	258-1
R0	←	sequential	R1	258-1
<B>	.	sequential	<B>	258-2
<B>	.	sequential	<B>	258-3
Rn	that	constraint	body relations	258-4
Rn	is	attribute	body relations	258-4
body relations	as	constraint	the head relation	258-4
body relations	whereas	constraint	the head relation	258-4
body relations	are viewed	action	the head relation	258-4
body relations	being stored	action	the head relation	258-4
the head relation	is not	action	<B>	258-4
<B>	to	constraint	the rule	258-5
<B>	referring	action	the rule	258-5
the rule	given earlier	action	the values	258-5
the values	of	constraint	relations R1	258-5
<B>	.	sequential	<B>	258-6
<B>	.	sequential	<B>	258-7
Rn	because	constraint	they	258-8
Rn	are known	action	they	258-8
they	by	constraint	the input instance Conjunctive Queries I	258-8
they	are provided	action	the input instance Conjunctive Queries I	258-8
<B>	In	constraint	other words	258-9
other words		sequential	we	258-9
we	are given	action	the extension	258-9
the extension	of	constraint	R1	258-9
<B>	.	sequential	<B>	258-10
<B>	.	sequential	<B>	258-11
Rn	for	constraint	this reason	258-12
this reason		sequential	they	258-12
they	are called	action	extensional relations	258-12
<B>	In	constraint	contrast	258-13
contrast		sequential	relation	258-13
relation		sequential	R0	258-13
R0	and	conjunctive	its value	258-13
R0	is not stored	action	its value	258-13
its value	on	constraint	request	258-13
its value	is computed	action	request	258-13
request	by	constraint	the query	258-13
the query		sequential	the rule	258-13
the rule	gives	action	only the intension	258-13
only the intension	or	conjunctive	definition	258-13
definition	of	constraint	R0	258-13
<B>	For	constraint	this reason	258-14
this reason		sequential	we	258-14
we	to	constraint	R0	258-14
we	refer	action	R0	258-14
R0	as	constraint	an intensional relation	258-14
<B>	In	constraint	some cases	258-15
some cases		sequential	the database instance	258-15
the database instance	with	constraint	R1	258-15
the database instance	associated	action	R1	258-15
<B>	.	sequential	<B>	258-16
<B>	.	sequential	<B>	258-17
Rn	is called	action	the extensional database	258-18
the extensional database		sequential	edb	258-18
edb	and	conjunctive	the rule itself	258-18
the rule itself	to	constraint	the intensional database	258-18
the rule itself	as	constraint	the intensional database	258-18
the rule itself	is referred	action	the intensional database	258-18
the intensional database		sequential	idb	258-18
the defined relation	to	constraint	an idb relation	258-19
the defined relation	as	constraint	an idb relation	258-19
the defined relation	Also is sometimes referred	action	an idb relation	258-19
We	now present	action	the first theoretical property	259-1
the first theoretical property	of	constraint	conjunctive queries	259-1
A query q	over	constraint	R	259-2
R	if	constraint	each I	259-2
R	for	constraint	each I	259-2
R	is	attribute	monotonic	259-2
each I		sequential	J	259-2
J	over	constraint	R	259-2
R		sequential	I	259-2
I	⊆	action	J	259-2
J	that	constraint	q I	259-2
J	implies	action	q I	259-2
q I		sequential	⊆ q	259-2
⊆ q		sequential	J	259-2
query		sequential	A q	259-3
A q	if	constraint	there	259-3
A q	is	attribute	satisfiable	259-3
there	is	attribute	some input	259-3
some input		sequential	I	259-3
I		sequential	that q	259-3
that q		sequential	I	259-3
I	is	attribute	nonempty	259-3
Proposition		sequential	4.2.2	260-1
Proof	Let	action	q	261-1
q	be	attribute	the conjunctive query	261-1
q	rule based	action	the conjunctive query	261-1
<B>	For	constraint	monotonicity	262-1
monotonicity	let	action	I	262-1
I	⊆	action	J	262-1
J	that	constraint	t ∈ q	262-1
J	and	conjunctive	t ∈ q	262-1
J	suppose	action	t ∈ q	262-1
t ∈ q		sequential	I	262-1
<B>	for	constraint	Then some valuation ν	262-2
Then some valuation ν	over	constraint	var	262-2
var		sequential	q	262-2
q		sequential	ν	262-2
ν		sequential	ui	262-2
ui		sequential	∈ I	262-2
∈ I		sequential	Ri	262-2
Ri	for	constraint	i	262-2
i		sequential	∈	262-2
∈		sequential	1	262-2
1		sequential	n	262-2
n	and	conjunctive	t	262-2
t	=	sequential	ν	262-2
ν		sequential	u	262-2
<B>	Because	constraint	I	262-3
I	⊆	action	J	262-3
J		sequential	ui	262-3
ui		sequential	ν ∈ J	262-3
ν ∈ J		sequential	Ri	262-3
Ri	for	constraint	so t ∈ q	262-3
Ri	and	conjunctive	so t ∈ q	262-3
so t ∈ q		sequential	J	262-3
<B>	For	constraint	satisfiability	263-1
satisfiability	be	attribute	d the set	263-1
satisfiability	let	action	d the set	263-1
d the set	of	constraint	constants	263-1
constants	in	constraint	q	263-1
constants	occurring	action	q	263-1
q	and	conjunctive	a ∈ dom	263-1
q	let	action	a ∈ dom	263-1
a ∈ dom	be	attribute	new	263-1
<B>	Define	action	I	264-1
I	over	constraint	the relation schemas	264-1
the relation schemas		sequential	R	264-1
R	of	constraint	the rule body	264-1
the rule body	so that	constraint	I	264-1
I		sequential	R	264-1
R	=	sequential	d	264-1
d		sequential	∪	264-1
∪	{	sequential	a }	264-1
a }		sequential	arity	264-1
arity		sequential	R	264-1
The monotonicity	of	constraint	the conjunctive queries	265-1
the conjunctive queries	to	constraint	limitations	265-1
the conjunctive queries	points	action	limitations	265-1
limitations	in	constraint	their expressive power	265-1
one	Indeed can easily exhibit	action	queries	265-2
queries		sequential	that	265-2
that	and	conjunctive	therefore not conjunctive queries	265-2
that	are	attribute	nonmonotonic	265-2
<B>	For	constraint	instance	265-3
instance		sequential	the query	265-3
the query		sequential	Which theaters	265-3
Which theaters	in	constraint	New York	265-3
New York	show	action	only Woody Allen films	265-3
only Woody Allen films	is	attribute	nonmonotonic	265-3
We	close	action	this subsection	266-1
this subsection	by	constraint	conjunctive queries	266-1
this subsection	indicating	action	conjunctive queries	266-1
this subsection	rule based	action	conjunctive queries	266-1
conjunctive queries	to	constraint	no queries	266-1
conjunctive queries	how can be used	action	no queries	266-1
conjunctive queries	express	action	no queries	266-1
<B>	For	constraint	example	266-2
example	consider	action	the query	266-2
<B>	To	constraint	an answer	267-1
<B>	provide	action	an answer	267-1
an answer		sequential	we	267-1
we	that	constraint	relation name	267-1
we	assume	action	relation name	267-1
relation name	ans	conjunctive	arity 0	267-1
relation name	has	action	arity 0	267-1
<B>	Then applying	action	the rule	267-2
the rule	←	sequential	Movies	267-2
Movies		sequential	x	267-2
x		sequential	Bergman	267-2
Bergman		sequential	y	267-2
y		sequential	Pariscope	267-2
Pariscope		sequential	z	267-2
z		sequential	x	267-2
x		sequential	w	267-2
w	returns	action	the relation	267-2
the relation	if	constraint	the answer	267-2
the answer	if	constraint	the answer	267-2
the answer	and	conjunctive	the answer	267-2
the answer	is	attribute	the answer	267-2
the answer	returns	action	the answer	267-2
the answer	is	attribute	<B>	267-2
Tableau Queries		sequential	Tableau Queries	268-1
<B>	to	constraint	a formulation	268-2
<B>	leads	action	a formulation	268-2
a formulation	of	constraint	conjunctive queries	268-2
conjunctive queries	called	action	<B>	268-2
Definition		sequential	4.2.3	269-1
A tableau query	is	attribute	simply a pair	269-2
simply a pair		sequential	T	269-2
T		sequential	u	269-2
u	or	conjunctive	T	269-2
T		sequential	u	269-2
u		sequential	T	269-2
T	is	attribute	where a tableau	269-2
where a tableau	and	conjunctive	each variable	269-2
each variable	in	constraint	u	269-2
u	in	constraint	T	269-2
u	also occurs	action	T	269-2
The summary tuple u	in	constraint	a tableau query	270-1
a tableau query		sequential	T	270-1
T		sequential	u	270-1
u	represents	action	the tuples	270-1
the tuples	in	constraint	the answer	270-1
the tuples	included	action	the answer	270-1
the answer	to	constraint	the query	270-1
the answer	of	constraint	all tuples u	270-2
the answer	Thus consists	action	all tuples u	270-2
all tuples u	for	constraint	which	270-2
which		sequential	the pattern	270-2
the pattern	by	constraint	T	270-2
the pattern	described	action	T	270-2
T	in	constraint	the database	270-2
T	is found	action	the database	270-2
Example		sequential	4.2.4	271-1
<B>	If	constraint	the unnamed perspective	271-2
the unnamed perspective	on	constraint	tuples	271-2
tuples	is used	action	the names	271-2
the names	of	constraint	the attributes	271-2
the attributes	in	constraint	u	271-2
the attributes	are not included	action	u	271-2
The notion	of	constraint	valuation	272-1
valuation	in	constraint	the natural fashion	272-1
valuation	is extended	action	the natural fashion	272-1
the natural fashion	to	constraint	tableaux1	272-1
the natural fashion	map	action	tableaux1	272-1
tableaux1	to	constraint	instances	272-1
An embedding	of	constraint	tableau T	272-2
tableau T	into	constraint	instance	272-2
instance		sequential	I	272-2
I	is	attribute	a valuation ν	272-2
a valuation ν	for	constraint	the variables	272-2
the variables	in	constraint	T such	272-2
the variables	occurring	action	T such	272-2
T such		sequential	that	272-2
that		sequential	ν	272-2
ν		sequential	T	272-2
T		sequential	⊆ I	272-2
The semantics	for	constraint	tableau queries	272-3
tableau queries	as	constraint	conjunctive queries	272-3
tableau queries	for	constraint	conjunctive queries	272-3
tableau queries	is	attribute	essentially the same	272-3
tableau queries	rule based	action	conjunctive queries	272-3
Conjunctive Queries Chapter		sequential	8	273-1
8		sequential	which	273-1
which	provides	action	an elegant characterization	273-1
an elegant characterization	of	constraint	two conjunctive queries	273-1
two conjunctive queries	yielding	action	identical results	273-1
identical results		sequential	the inputs	273-1
the inputs	when satisfy	action	certain dependencies	273-1
Conjunctive Calculus		sequential	Conjunctive Calculus	274-1
A review	of	constraint	predicate calculus	274-2
predicate calculus	in	constraint	Chapter 2	274-2
predicate calculus	is provided	action	Chapter 2	274-2
Chapter 2	but	conjunctive	the presentation	274-2
the presentation	of	constraint	the calculus	274-2
the calculus	in	constraint	the following chapter	274-2
the calculus	and	conjunctive	the following chapter	274-2
the following chapter	is	attribute	self	274-2
self	contained	action	<B>	274-2
We	by	constraint	conjunctive calculus queries	275-1
We	begin	action	conjunctive calculus queries	275-1
We	presenting	action	conjunctive calculus queries	275-1
conjunctive calculus queries		sequential	that	275-1
that	as	constraint	syntactic variants	275-1
that	can be viewed	action	syntactic variants	275-1
syntactic variants	of	constraint	conjunctive queries	275-1
syntactic variants	rule based	action	conjunctive queries	275-1
They	involve	action	simple use	275-2
simple use	of	constraint	conjunction	275-2
conjunction	and	conjunctive	existential quantification	275-2
<B>	As	constraint	the full conjunctive calculus	275-3
<B>	will be seen	action	the full conjunctive calculus	275-3
the full conjunctive calculus	defined later	action	unrestricted use	275-3
the full conjunctive calculus	allows	action	unrestricted use	275-3
unrestricted use	of	constraint	conjunction	275-3
conjunction	and	conjunctive	existential quantification	275-3
<B>	provides	action	more flexibility	275-4
more flexibility	in	constraint	the syntax	275-4
the syntax	as	constraint	expressive power	275-4
the syntax	but	conjunctive	expressive power	275-4
the syntax	will be seen	action	expressive power	275-4
the syntax	does not increase	action	expressive power	275-4
<B>	Consider	action	the conjunctive query	276-1
where x1		sequential	where x1	277-1
<B>	.	sequential	<B>	277-2
<B>	.	sequential	<B>	277-3
xk	are	attribute	all the variables	277-4
all the variables	in	constraint	the body	277-4
all the variables	occurring	action	the body	277-4
the body	and	conjunctive	not the head	277-4
The symbol	∧ denotes	action	conjunction	277-5
conjunction	and	conjunctive	existential quantification	277-5
conjunction	and	conjunctive	existential quantification	277-5
conjunction	denotes	action	existential quantification	277-5
existential quantification		sequential	<B>	277-5
Example		sequential	4.2.5	278-1
<B>	that	constraint	the existentially quantified variables	279-1
<B>	of	constraint	the existentially quantified variables	279-1
<B>	but	conjunctive	the existentially quantified variables	279-1
<B>	Note	attribute	some	279-1
the existentially quantified variables	play	action	the role	279-1
the role	of	constraint	anonymous variables	279-1
anonymous variables	in	constraint	the sense	279-1
the sense	in	constraint	Example 4.1.1	279-1
the sense	mentioned	action	Example 4.1.1	279-1
The syntax	as	constraint	a hybrid	280-1
The syntax	used here	action	a hybrid	280-1
The syntax	can be viewed	action	a hybrid	280-1
a hybrid	of	constraint	set	280-1
set		sequential	the usual notation	280-1
the usual notation	to	constraint	the form	280-1
the usual notation	used	action	the form	280-1
the usual notation	indicate	action	the form	280-1
the form	of	constraint	the query output	280-1
the query output	and	conjunctive	calculus	280-1
the query output	predicate	action	calculus	280-1
calculus	to	constraint	what	280-1
calculus	used	action	what	280-1
calculus	indicate	action	what	280-1
what	in	constraint	the output	280-1
what	should be included	action	the output	280-1
<B>	As	constraint	Chapter 2	280-2
<B>	in	constraint	Chapter 2	280-2
<B>	discussed	action	Chapter 2	280-2
Chapter 2		sequential	the semantics	280-2
the semantics	with	constraint	calculus formulas	280-2
the semantics	associated	action	calculus formulas	280-2
calculus formulas	is	attribute	a restricted version	280-2
a restricted version	of	constraint	the conventional semantics	280-2
the conventional semantics	in	constraint	order	280-2
the conventional semantics	found	attribute	first	280-2
order		sequential	logic	280-2
We	to	constraint	the formal definition	281-1
We	now turn	action	the formal definition	281-1
the formal definition	of	constraint	the syntax	281-1
the syntax	and	conjunctive	semantics	281-1
semantics	of	constraint	the conjunctive calculus	281-1
Definition		sequential	4.2.6	282-1
<B>	well formed	action	A formula	282-2
A formula	over	constraint	R	282-2
R	for	constraint	the conjunctive calculus	282-2
the conjunctive calculus	is	attribute	an expression	282-2
an expression	having	action	one	282-2
one	of	constraint	the following forms	282-2
the following forms		sequential	a an atom	282-2
a an atom	over	constraint	R	282-2
<B>	In	constraint	formulas	283-1
formulas		sequential	we	283-1
we	permit	action	the abbreviation	283-1
the abbreviation	of	constraint	∃x1	283-1
<B>	.	sequential	<B>	283-2
<B>	.	sequential	<B>	283-3
<B>	by	constraint	∃x1	283-4
<B>	.	sequential	<B>	283-5
<B>	.	sequential	<B>	283-6
xn		sequential	xn	283-7
The usual notion	of	constraint	occurrences	284-1
The usual notion	and	conjunctive	occurrences	284-1
The usual notion	bound	action	occurrences	284-1
occurrences	of	constraint	variables	284-1
variables	is now defined	action	<B>	284-1
An occurrence	of	constraint	variable x formula	284-2
An occurrence	in	constraint	variable x formula	284-2
variable x formula	if	constraint	<B>	284-2
variable x formula	is	attribute	free	284-2
Definition		sequential	4.2.7	285-1
4.2.7	is	attribute	where a conjunctive calculus formula	285-1
where a conjunctive calculus formula		sequential	e1	285-1
<B>	.	sequential	<B>	285-2
<B>	.	sequential	<B>	285-3
em	is	attribute	a free tuple	285-4
a free tuple	and	conjunctive	the set	285-4
the set	of	constraint	variables	285-4
variables	in	constraint	e1	285-4
variables	occurring	action	e1	285-4
<B>	.	sequential	<B>	285-5
<B>	.	sequential	<B>	285-6
em	is	attribute	exactly free ϕ	285-7
<B>	If	constraint	the named perspective	285-8
the named perspective	is being used	action	attributes	285-8
attributes	with	constraint	output tuples	285-8
attributes	can be associated	action	output tuples	285-8
output tuples	by	constraint	a relation name	285-8
output tuples	specifying	action	a relation name	285-8
a relation name		sequential	R	285-8
R	of	constraint	arity m	285-8
<B>	To	constraint	the semantics	286-1
<B>	define	action	the semantics	286-1
the semantics	of	constraint	conjunctive calculus queries	286-1
conjunctive calculus queries		sequential	it	286-1
it	to	constraint	some notation	286-1
it	is	attribute	convenient	286-1
it	introduce	action	some notation	286-1
<B>	that	constraint	finite set V ⊂ var	286-2
<B>	for	constraint	finite set V ⊂ var	286-2
<B>	Recall	action	finite set V ⊂ var	286-2
finite set V ⊂ var		sequential	a valuation	286-2
a valuation	over	constraint	V	286-2
V	is	attribute	a total function ν	286-2
a total function ν	from	constraint	V	286-2
V	to	constraint	<B>	286-2
V	dom	action	<B>	286-2
This valuation	as	constraint	a syntactic expression	286-3
This valuation	will sometimes be viewed	action	a syntactic expression	286-3
a syntactic expression	of	constraint	the form	286-3
the form		sequential	Conjunctive Queries	286-3
Conjunctive Queries		sequential	where x1	286-3
<B>	.	sequential	<B>	286-4
<B>	.	sequential	<B>	286-5
xn	is	attribute	a listing	286-6
a listing	of	constraint	V	286-6
V	and	conjunctive	ai	286-6
ai	=	sequential	ν	286-6
ν		sequential	xi	286-6
xi	for	constraint	i	286-6
i		sequential	∈	286-6
∈		sequential	1	286-6
1		sequential	n	286-6
<B>	as	constraint	a set	286-7
<B>	may also be interpreted	action	a set	286-7
<B>	For	constraint	example	286-8
example	if	constraint	x	286-8
x	in	constraint	not the domain	286-8
x	is	attribute	not the domain	286-8
not the domain	of	constraint	ν	286-8
ν	and	conjunctive	c	286-8
c		sequential	∈ dom	286-8
∈ dom		sequential	ν	286-8
ν		sequential	∪	286-8
∪	{	sequential	x /c	286-8
x /c	denotes	action	the valuation	286-8
the valuation	with	constraint	domain V ∪	286-8
domain V ∪	x	sequential	}	286-8
}		sequential	that	286-8
that	to	constraint	ν	286-8
that	is	attribute	identical	286-8
ν	on	constraint	V	286-8
V	and	conjunctive	maps x	286-8
maps x	to	constraint	c	286-8
<B>	Now let	action	R	287-1
R	be	attribute	a database schema	287-1
a database schema		sequential	a conjunctive calculus formula	287-1
a conjunctive calculus formula	over	constraint	R	287-1
R	and	conjunctive	a valuation	287-1
R	ν	action	a valuation	287-1
a valuation	over	constraint	<B>	287-1
I	under	constraint	ν	287-2
I	Then satisfies	action	ν	287-2
ν	denoted	action	I	287-2
I		sequential	ν	287-2
ν	if	constraint	ϕ	287-2
ϕ	=	sequential	R	287-2
R		sequential	u	287-2
u	is	attribute	a an atom	287-2
a an atom	and	conjunctive	ν	287-2
ν		sequential	u	287-2
u		sequential	∈ I	287-2
∈ I		sequential	R	287-2
R	or	conjunctive	<B>	287-2
<B>	Finally let	action	q	288-1
q		sequential	e1	288-1
<B>	.	sequential	<B>	288-2
<B>	.	sequential	<B>	288-3
<B>	be	attribute	a conjunctive calculus query	288-4
<B>	em	action	a conjunctive calculus query	288-4
a conjunctive calculus query	over	constraint	R	288-4
<B>	.	sequential	<B>	288-5
<B>	.	sequential	<B>	288-6
en		sequential	I	288-7
I		sequential	ν	288-7
ν	and	conjunctive	ν	288-7
ν	is	attribute	a valuation	288-7
a valuation	over	constraint	ϕ }	288-7
The active domain	of	constraint	a formula	289-1
a formula		sequential	denoted adom	289-1
denoted adom		sequential	ϕ	289-1
ϕ	is	attribute	the set	289-1
the set	of	constraint	constants	289-1
constants	in	constraint	queries q	289-1
constants	as with	constraint	queries q	289-1
constants	and	conjunctive	queries q	289-1
constants	occurring	action	queries q	289-1
queries q		sequential	we	289-1
we	use	action	adom	289-1
adom		sequential	ϕ	289-1
ϕ		sequential	I	289-1
I	to	constraint	adom	289-1
I	abbreviate	action	adom	289-1
adom		sequential	ϕ ∪ adom	289-1
ϕ ∪ adom		sequential	I	289-1
An easy induction	on	constraint	conjunctive calculus formulas	289-2
conjunctive calculus formulas	that	constraint	I	289-2
conjunctive calculus formulas	if	constraint	I	289-2
conjunctive calculus formulas	shows	action	I	289-2
I	|=	sequential	ν	289-2
ν		sequential	the range	289-2
the range	of	constraint	ν	289-2
ν	in	constraint	adom	289-2
ν	is contained	action	adom	289-2
adom		sequential	I	289-2
I	see	action	Exercise 4.3	289-2
<B>	in	constraint	turn	289-3
<B>	implies	action	turn	289-3
turn	that	constraint	a conjunctive calculus query	289-3
turn	to	constraint	a conjunctive calculus query	289-3
turn	evaluate	action	a conjunctive calculus query	289-3
a conjunctive calculus query		sequential	one	289-3
one	need only consider	action	valuations	289-3
valuations	with	constraint	range	289-3
range	in	constraint	adom	289-3
range	contained	action	adom	289-3
adom		sequential	ϕ	289-3
ϕ		sequential	I	289-3
I	and	conjunctive	only a finite number	289-3
only a finite number	of	constraint	them	289-3
This pleasant state	of	constraint	affairs	289-4
affairs	will no longer hold	action	disjunction	289-4
disjunction	or	conjunctive	negation	289-4
negation	into	constraint	the calculus	289-4
negation	when is incorporated	action	the calculus	289-4
the calculus	see	action	Section 4.5	289-4
Section 4.5	and	conjunctive	Chapter	289-4
Chapter		sequential	5	289-4
Conjunctive calculus formulas	and	conjunctive	ψ	290-1
ψ	over	constraint	R	290-1
R	if	constraint	they	290-1
R	are	attribute	equivalent	290-1
they	have	action	the same free variables	290-1
the same free variables	for	constraint	I	290-1
the same free variables	and	conjunctive	I	290-1
I	over	constraint	R	290-1
R	and	conjunctive	valuation	290-1
valuation		sequential	ν	290-1
ν	ϕ =	sequential	ψ	290-1
ψ		sequential	I	290-1
I		sequential	ν	290-1
ν		sequential	iff	290-1
iff		sequential	I	290-1
I		sequential	ψ	290-1
ψ		sequential	ν	290-1
It	that	constraint	ψ	290-2
It	if	constraint	ψ	290-2
It	and	conjunctive	ψ	290-2
It	is easily verified	action	ψ	290-2
ψ	if	constraint	9 ′	290-2
ψ	and	conjunctive	9 ′	290-2
ψ	are	attribute	equivalent	290-2
9 ′	is	attribute	the result	290-2
the result	of	constraint	an occurrence	290-2
the result	replacing	action	an occurrence	290-2
an occurrence	of	constraint	ψ	290-2
an occurrence	by	constraint	ψ	290-2
ψ	in	constraint	conjunctive calculus formula 9 9	290-2
conjunctive calculus formula 9 9	and	conjunctive	9	290-2
9		sequential	′	290-2
′	are	attribute	equivalent	290-2
′	see	action	Exercise 4.4	290-2
It	that	constraint	all conjunctive calculus formulas	291-1
It	for	constraint	all conjunctive calculus formulas	291-1
It	is easily verified	action	all conjunctive calculus formulas	291-1
all conjunctive calculus formulas		sequential	ψ	291-1
ψ	and	conjunctive	∧	291-1
∧		sequential	ψ	291-1
ψ	to	constraint	ψ	291-1
ψ	is	attribute	equivalent	291-1
ψ		sequential	ϕ	291-1
ϕ	and	conjunctive	∧	291-1
∧		sequential	ψ	291-1
ψ		sequential	∧ ξ	291-1
∧ ξ	to	constraint	∧ ψ	291-1
∧ ξ	is	attribute	equivalent	291-1
∧ ψ		sequential	∧	291-1
∧		sequential	ξ	291-1
<B>	For	constraint	this reason	291-2
this reason		sequential	we	291-2
we	may view	action	conjunction	291-2
conjunction	as	constraint	a polyadic connective	291-2
a polyadic connective		sequential	just binary	291-2
We	that	constraint	conjunctive calculus queries	292-1
We	next show	action	conjunctive calculus queries	292-1
conjunctive calculus queries		sequential	which	292-1
which	allow	action	unrestricted nesting	292-1
unrestricted nesting	of	constraint	∧	292-1
unrestricted nesting	and	conjunctive	∧	292-1
∧	than	constraint	the simple conjunctive queries	292-1
∧	are	attribute	no more powerful	292-1
the simple conjunctive queries	first exhibited	action	which	292-1
which	to	constraint	rules	292-1
which	correspond straightforwardly	action	rules	292-1
the simpler conjunctive queries	Thus provide	action	a normal form	292-2
a normal form	for	constraint	the full conjunctive calculus	292-2
<B>		sequential	a conjunctive calculus query	292-3
a conjunctive calculus query		sequential	q	292-3
q	=	sequential	u	292-3
q	{	sequential	u	292-3
u		sequential	}	292-3
}	in	constraint	normal form	292-3
}	is	attribute	normal form	292-3
normal form	if	constraint	ϕ	292-3
ϕ	has	action	the form	292-3
<B>	Consider now	action	rewrite	293-1
rewrite	or	conjunctive	transformation	293-1
transformation		sequential	the two rules	293-1
the two rules	for	constraint	conjunctive calculus queries	293-1
conjunctive calculus queries		sequential	Variable substitution	293-1
Variable substitution	replace	action	subformula	293-1
<B>	if	constraint	y	294-1
y	in	constraint	ψ	294-1
y	does not occur	action	ψ	294-1
ψ		sequential	ψx	294-1
ψx	where denotes	action	the formula	294-1
the formula	by	constraint	all free y occurrences	294-1
the formula	obtained	action	all free y occurrences	294-1
the formula	replacing	action	all free y occurrences	294-1
all free y occurrences	of	constraint	x	294-1
x	by	constraint	y	294-1
y	in	constraint	ψ	294-1
Merge-exists	replace	action	subformula	295-1
It	is easily verified	action	Exercise 4.4	296-1
It	see	action	Exercise 4.4	296-1
Exercise 4.4	that	constraint	application	296-1
application	of	constraint	these transformation rules	296-1
these transformation rules	to	constraint	a conjunctive calculus formula	296-1
a conjunctive calculus formula	1 yields	action	an equivalent formula	296-1
an equivalent formula	and	conjunctive	these rules	296-1
these rules	to	constraint	any conjunctive calculus formula	296-1
these rules	2 can be used	action	any conjunctive calculus formula	296-1
these rules	transform	action	any conjunctive calculus formula	296-1
any conjunctive calculus formula	into	constraint	an equivalent formula	296-1
an equivalent formula	in	constraint	normal form	296-1
It	follows	attribute	that	297-1
Lemma		sequential	4.2.8	297-1
We	now introduce	action	formal notation	298-1
formal notation	for	constraint	the expressive power	298-1
formal notation	comparing	action	the expressive power	298-1
the expressive power	of	constraint	query languages	298-1
<B>	Let	action	Q1	298-2
Q1	and	conjunctive	Q2	298-2
Q2	be	attribute	two query languages	298-2
two query languages	with	constraint	associated semantics	298-2
Q1	by	constraint	Q2	298-3
Q1	Then is dominated	action	Q2	298-3
Q2	or	conjunctive	Q1	298-3
Q1	than	constraint	Q2	298-3
Q1	is	attribute	weaker	298-3
Q2	denoted	action	Q1	298-3
Q1	⊑	sequential	Q2	298-3
Q2	if	constraint	each query q1	298-3
Q2	for	constraint	each query q1	298-3
each query q1	in	constraint	Q1	298-3
Q1		sequential	there	298-3
there	is	attribute	a query	298-3
a query		sequential	q2	298-3
q2	in	constraint	Q2	298-3
Q2		sequential	that q1 q2	298-3
Q1	and	conjunctive	Q2	298-4
Q2	are	attribute	equivalent	298-4
Q2	denoted	action	Q1	298-4
Q1	≡	sequential	Q2	298-4
Q2	if	constraint	Q1 ⊑ Q2	298-4
Q1 ⊑ Q2	and	conjunctive	Q2 ⊑ Q1	298-4
<B>	Because of	constraint	the close correspondence	299-1
the close correspondence	between	constraint	conjunctive queries	299-1
the close correspondence	rule based	action	conjunctive queries	299-1
conjunctive queries		sequential	tableau queries	299-1
tableau queries	and	conjunctive	conjunctive calculus queries	299-1
conjunctive calculus queries	in	constraint	normal form	299-1
normal form	is easily verified	action	Exercise 4.15	299-1
normal form	see	action	Exercise 4.15	299-1
Proposition		sequential	4.2.9	300-1
<B>	of	constraint	these results	301-1
these results	because of	constraint	the high contrast	301-1
these results	be	attribute	will surprising	301-1
the high contrast	between	constraint	the languages	301-1
<B>	Incorporating	action	Equality	302-1
<B>	For	constraint	example	302-2
example		sequential	query	302-2
query		sequential	4.4	302-2
4.4	as	constraint	ans	302-2
4.4	can be expressed	action	ans	302-2
ans		sequential	xth	302-2
xth		sequential	xad	302-2
xad		sequential	Movies	302-2
Movies		sequential	xti	302-2
xti		sequential	xd	302-2
xd		sequential	xac	302-2
xac		sequential	xd	302-2
xd	=	sequential	Bergman	302-2
Bergman		sequential	Pariscope	302-2
Pariscope		sequential	xth	302-2
xth		sequential	xti	302-2
xti		sequential	xs	302-2
xs		sequential	Location	302-2
Location		sequential	xth	302-2
xth		sequential	xad	302-2
xad		sequential	xp	302-2
Conjunctive Queries		sequential	Conjunctive Queries	303-1
<B>	Although	constraint	two problems	303-2
<B>	is	attribute	basically true	303-2
two problems	arise	action	<B>	303-2
unrestricted rules	with	constraint	equality	303-3
equality	First may yield	action	infinite answers	303-3
<B>	For	constraint	example	303-4
example	in	constraint	the rule	303-4
the rule		sequential	y	303-4
y	and	conjunctive	z	303-4
z	to	constraint	relation R	303-4
z	are not tied	action	relation R	303-4
relation R	and	conjunctive	there	303-4
there	are	attribute	infinitely many valuations	303-4
infinitely many valuations	satisfying	action	the body	303-4
the body	of	constraint	the rule	303-4
<B>	To	constraint	finite answers	303-5
<B>	ensure	action	finite answers	303-5
finite answers		sequential	it	303-5
it	to	constraint	an appropriate notion	303-5
it	is	attribute	necessary	303-5
it	introduce	action	an appropriate notion	303-5
an appropriate notion	of	constraint	range restriction	303-5
an unrestricted rule	with	constraint	equality	303-6
equality		sequential	range	303-6
range	if	constraint	the equalities	303-6
range	Informally is restricted	action	the equalities	303-6
the equalities	that	constraint	each variable	303-6
the equalities	require	action	each variable	303-6
each variable	in	constraint	the body	303-6
the body	to	constraint	an atom R	303-6
the body	in	constraint	an atom R	303-6
the body	or	conjunctive	an atom R	303-6
the body	be	attribute	equal	303-6
the body	occurring	action	an atom R	303-6
an atom R		sequential	ui	303-6
ui		sequential	Exercise 4.5	303-6
Exercise 4.5	explores	action	the notion	303-6
the notion	of	constraint	range restriction	303-6
range restriction	in	constraint	more detail	303-6
rule	based	action	A conjunctive query	303-7
A conjunctive query	with	constraint	equality	303-7
equality	is	attribute	range	303-7
range	restricted	action	a rule	303-7
a rule	with	constraint	equality	303-7
The equalities	in	constraint	this query	304-1
this query	that	constraint	a b	304-1
this query	require	action	a b	304-1
a b		sequential	which	304-1
which	is	attribute	impossible	304-1
there	Thus is	action	no valuation	304-2
no valuation	satisfying	action	the body	304-2
the body	of	constraint	the rule	304-2
the rule	and	conjunctive	the query	304-2
the query	yields	action	the empty relation	304-2
the empty relation	on	constraint	all inputs	304-2
We	use	action	q∅	304-3
q∅		sequential	R	304-3
R		sequential	R	304-3
R	or	conjunctive	q∅	304-3
q∅	if	constraint	R	304-3
R	and	conjunctive	R	304-3
R	to	constraint	the query	304-3
R	are understood	action	the query	304-3
R	denote	action	the query	304-3
the query		sequential	that	304-3
that	maps	action	all inputs	304-3
all inputs	over	constraint	R	304-3
R	to	constraint	the empty relation	304-3
the empty relation	over	constraint	R. Finally	304-3
R. Finally	that	constraint	one	304-3
R. Finally	note	action	one	304-3
one	if	constraint	the equalities	304-3
one	can easily check	action	the equalities	304-3
the equalities	in	constraint	a conjunctive query	304-3
a conjunctive query	with	constraint	equality	304-3
equality	if	constraint	the query	304-3
equality	and	conjunctive	the query	304-3
equality	are	attribute	unsatisfiable	304-3
the query	to	constraint	q∅	304-3
the query	is	attribute	hence equivalent	304-3
<B>	by	constraint	the transitive closure	304-4
<B>	is done	action	the transitive closure	304-4
<B>	computing	action	the transitive closure	304-4
the transitive closure	of	constraint	the equalities	304-4
the equalities	in	constraint	the query	304-4
the query	that	constraint	no two distinct constants	304-4
the query	and	conjunctive	no two distinct constants	304-4
the query	checking	action	no two distinct constants	304-4
no two distinct constants	to	constraint	<B>	304-4
no two distinct constants	are required	attribute	equal	304-4
no two distinct constants	be	attribute	equal	304-4
Each satisfiable rule	with	constraint	equality	304-5
equality	to	constraint	a rule	304-5
equality	is	attribute	equivalent	304-5
a rule	without	constraint	equality	304-5
equality	see	action	Exercise 4.5 c	304-5
One	can incorporate	action	equality	305-1
equality	into	constraint	tableau queries	305-1
tableau queries	in	constraint	a similar manner	305-1
a similar manner	by	constraint	a set	305-1
a similar manner	adding separately	action	a set	305-1
a set	of	constraint	required equalities	305-1
no expressive power	if	constraint	the query	305-2
no expressive power	Once again is gained	action	the query	305-2
the query	is	attribute	satisfiable	305-2
<B>	Incorporating	action	equality	305-3
equality	into	constraint	the conjunctive calculus	305-3
the conjunctive calculus	in	constraint	Exercise 4.6	305-3
the conjunctive calculus	is considered	action	Exercise 4.6	305-3
Query Composition	and	conjunctive	Views	306-1
A main result here	that	constraint	the conjunctive queries	306-2
A main result here	is	attribute	the conjunctive queries	306-2
A main result here	rule based	action	the conjunctive queries	306-2
the conjunctive queries	with	constraint	equality	306-2
equality	under	constraint	composition	306-2
equality	are closed	action	composition	306-2
<B>	Consider	action	a database	307-1
a database		sequential	R	307-1
R	=	sequential	R1	307-1
R	{	sequential	R1	307-1
<B>	.	sequential	<B>	307-2
<B>	.	sequential	<B>	307-3
Rn }		sequential	Rn }	307-4
<B>	that	constraint	we	307-5
<B>	Suppose	action	we	307-5
we	have	action	a query q	307-5
a query q	in	constraint	the preceding formalisms	307-5
a query q	of	constraint	the preceding formalisms	307-5
<B>	to	constraint	a relation	307-6
<B>	Conceptually can be used	action	a relation	307-6
<B>	define	action	a relation	307-6
a relation	with	constraint	new relation name S1	307-6
new relation name S1		sequential	which	307-6
which	in	constraint	subsequent queries	307-6
which	can be used	action	subsequent queries	307-6
subsequent queries	as	constraint	any ordinary relation	307-6
any ordinary relation	from	constraint	R	307-6
<B>	In	constraint	this context	307-7
this context		sequential	we	307-7
we	of	constraint	S1 S2	307-7
we	could call	attribute	each	307-7
<B>	.	sequential	<B>	307-8
<B>	.	sequential	<B>	307-9
<B>	in	constraint	contrast	307-10
contrast	with	constraint	the extensional relations	307-10
the extensional relations	of	constraint	R	307-10
This perspective	on	constraint	query composition	308-1
query composition	within	constraint	the paradigm	308-1
query composition	is expressed most conveniently	action	the paradigm	308-1
query composition	rule based	action	the paradigm	308-1
a conjunctive query program	with	constraint	equality	308-2
a conjunctive query program	without	constraint	equality	308-2
a conjunctive query program	or	conjunctive	equality	308-2
equality	is	attribute	Specifically a sequence P	308-2
Specifically a sequence P	of	constraint	rules	308-2
rules	having	action	the form	308-2
the form		sequential	S1	308-2
S1		sequential	u1	308-2
u1		sequential	body	308-2
body		sequential	1 S2	308-2
1 S2		sequential	u2	308-2
u2		sequential	body 2	308-2
<B>		sequential	Sm body m	309-1
Sm body m		sequential	each Si	309-1
each Si	in	constraint	not R	309-1
each Si	and	conjunctive	not R	309-1
each Si	is	attribute	where distinct	309-1
not R	for	constraint	each i	309-1
not R	and	conjunctive	each i	309-1
each i		sequential	∈	309-1
∈		sequential	1	309-1
1		sequential	m	309-1
m		sequential	the only relation names	309-1
the only relation names		sequential	that	309-1
that	in	constraint	body	309-1
that	may occur	action	body	309-1
body		sequential	i	309-1
i	are	attribute	R1	309-1
<B>	.	sequential	<B>	309-2
<B>	.	sequential	<B>	309-3
Rn	and	conjunctive	S1	309-4
<B>	.	sequential	<B>	309-5
<B>	.	sequential	<B>	309-6
Si−1		sequential	Si−1	309-7
An instance		sequential	I	309-8
I	over	constraint	R	309-8
R	and	conjunctive	the program P	309-8
the program P	as	constraint	defining values	309-8
the program P	can be viewed	action	defining values	309-8
defining values	for	constraint	S1	309-8
defining values	of	constraint	S1	309-8
<B>	.	sequential	<B>	309-9
<B>	.	sequential	<B>	309-10
Sm	in	constraint	the following way	309-11
the following way	For	constraint	i	309-11
i		sequential	∈	309-11
∈		sequential	1	309-11
1		sequential	m	309-11
m		sequential	P	309-11
P		sequential	I	309-11
I		sequential	Si	309-11
Si	=	sequential	qi	309-11
qi		sequential	P	309-11
P		sequential	I	309-11
I		sequential	qi	309-11
qi	is	attribute	where the ith rule	309-11
where the ith rule	and	conjunctive	relation Si	309-11
where the ith rule	defines	action	relation Si	309-11
relation Si	in	constraint	terms	309-11
terms	of	constraint	I	309-11
I	and	conjunctive	the previous Sj	309-11
the previous Sj		sequential	<B>	309-11
<B>	If	constraint	P	309-12
P	as	constraint	a single output relation	309-12
P	is viewed	action	a single output relation	309-12
P	defining	action	a single output relation	309-12
a single output relation		sequential	this output	309-12
this output	is	attribute	P	309-12
P		sequential	I	309-12
I		sequential	Sm	309-12
<B>	to	constraint	conjunctive queries	309-13
<B>	rule based	action	conjunctive queries	309-13
conjunctive queries		sequential	the relations	309-13
the relations	in	constraint	R	309-13
Example		sequential	4.3.1	310-1
Figure		sequential	4.3	311-1
4.3	shows	action	an example instance I	311-1
an example instance I	for	constraint	R	311-1
R	and	conjunctive	the values	311-1
the values		sequential	that	311-1
that	to	constraint	S1	311-1
that	are associated	action	S1	311-1
S1		sequential	S2	311-1
S2		sequential	S3	311-1
S3	by	constraint	P	311-1
P		sequential	I	311-1
It	that	constraint	the effect	312-1
It	is easily verified	action	the effect	312-1
the effect	of	constraint	the first two rules	312-1
the first two rules	of	constraint	P	312-1
P	on	constraint	S2	312-1
S2	to	constraint	the effect	312-1
S2	is	attribute	equivalent	312-1
the effect	of	constraint	the rule	312-1
the rule		sequential	S2	312-1
S2		sequential	x	312-1
x		sequential	y	312-1
y		sequential	z	312-1
z		sequential	Q	312-1
Q		sequential	x1	312-1
x1		sequential	y1	312-1
y1		sequential	R	312-1
R		sequential	y1	312-1
y1		sequential	z1	312-1
z1		sequential	w1	312-1
w1		sequential	x	312-1
x	=	sequential	x1	312-1
x1		sequential	w	312-1
w	=	sequential	z1	312-1
z1		sequential	R	312-1
R		sequential	w	312-1
w		sequential	y	312-1
y		sequential	v	312-1
v		sequential	Q	312-1
Q		sequential	x2	312-1
x2		sequential	y2	312-1
y2		sequential	R	312-1
R		sequential	y2	312-1
y2		sequential	z2	312-1
z2		sequential	w2	312-1
w2		sequential	v	312-1
v	=	sequential	x2	312-1
x2		sequential	z	312-1
z	=	sequential	z2	312-1
S2		sequential	x	313-1
x		sequential	y	313-1
y		sequential	z	313-1
z		sequential	Q	313-1
Q		sequential	x	313-1
x		sequential	y1	313-1
y1		sequential	R	313-1
R		sequential	y1	313-1
y1		sequential	w	313-1
w		sequential	w1	313-1
w1		sequential	R	313-1
R		sequential	w	313-1
w		sequential	y	313-1
y		sequential	v	313-1
v		sequential	Q	313-1
Q		sequential	v	313-1
v		sequential	y2	313-1
y2		sequential	R	313-1
R		sequential	y2	313-1
y2		sequential	z	313-1
z		sequential	w2	313-1
<B>	Note	action	variables	314-1
variables	to	constraint	undesired cross talk	314-1
variables	how are renamed	action	undesired cross talk	314-1
variables	prevent	action	undesired cross talk	314-1
undesired cross talk	between	constraint	the different rule bodies	314-1
the different rule bodies		sequential	that	314-1
that	to	constraint	this rule	314-1
that	are combined	action	this rule	314-1
that	form	action	this rule	314-1
The effect	of	constraint	P	314-2
P	on	constraint	S3	314-2
S3	can also be expressed	action	a single rule	314-2
S3	using	action	a single rule	314-2
a single rule	without	constraint	equality	314-2
equality	see	action	Exercise 4.7	314-2
It	to	constraint	a permutation	315-1
It	that	constraint	a permutation	315-1
It	if	constraint	a permutation	315-1
It	is	attribute	straightforward	315-1
It	verify	action	a permutation	315-1
a permutation		sequential	P ′	315-1
P ′	of	constraint	P	315-1
P		sequential	a listing	315-1
a listing	of	constraint	the elements	315-1
the elements	of	constraint	P	315-1
P	in	constraint	a possibly different order	315-1
a possibly different order	satisfies	action	the restriction	315-1
the restriction	that	constraint	relation names	315-1
relation names	in	constraint	a rule body	315-1
a rule body	in	constraint	must a previous rule head	315-1
a rule body	be	attribute	must a previous rule head	315-1
must a previous rule head		sequential	P	315-1
P		sequential	′	315-1
′	will define	action	the same mapping	315-1
the same mapping	as	constraint	P	315-1
This kind	of	constraint	consideration	315-2
consideration	in	constraint	a richer context	315-2
consideration	will arise	action	a richer context	315-2
a richer context		sequential	stratified negation	315-2
stratified negation	in	constraint	Chapter 15	315-2
stratified negation	when is considered	action	Chapter 15	315-2
Conjunctive Queries Q		sequential	R	316-1
R		sequential	S1	316-1
S1		sequential	S2 S3	316-1
S2 S3		sequential	Figure 4.3	316-1
Figure 4.3		sequential	Example 4.3.2	316-1
P	Clearly always defines	action	the empty relation S	317-1
the empty relation S		sequential	it	317-1
it	to	constraint	any conjunctive query	317-1
it	is	attribute	so not equivalent	317-1
it	rule based	action	any conjunctive query	317-1
any conjunctive query	without	constraint	equality	317-1
the use	of	constraint	the constants	317-2
the constants	and	conjunctive	b	317-2
b	in	constraint	P	317-2
P	Intuitively masks	action	the use	317-2
the use	of	constraint	equalities	317-2
equalities		sequential	which	317-2
which	in	constraint	this case	317-2
this case	and	conjunctive	an unsatisfiable query	317-2
this case	are	attribute	contradictory	317-2
this case	yield	action	an unsatisfiable query	317-2
<B>	on	constraint	the previous examples	318-1
<B>	Based	action	the previous examples	318-1
the previous examples	is easily verified	action	Exercise 4.7	318-1
the previous examples	see	action	Exercise 4.7	318-1
Theorem		sequential	4.3.3	319-1
4.3.3		sequential	Closure	319-1
Closure	under	constraint	Composition	319-1
<B>	if	constraint	P	319-2
P	is	attribute	satisfiable	319-2
q	without	constraint	equality	319-2
q	Furthermore can be expressed	action	equality	319-2
The notion	of	constraint	programs	320-1
programs	on	constraint	rule	320-1
programs	is based	action	rule	320-1
rule	based	action	the formalism	320-1
the formalism	of	constraint	the conjunctive queries	320-1
<B>	In	constraint	the other versions	320-2
the other versions	in	constraint	later this chapter	320-2
the other versions	and	conjunctive	later this chapter	320-2
the other versions	introduced previously	action	later this chapter	320-2
later this chapter		sequential	the notation	320-2
the notation	does not conveniently include	action	a mechanism	320-2
a mechanism	for	constraint	names	320-2
a mechanism	specifying	action	names	320-2
names	for	constraint	the output	320-2
the output	of	constraint	intermediate queries	320-2
<B>	For	constraint	the other formalisms	320-3
the other formalisms		sequential	we	320-3
we	use	action	a slightly more elaborate notation	320-3
a slightly more elaborate notation		sequential	that	320-3
that	permits	action	the specification	320-3
the specification	of	constraint	these names	320-3
<B>	In	constraint	the formalisms	320-4
<B>	of	constraint	the formalisms	320-4
the formalisms	with	constraint	a functional paradigm	320-4
the formalisms	are	attribute	compatible	320-4
the formalisms	purely expression based	action	a functional paradigm	320-4
a functional paradigm	let	action	S1	320-4
S1		sequential	q1	320-4
q1	in	constraint	let S2	320-4
let S2	= in	sequential	q2	320-4
<B>	let	action	Sm−1	321-1
Sm−1		sequential	qm−1	321-1
qm−1	in	constraint	qm	321-1
qm		sequential	S1	321-1
S1	=	sequential	q1	321-1
q1		sequential	S2	321-1
S2	=	sequential	q2	321-1
Sm−1	=	sequential	qm−1	322-1
qm−1		sequential	Sm	322-1
Sm	=	sequential	qm	322-1
It	from	constraint	Proposition 4.2.9	323-1
It	is	attribute	clear	323-1
Proposition 4.2.9	and	conjunctive	Theorem 4.3.3	323-1
Theorem 4.3.3	that	constraint	the conjunctive calculus	323-1
the conjunctive calculus	and	conjunctive	tableau queries	323-1
tableau queries	with	constraint	equality	323-1
equality	under	constraint	composition	323-1
equality	both	conjunctive	composition	323-1
equality	are closed	action	composition	323-1
Composition	and	conjunctive	User Views	324-1
User Views	that	constraint	the top level	324-1
User Views	Recall	action	the top level	324-1
the top level	of	constraint	three level	324-1
three level		sequential	the architecture	324-1
the architecture	for	constraint	databases	324-1
databases	see	action	Chapter 1	324-1
Chapter 1	of	constraint	user views	324-1
Chapter 1	consists	action	user views	324-1
user views		sequential	versions	324-1
versions	of	constraint	the data	324-1
the data		sequential	that	324-1
that	and	conjunctive	possibly restricted images	324-1
that	are restructured	action	possibly restricted images	324-1
possibly restricted images	of	constraint	the database	324-1
the database	as	constraint	the middle level	324-1
the database	at	constraint	the middle level	324-1
the database	represented	action	the middle level	324-1
<B>	In	constraint	many cases	324-2
many cases		sequential	these views	324-2
these views	as	constraint	queries	324-2
these views	are specified	action	queries	324-2
queries	or	conjunctive	query programs	324-2
<B>	may be materialized	action	a physical copy	324-3
a physical copy	of	constraint	the view	324-3
the view	and	conjunctive	relevant information	324-3
the view	or	conjunctive	relevant information	324-3
the view	is stored	attribute	virtual	324-3
the view	maintained	attribute	virtual	324-3
relevant information	about	constraint	the view	324-3
the view	as	constraint	<B>	324-3
the view	is computed	action	<B>	324-3
the view	needed	action	<B>	324-3
<B>	In	constraint	the latter case	324-4
the latter case		sequential	queries	324-4
queries	against	constraint	the view	324-4
the view	generate	action	composed queries	324-4
composed queries	against	constraint	the underlying database	324-4
the underlying database	as	constraint	the following example	324-4
the underlying database	by	constraint	the following example	324-4
the underlying database	illustrated	action	the following example	324-4
Example		sequential	4.3.4	325-1
The conjunctive query		sequential	What titles	326-1
What titles	in	constraint	Marilyn	326-1
Marilyn	at	constraint	the Le Champo	326-1
Marilyn	are featured	action	the Le Champo	326-1
the Le Champo	at	constraint	21:00	326-1
21:00	against	constraint	the view	326-1
21:00	can be expressed as	action	the view	326-1
Pariscope		sequential	Le Champo	327-1
Le Champo		sequential	xt	327-1
xt		sequential	21:00	327-1
21:00		sequential	Location	327-1
Location		sequential	Le Champo	327-1
Le Champo		sequential	xa	327-1
xa		sequential	xp	327-1
Conjunctive Queries Marilyn	=	sequential	xt	328-1
xt		sequential	∃xd	328-1
∃xd		sequential	Movies	328-1
Movies		sequential	xt	328-1
xt		sequential	xd	328-1
xd		sequential	Monroe	328-1
Monroe		sequential	Champo	328-1
Champo		sequential	info	328-1
info	=	sequential	xt	328-1
xt		sequential	xs	328-1
xs		sequential	xp	328-1
xp		sequential	∃xa	328-1
∃xa		sequential	Location	328-1
Location		sequential	Le Champo	328-1
Le Champo		sequential	xt	328-1
xt		sequential	xs	328-1
This example	illustrates	action	the case	329-1
the case	in	constraint	which	329-1
which		sequential	a query	329-1
a query	over	constraint	a single view	329-1
a query	is evaluated	action	a single view	329-1
a single view		sequential	evaluation	329-1
evaluation	of	constraint	the query	329-1
the query	involves	action	two layer	329-1
two layer		sequential	a composition	329-1
a composition	of	constraint	queries	329-1
<B>	If	constraint	a series	329-2
a series	of	constraint	nested views	329-2
nested views	is defined	action	query evaluation	329-2
query evaluation	can involve	action	query compositions	329-2
query compositions	or	conjunctive	two layers	329-2
query compositions	having	attribute	more	329-2
The use	of	constraint	algebra operators	330-1
algebra operators	provides	action	a distinctly different perspective	330-1
a distinctly different perspective	on	constraint	the conjunctive queries	330-1
There	are	attribute	two distinct algebras	330-2
two distinct algebras	with	constraint	the conjunctive queries	330-2
two distinct algebras	associated	action	the conjunctive queries	330-2
the conjunctive queries	and	conjunctive	they	330-2
they	from	constraint	ordered tuple	330-2
they	stem	action	ordered tuple	330-2
ordered tuple		sequential	the named perspective	330-2
the named perspective	and	conjunctive	function	330-2
function	based	action	the unnamed perspective	330-2
<B>	After	constraint	the two algebras	330-3
<B>	presenting	action	the two algebras	330-3
the two algebras		sequential	their equivalence	330-3
their equivalence	with	constraint	the conjunctive queries	330-3
the conjunctive queries	is discussed	action	<B>	330-3
The Unnamed Perspective The SPC Algebra		sequential	The Unnamed Perspective The SPC Algebra	331-1
<B>	Although	constraint	their application	331-2
their application	must satisfy	action	some typing constraints	331-2
some typing constraints		sequential	they	331-2
they	in	constraint	the sense	331-2
they	are	attribute	polymorphic	331-2
the sense	that	constraint	these operators	331-2
the sense	of	constraint	these operators	331-2
these operators	to	constraint	instances	331-2
these operators	can be applied	action	instances	331-2
instances	of	constraint	an infinite number	331-2
an infinite number	of	constraint	arities	331-2
arities	or	conjunctive	sorts	331-2
<B>	For	constraint	example	331-3
example	as	constraint	Chapter 3	331-3
example	in	constraint	Chapter 3	331-3
example	suggested	action	Chapter 3	331-3
Chapter 3		sequential	the union operator	331-3
the union operator	can take	action	as input	331-3
as input		sequential	any two relation instances	331-3
any two relation instances	having	action	the same sort	331-3
Three primitive algebra operators	form	action	the unnamed conjunctive algebra	332-1
the unnamed conjunctive algebra		sequential	selection	332-1
selection		sequential	projection	332-1
projection	and	conjunctive	cross-product	332-1
cross-product	or	conjunctive	Cartesian product	332-1
This algebra	to	constraint	the SPC algebra	332-2
This algebra	as	constraint	the SPC algebra	332-2
This algebra	is more often referred	action	the SPC algebra	332-2
the SPC algebra	on	constraint	the first letters	332-2
the SPC algebra	based	action	the first letters	332-2
the first letters	of	constraint	the three operators	332-2
the three operators		sequential	that	332-2
that	form	action	it	332-2
This convention	to	constraint	other algebras	332-3
This convention	will be used	action	other algebras	332-3
This convention	specify as well	action	other algebras	332-3
An example	before	constraint	the formal definition	332-4
An example	is given	action	the formal definition	332-4
the formal definition	of	constraint	these operators	332-4
Example		sequential	4.4.1	333-1
we	First use	action	selection	333-2
selection	to	constraint	the tuples	333-2
selection	extract	action	the tuples	333-2
the tuples	of	constraint	Movies	333-2
Movies		sequential	that	333-2
that	have	action	Bergman	333-2
Bergman	as	constraint	director	333-2
I1 =		sequential	σ 2	334-1
σ 2	=	sequential	Bergman	334-1
Bergman		sequential	Movies	334-1
I2 =		sequential	I1	335-1
I1	×	constraint	Pariscope	335-1
I3	=	sequential	σ 1=5	336-1
σ 1=5		sequential	I2	336-1
I4	=	sequential	4	337-1
I4	π	sequential	4	337-1
4		sequential	I3	337-1
I3	with	constraint	Location	337-1
I3	is paired	action	Location	337-1
Location	on	constraint	Theater	337-1
Location	and	conjunctive	Theater	337-1
Location	projected	action	Theater	337-1
Theater	and	conjunctive	Address	337-1
Address		sequential	the columns	337-1
the columns	to	constraint	the answer	337-1
the columns	yield	action	the answer	337-1
I5	=	sequential	π	338-1
π		sequential	2,3	338-1
2,3		sequential	σ 1=2	338-1
σ 1=2		sequential	I4 × Location	338-1
<B>	In	constraint	the pure SPC algebra	338-2
the pure SPC algebra		sequential	this query	338-2
this query	as	constraint	π 2,3 × Location	338-2
this query	is expressed	action	π 2,3 × Location	338-2
π 2,3 × Location		sequential	σ	338-2
σ		sequential	1=2	338-2
1=2		sequential	π	338-2
π		sequential	4	338-2
4		sequential	σ	338-2
σ		sequential	1=5	338-2
1=5		sequential	σ 2	338-2
σ 2	=	sequential	Bergman	338-2
Bergman		sequential	Movies	338-2
Movies	×	constraint	Pariscope	338-2
<B>	to	constraint	the conjunctive calculus query	339-1
<B>	corresponds closely	action	the conjunctive calculus query	339-1
the conjunctive calculus query	of	constraint	Example 4.2.5	339-1
Their actual implementation	from	constraint	the original form	340-1
Their actual implementation	is	attribute	usually quite different	340-1
the original form	of	constraint	the query	340-1
the query	as	constraint	Section 6.1	340-1
the query	in	constraint	Section 6.1	340-1
the query	will be discussed	action	Section 6.1	340-1
We	now formally define	action	the three operators	341-1
the three operators	forming	action	the SPC algebra	341-1
Selection		sequential	Selection	342-1
The two primitive forms	are	attribute	σ j=a	342-2
σ j=a	and	conjunctive	σ	342-2
σ		sequential	j=k	342-2
j=k		sequential	j	342-2
j		sequential	k	342-2
k	are	attribute	where positive integers	342-2
where positive integers	and	conjunctive	a ∈ dom	342-2
<B>	In	constraint	practice	342-3
practice		sequential	we	342-3
we	usually surround	action	constants	342-3
constants	with	constraint	quotes	342-3
The operator σ j=a	as	constraint	input	342-4
The operator σ j=a	takes	action	input	342-4
input		sequential	any relation instance	342-4
any relation instance		sequential	I	342-4
I	with	constraint	arity	342-4
arity		sequential	≥ j	342-4
≥ j	as	constraint	output	342-4
≥ j	and	conjunctive	output	342-4
≥ j	returns	action	output	342-4
output		sequential	an instance	342-4
an instance	of	constraint	the same arity	342-4
<B>	In	constraint	<B>	342-5
The operator σ j=k	for	constraint	positive integers j	343-1
positive integers j		sequential	k	343-1
k	for	constraint	inputs	343-1
k	is defined analogously	action	inputs	343-1
inputs	with	constraint	arity	343-1
Conjunctive Queries Projection		sequential	This operator	344-1
This operator	to	constraint	columns	344-1
This operator	and	conjunctive	columns	344-1
This operator	or	conjunctive	columns	344-1
This operator	can be used	action	columns	344-1
This operator	delete	action	columns	344-1
This operator	permute	action	columns	344-1
columns	of	constraint	a relation	344-1
The general form	of	constraint	this operator	344-2
this operator	is	attribute	πj empty sequence	344-2
πj empty sequence	of	constraint	positive integers	344-2
positive integers		sequential	the empty sequence	344-2
the empty sequence	with	constraint	possibly repeats	344-2
the empty sequence	is written	action	possibly repeats	344-2
This operator	as	constraint	input	344-3
This operator	takes	action	input	344-3
input		sequential	any relation instance	344-3
any relation instance	with	constraint	arity	344-3
arity		sequential	≥ max	344-3
≥ max	{	sequential	j1	344-3
<B>	.	sequential	<B>	344-4
<B>	.	sequential	<B>	344-5
jn		sequential	jn	344-6
Cross-product	or	conjunctive	Cartesian product	345-1
It	as	constraint	inputs	345-2
It	takes	action	inputs	345-2
inputs		sequential	a pair	345-2
a pair	of	constraint	relations	345-2
relations	having	action	arbitrary arities	345-2
arbitrary arities	n	conjunctive	m	345-2
arbitrary arities	and	conjunctive	m	345-2
m	and	conjunctive	a relation	345-2
m	returns	action	a relation	345-2
a relation	with	constraint	arity	345-2
arity	n	conjunctive	m	345-2
arity	+	sequential	m	345-2
<B>	.	sequential	<B>	345-3
<B>	.	sequential	<B>	345-4
t		sequential	n	345-5
n		sequential	1	345-5
<B>	.	sequential	<B>	345-6
<B>	.	sequential	<B>	345-7
<B>		sequential	m	345-8
m		sequential	t ∈	345-8
t ∈		sequential	I	345-8
I	and	conjunctive	∈	345-8
∈		sequential	J	345-8
J		sequential	}	345-8
Cross-product	and	conjunctive	0 ary	346-1
Cross-product	and	conjunctive	0 ary	346-1
Cross-product	is	attribute	associative	346-1
Cross-product	has	action	0 ary	346-1
0 ary		sequential	the nonempty relation	346-1
We	extend	action	the cross-product operator	347-1
the cross-product operator	to	constraint	tuples	347-1
tuples	in	constraint	the natural fashion	347-1
the natural fashion		sequential	that	347-1
that	is	attribute	u	347-1
u		sequential	× v	347-1
× v	is	attribute	a tuple	347-1
a tuple	with	constraint	arity	347-1
arity	=	sequential	arity	347-1
arity		sequential	u	347-1
u	+	sequential	arity	347-1
arity		sequential	v	347-1
The SPC algebra	is	attribute	the family	348-1
the family	of	constraint	expressions	348-1
the family	well formed	action	expressions	348-1
expressions	containing	action	relation names	348-1
relation names	and	conjunctive	one element	348-1
one element		sequential	unary constants	348-1
unary constants	under	constraint	the application	348-1
unary constants	and	conjunctive	the application	348-1
unary constants	closed	action	the application	348-1
the application	of	constraint	the selection	348-1
the selection		sequential	projection	348-1
projection	and	conjunctive	cross-product operators	348-1
cross-product operators	just defined	action	<B>	348-1
Each expression	to	constraint	a given database schema	348-2
Each expression	over	constraint	a given database schema	348-2
Each expression	is considered	action	a given database schema	348-2
Each expression	be defined	action	a given database schema	348-2
a given database schema	and	conjunctive	an associated output arity	348-2
a given database schema	has	action	an associated output arity	348-2
We	now give	action	the formal inductive definition	348-3
<B>	Let	action	R	349-1
R	be	attribute	a database schema	349-1
The base SPC		sequential	algebra	349-2
algebra	and	conjunctive	output	349-2
algebra	queries	action	output	349-2
output		sequential	arities	349-2
arities	are	attribute	Input relation	349-2
Input relation		sequential	Expression R	349-2
Expression R	with	constraint	arity	349-2
arity	to	constraint	arity	349-2
arity		sequential	R	349-2
Unary singleton constant		sequential	Expression	350-1
Expression		sequential	a }	350-1
a }		sequential	where a ∈ dom	350-1
where a ∈ dom	with	constraint	arity	350-1
arity	to	constraint	1	350-1
The family	of	constraint	SPC	351-1
SPC		sequential	algebra	351-1
algebra		sequential	queries	351-1
queries	contains	action	all base SPC queries	351-1
all base SPC queries	for	constraint	SPC queries q1	351-1
all base SPC queries	and	conjunctive	SPC queries q1	351-1
SPC queries q1		sequential	q2 α1	351-1
q2 α1	with	constraint	arities	351-1
arities		sequential	α2	351-1
α2		sequential	Selection	351-1
Selection		sequential	σ	351-1
σ		sequential	j=a	351-1
j=a		sequential	q1	351-1
q1	and	conjunctive	σ j=k	351-1
σ j=k		sequential	q1	351-1
q1		sequential	j	351-1
j		sequential	≤	351-1
≤		sequential	whenever k α1	351-1
whenever k α1	and	conjunctive	a ∈ dom	351-1
a ∈ dom	have	action	arity	351-1
arity		sequential	α1	351-1
Projection		sequential	πj	352-1
Cross product q1	×	sequential	q2	353-1
q2	has	action	arity	353-1
arity		sequential	α1	353-1
α1	+	sequential	α2	353-1
<B>	In	constraint	practice	354-1
practice		sequential	we	354-1
we	sometimes use	action	brackets	354-1
brackets	to	constraint	algebraic queries	354-1
brackets	surround	action	algebraic queries	354-1
algebraic queries		sequential	R	354-1
The semantics	of	constraint	these queries	355-1
these queries	in	constraint	the natural manner	355-1
these queries	is defined	action	the natural manner	355-1
the natural manner	see	action	Exercise 4.8	355-1
The SPC algebra	includes	action	unsatisfiable queries	356-1
unsatisfiable queries		sequential	σ 1=a	356-1
σ 1=a		sequential	σ 1=b	356-1
σ 1=b		sequential	R	356-1
R		sequential	where arity	356-1
where arity		sequential	R	356-1
R	and	conjunctive	a	356-1
R	≥ 1	sequential	a	356-1
a	=	sequential	b	356-1
<B>	to	constraint	q∅	356-2
<B>	is	attribute	equivalent	356-2
<B>	Before	constraint	SPC algebra	357-1
<B>	leaving	action	SPC algebra	357-1
SPC algebra		sequential	we	357-1
we	mention	action	three operators	357-1
three operators		sequential	that	357-1
that	by	constraint	the primitive ones	357-1
that	can be simulated	action	the primitive ones	357-1
<B>	is	attribute	intersection	357-2
intersection		sequential	∩	357-2
∩		sequential	which	357-2
which	is easily simulated	action	Exercise 4.28	357-2
which	see	action	Exercise 4.28	357-2
The other two operators	involve	action	generalizations	358-1
generalizations	of	constraint	the selection	358-1
the selection	and	conjunctive	cross-product operators	358-1
The resulting algebra	is called	action	the generalized SPC algebra	358-2
We	shall introduce	action	a normal form	358-3
a normal form	for	constraint	generalized SPC algebra expressions	358-3
The first operator	is	attribute	a generalization	359-1
a generalization	of	constraint	selection	359-1
selection	to	constraint	the specification	359-1
selection	permit	action	the specification	359-1
the specification	of	constraint	multiple conditions	359-1
A positive conjunctive selection formula	is	attribute	a conjunction F	359-2
a conjunction F		sequential	γ	359-2
γ		sequential	1	359-2
1		sequential	∧	359-2
∧	·	sequential	∧	359-2
∧		sequential	γn	359-2
γn	n	conjunctive	1	359-2
γn	≥	sequential	1	359-2
1		sequential	each conjunct γi	359-2
each conjunct γi	where has	action	the form	359-2
the form		sequential	j	359-2
j	=	sequential	a	359-2
a	or	conjunctive	j	359-2
j	=	sequential	k	359-2
k	for	constraint	positive integers	359-2
positive integers		sequential	j	359-2
j		sequential	k	359-2
k	and	conjunctive	a ∈ dom	359-2
a ∈ dom	and	conjunctive	a positive conjunctive selection operator	359-2
a positive conjunctive selection operator	is	attribute	an expression	359-2
an expression	of	constraint	the form σ F	359-2
the form σ F		sequential	F	359-2
F	is	attribute	where a positive conjunctive selection formula	359-2
The intended typing	and	conjunctive	semantics	359-3
semantics	for	constraint	these operators	359-3
these operators	as	constraint	the fact	359-3
these operators	is	attribute	clear	359-3
these operators	is	attribute	the fact	359-3
the fact	that	constraint	they	359-3
they	by	constraint	a composition	359-3
they	can be simulated	action	a composition	359-3
a composition	of	constraint	selections	359-3
selections	as	constraint	<B>	359-3
selections	defined earlier	action	<B>	359-3
The second operator	called	action	equi-join	360-1
equi-join	is	attribute	a binary operator	360-1
a binary operator		sequential	that	360-1
that	combines	action	cross-product	360-1
cross-product	and	conjunctive	selection	360-1
<B>	well formed	action	A equi-join operator	360-2
A equi-join operator	is	attribute	an expression ⊲⊳F	360-2
an expression ⊲⊳F	of	constraint	the form	360-2
the form		sequential	F	360-2
F	where =	sequential	1	360-2
F	γ	sequential	1	360-2
1		sequential	∧	360-2
∧	·	sequential	∧	360-2
∧		sequential	γn	360-2
γn	n	conjunctive	1	360-2
γn	≥	sequential	1	360-2
1	is	attribute	a conjunction	360-2
a conjunction		sequential	each conjunct γi	360-2
each conjunct γi	has	action	the form	360-2
the form		sequential	j	360-2
j	=	sequential	k	360-2
<B>	Given	action	an equi-join expression	361-1
an equi-join expression		sequential	I	361-1
I	⊲⊳F	action	J	361-1
J	let	action	F	361-1
F	be	attribute	′ the result	361-1
′ the result	of	constraint	each condition k	361-1
′ the result	replacing	action	each condition k	361-1
each condition k		sequential	j	361-1
j	in	constraint	F	361-1
F	by	constraint	j	361-1
j	=	sequential	arity	361-1
arity		sequential	I	361-1
I	+	sequential	k	361-1
<B>	As with	constraint	cross-product	361-2
cross-product		sequential	equi-join	361-2
equi-join	for	constraint	pairs	361-2
equi-join	is also defined	action	pairs	361-2
pairs	of	constraint	tuples	361-2
tuples	with	constraint	an undefined output	361-2
an undefined output	if	constraint	the tuples	361-2
the tuples	do not satisfy	action	the conditions	361-2
the conditions	specified	action	<B>	361-2
We	now develop	action	a normal form	362-1
a normal form	for	constraint	SPC algebra	362-1
We	that	constraint	this normal form	362-2
We	stress	action	this normal form	362-2
this normal form	for	constraint	theoretical purposes	362-2
this normal form	is	attribute	useful	362-2
theoretical purposes	in	constraint	a costly way	362-2
theoretical purposes	and	conjunctive	a costly way	362-2
theoretical purposes	represents	action	a costly way	362-2
a costly way	to	constraint	the answer	362-2
a costly way	compute	action	the answer	362-2
the answer	of	constraint	a given query	362-2
a given query	see	action	Chapter 6	362-2
<B>		sequential	n	363-1
n		sequential	≥ 0	363-1
≥ 0		sequential	m	363-1
m	≥	sequential	0	363-1
0		sequential	a 1	363-1
<B>	.	sequential	<B>	363-2
<B>	.	sequential	<B>	363-3
<B>	am	attribute	∈ dom	363-4
∈ dom	{	sequential	1	363-4
<B>	.	sequential	<B>	363-5
<B>	.	sequential	<B>	363-6
m	}	sequential	⊆	363-7
⊆	{	sequential	j1	363-7
<B>	.	sequential	<B>	363-8
<B>	.	sequential	<B>	363-9
jn }		sequential	R1	363-10
<B>	.	sequential	<B>	363-11
<B>	.	sequential	<B>	363-12
Rk	are	attribute	relation names	363-13
relation names		sequential	repeats	363-13
repeats	and	conjunctive	F	363-13
repeats	permitted	action	F	363-13
F	is	attribute	a positive conjunctive selection formula	363-13
Proposition		sequential	4.4.2	364-1
The proof	of	constraint	this proposition	365-1
this proposition	see	action	Exercise 4.12	365-1
Exercise 4.12	on	constraint	repeated application	365-1
Exercise 4.12	is based	action	repeated application	365-1
repeated application	of	constraint	the following SPC algebra rewrite rules	365-1
repeated application	eight equivalence preserving	action	the following SPC algebra rewrite rules	365-1
the following SPC algebra rewrite rules	or	conjunctive	transformations	365-1
Merge		sequential	select	366-1
select	replace	action	σF	366-1
σF		sequential	σ F ′	366-1
σ F ′		sequential	q	366-1
q	by	constraint	σ F ∧F ′	366-1
σ F ∧F ′		sequential	q	366-1
Merge		sequential	project	367-1
project	π $	sequential	π	367-1
project	replace	action	π	367-1
π		sequential	q	367-1
q	by	constraint	π	367-1
π		sequential	q	367-1
q		sequential	l	367-1
l	for	constraint	each term l j	367-1
each term l j		sequential	i	367-1
i	where =	sequential	kji	367-1
kji		sequential	i	367-1
i	in	constraint	<B>	367-1
i	$ l	sequential	<B>	367-1
<B>	through	constraint	project	368-1
<B>	Push	action	project	368-1
<B>	select	action	project	368-1
project	replace	action	σF	368-1
σF	π $	sequential	q	368-1
q	by	constraint	π	368-1
π		sequential	σ j F ′	368-1
σ j F ′		sequential	q	368-1
q		sequential	F ′	368-1
F ′	from	constraint	F	368-1
F ′	where is obtained	action	F	368-1
F	by	constraint	all coordinate values	368-1
F	replacing	action	all coordinate values	368-1
all coordinate values		sequential	i	368-1
i	by	constraint	ji	368-1
Conjunctive Queries Push select	through	constraint	singleton	369-1
singleton	replace	action	σ 1=j	369-1
σ 1=j		sequential	a × q	369-1
a × q	by	constraint	a ×	369-1
a ×		sequential	σ	369-1
σ		sequential	j	369-1
j		sequential	−1	369-1
−1	=a	sequential	q	369-1
Commute		sequential	cross	370-1
cross	replace	action	q	370-1
q		sequential	× q′	370-1
× q′	by	constraint	q′	370-1
× q′	π $ j	sequential	q′	370-1
× q′	$ j′	sequential	q′	370-1
q′	×	sequential	q	370-1
q	$ j	sequential	arity	370-1
q	where =	sequential	arity	370-1
arity		sequential	q′	370-1
q′	+	sequential	1	370-1
<B>	.	sequential	<B>	370-2
<B>	.	sequential	<B>	370-3
arity		sequential	q′	370-4
q′	+	sequential	j	370-4
j		sequential	′	370-4
′	=	sequential	1	370-4
<B>	.	sequential	<B>	370-5
<B>	.	sequential	<B>	370-6
arity		sequential	q′	370-7
<B>	Push	action	cross	371-1
cross	through	constraint	σ F × q′	371-1
cross	select	action	σ F × q′	371-1
cross	replace	action	σ F × q′	371-1
σ F × q′		sequential	q	371-1
q	by	constraint	σF	371-1
σF		sequential	q	371-1
q		sequential	×	371-1
×		sequential	q′	371-1
q′	and	conjunctive	q F	371-1
q′	replace	action	q F	371-1
q F		sequential	σ	371-1
σ		sequential	q′	371-1
q′	by	constraint	σ	371-1
σ		sequential	F′	371-1
F′		sequential	q	371-1
q		sequential	×	371-1
×		sequential	q′	371-1
q′		sequential	F ′	371-1
F ′	from	constraint	F	371-1
F ′	where is obtained	action	F	371-1
F	by	constraint	all coordinate values	371-1
F	replacing	action	all coordinate values	371-1
all coordinate values		sequential	i	371-1
i	by	constraint	i	371-1
i	+	sequential	arity	371-1
arity		sequential	q	371-1
<B>	Push	action	cross	372-1
cross	through	constraint	project	372-1
project	π $	sequential	q	372-1
project	replace	action	q	372-1
q		sequential	× q′	372-1
× q′	by	constraint	π	372-1
π		sequential	q	372-1
q		sequential	×	372-1
×		sequential	q′	372-1
q′	and	conjunctive	q	372-1
q′	replace	action	q	372-1
q		sequential	×	372-1
×		sequential	π	372-1
π		sequential	q′	372-1
q′		sequential	j	372-1
j	by	constraint	q	372-1
j	π $ j′	sequential	q	372-1
q	×	sequential	q′	372-1
q′	from	constraint	all coordinate values	372-1
q′	by	constraint	all coordinate values	372-1
q′	$ j′	sequential	all coordinate values	372-1
q′	$ j	sequential	all coordinate values	372-1
q′	where is obtained	action	all coordinate values	372-1
q′	replacing	action	all coordinate values	372-1
all coordinate values		sequential	i	372-1
i	by	constraint	i	372-1
i	+	sequential	arity	372-1
arity		sequential	q	372-1
<B>	For	constraint	a set S	373-1
a set S	of	constraint	rewrite	373-1
rewrite		sequential	rules	373-1
rules	and	conjunctive	algebra expressions	373-1
algebra expressions		sequential	q	373-1
q	write	action	q q′	373-1
q q′		sequential	S	373-1
S	or	conjunctive	simply q	373-1
simply q	if	constraint	S	373-1
S	from	constraint	the context	373-1
S	is understood	action	the context	373-1
the context	if	constraint	the result	373-1
the context	is	attribute	the result	373-1
the result	of	constraint	a subexpression	373-1
the result	replacing	action	a subexpression	373-1
a subexpression	of	constraint	q	373-1
q	according to	action	one	373-1
one	of	constraint	the rules	373-1
the rules	in	constraint	S. Let ∗	373-1
S. Let ∗	of	constraint	→S	373-1
It	that	constraint	the foregoing set	374-1
It	is easily verified	action	the foregoing set	374-1
the foregoing set	of	constraint	rewrite rules	374-1
rewrite rules	that	constraint	each SPC query q	374-1
rewrite rules	for	constraint	each SPC query q	374-1
rewrite rules	and	conjunctive	each SPC query q	374-1
rewrite rules	is	attribute	sound	374-1
each SPC query q		sequential	there	374-1
there	is	attribute	a normal form SPC query	374-1
a normal form SPC query	that	constraint	q′	374-1
q′	in	constraint	normal form	374-1
q′	is	attribute	normal form	374-1
normal form	and	conjunctive	q	374-1
<B>	In	constraint	Section 6.1	375-1
Section 6.1		sequential	we	375-1
we	describe	action	an approach	375-1
an approach	to	constraint	the evaluation	375-1
an approach	optimizing	action	the evaluation	375-1
the evaluation	of	constraint	conjunctive queries	375-1
conjunctive queries	using	action	rewrite rules	375-1
<B>	For	constraint	example	375-2
example	in	constraint	that context	375-2
that context		sequential	merge	375-2
merge	and	conjunctive	merge project	375-2
merge	select	action	merge project	375-2
merge project		sequential	the transformations	375-2
the transformations	as	constraint	the inverses	375-2
the transformations	are	attribute	helpful	375-2
the transformations	are	attribute	the inverses	375-2
the inverses	of	constraint	push	375-2
push		sequential	cross	375-2
cross	through	constraint	select	375-2
select	and	conjunctive	cross	375-2
select	push	action	cross	375-2
cross	through	constraint	the project	375-2
<B>	that	constraint	an SPC query	376-1
<B>	Finally note	action	an SPC query	376-1
an SPC query	as	constraint	the result	376-1
an SPC query	may require	action	the result	376-1
the result	of	constraint	transitivity	376-1
transitivity		sequential	the equality	376-1
the equality	of	constraint	two distinct constants	376-1
there	Thus are	action	unsatisfiable SPC queries	376-2
unsatisfiable SPC queries	to	constraint	q∅	376-2
<B>	to	constraint	the conjunctive queries	376-3
<B>	is	attribute	analogous	376-3
<B>	logic based	action	the conjunctive queries	376-3
the conjunctive queries	with	constraint	equality	376-3
It	is	attribute	clear	376-4
It	using	action	the normal form	376-4
the normal form	that	constraint	one	376-4
one	whether	constraint	an SPC query	376-4
one	can check	action	an SPC query	376-4
an SPC query	by	constraint	the selection formula F	376-4
an SPC query	is	attribute	q∅	376-4
an SPC query	examining	action	the selection formula F	376-4
The set	of	constraint	SPC queries	376-5
SPC queries		sequential	that	376-5
that	to	constraint	q∅	376-5
that	are	attribute	not equivalent	376-5
q∅	forms	action	the satisfiable SPC algebra	376-5
The Named Perspective		sequential	The SPJR Algebra	377-1
The SPJR Algebra	In	constraint	Example 4.4.1	377-1
Example 4.4.1		sequential	the relation I3	377-1
the relation I3	was constructed	action	selection	377-1
the relation I3	using	action	selection	377-1
selection	and	conjunctive	cross-product	377-1
cross-product	by	constraint	the expression σ 1=5	377-1
the expression σ 1=5		sequential	I1	377-1
I1	×	constraint	Pariscope	377-1
<B>	As	constraint	often the case	377-2
<B>	is	attribute	often the case	377-2
often the case		sequential	the columns	377-2
the columns	in	constraint	this selection	377-2
the columns	used	action	this selection	377-2
this selection	by	constraint	the same attribute	377-2
this selection	are labeled	action	the same attribute	377-2
<B>	In	constraint	the context	377-3
the context	of	constraint	the named perspective	377-3
the named perspective	on	constraint	tuples	377-3
tuples	suggests	action	a natural variant	377-3
a natural variant	of	constraint	the cross- product operator	377-3
the cross- product operator	of	constraint	the equi-join operator	377-3
the cross- product operator	and	conjunctive	the equi-join operator	377-3
the equi-join operator		sequential	that	377-3
that	is called	action	natural join	377-3
natural join	by	constraint	<B>	377-3
natural join	and	conjunctive	<B>	377-3
natural join	is denoted	action	<B>	377-3
the natural join	Informally requires	action	the tuples	377-4
the tuples		sequential	that	377-4
that	to	constraint	the common attributes	377-4
that	on	constraint	the common attributes	377-4
that	are concatenated	action	the common attributes	377-4
that	agree	action	the common attributes	377-4
Example		sequential	4.4.3	378-1
<B>	List	action	pairs	379-1
pairs	of	constraint	actors	379-1
actors		sequential	that	379-1
that	in	constraint	the same movie	379-1
that	acted	action	the same movie	379-1
<B>	To	constraint	one	380-1
<B>	answer	attribute	this	380-1
one	to	constraint	the Movies relation	380-1
one	would like	action	the Movies relation	380-1
one	join	action	the Movies relation	380-1
the Movies relation	with	constraint	itself	380-1
itself	on	constraint	only the Title column	380-1
itself	but	conjunctive	only the Title column	380-1
itself	matching	action	only the Title column	380-1
<B>	by	constraint	a copy	380-2
<B>	will be achieved	action	a copy	380-2
<B>	first creating	action	a copy	380-2
a copy		sequential	Movies′	380-2
Movies′	of	constraint	Movies	380-2
Movies	in	constraint	which	380-2
which		sequential	the attribute Director	380-2
the attribute Director	to	constraint	Director′	380-2
the attribute Director	has been renamed	action	Director′	380-2
Director′	and	conjunctive	Actor	380-2
Actor	to	constraint	Actor′	380-2
Actor′	with	constraint	Movies	380-2
Actor′	joining	attribute	this	380-2
Movies	onto	constraint	Actor	380-2
Movies	and	conjunctive	Actor	380-2
Movies	finally projecting	action	Actor	380-2
Actor	and	conjunctive	Actor′	380-2
Actor′		sequential	the columns	380-2
Renaming	for	constraint	query	380-3
Renaming	is also needed	action	query	380-3
query		sequential	4.6	380-3
4.6	see	action	Exercise 4.11	380-3
The named conjunctive algebra	has	action	four primitive operators	381-1
four primitive operators		sequential	selection	381-1
selection	as	constraint	projection	381-1
projection	with	constraint	now repeats	381-1
now repeats	and	conjunctive	<B>	381-1
now repeats	not permitted	attribute	natural	381-1
now repeats	join	action	<B>	381-1
now repeats	renaming	action	<B>	381-1
It	to	constraint	the SPJR algebra	381-2
It	as	constraint	the SPJR algebra	381-2
It	is thus referred	action	the SPJR algebra	381-2
<B>	As with	constraint	the SPC algebra	381-3
the SPC algebra		sequential	we	381-3
we	define	action	the individual operators	381-3
the individual operators	and	conjunctive	they	381-3
the individual operators	indicate	action	they	381-3
they	to	constraint	a typed polymorphic algebra	381-3
they	how are combined	action	a typed polymorphic algebra	381-3
they	form	action	a typed polymorphic algebra	381-3
<B>	In	constraint	each case	381-4
each case		sequential	we	381-4
we	indicate	action	the sorts	381-4
the sorts	of	constraint	input	381-4
input	and	conjunctive	output	381-4
<B>	If	constraint	a relation name	381-5
a relation name	for	constraint	the output	381-5
a relation name	is needed	action	the output	381-5
the output		sequential	it	381-5
it	to	constraint	the correct sort	381-5
it	to	constraint	the correct sort	381-5
it	is assumed	action	the correct sort	381-5
it	be chosen	action	the correct sort	381-5
it	have	action	the correct sort	381-5
Selection		sequential	Selection	382-1
These operators	to	constraint	any instance	382-2
These operators	apply	action	any instance	382-2
any instance		sequential	I	382-2
I	with	constraint	A ∈ sort	382-2
A ∈ sort		sequential	I	382-2
I		sequential	A	382-2
A		sequential	B	382-2
B		sequential	∈ sort	382-2
∈ sort		sequential	I	382-2
I	in	constraint	analogy	382-2
I	and	conjunctive	analogy	382-2
I	are defined	action	analogy	382-2
analogy	to	constraint	the unnamed selection	382-2
the unnamed selection	yielding	action	an output	382-2
an output	with	constraint	the same sort	382-2
the same sort	as	constraint	the input	382-2
Projection		sequential	Projection	383-1
Conjunctive Queries W respectively	and	conjunctive	an output	384-1
Conjunctive Queries W respectively	produces	action	an output	384-1
an output	with	constraint	sort	384-1
sort	to	constraint	V ∪ W	384-1
<B>	In	constraint	I	384-2
I		sequential	J	384-2
J	⊲⊳ =	sequential	t	384-2
J	{	sequential	t	384-2
t	over	constraint	V	384-2
V		sequential	∪	384-2
∪		sequential	W	384-2
W	for	constraint	some v ∈	384-2
some v ∈		sequential	I	384-2
I	w	constraint	∈	384-2
I	and	conjunctive	∈	384-2
∈		sequential	J	384-2
J		sequential	t	384-2
t		sequential	V	384-2
V	=	sequential	v	384-2
v	and	conjunctive	t	384-2
t		sequential	W	384-2
W	w	constraint	}	384-2
W	=	sequential	}	384-2
sort		sequential	I	385-1
I	When =	sequential	sort	385-1
sort		sequential	J	385-1
J		sequential	I	385-1
I		sequential	J	385-1
J	⊲⊳ =	sequential	I	385-1
I	∩	action	J	385-1
J	and	conjunctive	sort I	385-1
sort I		sequential	∩ sort	385-1
∩ sort		sequential	J	385-1
J	when =	sequential	I	385-1
I	⊲⊳	action	J	385-1
J	is	attribute	the cross-product	385-1
the cross-product	of	constraint	I	385-1
I	and	conjunctive	J	385-1
The join operator	and	conjunctive	0 ary	385-2
The join operator	is	attribute	associative	385-2
The join operator	has	action	0 ary	385-2
0 ary		sequential	the nonempty relation	385-2
the nonempty relation		sequential	}	385-2
}	as	constraint	identity	385-2
}	and	conjunctive	identity	385-2
<B>	Because	constraint	it	385-3
it	is	attribute	associative	385-3
we	as	constraint	a polyadic operator	385-3
we	sometimes view	action	a polyadic operator	385-3
we	join	action	a polyadic operator	385-3
a polyadic operator	for	constraint	example	385-3
a polyadic operator	and	conjunctive	example	385-3
a polyadic operator	write	action	example	385-3
example		sequential	I1	385-3
I1	In	constraint	<B>	385-3
<B>	Renaming	action	<B>	386-1
An attribute	renaming	action	f	386-2
f	for	constraint	U	386-2
U	by	constraint	the set	386-2
U	can be described	action	the set	386-2
U	specifying	action	the set	386-2
the set	of	constraint	pairs	386-2
pairs		sequential	A	386-2
A		sequential	f	386-2
f		sequential	f	386-2
f	where A =	sequential	A	386-2
A	as	constraint	A1A2	386-2
A	is usually written	action	A1A2	386-2
<B>	.	sequential	<B>	386-3
<B>	.	sequential	<B>	386-4
<B>	→	sequential	An B1B2	386-5
<B>	.	sequential	<B>	386-6
<B>	.	sequential	<B>	386-7
<B>	to	constraint	f	386-8
<B>	that	constraint	f	386-8
<B>	indicate	action	f	386-8
f		sequential	Ai	386-8
Ai	=	sequential	<B>	386-8
A renaming operator	for	constraint	inputs	386-9
inputs	over	constraint	U	386-9
U	is	attribute	an expression	386-9
an expression		sequential	δf	386-9
δf		sequential	f	386-9
f	is	attribute	where an attribute	386-9
where an attribute	for	constraint	U	386-9
where an attribute	renaming	action	U	386-9
U		sequential	this maps	386-9
this maps	to	constraint	outputs	386-9
outputs	over	constraint	f	386-9
f		sequential	U	386-9
<B>	In	constraint	I	386-10
<B>	for	constraint	I	386-10
I	over	constraint	U	386-10
Example		sequential	4.4.4	387-1
4.4		sequential	4.4	387-2
I	⊲⊳	action	J	388-1
J		sequential	σ A=1	388-1
σ A=1		sequential	I	388-1
I		sequential	δ	388-1
δ		sequential	BC→B′A	388-1
BC→B′A		sequential	J	388-1
J	and	conjunctive	π A	388-1
π A		sequential	I	388-1
I	Then are also shown	action	<B>	388-1
<B>	Let	action	K	388-2
K	be	attribute	one tuple	388-2
one tuple		sequential	the relation A	388-2
the relation A		sequential	1	388-2
1		sequential	C 9	388-2
πA		sequential	B	388-3
B		sequential	I	388-3
I	⊲⊳	sequential	K	388-3
K	with	constraint	σ A=1	388-3
K	Then coincides	action	σ A=1	388-3
σ A=1		sequential	I	388-3
I	and	conjunctive	J ⊲⊳ K	388-3
The base SPJR algebra queries	are	attribute	Input relation	389-1
Input relation		sequential	Expression R	389-1
Expression R	with	constraint	sort	389-1
sort	to	constraint	sort	389-1
sort		sequential	R	389-1
Unary singleton constant		sequential	Expression	390-1
Expression		sequential	A	390-1
A		sequential	a }	390-1
a }		sequential	where a ∈ dom	390-1
where a ∈ dom	with	constraint	sort A	390-1
The remainder	of	constraint	the syntax	391-1
the syntax	and	conjunctive	semantics	391-1
semantics	of	constraint	the SPJR algebra	391-1
the SPJR algebra	in	constraint	analogy	391-1
the SPJR algebra	is now defined	action	analogy	391-1
analogy	to	constraint	the SPC algebra	391-1
analogy	of	constraint	the SPC algebra	391-1
the SPC algebra	see	action	Exercise 4.8	391-1
Example		sequential	4.4.5	392-1
4.4.5	Consider again	action	Fig	392-1
4.4		sequential	4.4	392-2
<B>	Let	action	I	392-3
I	be	attribute	the instance	392-3
the instance	over	constraint	R S	392-3
R S	that	constraint	I	392-3
R S	}	sequential	I	392-3
I		sequential	R	392-3
R	=	sequential	I	392-3
I	and	conjunctive	I	392-3
I		sequential	S	392-3
S	=	sequential	J	392-3
R	is	attribute	Then a query	392-4
Then a query	and	conjunctive	the answer	392-4
the answer	to	constraint	that query	392-4
that query	denoted	action	R	392-4
R		sequential	I	392-4
I	is	attribute	just I	392-4
Figure		sequential	4.4	392-5
4.4	also gives	action	the values	392-5
the values	of	constraint	S	392-5
S		sequential	I	392-5
I		sequential	R ⊲⊳ S	392-5
R ⊲⊳ S		sequential	I	392-5
I		sequential	σ A=1	392-5
σ A=1		sequential	R	392-5
R		sequential	I	392-5
R B S B		sequential	C	393-1
C		sequential	B C B	393-1
B C B		sequential	B′	393-1
B′		sequential	Figure 4.4	393-1
Figure 4.4		sequential	Examples	393-1
Examples	of	constraint	SPJR operators	393-1
<B>		sequential	n	394-1
n		sequential	≥	394-1
≥		sequential	0	394-1
0		sequential	m 0	394-1
m 0		sequential	a 1	394-1
<B>	.	sequential	<B>	394-2
<B>	.	sequential	<B>	394-3
<B>	am	attribute	∈ dom	394-4
∈ dom	of	constraint	A1	394-4
<B>	.	sequential	<B>	394-5
<B>	.	sequential	<B>	394-6
Am	in	constraint	B1	394-7
Am	occurs	action	B1	394-7
<B>	.	sequential	<B>	394-8
<B>	.	sequential	<B>	394-9
Bn		sequential	the Ai	394-10
the Ai	are	attribute	distinct	394-10
<B>	.	sequential	<B>	394-11
<B>	.	sequential	<B>	394-12
Rk	are	attribute	relation names	394-13
relation names		sequential	repeats	394-13
repeats	permitted	action	δf	394-13
δf	is	attribute	a renaming j operator	394-13
a renaming j operator	for	constraint	sort	394-13
sort		sequential	Rj	394-13
Rj	for	constraint	each j ∈	394-13
each j ∈		sequential	1	394-13
1		sequential	k	394-13
k	and	conjunctive	no Ai	394-13
no Ai	in	constraint	any δf	394-13
no Ai	occur	action	any δf	394-13
any δf		sequential	R	394-13
R		sequential	j j	394-13
j j		sequential	the sorts	394-13
the sorts	of	constraint	δf	394-13
δf		sequential	R k	394-13
R k	and	conjunctive	F	394-13
R k	are	attribute	pairwise disjoint	394-13
F	is	attribute	a positive conjunctive selection formula	394-13
<B>	is easily verified	action	Exercise 4.12	394-14
<B>	see	action	Exercise 4.12	394-14
Proposition		sequential	4.4.6	395-1
The set	of	constraint	SPJR queries	396-1
SPJR queries	to	constraint	q∅	396-1
q∅	forms	action	the satisfiable SPJR algebra	396-1
Equivalence Theorem		sequential	Equivalence Theorem	397-1
<B>	As	constraint	logic	397-2
<B>	shown earlier	action	logic	397-2
logic	based	action	the three versions	397-2
the three versions	of	constraint	the conjunctive queries	397-2
the conjunctive queries	are	attribute	equivalent	397-2
We	that	constraint	the SPC	397-3
We	now show	action	the SPC	397-3
Conjunctive Queries		sequential	Lemma	398-1
Lemma		sequential	4.4.7	398-1
Crux		sequential	Crux	399-1
<B>	Let	action	q	399-2
q	be	attribute	the following normal form SPC query	399-2
We	now describe	action	an SPJR query q′	400-1
an SPJR query q′		sequential	that	400-1
that	to	constraint	q	400-1
that	is	attribute	equivalent	400-1
q		sequential	q′	400-1
q′	has	action	the following form	400-1
the following form		sequential	π A j	400-1
π A j		sequential	A k	400-1
jn k		sequential	jn k	401-1
<B>	.	sequential	<B>	401-2
<B>	.	sequential	<B>	401-3
As′		sequential	<B>	401-4
<B>	.	sequential	<B>	401-5
<B>	.	sequential	<B>	401-6
<B>	are	attribute	the coordinate positions	401-7
the coordinate positions	of	constraint	Rt	401-7
Rt	in	constraint	the expression R1	401-7
<B>	In	constraint	detail	401-8
detail	for	constraint	each r	401-8
each r		sequential	∈	401-8
∈		sequential	1	401-8
1		sequential	k	401-8
k	let	action	β	401-8
β		sequential	t	401-8
t	=	sequential	# t	401-8
t	+	sequential	# t	401-8
# t		sequential	m arity	401-8
m arity		sequential	R s=0 s	401-8
R s=0 s		sequential	the ith attribute	401-8
the ith attribute	of	constraint	Rt	401-8
Rt	to	constraint	the attribute	401-8
the attribute		sequential	Aβ	401-8
Aβ		sequential	t−1 +i	401-8
<B>	To	constraint	G	401-9
<B>	define	action	G	401-9
G	first define	action	the function γ	401-9
the function γ	from	constraint	coordinate positions	401-9
coordinate positions	to	constraint	names	401-9
coordinate positions	attribute	action	names	401-9
names	so that	constraint	γ	401-9
γ		sequential	j	401-9
<B>	Finally set	action	G	401-10
G	=	sequential	γ	401-10
γ		sequential	F	401-10
It	to	constraint	q′ q	401-11
It	that	constraint	q′ q	401-11
It	is	attribute	now straightforward	401-11
It	verify	action	q′ q	401-11
It	from	constraint	the preceding lemma	402-1
It	follows immediately	action	the preceding lemma	402-1
the preceding lemma		sequential	that	402-1
that		sequential	the satisfiable SPC algebra	402-1
the satisfiable SPC algebra	and	conjunctive	the satisfiable SPJR algebra	402-1
the satisfiable SPJR algebra	are	attribute	equivalent	402-1
The equivalence	between	constraint	the two algebraic languages	403-1
the two algebraic languages	and	conjunctive	logic	403-1
logic	based	action	the three languages	403-1
the three languages	with	constraint	a minor caveat	403-1
the three languages	holds	action	a minor caveat	403-1
a minor caveat	involving	action	the empty query	403-1
the empty query		sequential	q∅	403-1
<B>	As	constraint	the SPC	403-2
<B>	noted earlier	action	the SPC	403-2
Theorem		sequential	4.3.3	404-1
4.3.3		sequential	the closure	404-1
the closure	of	constraint	the conjunctive queries	404-1
the closure	rule based	action	the conjunctive queries	404-1
the conjunctive queries	under	constraint	composition	404-1
composition	in	constraint	the proof	404-1
composition	is used	action	the proof	404-1
the proof	of	constraint	this result	404-1
The closures	of	constraint	SPC	404-2
SPC	and	conjunctive	SPJR	404-2
SPJR		sequential	the algebras	404-2
the algebras	under	constraint	composition	404-2
composition	are	attribute	of course immediate	404-2
Theorem		sequential	4.4.8	405-1
Proof		sequential	Proof	406-1
We	briefly consider	action	how steps	407-1
how steps		sequential	i	407-1
i	and	conjunctive	the details	407-1
i	ii might be demonstrated	action	the details	407-1
the details	to	constraint	the reader	407-1
the details	are left	action	the reader	407-1
the reader		sequential	Exercise	407-1
Exercise		sequential	4.15	407-1
<B>	For	constraint	it	407-2
it	to	constraint	the SPC algebra operations	407-2
it	that	constraint	the SPC algebra operations	407-2
it	of	constraint	the SPC algebra operations	407-2
it	is	attribute	i sufficient	407-2
it	show	attribute	each	407-2
the SPC algebra operations	by	constraint	a rule	407-2
the SPC algebra operations	can be simulated	action	a rule	407-2
the inclusion	from	constraint	the fact	407-3
the inclusion	Indeed follows	action	the fact	407-3
the fact	that	constraint	conjunctive queries	407-3
the fact	rule based	action	conjunctive queries	407-3
conjunctive queries	under	constraint	composition	407-3
conjunctive queries	are closed	action	composition	407-3
composition	by	constraint	Theorem	407-3
Theorem		sequential	4.3.3	407-3
4.3.3	that	constraint	satisfiable rules	407-3
4.3.3	and	conjunctive	satisfiable rules	407-3
satisfiable rules	with	constraint	equality	407-3
equality	as	constraint	rules	407-3
equality	can be expressed	action	rules	407-3
rules	without	constraint	equality	407-3
The simulation	of	constraint	algebra operations	407-4
algebra operations	by	constraint	rules	407-4
rules	as	constraint	y	407-4
rules	x	sequential	y	407-4
rules	$	sequential	y	407-4
rules	is	attribute	y	407-4
rules	follows	action	y	407-4
y		sequential	P	407-4
P	$	sequential	x	407-4
x		sequential	Q	407-4
Q	$	sequential	y	407-4
y	and	conjunctive	no repeating variables	407-4
y	$ x	sequential	no repeating variables	407-4
y	$ y	sequential	no repeating variables	407-4
y	where contain	action	no repeating variables	407-4
no repeating variables	in	constraint	the case	407-4
the case		sequential	P x	407-4
P x	$ y	sequential	when the corresponding constant tuples	407-4
P x	are	attribute	when the corresponding constant tuples	407-4
<B>	y denotes	action	the vector	408-1
the vector	of	constraint	variables	408-1
variables	and	conjunctive	constants	408-1
constants	by	constraint	merging variables	408-1
constants	obtained	action	merging variables	408-1
merging variables	of	constraint	other variables	408-1
merging variables	with	constraint	other variables	408-1
merging variables	$ y	sequential	other variables	408-1
other variables	with	constraint	constants	408-1
other variables	or	conjunctive	constants	408-1
constants	according to	attribute	satisfiable	408-1
the selection formula F	of	constraint	the distinct variables	408-1
the selection formula F	and	conjunctive	the distinct variables	408-1
the selection formula F	$ x	sequential	the distinct variables	408-1
the selection formula F	consists	action	the distinct variables	408-1
the distinct variables	in	constraint	σ F	408-1
σ F	$	sequential	y	408-1
j1 jn distinct variables		sequential	j1 jn distinct variables	409-1
<B>	Next consider	action	step ii	410-1
<B>	Let	action	ans	410-2
ans	$ x	sequential	R1	410-2
ans	←	sequential	R1	410-2
R1	$ x1	sequential	<B>	410-2
<B>	.	sequential	<B>	410-3
<B>	.	sequential	<B>	410-4
Rn	$ xn	sequential	a rule	410-5
Rn	be	attribute	a rule	410-5
There	is	attribute	an equiv- x1	410-6
<B>	.	sequential	<B>	410-7
<B>	.	sequential	<B>	410-8
<B>	$ xn	sequential	fur ther	410-9
fur ther		sequential	cross- product	410-9
cross- product	with	constraint	constant relations	410-9
constant relations	to	constraint	the constants	410-9
constant relations	corresponding	action	the constants	410-9
the constants	in	constraint	finally x	410-9
the constants	and	conjunctive	finally x	410-9
the constants	$ x	sequential	finally x	410-9
We	with	constraint	some examples	411-1
We	begin	action	some examples	411-1
Example		sequential	4.5.1	412-1
Conjunctive Queries		sequential	Conjunctive Queries	413-1
rule	based	action	The formalism	414-1
The formalism	can accommodate	action	this query	414-1
this query	by	constraint	more than one rule	414-1
this query	permitting	action	more than one rule	414-1
more than one rule	with	constraint	the same relation name	414-1
the same relation name	in	constraint	the head	414-1
the head	and	conjunctive	the union	414-1
the head	taking	action	the union	414-1
the union	of	constraint	their outputs	414-1
their outputs	as	constraint	the answer	414-1
the answer		sequential	ans	414-1
ans		sequential	xt	414-1
xt		sequential	Pariscope	414-1
Pariscope		sequential	xt	414-1
xt		sequential	Annie Hall	414-1
Annie Hall		sequential	xs	414-1
<B>	Consider now	action	the following query	415-1
This query	of	constraint	the preceding formalisms	416-1
This query	can be expressed	attribute	any	416-1
This query	using	attribute	any	416-1
the preceding formalisms	except	constraint	the SPJR	416-1
the preceding formalisms	for	constraint	the SPJR	416-1
<B>	Let	action	I1	417-1
I1		sequential	I2	417-1
I2	be	attribute	two relations	417-1
two relations	with	constraint	the same arity	417-1
<B>	As	constraint	standard	417-2
standard	in	constraint	mathematics	417-2
mathematics		sequential	I1	417-2
I1	∪	sequential	I2	417-2
I2	is	attribute	the relation	417-2
the relation	having	action	this arity	417-2
this arity	and	conjunctive	the union	417-2
this arity	containing	action	the union	417-2
the union	of	constraint	the two sets	417-2
the two sets	of	constraint	tuples	417-2
The definition	of	constraint	the SPCU algebra	417-3
the SPCU algebra	by	constraint	the definition	417-3
the SPCU algebra	is obtained	action	the definition	417-3
the SPCU algebra	extending	action	the definition	417-3
the definition	of	constraint	the SPC algebra	417-3
the SPC algebra	to	constraint	the union operator	417-3
the SPC algebra	include	action	the union operator	417-3
The SPJRU algebra	in	constraint	the same fashion	417-4
The SPJRU algebra	is obtained	action	the same fashion	417-4
the same fashion	except	constraint	union	417-4
the same fashion	that	constraint	union	417-4
union	to	constraint	expressions	417-4
union	can only be applied	action	expressions	417-4
expressions	having	action	the same sort	417-4
SPCU	and	conjunctive	SPJRU	418-1
SPJRU		sequential	The algebras	418-1
The algebras	by	constraint	the selection operator	418-1
The algebras	can be generalized	action	the selection operator	418-1
The algebras	extending	action	the selection operator	418-1
the selection operator	in	constraint	the case	418-1
the selection operator	and	conjunctive	the case	418-1
the selection operator	join	action	the case	418-1
the case	of	constraint	SPC	418-1
SPC	as	constraint	<B>	418-1
We	can define	action	normal forms	418-2
normal forms	for	constraint	algebras	418-2
normal forms	both	conjunctive	algebras	418-2
algebras		sequential	which	418-2
which	are	attribute	expressions	418-2
expressions	of	constraint	normal form SPC	418-2
expressions	or	conjunctive	normal form SPC	418-2
expressions	consisting	attribute	more	418-2
normal form SPC		sequential	SPJR	418-2
SPJR		sequential	one expressions	418-2
one expressions	combined	action	a polyadic union operator	418-2
one expressions	using	action	a polyadic union operator	418-2
a polyadic union operator	see	action	Exercise 4.23	418-2
<B>	As	constraint	the previous example	418-3
<B>	by	constraint	the previous example	418-3
<B>	suggested	action	the previous example	418-3
the previous example		sequential	disjunction	418-3
disjunction	into	constraint	selection formulas	418-3
disjunction	can also be incorporated	action	selection formulas	418-3
selection formulas	with	constraint	no increase	418-3
no increase	in	constraint	expressive power	418-3
expressive power	see	action	Exercise 4.22	418-3
<B>	to	constraint	conjunctive queries	419-1
<B>	Turning now	action	conjunctive queries	419-1
<B>	rule based	action	conjunctive queries	419-1
conjunctive queries		sequential	the simplest way	419-1
the simplest way	to	constraint	the capability	419-1
the simplest way	incorporate	action	the capability	419-1
the capability	of	constraint	union	419-1
union	to	constraint	sets	419-1
union	is	attribute	sets	419-1
union	consider	action	sets	419-1
sets	of	constraint	rules	419-1
rules	all having	action	the same relation name	419-1
the same relation name	in	constraint	the head	419-1
These queries	by	constraint	the union	419-2
These queries	are evaluated	action	the union	419-2
These queries	taking	action	the union	419-2
the union	of	constraint	the output	419-2
the output	of	constraint	the individual rules	419-2
<B>	without	constraint	the expressive power	420-1
<B>	can be generalized	action	the expressive power	420-1
<B>	increasing	action	the expressive power	420-1
the expressive power	by	constraint	something	420-1
the expressive power	incorporating	action	something	420-1
something	to	constraint	query composition	420-1
A nonrecursive datalog program		sequential	nr-datalog program	420-2
nr-datalog program	over	constraint	schema R	420-2
schema R	is	attribute	a set	420-2
a set	of	constraint	rules S1	420-2
rules S1		sequential	body 1	420-2
body 1		sequential	S2	420-2
S2		sequential	body 2	420-2
<B>		sequential	body m	421-1
body m		sequential	no relation name	421-1
no relation name	in	constraint	R	421-1
R	in	constraint	a rule head	421-1
R	where occurs	action	a rule head	421-1
a rule head		sequential	the same relation name	421-1
the same relation name	in	constraint	more than one rule head	421-1
the same relation name	may appear	action	more than one rule head	421-1
more than one rule head	and	conjunctive	there	421-1
there	is	attribute	ordering	421-1
ordering		sequential	some r1	421-1
<B>	.	sequential	<B>	421-2
<B>	.	sequential	<B>	421-3
rm	of	constraint	the rules	421-4
the rules	so that	constraint	the relation name	421-4
the relation name	in	constraint	the head	421-4
the head	of	constraint	ri	421-4
ri	in	constraint	the body	421-4
ri	does not occur	action	the body	421-4
the body	of	constraint	a rule rj	421-4
a rule rj		sequential	j	421-4
j		sequential	whenever ≤	421-4
whenever ≤		sequential	i	421-4
The term	because	constraint	recursion	422-1
The term	is used	action	recursion	422-1
recursion	is not permitted	action	<B>	422-1
A simple example	of	constraint	a recursive rule	422-2
a recursive rule	is	attribute	<B>	422-2
<B>	In	constraint	a nonrecursive datalog program P	423-1
a nonrecursive datalog program P	over	constraint	R	423-1
R	as	constraint	a database schema	423-1
R	is viewed	action	a database schema	423-1
R	having	action	a database schema	423-1
a database schema	as	constraint	target	423-1
Program P	as	constraint	R	423-2
Program P	from	constraint	R	423-2
Program P	can also be viewed	action	R	423-2
Program P	mapping	action	R	423-2
R	to	constraint	a single relation	423-2
a single relation	see	action	Exercise 4.24	423-2
<B>	to	constraint	tableau queries	424-1
<B>	Turning	action	tableau queries	424-1
tableau queries		sequential	a union	424-1
a union	of	constraint	tableaux query	424-1
tableaux query	over	constraint	schema R	424-1
schema R	or	conjunctive	R	424-1
R	is	attribute	an expression	424-1
an expression	of	constraint	the form	424-1
the form		sequential	T1	424-1
<B>	.	sequential	<B>	424-2
<B>	.	sequential	<B>	424-3
Tn }		sequential	u	424-4
u		sequential	n	424-4
n		sequential	≥ 1	424-4
≥ 1	and	conjunctive	Ti	424-4
Ti		sequential	u	424-4
u	is	attribute	where a tableau query	424-4
where a tableau query	over	constraint	R	424-4
R	for	constraint	i	424-4
i		sequential	∈	424-4
∈		sequential	1	424-4
1		sequential	n	424-4
The semantics	of	constraint	these queries	424-5
these queries	by	constraint	the queries	424-5
these queries	is obtained	action	the queries	424-5
these queries	evaluating independently	action	the queries	424-5
the queries		sequential	Ti	424-5
Ti		sequential	u	424-5
u	and	conjunctive	the union	424-5
u	taking	action	the union	424-5
the union	of	constraint	their results	424-5
Equality	into	constraint	these queries	424-6
Equality	is incorporated	action	these queries	424-6
these queries	by	constraint	the queries	424-6
these queries	of	constraint	the queries	424-6
these queries	permitting	attribute	each	424-6
the queries		sequential	Ti	424-6
Ti		sequential	u	424-6
u	to	constraint	equality	424-6
u	have	action	equality	424-6
We	can now state	action	Exercise 4.25	425-1
We	see	action	Exercise 4.25	425-1
Exercise 4.25		sequential	the following Theorem 4.5.2	425-1
The union	of	constraint	tableau queries	426-1
tableau queries	than	constraint	the aforementioned languages	426-1
tableau queries	is	attribute	weaker	426-1
the aforementioned languages	with	constraint	union	426-1
<B>	because	constraint	the definition	427-1
<B>	is	attribute	the definition	427-1
the definition	of	constraint	union	427-1
union	of	constraint	tableau queries	427-1
tableau queries	essentially does not allow	action	separate summary rows	427-1
separate summary rows	for	constraint	each tableau	427-1
each tableau	in	constraint	the union	427-1
<B>	With	constraint	just one summary row	427-2
just one summary row		sequential	the nonrecursive datalog query	427-2
the nonrecursive datalog query	as	constraint	a union	427-2
the nonrecursive datalog query	can not be expressed	action	a union	427-2
a union	of	constraint	tableaux query	427-2
Conjunctive Queries		sequential	Conjunctive Queries	428-1
Union	and	conjunctive	the Conjunctive Calculus	429-1
Example		sequential	4.5.3	430-1
<B>	Speaking intuitively	action	the answer	431-1
the answer	of	constraint	q	431-1
q	on	constraint	nonempty instance	431-1
nonempty instance		sequential	I	431-1
I	be	attribute	a slight abuse	431-1
I	will using	action	a slight abuse	431-1
a slight abuse	of	constraint	notation	431-1
notation		sequential	q	431-1
q		sequential	I	431-1
I	=	sequential	I	431-1
I	×	action	dom	431-1
dom		sequential	∪	431-1
∪		sequential	dom	431-1
dom	×	constraint	I	431-1
<B>	is	attribute	an infinite set	432-1
an infinite set	of	constraint	tuples	432-1
tuples	and	conjunctive	thus not an instance	432-1
thus not an instance	according to	action	the formal definition	432-1
the query q	of	constraint	the previous example	433-1
the previous example	is	attribute	Informally not safe	433-1
This notion	is	attribute	one	433-1
one	of	constraint	the central topics	433-1
the central topics		sequential	that	433-1
that	to	constraint	first order	433-1
that	needs	action	first order	433-1
that	be resolved	action	first order	433-1
that	when using	action	first order	433-1
first order		sequential	the predicate calculus	433-1
the predicate calculus	as	constraint	a relational query language	433-1
a relational query language	and	conjunctive	it	433-1
it	in	constraint	Chapter 5	433-1
it	is studied	action	Chapter 5	433-1
We	to	constraint	the issue	433-2
We	return	action	the issue	433-2
the issue	of	constraint	union	433-2
the issue	adding	action	union	433-2
union	to	constraint	the conjunctive calculus	433-2
the conjunctive calculus	see	action	also Exercise 4.26	433-2
Bibliographic Notes		sequential	Codd	434-1
Codd		sequential	pioneering article	434-1
pioneering article		sequential	Cod70	434-1
Cod70	on	constraint	the relational model	434-1
the relational model	introduces	action	the first relational query language	434-1
the first relational query language		sequential	a named algebra	434-1
The predicate calculus	to	constraint	the relational model	434-2
The predicate calculus	was adapted	action	the relational model	434-2
the relational model	in	constraint	Cod72 b	434-2
Cod72 b		sequential	it	434-2
it	to	constraint	the algebra	434-2
it	to	constraint	the algebra	434-2
it	where was shown	attribute	essentially equivalent	434-2
it	be	attribute	essentially equivalent	434-2
The conjunctive queries	in	constraint	the calculus paradigm	434-3
the calculus paradigm	in	constraint	CM77	434-3
the calculus paradigm	were first introduced	action	CM77	434-3
Their equivalence	with	constraint	the SPC algebra	434-4
the SPC algebra	is also shown	action	<B>	434-4
Typed tableau queries	as	constraint	a representation	435-1
Typed tableau queries	appeared	attribute	two dimensional	435-1
a representation	of	constraint	a subset	435-1
a subset	of	constraint	the conjunctive queries	435-1
the conjunctive queries	in	constraint	ASU79b	435-1
ASU79b	along	constraint	a proof	435-1
ASU79b	with	constraint	a proof	435-1
a proof	that	constraint	all typed restricted SPJ algebra expressions	435-1
all typed restricted SPJ algebra expressions	over	constraint	one relation	435-1
one relation	can be expressed	action	them	435-1
one relation	using	action	them	435-1
A precursor	to	constraint	the typed tableau queries	435-2
the typed tableau queries	in	constraint	ABU79	435-2
the typed tableau queries	is found	action	ABU79	435-2
ABU79		sequential	which	435-2
which	uses	action	a technique	435-2
a technique	to	constraint	tableaux	435-2
tableaux	to	constraint	the join operator	435-2
tableaux	analyze	action	the join operator	435-2
ASU79a		sequential	ASSU81	435-3
ASSU81		sequential	CV81	435-3
CV81	continued	action	the investigation	435-3
the investigation	of	constraint	typed tableau queries	435-3
<B>	of	constraint	the results	436-1
the results	in	constraint	this chapter	436-1
this chapter	for	constraint	example	436-1
this chapter	including	action	example	436-1
example		sequential	the equivalence	436-1
the equivalence	of	constraint	the SPC	436-1
Exercises Exercises Exercise		sequential	4.1 Express queries	437-1
4.1 Express queries		sequential	4.1 –4.3	437-1
4.1 –4.3	and	conjunctive	4.5 –4.9	437-1
4.5 –4.9	as	constraint	rule	437-1
rule	based	action	a conjunctive queries	437-1
a conjunctive queries		sequential	b conjunctive calculus queries	437-1
b conjunctive calculus queries		sequential	c	437-1
c		sequential	tableau queries	437-1
tableau queries		sequential	d	437-1
d		sequential	SPC expressions	437-1
SPC expressions	and	conjunctive	e SPJR expressions	437-1
Exercise		sequential	4.2	438-1
<B>	Exercise	action	4.3	439-1
Exercise		sequential	4.4	440-1
<B>	Exercise	action	4.5	441-1
Exercise		sequential	4.6	442-1
<B>	Give	action	a syntactic condition	442-2
a syntactic condition		sequential	that	442-2
that	that	constraint	the answer	442-2
that	ensures	action	the answer	442-2
the answer	to	constraint	a query q	442-2
a query q	on	constraint	I	442-2
I	involves	action	only constants	442-2
only constants	from	constraint	adom	442-2
adom		sequential	q	442-2
q		sequential	I	442-2
I	that	constraint	the answer	442-2
I	and	conjunctive	the answer	442-2
the answer	by	constraint	only valuations	442-2
the answer	can be obtained	action	only valuations	442-2
the answer	considering	action	only valuations	442-2
only valuations		sequential	whose range	442-2
whose range	in	constraint	adom	442-2
whose range	is contained	action	adom	442-2
adom		sequential	q	442-2
q		sequential	I	442-2
<B>	Exercise	action	4.7	443-1
4.7	Give	action	a proof	443-1
a proof	of	constraint	Theorem 4.3.3	443-1
Conjunctive Queries Exercise		sequential	4.8	444-1
<B>	Exercise	action	4.9	445-1
4.9	Consider	action	the algebra	445-1
the algebra	of	constraint	all SPJR queries	445-1
the algebra	consisting	action	all SPJR queries	445-1
all SPJR queries	in	constraint	which	445-1
which		sequential	constants	445-1
constants	do not occur	action	<B>	445-1
Exercise		sequential	4.10	446-1
<B>	or	conjunctive	Each SPJR algebra expression	446-2
<B>	Prove	action	Each SPJR algebra expression	446-2
<B>	disprove	action	Each SPJR algebra expression	446-2
Each SPJR algebra expression	to	constraint	an SPJR algebra expression	446-2
Each SPJR algebra expression	is	attribute	equivalent	446-2
an SPJR algebra expression	of	constraint	whose selection operators	446-2
whose selection operators	are constant based	action	<B>	446-2
Exercise		sequential	4.11	447-1
Exercise		sequential	4.12	448-1
Exercise		sequential	4.13	449-1
Exercise		sequential	4.14	450-1
Exercise		sequential	4.15	451-1
Exercise		sequential	4.16	452-1
Exercise		sequential	4.17	453-1
<B>	If	constraint	q	453-2
q	has	action	r rows	453-2
r rows	and	conjunctive	q′	453-2
q′	has	action	j joins	453-2
j joins	of	constraint	database relations	453-2
database relations	that	constraint	j	453-2
database relations	show	action	j	453-2
j	=	sequential	r − 1	453-2
Exercises		sequential	Exercises	454-1
Exercise		sequential	4.20	455-1
<B>	that	constraint	q	456-1
<B>	if	constraint	q	456-1
<B>	Prove	action	q	456-1
q	=	sequential	T	456-1
T		sequential	u	456-1
u	is	attribute	repeat	456-1
repeat	restricted	action	a typed tableau query	456-1
a typed tableau query	over	constraint	R	456-1
R		sequential	there	456-1
there	is q′	action	a typed restricted SPJ query	456-1
a typed restricted SPJ query	that	constraint	the image	456-1
the image	of	constraint	q′	456-1
q′	under	constraint	the algorithm part	456-1
the algorithm part	of	constraint	Exercise 4.19	456-1
Exercise 4.19	is	attribute	a q	456-1
Exercise		sequential	4.21	457-1
4.21	Extend	action	Proposition 4.2.2	457-1
Proposition 4.2.2	to	constraint	disjunction	457-1
Proposition 4.2.2	include	action	disjunction	457-1
disjunction		sequential	i.e. union	457-1
Exercise		sequential	4.22	458-1
<B>	Define	action	SPC 1	459-1
SPC 1		sequential	the algebra	459-1
the algebra	to	constraint	the SPC algebra	459-1
the algebra	be	attribute	the SPC algebra	459-1
the SPC algebra	except	constraint	nonsingleton unary constant relations	459-1
the SPC algebra	that	constraint	nonsingleton unary constant relations	459-1
nonsingleton unary constant relations	as	constraint	base queries	459-1
nonsingleton unary constant relations	can be used	action	base queries	459-1
base queries	and	conjunctive	the SPC-n algebra	459-1
base queries	define	action	the SPC-n algebra	459-1
the SPC-n algebra	to	constraint	the SPC algebra	459-1
the SPC-n algebra	be	attribute	the SPC algebra	459-1
the SPC algebra		sequential	Conjunctive Queries	459-1
Conjunctive Queries	except	constraint	nonsingleton constant relations	459-1
Conjunctive Queries	that	constraint	nonsingleton constant relations	459-1
nonsingleton constant relations	of	constraint	arbitrary arity	459-1
arbitrary arity	as	constraint	base queries	459-1
arbitrary arity	can be used	action	base queries	459-1
<B>	Define analogously	action	SPJR 1	459-2
SPJR 1		sequential	the ∗	459-2
the ∗	and	conjunctive	SPJR n∗	459-2
SPJR n∗		sequential	algebras	459-2
Exercise		sequential	4.23	460-1
Exercise		sequential	4.24	461-1
Exercise 4.25 Prove Theorem 4.5.2		sequential	Exercise 4.25 Prove Theorem 4.5.2	462-1
<B>	Let	action	I	463-1
I	be	attribute	an instance	463-1
an instance	over	constraint	R S }	463-1
<B>	Using	action	the natural extension	463-2
the natural extension	of	constraint	the notion	463-2
the notion	of	constraint	satisfies	463-2
satisfies	to	constraint	disjunction	463-2
disjunction	for	constraint	each subformula	463-2
disjunction	show	action	each subformula	463-2
each subformula	of	constraint	form	463-2
each subformula	with	constraint	form	463-2
form	and	conjunctive	each valuation ν	463-2
each valuation ν	over	constraint	range	463-2
each valuation ν	with	constraint	range	463-2
range	in	constraint	adom	463-2
range	contained	action	adom	463-2
adom		sequential	I	463-2
I		sequential	there	463-2
there	exists	action	c ∈ dom such	463-2
c ∈ dom such		sequential	that	463-2
that		sequential	I	463-2
I		sequential	ψ	463-2
ψ		sequential	ν	463-2
ν	∪	sequential	w/c	463-2
w/c		sequential	}	463-2
}		sequential	iff	463-2
iff		sequential	there	463-2
there	exists	action	c	463-2
c		sequential	∈ adom	463-2
∈ adom		sequential	I	463-2
I	that	constraint	I	463-2
I		sequential	ψ	463-2
ψ		sequential	ν	463-2
ν		sequential	∪	463-2
∪		sequential	w/c	463-2
w/c		sequential	}	463-2
<B>	that	constraint	this query	463-3
<B>	Conclude	action	this query	463-3
this query	by	constraint	only valuations	463-3
this query	can be evaluated	action	only valuations	463-3
this query	considering	action	only valuations	463-3
only valuations		sequential	whose range	463-3
whose range	in	constraint	adom	463-3
whose range	is contained	action	adom	463-3
adom		sequential	I	463-3
Exercise		sequential	4.27	464-1
Exercises Exercise 4.28		sequential	Exercises Exercise 4.28	465-1
Exercise 4.30		sequential	Exercise 4.30	466-1
Conjunctive queries	are	attribute	great	467-1
<B>	But	conjunctive	what	467-2
what	if	constraint	I	467-2
I	to	constraint	a movie	467-2
I	want	action	a movie	467-2
I	see	action	a movie	467-2
a movie		sequential	that	467-2
that	doesn feature	action	Woody Allen	467-2
Vittorio		sequential	Vittorio	468-1
Sergio		sequential	Sergio	469-1
Riccardo		sequential	Riccardo	470-1
What	are	attribute	the Hitchcock movies	471-1
the Hitchcock movies	in	constraint	which	471-1
which		sequential	Hitchcock	471-1
Hitchcock	did not play	action	<B>	471-1
What movies	at	constraint	the Gaumont Opera	472-1
What movies	are featured	action	the Gaumont Opera	472-1
the Gaumont Opera	at	constraint	not the Gaumont les Halles	472-1
the Gaumont Opera	but	conjunctive	not the Gaumont les Halles	472-1
<B>	List	action	those movies	473-1
those movies	for	constraint	which	473-1
which		sequential	all actors	473-1
all actors	of	constraint	the movie	473-1
the movie	under	constraint	Hitchcock	473-1
the movie	have acted	action	Hitchcock	473-1
Hitchcock		sequential	direction	473-1
This chapter	explores	action	negation	474-1
negation	to	constraint	all forms	474-1
negation	how can be added	action	all forms	474-1
all forms	of	constraint	the conjunctive queries	474-1
the conjunctive queries	except	constraint	the tableau queries	474-1
the conjunctive queries	for	constraint	the tableau queries	474-1
the tableau queries	to	constraint	the power	474-1
the tableau queries	provide	action	the power	474-1
the power	to	constraint	such queries	474-1
the power	needed	action	such queries	474-1
the power	express	action	such queries	474-1
<B>	yields	action	languages	474-2
languages	in	constraint	the various paradigms	474-2
the various paradigms		sequential	that	474-2
that	have	action	the same expressive power	474-2
They	include	action	relational algebra	474-3
relational algebra		sequential	relational calculus	474-3
relational calculus	and	conjunctive	nonrecursive datalog	474-3
nonrecursive datalog	with	constraint	negation	474-3
The class	of	constraint	queries	474-4
queries		sequential	they	474-4
they	to	constraint	first order	474-4
they	as	constraint	first order	474-4
they	express	action	first order	474-4
they	is often referred	action	first order	474-4
first order		sequential	the queries	474-4
the queries	because	constraint	relational calculus	474-4
relational calculus	is	attribute	order	474-4
order	essentially predicate	action	calculus	474-4
calculus	without	constraint	function symbols	474-4
These languages	of	constraint	fundamental importance	474-5
These languages	are	attribute	fundamental importance	474-5
fundamental importance	in	constraint	database systems	474-5
They	provide	action	adequate power	474-6
adequate power	for	constraint	many applications	474-6
many applications	at	constraint	the same time	474-6
many applications	and	conjunctive	the same time	474-6
the same time	with	constraint	reasonable efficiency	474-6
the same time	can be implemented	action	reasonable efficiency	474-6
They	constitute	action	the basis	475-1
the basis	for	constraint	the standard commercial relational languages	475-1
the standard commercial relational languages		sequential	SQL	475-1
<B>	In	constraint	the case	476-1
the case	of	constraint	the algebras	476-1
the algebras		sequential	negation	476-1
negation	is added	action	the set difference operator	476-1
negation	using	action	the set difference operator	476-1
the set difference operator	yielding	action	the language s	476-1
the language s	to	constraint	relational algebra	476-1
the language s	as	constraint	relational algebra	476-1
the language s	generally referred	action	relational algebra	476-1
relational algebra		sequential	Section	476-1
Section		sequential	5.1	476-1
<B>	In	constraint	the case	476-2
the case	of	constraint	the paradigm	476-2
the case	rule based	action	the paradigm	476-2
the paradigm		sequential	we	476-2
we	consider	action	negative literals	476-2
negative literals	in	constraint	the bodies	476-2
the bodies	of	constraint	rules	476-2
rules		sequential	which	476-2
which	as	constraint	the absence	476-2
which	are interpreted	action	the absence	476-2
the absence	of	constraint	the corresponding facts	476-2
the corresponding facts	yields	action	nonrecursive datalog	476-2
The chapter	with	constraint	brief digressions	477-1
The chapter	concludes	action	brief digressions	477-1
brief digressions	concerning	action	aggregate functions	477-1
aggregate functions	into	constraint	the algebra	477-1
aggregate functions	can be incorporated	action	the algebra	477-1
the algebra	and	conjunctive	calculus	477-1
calculus		sequential	Section	477-1
Section		sequential	5.5	477-1
5.5	and	conjunctive	the emerging area	477-1
5.5	concerning	action	the emerging area	477-1
the emerging area	of	constraint	constraint databases	477-1
constraint databases		sequential	which	477-1
which	provide	action	a natural mechanism	477-1
a natural mechanism	for	constraint	infinite databases	477-1
a natural mechanism	and	conjunctive	infinite databases	477-1
a natural mechanism	representing	action	infinite databases	477-1
a natural mechanism	manipulating	action	infinite databases	477-1
infinite databases	in	constraint	a finite manner	477-1
a finite manner		sequential	Section	477-1
Section		sequential	5.6	477-1
<B>	From	constraint	the theoretical perspective	478-1
the theoretical perspective		sequential	the most important aspects	478-1
the most important aspects	of	constraint	this chapter	478-1
this chapter	include	action	the demonstration	478-1
the demonstration	of	constraint	the equivalence	478-1
the equivalence	of	constraint	the algebra	478-1
the algebra	and	conjunctive	calculus	478-1
calculus	including	action	a relatively direct transformation	478-1
a relatively direct transformation	of	constraint	calculus queries	478-1
calculus queries	into	constraint	equivalent algebra ones	478-1
equivalent algebra ones	and	conjunctive	the application	478-1
the application	of	constraint	the classical proof technique	478-1
the classical proof technique	of	constraint	structural induction	478-1
structural induction	on	constraint	calculus formulas	478-1
structural induction	both	conjunctive	calculus formulas	478-1
structural induction	used	action	calculus formulas	478-1
calculus formulas	and	conjunctive	algebra expressions	478-1
The Relational Algebras	Incorporating	action	the difference operator	479-1
the difference operator	into	constraint	the algebras	479-1
the difference operator	denoted	action	the algebras	479-1
the algebras	is	attribute	straightforward	479-1
<B>	As with	constraint	union	479-2
union	and	conjunctive	intersection	479-2
intersection	to	constraint	expressions	479-2
intersection	can only be applied	action	expressions	479-2
expressions		sequential	that	479-2
that	have	action	the same sort	479-2
the same sort	in	constraint	the named case	479-2
the named case	or	conjunctive	arity	479-2
arity	in	constraint	the unnamed case	479-2
Example		sequential	5.1.1	480-1
The unnamed relational algebra	by	constraint	the difference operator	481-1
The unnamed relational algebra	is obtained	action	the difference operator	481-1
The unnamed relational algebra	adding	action	the difference operator	481-1
the difference operator	to	constraint	the SPCU algebra	481-1
It	to	constraint	the intersection operator	481-2
It	is	attribute	conventional also	481-2
It	permit	action	the intersection operator	481-2
the intersection operator	denoted	action	∩	481-2
∩	in	constraint	this algebra	481-2
this algebra	because	constraint	it	481-2
it	is simulated easily	action	cross-product	481-2
it	using	action	cross-product	481-2
cross-product		sequential	select	481-2
select	and	conjunctive	project	481-2
project	or	conjunctive	difference	481-2
project	using	action	difference	481-2
difference	see	action	Exercise 5.4	481-2
<B>	Because	constraint	union	481-3
union	is	attribute	present	481-3
nonsingleton constant relations	in	constraint	this algebra	481-3
nonsingleton constant relations	may be used	action	this algebra	481-3
the selection operator	to	constraint	negation	481-4
the selection operator	Finally can be extended	action	negation	481-4
the selection operator	permit	action	negation	481-4
negation	see	action	Exercise 5.4	481-4
The named relational algebra	in	constraint	an analogous fashion	482-1
The named relational algebra	is obtained	action	an analogous fashion	482-1
an analogous fashion	and	conjunctive	similar generalizations	482-1
similar generalizations	can be developed	action	<B>	482-1
<B>	and	conjunctive	The relational algebras	483-1
<B>	named	action	The relational algebras	483-1
The relational algebras	have	action	equivalent expressive power	483-1
The notion	of	constraint	composition	484-1
composition	of	constraint	relational algebra queries	484-1
relational algebra queries	in	constraint	analogy	484-1
relational algebra queries	can be defined	action	analogy	484-1
analogy	to	constraint	the composition	484-1
the composition	of	constraint	conjunctive queries	484-1
conjunctive queries	in	constraint	the previous chapter	484-1
conjunctive queries	described	action	the previous chapter	484-1
It	that	constraint	the relational algebras	484-2
It	is easily verified	action	the relational algebras	484-2
the relational algebras	and	conjunctive	hence the other equivalent languages	484-2
hence the other equivalent languages	in	constraint	this chapter	484-2
hence the other equivalent languages	presented	action	this chapter	484-2
this chapter	under	constraint	composition	484-2
this chapter	are closed	action	composition	484-2
Nonrecursive Datalog	with	constraint	Negation	485-1
<B>	yields	action	the nonrecursive datalog	486-1
the nonrecursive datalog	with	constraint	negation	486-1
negation		sequential	also denoted nonrecursive datalog	486-1
S		sequential	u	487-1
u		sequential	L1	487-1
<B>	.	sequential	<B>	487-2
<B>	.	sequential	<B>	487-3
Ln		sequential	S	487-4
S	is	attribute	where a relation name	487-4
where a relation name		sequential	u	487-4
u	is	attribute	a free tuple	487-4
a free tuple	of	constraint	appropriate arity	487-4
appropriate arity	and	conjunctive	each Li	487-4
each Li	is	attribute	a literal	487-4
an expression	of	constraint	the form	487-4
the form		sequential	R	487-4
R		sequential	v	487-4
v	or	conjunctive	¬R	487-4
¬R		sequential	v	487-4
v		sequential	R	487-4
R	is	attribute	where a relation name	487-4
where a relation name	and	conjunctive	v	487-4
v	is	attribute	a free tuple	487-4
a free tuple	of	constraint	appropriate arity	487-4
appropriate arity	and	conjunctive	S	487-4
S	in	constraint	the body	487-4
S	where does not occur	action	the body	487-4
This rule		sequential	range	487-5
range	if	constraint	each variable x	487-5
range	is restricted	action	each variable x	487-5
each variable x	in	constraint	the rule	487-5
each variable x	occurring	action	the rule	487-5
the rule	in	constraint	one literal	487-5
the rule	at	constraint	one literal	487-5
the rule	occurs	attribute	least	487-5
one literal	of	constraint	the form	487-5
the form		sequential	R	487-5
R		sequential	v	487-5
v	in	constraint	the rule body	487-5
<B>	Unless	constraint	all datalog¬ rules	487-6
<B>	otherwise specified	action	all datalog¬ rules	487-6
all datalog¬ rules	to	constraint	range	487-6
all datalog¬ rules	considered	action	range	487-6
all datalog¬ rules	are assumed	action	range	487-6
range	be restricted	action	<B>	487-6
<B>	To	constraint	the semantics	488-1
<B>	give	action	the semantics	488-1
the semantics	of	constraint	the foregoing rule q	488-1
the foregoing rule q	let	action	R	488-1
R	be	attribute	a relation schema	488-1
a relation schema		sequential	that	488-1
that	of	constraint	the relation names	488-1
that	includes	attribute	all	488-1
the relation names	in	constraint	the body the rule	488-1
the relation names	occurring	action	the body the rule	488-1
the body the rule	of	constraint	q	488-1
q	and	conjunctive	I	488-1
q	let	action	I	488-1
I	be	attribute	an instance	488-1
an instance	of	constraint	R	488-1
the image	of	constraint	I	489-1
I	under	constraint	q	489-1
q	is	attribute	Then q	489-1
Then q		sequential	I	489-1
I	=	sequential	ν	489-1
ν		sequential	u	489-1
u		sequential	ν	489-1
ν	is	attribute	a valuation	489-1
a valuation	for	constraint	i	489-1
a valuation	and	conjunctive	i	489-1
i		sequential	∈	489-1
∈		sequential	1	489-1
1		sequential	n	489-1
<B>	In	constraint	this image	490-1
this image	as	constraint	a difference q1	490-1
this image	can be expressed	action	a difference q1	490-1
a difference q1		sequential	q2	490-1
q2		sequential	q1	490-1
q1	is	attribute	where an SPC query	490-1
where an SPC query	and	conjunctive	q2	490-1
q2	is	attribute	an SPCU query	490-1
an SPCU query	see	action	Exercise 5.9	490-1
Equality	by	constraint	literals =	491-1
Equality	may be incorporated	action	literals =	491-1
Equality	permitting	action	literals =	491-1
literals =	of	constraint	the form	491-1
the form		sequential	t	491-1
t	and	conjunctive	s	491-1
s	=	sequential	t	491-1
t	for	constraint	terms	491-1
terms	and	conjunctive	t	491-1
The semantics	in	constraint	the natural manner	491-2
The semantics	are defined	action	the natural manner	491-2
<B>	To	constraint	the full expressive power	492-1
<B>	obtain	action	the full expressive power	492-1
the full expressive power	of	constraint	the relational algebras	492-1
the relational algebras		sequential	we	492-1
we	must consider	action	sets	492-1
sets	of	constraint	nr-datalog¬ rules	492-1
nr-datalog¬ rules	to	constraint	the nr-datalog programs	492-1
nr-datalog¬ rules	are	attribute	analogous	492-1
the nr-datalog programs	in	constraint	the previous chapter	492-1
the nr-datalog programs	introduced	action	the previous chapter	492-1
A nonrecursive datalog¬ program	with	constraint	equality	492-2
A nonrecursive datalog¬ program	without	constraint	equality	492-2
A nonrecursive datalog¬ program	or	conjunctive	equality	492-2
equality	over	constraint	schema R	492-2
schema R	is	attribute	a sequence S2	492-2
a sequence S2		sequential	S1	492-2
S1		sequential	body1	492-2
body1	←	sequential	body2	492-2
<B>		sequential	bodym	493-1
bodym	of	constraint	nr-datalog¬ rules	493-1
nr-datalog¬ rules		sequential	no relation name	493-1
no relation name	in	constraint	R	493-1
R	in	constraint	a rule head	493-1
R	where occurs	action	a rule head	493-1
a rule head		sequential	the same relation name	493-1
the same relation name	in	constraint	more than one rule head	493-1
the same relation name	may appear	action	more than one rule head	493-1
more than one rule head	and	conjunctive	there	493-1
there	is	attribute	some ordering	493-1
some ordering		sequential	r1	493-1
<B>	.	sequential	<B>	493-2
<B>	.	sequential	<B>	493-3
rm	of	constraint	the rules	493-4
the rules	so that	constraint	the relation name	493-4
the relation name	in	constraint	the head	493-4
the head	of	constraint	a rule ri	493-4
a rule ri	in	constraint	the body	493-4
a rule ri	does not occur	action	the body	493-4
the body	of	constraint	a rule rj	493-4
a rule rj		sequential	j	493-4
j		sequential	whenever ≤	493-4
whenever ≤		sequential	i	493-4
The semantics	of	constraint	these programs	493-5
these programs	to	constraint	the semantics	493-5
these programs	are	attribute	entirely analogous	493-5
the semantics	of	constraint	nr-datalog programs	493-5
An nr-datalog¬ query	is	attribute	a query	493-6
a query	by	constraint	some nr-datalog¬ program	493-6
a query	defined	action	some nr-datalog¬ program	493-6
some nr-datalog¬ program	with	constraint	a specified target relation	493-6
Example		sequential	5.2.1	494-1
Query		sequential	5.3	495-1
5.3	by	constraint	Hitch actor	495-1
5.3	is answered	action	Hitch actor	495-1
Hitch actor		sequential	z	495-1
z		sequential	Movies	495-1
Movies		sequential	x	495-1
x		sequential	Hitchcock	495-1
Hitchcock		sequential	z	495-1
z		sequential	not ans	495-1
not ans		sequential	x	495-1
Care	must be taken	action	nr-datalog¬ programs	496-1
Care	when forming	action	nr-datalog¬ programs	496-1
<B>	for	constraint	example	496-2
<B>	Consider	action	example	496-2
example		sequential	the following program	496-2
the following program		sequential	which	496-2
which	forms	action	a kind	496-2
a kind	of	constraint	merging	496-2
merging	of	constraint	the first two rules	496-2
the first two rules	of	constraint	the previous program	496-2
the first rule	is	attribute	Intuitively a combination	496-3
Intuitively a combination	of	constraint	the first two rules	496-3
the first two rules	of	constraint	the preceding program	496-3
the preceding program	using	action	variable renaming	496-3
variable renaming	in	constraint	the spirit	496-3
the spirit	of	constraint	Example 4.3.1	496-3
<B>		sequential	not-ans	497-1
not-ans		sequential	x	497-1
x		sequential	Movies	497-1
Movies		sequential	x	497-1
x		sequential	y	497-1
y		sequential	z	497-1
z		sequential	¬ Movies	497-1
¬ Movies		sequential	Hitchcock	497-1
Hitchcock		sequential	z	497-1
z		sequential	Movies	497-1
Movies		sequential	x′	497-1
x′		sequential	Hitchcock	497-1
Hitchcock		sequential	z′	497-1
z′	expressing	action	query	497-1
query		sequential	5.3	497-1
5.3		sequential	it	497-1
it	expresses	attribute	the	497-1
it	following	action	<B>	497-1
It	that	constraint	each nr-datalog¬ program	498-1
It	is easily verified	action	each nr-datalog¬ program	498-1
each nr-datalog¬ program	with	constraint	equality	498-1
equality	by	constraint	an nr-datalog¬ program	498-1
equality	can be simulated	action	an nr-datalog¬ program	498-1
an nr-datalog¬ program	not using	action	equality	498-1
equality	see	action	Exercise 5.10	498-1
<B>	see	action	Exercise 5.11	498-2
Exercise 5.11	holds	action	Proposition 5.2.2	498-2
The Relational Calculus		sequential	The Relational Calculus	499-1
this flexibility	with	constraint	it	500-1
this flexibility	However brings	action	it	500-1
it		sequential	a nontrivial cost	500-1
<B>	of	constraint	the theoretical development	500-2
the theoretical development	in	constraint	the following section	500-2
the theoretical development	and	conjunctive	the following section	500-2
the following section	on	constraint	different approaches	500-2
the following section	is focused	action	different approaches	500-2
different approaches	to	constraint	the calculus	500-2
different approaches	make	action	the calculus	500-2
the calculus	to	constraint	problems	500-2
the calculus	and	conjunctive	problems	500-2
the calculus	prevent	attribute	this	500-2
<B>	Although	constraint	considerable effort	500-3
considerable effort	is required	action	it	500-3
it	is	attribute	a relatively small price	500-3
a relatively small price	to	constraint	the flexibility	500-3
a relatively small price	for	constraint	the flexibility	500-3
a relatively small price	pay	action	the flexibility	500-3
the flexibility	obtained	action	<B>	500-3
This section	first extends	action	the syntax	501-1
the syntax	of	constraint	the conjunctive calculus	501-1
the conjunctive calculus	to	constraint	the full calculus	501-1
some intuitive examples	Then are presented	action	that	502-1
that	illustrate	action	some calculus queries	502-1
some calculus queries	can violate	action	the principle	502-1
the principle	of	constraint	domain independence	502-1
domain independence		sequential	A variety	502-1
A variety	of	constraint	approaches	502-1
approaches	to	constraint	this problem	502-1
approaches	have been developed	action	this problem	502-1
approaches	resolve	action	this problem	502-1
this problem	on	constraint	the use	502-1
this problem	based	action	the use	502-1
the use	of	constraint	restrictions	502-1
the use	both	conjunctive	restrictions	502-1
the use	and	conjunctive	restrictions	502-1
This section	on	constraint	semantic restrictions	503-1
This section	focuses	action	semantic restrictions	503-1
The first step	in	constraint	a somewhat technical definition	503-2
The first step	understanding	attribute	these	503-2
The first step	is	attribute	a somewhat technical definition	503-2
a somewhat technical definition	on	constraint	relativized interpretation	503-2
a somewhat technical definition	based	action	relativized interpretation	503-2
relativized interpretation	for	constraint	the semantics	503-2
the semantics	of	constraint	calculus queries	503-2
calculus queries		sequential	the semantics	503-2
the semantics	to	constraint	different underlying domains	503-2
the semantics	are defined	attribute	relative	503-2
different underlying domains		sequential	subsets	503-2
subsets	of	constraint	dom	503-2
<B>	permits	action	us	503-3
us	to	constraint	a formal definition	503-3
us	give	action	a formal definition	503-3
a formal definition	of	constraint	domain independence	503-3
domain independence	to	constraint	a family	503-3
domain independence	and	conjunctive	a family	503-3
domain independence	leads	action	a family	503-3
a family	of	constraint	different semantics	503-3
different semantics	for	constraint	a given query	503-3
The section	by	constraint	the equivalence	504-1
The section	closes	action	the equivalence	504-1
The section	presenting	action	the equivalence	504-1
the equivalence	of	constraint	the calculus	504-1
the calculus	under	constraint	two	504-1
two	of	constraint	the semantics	504-1
the semantics	with	constraint	the algebra	504-1
<B>	effectively closes	action	the issue	504-2
the issue	of	constraint	expressive power	504-2
expressive power	of	constraint	the calculus	504-2
the calculus	from	constraint	at least a semantic point	504-2
at least a semantic point	of	constraint	view	504-2
One	of	constraint	the semantics	504-3
the semantics	for	constraint	the calculus	504-3
the calculus	is	attribute	active domain	504-3
the calculus	presented here	action	active domain	504-3
active domain		sequential	the semantics	504-3
the semantics	in	constraint	the development	504-3
the semantics	is	attribute	particularly convenient	504-3
the development	of	constraint	theoretical results	504-3
theoretical results	concerning	action	the expressive power	504-3
the expressive power	of	constraint	a variety	504-3
a variety	of	constraint	languages	504-3
languages	in	constraint	Parts	504-3
languages	presented	action	Parts	504-3
Parts		sequential	D	504-3
D	and	conjunctive	E	504-3
<B>		sequential	Formed Formulas	505-1
Formed Formulas	Revisited	action	<B>	505-1
Explicit equality	to	constraint	the full expressive power	505-2
Explicit equality	is needed	action	the full expressive power	505-2
Explicit equality	obtain	action	the full expressive power	505-2
the full expressive power	of	constraint	the algebras	505-2
the algebras	see	action	Exercise 5.12	505-2
<B>	As	constraint	disjunction	505-3
<B>	both	conjunctive	disjunction	505-3
<B>	will be seen	action	disjunction	505-3
disjunction	and	conjunctive	universal quantification	505-3
universal quantification	as	constraint	consequences	505-3
universal quantification	can be viewed	action	consequences	505-3
consequences	of	constraint	negation	505-3
consequences	adding	action	negation	505-3
negation	because	constraint	ψ	505-3
ψ		sequential	¬	505-3
¬		sequential	¬ϕ	505-3
¬ϕ		sequential	∧ ¬ψ	505-3
∧ ¬ψ	and	conjunctive	∀xϕ ≡¬∃x¬ϕ	505-3
The formal definition	of	constraint	the syntax	506-1
the syntax	of	constraint	the relational calculus	506-1
the relational calculus	is	attribute	a straightforward extension	506-1
a straightforward extension	of	constraint	the conjunctive calculus	506-1
a straightforward extension	for	constraint	the conjunctive calculus	506-1
the conjunctive calculus	in	constraint	the previous chapter	506-1
the conjunctive calculus	given	action	the previous chapter	506-1
We	include	action	the full definition here	506-2
the full definition here	for	constraint	the reader	506-2
the reader		sequential	convenience	506-2
A term	or	conjunctive	a variable	506-3
A term	is	attribute	a constant	506-3
<B>	For	constraint	a given input schema R	506-4
a given input schema R		sequential	the base formulas	506-4
the base formulas	as	constraint	atoms	506-4
the base formulas	include	action	atoms	506-4
atoms	over	constraint	R	506-4
R	and	conjunctive	equality	506-4
equality		sequential	inequality	506-4
inequality		sequential	atoms	506-4
atoms	of	constraint	the form e	506-4
the form e	=	sequential	e′	506-4
e′		sequential	e	506-4
e	=	sequential	e′	506-4
e′	for	constraint	terms	506-4
terms		sequential	e	506-4
e		sequential	e′	506-4
<B>	well formed	action	The formulas	506-5
The formulas	of	constraint	the relational calculus	506-5
the relational calculus	over	constraint	R	506-5
R	include	action	the base formulas	506-5
the base formulas	and	conjunctive	formulas	506-5
formulas	of	constraint	the form	506-5
the form		sequential	∧	506-5
∧		sequential	ψ	506-5
ψ	and	conjunctive	ψ	506-5
ψ	are	attribute	formulas	506-5
formulas	over	constraint	R	506-5
It	to	constraint	the binary connectives	507-1
It	is	attribute	sometimes convenient	507-1
It	view	action	the binary connectives	507-1
the binary connectives	as	constraint	∨ polyadic connectives	507-1
the binary connectives	and	conjunctive	∨ polyadic connectives	507-1
<B>	In	constraint	some contexts	508-1
some contexts		sequential	e	508-1
e		sequential	e′	508-1
e′	as	constraint	an abbreviation	508-1
e′	is viewed	action	an abbreviation	508-1
an abbreviation	of	constraint	¬	508-1
¬		sequential	e	508-1
e	=	sequential	e′	508-1
It	to	constraint	two additional logical connectives	509-1
It	is	attribute	often convenient	509-1
It	include	action	two additional logical connectives	509-1
two additional logical connectives	implies	action	→	509-1
→	to	constraint	<B>	509-1
→	and	conjunctive	<B>	509-1
→	is	attribute	equivalent	509-1
We	as	constraint	syntactic abbreviations	509-2
We	view	attribute	these	509-2
syntactic abbreviations	as	constraint	ψ	509-2
syntactic abbreviations	follows	action	ψ	509-2
ψ		sequential	¬ϕ	509-2
The notions	of	constraint	occurrences	510-1
The notions	and	conjunctive	occurrences	510-1
The notions	bound	action	occurrences	510-1
occurrences	of	constraint	variables	510-1
variables	in	constraint	a formula	510-1
a formula	of	constraint	formula	510-1
a formula	for	constraint	formula	510-1
a formula	and	conjunctive	formula	510-1
formula	to	constraint	their definition	510-1
formula	are defined analogously	action	their definition	510-1
their definition	for	constraint	the conjunctive calculus	510-1
<B>	In	constraint	addition	510-2
addition		sequential	the notion	510-2
the notion	of	constraint	relational calculus query	510-2
relational calculus query	in	constraint	analogy	510-2
relational calculus query	is defined	action	analogy	510-2
analogy	to	constraint	the notion	510-2
the notion	of	constraint	conjunctive calculus query	510-2
conjunctive calculus query	to	constraint	an expression	510-2
conjunctive calculus query	be	attribute	an expression	510-2
an expression	of	constraint	the form	510-2
the form	if	constraint	the sort	510-2
the form	or	conjunctive	the sort	510-2
the sort	from	constraint	the context	510-2
the sort	is understood	action	the context	510-2
the context		sequential	where e1	510-2
<B>	.	sequential	<B>	510-3
<B>	.	sequential	<B>	510-4
em	are	attribute	terms	510-5
terms		sequential	repeats	510-5
repeats	and	conjunctive	the set	510-5
repeats	permitted	action	the set	510-5
the set	of	constraint	variables	510-5
variables	in	constraint	e1	510-5
variables	occurring	action	e1	510-5
<B>	.	sequential	<B>	510-6
<B>	.	sequential	<B>	510-7
em	is	attribute	exactly free ϕ	510-8
Example		sequential	5.3.1	511-1
Query		sequential	5.1	511-2
5.1	in	constraint	the relational calculus	511-2
5.1	can be expressed as	action	the relational calculus	511-2
Query		sequential	5.3	512-1
5.3	by	constraint	<B>	512-1
5.3	is expressed	action	<B>	512-1
The first conjunct	that	constraint	the variable xt	513-1
The first conjunct	ensures	action	the variable xt	513-1
the variable xt	over	constraint	titles	513-1
the variable xt	ranges	action	titles	513-1
titles	in	constraint	the current value	513-1
the current value	of	constraint	Movies	513-1
Movies	and	conjunctive	the second conjunct	513-1
the second conjunct	enforces	action	the condition	513-1
the condition	on	constraint	actors	513-1
actors	of	constraint	the movie	513-1
the movie	by	constraint	xt	513-1
the movie	identified	action	xt	513-1
<B>	Before	constraint	the alternative semantics	514-1
<B>	presenting	action	the alternative semantics	514-1
the alternative semantics	for	constraint	the relational calculus	514-1
the relational calculus		sequential	we	514-1
we	present	action	an intuitive indication	514-1
an intuitive indication	of	constraint	the kinds	514-1
the kinds	of	constraint	problems	514-1
problems		sequential	that	514-1
that	if	constraint	the conventional definitions	514-1
that	arise	action	the conventional definitions	514-1
the conventional definitions	from	constraint	predicate calculus	514-1
predicate calculus	to	constraint	the current context	514-1
predicate calculus	are adapted directly	action	the current context	514-1
The fundamental problems	of	constraint	the calculus	515-1
The fundamental problems	using	action	the calculus	515-1
the calculus	by	constraint	the following expressions	515-1
the calculus	are illustrated	action	the following expressions	515-1
<B>	If	constraint	the usual semantics	516-1
the usual semantics	of	constraint	predicate calculus	516-1
predicate calculus	to	constraint	this context	516-1
predicate calculus	are adapted directly	action	this context	516-1
this context		sequential	the query	516-1
the query		sequential	1	516-1
1	produces	action	all tuples	516-1
all tuples		sequential	a where a ∈ dom	516-1
a where a ∈ dom	and	conjunctive	Cries	516-1
Cries	and	conjunctive	Whispers	516-1
<B>	if	constraint	the underlying domain	517-1
the underlying domain	is	attribute	Even finite	517-1
users	will typically not know	action	the exact contents	517-1
the exact contents	of	constraint	the domains	517-1
the domains	for	constraint	<B>	517-1
the domains	used	attribute	each variable	517-1
<B>	In	constraint	this case	517-2
this case		sequential	it	517-2
it	to	constraint	the result	517-2
it	be	attribute	would disturbing	517-2
it	have	action	the result	517-2
the result	of	constraint	a user query	517-2
a user query	on	constraint	information	517-2
a user query	depend	action	information	517-2
information	under	constraint	the user	517-2
the user		sequential	not directly control	517-2
<B>	is	attribute	another argument	517-3
another argument	for	constraint	domain	517-3
another argument	permitting	action	domain	517-3
domain		sequential	only queries	517-3
The answer	to	constraint	this query	518-1
this query	because	constraint	it	518-1
this query	is	attribute	necessarily finite	518-1
it	is	attribute	a subset	518-1
a subset	of	constraint	π 1	518-1
π 1		sequential	R	518-1
the query	is	attribute	domain	518-2
domain		sequential	<B>	518-2
<B>	To	constraint	y	518-3
<B>	that	constraint	y	518-3
<B>	if	constraint	y	518-3
<B>	see why	action	y	518-3
<B>	note	action	y	518-3
y	to	constraint	dom	518-3
y	over	constraint	dom	518-3
y	of	constraint	dom	518-3
y	is assumed	attribute	all	518-3
y	range	attribute	all	518-3
dom		sequential	the answer	518-3
the answer	is	attribute	always the empty relation	518-3
<B>	On	constraint	the other hand	518-4
the other hand	if	constraint	the underlying domain	518-4
the underlying domain	of	constraint	interpretation	518-4
interpretation	is	attribute	finite	518-4
it	that	constraint	the answer	518-4
it	is	attribute	possible	518-4
the answer	be	attribute	will nonempty	518-4
<B>	for	constraint	example	518-5
<B>	occurs	action	example	518-5
example	if	constraint	the domain	518-5
the domain	{	sequential	1	518-5
the domain	is	attribute	1	518-5
<B>	.	sequential	<B>	518-6
<B>	.	sequential	<B>	518-7
5 }	and	conjunctive	the input	518-8
the input	for	constraint	R	518-8
R	is	attribute	{ 3	518-8
{ 3		sequential	1	518-8
<B>	.	sequential	<B>	518-9
<B>	.	sequential	<B>	518-10
3		sequential	5 }	518-11
<B>		sequential	this query	518-12
this query	on	constraint	the underlying domain s	518-12
this query	So depends	action	the underlying domain s	518-12
the underlying domain s	for	constraint	the different variables	518-12
the underlying domain s	being used	action	the different variables	518-12
the different variables	under	constraint	the user	518-12
the different variables	and	conjunctive	the user	518-12
the different variables	is	attribute	the user	518-12
the user		sequential	not control	518-12
There	is	attribute	a further difficulty	519-1
a further difficulty	of	constraint	a more practical nature	519-1
a more practical nature	by	constraint	query	519-1
a more practical nature	raised	action	query	519-1
query	-	sequential	3	519-1
<B>	if	constraint	the intuitively appealing semantics	520-1
the intuitively appealing semantics	of	constraint	the predicate calculus	520-1
the predicate calculus	are used	action	the naive approach	520-1
the naive approach	to	constraint	quantifiers	520-1
the naive approach	evaluating	action	quantifiers	520-1
quantifiers	to	constraint	the execution	520-1
quantifiers	Specifically leads	action	the execution	520-1
the execution	of	constraint	potentially infinite procedures	520-1
<B>	Although	constraint	the proper answer	520-2
the proper answer	to	constraint	such queries	520-2
such queries	in	constraint	a finite manner	520-2
such queries	can be computed	action	a finite manner	520-2
a finite manner	see	action	Theorem 5.6.1	520-2
Theorem 5.6.1	is	attribute	technically intricate	520-2
The following example	indicates	attribute	how easy	521-1
it	to	constraint	an unsafe query	521-1
it	is	attribute	an unsafe query	521-1
it	form mistakenly	action	an unsafe query	521-1
an unsafe query	in	constraint	practice	521-1
Example		sequential	5.3.2	522-1
<B>	that	constraint	the first conjunct	522-2
<B>	Suppose	action	the first conjunct	522-2
the first conjunct	of	constraint	that query	522-2
that query	to	constraint	<B>	522-2
that query	is omitted	attribute	the following	522-2
that query	obtain	attribute	the following	522-2
This query	returns	action	all titles	523-1
all titles	of	constraint	movies	523-1
movies		sequential	that	523-1
that	have	action	the specified property	523-1
the specified property	and	conjunctive	also all elements	523-1
also all elements	of	constraint	dom	523-1
dom	in	constraint	π Title	523-1
dom	not occurring	action	π Title	523-1
π Title		sequential	Movies	523-1
<B>	if	constraint	range	523-2
<B>	to	constraint	range	523-2
<B>	Even were restricted	action	range	523-2
range	over	constraint	the set	523-2
the set	of	constraint	movie titles	523-2
the set	and	conjunctive	movie titles	523-2
movie titles		sequential	it	523-2
it	be	attribute	domain	523-2
domain		sequential	<B>	523-2
Relativized Interpretations		sequential	Relativized Interpretations	524-1
<B>	As	constraint	the first step	524-2
the first step		sequential	we	524-2
we	present	action	a definition	524-2
a definition		sequential	that	524-2
that	will permit	action	us	524-2
us	to	constraint	calculus queries	524-2
us	about	constraint	calculus queries	524-2
us	talk	action	calculus queries	524-2
calculus queries	in	constraint	connection	524-2
connection	with	constraint	different underlying domains	524-2
<B>	Under	constraint	the conventional semantics	525-1
the conventional semantics	with	constraint	predicate calculus	525-1
the conventional semantics	associated	action	predicate calculus	525-1
predicate calculus		sequential	quantified variables	525-1
quantified variables	over	constraint	all elements	525-1
quantified variables	range	action	all elements	525-1
all elements	of	constraint	the underlying domain	525-1
the underlying domain	in	constraint	our case	525-1
our case		sequential	dom	525-1
<B>	For	constraint	our purposes	525-2
our purposes		sequential	we	525-2
we	generalize	action	this notion	525-2
this notion	to	constraint	explicit specification	525-2
this notion	permit	action	explicit specification	525-2
explicit specification	of	constraint	the underlying domain	525-2
the underlying domain	to	constraint	which variables	525-2
the underlying domain	over	constraint	which variables	525-2
the underlying domain	use	action	which variables	525-2
which variables	may range	action	<B>	525-2
<B>	to	constraint	d	526-1
d	denoted	action	I	526-1
I		sequential	ν	526-1
ν	if	constraint	ϕ	526-1
ϕ	=	sequential	R	526-1
R		sequential	u	526-1
u	is	attribute	a an atom	526-1
a an atom	and	conjunctive	ν	526-1
ν		sequential	u	526-1
u		sequential	∈ I	526-1
∈ I		sequential	R	526-1
The notion	of	constraint	satisfies	527-1
<B>	.	sequential	<B>	527-2
<B>	.	sequential	<B>	527-3
<B>	to	constraint	the usual notion	527-4
<B>	to	constraint	the usual notion	527-4
<B>	just presented	attribute	equivalent	527-4
<B>	is	attribute	equivalent	527-4
the usual notion	of	constraint	satisfaction	527-4
satisfaction	in	constraint	order	527-4
satisfaction	found	attribute	first	527-4
order		sequential	logic	527-4
logic		sequential	the set d	527-4
the set d	where plays	action	the role	527-4
the role	of	constraint	the universe	527-4
the universe	of	constraint	discourse	527-4
discourse	in	constraint	first order	527-4
first order		sequential	logic	527-4
<B>	In	constraint	practical database settings	527-5
practical database settings		sequential	it	527-5
it	to	constraint	the underlying universe	527-5
it	that	constraint	the underlying universe	527-5
it	is	attribute	most natural	527-5
it	assume	action	the underlying universe	527-5
the underlying universe	for	constraint	this reason	527-5
the underlying universe	is	attribute	dom	527-5
this reason		sequential	we	527-5
we	use here	action	specialized terminology	527-5
<B>	that	constraint	query q	528-1
<B>	for	constraint	query q	528-1
<B>	Recall	action	query q	528-1
query q	and	conjunctive	input	528-1
input		sequential	a instance	528-1
a instance		sequential	I	528-1
I		sequential	we	528-1
we	denote	action	adom	528-1
adom		sequential	q	528-1
q		sequential	∪	528-1
∪		sequential	adom	528-1
adom		sequential	I	528-1
I	by	constraint	adom	528-1
adom		sequential	q	528-1
q		sequential	I	528-1
I	and	conjunctive	the notation	528-1
the notation		sequential	adom	528-1
adom		sequential	ϕ	528-1
ϕ		sequential	I	528-1
I	for	constraint	formula	528-1
formula	is defined analogously	action	<B>	528-1
We	can now define	action	the relativized semantics	529-1
the relativized semantics	for	constraint	the calculus	529-1
<B>	Let	action	R	529-2
R	be	attribute	a schema	529-2
a schema		sequential	q	529-2
q	=	sequential	e1	529-2
q	{	sequential	e1	529-2
<B>	.	sequential	<B>	529-3
<B>	.	sequential	<B>	529-4
en		sequential	a calculus query	529-5
a calculus query	over	constraint	R	529-5
R	and	conjunctive	d	529-5
d		sequential	I	529-5
I		sequential	a relativized instance	529-5
a relativized instance	over	constraint	R	529-5
the image	of	constraint	I	530-1
I	under	constraint	q relative	530-1
q relative	to	constraint	d	530-1
d	is	attribute	qd	530-1
qd		sequential	I	530-1
I	=	sequential	ν	530-1
ν		sequential	e1	530-1
<B>	.	sequential	<B>	530-2
<B>	.	sequential	<B>	530-3
en		sequential	I	530-4
I	|=d	action	ν	530-4
ν		sequential	ν	530-4
ν	is	attribute	a valuation ϕ	530-4
a valuation ϕ	over	constraint	range	530-4
a valuation ϕ	with	constraint	range	530-4
range		sequential	⊆ d	530-4
⊆ d		sequential	}	530-4
<B>	that	constraint	d	531-1
<B>	if	constraint	d	531-1
<B>	Note	action	d	531-1
d	is	attribute	infinite	531-1
this image	be	attribute	may an infinite set	531-1
may an infinite set	of	constraint	tuples	531-1
qd		sequential	I	532-1
I	=	sequential	qd∪ adom	532-1
qd∪ adom		sequential	q	532-1
q		sequential	I	532-1
I		sequential	I	532-1
Example		sequential	5.3.3	533-1
<B>	that	constraint	an interpretation	534-1
<B>	under	constraint	an interpretation	534-1
<B>	illustrates	action	an interpretation	534-1
an interpretation	to	constraint	a set d	534-1
a set d		sequential	a calculus query q	534-1
a calculus query q	on	constraint	input	534-1
input		sequential	I	534-1
I	by	constraint	|d	534-1
I	may be affected	action	|d	534-1
|d		sequential	adom	534-1
adom		sequential	q	534-1
q		sequential	I	534-1
It	to	constraint	the semantics	535-1
It	that	constraint	the semantics	535-1
It	is	attribute	important	535-1
It	note	action	the semantics	535-1
the semantics	of	constraint	algebra	535-1
algebra	and	conjunctive	datalog¬	535-1
datalog¬		sequential	queries	535-1
queries	on	constraint	instance	535-1
queries	q evaluated	action	instance	535-1
instance		sequential	I	535-1
I	of	constraint	dom	535-1
I	whether	constraint	dom	535-1
I	are	attribute	independent	535-1
dom	or	conjunctive	subset d	535-1
subset d		sequential	some adom	535-1
some adom		sequential	q	535-1
q		sequential	I	535-1
I		sequential	⊆	535-1
⊆		sequential	⊆ dom	535-1
⊆ dom	as	constraint	the underlying domain	535-1
⊆ dom	d is used	action	the underlying domain	535-1
<B>	and	conjunctive	The Domain Semantics	536-1
The Domain Semantics	for	constraint	Calculus Queries	536-1
<B>	of	constraint	the conventional interpretation	536-2
<B>	to	constraint	the conventional interpretation	536-2
<B>	corresponds most closely	action	the conventional interpretation	536-2
the conventional interpretation	of	constraint	predicate calculus	536-2
predicate calculus	and	conjunctive	thus perhaps the intuitively most natural semantics	536-2
predicate calculus	is	attribute	thus perhaps the intuitively most natural semantics	536-2
thus perhaps the intuitively most natural semantics	for	constraint	the calculus	536-2
Definition		sequential	5.3.4	537-1
The second interpretation	on	constraint	quantified variables	538-1
The second interpretation	is based	action	quantified variables	538-1
The second interpretation	restricting	action	quantified variables	538-1
quantified variables	to	constraint	the active domain	538-1
quantified variables	over	constraint	the active domain	538-1
quantified variables	range	action	the active domain	538-1
the active domain	of	constraint	the query	538-1
the query	and	conjunctive	the input	538-1
<B>	Although	constraint	this interpretation	538-2
this interpretation	from	constraint	the practical perspective	538-2
this interpretation	is	attribute	unnatural	538-2
the practical perspective		sequential	it	538-2
it	has	action	the advantage	538-2
the advantage	that	constraint	the output	538-2
the output	is always defined	attribute	finite	538-2
It	is	attribute	also a convenient semantics	538-3
also a convenient semantics	for	constraint	certain theoretical developments	538-3
Definition		sequential	5.3.5	539-1
The family	of	constraint	mappings	539-2
mappings	from	constraint	calculus queries	539-2
mappings	obtained	action	calculus queries	539-2
calculus queries	under	constraint	the active domain interpretation	539-2
the active domain interpretation	is denoted	action	CALC adom	539-2
Example		sequential	5.3.6	540-1
<B>	Under	constraint	the natural interpretation	540-2
the natural interpretation	on	constraint	input	540-2
input		sequential	the instance	540-2
the instance		sequential	I	540-2
I	in	constraint	Chapter 3	540-2
I	shown	action	Chapter 3	540-2
Chapter 3		sequential	this query	540-2
this query	yields	action	the undefined result	540-2
<B>	On	constraint	the other hand	540-3
the other hand	under	constraint	the active domain interpretation	540-3
the active domain interpretation	as	constraint	output	540-3
the active domain interpretation	yields	action	output	540-3
output	written informally	action	actors	540-3
actors	in	constraint	Cries	540-3
Cries	and	conjunctive	Whispers	540-3
Whispers		sequential	}	540-3
}	×	constraint	adom	540-3
adom		sequential	I	540-3
I		sequential	∪	540-3
∪		sequential	adom	540-3
adom		sequential	I	540-3
I		sequential	×	540-3
×		sequential	movies	540-3
movies	by	constraint	Bergman	540-3
Bergman	featuring	action	Ullman }	540-3
Ullman }		sequential	which	540-3
which	and	conjunctive	<B>	540-3
which	is	attribute	finite	540-3
which	defined	action	<B>	540-3
Domain Independence		sequential	Domain Independence	541-1
Definition		sequential	5.3.7	542-1
<B>	In	constraint	q	543-1
<B>	if	constraint	q	543-1
q	is	attribute	domain	543-1
domain		sequential	the output	543-1
the output	according to	action	the natural interpretation	543-1
the natural interpretation	by	constraint	the active domain interpretation	543-1
the natural interpretation	can be obtained	action	the active domain interpretation	543-1
the natural interpretation	computing	action	the active domain interpretation	543-1
Thus Lemma		sequential	5.3.8	543-2
5.3.8		sequential	CALCdi	543-2
CALCdi	⊑	sequential	CALC adom	543-2
Example		sequential	5.3.9	544-1
Equivalence	of	constraint	Algebra	545-1
Algebra	and	conjunctive	Calculus	545-1
Theorem		sequential	5.3.10	546-1
5.3.10		sequential	Equivalence Theorem	546-1
Proposition 5.2.2	that	constraint	nr-datalog¬	547-1
Proposition 5.2.2	shows	action	nr-datalog¬	547-1
nr-datalog¬	and	conjunctive	the algebras	547-1
the algebras	have	action	equivalent expressive power	547-1
<B>	In	constraint	addition	547-2
addition		sequential	Lemma 5.3.8	547-2
Lemma 5.3.8	that	constraint	CALC	547-2
Lemma 5.3.8	shows	action	CALC	547-2
CALC		sequential	CALCdi adom	547-2
<B>	To	constraint	the proof	547-3
<B>	complete	action	the proof	547-3
the proof		sequential	we	547-3
we	demonstrate	action	<B>	547-3
Lemma		sequential	5.3.11	548-1
Proof	Let	action	q	549-1
q	be	attribute	an unnamed algebra query	549-1
an unnamed algebra query	with	constraint	arity n	549-1
<B>	.	sequential	<B>	549-2
<B>	.	sequential	<B>	549-3
xn	to	constraint	q	549-4
xn	ϕq	sequential	q	549-4
xn	is	attribute	equivalent	549-4
The formula ϕq	is constructed	action	an induction	549-5
The formula ϕq	using	action	an induction	549-5
an induction	on	constraint	subexpressions	549-5
subexpressions	of	constraint	q	549-5
<B>	In	constraint	subexpression E	549-6
<B>	for	constraint	subexpression E	549-6
subexpression E	of	constraint	q	549-6
q		sequential	we	549-6
we	define	action	ϕE	549-6
ϕE	according to	action	the following cases	549-6
F		sequential	ψF	550-1
ψF	is	attribute	where the formula	550-1
where the formula	from	constraint	F	550-1
where the formula	obtained	action	F	550-1
F	by	constraint	each coordinate identifier	550-1
F	replacing	action	each coordinate identifier	550-1
each coordinate identifier		sequential	i	550-1
i	by	constraint	variable xi	550-1
<B>	in	constraint	n	551-1
n	=	sequential	yin j1 jl E1	551-1
yin j1 jl E1		sequential	where j1	551-1
<B>	.	sequential	<B>	551-2
<B>	.	sequential	<B>	551-3
jl	is	attribute	a listing	551-4
a listing	of	constraint	1	551-4
1		sequential	arity	551-4
arity		sequential	E1	551-4
E1	{	sequential	i1	551-4
<B>	.	sequential	<B>	551-5
<B>	.	sequential	<B>	551-6
<B>	in	constraint	}	551-7
E2		sequential	E2	552-1
E2		sequential	E2	553-1
E2		sequential	E2	554-1
Lemma		sequential	5.3.12	555-1
Crux		sequential	Let	556-1
Let		sequential	q	556-1
q	{	sequential	x1	556-1
<B>	.	sequential	<B>	556-2
<B>	.	sequential	<B>	556-3
xn	be	attribute	a calculus query	556-4
a calculus query	over	constraint	R	556-4
an inductive construction	Next is performed	action	<B>	557-1
<B>	To	constraint	each subformula ψ	557-2
each subformula ψ		sequential	y1	557-2
<B>	.	sequential	<B>	557-3
<B>	.	sequential	<B>	557-4
<B>	of	constraint	an algebra expression Eψ	557-5
<B>	associates	action	an algebra expression Eψ	557-5
an algebra expression Eψ	with	constraint	the property	557-5
the property		sequential	that	557-5
that	abusing slightly	action	notation	557-5
We	now illustrate Eψ	action	a few cases	558-1
a few cases	of	constraint	the construction	558-1
the construction	of	constraint	expressions	558-1
expressions	and	conjunctive	the rest	558-1
expressions	leave	action	the rest	558-1
the rest	for	constraint	the reader	558-1
the reader	see	action	Exercise 5.13 b	558-1
<B>	that	constraint	ψ	558-2
<B>	Suppose	action	ψ	558-2
ψ	is	attribute	a subformula of	558-2
Eψ	in	constraint	the following manner	558-3
Eψ	Then is constructed	action	the following manner	558-3
the following manner		sequential	k F	558-3
k F		sequential	R	558-3
R	and	conjunctive	F	558-3
R	$ k	sequential	F	558-3
F	in	constraint	accordance	558-3
F	where are chosen	action	accordance	558-3
accordance	with	constraint	<B>	558-3
accordance	and	conjunctive	<B>	558-3
accordance	$ y	sequential	<B>	558-3
accordance	$ t	sequential	<B>	558-3
Syntactic Restrictions	for	constraint	Domain Independence	559-1
Several criteria	affect	action	the development	560-1
the development	of	constraint	these conditions	560-1
these conditions	including	action	their generality	560-1
their generality		sequential	their simplicity	560-1
their simplicity	and	conjunctive	the ease	560-1
the ease	with	constraint	which	560-1
which		sequential	queries	560-1
queries	satisfying	action	the conditions	560-1
the conditions	into	constraint	the relational algebra	560-1
the conditions	can be translated	action	the relational algebra	560-1
the relational algebra	or	conjunctive	lower level	560-1
lower level		sequential	other representations	560-1
We	present here	action	one such condition	560-2
one such condition	called	action	safe range	560-2
safe range	but	conjunctive	the flavor	560-2
safe range	is	attribute	relatively simple	560-2
safe range	illustrates	action	the flavor	560-2
the flavor	and	conjunctive	theoretical properties	560-2
theoretical properties	of	constraint	these conditions	560-2
theoretical properties	of	constraint	these conditions	560-2
It	as	constraint	a vehicle	560-3
It	will serve	action	a vehicle	560-3
a vehicle	to	constraint	one approach	560-3
a vehicle	illustrate	action	one approach	560-3
one approach	to	constraint	these restricted queries	560-3
one approach	translating	action	these restricted queries	560-3
these restricted queries	into	constraint	the algebra	560-3
Other examples	in	constraint	Exercises 5.25	560-4
Other examples	are explored	action	Exercises 5.25	560-4
Exercises 5.25	and	conjunctive	5.26	560-4
5.26		sequential	translations	560-4
translations	of	constraint	the algebra	560-4
translations	into	constraint	the algebra	560-4
the algebra	are	attribute	considerably more involved	560-4
This section	with	constraint	a brief digression	561-1
This section	begins	action	a brief digression	561-1
a brief digression	concerning	action	equivalence	561-1
equivalence	preserving	action	rewrite rules	561-1
rewrite rules	for	constraint	the calculus	561-1
the family CALCsr	of	constraint	range	561-2
range		sequential	queries	561-2
queries	Next is introduced	action	<B>	561-2
It	that	constraint	the algebra	561-3
It	is shown easily	action	the algebra	561-3
the algebra		sequential	CALCsr	561-3
A rather involved construction	for	constraint	range	561-4
A rather involved construction	is presented	attribute	safe	561-4
A rather involved construction	transforming	attribute	safe	561-4
range		sequential	queries	561-4
queries	into	constraint	the algebra	561-4
The section	by	constraint	a variant	561-5
The section	concludes	action	a variant	561-5
The section	defining	action	a variant	561-5
a variant	of	constraint	the calculus	561-5
the calculus		sequential	that	561-5
that	to	constraint	the conjunctive queries	561-5
that	is	attribute	equivalent	561-5
the conjunctive queries	with	constraint	union	561-5
y	in	constraint	y	562-1
y	in	constraint	Figure	562-1
y	y	attribute	ϕ not free ϕ	562-1
Figure		sequential	5.1	562-1
5.1		sequential	Equivalence	562-1
Equivalence	preserving	action	rewrite rules	562-1
rewrite rules	for	constraint	calculus formulas Equivalence	562-1
calculus formulas Equivalence	Preserving	action	Rewrite Rules	562-1
<B>	preserve	action	equivalence	562-2
equivalence	of	constraint	the underlying domain	562-2
the underlying domain	to	constraint	calculus queries	562-2
the underlying domain	used	action	calculus queries	562-2
the underlying domain	evaluate	action	calculus queries	562-2
<B>	of	constraint	these rules	563-1
these rules	in	constraint	the transformation	563-1
these rules	will be used	action	the transformation	563-1
the transformation	of	constraint	range	563-1
range		sequential	queries	563-1
queries	into	constraint	the algebra	563-1
Calculus formulas		sequential	ψ	564-1
ψ	over	constraint	schema R	564-1
schema R	are	attribute	equivalent	564-1
schema R	denoted	action	ψ	564-1
ψ	if	constraint	I	564-1
ψ	for	constraint	I	564-1
I	over	constraint	each R	564-1
each R		sequential	d ⊆	564-1
d ⊆		sequential	dom	564-1
dom	and	conjunctive	valuation	564-1
valuation		sequential	ν	564-1
ν	with	constraint	range	564-1
range		sequential	⊆ d	564-1
⊆ d		sequential	I	564-1
I	|=d∪	action	adom	564-1
adom		sequential	I	564-1
I		sequential	ν	564-1
ν	if	constraint	I	564-1
ν	if	constraint	I	564-1
ν	and	conjunctive	I	564-1
I	|=d∪	action	adom	564-1
adom		sequential	ψ	564-1
ψ		sequential	I	564-1
I		sequential	ψ	564-1
ψ		sequential	ν	564-1
Figure		sequential	5.1	565-1
5.1	shows	action	a number	565-1
a number	of	constraint	rewrite rules	565-1
a number	equivalence preserving	action	rewrite rules	565-1
rewrite rules	for	constraint	calculus formulas	565-1
It	to	constraint	ψ	565-2
It	that	constraint	ψ	565-2
It	if	constraint	ψ	565-2
It	is	attribute	straightforward	565-2
It	verify	action	ψ	565-2
ψ	to	constraint	ψ′	565-2
ψ	transforms	action	ψ′	565-2
ψ′	by	constraint	a rewrite rule	565-2
a rewrite rule	if	constraint	ϕ′	565-2
a rewrite rule	and	conjunctive	ϕ′	565-2
ϕ′	is	attribute	the result	565-2
the result	of	constraint	an occurrence	565-2
the result	replacing	action	an occurrence	565-2
an occurrence	of	constraint	subformula ψ	565-2
subformula ψ	of	constraint	formula	565-2
subformula ψ	by	constraint	formula	565-2
formula	≡	sequential	<B>	565-2
<B>	that	constraint	x ∈	566-1
<B>	Note	action	x ∈	566-1
<B>	assuming	action	x ∈	566-1
x ∈		sequential	ψ	566-1
ψ	and	conjunctive	y	566-1
y		sequential	∈	566-1
∈		sequential	ϕ	566-1
Example		sequential	5.4.1 Recall	567-1
5.4.1 Recall	from	constraint	Chapter 2	567-1
Chapter 2	that	constraint	a formula	567-1
a formula	in	constraint	prenex normal form	567-1
a formula	is	attribute	prenex normal form	567-1
prenex normal form		sequential	PNF	567-1
PNF	if	constraint	it	567-1
it	has	action	the form % 1x1	567-1
<B>	.	sequential	<B>	567-2
<B>	.	sequential	<B>	567-3
<B>	%	sequential	i	567-4
<B>	each %	sequential	i	567-4
i	either	conjunctive	no quantifiers	567-4
i	or	conjunctive	no quantifiers	567-4
i	and	conjunctive	no quantifiers	567-4
i	is	attribute	no quantifiers	567-4
no quantifiers	in	constraint	ψ	567-4
no quantifiers	occur	action	ψ	567-4
<B>	In	constraint	this case	567-5
this case		sequential	ψ	567-5
ψ	is called	action	the matrix	567-5
the matrix	of	constraint	formula	567-5
It	is easily verified	action	Exercise 5.14	568-1
It	see	action	Exercise 5.14	568-1
Exercise 5.14	that	constraint	the rewrite rules	568-1
the rewrite rules	to	constraint	an arbitrary calculus formula	568-1
the rewrite rules	can be used	action	an arbitrary calculus formula	568-1
the rewrite rules	transform	action	an arbitrary calculus formula	568-1
an arbitrary calculus formula	into	constraint	an equivalent formula	568-1
an equivalent formula		sequential	that	568-1
that	in	constraint	PNF	568-1
that	is	attribute	PNF	568-1
PNF	with	constraint	a CNF matrix	568-1
a CNF matrix	into	constraint	an equivalent formula	568-1
a CNF matrix	and	conjunctive	an equivalent formula	568-1
an equivalent formula		sequential	that	568-1
that	in	constraint	PNF	568-1
that	is	attribute	PNF	568-1
PNF	with	constraint	a DNF matrix	568-1
Safe Range		sequential	Queries	569-1
<B>	During	constraint	this development	570-1
this development		sequential	it	570-1
it	to	constraint	calculus formulas	570-1
it	of	constraint	calculus formulas	570-1
it	is	attribute	sometimes useful	570-1
it	speak	action	calculus formulas	570-1
calculus formulas	in	constraint	terms	570-1
terms	of	constraint	their parse trees	570-1
<B>	For	constraint	example	570-2
example		sequential	we	570-2
we	that	constraint	the formula ∧	570-2
we	will say	action	the formula ∧	570-2
the formula ∧		sequential	R	570-2
R		sequential	x	570-2
x		sequential	∃y	570-2
∃y		sequential	S	570-2
S		sequential	y	570-2
y		sequential	z	570-2
z		sequential	∧	570-2
The normalization	of	constraint	formulas	571-1
formulas	puts	action	them	571-1
them	into	constraint	a form	571-1
a form	for	constraint	safety	571-1
a form	more easily analyzed	action	safety	571-1
safety	without	constraint	their syntactic structure	571-1
safety	substantially changing	action	their syntactic structure	571-1
equivalence	preserving	action	The following rewrite rules	571-2
The following rewrite rules	to	constraint	a formula	571-2
The following rewrite rules	are used	action	a formula	571-2
The following rewrite rules	place	action	a formula	571-2
a formula	into	constraint	safe range	571-2
safe range		sequential	normal form	571-2
normal form		sequential	SRNF	571-2
SRNF		sequential	Variable substitution	571-2
It	until	constraint	no distinct pair	571-3
It	is applied	action	no distinct pair	571-3
no distinct pair	of	constraint	quantifiers	571-3
quantifiers	binds	action	the same variable	571-3
the same variable	and	conjunctive	no variable	571-3
no variable	both	conjunctive	<B>	571-3
no variable	and	conjunctive	<B>	571-3
no variable	occurs	attribute	free	571-3
<B>	Remove	action	universal quantifiers	572-1
universal quantifiers	Replace	action	subformula	572-1
subformula	by	constraint	<B>	572-1
subformula	$ xψ	sequential	<B>	572-1
subformula	¬∃	sequential	<B>	572-1
subformula	$ x¬ψ	sequential	<B>	572-1
<B>	and	conjunctive	the next condition	572-2
the next condition	can be relaxed	action	Example 5.4.5	572-2
the next condition	see	action	Example 5.4.5	572-2
<B>	Remove	action	implications	573-1
implications	Replace	action	ψ	573-1
ψ	→	sequential	ξ	573-1
ξ	by	constraint	¬ψ	573-1
¬ψ		sequential	ξ	573-1
ξ	for	constraint	<B>	573-1
ξ	and	conjunctive	<B>	573-1
<B>	Push	action	negations	574-1
<B>	and	conjunctive	existential quantifiers	575-1
<B>	or	conjunctive	existential quantifiers	575-1
<B>	and	conjunctive	existential quantifiers	575-1
<B>	Flatten	attribute	s	575-1
The SRNF formula	from	constraint	these rules	576-1
The SRNF formula	resulting	action	these rules	576-1
The SRNF formula	applying	action	these rules	576-1
these rules	to	constraint	SRNF	576-1
these rules	is denoted	action	SRNF	576-1
SRNF		sequential	ϕ	576-1
A formula		sequential	query	576-2
query	{	sequential	}	576-2
query	$ e	sequential	}	576-2
query	ϕ	sequential	}	576-2
}	in	constraint	SRNF	576-2
}	is	attribute	SRNF	576-2
SRNF	if	constraint	SRNF	576-2
SRNF		sequential	ϕ	576-2
ϕ	=	sequential	<B>	576-2
Example		sequential	5.4.2	577-1
The second calculus query	in	constraint	not SRNF	577-2
The second calculus query	is	attribute	not SRNF	577-2
not SRNF		sequential	the corresponding SRNF query	577-2
the corresponding SRNF query	is	attribute	<B>	577-2
<B>	Transforming	action	the query	578-1
the query	of	constraint	Example 5.3.2	578-1
Example 5.3.2	into	constraint	SRNF yields	578-1
We	now present	action	a syntactic condition	579-1
a syntactic condition	on	constraint	SRNF formulas	579-1
SRNF formulas		sequential	that	579-1
that	that	constraint	each variable	579-1
that	ensures	action	each variable	579-1
each variable	is	attribute	range	579-1
range	in	constraint	the sense	579-1
range	restricted	action	the sense	579-1
the sense	that	constraint	its possible values all	579-1
its possible values all	within	constraint	the active domain	579-1
its possible values all	lie	action	the active domain	579-1
the active domain	of	constraint	the formula	579-1
the formula	or	conjunctive	the input	579-1
<B>	If	constraint	a quantified variable	579-2
a quantified variable		sequential	range	579-2
range	if	constraint	one	579-2
range	or	conjunctive	one	579-2
range	is not restricted	action	one	579-2
one	of	constraint	the free variables	579-2
the free variables		sequential	range	579-2
range	is not restricted	action	the associated query	579-2
the associated query	is rejected	action	<B>	579-2
<B>	To	constraint	the definition	579-3
<B>	make	action	the definition	579-3
the definition		sequential	we	579-3
we	first define	action	the set	579-3
the set	of	constraint	range	579-3
range	restricted	action	variables	579-3
variables	of	constraint	an SRNF formula	579-3
an SRNF formula	using	action	the following procedure	579-3
the following procedure		sequential	which	579-3
which	either	conjunctive	the symbol ⊥	579-3
which	returns	action	the symbol ⊥	579-3
the symbol ⊥	that	constraint	some quantified variable	579-3
the symbol ⊥	indicating	action	some quantified variable	579-3
some quantified variable		sequential	range	579-3
range	or	conjunctive	the set	579-3
range	is not restricted	action	the set	579-3
the set	of	constraint	free variables	579-3
free variables		sequential	that	579-3
that		sequential	range	579-3
range	is restricted	action	<B>	579-3
Input		sequential	a calculus formula	580-1
a calculus formula	in	constraint	SRNF Output	580-1
SRNF Output		sequential	a subset	580-1
a subset	of	constraint	the free variables	580-1
the free variables	of	constraint	or3	580-1
or3	begin	action	case	580-1
case	of	constraint	R	580-1
R		sequential	e1	580-1
<B>	.	sequential	<B>	580-2
<B>	.	sequential	<B>	580-3
en		sequential	rr	580-4
rr	ϕ =	sequential	the set	580-4
the set	of	constraint	variables	580-4
variables	in	constraint	e1	580-4
variables	{	sequential	e1	580-4
<B>	.	sequential	<B>	580-5
<B>	.	sequential	<B>	580-6
en }		sequential	x	580-7
x	=	sequential	a	580-7
a	or	conjunctive	a	580-7
a	=	sequential	x	580-7
x		sequential	rr	580-7
rr		sequential	ϕ	580-7
ϕ	=	sequential	}	580-7
ϕ	{	sequential	}	580-7
ϕ	x	sequential	}	580-7
}		sequential	rr	580-7
rr		sequential	ψ	580-7
ψ	if	constraint	x	580-7
x		sequential	y	580-7
y		sequential	}	580-7
}		sequential	∩	580-7
∩		sequential	rr	580-7
rr		sequential	ψ	580-7
ψ	=	sequential	∅	580-7
∅		sequential	rr	580-7
rr		sequential	ψ	580-7
ψ		sequential	∪	580-7
∪		sequential	x	580-7
x		sequential	y	580-7
y		sequential	} otherwise	580-7
} otherwise		sequential	ϕ1	580-7
ϕ1	if	constraint	rr	580-7
ϕ1	$ x ⊆	sequential	rr	580-7
rr	ϕ	sequential	1	580-7
1		sequential	rr	580-7
rr		sequential	ϕ	580-7
ϕ	=	sequential	rr	580-7
rr	ϕ	sequential	else return	580-7
rr	1 $ x	sequential	else return	580-7
else return		sequential	end	580-7
end		sequential	case end x	580-7
case end x	to	constraint	the set	580-7
case end x	denote	action	the set	580-7
the set	of	constraint	variables	580-7
variables	in	constraint	<B>	580-7
variables	$ x	sequential	<B>	580-7
variables	occurring	action	<B>	580-7
<B>		sequential	the occurrence	581-1
the occurrence	of	constraint	a variable x	581-1
a variable x	in	constraint	a base relation	581-1
a base relation	in	constraint	an atom	581-1
a base relation	or	conjunctive	an atom	581-1
an atom	of	constraint	the form	581-1
the form		sequential	x	581-1
x	=	sequential	that	581-1
x	a restricts	action	that	581-1
that		sequential	<B>	581-1
This restriction	through	constraint	∧	581-2
This restriction	is propagated	action	∧	581-2
∧	in	constraint	∨	581-2
∧	possibly lost	action	∨	581-2
∨	in	constraint	<B>	581-2
∨	and	conjunctive	<B>	581-2
∨	always lost	action	<B>	581-2
<B>	In	constraint	addition	581-3
addition		sequential	each quantified variable	581-3
each quantified variable	by	constraint	the subformula	581-3
each quantified variable	must be restricted	action	the subformula	581-3
the subformula		sequential	it	581-3
it	in	constraint	<B>	581-3
it	occurs	action	<B>	581-3
Example 5.4.4 Recall		sequential	Examples 5.3.1	582-1
Examples 5.3.1	and	conjunctive	5.4.2	582-1
The first query	of	constraint	Example 5.3.1	582-2
Example 5.3.1	is	attribute	safe range	582-2
The first query	of	constraint	Example 5.4.2	582-3
Example 5.4.2	is	attribute	also safe range	582-3
<B>		sequential	the second query	582-4
the second query	of	constraint	Example 5.4.2	582-4
Example 5.4.2	because	constraint	the free variable xt	582-4
Example 5.4.2	is	attribute	the free variable xt	582-4
the free variable xt		sequential	range	582-4
range	by	constraint	the formula	582-4
range	not is not restricted	action	the formula	582-4
<B>	Before	constraint	we	583-1
<B>	continuing	action	we	583-1
we	explore	action	a generalization	583-1
a generalization	of	constraint	the notion	583-1
the notion	of	constraint	safe range	583-1
safe range	to	constraint	universal quantification	583-1
safe range	permit	action	universal quantification	583-1
Example		sequential	5.4.5	584-1
<B>	into	constraint	SRNF	584-2
<B>	Transforming	action	SRNF	584-2
SRNF	that	constraint	the parent	584-2
SRNF	and	conjunctive	the parent	584-2
SRNF	assuming	action	the parent	584-2
the parent	of	constraint	ψ	584-2
ψ	is	attribute	not ¬	584-2
we	obtain	action	x	584-2
x	ψ	sequential	1	584-2
1	$ x	sequential	∧	584-2
∧	¬	sequential	ψ2	584-2
ψ2	$ y	sequential	<B>	584-2
rr	Now ψ′ is defined iff	action	<B>	585-1
<B>	In	constraint	this case	586-1
this case		sequential	rr	586-1
rr		sequential	ψ′	586-1
ψ′	=	sequential	<B>	586-1
<B>	by	constraint	the second query	586-2
<B>	is illustrated	action	the second query	586-2
the second query	of	constraint	Example 5.3.1	586-2
Example 5.3.1	into	constraint	SRNF	586-2
Example 5.3.1	was transformed	action	SRNF	586-2
SRNF	in	constraint	Example 5.4.2	586-2
SRNF	to	constraint	subformulas	587-1
SRNF	Thus can be extended	action	subformulas	587-1
SRNF	permit	action	subformulas	587-1
subformulas		sequential	that	587-1
that	have	action	the form	587-1
the form	of	constraint	ψ	587-1
ψ	without	constraint	the development	587-1
ψ	materially affecting	action	the development	587-1
The calculus query	in	constraint	the proof	588-1
The calculus query	constructed	action	the proof	588-1
the proof	of	constraint	Lemma 5.3.11	588-1
Lemma 5.3.11	in	constraint	fact	588-1
Lemma 5.3.11	is	attribute	fact	588-1
fact		sequential	safe range	588-1
It	that	constraint	the algebra	588-2
It	thus follows	action	the algebra	588-2
the algebra		sequential	CALCsr	588-2
The development here	that	constraint	CALCsr	589-1
The development here	of	constraint	CALCsr	589-1
The development here	implies	attribute	all	589-1
CALCsr		sequential	CALCdi	589-1
CALCdi	and	conjunctive	CALC adom	589-1
CALC adom	are	attribute	equivalent	589-1
the particular choice	to	constraint	the discussion	589-2
the particular choice	is	attribute	When irrelevant	589-2
the discussion		sequential	we	589-2
we	use	action	the term relational calculus	589-2
the term relational calculus	to	constraint	these three equivalent query languages	589-2
the term relational calculus	to	constraint	these three equivalent query languages	589-2
the term relational calculus	of	constraint	these three equivalent query languages	589-2
the term relational calculus	refer	attribute	any	589-2
<B>	From	constraint	Safe Range	590-1
Safe Range	to	constraint	the Algebra	590-1
<B>	Speaking loosely	action	this translation	590-2
this translation	in	constraint	the sense	590-2
this translation	is	attribute	relatively direct	590-2
the sense	that	constraint	the algebra query E	590-2
the algebra query E	for	constraint	calculus query q	590-2
the algebra query E	constructed	action	calculus query q	590-2
calculus query q	largely follows	action	the structure	590-2
the structure	of	constraint	q	590-2
<B>	As	constraint	a result	590-3
a result		sequential	evaluation	590-3
evaluation	of	constraint	E	590-3
E	in	constraint	most cases	590-3
most cases	than	constraint	the algebra query	590-3
most cases	be	attribute	will more efficient	590-3
most cases	using	action	the algebra query	590-3
the algebra query		sequential	that	590-3
that	for	constraint	q	590-3
that	is constructed	action	q	590-3
q	by	constraint	the proof	590-3
the proof	of	constraint	Lemma 5.3.12	590-3
Examples	of	constraint	the construction	591-1
the construction	after	constraint	the formal argument	591-1
the construction	used	action	the formal argument	591-1
the construction	are presented	action	the formal argument	591-1
Theorem CALCsr		sequential	5.4.6	592-1
5.4.6	≡	constraint	the relational algebra	592-1
<B>		sequential	range	592-2
range		sequential	each query	592-2
each query	is	attribute	domain	592-2
domain		sequential	<B>	592-2
The proof	of	constraint	this theorem	593-1
this theorem	involves	action	several steps	593-1
<B>	As	constraint	the algebra	593-2
<B>	seen earlier	action	the algebra	593-2
the algebra		sequential	CALCsr	593-2
<B>	To	constraint	the other direction	593-3
<B>	prove	action	the other direction	593-3
the other direction		sequential	we	593-3
we	develop	action	a translation	593-3
a translation	from	constraint	range	593-3
range		sequential	queries	593-3
queries	into	constraint	the named algebra	593-3
<B>	Because	constraint	the algebra	593-4
the algebra	is	attribute	domain	593-4
domain	will also imply	action	the second sentence	593-4
the second sentence	of	constraint	the theorem	593-4
<B>	To	constraint	ϕ	594-1
<B>	begin	action	ϕ	594-1
<B>	let	action	ϕ	594-1
ϕ	be	attribute	safe range	594-1
safe range		sequential	a formula	594-1
a formula	in	constraint	SRNF	594-1
An occurrence	of	constraint	a subformula ψ in	594-2
a subformula ψ in	is	attribute	self	594-2
self	if	constraint	its root	594-2
self	contained	action	its root	594-2
its root	is	attribute	∧	594-2
∧	if	constraint	xψ1	594-2
∧	or	conjunctive	xψ1	594-2
xψ1	and	conjunctive	rr	594-2
rr		sequential	ψ	594-2
ψ	=	sequential	1	594-2
ψ	ψ	sequential	1	594-2
1	or	conjunctive	<B>	594-2
<B>	if	constraint	ψ	595-1
ψ	is	attribute	self	595-1
self	contained	action	a subformula	595-1
a subformula	of	constraint	that	595-1
that	does not have	action	∧	595-1
∧	as	constraint	a root	595-1
a root		sequential	all free variables	595-1
all free variables	in	constraint	ψ	595-1
ψ		sequential	range	595-1
range	within	constraint	ψ	595-1
range	Intuitively are restricted	action	ψ	595-1
<B>	As	constraint	we	595-2
we	if	constraint	RANF	595-2
we	in	constraint	RANF	595-2
we	shall see	attribute	ϕ	595-2
we	is	attribute	RANF	595-2
RANF	permits	action	construction	595-2
construction	of	constraint	an equivalent relational algebra query Eϕ	595-2
an equivalent relational algebra query Eϕ	using	action	an induction	595-2
an induction	from	constraint	leaf	595-2
leaf	to	constraint	root	595-2
We	now develop	action	an algorithm	596-1
an algorithm		sequential	RANF ALG	596-1
RANF ALG		sequential	that	596-1
that	transforms	attribute	safe	596-1
range		sequential	SRNF formulas	596-1
SRNF formulas	into	constraint	RANF	596-1
It	on	constraint	the following rewrite rules where	596-2
It	is based	action	the following rewrite rules where	596-2
<B>	that	constraint	rr	597-1
<B>	Suppose	action	rr	597-1
rr		sequential	ψ	597-1
ψ	=	sequential	ψ	597-1
ψ	but	conjunctive	rr	597-1
rr	ξ	sequential	1	597-1
1		sequential	∨ ξm	597-1
∨ ξm	=	sequential	1	597-1
∨ ξm	ξ	sequential	1	597-1
1		sequential	∨	597-1
∨		sequential	ξm	597-1
<B>	Nondeterministically choose	action	a subset i1	597-2
<B>	.	sequential	<B>	597-3
<B>	.	sequential	<B>	597-4
ik	of	constraint	1	597-5
<B>	.	sequential	<B>	597-6
<B>	.	sequential	<B>	597-7
<B>	that	constraint	′	597-8
<B>	n	conjunctive	′	597-8
′	=	sequential	1 ∧	597-8
′	ξ	sequential	1 ∧	597-8
1 ∧		sequential	∧	597-8
∧		sequential	∧	597-8
∧		sequential	ψ	597-8
ψ		sequential	∨	597-8
∨		sequential	ξ ik m ∧	597-8
ξ ik m ∧		sequential	ψi1	597-8
<B>	satisfies	action	rr	598-1
rr		sequential	ξ	598-1
ξ		sequential	′	598-1
′	=	sequential	ξ	598-1
ξ		sequential	′	598-1
One choice	of	constraint	i1	598-2
<B>	.	sequential	<B>	598-3
<B>	.	sequential	<B>	598-4
ik	to	constraint	1	598-5
ik	of	constraint	1	598-5
ik	is	attribute	all	598-5
ik	use	attribute	all	598-5
<B>	.	sequential	<B>	598-6
<B>	.	sequential	<B>	598-7
<B>	n	conjunctive	a formula	598-8
<B>	necessarily yields	action	a formula	598-8
a formula		sequential	′	598-8
′	with	constraint	this property	598-8
<B>	Letting	action	j1	598-9
<B>	.	sequential	<B>	598-10
<B>	.	sequential	<B>	598-11
jl }	=	sequential	1	598-12
jl }	{	sequential	1	598-12
<B>	.	sequential	<B>	598-13
<B>	.	sequential	<B>	598-14
<B>	n	conjunctive	}	598-15
jl		sequential	jl	599-1
The rewrite rule	to	constraint	subformula ψ	599-2
The rewrite rule	is	attribute	subformula ψ	599-2
The rewrite rule	replace	action	subformula ψ	599-2
subformula ψ	by	constraint	ψ ′	599-2
ψ ′	and	conjunctive	SRNF	599-2
ψ ′	possibly apply	action	SRNF	599-2
SRNF	to	constraint	an ∨	599-2
SRNF	flatten	action	an ∨	599-2
an ∨	if	constraint	both l	599-2
both l	=	sequential	0	599-2
0	and	conjunctive	the parent	599-2
the parent	of	constraint	ψ	599-2
ψ	is	attribute	∨	599-2
xξ		sequential	rr	600-1
rr		sequential	ψ	600-1
ψ	where =	sequential	ψ	600-1
ψ	but	conjunctive	rr	600-1
rr		sequential	ξ	600-1
ξ	=	sequential	ξ	600-1
<B>	Then replace	action	ψ	600-2
ψ	by	constraint	ψ	600-2
ψ		sequential	′	600-2
′	=	sequential	SRNF	600-2
SRNF		sequential	ψj	600-2
ψj		sequential	∧	600-2
∧	·	sequential	∧	600-2
∧		sequential	ψ	600-2
ψ		sequential	∧	600-2
∧	∃	sequential	jl where	600-2
∧	$ xξ ′	sequential	jl where	600-2
jl where		sequential	ik	600-2
xξ		sequential	rr	601-1
rr		sequential	ψ	601-1
ψ	where =	sequential	ψ	601-1
ψ	but	conjunctive	rr	601-1
rr		sequential	ξ	601-1
ξ	=	sequential	ξ	601-1
<B>	Then replace	action	ψ	601-2
ψ	by	constraint	ψ	601-2
ψ		sequential	′	601-2
′	=	sequential	SRNF	601-2
SRNF		sequential	ψ	601-2
ψ		sequential	1	601-2
1		sequential	∧	601-2
∧	·	sequential	∧	601-2
∧	·	sequential	∧	601-2
∧	ψn	conjunctive	∧	601-2
∧	¬∃	sequential	ik	601-2
∧	$ xξ ′	sequential	ik	601-2
ik	from	constraint	the observation	601-2
ik	where follows	action	the observation	601-2
the observation	that	constraint	the propositional p	601-2
the propositional p		sequential	formulas ∧ q	601-2
formulas ∧ q		sequential	∧ ¬r	601-2
∧ ¬r	and	conjunctive	p	601-2
p		sequential	∧ q	601-2
∧ q		sequential	∧	601-2
The algorithm		sequential	RANF ALG	602-1
RANF ALG	for	constraint	these rewrite rules	602-1
RANF ALG	applying	action	these rewrite rules	602-1
these rewrite rules	and	conjunctive	<B>	602-1
these rewrite rules	is	attribute	top	602-1
We	sketch now	action	the algorithm	602-2
the algorithm	see	action	Exercise 5.19	602-2
Output		sequential	a RANF formula ϕ′ RANF	603-1
a RANF formula ϕ′ RANF	to	constraint	some subformula ψ	603-1
a RANF formula ϕ′ RANF	while	constraint	some subformula ψ	603-1
a RANF formula ϕ′ RANF	begin	action	some subformula ψ	603-1
some subformula ψ	with	constraint	its conjuncts	603-1
its conjuncts	of	constraint	the premise	603-1
its conjuncts	possibly reordered	action	the premise	603-1
its conjuncts	satisfies	action	the premise	603-1
the premise	of	constraint	R1	603-1
R1		sequential	R2	603-1
R2	or	conjunctive	R3 do	603-1
R3 do		sequential	case R1	603-1
case R1	as	constraint	exercise	603-1
case R1	left	action	exercise	603-1
exercise		sequential	R2	603-1
R2	as	constraint	exercise	603-1
R2	left	action	exercise	603-1
exercise		sequential	R3	603-1
R3	Let	action	ψ	603-1
ψ	=	sequential	ψ	603-1
ψ		sequential	1	603-1
1		sequential	∧	603-1
∧		sequential	∧	603-1
∧		sequential	¬∃	603-1
¬∃	$ xξ ik ik	sequential	xβ	603-1
xβ		sequential	end case end	603-1
end case end	while	constraint	The proof	603-1
end case end	end	action	The proof	603-1
The proof	that	constraint	these rewrite rules	603-1
these rewrite rules	to	constraint	safe range	603-1
these rewrite rules	can be used	action	safe range	603-1
these rewrite rules	transform	action	safe range	603-1
safe range		sequential	a SRNF formula	603-1
a SRNF formula	into	constraint	a RANF formula	603-1
a RANF formula	has	action	two steps	603-1
two steps	see	action	Exercise 5.19	603-1
a case analysis	to	constraint	safe range	603-2
a case analysis	that	constraint	safe range	603-2
a case analysis	if	constraint	safe range	603-2
a case analysis	First can be used	action	safe range	603-2
a case analysis	show	action	safe range	603-2
safe range	in	constraint	SRNF	603-2
SRNF	in	constraint	not RANF	603-2
SRNF	is	attribute	not RANF	603-2
not RANF		sequential	one	603-2
one	of	constraint	the rewrite rules	603-2
the rewrite rules		sequential	R1	603-2
R1		sequential	R2	603-2
R2		sequential	R3	603-2
R3	can be applied	action	<B>	603-2
it	that	constraint	Algorithm 5.4.7	603-3
it	Second is shown	action	Algorithm 5.4.7	603-3
Algorithm 5.4.7	terminates	action	<B>	603-3
<B>	by	constraint	each successfully completed call	604-1
<B>	that	constraint	each successfully completed call	604-1
<B>	is accomplished	action	each successfully completed call	604-1
<B>	showing	action	each successfully completed call	604-1
each successfully completed call	to	constraint	RANF ALG	604-1
RANF ALG	1 reduces	action	the number	604-1
the number	of	constraint	subformulas	604-1
the number	non-self contained	action	subformulas	604-1
subformulas	if	constraint	a call	604-1
subformulas	and	conjunctive	a call	604-1
a call	to	constraint	RANF	604-1
RANF		sequential	ALG	604-1
ALG	on	constraint	ψ	604-1
ψ	invokes	action	other calls	604-1
other calls	to	constraint	RANF	604-1
RANF		sequential	ALG	604-1
ALG		sequential	the input	604-1
the input	to	constraint	these recursive calls	604-1
these recursive calls	2 has	action	fewer subformulas	604-1
these recursive calls	contained	action	fewer subformulas	604-1
fewer subformulas	than	constraint	ψ	604-1
fewer subformulas	does	action	ψ	604-1
We	to	constraint	the transformation	605-1
We	now turn	action	the transformation	605-1
the transformation	of	constraint	RANF formulas	605-1
RANF formulas	into	constraint	equivalent relational algebra queries	605-1
We	abuse somewhat	action	notation	605-2
notation	that	constraint	each variable	605-2
notation	and	conjunctive	each variable	605-2
notation	assume	action	each variable	605-2
each variable	is	attribute	also an attribute	605-2
<B>	Let	action	RANF formula	606-1
RANF formula	ϕ be fixed	action	<B>	606-1
The construction	of	constraint	Eϕ	606-2
Eϕ	from	constraint	leaf	606-2
Eϕ	is	attribute	inductive	606-2
leaf	to	constraint	root	606-2
root	in	constraint	the following algorithm	606-2
root	and	conjunctive	the following algorithm	606-2
root	is sketched	action	the following algorithm	606-2
The special operator diff	on	constraint	inputs	606-3
inputs		sequential	R	606-3
R	and	conjunctive	S	606-3
S		sequential	att	606-3
att		sequential	S	606-3
S		sequential	where ⊂	606-3
where ⊂		sequential	att	606-3
att		sequential	R	606-3
R	by	constraint	R diff	606-3
R	is defined	action	R diff	606-3
R diff		sequential	S	606-3
S	=	sequential	R −	606-3
R −		sequential	R	606-3
R	⊲⊳	sequential	S	606-3
k	and	conjunctive	selection formula	607-1
selection formula		sequential	F	607-1
F	in	constraint	the first entry	607-1
the first entry	of	constraint	the case statement	607-1
the case statement	to	constraint	the reader	607-1
the case statement	are left	action	the reader	607-1
the reader	see	action	Example 5.4.9	607-1
Example 5.4.9	and	conjunctive	Exercise 5.19	607-1
Input		sequential	a formula	608-1
a formula	in	constraint	modified RANF Output	608-1
modified RANF Output		sequential	an algebra query Eϕ	608-1
an algebra query Eϕ	to	constraint	case ϕ	608-1
an algebra query Eϕ	begin	action	case ϕ	608-1
case ϕ	of	constraint	R k F	608-1
case ϕ	$ e	sequential	R k F	608-1
R k F		sequential	R	608-1
R		sequential	x	608-1
x	=	sequential	a	608-1
a	if	constraint	ξ	608-1
ξ	is	attribute	x	608-1
x	=	sequential	x	608-1
x		sequential	Eψ	608-1
Eψ	if	constraint	ξ	608-1
ξ		sequential	x	608-1
x	is =	sequential	y	608-1
y	with	constraint	x	608-1
x	if	constraint	ξ	608-1
x	y	conjunctive	ξ	608-1
ξ	is	attribute	x	608-1
x	=	sequential	y	608-1
y		sequential	σx=y	608-1
σx=y		sequential	Eψ	608-1
Eψ	if	constraint	ξ	608-1
ξ	=	sequential	¬ξ ′	608-1
¬ξ ′		sequential	Eψ diff Eξ′	608-1
Eψ diff Eξ′	if	constraint	ξ	608-1
ξ		sequential	′	608-1
′		sequential	⊂	608-1
⊂		sequential	ψ	608-1
<B>	.	sequential	<B>	608-2
<B>	.	sequential	<B>	608-3
xn	be	attribute	safe range	608-4
<B>	Because	constraint	the transformations	608-5
the transformations	for	constraint	SRNF	608-5
the transformations	used	action	SRNF	608-5
SRNF	and	conjunctive	RANF	608-5
RANF	are	attribute	equivalence	608-5
equivalence	without	constraint	loss	608-5
equivalence	preserving	action	loss	608-5
loss	of	constraint	generality	608-5
generality		sequential	we	608-5
we	that	constraint	modified RANF	608-5
we	in	constraint	modified RANF	608-5
we	is	attribute	modified RANF	608-5
we	can assume	action	modified RANF	608-5
<B>	To	constraint	the proof	608-6
<B>	conclude	action	the proof	608-6
the proof	of	constraint	Theorem 5.4.6	608-6
Theorem 5.4.6		sequential	it	608-6
it	that	constraint	q	608-6
it	must be shown	action	q	608-6
q	and	conjunctive	Eϕ	608-6
Eϕ	are	attribute	equivalent	608-6
<B>	In	constraint	fact	608-7
fact		sequential	it	608-7
it	that	constraint	each instance	608-7
it	for	constraint	each instance	608-7
it	can be shown	action	each instance	608-7
each instance		sequential	I	608-7
I	and	conjunctive	each d	608-7
each d		sequential	adom	608-7
adom		sequential	q	608-7
q		sequential	I	608-7
I		sequential	⊆	608-7
⊆		sequential	d ⊆ dom	608-7
d ⊆ dom		sequential	qd	608-7
qd		sequential	I	608-7
I	=	sequential	Eϕ	608-7
Eϕ		sequential	I	608-7
<B>	that	constraint	q	609-1
<B>	will also yield	action	q	609-1
q	is	attribute	domain	609-1
domain		sequential	<B>	609-1
<B>	Let	action	I	610-1
I	and	conjunctive	<B>	610-1
I	d be fixed	action	<B>	610-1
A straightforward induction	to	constraint	each subformula ψ	610-2
A straightforward induction	that	constraint	each subformula ψ	610-2
A straightforward induction	for	constraint	each subformula ψ	610-2
A straightforward induction	can be used	action	each subformula ψ	610-2
A straightforward induction	show	action	each subformula ψ	610-2
each subformula ψ		sequential	y1	610-2
<B>	.	sequential	<B>	610-3
<B>	.	sequential	<B>	610-4
<B>	of	constraint	each variable assignment ν	610-5
<B>	and	conjunctive	each variable assignment ν	610-5
each variable assignment ν	with	constraint	range d	610-5
range d		sequential	I	610-5
I		sequential	ψ	610-5
ψ		sequential	ν	610-5
ν		sequential	ν	610-5
ν		sequential	y1	610-5
<B>	.	sequential	<B>	610-6
<B>	.	sequential	<B>	610-7
ν ∈		sequential	ym	610-8
Example		sequential	5.4.9	611-1
5.4.9		sequential	q1	611-1
q1	=	sequential	a	611-1
q1	{	sequential	a	611-1
a		sequential	x	611-1
x		sequential	y	611-1
y		sequential	A1A2A3 ∃z	611-1
A1A2A3 ∃z		sequential	P	611-1
P		sequential	x	611-1
x		sequential	y	611-1
y		sequential	z	611-1
z		sequential	∨	611-1
∨		sequential	R	611-1
R		sequential	x	611-1
x		sequential	y	611-1
The formula	of	constraint	q1	612-1
q1	in	constraint	SRNF	612-1
q1	is	attribute	SRNF	612-1
Transformation	into	constraint	RANF yields	612-2
E	=	sequential	πx	613-1
πx		sequential	y	613-1
y		sequential	δ B1B2B3 →xyz	613-1
δ B1B2B3 →xyz		sequential	P	613-1
<B>		sequential	an algebra query	614-1
an algebra query	to	constraint	q1	614-1
q1	is	attribute	<B>	614-1
q2	=	sequential	x	615-1
x		sequential	∃y	615-1
∃y		sequential	R	615-1
R		sequential	x	615-1
x		sequential	y	615-1
y		sequential	∧ ∀z	615-1
∧ ∀z		sequential	S	615-1
S		sequential	z	615-1
z	→	sequential	a T	615-1
a T		sequential	y	615-1
y		sequential	z	615-1
<B>	to	constraint	SRNF	616-1
<B>	Transforming	action	SRNF	616-1
SRNF		sequential	we	616-1
we	have	action	<B>	616-1
<B>	to	constraint	RANF	617-1
<B>	Transforming	action	RANF	617-1
RANF	and	conjunctive	the conjunctions	617-1
RANF	reordering	action	the conjunctions	617-1
the conjunctions		sequential	we	617-1
we	obtain	action	<B>	617-1
E1	=	sequential	δ A1A2 →xy	618-1
δ A1A2 →xy		sequential	R	618-1
R		sequential	⊲⊳	618-1
⊲⊳	w	constraint	b }	618-1
b }		sequential	E2	618-1
E2	=	sequential	σv=x	618-1
σv=x		sequential	E1	618-1
E1	⊲⊳	sequential	δx→v	618-1
δx→v		sequential	E1	618-1
E1		sequential	diff	618-1
diff		sequential	δ C1C2→vw	618-1
δ C1C2→vw		sequential	T	618-1
T		sequential	E3	618-1
E3	=	sequential	πx	618-1
πx		sequential	y	618-1
y		sequential	E2	618-1
E2		sequential	E4	618-1
E4	=	sequential	πx	618-1
πx		sequential	y	618-1
y		sequential	δ	618-1
δ		sequential	A B2=a	618-1
A B2=a		sequential	S	618-1
S		sequential	diff δ C1C2 →yz	618-1
diff δ C1C2 →yz		sequential	T	618-1
T		sequential	E5	618-1
E5	=	sequential	πx	618-1
πx		sequential	E3	618-1
E3		sequential	E4	618-1
The Positive Existential Calculus		sequential	The Positive Existential Calculus	619-1
<B>	Incorporating	action	disjunction	619-2
disjunction	into	constraint	the conjunctive calculus	619-2
the conjunctive calculus	because of	constraint	the possibility	619-2
the conjunctive calculus	was	attribute	more troublesome	619-2
the possibility	of	constraint	infinite answers	619-2
infinite answers		sequential	We	619-2
We	now apply	action	the tools	619-2
the tools	in	constraint	this chapter	619-2
the tools	developed earlier	action	this chapter	619-2
this chapter	to	constraint	this situation	619-2
this chapter	remedy	action	this situation	619-2
Theorem		sequential	5.4.10	620-1
<B>	In	constraint	practical query languages	621-1
practical query languages		sequential	the underlying domain	621-1
the underlying domain	with	constraint	sorts	621-1
the underlying domain	is	attribute	sorts	621-1
the underlying domain	many sorted	action	sorts	621-1
sorts		sequential	boolean	621-1
boolean		sequential	string	621-1
string		sequential	integer	621-1
integer	or	conjunctive	<B>	621-1
These languages	allow	action	the use	621-2
the use	of	constraint	comparators	621-2
comparators		sequential	≤	621-2
≤	between	constraint	database entries	621-2
database entries	in	constraint	an ordered sort	621-2
an ordered sort	and	conjunctive	functions	621-2
functions		sequential	sum	621-2
sum		sequential	count	621-2
count	or	conjunctive	average	621-2
average	on	constraint	numeric sorts	621-2
<B>	In	constraint	this section	621-3
this section		sequential	aggregate operators	621-3
aggregate operators	are briefly considered	action	<B>	621-3
<B>	In	constraint	the next section	622-1
the next section		sequential	a novel approach	622-1
a novel approach	for	constraint	arithmetic constraints	622-1
a novel approach	incorporating	action	arithmetic constraints	622-1
arithmetic constraints	into	constraint	the relational model	622-1
the relational model	will be addressed	action	<B>	622-1
Example		sequential	5.5.1	623-1
5.5.1	Consider	action	a relation Sales	623-1
a relation Sales		sequential	Theater	623-1
Theater		sequential	Title	623-1
Title		sequential	Date	623-1
Date		sequential	Attendance	623-1
Attendance		sequential	a tuple	623-1
a tuple		sequential	th	623-1
th		sequential	ti	623-1
ti		sequential	d	623-1
d	that	constraint	date d	623-1
d	on	constraint	date d	623-1
d	indicates	action	date d	623-1
date d		sequential	a total	623-1
a total	of	constraint	a people	623-1
a people	attended	action	showings	623-1
showings	of	constraint	movie ti	623-1
movie ti	at	constraint	theater	623-1
We	that	constraint	Theater	623-2
We	assume	action	Theater	623-2
Theater		sequential	Title	623-2
Title		sequential	Date	623-2
Date	that	constraint	two distinct tuples	623-2
Date	is	attribute	a key	623-2
two distinct tuples	can not share	action	the same values	623-2
the same values	on	constraint	these three attributes	623-2
Two queries	involving	action	aggregate functions	623-3
aggregate functions	For	constraint	each theater	623-3
aggregate functions	are	attribute	each theater	623-3
each theater	list	action	the total number	623-3
the total number	of	constraint	movies	623-3
movies		sequential	that	623-3
that	have been shown	action	<B>	623-3
<B>	For	constraint	each theater	624-1
each theater	and	conjunctive	movie	624-1
movie	list	action	the total attendance	624-1
the first query	in	constraint	a pidgin language	625-1
the first query	Informally might be expressed	action	a pidgin language	625-1
a pidgin language	as	constraint	a value	625-1
a pidgin language	since	constraint	a value	625-1
a value	to	constraint	many times	625-1
a value	as	constraint	many times	625-1
a value	has	action	many times	625-1
a value	be counted	action	many times	625-1
many times	as	constraint	it	625-1
it	in	constraint	the selection	625-1
it	occurs	action	the selection	625-1
<B>	that	constraint	a more natural setting	625-2
<B>	suggests	action	a more natural setting	625-2
a more natural setting	for	constraint	aggregate functions	625-2
a more natural setting	studying	action	aggregate functions	625-2
aggregate functions	would explicitly include	action	bags	625-2
bags	or	conjunctive	multisets	625-2
multisets		sequential	collections	625-2
collections	in	constraint	which	625-2
which		sequential	duplicates	625-2
duplicates	and	conjunctive	not just sets	625-2
duplicates	are permitted	action	not just sets	625-2
not just sets		sequential	a somewhat radical departure	625-2
a somewhat radical departure	from	constraint	the model	625-2
the model		sequential	we	625-2
we	have used so far	action	<B>	625-2
The two queries	as	constraint	aggregate functions	626-1
The two queries	can be expressed	action	aggregate functions	626-1
The two queries	follows	action	aggregate functions	626-1
The two queries	using	action	aggregate functions	626-1
aggregate functions	in	constraint	an algebraic language	626-1
We	now briefly present	action	a more formal development	627-1
<B>	To	constraint	the formalism	627-2
<B>	simplify	action	the formalism	627-2
the formalism	on	constraint	the unnamed perspective	627-2
the formalism	is based	action	the unnamed perspective	627-2
the unnamed perspective	and	conjunctive	we	627-2
we	that	constraint	dom	627-2
we	assume	action	dom	627-2
dom	=	sequential	N	627-2
N		sequential	the set	627-2
the set	of	constraint	nonnegative integers	627-2
We	within	constraint	the relational model	627-3
We	stay	action	the relational model	627-3
the relational model	although	constraint	the preceding example	627-3
the relational model	as	constraint	the preceding example	627-3
the relational model	in	constraint	the preceding example	627-3
the relational model	noted	action	the preceding example	627-3
the preceding example		sequential	a richer data model	627-3
a richer data model	with	constraint	bags	627-3
bags	be	attribute	would more natural	627-3
the complex value model		sequential	that	627-4
that	in	constraint	Chapter 20	627-4
that	will be studied	action	Chapter 20	627-4
Chapter 20	Indeed provides	action	a more appropriate context	627-4
a more appropriate context	for	constraint	aggregate functions	627-4
a more appropriate context	considering	action	aggregate functions	627-4
We	shall adopt	action	a somewhat abstract view	628-1
a somewhat abstract view	of	constraint	aggregate operators	628-1
An aggregate function		sequential	f	628-2
f	to	constraint	a family	628-2
f	be	attribute	a family	628-2
f	is defined	action	a family	628-2
a family	of	constraint	functions	628-2
functions		sequential	f1	628-2
f1		sequential	f2	628-2
<B>	.	sequential	<B>	628-3
<B>	.	sequential	<B>	628-4
<B>	that	constraint	each j	628-5
<B>	for	constraint	each j	628-5
each j	≥	sequential	1	628-5
1	and	conjunctive	each relation schema S	628-5
each relation schema S	with	constraint	arity	628-5
arity		sequential	S	628-5
S		sequential	j	628-5
j		sequential	fj	628-5
fj		sequential	Inst	628-5
Inst		sequential	S	628-5
S	→	sequential	N	628-5
<B>	As	constraint	the case	628-6
<B>	in	constraint	the case	628-6
the case	of	constraint	sum	628-6
sum		sequential	we	628-6
we	want	action	the fi	628-6
the fi	to	constraint	only the content	628-6
the fi	on	constraint	only the content	628-6
the fi	depend	action	only the content	628-6
only the content	of	constraint	the column	628-6
the column	to	constraint	which	628-6
which		sequential	they	628-6
they	are applied	action	the content	628-6
the content	where includes	action	not the set	628-6
not the set	of	constraint	elements	628-6
elements	in	constraint	the column	628-6
the column	but	conjunctive	also the number	628-6
also the number	of	constraint	their occurrences	628-6
their occurrences		sequential	columns	628-6
columns	as	constraint	bags	628-6
columns	are viewed	action	bags	628-6
This requirement	by	constraint	the following uniformity property	628-7
This requirement	is captured	action	the following uniformity property	628-7
the following uniformity property	on	constraint	each aggregate function f	628-7
the following uniformity property	imposed	action	each aggregate function f	628-7
fi		sequential	I	628-8
I	Then =	sequential	fj	628-8
fj		sequential	J	628-8
We	next illustrate	action	aggregate functions	629-1
aggregate functions	into	constraint	the algebra	629-1
aggregate functions	how can be incorporated	action	the algebra	629-1
the algebra	and	conjunctive	calculus	629-1
calculus		sequential	we	629-1
we	for	constraint	nr-datalog¬	629-1
we	do not discuss	attribute	this	629-1
we	how is done	action	nr-datalog¬	629-1
nr-datalog¬	since	constraint	it	629-1
it	to	constraint	the algebra	629-1
it	is	attribute	similar	629-1
Aggregate functions	to	constraint	the algebra	629-2
Aggregate functions	are added	action	the algebra	629-2
the algebra	using	action	an extended projection operation	629-2
<B>		sequential	the projection function	630-1
the projection function	for	constraint	aggregate function	630-1
aggregate function	f	constraint	relation instance	630-1
aggregate function	on	constraint	relation instance	630-1
relation instance		sequential	I	630-1
I	as	constraint	jm k	630-1
I	is defined	action	jm k	630-1
I	follows	action	jm k	630-1
jm k		sequential	σ	630-1
σ		sequential	j1 =aj	630-1
m=ajm		sequential	m=ajm	631-1
<B>	.	sequential	<B>	631-2
<B>	.	sequential	<B>	631-3
jm		sequential	jm	631-4
<B>	to	constraint	the calculus	632-1
<B>	Turning	action	the calculus	632-1
the calculus		sequential	we	632-1
we	with	constraint	an example	632-1
we	begin	action	an example	632-1
Query		sequential	5.5	632-2
5.5	in	constraint	the extended calculus	632-2
5.5	can be expressed	action	the extended calculus	632-2
the extended calculus	as	constraint	sum2	632-2
sum2	is	attribute	where the aggregate function	632-2
where the aggregate function	summing	action	the second column	632-2
the second column	of	constraint	a relation	632-2
<B>	that	constraint	the subexpression	632-3
<B>	Note	action	the subexpression	632-3
the subexpression		sequential	d2	632-3
d2		sequential	a2	632-3
a2		sequential	Sales	632-3
Sales		sequential	th	632-3
th		sequential	ti	632-3
ti		sequential	d2	632-3
d2	a	sequential	2	632-3
2	has	action	free variables	632-3
free variables		sequential	th	632-3
th	and	conjunctive	ti	632-3
ti		sequential	that	632-3
that	in	constraint	the target	632-3
that	do not occur	action	the target	632-3
the target	of	constraint	the subexpression	632-3
different assignments	for	constraint	these variables	632-4
these variables	Intuitively will yield	action	different values	632-4
different values	for	constraint	the subexpression	632-4
<B>		sequential	aggregate functions	633-1
aggregate functions	into	constraint	the calculus	633-1
aggregate functions	are incorporated	action	the calculus	633-1
the calculus	by	constraint	aggregate terms	633-1
the calculus	permitting	action	aggregate terms	633-1
aggregate terms		sequential	that	633-1
that	have	action	the form fj	633-1
the form fj	$ x	sequential	}	633-1
the form fj	|	sequential	}	633-1
the form fj	ψ	sequential	}	633-1
}		sequential	f	633-1
f	is	attribute	where an aggregate function	633-1
where an aggregate function		sequential	j	633-1
j		sequential	≤	633-1
≤		sequential	x	633-1
x	and	conjunctive	ψ	633-1
ψ	is	attribute	a calculus formula	633-1
a calculus formula	with	constraint	possibly aggregate terms	633-1
<B>	When defining	action	the extended calculus	633-2
the extended calculus		sequential	care	633-2
care	to	constraint	aggregate terms	633-2
care	that	constraint	aggregate terms	633-2
care	must be taken	action	aggregate terms	633-2
care	guarantee	action	aggregate terms	633-2
aggregate terms	on	constraint	<B>	633-2
aggregate terms	do not recursively depend	attribute	each other	633-2
<B>	with	constraint	a suitable generalization	633-3
<B>	can be accomplished	action	a suitable generalization	633-3
a suitable generalization	of	constraint	safe range	633-3
This generalization	that	constraint	free variables	633-4
This generalization	will also ensure	action	free variables	633-4
free variables	in	constraint	an aggregate term	633-4
free variables	occurring	action	an aggregate term	633-4
an aggregate term		sequential	range	633-4
range	by	constraint	a subformula	633-4
range	are restricted	action	a subformula	633-4
a subformula	containing	action	it	633-4
It	to	constraint	the semantics	633-5
It	is	attribute	straightforward	633-5
It	define	action	the semantics	633-5
the semantics	of	constraint	safe range	633-5
safe range		sequential	the generalized calculus	633-5
the generalized calculus	with	constraint	aggregate functions	633-5
One	that	constraint	the extensions	633-6
One	can show	action	the extensions	633-6
the extensions	of	constraint	the algebra	633-6
the algebra	and	conjunctive	safe range	633-6
safe range		sequential	calculus	633-6
calculus	with	constraint	the same set	633-6
the same set	of	constraint	aggregate functions	633-6
aggregate functions	have	action	the same expressive power	633-6
Digression		sequential	Finite Representations	634-1
Finite Representations	of	constraint	Infinite Databases	634-1
<B>	As	constraint	we	634-2
we	have seen	attribute	this	634-2
we	introduced	action	significant difficulty	634-2
significant difficulty	in	constraint	connection	634-2
connection	with	constraint	domain independence	634-2
domain independence	of	constraint	calculus queries	634-2
It	in	constraint	connection	634-3
It	is	attribute	also restrictive	634-3
connection	with	constraint	some application areas	634-3
some application areas		sequential	that	634-3
that	or	conjunctive	data	634-3
that	involve	attribute	temporal	634-3
<B>	For	constraint	example	634-4
example		sequential	it	634-4
it	to	constraint	a rectangle	634-4
it	of	constraint	a rectangle	634-4
it	be	attribute	would convenient	634-4
it	think	action	a rectangle	634-4
a rectangle	in	constraint	the real plane	634-4
the real plane	as	constraint	an infinite set	634-4
an infinite set	of	constraint	points	634-4
points	if	constraint	it	634-4
it	in	constraint	some finite manner	634-4
it	even can be represented easily	action	some finite manner	634-4
<B>	In	constraint	this short section	635-1
this short section		sequential	we	635-1
we	and	conjunctive	some material	635-1
we	briefly describe	attribute	recent	635-1
some material		sequential	that	635-1
that	uses	action	logic	635-1
logic	to	constraint	the finite representation	635-1
logic	permit	action	the finite representation	635-1
the finite representation	of	constraint	infinite databases	635-1
We	by	constraint	an alternative approach	635-2
We	begin	action	an alternative approach	635-2
We	presenting	action	an alternative approach	635-2
an alternative approach	to	constraint	the problem	635-2
an alternative approach	resolving	action	the problem	635-2
the problem	of	constraint	safety	635-2
safety		sequential	that	635-2
that	permits	action	queries	635-2
queries	to	constraint	answers	635-2
queries	have	action	answers	635-2
answers		sequential	that	635-2
that	but	conjunctive	<B>	635-2
that	are	attribute	infinite	635-2
We	introduce	action	a promising generalization	635-3
a promising generalization	of	constraint	the relational model	635-3
the relational model		sequential	that	635-3
that	uses	action	constraints	635-3
constraints	to	constraint	infinite databases	635-3
constraints	represent	action	infinite databases	635-3
infinite databases	and	conjunctive	we	635-3
we	describe	action	query processing	635-3
query processing	against	constraint	an efficient manner	635-3
query processing	in	constraint	an efficient manner	635-3
query processing	can be performed	attribute	these	635-3
<B>	For	constraint	this result	636-1
this result		sequential	we	636-1
we	shall use	action	a finite set d ⊂ dom	636-1
a finite set d ⊂ dom		sequential	which	636-1
which	to	constraint	the active domain	636-1
which	corresponds intuitively	action	the active domain	636-1
the active domain	of	constraint	query	636-1
query	and	conjunctive	input	636-1
input		sequential	a database	636-1
a database	and	conjunctive	a set	636-1
a set		sequential	C	636-1
C	=	sequential	c1	636-1
C	{	sequential	c1	636-1
<B>	.	sequential	<B>	636-2
<B>	.	sequential	<B>	636-3
cm		sequential	}	636-4
}	of	constraint	m distinct symbols	636-4
m distinct symbols		sequential	which	636-4
which	as	constraint	placeholders	636-4
which	will serve	action	placeholders	636-4
placeholders	for	constraint	elements	636-4
elements	of	constraint	dom d	636-4
semd		sequential	t	637-1
t	=	sequential	ρ	637-1
ρ		sequential	t	637-1
t		sequential	ρ	637-1
ρ	is	attribute	a one one mapping	637-1
a one one mapping	from	constraint	d ∪ C	637-1
d ∪ C		sequential	that	637-1
that	leaves	action	d	637-1
d	and	conjunctive	maps C	637-1
d	fixed	action	maps C	637-1
maps C	into	constraint	dom	637-1
dom		sequential	d }	637-1
The following theorem	without	constraint	proof	638-1
The following theorem	stated	action	proof	638-1
proof	characterizes	action	the result	638-1
the result	of	constraint	an arbitrary calculus query	638-1
the result	applying	action	an arbitrary calculus query	638-1
an arbitrary calculus query	using	action	the natural semantics	638-1
Theorem		sequential	5.6.1	639-1
5.6.1	Let	action	q	639-1
q	=	sequential	e1	639-1
q	{	sequential	e1	639-1
<B>	.	sequential	<B>	639-2
<B>	.	sequential	<B>	639-3
en	be	attribute	an arbitrary calculus query	639-4
an arbitrary calculus query		sequential	each quantifier	639-4
each quantifier	in	constraint	ϕ	639-4
ϕ	quantifies	action	a distinct variable	639-4
a distinct variable		sequential	that	639-4
that	in	constraint	ϕ	639-4
that	is	attribute	not free	639-4
<B>	Let	action	C	639-5
C		sequential	c1	639-5
<B>	.	sequential	<B>	639-6
<B>	.	sequential	<B>	639-7
cm	be	attribute	a set	639-8
a set	of	constraint	m distinct symbols	639-8
m distinct symbols	in	constraint	dom	639-8
m distinct symbols	not occurring	action	dom	639-8
dom	as	constraint	domain elements	639-8
dom	but	conjunctive	domain elements	639-8
dom	viewed	action	domain elements	639-8
domain elements		sequential	m	639-8
m	is	attribute	where the number	639-8
where the number	of	constraint	distinct variables in	639-8
<B>	for	constraint	each input instance	639-9
each input instance		sequential	I	639-9
I		sequential	qdom	639-9
qdom		sequential	I	639-9
I	Then =	sequential	∪	639-9
∪		sequential	semadom	639-9
semadom		sequential	q	639-9
q		sequential	I	639-9
I		sequential	t	639-9
t		sequential	t ∈ q	639-9
t ∈ q		sequential	adom	639-9
adom		sequential	q	639-9
q		sequential	I	639-9
I		sequential	∪C	639-9
∪C		sequential	I	639-9
<B>	that	constraint	we	640-1
<B>	if	constraint	we	640-1
<B>	shows	action	we	640-1
we	apply	action	a calculus query	640-1
a calculus query	under	constraint	the natural semantics	640-1
the natural semantics	to	constraint	a finite database	640-1
a finite database		sequential	the result	640-1
the result	if	constraint	<B>	640-1
the result	is	attribute	recursive	640-1
<B>	But	conjunctive	the set	640-2
the set	of	constraint	infinite databases	640-2
infinite databases	in	constraint	this manner	640-2
infinite databases	is described	action	this manner	640-2
this manner	under	constraint	the application	640-2
this manner	closed	action	the application	640-2
the application	of	constraint	calculus queries	640-2
The affirmative answer	by	constraint	an elegant generalization	640-3
The affirmative answer	is provided	action	an elegant generalization	640-3
an elegant generalization	of	constraint	the relational model	640-3
the relational model	presented next	action	Exercise 5.31	640-3
the relational model	see	action	Exercise 5.31	640-3
Constraint Query Languages		sequential	Constraint Query Languages	641-1
The starting point	to	constraint	infinite databases	641-2
The starting point	is	attribute	infinite databases	641-2
The starting point	consider	action	infinite databases	641-2
infinite databases	with	constraint	finite representations	641-2
finite representations	on	constraint	the use	641-2
finite representations	based	action	the use	641-2
the use	of	constraint	constraints	641-2
<B>	To	constraint	we	641-3
<B>	begin	action	we	641-3
we	define	action	a generalized n- tuple	641-3
a generalized n- tuple	as	constraint	a conjunction	641-3
a conjunction	of	constraint	constraints	641-3
constraints	over	constraint	variables	641-3
constraints	n	conjunctive	variables	641-3
The constraints	=	sequential	<B>	641-4
The constraints	=	sequential	<B>	641-4
The constraints	typically include	action	<B>	641-4
<B>	In	constraint	some sense	641-5
some sense		sequential	such a constraint	641-5
such a constraint	as	constraint	a finite representation	641-5
such a constraint	can be viewed	action	a finite representation	641-5
a finite representation	of	constraint	a set	641-5
a set	of	constraint	n-tuples	641-5
n-tuples		sequential	the valuations	641-5
the valuations	of	constraint	the variables	641-5
the variables		sequential	that	641-5
that	satisfy	action	the constraint	641-5
Example		sequential	5.6.2	642-1
<B>	that	constraint	rectangles	642-2
<B>	Suppose first	action	rectangles	642-2
rectangles	are given	action	5 tuples n	642-2
rectangles	using	action	5 tuples n	642-2
5 tuples n		sequential	x1	642-2
x1		sequential	y1	642-2
y1		sequential	x2	642-2
x2		sequential	y2	642-2
y2	n	conjunctive	where the name	642-2
y2	is	attribute	where the name	642-2
where the name	of	constraint	the rectangle	642-2
the rectangle		sequential	x1	642-2
x1		sequential	y1	642-2
y1	are	attribute	the coordinates	642-2
the coordinates	of	constraint	the lower left corner	642-2
the lower left corner	and	conjunctive	x2	642-2
x2		sequential	y2	642-2
y2	are	attribute	the coordinates	642-2
the coordinates	of	constraint	the upper right	642-2
The set	of	constraint	points	642-3
points		sequential	u	642-3
u		sequential	v	642-3
v	in	constraint	such a rectangle	642-3
such a rectangle	by	constraint	x1	642-3
such a rectangle	delimited	action	x1	642-3
x1		sequential	y1	642-3
y1		sequential	x2	642-3
x2		sequential	y2	642-3
y2	by	constraint	the constraint x1	642-3
y2	is given	action	the constraint x1	642-3
the constraint x1		sequential	≤	642-3
≤		sequential	u	642-3
u		sequential	x2	642-3
x2		sequential	∧	642-3
∧		sequential	y1	642-3
y1	≤	sequential	v	642-3
v	≤	sequential	y2	642-3
the names	of	constraint	intersecting rectangles	643-1
intersecting rectangles	from	constraint	a relation R	643-1
a relation R	by	constraint	R	643-1
a relation R	Now are given	action	R	643-1
R		sequential	n2	643-1
n2		sequential	x′	643-1
x′		sequential	u	643-1
u		sequential	≤	643-1
≤	x	sequential	′2 y′	643-1
′2 y′		sequential	1 v	643-1
1 v	≤	sequential	y′	643-1
y′		sequential	2	643-1
2		sequential	}	643-1
<B>	within	constraint	essentially the framework	644-1
<B>	is	attribute	essentially the framework	644-1
essentially the framework	of	constraint	the relational model	644-1
the relational model	except	constraint	we	644-1
the relational model	that	constraint	we	644-1
the relational model	presented so far	action	we	644-1
we	are using	action	an infinite base relation ≤	644-1
There	is	attribute	a level	644-2
a level	of	constraint	indirection	644-2
indirection	between	constraint	the representation	644-2
the representation	of	constraint	a rectangle	644-2
a rectangle		sequential	a x1	644-2
a x1		sequential	y1	644-2
y1		sequential	x2	644-2
x2		sequential	y2	644-2
y2	and	conjunctive	the actual set	644-2
the actual set	of	constraint	points	644-2
points		sequential	that	644-2
that		sequential	it	644-2
it	contains	action	<B>	644-2
<B>	In	constraint	the following constraint formalism	645-1
the following constraint formalism		sequential	a named rectangle	645-1
a named rectangle	by	constraint	<B>	645-1
a named rectangle	can be represented	action	<B>	645-1
<B>	as	constraint	a finite syntactic representation	646-1
<B>	should be viewed	action	a finite syntactic representation	646-1
a finite syntactic representation	of	constraint	an infinite set	646-1
an infinite set	of	constraint	triples	646-1
A triple z1		sequential	z2	646-2
z2		sequential	z3	646-2
z3	satisfying	action	this constraint	646-2
this constraint	that	constraint	the point	646-2
this constraint	indicates	action	the point	646-2
the point	of	constraint	coordinates	646-2
coordinates		sequential	z2	646-2
z2		sequential	z3	646-2
z3	in	constraint	a rectangle	646-2
z3	is	attribute	a rectangle	646-2
a rectangle	with	constraint	name z1	646-2
One	can see	action	a number	647-1
a number	of	constraint	uses	647-1
uses	in	constraint	constraints	647-1
uses	allowing	action	constraints	647-1
constraints	in	constraint	the language	647-1
<B>		sequential	constraints	647-2
constraints	for	constraint	domains	647-2
constraints	arise naturally	action	domains	647-2
domains	concerning	action	measures	647-2
measures		sequential	price	647-2
price		sequential	distance	647-2
distance		sequential	time	647-2
time		sequential	<B>	647-2
The introduction	of	constraint	time	647-3
time	in	constraint	the active area	647-3
time	has already been studied	action	the active area	647-3
the active area	of	constraint	temporal databases	647-3
temporal databases	see	action	Section 22.6	647-3
<B>	In	constraint	other applications	647-4
other applications		sequential	spatial databases	647-4
spatial databases		sequential	geometry	647-4
geometry	plays	action	an essential role	647-4
an essential role	in	constraint	the realm	647-4
an essential role	and	conjunctive	the realm	647-4
an essential role	fits nicely	action	the realm	647-4
the realm	of	constraint	constraint query languages	647-4
One	can clearly obtain	action	different languages	648-1
different languages	by	constraint	various domains	648-1
different languages	considering	action	various domains	648-1
various domains	and	conjunctive	various forms	648-1
various forms	of	constraint	constraints	648-1
Relational calculus		sequential	relational algebra	648-2
relational algebra	or	conjunctive	some other relational languages	648-2
some other relational languages	with	constraint	instance	648-2
some other relational languages	for	constraint	instance	648-2
some other relational languages	can be extended	action	instance	648-2
instance		sequential	the theory	648-2
the theory	of	constraint	real closed fields	648-2
real closed fields	or	conjunctive	the theory	648-2
the theory	of	constraint	dense orders	648-2
dense orders	without	constraint	endpoints	648-2
a requirement	is	attribute	Of course the decidability	648-3
Of course the decidability	of	constraint	the resulting language	648-3
Definition		sequential	5.6.3	649-1
<B>	that	constraint	I	650-1
<B>	Suppose	action	I	650-1
I	is	attribute	a generalized instance	650-1
We	to	constraint	I	650-2
We	refer	action	I	650-2
I	as	constraint	a syntactic database	650-2
a syntactic database	to	constraint	the set	650-2
a syntactic database	and	conjunctive	the set	650-2
the set	of	constraint	conventional tuples	650-2
conventional tuples	by	constraint	I	650-2
conventional tuples	represented	action	I	650-2
I	as	constraint	the semantic database	650-2
We	now present	action	two applications	651-1
two applications	of	constraint	this approach	651-1
this approach		sequential	one	651-1
one	in	constraint	connection	651-1
connection	with	constraint	the reals	651-1
the reals	with	constraint	the rationals	651-1
the reals	and	conjunctive	the rationals	651-1
We	that	constraint	the constants	652-1
We	assume now	action	the constants	652-1
the constants	over	constraint	a real closed field	652-1
the constants	are interpreted	action	a real closed field	652-1
a real closed field		sequential	the reals	652-1
The constraints	are	attribute	polynomial inequality constraints	652-2
polynomial inequality constraints		sequential	inequalities	652-2
inequalities	of	constraint	the form p	652-2
the form p		sequential	x1	652-2
<B>	.	sequential	<B>	652-3
<B>	.	sequential	<B>	652-4
xn	≥	sequential	0	652-5
0		sequential	p	652-5
p	is	attribute	where a polynomial	652-5
Two 3 tuples	in	constraint	this context	652-6
this context	×	sequential	3.56 x2	652-6
this context	are	attribute	3.56 x2	652-6
One	can evaluate	action	queries	653-1
queries		sequential	algebraically bottom up	653-1
algebraically bottom up	at	constraint	each step	653-1
each step	of	constraint	the computation	653-1
the computation		sequential	the result	653-1
the result	is	attribute	still a generalized instance	653-1
<B>	is	attribute	a straightforward consequence	653-2
a straightforward consequence	of	constraint	Tarski	653-2
Tarski		sequential	decision procedure	653-2
decision procedure	for	constraint	the theory	653-2
the theory	of	constraint	real closed fields	653-2
A difficulty	in	constraint	projection	653-3
A difficulty	resides	action	projection	653-3
projection		sequential	quantifier elimination	653-3
The procedure	for	constraint	projection	653-4
projection	in	constraint	the size	653-4
projection	is	attribute	extremely costly	653-4
the size	of	constraint	the query	653-4
<B>	for	constraint	a fixed query	653-5
a fixed query		sequential	the complexity	653-5
the complexity	in	constraint	the size	653-5
the size	of	constraint	the syntactic database	653-5
the syntactic database	in	constraint	nc	653-5
the syntactic database	is	attribute	However reasonable	653-5
We	that	constraint	the constants	654-1
We	assume now	action	the constants	654-1
the constants	over	constraint	a countably infinite set	654-1
the constants	are interpreted	action	a countably infinite set	654-1
a countably infinite set	with	constraint	a binary relation	654-1
a binary relation	is	attribute	a dense order	654-1
a dense order		sequential	the rationals	654-1
The constraints	of	constraint	xθy	654-2
The constraints	are	attribute	xθy	654-2
xθy	or	conjunctive	xθ	654-2
xθ		sequential	the form c	654-2
the form c		sequential	x	654-2
x		sequential	y	654-2
y	are	attribute	where variables	654-2
where variables		sequential	c	654-2
c	and	conjunctive	θ	654-2
c	is	attribute	a constant	654-2
θ	among	constraint	≤	654-2
θ	is	attribute	≤	654-2
≤	=	sequential	<B>	654-2
An example is	of	constraint	a 3 tuple	654-3
bottom	up	constraint	a algebraic evaluation	655-1
a algebraic evaluation	is	attribute	Here again feasible	655-1
evaluation	in	constraint	Indeed ac0	655-2
evaluation	is	attribute	Indeed ac0	655-2
Indeed ac0	in	constraint	the size	655-2
the size	of	constraint	the syntactic database	655-2
the syntactic database	for	constraint	a fixed query	655-2
<B>	In	constraint	the remainder	656-1
the remainder	of	constraint	this book	656-1
this book		sequential	we	656-1
we	consider	action	standard databases	656-1
standard databases	and	conjunctive	not generalized ones	656-1
Bibliographic Notes		sequential	Bibliographic Notes	657-1
<B>	In	constraint	Cod72	657-2
Cod72		sequential	b	657-2
b	introduced	action	the equivalence	657-2
the equivalence	of	constraint	the calculus	657-2
the calculus	and	conjunctive	algebra	657-2
algebra	to	constraint	the database community	657-2
That paper	coined	action	the phrase	657-3
the phrase		sequential	relational completeness	657-3
relational completeness	to	constraint	the expressive power	657-3
relational completeness	describe	action	the expressive power	657-3
the expressive power	of	constraint	relational query languages	657-3
We	have not emphasized here	action	that phrase	657-4
that phrase	because	constraint	subsequent research	657-4
subsequent research	that	constraint	a more natural notion	657-4
subsequent research	has suggested	action	a more natural notion	657-4
a more natural notion	of	constraint	completeness	657-4
completeness	in	constraint	terms	657-4
completeness	can be described	action	terms	657-4
terms	of	constraint	Turing computability	657-4
Turing computability	see	action	Chapter 16	657-4
One such result	in	constraint	this chapter	658-1
One such result	presented	action	this chapter	658-1
this chapter	is	attribute	the equivalence	658-1
the equivalence	of	constraint	the positive existential Notes culus	658-1
the positive existential Notes culus	and	conjunctive	the SPCU algebra	658-1
the SPCU algebra		sequential	CH82	658-1
CH82		sequential	analogous results	658-1
analogous results	for	constraint	the relational calculus	658-1
analogous results	have also been developed	action	the relational calculus	658-1
the relational calculus	with	constraint	aggregate operators	658-1
the relational calculus	extended	action	aggregate operators	658-1
aggregate operators		sequential	Klu82	658-1
Klu82		sequential	the complex value model	658-1
Notions	to	constraint	domain independence	659-1
domain independence	as	constraint	Low15	659-1
domain independence	are found	action	Low15	659-1
Low15	in	constraint	the logic community	659-1
the logic community	in	constraint	the database community	659-1
the database community		sequential	the first paper	659-1
the first paper	on	constraint	this topic	659-1
this topic	to	constraint	Kuh67	659-1
this topic	be	attribute	Kuh67	659-1
this topic	appears	action	Kuh67	659-1
Kuh67		sequential	which	659-1
which	introduced	action	the notion	659-1
the notion	of	constraint	definite queries	659-1
The notion	of	constraint	domain independence	659-2
domain independence	from	constraint	Fag82 b	659-2
domain independence	is	attribute	Fag82 b	659-2
domain independence	used here	action	Fag82 b	659-2
Fag82 b		sequential	Mak81	659-2
Mak81		sequential	the notions	659-2
the notions	of	constraint	domain	659-2
the notions	and	conjunctive	domain	659-2
domain	in	constraint	ND82	659-2
domain	were proved	attribute	equivalent	659-2
A large number	of	constraint	classes	659-3
classes	of	constraint	domain	659-3
domain		sequential	formulas	659-3
formulas	have been investigated	action	<B>	659-3
<B>	include	action	Ull82 b	659-4
Ull82 b		sequential	the safe safe DRC	659-4
the safe safe DRC		sequential	Ull88	659-4
Ull88		sequential	range	659-4
range		sequential	<B>	659-4
Domain independence	in	constraint	the context	660-1
Domain independence	also arises	action	the context	660-1
the context	of	constraint	dependencies	660-1
dependencies		sequential	Fag82 b	660-1
Fag82 b		sequential	Mak81	660-1
Mak81	and	conjunctive	datalog	660-1
datalog		sequential	Dec86	660-1
Dec86		sequential	Top87	660-1
Top87		sequential	RBS87	660-1
RBS87		sequential	TS88	660-1
The issue	of	constraint	domain independence	660-2
The issue	extending	action	domain independence	660-2
domain independence	to	constraint	functions	660-2
domain independence	incorporate	action	functions	660-2
functions		sequential	arithmetic functions	660-2
arithmetic functions	or	conjunctive	user	660-2
user	defined	action	functions	660-2
functions	in	constraint	AB88	660-2
functions	is considered	action	AB88	660-2
AB88		sequential	Top91	660-2
Top91		sequential	EHJ93	660-2
The issue	of	constraint	domain independence	660-3
The issue	extending	action	domain independence	660-3
domain independence	to	constraint	freely interpreted functions	660-3
domain independence	incorporate	action	freely interpreted functions	660-3
freely interpreted functions		sequential	arise	660-3
arise	in	constraint	logic programming	660-3
logic programming	in	constraint	Kif88	660-3
logic programming	is addressed	action	Kif88	660-3
Syntactic conditions	on	constraint	datalog programs	661-1
datalog programs	with	constraint	arithmetic	661-1
arithmetic		sequential	that	661-1
that	ensure	action	safety	661-1
safety	in	constraint	RBS87	661-1
safety	are developed	action	RBS87	661-1
RBS87		sequential	KRS88a	661-1
KRS88a		sequential	KRS88	661-1
KRS88		sequential	b	661-1
b		sequential	SV89	661-1
Issues	of	constraint	safety	661-2
safety	in	constraint	the presence	661-2
the presence	of	constraint	function	661-2
function	or	conjunctive	order	661-2
order		sequential	symbols	661-2
symbols	in	constraint	AH91	661-2
symbols	are also considered	action	AH91	661-2
Aggregate functions	into	constraint	the relational algebra	661-3
Aggregate functions	were first incorporated	action	the relational algebra	661-3
the relational algebra	and	conjunctive	calculus	661-3
calculus	in	constraint	Klu82	661-3
Klu82	see also	action	AB88	661-3
The notion	of	constraint	safe range	662-1
safe range	than	constraint	safe safe DRC	662-1
safe range	presented here	attribute	richer	662-1
safe range	is	attribute	richer	662-1
safe safe DRC	and	conjunctive	range	662-1
range	than	constraint	range	662-1
range	and	conjunctive	range	662-1
range	and	conjunctive	range	662-1
range	allowed	attribute	evaluable	662-1
range	restricted	action	<B>	662-1
It	follows	action	the spirit	662-2
the spirit	of	constraint	the definition	662-2
the definition	of	constraint	VanGT91	662-2
the definition	in	constraint	VanGT91	662-2
the definition	allowed	action	VanGT91	662-2
the definition	presented	action	VanGT91	662-2
VanGT91	and	conjunctive	safe range	662-2
safe range	in	constraint	AB88	662-2
The transformations	of	constraint	safe range	662-3
safe range		sequential	the calculus	662-3
the calculus	to	constraint	the algebra	662-3
the algebra	presented here	action	the more general transformations	662-3
the algebra	follows	action	the more general transformations	662-3
the more general transformations	in	constraint	VanGT91	662-3
VanGT91		sequential	EHJ93	662-3
The notion	of	constraint	relational algebra normal form	662-4
relational algebra normal form	in	constraint	those works	662-4
relational algebra normal form	used	action	those works	662-4
those works	than	constraint	the notion	662-4
those works	is	attribute	more general	662-4
the notion	by	constraint	that name	662-4
that name	used here	action	<B>	662-4
Query languages	for	constraint	finite databases	663-1
Query languages	have mostly been considered	action	finite databases	663-1
An exception	is	attribute	<B>	663-2
<B>	with	constraint	constraints	664-1
<B>	Programming	action	constraints	664-1
constraints	for	constraint	some time	664-1
constraints	has been studied	action	some time	664-1
some time	in	constraint	topic areas	664-1
topic areas	from	constraint	linear programming	664-1
topic areas	ranging	action	linear programming	664-1
linear programming	to	constraint	AI	664-1
AI	to	constraint	logic programming	664-1
<B>	Although	constraint	the declarative spirit	664-2
the declarative spirit	of	constraint	constraint programming	664-2
the declarative spirit	both	conjunctive	constraint programming	664-2
constraint programming	and	conjunctive	database query	664-2
database query		sequential	languages	664-2
languages	to	constraint	a natural marriage	664-2
languages	leads	action	a natural marriage	664-2
a natural marriage		sequential	it	664-2
it	that	constraint	the combination	664-2
it	is	attribute	the combination	664-2
the combination	of	constraint	the two paradigms	664-2
the two paradigms	for	constraint	constraint databases	664-2
the two paradigms	has been studied seriously	action	constraint databases	664-2
constraint databases	with	constraint	dense order	664-2
dense order	and	conjunctive	inequalities	664-2
inequalities	is featured	action	<B>	664-2
Recent works	on	constraint	constraint database languages	664-3
constraint database languages	in	constraint	Kup93	664-3
constraint database languages	can be found	action	Kup93	664-3
Kup93		sequential	GS94	664-3
Exercises Exercise 5.1 Express queries		sequential	5.2	665-1
5.2	and	conjunctive	5.3	665-1
5.3	in	constraint	1 the relational algebras	665-1
1 the relational algebras		sequential	2 nonrecursive datalog¬	665-1
2 nonrecursive datalog¬	and	conjunctive	domain	665-1
domain		sequential	3 relational calculus	665-1
<B>	Exercise	action	5.2	666-1
<B>	Exercise	action	5.3	667-1
<B>	Exercise	action	5.4	668-1
<B>	that	constraint	these selection operators	669-1
<B>	Show	action	these selection operators	669-1
these selection operators	can be simulated	action	atomic selection operators	669-1
these selection operators	using	action	atomic selection operators	669-1
atomic selection operators		sequential	union	669-1
union		sequential	intersect	669-1
intersect	and	conjunctive	difference	669-1
<B>	Exercise	action	5.5	670-1
<B>	Exercise	action	5.6	671-1
Exercises Exercise 5.7	Prove	action	Proposition 5.1.2	672-1
Proposition 5.1.2	that	constraint	the relational algebras	672-1
Proposition 5.1.2	and	conjunctive	the relational algebras	672-1
Proposition 5.1.2	named	action	the relational algebras	672-1
the relational algebras	have	action	equivalent expressive power	672-1
<B>	Exercise	action	5.8	673-1
<B>	Exercise	action	5.9	674-1
<B>	Exercise	action	5.10 Verify	675-1
5.10 Verify	that	constraint	each nr-datalog¬ program	675-1
each nr-datalog¬ program	with	constraint	equality	675-1
equality	by	constraint	one	675-1
equality	can be simulated	action	one	675-1
one	without	constraint	equality	675-1
Exercise		sequential	5.11	676-1
5.11	Prove	action	Proposition 5.2.2	676-1
Hint		sequential	Hint	676-2
Exercise		sequential	5.13	677-1
Exercise		sequential	5.14	678-1
<B>	Exercise	action	5.15	679-1
5.15	Verify	action	the claims	679-1
the claims	of	constraint	Example 5.3.9	679-1
Exercise		sequential	5.16	680-1
Exercise		sequential	5.17	681-1
Exercise		sequential	5.18	682-1
<B>	If	constraint	it	682-2
it	is	attribute	not domain	682-2
not domain	give	action	examples	682-2
examples	of	constraint	different domains	682-2
different domains	yielding	action	different answers	682-2
different answers	on	constraint	the same input	682-2
the same input	if	constraint	it	682-2
the same input	and	conjunctive	it	682-2
it	is	attribute	safe range	682-2
safe range	translate	action	it	682-2
it	into	constraint	the algebra	682-2
<B>	Exercise	action	5.20	683-1
5.20	Consider	action	the proof	683-1
the proof	of	constraint	Theorem 5.4.6	683-1
Exercise		sequential	5.21	684-1
Hint	Given	action	calculus query q	684-2
calculus query q	first build	action	a formula ξ	684-2
a formula ξ		sequential	adom	684-2
adom		sequential	x	684-2
x	that	constraint	I	684-2
I		sequential	ξ adom	684-2
ξ adom		sequential	x	684-2
x		sequential	ν	684-2
ν		sequential	ν	684-2
ν		sequential	x	684-2
x		sequential	iff ∈ adom	684-2
iff ∈ adom		sequential	q	684-2
q		sequential	I	684-2
<B>	Now perform	action	an induction	684-3
an induction	on	constraint	subformulas	684-3
j1		sequential	jl	685-1
jl		sequential	i1	685-1
i1		sequential	=a1	685-1
=a1		sequential	∧·	685-1
∧·	··∧ik=ak	sequential	where j1	685-1
∧·	{	sequential	where j1	685-1
<B>	.	sequential	<B>	685-2
<B>	.	sequential	<B>	685-3
jl	is	attribute	a listing	685-4
a listing	in	constraint	order	685-4
order	of	constraint	indexes	685-4
order	or	conjunctive	indexes	685-4
indexes	in	constraint	<B>	685-4
indexes	{ 1	sequential	<B>	685-4
<B>	.	sequential	<B>	685-5
<B>	.	sequential	<B>	685-6
<B>	n	conjunctive	}	685-7
}	{	sequential	i1	685-7
<B>	.	sequential	<B>	685-8
<B>	.	sequential	<B>	685-9
ik }		sequential	ik }	685-10
<B>	that	constraint	the special case	685-11
<B>	Note	action	the special case	685-11
the special case	of	constraint	gen 1	685-11
gen 1		sequential	b Exercises	685-11
b Exercises	is	attribute	a test	685-11
a test	of	constraint	I	685-11
a test	whether	constraint	I	685-11
I	is	attribute	nonempty	685-11
<B>	In	constraint	some research	685-12
some research	in	constraint	AI	685-12
AI		sequential	the primitive mechanism	685-12
the primitive mechanism	for	constraint	relations	685-12
the primitive mechanism	accessing	action	relations	685-12
relations	on	constraint	generators	685-12
relations	is based	action	generators	685-12
generators		sequential	that	685-12
that	as	constraint	a stream	685-12
that	are viewed	action	a stream	685-12
that	producing	action	a stream	685-12
a stream	of	constraint	tuples	685-12
tuples	as	constraint	output	685-12
<B>	For	constraint	example	685-13
example		sequential	the query x	685-13
the query x		sequential	y	685-13
y		sequential	z	685-13
z		sequential	R	685-13
R		sequential	x	685-13
x		sequential	y	685-13
y		sequential	∧ S	685-13
∧ S		sequential	y	685-13
y		sequential	z	685-13
z	can be computed	action	the algorithm	685-13
z	using	action	the algorithm	685-13
the algorithm	for	constraint	each tuple x	685-13
each tuple x		sequential	y	685-13
y	by	constraint	gen	685-13
y	generated	action	gen	685-13
gen		sequential	1	685-13
1		sequential	x,2	685-13
x,2		sequential	y	685-13
y		sequential	R	685-13
R	for	constraint	each value z	685-13
each value z	by	constraint	gen	685-13
each value z	generated	action	gen	685-13
gen		sequential	1	685-13
1		sequential	y	685-13
y		sequential	S	685-13
S		sequential	output	685-13
output		sequential	y	685-13
y		sequential	x z end	685-13
x z end	for	constraint	each end	685-13
each end	for	constraint	each an algorithm	685-13
each end	Develop	action	each an algorithm	685-13
each an algorithm	for	constraint	calculus queries	685-13
each an algorithm	translating	action	calculus queries	685-13
calculus queries	into	constraint	programs	685-13
programs	using	action	generators	685-13
<B>	Describe	action	syntactic restrictions	686-1
syntactic restrictions	on	constraint	the calculus	686-1
the calculus		sequential	that	686-1
that	that	constraint	your algorithm	686-1
that	ensure	action	your algorithm	686-1
your algorithm	succeeds	action	<B>	686-1
<B>	Give	action	a formal definition	687-1
a formal definition	for	constraint	the syntax	687-1
the syntax	of	constraint	the tuple calculus	687-1
the tuple calculus	for	constraint	the relativized interpretation	687-1
the tuple calculus	and	conjunctive	the relativized interpretation	687-1
the relativized interpretation		sequential	active domain	687-1
active domain	and	conjunctive	domain	687-1
domain		sequential	semantics	687-1
<B>	Develop	action	an analog	687-2
an analog	of	constraint	safe range	687-2
<B>	Prove	action	the equivalence	687-3
the equivalence	of	constraint	conventional calculus	687-3
conventional calculus	and	conjunctive	tuple calculus	687-3
tuple calculus	under	constraint	these semantics	687-3
tuple calculus	of	constraint	these semantics	687-3
Exercise		sequential	5.24	688-1
gen		sequential	x	689-1
x	if	constraint	ϕ	689-1
ϕ	ϕ =	sequential	R	689-1
R		sequential	u	689-1
u	for	constraint	R ∈ R	689-1
R ∈ R	and	conjunctive	x ∈	689-1
x ∈		sequential	some free gen	689-1
some free gen		sequential	x	689-1
x		sequential	¬ϕ	689-1
¬ϕ	if	constraint	gen	689-1
gen		sequential	x pushnot	689-1
x pushnot		sequential	¬ϕ	689-1
¬ϕ		sequential	gen	689-1
gen		sequential	x	689-1
x	if	constraint	x	689-1
x		sequential	y	689-1
y	and	conjunctive	gen	689-1
y	are	attribute	distinct	689-1
gen		sequential	x	689-1
x		sequential	ϕ	689-1
ϕ		sequential	gen	689-1
gen		sequential	x	689-1
x	if	constraint	x	689-1
x		sequential	y	689-1
y	and	conjunctive	gen	689-1
y	are	attribute	distinct	689-1
gen		sequential	x	689-1
x		sequential	ϕ	689-1
ϕ		sequential	gen	689-1
gen		sequential	x	689-1
x		sequential	∨	689-1
∨		sequential	ψ	689-1
ψ	if	constraint	gen	689-1
gen		sequential	x	689-1
x	and	conjunctive	gen	689-1
gen		sequential	x ψ	689-1
x ψ		sequential	gen	689-1
gen		sequential	x	689-1
x		sequential	∧	689-1
∧		sequential	ψ	689-1
ψ	if	constraint	gen	689-1
gen		sequential	x	689-1
x	or	conjunctive	gen	689-1
gen		sequential	x	689-1
x		sequential	ψ	689-1
ψ		sequential	pushnot	689-1
pushnot		sequential	¬ϕ	689-1
¬ϕ	in	constraint	the natural manner	689-1
¬ϕ	is defined	action	the natural manner	689-1
the natural manner	to	constraint	the result	689-1
the natural manner	be	attribute	the result	689-1
the result	of	constraint	the negation	689-1
the result	pushing	action	the negation	689-1
the negation	into	constraint	the next highest level logical connective	689-1
the next highest level logical connective	with	constraint	consecutive negations	689-1
consecutive negations	unless	constraint	an atom	689-1
consecutive negations	cancelling	attribute	each other	689-1
consecutive negations	is	attribute	an atom	689-1
an atom	using	action	the rewrite rules	689-1
the rewrite rules		sequential	5	689-1
5		sequential	6	689-1
6		sequential	7	689-1
7		sequential	10	689-1
10	and	conjunctive	11	689-1
11	from	constraint	Fig	689-1
5.1		sequential	5.1	689-2
A formula	is allowed	action	<B>	689-3
<B>	In	constraint	VanGT91	690-1
VanGT91		sequential	EHJ93	690-1
EHJ93		sequential	a translation	690-1
a translation	of	constraint	allowed formulas	690-1
allowed formulas	into	constraint	the algebra	690-1
the algebra	is presented	action	<B>	690-1
<B>	with	constraint	DNF matrix	691-1
<B>	be	attribute	DNF matrix	691-1
DNF matrix	using	action	the rewrite rules	691-1
the rewrite rules	of	constraint	Fig	691-1
5.1	and	conjunctive	ϕ	691-2
5.1	let	action	ϕ	691-2
ϕ		sequential	CNF	691-2
CNF	be	attribute	similarly the result	691-2
similarly the result	of	constraint	ϕ	691-2
similarly the result	transforming	action	ϕ	691-2
ϕ	into	constraint	PNF	691-2
PNF	with	constraint	CNF matrix	691-2
The query q		sequential	range	691-3
range	if	constraint	each free variable x	691-3
range	is restricted	action	each free variable x	691-3
each free variable x	in	constraint	x	691-3
each free variable x	in	constraint	x	691-3
each free variable x	than	constraint	x	691-3
each free variable x	i occurs	attribute	a positive literal	691-3
x	=	sequential	y	691-3
y	in	constraint	every Di	691-3
every Di		sequential	each existentially quantified variable x	691-3
each existentially quantified variable x	in	constraint	DNF	691-3
DNF	in	constraint	x	691-3
DNF	than	constraint	x	691-3
DNF	ii occurs	attribute	a positive literal	691-3
x	other =	sequential	y	691-3
y	in	constraint	<B>	691-3
<B>	Prove	action	range	692-1
range	restricted	action	that queries	692-1
that queries	are	attribute	domain	692-1
domain		sequential	<B>	692-1
<B>	In	constraint	VanGT91	692-2
VanGT91		sequential	a translation	692-2
a translation	of	constraint	range	692-2
range	restricted	action	the queries	692-2
the queries	into	constraint	the algebra	692-2
the algebra	is presented	action	<B>	692-2
Exercise		sequential	5.27	693-1
5.27		sequential	q1	693-1
q1	=	sequential	{ x	693-1
{ x		sequential	∀y	693-1
∀y		sequential	R	693-1
R		sequential	100 y	693-1
100 y	→	sequential	S	693-1
S		sequential	x	693-1
x		sequential	y	693-1
y		sequential	}	693-1
}		sequential	q2	693-1
q2	=	sequential	∃x∀y	693-1
q2	{	sequential	∃x∀y	693-1
∃x∀y		sequential	R	693-1
R		sequential	100	693-1
100		sequential	y	693-1
y	→	sequential	S	693-1
S		sequential	x	693-1
x		sequential	y	693-1
Exercise		sequential	5.28	694-1
<B>	Write	action	algebra	695-1
algebra	and	conjunctive	calculus	695-1
calculus		sequential	queries	695-1
queries		sequential	that	695-1
that	express	action	this query	695-1
Exercise		sequential	5.29	696-1
<B>	Let	action	I1	696-2
I1	=	sequential	9x2	696-2
9x2	+	sequential	4x	696-2
Exercises		sequential	whose semantics	697-1
whose semantics	to	constraint	semd	697-1
whose semantics	are	attribute	equal	697-1
semd		sequential	t	697-1
<B>	Exercise	action	5.32 domn	698-1
5.32 domn	−	sequential	I	698-1
The analogous operator	for	constraint	the named algebra	698-2
The analogous operator	is defined	action	the named algebra	698-2
<B>	that	constraint	the calculus	698-3
<B>	Prove	action	the calculus	698-3
the calculus	under	constraint	the natural interpretation	698-3
the natural interpretation	to	constraint	the algebra	698-3
the natural interpretation	is	attribute	equivalent	698-3
the algebra	with	constraint	operators	698-3
operators		sequential	σ	698-3
σ		sequential	π	698-3
π		sequential	×	698-3
×		sequential	∪	698-3
∪		sequential	c	698-3
c	}	sequential	<B>	698-3
The query	over	constraint	R	699-1
The query	even is defined	action	R	699-1
R	as	constraint	even I	699-1
R	follows	action	even I	699-1
even I	=	sequential	}	699-1
}	if	constraint	I	699-1
I	and	conjunctive	I	699-1
I	is even	action	I	699-1
I	even = otherwise	sequential	}	699-1
}		sequential	<B>	699-1
Exercise		sequential	5.35	700-1
<B>	For	constraint	a Boolean algebra	701-1
a Boolean algebra	define	action	≤ y	701-1
≤ y	to	constraint	∧	701-1
≤ y	mean	action	∧	701-1
∧		sequential	y	701-1
y	=	sequential	x	701-1
<B>	Let dij	action	the diagonals	702-1
the diagonals	by	constraint	the statement	702-1
the diagonals	be defined	action	the statement	702-1
the statement	for	constraint	each i	702-1
each i		sequential	j	702-1
j		sequential	dij	702-1
dij	=	sequential	σ	702-1
σ		sequential	A	702-1
A		sequential	Cn	702-1
Cn	and	conjunctive	the i	702-1
Cn	let	action	the i	702-1
the i		sequential	Aj ith cylinder Ci	702-1
Aj ith cylinder Ci	for	constraint	I	702-1
Aj ith cylinder Ci	be defined	attribute	each	702-1
I	by	constraint	the statement	702-1
the statement		sequential	CiI	702-1
CiI	is	attribute	the relation	702-1
the relation	over	constraint	RC	702-1
RC	by	constraint	CiI	702-1
RC	defined	action	CiI	702-1
CiI	=	sequential	t	702-1
t		sequential	π	702-1
π		sequential	A	702-1
A		sequential	i	702-1
i		sequential	∈ C }	702-1
h		sequential	R2	703-1
R2	if	constraint	A1 ∈ sort	703-1
R2	and	conjunctive	A1 ∈ sort	703-1
A1 ∈ sort		sequential	R	703-1
R		sequential	h	703-1
h		sequential	π A	703-1
π A		sequential	R	703-1
R	2 =	sequential	C	703-1
Optimization		sequential	Optimization	704-1
Riccardo		sequential	Riccardo	705-1
Vittorio		sequential	Vittorio	706-1
<B>	.	sequential	<B>	706-2
<B>	.	sequential	<B>	706-3
Sergio		sequential	Sergio	707-1
This chapter	and	conjunctive	first order	708-1
This chapter	examines	attribute	conjunctive	708-1
first order		sequential	the queries	708-1
the queries	from	constraint	the perspective	708-1
the perspective	of	constraint	static analysis	708-1
static analysis	in	constraint	the sense	708-1
the sense	of	constraint	programming languages	708-1
It	that	constraint	many properties	708-2
It	is shown	action	many properties	708-2
many properties	of	constraint	conjunctive queries	708-2
conjunctive queries		sequential	e.g. equivalence	708-2
e.g. equivalence		sequential	containment	708-2
containment	although	constraint	they	708-2
containment	are	attribute	decidable	708-2
they	for	constraint	first order	708-2
they	are	attribute	not decidable	708-2
first order		sequential	queries	708-2
Static analysis techniques	in	constraint	connection	708-3
Static analysis techniques	are also applied here	action	connection	708-3
connection	with	constraint	query optimization	708-3
query optimization	transforming	action	queries	708-3
queries	in	constraint	high level	708-3
queries	expressed	action	high level	708-3
high level		sequential	a largely declarative language	708-3
a largely declarative language	into	constraint	equivalent queries	708-3
equivalent queries	or	conjunctive	machine instruction programs	708-3
machine instruction programs		sequential	that	708-3
that	than	constraint	a naive execution	708-3
that	are	attribute	arguably more efficient	708-3
a naive execution	of	constraint	the initial query	708-3
<B>	To	constraint	background	709-1
<B>	provide	action	background	709-1
background		sequential	this chapter	709-1
this chapter	with	constraint	a survey	709-1
this chapter	begins	action	a survey	709-1
a survey	of	constraint	practical optimization techniques	709-1
practical optimization techniques	for	constraint	the conjunctive queries	709-1
The majority	of	constraint	practically oriented research	709-2
practically oriented research	and	conjunctive	development	709-2
development	on	constraint	query optimization	709-2
query optimization	on	constraint	variants	709-2
query optimization	has been focused	action	variants	709-2
variants	of	constraint	the conjunctive queries	709-2
the conjunctive queries	with	constraint	arithmetic operators	709-2
the conjunctive queries	possibly extended	action	arithmetic operators	709-2
arithmetic operators	and	conjunctive	comparators	709-2
<B>	Because of	constraint	the myriad factors	709-3
the myriad factors		sequential	that	709-3
that	play	action	a role	709-3
a role	in	constraint	query evaluation	709-3
query evaluation		sequential	most practically successful techniques	709-3
most practically successful techniques	on	constraint	heuristics	709-3
most practically successful techniques	rely heavily	action	heuristics	709-3
the chapter	and	conjunctive	the Homomorphism Theorem	710-1
the chapter	Next presents	attribute	elegant	710-1
the Homomorphism Theorem		sequential	which	710-1
which	characterizes	action	containment	710-1
containment	and	conjunctive	equivalence	710-1
equivalence	between	constraint	conjunctive queries	710-1
<B>	to	constraint	the notion	710-2
<B>	leads	action	the notion	710-2
the notion	of	constraint	tableau	710-2
tableau		sequential	minimization	710-2
<B>	provides	action	a theoretical notion	710-3
a theoretical notion	of	constraint	true optimality	710-3
true optimality	for	constraint	conjunctive queries	710-3
It	that	constraint	these properties	710-4
It	is also shown	action	these properties	710-4
It	deciding	action	these properties	710-4
these properties	and	conjunctive	conjunctive queries	710-4
these properties	minimizing	action	conjunctive queries	710-4
conjunctive queries	is	attribute	np	710-4
np	in	constraint	the size	710-4
the size	of	constraint	the input queries	710-4
Undecidability results	for	constraint	first order	711-1
Undecidability results	are presented	action	first order	711-1
first order		sequential	the queries	711-1
<B>	Although	constraint	undecidability results	711-2
<B>	to	constraint	undecidability results	711-2
undecidability results	for	constraint	first order	711-2
first order		sequential	conventional logic	711-2
conventional logic		sequential	the proof techniques	711-2
the proof techniques	because	constraint	all instances	711-2
the proof techniques	used here	attribute	necessarily different	711-2
the proof techniques	are	attribute	necessarily different	711-2
all instances	by	constraint	definition	711-2
all instances	considered	attribute	finite	711-2
all instances	are	attribute	finite	711-2
The undecidability results	that	constraint	there	711-3
The undecidability results	imply	action	there	711-3
there	is	attribute	no hope	711-3
no hope	of	constraint	an algorithm	711-3
no hope	developing	action	an algorithm	711-3
an algorithm		sequential	that	711-3
that	performs	action	optimization	711-3
optimization	of	constraint	order	711-3
order		sequential	queries	711-3
queries		sequential	that	711-3
that	is	attribute	complete	711-3
Only limited optimization	of	constraint	order	711-4
order		sequential	queries	711-4
queries	involving	action	difference	711-4
difference	in	constraint	most systems	711-4
difference	is provided	action	most systems	711-4
The chapter	by	constraint	a specialized subset	712-1
The chapter	to	constraint	a specialized subset	712-1
The chapter	closes	action	a specialized subset	712-1
The chapter	returning	action	a specialized subset	712-1
a specialized subset	of	constraint	the conjunctive queries	712-1
the conjunctive queries	on	constraint	acyclic	712-1
the conjunctive queries	based	action	acyclic	712-1
acyclic	joins	action	<B>	712-1
<B>	to	constraint	several interesting properties	712-2
<B>	have been shown	action	several interesting properties	712-2
<B>	enjoy	action	several interesting properties	712-2
several interesting properties		sequential	some yielding insight	712-2
some yielding insight	into	constraint	more efficient query processing	712-2
Chapter 13	in	constraint	Part D	713-1
Part D	examines	action	techniques	713-1
techniques	for	constraint	datalog queries	713-1
techniques	optimizing	action	datalog queries	713-1
Analysis	and	conjunctive	Optimization	714-1
Optimization		sequential	Static Issues	714-1
Static Issues	in	constraint	Practical Query Optimization Query optimization	714-1
Practical Query Optimization Query optimization	is	attribute	one	714-1
one	of	constraint	the central topics	714-1
the central topics	of	constraint	database systems	714-1
A myriad	of	constraint	factors	714-2
factors	play	action	a role	714-2
a role	in	constraint	this area	714-2
this area	including	action	storage	714-2
storage	and	conjunctive	indexing	714-2
indexing		sequential	techniques	714-2
techniques		sequential	page sizes	714-2
page sizes	and	conjunctive	paging protocols	714-2
paging protocols		sequential	the underlying operating system	714-2
the underlying operating system		sequential	statistical properties	714-2
statistical properties	of	constraint	the stored data	714-2
the stored data		sequential	statistical properties	714-2
statistical properties	of	constraint	anticipated queries	714-2
anticipated queries	and	conjunctive	updates	714-2
updates		sequential	implementations	714-2
implementations	of	constraint	specific operators	714-2
specific operators	and	conjunctive	the expressive power	714-2
the expressive power	of	constraint	the query languages	714-2
the query languages	to	constraint	<B>	714-2
the query languages	used	attribute	a few	714-2
the query languages	name	attribute	a few	714-2
Query optimization	at	constraint	all levels	714-3
Query optimization	can be performed	action	all levels	714-3
all levels	of	constraint	three level	714-3
three level		sequential	the database architecture	714-3
<B>	At	constraint	the physical level	714-4
the physical level		sequential	this work	714-4
this work	on	constraint	example	714-4
this work	for	constraint	example	714-4
this work	focuses	action	example	714-4
example		sequential	access techniques	714-4
access techniques		sequential	statistical properties	714-4
statistical properties	of	constraint	stored data	714-4
stored data	and	conjunctive	buffer management	714-4
<B>	At	constraint	a more logical level	714-5
a more logical level		sequential	algebraic equivalences	714-5
algebraic equivalences	to	constraint	queries	714-5
algebraic equivalences	are used	action	queries	714-5
algebraic equivalences	rewrite	action	queries	714-5
queries	into	constraint	forms	714-5
forms		sequential	that	714-5
that	can be implemented more efficiently	action	<B>	714-5
We	with	constraint	a discussion	715-1
We	begin now	action	a discussion	715-1
a discussion	of	constraint	rudimentary considerations	715-1
rudimentary considerations		sequential	that	715-1
that	affect	action	query processing	715-1
query processing	including	action	the usual cost measurements	715-1
the usual cost measurements	and	conjunctive	basic methods	715-1
basic methods	for	constraint	relations	715-1
basic methods	accessing	action	relations	715-1
relations	and	conjunctive	algebraic operators	715-1
relations	implementing	action	algebraic operators	715-1
an optimization approach	on	constraint	algebraic equivalences	715-2
an optimization approach	based	action	algebraic equivalences	715-2
algebraic equivalences	to	constraint	a given algebraic expression	715-2
algebraic equivalences	Next is described	attribute	this	715-2
algebraic equivalences	is used	action	a given algebraic expression	715-2
algebraic equivalences	replace	action	a given algebraic expression	715-2
a given algebraic expression	by	constraint	an equivalent one	715-2
an equivalent one		sequential	that	715-2
that	can typically be computed more quickly	action	<B>	715-2
<B>	to	constraint	the important notion	715-3
<B>	leads	action	the important notion	715-3
the important notion	of	constraint	query evaluation plans	715-3
query evaluation plans	and	conjunctive	they	715-3
they	in	constraint	modern systems	715-3
they	are used	action	modern systems	715-3
modern systems	to	constraint	many alternative implementations	715-3
modern systems	among	constraint	many alternative implementations	715-3
modern systems	and	conjunctive	many alternative implementations	715-3
modern systems	represent	action	many alternative implementations	715-3
modern systems	choose	action	many alternative implementations	715-3
many alternative implementations	of	constraint	a query	715-3
We	examine	action	intricate techniques	715-4
intricate techniques	for	constraint	multiway joins	715-4
intricate techniques	implementing	action	multiway joins	715-4
multiway joins	on	constraint	different orderings	715-4
multiway joins	based	action	different orderings	715-4
different orderings	of	constraint	binary joins	715-4
binary joins	on	constraint	join decomposition	715-4
binary joins	and	conjunctive	join decomposition	715-4
The discussion	in	constraint	this section	716-1
The discussion	presented	action	this section	716-1
this section	only scratches	action	the surface	716-1
the surface	of	constraint	the rich body	716-1
the rich body	of	constraint	research	716-1
the rich body	systems oriented	action	research	716-1
research	and	conjunctive	development	716-1
development	on	constraint	query optimizers	716-1
query optimizers	indicating	action	only a handful	716-1
only a handful	of	constraint	the most important factors	716-1
the most important factors		sequential	that	716-1
that	are involved	action	<B>	716-1
Nothing	about	constraint	several factors	716-2
Nothing	will be said	action	several factors	716-2
several factors		sequential	the impact	716-2
the impact	of	constraint	negation	716-2
negation	in	constraint	queries	716-2
queries		sequential	memory	716-2
memory		sequential	buffering strategies	716-2
buffering strategies	and	conjunctive	the implications	716-2
the implications	of	constraint	different environments	716-2
different environments	distributed	action	real time	716-2
different environments	object oriented	action	real time	716-2
real time		sequential	large main memory	716-2
large main memory	and	conjunctive	secondary memories	716-2
secondary memories	than	constraint	conventional disks	716-2
<B>	In	constraint	part	716-3
part	due to	constraint	the intricacy	716-3
the intricacy	and	conjunctive	number	716-3
number	of	constraint	interrelated factors	716-3
interrelated factors	of	constraint	the fundamental theoretical research	716-3
interrelated factors	involved	attribute	little	716-3
the fundamental theoretical research	on	constraint	query optimization	716-3
query optimization	has found	action	its way	716-3
its way	into	constraint	practice	716-3
<B>	As	constraint	the field	716-4
the field	is maturing	action	salient aspects	716-4
salient aspects	of	constraint	query optimization	716-4
query optimization	of	constraint	the foothold	716-4
query optimization	are becoming	attribute	isolated	716-4
query optimization	may provide	attribute	some	716-4
the foothold	for	constraint	significant theoretical work	716-4
the foothold	needed	action	significant theoretical work	716-4
significant theoretical work	to	constraint	<B>	716-4
significant theoretical work	and	conjunctive	<B>	716-4
significant theoretical work	emerge	action	<B>	716-4
significant theoretical work	be applied	action	<B>	716-4
The Physical Model		sequential	The Physical Model	717-1
Manipulation	of	constraint	the stored data	717-2
the stored data	including	action	the application	717-2
the application	of	constraint	algebraic operators	717-2
algebraic operators	requires	action	copies	717-2
algebraic operators	making	action	copies	717-2
copies	in	constraint	primary memory	717-2
primary memory	of	constraint	portions	717-2
portions	of	constraint	the stored data	717-2
the stored data	and	conjunctive	results	717-2
the stored data	and	conjunctive	results	717-2
the stored data	storing again	attribute	intermediate	717-2
results	in	constraint	secondary memory	717-2
<B>	By	constraint	the major time expense	717-3
the major time expense	in	constraint	query processing	717-3
query processing	for	constraint	processor	717-3
processor		sequential	a system	717-3
a system	is	attribute	the number	717-3
the number	of	constraint	disk pages	717-3
disk pages		sequential	that	717-3
that	in	constraint	primary memory	717-3
that	out	constraint	primary memory	717-3
that	of	constraint	primary memory	717-3
that	and	conjunctive	primary memory	717-3
that	must be swapped	action	primary memory	717-3
<B>	In	constraint	the case	717-4
the case	of	constraint	distributed systems	717-4
distributed systems		sequential	the communication costs	717-4
the communication costs	typically dominate	action	all others	717-4
all others	and	conjunctive	an important focus	717-4
all others	become	action	an important focus	717-4
an important focus	of	constraint	optimization	717-4
<B>	Viewed	attribute	a little	718-1
the physical level	of	constraint	relational query implementation	718-1
relational query implementation	involves	action	three basic activities	718-1
three basic activities	1 generating	action	streams	718-1
streams	of	constraint	tuples	718-1
tuples		sequential	2	718-1
2	manipulating	action	streams	718-1
streams	of	constraint	tuples	718-1
tuples	to	constraint	projections	718-1
tuples	perform	action	projections	718-1
projections	and	conjunctive	streams	718-1
projections	3 combining	action	streams	718-1
streams	of	constraint	tuples	718-1
tuples	to	constraint	joins	718-1
tuples	perform	action	joins	718-1
joins		sequential	unions	718-1
unions	and	conjunctive	intersections	718-1
Indexing methods	including	action	primarily B trees	718-2
primarily B trees	and	conjunctive	hash indexes	718-2
hash indexes	to	constraint	the size	718-2
hash indexes	can be used	action	the size	718-2
hash indexes	reduce significantly	action	the size	718-2
the size	of	constraint	some streams	718-2
<B>	Although	constraint	it	718-3
<B>	not discussed here	action	it	718-3
it	to	constraint	the cost	718-3
it	is	attribute	important	718-3
it	consider	action	the cost	718-3
the cost	of	constraint	indexes	718-3
the cost	maintaining	action	indexes	718-3
indexes	and	conjunctive	clusterings	718-3
clusterings	as	constraint	updates	718-3
updates	to	constraint	the database	718-3
the database	occur	action	<B>	718-3
<B>		sequential	memory	719-1
memory		sequential	buffering techniques	719-1
buffering techniques	including	action	the partitioning	719-1
the partitioning	of	constraint	main memory	719-1
main memory	into	constraint	segments	719-1
segments	and	conjunctive	paging	719-1
paging		sequential	policies	719-1
policies	deleting	action	pages	719-1
pages	on	constraint	policies	719-1
pages	based	action	policies	719-1
policies	of	constraint	use	719-1
use	and	conjunctive	most recent use	719-1
most recent use	can significantly impact	action	the number	719-1
the number	of	constraint	page	719-1
page	/	sequential	I Os	719-1
I Os	used	action	<B>	719-1
<B>	Speaking broadly	action	an evaluation plan	720-1
an evaluation plan	or	conjunctive	access plan	720-1
access plan	for	constraint	a query	720-1
a query		sequential	a stored database state	720-1
a stored database state	and	conjunctive	a collection	720-1
a collection	of	constraint	existing indexes	720-1
existing indexes	and	conjunctive	other data structures	720-1
other data structures	is	attribute	a specification	720-1
a specification	of	constraint	a sequence	720-1
a sequence	of	constraint	operations	720-1
operations		sequential	that	720-1
that	will compute	action	the answer	720-1
the answer	to	constraint	the query	720-1
The term evaluation plan	to	constraint	specifications	720-2
The term evaluation plan	to	constraint	specifications	720-2
The term evaluation plan	is used most often	action	specifications	720-2
The term evaluation plan	refer	action	specifications	720-2
specifications		sequential	that	720-2
that	at	constraint	a low physical level	720-2
that	are	attribute	a low physical level	720-2
a low physical level	for	constraint	level	720-2
a low physical level	but	conjunctive	level	720-2
a low physical level	may sometimes be used	attribute	higher	720-2
level		sequential	specifications	720-2
<B>	As	constraint	we	720-3
we	shall see	action	query optimizers	720-3
query optimizers	typically develop	action	several evaluation plans	720-3
several evaluation plans	and	conjunctive	one	720-3
several evaluation plans	choose	action	one	720-3
one	for	constraint	execution	720-3
Implementation	of	constraint	Algebraic Operators	721-1
Selection	in	constraint	a straightforward manner	722-1
Selection	can be realized	action	a straightforward manner	722-1
a straightforward manner	by	constraint	a scan	722-1
a scan	of	constraint	the argument relation	722-1
the argument relation	in	constraint	linear time	722-1
the argument relation	and	conjunctive	linear time	722-1
the argument relation	can thus be achieved	action	linear time	722-1
Access structures		sequential	B	722-2
B		sequential	tree	722-2
tree		sequential	indexes	722-2
indexes	or	conjunctive	hash tables	722-2
hash tables	to	constraint	the search time	722-2
hash tables	can be used	action	the search time	722-2
hash tables	reduce	action	the search time	722-2
the search time	to	constraint	the selected tuples	722-2
the search time	needed	action	the selected tuples	722-2
the search time	find	action	the selected tuples	722-2
<B>	In	constraint	the case	722-3
the case	of	constraint	selections	722-3
selections	with	constraint	single tuple output	722-3
single tuple output	permits	action	evaluation	722-3
evaluation	within	constraint	essentially constant time	722-3
essentially constant time	or	conjunctive	three	722-3
three		sequential	two page fetches	722-3
<B>	For	constraint	larger outputs	722-4
larger outputs		sequential	the selection	722-4
the selection	or	conjunctive	three	722-4
the selection	may take	action	three	722-4
three		sequential	two page fetches	722-4
two page fetches	per	constraint	output tuple	722-4
output tuple	if	constraint	the input relation	722-4
output tuple	can be improved significantly	action	the input relation	722-4
the input relation	so that	constraint	all tuples	722-4
the input relation	is clustered	action	all tuples	722-4
the input relation	stored	action	all tuples	722-4
all tuples	with	constraint	a given attribute value	722-4
a given attribute value	on	constraint	the disk pages	722-4
a given attribute value	or	conjunctive	the disk pages	722-4
a given attribute value	are	attribute	same	722-4
Projection	is	attribute	a bit	723-1
a bit	because	constraint	it	723-1
it	for	constraint	two essentially different operations	723-1
it	actually calls	action	two essentially different operations	723-1
two essentially different operations		sequential	tuple rewriting	723-1
tuple rewriting	and	conjunctive	elimination	723-1
tuple rewriting	duplicate	action	elimination	723-1
The tuple rewriting	by	constraint	tuples	723-2
The tuple rewriting	is typically accomplished	action	tuples	723-2
The tuple rewriting	bringing	action	tuples	723-2
tuples	into	constraint	primary memory	723-2
primary memory	and	conjunctive	them	723-2
primary memory	rewriting	action	them	723-2
them	with	constraint	coordinate values	723-2
coordinate values	as	constraint	<B>	723-2
coordinate values	for	constraint	<B>	723-2
coordinate values	and	conjunctive	<B>	723-2
coordinate values	permuted	action	<B>	723-2
coordinate values	removed	action	<B>	723-2
coordinate values	called	action	<B>	723-2
<B>	may yield	action	a listing	723-3
a listing	of	constraint	tuples	723-3
tuples		sequential	that	723-3
that	contains	action	duplicates	723-3
<B>	If	constraint	a pure relational algebra projection	723-4
a pure relational algebra projection	to	constraint	these duplicates	723-4
a pure relational algebra projection	is	attribute	these duplicates	723-4
a pure relational algebra projection	be implemented	action	these duplicates	723-4
these duplicates	must be removed	action	<B>	723-4
One strategy	for	constraint	the list	723-5
One strategy	involves	action	the list	723-5
One strategy	sorting	action	the list	723-5
the list	of	constraint	tuples	723-5
tuples	and	conjunctive	duplicates	723-5
tuples	removing	action	duplicates	723-5
duplicates	takes	action	time	723-5
time	on	constraint	the order	723-5
the order	of	constraint	log	723-5
the order	n	conjunctive	log	723-5
log	n	conjunctive	<B>	723-5
<B>	Because of	constraint	the potential expense	724-1
the potential expense	by	constraint	duplicate elimination	724-1
the potential expense	incurred	action	duplicate elimination	724-1
duplicate elimination		sequential	most practical relational languages	724-1
most practical relational languages	permit	action	duplicates	724-1
duplicates	in	constraint	results	724-1
duplicates	and	conjunctive	results	724-1
An explicit command		sequential	that	724-2
that	for	constraint	duplicate elimination	724-2
that	calls	action	duplicate elimination	724-2
duplicate elimination	is typically provided	action	<B>	724-2
<B>	in	constraint	Even languages	724-3
Even languages		sequential	that	724-3
that	support	action	a pure algebra	724-3
a pure algebra		sequential	it	724-3
it	to	constraint	duplicates	724-3
it	be	attribute	may more efficient	724-3
it	leave	action	duplicates	724-3
duplicates	in	constraint	intermediate results	724-3
intermediate results	and	conjunctive	duplicate elimination	724-3
intermediate results	perform once	action	duplicate elimination	724-3
duplicate elimination	as	constraint	a final step	724-3
The equi-join	than	constraint	selection	725-1
The equi-join	is	attribute	typically much more expensive	725-1
selection	or	conjunctive	projection	725-1
projection	because	constraint	two relations	725-1
two relations	are	attribute	involved	725-1
The following naive nested loop implementation	of	constraint	⊲⊳F	725-2
⊲⊳F	will take	action	time	725-2
time	on	constraint	the order	725-2
the order	of	constraint	the product n1	725-2
the product n1	×	constraint	n2	725-2
n2	of	constraint	the sizes	725-2
the sizes	of	constraint	the input relations I1	725-2
the input relations I1		sequential	I2	725-2
I2		sequential	Static Analysis	725-2
Static Analysis	and	conjunctive	Optimization J	725-2
Optimization J	for	constraint	each u	725-2
Optimization J	=	sequential	each u	725-2
Optimization J	∅	sequential	each u	725-2
each u	in	constraint	I1	725-2
I1	for	constraint	each v	725-2
each v	in	constraint	I2	725-2
I2	if	constraint	u	725-2
u	and	conjunctive	v	725-2
v	are	attribute	joinable	725-2
J	=	sequential	J	725-2
J		sequential	∪	725-2
∪	{	sequential	u	725-2
u		sequential	⊲⊳F	725-2
⊲⊳F		sequential	v	725-2
v		sequential	}	725-2
<B>	by	constraint	the algorithm	726-1
<B>	Typically can be improved	action	the algorithm	726-1
<B>	using	action	the algorithm	726-1
<B>	sort merge	action	the algorithm	726-1
the algorithm		sequential	which	726-1
which	both	conjunctive	inputs	726-1
which	independently sorts	action	inputs	726-1
inputs	according to	action	the join attributes	726-1
the join attributes	and	conjunctive	a simultaneous scan	726-1
the join attributes	performs	action	a simultaneous scan	726-1
a simultaneous scan	of	constraint	both relations	726-1
both relations	outputting join	action	tuples	726-1
tuples	as	constraint	<B>	726-1
tuples	discovered	action	<B>	726-1
<B>	reduces	action	the running time	726-2
the running time	to	constraint	the order	726-2
the order	of	constraint	max	726-2
max	n	conjunctive	1 log n1	726-2
1 log n1	n	conjunctive	2 log n2	726-2
1 log n1	+	sequential	2 log n2	726-2
2 log n2		sequential	size	726-2
size	of	constraint	output	726-2
<B>	In	constraint	many cases	727-1
many cases		sequential	a more efficient implementation	727-1
a more efficient implementation	of	constraint	join	727-1
join	by	constraint	a variant	727-1
join	can be accomplished	action	a variant	727-1
a variant	of	constraint	the foregoing nested loop algorithm	727-1
the foregoing nested loop algorithm		sequential	that	727-1
that	uses	action	indexes	727-1
<B>	In	constraint	the inner loop	727-2
<B>	replace	action	the inner loop	727-2
the inner loop	by	constraint	indexed retrievals	727-2
indexed retrievals	to	constraint	tuples	727-2
tuples	of	constraint	I2	727-2
I2		sequential	that	727-2
that	match	action	the tuple	727-2
the tuple	of	constraint	I1	727-2
I1	under	constraint	consideration	727-2
Cross -product	in	constraint	isolation	728-1
isolation	is	attribute	perhaps the most expensive algebra operation	728-1
<B>	In	constraint	practice	728-2
practice	arises only rarely	action	it	728-2
it	that	constraint	selection conditions	728-2
it	is	attribute	much more common	728-2
selection conditions	on	constraint	the cross product	728-2
the cross product	to	constraint	it	728-2
the cross product	can be used	action	it	728-2
the cross product	transform	action	it	728-2
it	into	constraint	some form	728-2
some form	of	constraint	join	728-2
Query Trees	and	conjunctive	Query Rewriting	729-1
We	present	action	shortly a family	730-1
shortly a family	of	constraint	rewriting rules	730-1
rewriting rules		sequential	that	730-1
that	illustrates	action	the general flavor	730-1
the general flavor	of	constraint	this component	730-1
this component	of	constraint	query optimizers	730-1
query optimizers	see	action	Fig	730-1
6.2		sequential	6.2	730-2
<B>	Unlike	constraint	true optimizers	730-3
true optimizers		sequential	the rules	730-3
the rules	on	constraint	the algebra	730-3
the rules	presented here	action	the algebra	730-3
the rules	however focus exclusively	action	the algebra	730-3
we	Later examine	action	the larger issue	730-4
the larger issue	of	constraint	rules	730-4
rules	to	constraint	evaluation plans	730-4
rules	and	conjunctive	evaluation plans	730-4
rules	how are used	attribute	optimal	730-4
rules	find	attribute	optimal	730-4
We	shall use	action	the SPC algebra	731-1
the SPC algebra	by	constraint	positive conjunctive selection	731-1
the SPC algebra	generalized	action	positive conjunctive selection	731-1
the SPC algebra	permitting	action	positive conjunctive selection	731-1
positive conjunctive selection	and	conjunctive	equi-join	731-1
A central concept	of	constraint	query tree	731-2
A central concept	used	attribute	that	731-2
A central concept	is	attribute	that	731-2
query tree		sequential	which	731-2
which	is	attribute	essentially the parse tree	731-2
essentially the parse tree	of	constraint	an algebraic expression	731-2
<B>	Consider again	action	Query	731-3
Query		sequential	4.4	731-3
4.4	as	constraint	a rule	731-3
4.4	expressed here	action	a rule	731-3
a rule		sequential	ans	731-3
ans		sequential	xth	731-3
xth		sequential	xad	731-3
xad		sequential	Movies	731-3
Movies		sequential	xti	731-3
xti		sequential	Bergman	731-3
Bergman		sequential	xac	731-3
xac		sequential	Pariscope	731-3
Pariscope		sequential	xth	731-3
xth		sequential	xti	731-3
xti		sequential	xs	731-3
xs		sequential	Location	731-3
Location		sequential	xth	731-3
xth		sequential	xad	731-3
xad		sequential	xp	731-3
q1	=	sequential	π 4,8σ2=	732-1
π 4,8σ2=		sequential	Bergman	732-1
Bergman		sequential	Movies ⊲ ⊳1=2 Pariscope	732-1
Movies ⊲ ⊳1=2 Pariscope	⊲	sequential	⊳4=1 Location	732-1
Location Location		sequential	Pariscope Movies	733-1
Pariscope Movies		sequential	Pariscope Movies	733-1
Pariscope Movies		sequential	Figure	733-1
Figure		sequential	6.1	733-1
6.1		sequential	Two query trees	733-1
Two query trees	for	constraint	Query	733-1
Query		sequential	4.4	733-1
4.4	from	constraint	Chapter 4	733-1
6.1		sequential	<B>	733-2
<B>	To	constraint	a rough idea	734-1
<B>	provide	action	a rough idea	734-1
a rough idea	of	constraint	evaluation costs	734-1
evaluation costs	that	constraint	Movies	734-1
evaluation costs	how might be estimated	action	Movies	734-1
evaluation costs	suppose now	action	Movies	734-1
Movies	has	action	10,000 tuples	734-1
10,000 tuples	with	constraint	about 5 tuples	734-1
about 5 tuples	per	constraint	movie	734-1
movie		sequential	Pariscope	734-1
Pariscope	has	action	about 200 tuples	734-1
about 200 tuples	and	conjunctive	Location	734-1
Location	has	action	about 100 tuples	734-1
<B>	that	constraint	each relation	734-2
<B>	in	constraint	each relation	734-2
<B>	Suppose	attribute	further	734-2
each relation		sequential	there	734-2
there	are	attribute	about 50 tuples	734-2
about 50 tuples	per	constraint	page	734-2
page	that	constraint	no indexes	734-2
page	and	conjunctive	no indexes	734-2
no indexes	are	attribute	available	734-2
<B>	Under	constraint	a naive evaluation	735-1
a naive evaluation	of	constraint	q1	735-1
q1		sequential	an intermediate result	735-1
an intermediate result	for	constraint	each internal node	735-1
an intermediate result	would be produced	action	each internal node	735-1
each internal node	of	constraint	q1	735-1
q1		sequential	query tree	735-1
<B>	In	constraint	this example	735-2
this example		sequential	the join	735-2
the join	of	constraint	Movies	735-2
Movies	and	conjunctive	Pariscope	735-2
Pariscope	×	sequential	5	735-2
Pariscope	would produce	action	5	735-2
5	=	sequential	about 200 1000 tuples	735-2
about 200 1000 tuples		sequential	which	735-2
which	as	constraint	the input tuples	735-2
which	being	attribute	about twice as wide	735-2
the input tuples	will occupy	action	about 40 pages	735-2
The second equi-join	will yield	action	about 1000 tuples	735-3
about 1000 tuples		sequential	that	735-3
that	fit	action	18	735-3
18	to	constraint	a page	735-3
a page	thus occupying	action	about 55 pages	735-3
<B>	that	constraint	there	735-4
<B>	Assuming	action	there	735-4
there	are	attribute	four Bergman films	735-4
four Bergman films	in	constraint	two	735-4
four Bergman films	or	conjunctive	two	735-4
four Bergman films	playing	action	two	735-4
two		sequential	one theaters each	735-4
one theaters each		sequential	the final answer	735-4
the final answer	will contain	action	about six tuples	735-4
The total number	of	constraint	page fetches	736-1
page fetches	is	attribute	about 206	736-1
page fetches	performed here	action	about 206	736-1
about 206	for	constraint	the input relations	736-1
about 206	reading	action	the input relations	736-1
the input relations	that	constraint	no indexes	736-1
the input relations	assuming	action	no indexes	736-1
no indexes	and	conjunctive	95	736-1
no indexes	are	attribute	available	736-1
95	for	constraint	the intermediate relations	736-1
95	with	constraint	the intermediate relations	736-1
95	working	action	the intermediate relations	736-1
<B>	Consider now	action	the query q2	737-1
the query q2		sequential	whose query tree	737-1
whose query tree	in	constraint	Fig	737-1
whose query tree	is illustrated	action	Fig	737-1
6.1		sequential	<B>	737-2
It	that	constraint	q1	737-3
It	to	constraint	q1	737-3
It	is easily verified	attribute	this	737-3
It	is	attribute	equivalent	737-3
q2	from	constraint	q1	737-4
q2	Intuitively was formed	action	q1	737-4
q1	by	constraint	selections	737-4
q1	pushing	action	selections	737-4
selections	and	conjunctive	projections	737-4
projections	down	constraint	the tree	737-4
the tree	as	constraint	the size	737-4
the tree	generally reduces	action	the size	737-4
the size	of	constraint	intermediate results	737-4
intermediate results	of	constraint	thus computing	737-4
intermediate results	and	conjunctive	thus computing	737-4
thus computing	with	constraint	them	737-4
Static Analysis	and	conjunctive	Optimization	738-1
<B>	with	constraint	Pariscope	738-2
<B>	Joining	action	Pariscope	738-2
Pariscope	will yield	action	about six tuples	738-2
about six tuples	and	conjunctive	the final join	738-2
the final join	with	constraint	Location	738-2
Location	will again yield	action	six tuples	738-2
only one page	to	constraint	the intermediate results	738-3
only one page	Thus is needed	action	the intermediate results	738-3
only one page	hold	action	the intermediate results	738-3
the intermediate results	during	constraint	this evaluation	738-3
the intermediate results	constructed	action	this evaluation	738-3
this evaluation		sequential	a considerable savings	738-3
a considerable savings	over	constraint	the 95 pages	738-3
the 95 pages	by	constraint	the previous one	738-3
the 95 pages	needed	action	the previous one	738-3
It	to	constraint	several algebraic operators	739-1
It	is	attribute	often beneficial	739-1
It	combine	action	several algebraic operators	739-1
several algebraic operators	into	constraint	a single implemented operation	739-1
<B>	As	constraint	a general rule	739-2
a general rule	of	constraint	thumb	739-2
thumb		sequential	it	739-2
it	to	constraint	the inputs	739-2
it	is	attribute	typical	739-2
it	materialize	action	the inputs	739-2
the inputs	of	constraint	each equi-join	739-2
The equi-join itself	and	conjunctive	all unary operations	739-3
all unary operations	above	constraint	directly it	739-3
directly it	in	constraint	the query tree	739-3
the query tree	before	constraint	output	739-3
the query tree	are performed	action	output	739-3
The dashed ovals	of	constraint	Fig	739-4
6.1	b illustrate	action	a natural grouping	739-5
a natural grouping		sequential	that	739-5
that	for	constraint	this tree	739-5
that	can be used	action	this tree	739-5
<B>	In	constraint	practical systems	739-6
practical systems		sequential	the implementation	739-6
the implementation	and	conjunctive	grouping	739-6
grouping	of	constraint	operators	739-6
operators	in	constraint	much finer detail	739-6
operators	is typically considered	action	much finer detail	739-6
The use	of	constraint	different query trees	740-1
different query trees	and	conjunctive	different evaluation plans	740-1
different evaluation plans	can yield	action	dramatically different costs	740-1
dramatically different costs	in	constraint	the evaluation	740-1
the evaluation	of	constraint	equivalent queries	740-1
<B>	that	constraint	the user	740-2
<B>	Does mean	action	the user	740-2
the user	to	constraint	queries	740-2
the user	in	constraint	queries	740-2
the user	will have	attribute	extremely careful	740-2
the user	be	attribute	extremely careful	740-2
the user	expressing	action	queries	740-2
The beauty	of	constraint	query optimization	740-3
query optimization	that	constraint	the answer	740-3
query optimization	is	attribute	the answer	740-3
the answer	is	attribute	a resounding	740-3
The user	may choose	action	any representation	740-4
any representation	of	constraint	a query	740-4
a query	and	conjunctive	the system	740-4
the system	for	constraint	several equivalent evaluation plans	740-4
the system	be	attribute	will responsible	740-4
the system	generating	action	several equivalent evaluation plans	740-4
several equivalent evaluation plans	and	conjunctive	the least expensive one	740-4
several equivalent evaluation plans	choosing	action	the least expensive one	740-4
<B>	For	constraint	this reason	740-5
this reason	though	constraint	the relational algebra	740-5
the relational algebra	is	attribute	even conceptually procedural	740-5
it	as	constraint	an essentially declarative language	740-5
it	is implemented	action	an essentially declarative language	740-5
<B>	In	constraint	the case	741-1
the case	of	constraint	the algebra	741-1
the algebra		sequential	the generation	741-1
the generation	of	constraint	evaluation plans	741-1
evaluation plans	on	constraint	the existence	741-1
evaluation plans	is typically based	action	the existence	741-1
the existence	of	constraint	rules	741-1
rules	for	constraint	algebraic expressions	741-1
rules	transforming	action	algebraic expressions	741-1
algebraic expressions	into	constraint	equivalent ones	741-1
We	have already seen	action	rules	741-2
We	rewrite	action	rules	741-2
rules	in	constraint	the context	741-2
the context	of	constraint	SPC	741-2
the context	transforming	action	SPC	741-2
SPC	and	conjunctive	SPJR	741-2
SPJR		sequential	expressions	741-2
expressions	into	constraint	normal form	741-2
normal form	see	action	Propositions 4.4.2	741-2
Propositions 4.4.2	and	conjunctive	4.4.6	741-2
A different set	of	constraint	rules	741-3
rules	in	constraint	the present context	741-3
rules	is	attribute	useful	741-3
the present context	due to	constraint	the focus	741-3
the focus	on	constraint	the execution time	741-3
the focus	optimizing	action	the execution time	741-3
the execution time	and	conjunctive	space requirements	741-3
<B>	In	constraint	Fig	742-1
we	6.2 present	action	a family	742-2
a family	of	constraint	representative	742-2
representative	rewrite	action	rules	742-2
rules		sequential	three	742-2
three	with	constraint	inverses	742-2
inverses		sequential	that	742-2
that	for	constraint	the transformations	742-2
that	can be used	action	the transformations	742-2
that	performing	action	the transformations	742-2
the transformations	for	constraint	optimization	742-2
the transformations	needed	action	optimization	742-2
optimization	at	constraint	the logical level	742-2
<B>	In	constraint	these rules	743-1
these rules		sequential	we	743-1
we	view	action	cross-product	743-1
cross-product	as	constraint	a special case	743-1
a special case	of	constraint	equi-join	743-1
equi-join	in	constraint	which	743-1
which		sequential	the selection formula	743-1
the selection formula	is	attribute	empty	743-1
<B>	Because of	constraint	their similarity	743-2
their similarity	to	constraint	the rules	743-2
the rules	for	constraint	the normal form results	743-2
the rules	used	action	the normal form results	743-2
the normal form results	of	constraint	the rules	743-2
the rules	in	constraint	only abstract form	743-2
the rules	are shown	action	only abstract form	743-2
only abstract form		sequential	detailed formulation	743-2
detailed formulation	of	constraint	verification	743-2
verification	of	constraint	their soundness	743-2
their soundness	for	constraint	the reader	743-2
their soundness	is left	action	the reader	743-2
the reader	see	action	Exercise 6.1	743-2
We	also include	action	the following rule	743-3
the following rule		sequential	Simplify	743-3
Simplify		sequential	identities	743-3
identities	replace	action	π	743-3
π		sequential	1	743-3
1		sequential	arity	743-3
arity		sequential	q	743-3
q		sequential	q	743-3
q	by	constraint	q	743-3
q		sequential	replace	743-3
replace		sequential	σi=iq	743-3
σi=iq	by	constraint	q	743-3
q		sequential	replace q	743-3
replace q		sequential	×	743-3
×		sequential	}	743-3
}	by	constraint	q	743-3
q		sequential	replace	743-3
replace		sequential	q	743-3
q		sequential	×	743-3
×		sequential	}	743-3
}	by	constraint	}	743-3
}	and	conjunctive	q ⊳1=1	743-3
}	replace	action	q ⊳1=1	743-3
q ⊳1=1		sequential	arity	743-3
arity		sequential	q	743-3
q	=	sequential	arity	743-3
arity		sequential	q	743-3
q		sequential	q	743-3
q	by	constraint	q	743-3
<B>	between	constraint	Evaluation Plans j k l l l F ′	744-1
<B>	and	conjunctive	Evaluation Plans j k l l l F ′	744-1
<B>	Generating	action	Evaluation Plans j k l l l F ′	744-1
<B>	Choosing	action	Evaluation Plans j k l l l F ′	744-1
Evaluation Plans j k l l l F ′		sequential	q	744-1
q		sequential	q1	744-1
q1		sequential	⊲⊳	744-1
⊲⊳		sequential	q2	744-1
q2		sequential	q2 ⊲⊳ q1	744-1
q2 ⊲⊳ q1		sequential	q1 ⊲⊳G σ F ′	744-1
q1 ⊲⊳G σ F ′		sequential	q2	744-1
q2		sequential	q1 ⊲ ⊳ G′ q2 l l q1 ⊲	744-1
q1 ⊲ ⊳ G′ q2 l l q1 ⊲		sequential	⊳ G′ πk	744-1
⊳ G′ πk		sequential	2	744-1
2		sequential	Figure	744-1
Figure		sequential	6.2	744-1
6.2		sequential	Rewriting rules	744-1
Rewriting rules	for	constraint	SPC algebra them	744-1
SPC algebra them	and	conjunctive	the one	744-1
SPC algebra them	3 select	action	the one	744-1
the one	of	constraint	lowest cost	744-1
The database system	executes	action	the selected evaluation plan	744-2
<B>	In	constraint	early work	745-1
early work		sequential	the transformation rules	745-1
the transformation rules	and	conjunctive	the method	745-1
the transformation rules	used	action	the method	745-1
the method	for	constraint	evaluation plan generation	745-1
evaluation plan generation	were	attribute	essentially intermixed	745-1
<B>	in	constraint	part	745-2
<B>	Motivated	action	part	745-2
part	by	constraint	the desire	745-2
the desire	to	constraint	database systems	745-2
the desire	make	action	database systems	745-2
database systems		sequential	more recent proposals	745-2
more recent proposals	have isolated	action	the transformation rules	745-2
the transformation rules	from	constraint	the algorithms	745-2
the algorithms	for	constraint	evaluation plans	745-2
the algorithms	generating	action	evaluation plans	745-2
<B>	has	action	the advantages	745-3
the advantages	of	constraint	the semantics	745-3
the advantages	exposing	action	the semantics	745-3
the semantics	of	constraint	evaluation plan generation	745-3
evaluation plan generation	and	conjunctive	it	745-3
evaluation plan generation	making	action	it	745-3
it	to	constraint	new kinds	745-3
it	incorporate	action	new kinds	745-3
new kinds	of	constraint	information	745-3
information	into	constraint	the framework	745-3
Early work	on	constraint	the cost	746-1
Early work	estimating	action	the cost	746-1
the cost	of	constraint	evaluation plans	746-1
evaluation plans	essentially on	constraint	<B>	746-1
evaluation plans	was based	action	<B>	746-1
Sideways Information Passing		sequential	Sideways Information Passing	747-1
<B>	of	constraint	the early research	748-1
the early research	on	constraint	practical query optimization	748-1
practical query optimization	in	constraint	connection	748-1
practical query optimization	was performed	action	connection	748-1
connection	with	constraint	System R	748-1
System R	and	conjunctive	INGRES	748-1
INGRES		sequential	the systems	748-1
The basic building block	of	constraint	Static Analysis	748-2
Static Analysis	and	conjunctive	Optimization	748-2
Optimization		sequential	the query languages	748-2
the query languages	in	constraint	these systems	748-2
the query languages	used	action	these systems	748-2
these systems		sequential	SQL	748-2
SQL	and	conjunctive	Quel	748-2
Quel	takes	action	the form	748-2
the form	of	constraint	clauses	748-2
the form	from	constraint	clauses	748-2
clauses	or	conjunctive	blocks	748-2
<B>	For	constraint	example	748-3
example	as	constraint	Chapter 7	748-3
example	in	constraint	Chapter 7	748-3
Chapter 7		sequential	Query	748-3
Query		sequential	4.4	748-3
4.4	in	constraint	SQL	748-3
4.4	can be expressed	action	SQL	748-3
SQL	as	constraint	select Theater	748-3
select Theater		sequential	Address	748-3
Address	from	constraint	Movies	748-3
Movies		sequential	Location	748-3
Location		sequential	Pariscope	748-3
Pariscope		sequential	Director	748-3
Director	where =	sequential	Bergman	748-3
<B>	into	constraint	the algebra	749-1
<B>	can be translated	action	the algebra	749-1
the algebra	as	constraint	a join	749-1
a join	between	constraint	the three relations the	749-1
the three relations the	of	constraint	part	749-1
the three relations the	from	constraint	part	749-1
part	using	action	join condition	749-1
join condition	by	constraint	the where	749-1
join condition	given	action	the where	749-1
the where	onto	constraint	the columns	749-1
the where	and	conjunctive	the columns	749-1
the where	projecting	action	the columns	749-1
the columns	in	constraint	the select	749-1
the columns	mentioned	action	the select	749-1
<B>	from	constraint	a typical block	749-2
a typical block	by	constraint	an SPC query	749-2
a typical block	Thus can be expressed	action	an SPC query	749-2
an SPC query	as	constraint	π	749-2
π		sequential	σ j F	749-2
σ j F		sequential	R1 ×	749-2
R1 ×		sequential	× Rn	749-2
<B>	With	constraint	such expressions	750-1
such expressions		sequential	the System R query optimizer	750-1
the System R query optimizer	pushes	action	selections	750-1
selections		sequential	that	750-1
that	affect	action	a single relation	750-1
a single relation	into	constraint	the join	750-1
the join	and	conjunctive	evaluation plans	750-1
the join	considers	action	evaluation plans	750-1
evaluation plans	on	constraint	left	750-1
evaluation plans	based	action	left	750-1
left	to	constraint	that	750-1
left	joins	action	that	750-1
that	have	action	the form	750-1
the form		sequential	i2	750-1
i2	in	constraint	different orderings Ri	750-1
i2	using	action	different orderings Ri	750-1
<B>	.	sequential	<B>	750-2
<B>	.	sequential	<B>	750-3
R		sequential	R	750-4
We	now present	action	a heuristic	750-5
a heuristic	on	constraint	1	750-5
a heuristic	in	constraint	1	750-5
a heuristic	based	action	1	750-5
1	in	constraint	formation	750-5
formation		sequential	sideways passing	750-5
sideways passing		sequential	which	750-5
which	in	constraint	the System R optimizer	750-5
which	is used	action	the System R optimizer	750-5
the System R optimizer	for	constraint	some possible orderings	750-5
the System R optimizer	eliminating	action	some possible orderings	750-5
some possible orderings	from	constraint	consideration	750-5
this heuristic	Interestingly has also played	action	an important role	750-6
an important role	in	constraint	evaluation techniques	750-6
an important role	developing	action	evaluation techniques	750-6
evaluation techniques	for	constraint	recursive datalog queries	750-6
recursive datalog queries	as	constraint	Chapter 13	750-6
recursive datalog queries	in	constraint	Chapter 13	750-6
recursive datalog queries	discussed	action	Chapter 13	750-6
<B>	To	constraint	the heuristic	751-1
<B>	describe	action	the heuristic	751-1
the heuristic		sequential	we	751-1
we	rewrite	action	the preceding SPC query	751-1
the preceding SPC query	as	constraint	a rule	751-1
the preceding SPC query	generalized	action	a rule	751-1
a rule		sequential	that	751-1
that	has	action	the form	751-1
the form		sequential	all equalities	751-1
all equalities	of	constraint	the selection condition F	751-1
the selection condition F	by	constraint	constants	751-1
the selection condition F	where are incorporated	action	constants	751-1
the selection condition F	using	action	constants	751-1
constants	and	conjunctive	variables	751-1
constants	equating	action	variables	751-1
variables	in	constraint	the free tuples u1	751-1
<B>	.	sequential	<B>	751-2
<B>	.	sequential	<B>	751-3
<B>	and	conjunctive	the expressions C1	751-4
<B>	.	sequential	<B>	751-5
<B>	.	sequential	<B>	751-6
Cm	are	attribute	conditions	751-7
conditions	in	constraint	the selection condition	751-7
the selection condition		sequential	F	751-7
F	in	constraint	that way	751-7
F	not captured	action	that way	751-7
<B>	might include	action	e.g. inequalities	751-8
e.g. inequalities	and	conjunctive	conditions	751-8
conditions	on	constraint	order	751-8
conditions	based	action	order	751-8
We	shall call	action	Ri	751-9
Ri		sequential	ui	751-9
ui		sequential	the relation atoms	751-9
the relation atoms	and	conjunctive	the Cj	751-9
the Cj		sequential	constraint atoms	751-9
Example		sequential	6.1.1	752-1
R		sequential	v	753-1
v	w	constraint	y	753-1
y		sequential	P	753-1
P		sequential	a	753-1
a		sequential	v	753-1
v		sequential	Q	753-1
Q		sequential	b	753-1
b		sequential	w	753-1
w		sequential	x	753-1
x		sequential	S	753-1
S		sequential	x	753-1
x		sequential	y	753-1
y		sequential	z	753-1
z		sequential	Figure	753-1
Figure		sequential	6.3	753-1
6.3		sequential	the sideways information passing graph	753-1
the sideways information passing graph	or	conjunctive	sip graph	753-1
sip graph	of	constraint	a rule ρ	753-1
a rule ρ		sequential	that	753-1
that	has	action	the form	753-1
the form		sequential	∗	753-1
∗	just shown	action	has vertexes	753-1
has vertexes		sequential	the set	753-1
the set	of	constraint	relation atoms	753-1
relation atoms	of	constraint	a rule	753-1
a rule	and	conjunctive	an undirected edge	753-1
a rule	includes	action	an undirected edge	753-1
an undirected edge	between	constraint	atoms Ri	753-1
atoms Ri		sequential	ui	753-1
ui		sequential	Rj	753-1
Rj		sequential	uj	753-1
uj	if	constraint	ui	753-1
ui	and	conjunctive	uj	753-1
uj	at	constraint	one variable	753-1
uj	have	attribute	least	753-1
one variable	in	constraint	<B>	753-1
each node	with	constraint	a constant appearing	753-2
a constant appearing	Furthermore is specially marked	action	<B>	753-2
The sip graph	for	constraint	the rule	753-3
the rule	of	constraint	Example 6.1.1	753-3
Example 6.1.1	in	constraint	Fig	753-3
Example 6.1.1	is shown	action	Fig	753-3
6.3		sequential	6.3	753-4
<B>	Let	action	us	754-1
us	that	constraint	the sip graph ρ	754-1
us	assume	action	the sip graph ρ	754-1
the sip graph ρ	for	constraint	a rule	754-1
a rule	is connected	action	<B>	754-1
<B>	In	constraint	this case	754-2
this case		sequential	a sideways information passing strategy	754-2
a sideways information passing strategy		sequential	sip strategy	754-2
sip strategy	for	constraint	ρ	754-2
ρ	is	attribute	an ordering A1	754-2
<B>	.	sequential	<B>	754-3
<B>	.	sequential	<B>	754-4
<B>	of	constraint	the atoms	754-5
the atoms	in	constraint	the rule	754-5
the rule	that	constraint	each j 1	754-5
the rule	for	constraint	each j 1	754-5
each j 1	either	conjunctive	<B>	754-5
Example		sequential	6.1.2 P	755-1
6.1.2 P		sequential	v	755-1
v		sequential	Q	755-1
Q		sequential	b	755-1
b		sequential	w	755-1
w		sequential	x	755-1
x		sequential	v	755-1
v		sequential	≤ x	755-1
≤ x		sequential	R	755-1
R		sequential	v	755-1
v		sequential	w	755-1
w		sequential	y	755-1
y		sequential	S	755-1
S		sequential	x	755-1
x		sequential	y	755-1
y		sequential	z	755-1
z		sequential	P	755-1
P		sequential	v	755-1
v		sequential	R	755-1
R		sequential	v	755-1
v	w	constraint	y	755-1
y		sequential	S	755-1
S		sequential	x	755-1
x		sequential	y	755-1
y		sequential	z	755-1
z		sequential	v	755-1
v		sequential	≤ x	755-1
≤ x		sequential	Q	755-1
Q		sequential	b	755-1
b		sequential	w	755-1
w		sequential	x	755-1
x		sequential	Q	755-1
Q		sequential	b	755-1
b		sequential	w	755-1
w		sequential	x	755-1
x		sequential	R	755-1
R		sequential	v	755-1
v		sequential	w	755-1
w		sequential	y	755-1
y		sequential	P	755-1
P		sequential	v	755-1
v		sequential	S	755-1
S		sequential	x	755-1
x		sequential	y	755-1
y		sequential	z	755-1
z		sequential	v	755-1
v		sequential	≤ x	755-1
Static Analysis	and	conjunctive	Optimization	756-1
Example		sequential	6.1.3	757-1
<B>	that	constraint	a join	758-1
<B>	to	constraint	a join	758-1
<B>	Suppose	attribute	left	758-1
a join	is performed	action	the sip strategy	758-1
a join	according to	action	the sip strategy	758-1
the sip strategy	shown	action	<B>	758-1
<B>	At	constraint	different intermediate stages	758-2
different intermediate stages		sequential	certain variables	758-2
certain variables	because	constraint	they	758-2
certain variables	can be forgotten	action	they	758-2
they	in	constraint	the answer	758-2
they	are not used	action	the answer	758-2
the answer	nor	conjunctive	they	758-2
they	in	constraint	subsequent joins	758-2
they	are used	action	subsequent joins	758-2
<B>	In	constraint	the third atom	758-3
<B>	after	constraint	the third atom	758-3
the third atom		sequential	the variable y	758-3
the variable y	after	constraint	the fourth atom v	758-3
the variable y	can be projected out	action	the fourth atom v	758-3
the fourth atom v	after	constraint	the fifth atom	758-3
the fourth atom v	and	conjunctive	the fifth atom	758-3
the fourth atom v	can be projected out	action	the fifth atom	758-3
the fifth atom	w	constraint	x	758-3
the fifth atom	and	conjunctive	x	758-3
x	can be projected out	action	<B>	758-3
It	to	constraint	a general policy	758-4
It	is	attribute	straightforward	758-4
It	formulate	action	a general policy	758-4
a general policy	for	constraint	unneeded variables	758-4
a general policy	to	constraint	unneeded variables	758-4
a general policy	when project out	action	unneeded variables	758-4
unneeded variables	see	action	Exercise 6.4	758-4
Query Decomposition	Join	action	Detachment	759-1
Detachment	and	conjunctive	Tuple	759-1
Tuple		sequential	Substitution	759-1
<B>	on	constraint	decomposing multiway	759-2
<B>	are based	action	decomposing multiway	759-2
decomposing multiway	into	constraint	smaller ones	759-2
decomposing multiway	joins	action	smaller ones	759-2
<B>	While	constraint	SPC queries the form	760-1
<B>	on	constraint	SPC queries the form	760-1
<B>	again focusing	action	SPC queries the form	760-1
SPC queries the form	of	constraint	j F	760-1
j F		sequential	R1	760-1
R1		sequential	× Rn	760-1
× Rn	for	constraint	this discussion	760-1
this discussion		sequential	we	760-1
we	use	action	a slightly different notation	760-1
<B>	In	constraint	tuple variables	760-2
tuple variables		sequential	domain variables	760-2
domain variables	are used	action	<B>	760-2
We	consider	action	expressions	760-3
expressions	of	constraint	the form	760-3
the form		sequential	s1	760-3
<B>	.	sequential	<B>	760-4
<B>	.	sequential	<B>	760-5
sn	are	attribute	tuple variables	760-6
tuple variables		sequential	C1	760-6
<B>	.	sequential	<B>	760-7
<B>	.	sequential	<B>	760-8
Cn	are	attribute	Boolean conditions	760-9
Boolean conditions	to	constraint	coordinates	760-9
Boolean conditions	referring	action	coordinates	760-9
coordinates	of	constraint	the variables s1	760-9
<B>	.	sequential	<B>	760-10
<B>	.	sequential	<B>	760-11
sn		sequential	s1.3	760-12
s1.3	=	sequential	s4.1	760-12
s4.1	∨	sequential	s2.4	760-12
s2.4	and	conjunctive	T	760-12
s2.4	= a	sequential	T	760-12
T	is	attribute	a target condition	760-12
a target condition		sequential	that	760-12
that	gives	action	a value	760-12
a value	for	constraint	each coordinate	760-12
each coordinate	of	constraint	the target variable s.	760-12
<B>	.	sequential	<B>	760-13
<B>	.	sequential	<B>	760-14
Cn	has	action	∧	760-15
∧	as	constraint	its parent connective	760-15
i		sequential	i	761-1
<B>	In	constraint	the INGRES optimizer	762-1
the INGRES optimizer	with	constraint	other steps	762-1
the INGRES optimizer	is typically combined	action	other steps	762-1
<B>	Join	action	detachment	763-1
detachment	for	constraint	a query	763-1
detachment	is	attribute	useful	763-1
detachment	separating	action	a query	763-1
a query	into	constraint	two separate queries	763-1
two separate queries		sequential	the second	763-1
the second	to	constraint	<B>	763-1
the second	where refers	attribute	the first	763-1
<B>	Consider	action	a query	763-2
a query		sequential	that	763-2
that	has	action	the specialized form	763-2
the specialized form		sequential	ans	763-2
ans		sequential	t	763-2
t		sequential	P1	763-2
P1		sequential	p1	763-2
<B>	.	sequential	<B>	763-3
<B>	.	sequential	<B>	763-4
Pm		sequential	pm	763-5
pm		sequential	C1	763-5
<B>	.	sequential	<B>	763-6
<B>	.	sequential	<B>	763-7
Ck		sequential	T	763-8
T		sequential	Q	763-8
Q		sequential	q	763-8
q		sequential	R1	763-8
R1		sequential	r1	763-8
<B>	.	sequential	<B>	763-9
<B>	.	sequential	<B>	763-10
Rn		sequential	rn	763-11
rn		sequential	D1	763-11
<B>	.	sequential	<B>	763-12
<B>	.	sequential	<B>	763-13
Dl		sequential	conditions	763-14
conditions		sequential	where C1	763-14
<B>	.	sequential	<B>	763-15
<B>	.	sequential	<B>	763-16
Ck		sequential	T	763-17
T	to	constraint	only variables	763-17
T	refer	action	only variables	763-17
only variables		sequential	t	763-17
t		sequential	p1	763-17
<B>	.	sequential	<B>	763-18
<B>	.	sequential	<B>	763-19
pm		sequential	q	763-20
q	and	conjunctive	D1	763-20
<B>	.	sequential	<B>	763-21
<B>	.	sequential	<B>	763-22
Dl	to	constraint	r1	763-23
Dl	refer only	action	r1	763-23
Dl	q	action	r1	763-23
<B>	.	sequential	<B>	763-24
<B>	.	sequential	<B>	763-25
<B>		sequential	<B>	763-26
It	that	constraint	the sequence temp	763-27
It	to	constraint	the sequence temp	763-27
It	is easily verified	attribute	this	763-27
It	is	attribute	equivalent	763-27
the sequence temp		sequential	q	763-27
q		sequential	Q	763-27
Q		sequential	q	763-27
q		sequential	R1	763-27
R1		sequential	r1	763-27
<B>	.	sequential	<B>	763-28
<B>	.	sequential	<B>	763-29
Rn		sequential	rn	763-30
rn		sequential	D1	763-30
<B>	.	sequential	<B>	763-31
<B>	.	sequential	<B>	763-32
Dl		sequential	Dl	763-33
<B>	In	constraint	this example	764-1
this example		sequential	variable q	764-1
variable q	as	constraint	a pivot	764-1
variable q	acts	action	a pivot	764-1
a pivot	around	constraint	which	764-1
which		sequential	the detachment	764-1
the detachment	is performed	action	<B>	764-1
More general forms	of	constraint	join detachment	765-1
join detachment	in	constraint	which	765-1
join detachment	can be developed	action	which	765-1
which		sequential	a set	765-1
a set	of	constraint	variables	765-1
variables	as	constraint	the pivot	765-1
variables	serves	action	the pivot	765-1
the pivot	see	action	Exercise 6.6	765-1
Tuple substitution	chooses	action	one	766-1
one	of	constraint	the underlying relations	766-1
<B>	Consider again	action	a query	766-2
a query	of	constraint	form	766-2
form	∗∗ just shown	action	<B>	766-2
The tuple substitution	of	constraint	Ri	766-3
The tuple substitution	on	constraint	Ri	766-3
Ri	by	constraint	the program	766-3
Ri	is given	action	the program	766-3
the program	for	constraint	each r inRi do	766-3
we	to	constraint	ans	767-1
we	that	constraint	ans	767-1
we	Here use	attribute	+←	767-1
we	indicate	action	ans	767-1
ans	to	constraint	the values	767-1
ans	is	attribute	the values	767-1
ans	accumulate	action	the values	767-1
the values	from	constraint	all tuples	767-1
the values	stemming	action	all tuples	767-1
all tuples	in	constraint	the value	767-1
all tuples	r	action	the value	767-1
the value	of	constraint	Ri	767-1
Ri		sequential	r	767-1
r	for	constraint	si	767-1
r	furthermore is substituted	action	si	767-1
si	in	constraint	the conditions	767-1
si	of	constraint	the conditions	767-1
There	is here	action	trade	768-1
trade		sequential	an obvious off	768-1
an obvious off	between	constraint	the number	768-1
an obvious off	reducing	action	the number	768-1
the number	of	constraint	variables	768-1
variables	in	constraint	the join	768-1
the join	and	conjunctive	the number	768-1
the number	of	constraint	tuples	768-1
tuples	in	constraint	Ri	768-1
<B>	In	constraint	the INGRES optimizer	768-2
the INGRES optimizer	of	constraint	the Ri	768-2
the Ri	as	constraint	a candidate	768-2
the Ri	is considered	action	a candidate	768-2
a candidate	for	constraint	the tuple substitution	768-2
a candidate	forming	action	the tuple substitution	768-2
<B>	During	constraint	this process	768-3
this process		sequential	conditions	768-3
conditions	to	constraint	the Ri	768-3
conditions	may be applied	action	the Ri	768-3
the Ri	to	constraint	their size	768-3
the Ri	decrease	action	their size	768-3
Global Optimization		sequential	Global Optimization	769-1
<B>	In	constraint	this section	769-2
this section		sequential	we	769-2
we	develop	action	an approach	769-2
an approach	to	constraint	the global optimization	769-2
the global optimization	of	constraint	conjunctive queries	769-2
<B>	allows	action	a transformation	769-3
a transformation	of	constraint	an algebra query	769-3
an algebra query		sequential	that	769-3
that	removes	action	several joins	769-3
several joins	in	constraint	a single step	769-3
a single step		sequential	a capability	769-3
a capability	by	constraint	the techniques	769-3
a capability	not provided	action	the techniques	769-3
the techniques	of	constraint	the previous section	769-3
The global optimization technique	on	constraint	an elegant Homomorphism Theorem	769-4
The global optimization technique	is based	action	an elegant Homomorphism Theorem	769-4
The Homomorphism Theorem		sequential	The Homomorphism Theorem	770-1
<B>		sequential	q1 q2 iff	770-2
q1 q2 iff		sequential	q1 ⊆	770-2
q1 ⊆		sequential	q2	770-2
q2	and	conjunctive	q2	770-2
q2		sequential	⊆ q1	770-2
The Homomorphism Theorem	provides	action	a characterization	770-3
a characterization	for	constraint	containment	770-3
containment	and	conjunctive	equivalence	770-3
equivalence	of	constraint	conjunctive queries	770-3
We	on	constraint	the tableau formalism	771-1
We	focus here	action	the tableau formalism	771-1
the tableau formalism	for	constraint	conjunctive queries	771-1
conjunctive queries	although	constraint	rule	771-1
rule	based	action	the formalism	771-1
the formalism	could be used equally well	action	<B>	771-1
<B>	In	constraint	addition	771-2
addition	although	constraint	the results	771-2
the results	for	constraint	tableau queries	771-2
the results	hold	action	tableau queries	771-2
tableau queries	over	constraint	database schemas	771-2
database schemas	involving	action	more than one relation	771-2
more than one relation		sequential	the examples	771-2
the examples	on	constraint	queries	771-2
the examples	presented	action	queries	771-2
the examples	focus	action	queries	771-2
queries	over	constraint	a single relation	771-2
<B>	Recall	action	the notion	772-1
the notion	of	constraint	valuation	772-1
valuation		sequential	a mapping	772-1
a mapping	from	constraint	variables	772-1
variables	to	constraint	constants	772-1
constants	to	constraint	the identity	772-1
constants	be	attribute	the identity	772-1
constants	extended	action	the identity	772-1
the identity	on	constraint	constants	772-1
constants	to	constraint	free tuples	772-1
constants	and	conjunctive	free tuples	772-1
constants	generalized	action	free tuples	772-1
free tuples	and	conjunctive	tableaux	772-1
tableaux	in	constraint	the natural fashion	772-1
Static Analysis	and	conjunctive	Optimization R B	773-1
Optimization R B		sequential	R B	773-1
R B		sequential	R B	773-1
R B		sequential	R B	773-1
R B		sequential	x y x	773-1
x y x		sequential	y x x	773-1
y x x		sequential	y	773-1
y		sequential	y	773-1
y		sequential	1	773-1
1		sequential	x x x y	773-1
x x x y	y	sequential	1 y	773-1
1 y		sequential	1	773-1
1		sequential	x 1	773-1
x 1		sequential	y	773-1
y		sequential	x y	773-1
x y		sequential	x y	773-1
x y		sequential	x y	773-1
x y		sequential	x	773-1
x		sequential	y	773-1
y		sequential	x	773-1
x		sequential	y	773-1
y		sequential	x	773-1
x		sequential	y q	773-1
y q		sequential	x	773-1
x		sequential	y	773-1
y		sequential	0	773-1
0	=	sequential	T	773-1
T		sequential	0	773-1
0	〈	sequential	y〉	773-1
0	x	sequential	y〉	773-1
y〉		sequential	q	773-1
q		sequential	1	773-1
1	=	sequential	T	773-1
T		sequential	1	773-1
1	〈	sequential	y〉	773-1
1	x	sequential	y〉	773-1
y〉		sequential	q 2	773-1
q 2	=	sequential	T	773-1
T		sequential	2	773-1
2	〈	sequential	y〉	773-1
2	x	sequential	y〉	773-1
y〉		sequential	q	773-1
q		sequential	ω	773-1
ω	=	sequential	T	773-1
T		sequential	ω	773-1
ω	〈	sequential	y〉	773-1
ω	x	sequential	y〉	773-1
y〉		sequential	Figure	773-1
Figure		sequential	6.4	773-1
6.4		sequential	Tableau queries	773-1
Tableau queries	to	constraint	the Homomorphism Theorem Valuations	773-1
Tableau queries	used	action	the Homomorphism Theorem Valuations	773-1
Tableau queries	illustrate	action	the Homomorphism Theorem Valuations	773-1
the Homomorphism Theorem Valuations	in	constraint	the definition	773-1
the Homomorphism Theorem Valuations	are used	action	the definition	773-1
the definition	of	constraint	the semantics	773-1
the semantics	of	constraint	tableau queries	773-1
<B>		sequential	a substitution	773-2
a substitution	is	attribute	a mapping	773-2
a mapping	from	constraint	variables	773-2
variables	to	constraint	variables	773-2
variables	and	conjunctive	constants	773-2
constants		sequential	which	773-2
which	to	constraint	the identity	773-2
which	be	attribute	the identity	773-2
which	is extended	action	the identity	773-2
the identity	on	constraint	constants	773-2
constants	to	constraint	free tuples	773-2
constants	and	conjunctive	free tuples	773-2
constants	generalized	action	free tuples	773-2
free tuples	and	conjunctive	tableaux	773-2
tableaux	in	constraint	the natural fashion	773-2
We	begin	action	the discussion	774-1
the discussion	with	constraint	two examples	774-1
<B>	presents	action	several simple examples	774-2
several simple examples	of	constraint	the Homomorphism Theorem	774-2
the Homomorphism Theorem	in	constraint	action	774-2
Example		sequential	6.2.1	775-1
6.4		sequential	6.4	775-2
<B>	By	constraint	the Homomorphism Theorem	775-3
<B>	using	action	the Homomorphism Theorem	775-3
the Homomorphism Theorem		sequential	it	775-3
it	that	constraint	q0 ⊆ q1 ⊆ q2 ⊆ qω	775-3
it	can be shown	action	q0 ⊆ q1 ⊆ q2 ⊆ qω	775-3
<B>	To	constraint	the flavor	776-1
<B>	illustrate	action	the flavor	776-1
the flavor	of	constraint	the proof	776-1
the proof	of	constraint	the Homomorphism Theorem	776-1
the Homomorphism Theorem		sequential	we	776-1
we	that	constraint	q1 ⊆ q2	776-1
we	argue informally	action	q1 ⊆ q2	776-1
<B>	that	constraint	there	776-2
<B>	Note	action	there	776-2
there	is	attribute	substitution	776-2
substitution		sequential	θ	776-2
θ	that	constraint	θ	776-2
θ		sequential	T2	776-2
T2		sequential	such ⊆ T1	776-2
such ⊆ T1	and	conjunctive	θ	776-2
θ		sequential	x	776-2
x		sequential	y	776-2
y	=	sequential	x	776-2
x		sequential	y	776-2
y		sequential	let θ	776-2
let θ		sequential	x1	776-2
x1	=	sequential	θ	776-2
θ		sequential	x2	776-2
x2	=	sequential	x1	776-2
x1	and	conjunctive	θ	776-2
θ		sequential	y1	776-2
y1	=	sequential	θ	776-2
θ		sequential	y2	776-2
y2	=	sequential	y1	776-2
<B>	that	constraint	I	776-3
<B>	Now suppose	action	I	776-3
I	is	attribute	an instance	776-3
an instance	over	constraint	AB	776-3
AB	that	constraint	t ∈ q1	776-3
AB	and	conjunctive	t ∈ q1	776-3
t ∈ q1		sequential	I	776-3
there	Then is	action	a valuation	776-4
a valuation		sequential	ν	776-4
ν		sequential	that	776-4
that		sequential	ν	776-4
ν		sequential	T1	776-4
T1		sequential	⊆	776-4
⊆		sequential	I	776-4
I	and	conjunctive	ν	776-4
ν		sequential	x	776-4
x		sequential	y	776-4
y	=	sequential	t	776-4
It	that	constraint	θ	776-5
It	follows	action	θ	776-5
θ		sequential	ν	776-5
ν	is	attribute	a valuation	776-5
a valuation		sequential	that	776-5
that	embeds	action	T2	776-5
T2	into	constraint	I	776-5
I	with	constraint	θ	776-5
θ		sequential	ν	776-5
ν		sequential	x	776-5
x		sequential	y	776-5
y	=	sequential	t	776-5
t		sequential	whence t ∈ q2	776-5
whence t ∈ q2		sequential	I	776-5
the existence	of	constraint	a substitution	777-1
a substitution	embedding	action	the tableau	777-1
the tableau	of	constraint	q2	777-1
q2	into	constraint	the tableau	777-1
the tableau	of	constraint	q1	777-1
q1	and	conjunctive	the summary	777-1
q1	mapping	action	the summary	777-1
the summary	of	constraint	q2	777-1
q2	to	constraint	the summary	777-1
the summary	of	constraint	q1	777-1
q1	that	constraint	q1	777-1
q1	Intuitively implies	action	q1	777-1
q1	than	constraint	q2	777-1
q1	is	attribute	more restrictive	777-1
q2	than	constraint	q2	777-1
q2	or	conjunctive	q2	777-1
the Homomorphism Theorem	that	constraint	also a necessary condition	777-2
the Homomorphism Theorem	Surprisingly states	attribute	this	777-2
the Homomorphism Theorem	is	attribute	also a necessary condition	777-2
also a necessary condition	for	constraint	containment	777-2
containment	if	constraint	q	777-2
q		sequential	⊆	777-2
⊆		sequential	q	777-2
q	than	constraint	q′	777-2
q	is	attribute	more restrictive	777-2
q′	in	constraint	this sense	777-2
The second example	illustrates	action	a limitation	778-1
a limitation	of	constraint	the techniques	778-1
the techniques	in	constraint	the previous section	778-1
the techniques	discussed	action	the previous section	778-1
Example		sequential	6.2.2	779-1
6.5		sequential	6.5	779-2
It	that	constraint	q	779-3
It	can be shown	action	q	779-3
q	≡	sequential	q′	779-3
q′	that	constraint	q′	779-3
q′	but	conjunctive	q′	779-3
q′	from	constraint	q	779-3
q′	can not be obtained	action	q	779-3
q	using	action	the rewrite rules	779-3
the rewrite rules	of	constraint	the previous section	779-3
the previous section	see	action	Exercise 6.3	779-3
Exercise 6.3	or	conjunctive	the other optimization techniques	779-3
the other optimization techniques	presented	action	<B>	779-3
R B R B x x x x x y y 2 y y n–1		sequential	1	780-1
1		sequential	x	780-1
x		sequential	y	780-1
y		sequential	1	780-1
1		sequential	n	780-1
n		sequential	y	780-1
y		sequential	x	780-1
x		sequential	n	780-1
n		sequential	x	780-1
x		sequential	q	780-1
q	=	sequential	T	780-1
T		sequential	u	780-1
u		sequential	q′	780-1
q′	=	sequential	T′	780-1
T′		sequential	u	780-1
u		sequential	Figure	780-1
Figure		sequential	6.5	780-1
6.5		sequential	Pair	780-1
Pair	of	constraint	equivalent tableau queries	780-1
equivalent tableau queries	Let	action	q	780-1
q	=	sequential	T	780-1
T		sequential	u	780-1
u	and	conjunctive	q′	780-1
q′	=	sequential	T′	780-1
T′		sequential	u′	780-1
u′	be	attribute	two tableau queries	780-1
two tableau queries	over	constraint	the same schema	780-1
the same schema		sequential	R.	780-1
R.		sequential	A homomorphism	780-1
A homomorphism	from	constraint	q′	780-1
q′	to	constraint	q	780-1
q	is	attribute	θ	780-1
θ		sequential	that	780-1
that		sequential	θ	780-1
θ		sequential	T′	780-1
T′		sequential	⊆ T	780-1
⊆ T	and	conjunctive	θ	780-1
θ		sequential	u′	780-1
u′	=	sequential	u	780-1
Theorem		sequential	6.2.3	781-1
6.2.3		sequential	Homomorphism Theorem	781-1
Proof	that	constraint	there	782-1
Proof	Suppose first	action	there	782-1
there	exists	action	a homomorphism θ	782-1
a homomorphism θ	from	constraint	q′	782-1
q′	to	constraint	q	782-1
<B>	Let	action	I	782-2
I	be	attribute	an instance	782-2
an instance	over	constraint	R	782-2
there	Then is	action	a valuation ν	782-3
a valuation ν		sequential	that	782-3
that	embeds	action	T	782-3
T	into	constraint	I	782-3
I	that	constraint	ν	782-3
ν		sequential	u	782-3
u	w	constraint	<B>	782-3
u	=	sequential	<B>	782-3
<B>	For	constraint	the opposite inclusion	783-1
the opposite inclusion	that	constraint	q ⊆ q′	783-1
the opposite inclusion	suppose	action	q ⊆ q′	783-1
q ⊆ q′		sequential	T	783-1
T		sequential	u	783-1
u		sequential	⊆	783-1
⊆		sequential	T′	783-1
T′		sequential	u′	783-1
<B>	Speaking intuitively	action	we	783-2
we	complete	action	the proof	783-2
the proof	by	constraint	both q	783-2
the proof	applying	action	both q	783-2
both q	and	conjunctive	q′	783-2
q′	to	constraint	the instance T	783-2
<B>	To	constraint	this argument	783-3
<B>	make	action	this argument	783-3
this argument		sequential	we	783-3
we	construct	action	an instance	783-3
an instance		sequential	IT	783-3
IT		sequential	that	783-3
that	to	constraint	T	783-3
that	is	attribute	isomorphic	783-3
<B>	Let	action	V	784-1
V	be	attribute	the set	784-1
the set	of	constraint	variables	784-1
variables	in	constraint	T	784-1
variables	occurring	action	T	784-1
<B>	Let	action	µ	784-2
µ	be	attribute	the valuation	784-2
the valuation	mapping	action	each x	784-2
each x	to	constraint	IT	784-2
each x	and	conjunctive	IT	784-2
each x	ax	action	IT	784-2
each x	let	action	IT	784-2
IT	=	sequential	µ	784-2
µ		sequential	T	784-2
<B>	Because	constraint	µ	784-3
µ	is	attribute	a bijection	784-3
a bijection	from	constraint	V	784-3
V	to	constraint	µ	784-3
µ		sequential	V	784-3
V	because	constraint	µ	784-3
V	and	conjunctive	µ	784-3
µ		sequential	V	784-3
V	has	action	empty intersection	784-3
empty intersection	with	constraint	the constants	784-3
the constants	in	constraint	T	784-3
the constants	occurring	action	T	784-3
T		sequential	the inverse µ−1	784-3
the inverse µ−1	of	constraint	µ	784-3
µ	on	constraint	adom	784-3
µ	is well defined	action	adom	784-3
adom		sequential	IT	784-3
It	that	constraint	u	785-1
It	is	attribute	clear	785-1
u		sequential	µ ∈ q	785-1
µ ∈ q		sequential	IT	785-1
IT	by	constraint	assumption	785-1
IT	and	conjunctive	assumption	785-1
assumption		sequential	µ	785-1
µ		sequential	u	785-1
u		sequential	∈ q′	785-1
∈ q′		sequential	IT	785-1
there	Thus is	action	a valuation	785-2
a valuation	ν	constraint	<B>	785-2
a valuation	embeds	action	<B>	785-2
It	that	constraint	ν	785-3
It	is now easily verified	action	ν	785-3
ν		sequential	µ −1	785-3
µ −1	is	attribute	a homomorphism	785-3
a homomorphism	from	constraint	q′	785-3
q′	to	constraint	q	785-3
<B>	Permitting	action	a slight abuse	786-1
a slight abuse	of	constraint	notation	786-1
notation		sequential	we	786-1
we	have	attribute	the	786-1
we	following	action	Exercise 6.8	786-1
we	see	action	Exercise 6.8	786-1
Corollary		sequential	6.2.4	787-1
Static Analysis	and	conjunctive	Optimization	788-1
<B>	In	constraint	q	789-1
<B>	if	constraint	q	789-1
q	=	sequential	T	789-1
T		sequential	u	789-1
u	and	conjunctive	q′	789-1
q′	=	sequential	T′	789-1
T′		sequential	u′	789-1
u′	are	attribute	equivalent	789-1
u	and	conjunctive	u′	789-1
u′	up to	constraint	one	789-1
u′	are	attribute	identical	789-1
one		sequential	one renaming	789-1
one renaming	of	constraint	variables	789-1
Only one direction	of	constraint	the preceding characterization	790-1
the preceding characterization	if	constraint	the underlying domain	790-1
the preceding characterization	holds	action	the underlying domain	790-1
the underlying domain	is	attribute	finite	790-1
the underlying domain	see	action	Exercise 6.12	790-1
<B>	In	constraint	addition	790-2
addition		sequential	the direct generalization	790-2
the direct generalization	of	constraint	the theorem	790-2
the theorem	to	constraint	tableau queries	790-2
tableau queries	with	constraint	equality	790-2
equality	does not hold	action	Exercise 6.9	790-2
equality	see	action	Exercise 6.9	790-2
Query Optimization	by	constraint	Tableau Minimization	791-1
We	that	constraint	there	792-1
We	note first	action	there	792-1
there	are	attribute	simple algorithms	792-1
simple algorithms	for	constraint	tableau queries	792-1
simple algorithms	translating	action	tableau queries	792-1
tableau queries	into	constraint	SPC queries	792-1
SPC queries	and	conjunctive	<B>	792-1
<B>	given	action	a tableau query	792-2
a tableau query		sequential	the corresponding generalized SPC query	792-2
the corresponding generalized SPC query	More specifically has	action	the form π	792-2
the form π		sequential	σ j F	792-2
σ j F		sequential	R1	792-2
R1		sequential	×	792-2
×		sequential	× Rk	792-2
× Rk		sequential	each component Ri	792-2
each component Ri	to	constraint	a distinct row	792-2
each component Ri	where corresponds	action	a distinct row	792-2
a distinct row	of	constraint	the tableau	792-2
<B>	For	constraint	the opposite direction	792-3
the opposite direction		sequential	one algorithm	792-3
one algorithm	for	constraint	SPC queries	792-3
one algorithm	translating	action	SPC queries	792-3
SPC queries	into	constraint	tableau queries	792-3
tableau queries	to	constraint	the normal form	792-3
tableau queries	into	constraint	the normal form	792-3
tableau queries	is	attribute	the normal form	792-3
tableau queries	first translate	action	the normal form	792-3
the normal form	for	constraint	generalized SPC queries	792-3
generalized SPC queries	into	constraint	a tableau query	792-3
generalized SPC queries	and	conjunctive	a tableau query	792-3
A more direct approach		sequential	that	792-4
that	inductively builds	action	tableau queries	792-4
tableau queries	to	constraint	subexpressions	792-4
tableau queries	corresponding	action	subexpressions	792-4
subexpressions	of	constraint	an SPC query	792-4
an SPC query	can also be developed	action	Exercise 4.18	792-4
an SPC query	see	action	Exercise 4.18	792-4
Analogous remarks	to	constraint	SPJR queries	792-5
Analogous remarks	apply	action	SPJR queries	792-5
The goal	of	constraint	the optimization	793-1
the optimization	to	constraint	the number	793-1
the optimization	is	attribute	the number	793-1
the optimization	presented here	action	the number	793-1
the optimization	minimize	action	the number	793-1
the number	of	constraint	rows	793-1
rows	in	constraint	the tableau	793-1
<B>	Because	constraint	the number	793-2
the number	of	constraint	rows	793-2
rows	in	constraint	a tableau query	793-2
a tableau query	than	constraint	the number	793-2
a tableau query	is	attribute	one more	793-2
the number	of	constraint	joins	793-2
joins	in	constraint	SPC	793-2
SPC		sequential	SPJR	793-2
SPJR		sequential	the query	793-2
the query	to	constraint	that tableau	793-2
the query	corresponding	action	that tableau	793-2
that tableau	see	action	Exercise	793-2
Exercise		sequential	4.18 c	793-2
4.18 c		sequential	the tableau minimization procedure	793-2
the tableau minimization procedure	provides	action	a way	793-2
a way	to	constraint	the number	793-2
a way	minimize	action	the number	793-2
the number	of	constraint	joins	793-2
joins	in	constraint	SPC	793-2
we	that	constraint	an optimal tableau query	794-1
we	Surprisingly show	action	an optimal tableau query	794-1
an optimal tableau query	to	constraint	tableau query q	794-1
tableau query q	by	constraint	some rows	794-1
tableau query q	can be obtained simply	action	some rows	794-1
tableau query q	eliminating	action	some rows	794-1
some rows	from	constraint	the tableau	794-1
the tableau	of	constraint	q	794-1
We	that	constraint	a tableau query	795-1
We	say	action	a tableau query	795-1
a tableau query		sequential	T	795-1
T		sequential	u	795-1
u	if	constraint	there	795-1
u	is	attribute	minimal	795-1
there	is	attribute	no query	795-1
no query		sequential	S	795-1
S		sequential	v	795-1
v	to	constraint	T	795-1
T		sequential	u	795-1
u	with	constraint	|S|	795-1
|S|		sequential	T|	795-1
T|		sequential	S	795-1
S	where has	action	strictly fewer rows	795-1
strictly fewer rows	than	constraint	T	795-1
We	can now demonstrate	attribute	the following	796-1
Theorem		sequential	6.2.6	797-1
6.2.6	Let	action	q	797-1
q	=	sequential	T	797-1
T		sequential	u	797-1
u	be	attribute	a tableau query	797-1
there	Then is	action	a subset	797-2
Proof	Let	action	S	798-1
S	be	attribute	v a minimal tableau	798-1
v a minimal tableau		sequential	that	798-1
that	to	constraint	q	798-1
that	is	attribute	equivalent	798-1
<B>	By	constraint	Corollary 6.2.5	798-2
Corollary 6.2.5		sequential	there	798-2
there	are	attribute	homomorphisms θ	798-2
homomorphisms θ	from	constraint	q	798-2
q	to	constraint	S	798-2
S		sequential	v	798-2
v	and	conjunctive	λ	798-2
λ	from	constraint	S	798-2
S		sequential	v	798-2
v	to	constraint	q	798-2
<B>	Let	action	T′	798-3
T′	=	sequential	θ	798-3
θ		sequential	λ	798-3
λ		sequential	S	798-3
It	to	constraint	T′	798-4
It	is	attribute	straightforward	798-4
It	verify	attribute	that	798-4
T′		sequential	u	798-4
u		sequential	q	798-4
q	and	conjunctive	T′|	798-4
T′|		sequential	≤ |S|	798-4
<B>	By	constraint	minimality	798-5
minimality	of	constraint	S v	798-5
S v		sequential	it	798-5
it	follows	attribute	that	798-5
T′|	=	sequential	|S|	798-5
|S|	and	conjunctive	T′	798-5
T′		sequential	u	798-5
u	is	attribute	minimal	798-5
Example 6.2.7	illustrates	action	one	799-1
one	might minimize	action	a tableau	799-1
a tableau	by	constraint	hand	799-1
R B C u1 x2 y1 u2 x u3 y		sequential	y1	800-1
y1		sequential	x1	800-1
x1		sequential	u4	800-1
u4		sequential	x	800-1
x		sequential	y2	800-1
y2		sequential	u5	800-1
u5		sequential	x2	800-1
x2		sequential	y2	800-1
y2		sequential	u	800-1
u		sequential	x y	800-1
x y		sequential	Figure	800-1
Figure		sequential	6.6	800-1
6.6		sequential	6.6	800-2
<B>	To	constraint	T	800-3
<B>	minimize	action	T	800-3
T		sequential	u	800-3
u		sequential	we	800-3
we	to	constraint	which rows	800-3
we	wish	action	which rows	800-3
we	detect	action	which rows	800-3
which rows	of	constraint	T	800-3
T	can be eliminated	action	<B>	800-3
<B>	Consider	action	u1	801-1
<B>	Suppose	action	there	801-2
there	is	attribute	a homomorphism θ	801-2
a homomorphism θ	from	constraint	T	801-2
T		sequential	u	801-2
u	onto	constraint	itself	801-2
itself		sequential	that	801-2
that	eliminates	action	u1	801-2
u1		sequential	u1 ∈ θ	801-2
u1 ∈ θ		sequential	T	801-2
<B>	Because	constraint	any homomorphism	801-3
any homomorphism	on	constraint	T	801-3
T		sequential	u	801-3
u	is	attribute	the identity	801-3
the identity	on	constraint	u	801-3
u		sequential	θ	801-3
θ		sequential	z	801-3
z	=	sequential	z	801-3
θ		sequential	u1	802-1
u1	be	attribute	Thus must u5	802-1
<B>	But	conjunctive	θ	802-2
θ		sequential	y1	802-2
y1	=	sequential	y2	802-2
y2	and	conjunctive	θ	802-2
θ		sequential	u2	802-2
u2		sequential	∈	802-2
∈		sequential	u4	802-2
u4		sequential	u5	802-2
u5		sequential	}	802-2
<B>	In	constraint	θ	802-3
θ		sequential	z	802-3
z		sequential	1	802-3
1		sequential	∈	802-3
The preceding theorem	suggests	action	an improvement	803-1
an improvement	over	constraint	the optimization strategies	803-1
the optimization strategies	in	constraint	Section 6.1	803-1
the optimization strategies	described	action	Section 6.1	803-1
<B>	given	action	satisfiable conjunctive query	803-2
satisfiable conjunctive query		sequential	a q	803-2
a q		sequential	the following steps	803-2
the following steps	Specifically can be used	action	<B>	803-2
Example		sequential	6.2.8	804-1
Static Analysis	and	conjunctive	Optimization R B	805-1
Optimization R B		sequential	C	805-1
C		sequential	x x1	805-1
x x1		sequential	x1 u x	805-1
x1 u x		sequential	Figure 6.7	805-1
Figure 6.7		sequential	Tableau	805-1
Tableau	to	constraint	q	805-1
6.7		sequential	6.7	805-2
<B>	To	constraint	T	805-3
<B>	minimize	action	T	805-3
T		sequential	u	805-3
u		sequential	we	805-3
we	to	constraint	a homomorphism	805-3
we	wish	action	a homomorphism	805-3
we	find	action	a homomorphism	805-3
a homomorphism		sequential	that	805-3
that	folds	action	T	805-3
T	onto	constraint	a subtableau	805-3
a subtableau	with	constraint	minimal number	805-3
minimal number	of	constraint	rows	805-3
<B>	If	constraint	several stages	805-4
<B>	in	constraint	several stages	805-4
<B>	desired	attribute	this	805-4
<B>	can be done	action	several stages	805-4
several stages	of	constraint	which	805-4
which	or	conjunctive	one rows	805-4
which	eliminates	attribute	more	805-4
<B>	that	constraint	the first row	805-5
<B>	Note	action	the first row	805-5
the first row	because	constraint	every homomorphism	805-5
the first row	can not be eliminated	action	every homomorphism	805-5
every homomorphism	is	attribute	the identity	805-5
the identity	on	constraint	u	805-5
u	on	constraint	therefore x	805-5
u	and	conjunctive	therefore x	805-5
A similar observation	for	constraint	the third row	805-6
A similar observation	holds	action	the third row	805-6
the second row	However can be eliminated	action	the homomorphism	805-7
the second row	using	action	the homomorphism	805-7
the homomorphism		sequential	that	805-7
that	to	constraint	z	805-7
that	z 2	sequential	z	805-7
that	maps	action	z	805-7
z	and	conjunctive	the identity everywhere else	805-7
z	is	attribute	the identity everywhere else	805-7
the minimal tableau	to	constraint	T	805-8
T		sequential	u	805-8
u	of	constraint	the rows	805-8
u	and	conjunctive	the rows	805-8
u	Thus consists	attribute	first	805-8
the rows	of	constraint	T	805-8
An SPJR query	to	constraint	the minimized tableau	805-9
the minimized tableau	is	attribute	πAB	805-9
πAB		sequential	σ B=5	805-9
σ B=5		sequential	R	805-9
R		sequential	πBC	805-9
πBC		sequential	σ B=5	805-9
σ B=5		sequential	R	805-9
the optimization procedure	in	constraint	one join operation	806-1
the optimization procedure	Thus resulted	action	one join operation	806-1
the optimization procedure	saving	action	one join operation	806-1
<B>	Before	constraint	minimal tableau queries	807-1
<B>	leaving	action	minimal tableau queries	807-1
minimal tableau queries		sequential	we	807-1
we	present	action	a result	807-1
a result		sequential	that	807-1
that	describes	action	a strong correspondence	807-1
a strong correspondence	between	constraint	equivalent minimal tableau queries	807-1
Two tableau queries		sequential	T	807-2
T		sequential	u	807-2
u		sequential	T′	807-2
T′		sequential	u′	807-2
u′	if	constraint	there	807-2
u′	are	attribute	isomorphic	807-2
there	is	attribute	a one one substitution θ	807-2
a one one substitution θ		sequential	that	807-2
that	maps	action	variables	807-2
variables	to	constraint	variables	807-2
variables		sequential	θ	807-2
θ		sequential	T	807-2
T		sequential	u	807-2
u	=	sequential	T′	807-2
T′		sequential	u′	807-2
<B>	In	constraint	other words	807-3
other words		sequential	T	807-3
T		sequential	u	807-3
u	and	conjunctive	T ′	807-3
T ′		sequential	u′	807-3
u′	are	attribute	the same up to	807-3
renaming	of	constraint	variables	807-3
The proof	of	constraint	this result	807-4
this result	to	constraint	the reader	807-4
this result	is left	action	the reader	807-4
the reader	see	action	Exercise 6.11	807-4
Proposition		sequential	6.2.9	808-1
6.2.9	Let	action	q	808-1
q	=	sequential	T	808-1
T		sequential	u	808-1
u	and	conjunctive	q′	808-1
q′	=	sequential	T′ u′	808-1
T′ u′	and	conjunctive	<B>	808-1
T′ u′	be	attribute	minimal	808-1
q	and	conjunctive	q′	808-2
q′	are	attribute	Then isomorphic	808-2
Complexity	of	constraint	Tableau Decision Problems	809-1
Theorem		sequential	6.2.10	810-1
These results	if	constraint	q	811-1
These results	remain	attribute	true	811-1
q		sequential	q′	811-1
q′	to	constraint	single relation	811-1
q′	be	attribute	single relation	811-1
q′	are restricted	action	single relation	811-1
single relation	typed	action	tableau queries	811-1
tableau queries		sequential	that	811-1
that	have	action	no constants	811-1
Proof		sequential	Proof	812-1
The exact cover problem	to	constraint	a set	812-2
The exact cover problem	is	attribute	a set	812-2
The exact cover problem	decide	action	a set	812-2
The exact cover problem	given	action	a set	812-2
a set		sequential	X	812-2
X	=	sequential	x1	812-2
X	{	sequential	x1	812-2
<B>	.	sequential	<B>	812-3
<B>	.	sequential	<B>	812-4
xn		sequential	}	812-5
}	and	conjunctive	a collection	812-5
a collection		sequential	S	812-5
S	=	sequential	S1	812-5
S	{	sequential	S1	812-5
<B>	.	sequential	<B>	812-6
<B>	.	sequential	<B>	812-7
Sm		sequential	}	812-8
}	of	constraint	subsets	812-8
subsets	of	constraint	that	812-8
that		sequential	∪S	812-8
∪S	=	sequential	X	812-8
X	whether	constraint	there	812-8
there	is	attribute	an exact cover	812-8
an exact cover	of	constraint	X	812-8
X	by	constraint	S	812-8
S		sequential	a subset such	812-8
a subset such		sequential	S′	812-8
S′	of	constraint	S	812-8
S	that	constraint	each member	812-8
each member	of	constraint	X	812-8
X	in	constraint	exactly one member	812-8
X	occurs	action	exactly one member	812-8
exactly one member	of	constraint	S′	812-8
The exact cover problem	to	constraint	<B>	812-9
The exact cover problem	is known	attribute	np- complete	812-9
The exact cover problem	be	attribute	np- complete	812-9
We	now sketch	action	a polynomial transformation	813-1
a polynomial transformation	from	constraint	instances E	813-1
instances E	=	sequential	X	813-1
X		sequential	S	813-1
S	of	constraint	the exact cover problem	813-1
the exact cover problem	to	constraint	pairs qE	813-1
pairs qE		sequential	q′	813-1
q′	of	constraint	typed tableau queries	813-1
This construction	is applied	action	E	813-2
E	in	constraint	various ways	813-2
various ways	to	constraint	the np-completeness results	813-2
various ways	obtain	action	the np-completeness results	813-2
The construction	in	constraint	Fig	813-3
The construction	is illustrated	action	Fig	813-3
6.8		sequential	6.8	813-4
<B>	Let	action	E	814-1
E	=	sequential	X S	814-1
X S	be	attribute	an instance	814-1
an instance	of	constraint	the exact cover problem	814-1
the exact cover problem		sequential	X	814-1
X	where =	sequential	x1	814-1
X	{	sequential	x1	814-1
<B>	.	sequential	<B>	814-2
<B>	.	sequential	<B>	814-3
xn		sequential	}	814-4
}	and	conjunctive	S	814-4
S	=	sequential	S1	814-4
S	{	sequential	S1	814-4
<B>	.	sequential	<B>	814-5
<B>	.	sequential	<B>	814-6
Sm }		sequential	Sm }	814-7
<B>	Let	action	A1	814-8
<B>	.	sequential	<B>	814-9
<B>	.	sequential	<B>	814-10
An		sequential	B1	814-11
<B>	.	sequential	<B>	814-12
<B>	.	sequential	<B>	814-13
<B>	be	attribute	a listing	814-14
a listing	of	constraint	distinct attributes	814-14
distinct attributes	and	conjunctive	R	814-14
distinct attributes	let	action	R	814-14
R	to	constraint	this set	814-14
R	be chosen	action	this set	814-14
R	have	action	this set	814-14
this set	as	constraint	its sort	814-14
<B>	Both	conjunctive	qE	814-15
qE	and	conjunctive	q′	814-15
q′	over	constraint	relation R	814-15
q′	are	attribute	relation R	814-15
relation R	and	conjunctive	both queries E	814-15
both queries E	as	constraint	summary	814-15
both queries E	have	action	summary	814-15
summary		sequential	t	814-15
t	=	sequential	A1	814-15
A1		sequential	a 1	814-15
<B>	.	sequential	<B>	814-16
<B>	.	sequential	<B>	814-17
<B>		sequential	where a1	814-18
<B>	.	sequential	<B>	814-19
<B>	.	sequential	<B>	814-20
<B>	are	attribute	distinct variables	814-21
<B>	Let	action	b1	815-1
<B>	.	sequential	<B>	815-2
<B>	.	sequential	<B>	815-3
<B>	be	attribute	an additional set	815-4
an additional set	of	constraint	m	815-4
m		sequential	variables	815-4
The tableau TE	of	constraint	qE	815-5
qE	n	conjunctive	tuples	815-5
qE	has	action	tuples	815-5
tuples	to	constraint	a different element	815-5
tuples	corresponding	action	a different element	815-5
a different element	of	constraint	X	815-5
The tuple	for	constraint	xi	815-6
xi	for	constraint	attribute Ai	815-6
xi	has	action	attribute Ai	815-6
attribute Ai		sequential	bj	815-6
bj	for	constraint	attribute	815-6
<B>	Let	action	c1	816-1
<B>	.	sequential	<B>	816-2
<B>	.	sequential	<B>	816-3
cm	be	attribute	an additional set	816-4
an additional set	of	constraint	m distinct variables	816-4
The tableau T	of	constraint	q′	816-5
q′	has	action	m E E tuples	816-5
m E E tuples	to	constraint	a different element	816-5
m E E tuples	corresponding	action	a different element	816-5
a different element	of	constraint	S	816-5
<B>	To	constraint	the construction	817-1
<B>	illustrate	action	the construction	817-1
the construction	let	action	E	817-1
E	=	sequential	X S	817-1
X S	be	attribute	an instance	817-1
an instance	of	constraint	the exact cover problem	817-1
the exact cover problem		sequential	X	817-1
X	where =	sequential	x1	817-1
x1		sequential	x2	817-1
x2		sequential	x3	817-1
x3		sequential	x4 }	817-1
x4 }	and	conjunctive	S	817-1
S	=	sequential	S1	817-1
S	{	sequential	S1	817-1
S1		sequential	S2	817-1
S2		sequential	S3	817-1
S3		sequential	}	817-1
}		sequential	S1	817-1
S1	where =	sequential	x1	817-1
S1	{	sequential	x1	817-1
x1		sequential	x3	817-1
x3	}	sequential	S2	817-1
S2	=	sequential	x2	817-1
S2	{	sequential	x2	817-1
x2		sequential	x3	817-1
x3		sequential	x4	817-1
x4	}	sequential	S3	817-1
S3	=	sequential	x2	817-1
S3	{	sequential	x2	817-1
x2		sequential	x4	817-1
x4		sequential	}	817-1
The tableau	queries	action	qξ	818-1
qξ	to	constraint	X	818-1
qξ	and	conjunctive	X	818-1
qξ	corresponding	action	X	818-1
X		sequential	S	818-1
S	in	constraint	Fig	818-1
S	q′ are shown	action	Fig	818-1
6.8		sequential	6.8	818-2
the ξ blank entries	Here indicate	action	distinct new variables	818-3
<B>	that	constraint	ξ	818-4
<B>	Note	action	ξ	818-4
ξ	=	sequential	X	818-4
X		sequential	S	818-4
S	and	conjunctive	q′ ⊆ q	818-4
S	is	attribute	satisfiable	818-4
it	to	constraint	a given instance	819-1
it	that	constraint	a given instance	819-1
it	for	constraint	a given instance	819-1
it	is	attribute	More generally straightforward	819-1
it	verify	action	a given instance	819-1
a given instance		sequential	ξ	819-1
ξ	=	sequential	X	819-1
X		sequential	S	819-1
S	of	constraint	the exact cover problem	819-1
the exact cover problem		sequential	X	819-1
X	has	action	an exact cover	819-1
an exact cover	in	constraint	S iff	819-1
S iff		sequential	q′ ⊆ q parts	819-1
q′ ⊆ q parts	and	conjunctive	c	819-1
c	of	constraint	the theorem	819-1
the theorem	for	constraint	Exercise 6.16	819-1
the theorem	b is left	action	Exercise 6.16	819-1
Static Analysis	and	conjunctive	Optimization R	820-1
Optimization R		sequential	R b c	820-1
R b c		sequential	1 c	820-1
1 c		sequential	3 b	820-1
3 b		sequential	2 b	820-1
2 b		sequential	3 c	820-1
3 c		sequential	c 3 b	820-1
c 3 b		sequential	1 b	820-1
1 b		sequential	2 c	820-1
2 c		sequential	c 2 b	820-1
c 2 b		sequential	2 b 3 q ξ	820-1
2 b 3 q ξ		sequential	q′ξ Figure	820-1
q′ξ Figure		sequential	6.8	820-1
6.8		sequential	Tableau queries	820-1
Tableau queries	to	constraint	an exact cover data	820-1
Tableau queries	corresponding	action	an exact cover data	820-1
<B>	Given	action	an n-way	820-2
an n-way	join	action	the System R optimizer	820-2
the System R optimizer	may potentially consider	action	n	820-2
evaluation strategies	on	constraint	different orderings	820-3
evaluation strategies	based	action	different orderings	820-3
different orderings	of	constraint	the n relations	820-3
the n relations	in	constraint	the size	820-3
the n relations	be	attribute	may exponential	820-3
the size	of	constraint	the query	820-3
<B>	In	constraint	many cases	820-4
many cases		sequential	the search	820-4
the search	for	constraint	a minimal tableau	820-4
a minimal tableau	to	constraint	optimal join	820-4
a minimal tableau	or	conjunctive	optimal join	820-4
a minimal tableau	left	attribute	right	820-4
optimal join	because	constraint	the data	820-4
optimal join	may be justified	action	the data	820-4
the data	than	constraint	the initial query	820-4
the data	is	attribute	so much larger	820-4
<B>	in	constraint	Part D	820-5
Part D		sequential	we	820-5
we	both	conjunctive	data complexity	820-5
we	More generally shall examine	action	data complexity	820-5
data complexity	and	conjunctive	expression complexity	820-5
expression complexity		sequential	the former	820-5
the former	on	constraint	complexity	820-5
the former	where focuses	action	complexity	820-5
complexity	to	constraint	the size	820-5
the size	of	constraint	the data	820-5
the data	to	constraint	the size	820-5
the data	and	conjunctive	the size	820-5
the size	of	constraint	queries	820-5
Static Analysis	of	constraint	the Relational Calculus	821-1
<B>	In	constraint	we	821-2
we	present	action	a general technique	821-2
a general technique	for	constraint	the undecidability	821-2
a general technique	proving	action	the undecidability	821-2
the undecidability	of	constraint	problems	821-2
problems	involving	action	static analysis	821-2
static analysis	of	constraint	first order	821-2
first order		sequential	queries	821-2
queries	and	conjunctive	the undecidability	821-2
queries	demonstrate	action	the undecidability	821-2
the undecidability	of	constraint	three such problems	821-2
We	by	constraint	the basic property	822-1
We	on	constraint	the basic property	822-1
We	begin	action	the basic property	822-1
We	focusing	action	the basic property	822-1
the basic property	of	constraint	satisfiability	822-1
<B>	that	constraint	a query q	822-2
<B>	Recall	action	a query q	822-2
a query q	if	constraint	there	822-2
a query q	is	attribute	satisfiable	822-2
there	is	attribute	some input	822-2
some input		sequential	I	822-2
I		sequential	that q	822-2
that q		sequential	I	822-2
I	is	attribute	nonempty	822-2
All conjunctive queries	are	attribute	satisfiable	822-3
Proposition		sequential	4.2.2	822-3
4.2.2	if	constraint	equality	822-3
4.2.2	and	conjunctive	equality	822-3
equality	is incorporated	action	satisfiability	822-3
satisfiability	but	conjunctive	it	822-3
satisfiability	is not guaranteed	action	it	822-3
it	is	attribute	decidable	822-3
Exercise		sequential	4.5	822-3
<B>	for	constraint	the calculus	822-4
<B>	no longer holds	action	the calculus	822-4
<B>	To	constraint	this result	823-1
<B>	prove	action	this result	823-1
this result		sequential	we	823-1
we	use	action	a reduction	823-1
a reduction	of	constraint	the Post Correspondence Problem	823-1
the Post Correspondence Problem		sequential	PCP	823-1
PCP	see	action	Chapter 2	823-1
Chapter 2	to	constraint	the satisfiability problem	823-1
The reduction	in	constraint	terms	823-2
The reduction	is most easily described	action	terms	823-2
terms	of	constraint	the calculus	823-2
the calculus		sequential	it	823-2
it	of course can also be established	action	the algebras	823-2
it	using	action	the algebras	823-2
the algebras	or	conjunctive	nr-datalog¬	823-2
There	is	attribute	an important difference	824-1
<B>	In	constraint	first order	824-2
first order		sequential	conventional logic	824-2
conventional logic	see	action	Chapter 2	824-2
Chapter 2	both	conjunctive	infinite interpretations	824-2
Chapter 2	and	conjunctive	infinite interpretations	824-2
infinite interpretations	are considered	action	<B>	824-2
Satisfiability	of	constraint	order	824-3
order		sequential	sentences	824-3
sentences	is	attribute	co-recursively enumerable	824-3
<B>	but	conjunctive	<B>	824-4
<B>	from	constraint	Gödel	824-5
<B>	follows	action	Gödel	824-5
Gödel		sequential	Completeness Theorem	824-5
<B>	In	constraint	contrast	824-6
contrast	in	constraint	the context	824-6
the context	of	constraint	first order	824-6
first order		sequential	queries	824-6
queries		sequential	only finite instances	824-6
only finite instances	are considered	attribute	legal	824-6
<B>	brings	action	us	824-7
us	into	constraint	the realm	824-7
the realm	of	constraint	finite model theory	824-7
<B>	As	constraint	satisfiability	824-8
<B>	will be shown	action	satisfiability	824-8
satisfiability	of	constraint	order	824-8
order		sequential	queries	824-8
queries	is	attribute	recursively enumerable	824-8
<B>	but	conjunctive	<B>	824-9
We	shall revisit	action	the contrast	824-10
the contrast	between	constraint	first order	824-10
first order		sequential	conventional logic	824-10
conventional logic	and	conjunctive	the database perspective	824-10
the database perspective		sequential	finite model theory	824-10
finite model theory	in	constraint	Chapters 9	824-10
Chapters 9	and	conjunctive	10	824-10
Theorem		sequential	6.3.1	825-1
6.3.1		sequential	Satisfiability	825-1
Satisfiability	of	constraint	relational calculus queries	825-1
relational calculus queries	is	attribute	r.e	825-1
<B>	but	conjunctive	<B>	825-2
Proof		sequential	Proof	826-1
<B>	To	constraint	satisfiability	827-1
<B>	that	constraint	satisfiability	827-1
<B>	show	action	satisfiability	827-1
satisfiability	is	attribute	not recursive	827-1
we	reduce	action	the PCP	827-1
the PCP	to	constraint	the satisfiability problem	827-1
<B>	In	constraint	we	827-2
we	that	constraint	there	827-2
we	if	constraint	there	827-2
we	show	action	there	827-2
there	were	attribute	an algorithm	827-2
an algorithm	for	constraint	satisfiability	827-2
an algorithm	solving	action	satisfiability	827-2
satisfiability		sequential	it	827-2
it	to	constraint	an algorithm	827-2
it	could be used	action	an algorithm	827-2
it	construct	action	an algorithm	827-2
an algorithm		sequential	that	827-2
that	solves	action	the PCP	827-2
<B>	Let	action	P	828-1
P	=	sequential	u1	828-1
<B>	.	sequential	<B>	828-2
<B>	.	sequential	<B>	828-3
un		sequential	v1	828-4
<B>	.	sequential	<B>	828-5
<B>	.	sequential	<B>	828-6
<B>	be	attribute	an instance	828-7
an instance	of	constraint	the PCP	828-7
the PCP		sequential	a pair	828-7
a pair	of	constraint	sequences	828-7
sequences	of	constraint	nonempty words	828-7
nonempty words	over	constraint	alphabet	828-7
alphabet	{	sequential	0,1	828-7
0,1		sequential	}	828-7
We	describe now	attribute	domain independent	828-8
a calculus query		sequential	qP	828-8
qP	=	sequential	ϕP }	828-8
ϕP }	with	constraint	the property	828-8
the property		sequential	that	828-8
that		sequential	qP	828-8
qP	is	attribute	satisfiable	828-8
iff		sequential	P	828-8
P	has	action	a solution	828-8
We	shall use	action	a relation schema R	829-1
a relation schema R	having	action	relations	829-1
relations		sequential	ENC	829-1
ENC		sequential	ODING	829-1
ODING	with	constraint	sort	829-1
sort		sequential	A	829-1
A		sequential	B	829-1
B		sequential	C	829-1
C		sequential	D	829-1
D		sequential	E	829-1
E	and	conjunctive	SYNCH	829-1
SYNCH		sequential	RONIZATION	829-1
RONIZATION	with	constraint	sort	829-1
sort		sequential	F	829-1
F		sequential	G	829-1
The query qP	shall use	action	constants	829-2
<B>	To	constraint	the construction	830-1
<B>	illustrate	action	the construction	830-1
the construction	of	constraint	the algorithm	830-1
the algorithm	consider	action	the following instance	830-1
the following instance	of	constraint	the PCP	830-1
the PCP		sequential	u1	830-1
u1	=	sequential	011	830-1
011		sequential	u2	830-1
u2	=	sequential	011	830-1
011		sequential	u3	830-1
u3	=	sequential	0	830-1
0		sequential	v1	830-1
v1	=	sequential	0	830-1
0		sequential	v2	830-1
v2	=	sequential	11	830-1
11		sequential	v3	830-1
v3	=	sequential	01100	830-1
<B>	that	constraint	1	831-1
<B>	=	sequential	1	831-1
<B>	Note	attribute	s	831-1
1		sequential	2	831-1
2		sequential	3	831-1
3		sequential	2	831-1
2	is	attribute	a solution	831-1
a solution	of	constraint	this instance	831-1
<B>	is	attribute	u1u2u3u2	831-2
u1u2u3u2	=	sequential	0110110011	831-2
0110110011	=	sequential	v1v2v3v2	831-2
Figure		sequential	6.9	832-1
6.9	shows	action	an input instance	832-1
<B>	In	constraint	the relation	833-1
the relation		sequential	ENC	833-1
ENC	of	constraint	this figure	833-1
this figure		sequential	the first two columns	833-1
the first two columns	form	action	a cycle	833-1
a cycle	so that	constraint	the 10 tuples	833-1
the 10 tuples	as	constraint	a sequence	833-1
the 10 tuples	can be viewed	action	a sequence	833-1
a sequence		sequential	a set	833-1
The third column	holds	action	a listing	833-2
a listing	of	constraint	the word	833-2
the word	w	constraint	that	833-2
the word	= 0110110011	sequential	that	833-2
that	witnesses	action	the solution	833-2
the solution	to	constraint	P	833-2
P		sequential	the fourth column	833-2
the fourth column	describes	action	which words	833-2
which words	of	constraint	sequence	833-2
sequence		sequential	u1	833-2
<B>	.	sequential	<B>	833-3
<B>	.	sequential	<B>	833-4
un	to	constraint	the fifth column	833-5
un	w	constraint	the fifth column	833-5
un	and	conjunctive	the fifth column	833-5
un	are used	action	the fifth column	833-5
un	obtain	action	the fifth column	833-5
the fifth column	describes	action	which words	833-5
which words	of	constraint	sequence	833-5
sequence		sequential	v1	833-5
<B>	.	sequential	<B>	833-6
<B>	.	sequential	<B>	833-7
vn	are used	action	<B>	833-8
The relation		sequential	SYNCH	833-9
SYNCH	to	constraint	the two representations	833-9
SYNCH	is used	action	the two representations	833-9
SYNCH	synchronize	action	the two representations	833-9
the two representations	of	constraint	the pairs	833-9
the two representations	w	constraint	the pairs	833-9
the two representations	by	constraint	the pairs	833-9
the two representations	listing	action	the pairs	833-9
the pairs	to	constraint	the beginnings	833-9
the pairs	corresponding	action	the beginnings	833-9
the beginnings	of	constraint	new u-words	833-9
new u-words	and	conjunctive	v-words	833-9
The formula		sequential	P	834-1
P	constructed now	action	subformulas	834-1
P	includes	action	subformulas	834-1
subformulas	to	constraint	the various conditions	834-1
subformulas	whether	constraint	the various conditions	834-1
subformulas	test	action	the various conditions	834-1
the various conditions	on	constraint	an input instance	834-1
the various conditions	just enumerated	action	an input instance	834-1
the various conditions	hold	action	an input instance	834-1
<B>	In	constraint	ENC	834-2
<B>	=	sequential	ENC	834-2
ENC		sequential	∧	834-2
∧		sequential	cycle ∧	834-2
cycle ∧		sequential	SYNCH keys	834-2
SYNCH keys		sequential	∧	834-2
∧		sequential	encode ϕv-	834-2
encode ϕv-		sequential	∧	834-2
∧		sequential	encode	834-2
encode		sequential	∧	834-2
∧		sequential	ϕu-v- synch	834-2
ϕu-v- synch	speaking informally	action	Static Analysis	834-2
Static Analysis	and	conjunctive	Optimization ENC	834-2
Optimization ENC		sequential	B C D E SYNCH F G c1 d1 c1 d2 c1 d2 c2 d3 c2 d3 c2 d3 c3	834-2
B C D E SYNCH F G c1 d1 c1 d2 c1 d2 c2 d3 c2 d3 c2 d3 c3		sequential	d3 c2 d3 c2 d2	834-2
d3 c2 d3 c2 d2		sequential	c2 d2	834-2
c2 d2		sequential	Figure	834-2
Figure		sequential	6.9	834-2
6.9		sequential	Encoding	834-2
Encoding	of	constraint	a solution	834-2
a solution	to	constraint	PCP	834-2
i		sequential	− 1 additional tuples	835-1
− 1 additional tuples	in	constraint	ENC	835-1
k		sequential	ci	836-1
ci		sequential	djk z1	836-1
<B>	.	sequential	<B>	836-2
<B>	.	sequential	<B>	836-3
zk	=	sequential	ui	836-4
ui		sequential	none	836-4
none	of	constraint	x2	836-4
<B>	.	sequential	<B>	836-5
<B>	.	sequential	<B>	836-6
xk	in	constraint	the first column	836-7
xk	occurs	action	the first column	836-7
the first column	of	constraint	SYNCH	836-7
SYNCH	if	constraint	yk	836-7
SYNCH	and	conjunctive	yk	836-7
yk	=	sequential	the value	836-7
yk	$	sequential	the value	836-7
the value	after	constraint	xk	836-7
xk	in	constraint	the first column	836-7
xk	occurs	action	the first column	836-7
the first column	of	constraint	SYNCH	836-7
x	and	conjunctive	y	837-1
y	as	constraint	ϕu-encode	837-1
y	in	constraint	ϕu-encode	837-1
y	is done	action	ϕu-encode	837-1
The constructions	of	constraint	these formulas	838-1
these formulas	are	attribute	relatively straightforward	838-1
we	give here	action	two	838-1
two	of	constraint	them	838-1
them	and	conjunctive	the others	838-1
them	leave	action	the others	838-1
the others	for	constraint	the reader	838-1
the reader	see	action	Exercise 6.19	838-1
<B>	In	constraint	we	838-2
we	let	action	ψ	838-2
ψ		sequential	x	838-2
x		sequential	y	838-2
y	=	sequential	∃p	838-2
∃p		sequential	q	838-2
q		sequential	r	838-2
r		sequential	ENC	838-2
ENC		sequential	x	838-2
x		sequential	y	838-2
y		sequential	p	838-2
p		sequential	q	838-2
q		sequential	r	838-2
<B>	If	constraint	ENC	839-1
ENC	satisfies	action	ϕENC −key ∧ ϕcycle	839-1
ϕENC −key ∧ ϕcycle		sequential	the first two coordinates	839-1
the first two coordinates	of	constraint	ENC	839-1
ENC	or	conjunctive	one disjoint cycles	839-1
ENC	hold	attribute	more	839-1
one disjoint cycles		sequential	exactly one	839-1
exactly one	of	constraint	which	839-1
which	the value $	sequential	<B>	839-1
which	contains	action	<B>	839-1
Parts		sequential	1	840-1
1	and	conjunctive	2	840-1
2	of	constraint	ϕu-v-synch	840-1
ϕu-v-synch	by	constraint	the formula SYNCH	840-1
ϕu-v-synch	are realized	action	the formula SYNCH	840-1
the formula SYNCH	$	sequential	$	840-1
the formula SYNCH	,	sequential	$	840-1
<B>	that	constraint	the query qP	841-1
<B>	Verifying	action	the query qP	841-1
the query qP	if	constraint	P	841-1
the query qP	if	constraint	P	841-1
the query qP	and	conjunctive	P	841-1
the query qP	is	attribute	satisfiable	841-1
P	has	action	a solution	841-1
a solution	to	constraint	the reader	841-1
a solution	is left	action	the reader	841-1
the reader	see	action	Exercise 6.19	841-1
The preceding theorem	to	constraint	other important undecidability results	842-1
The preceding theorem	can be applied	action	other important undecidability results	842-1
The preceding theorem	derive	action	other important undecidability results	842-1
Corollary		sequential	6.3.2	843-1
Proof		sequential	Proof	844-1
<B>	see	action	Exercise 6.20	844-2
The proofs	of	constraint	undecidability	844-3
undecidability	by	constraint	reduction	844-3
undecidability	are	attribute	reduction	844-3
reduction	from	constraint	the satisfiability problem	844-3
<B>	For	constraint	equivalence	844-4
equivalence	that	constraint	there	844-4
equivalence	suppose	action	there	844-4
there	were	attribute	an algorithm	844-4
an algorithm	for	constraint	equivalence	844-4
an algorithm	deciding	action	equivalence	844-4
equivalence	between	constraint	relational calculus queries	844-4
the satisfiability problem	as	constraint	<B>	844-5
the satisfiability problem	Then can be solved	action	<B>	844-5
the satisfiability problem	follows	action	<B>	844-5
<B>	.	sequential	<B>	844-6
<B>	.	sequential	<B>	844-7
xn		sequential	}	844-8
}	if	constraint	it	844-8
}	if	constraint	it	844-8
}	and	conjunctive	it	844-8
}	is	attribute	unsatisfiable	844-8
it	to	constraint	the empty query q∅	844-8
it	is	attribute	equivalent	844-8
<B>	that	constraint	equivalence	844-9
<B>	demonstrates	action	equivalence	844-9
equivalence	is	attribute	not decidable	844-9
The undecidability	of	constraint	containment	845-1
containment	from	constraint	<B>	845-1
containment	also follows	attribute	this	845-1
<B>	For	constraint	domain independence	846-1
domain independence	let	action	ψ	846-1
ψ	be	attribute	a sentence	846-1
a sentence		sequential	whose truth value	846-1
whose truth value	on	constraint	the underlying domain	846-1
whose truth value	depends	action	the underlying domain	846-1
Then x1		sequential	Then x1	846-2
<B>	.	sequential	<B>	846-3
<B>	.	sequential	<B>	846-4
xn		sequential	∧	846-5
∧		sequential	ψ	846-5
ψ	is	attribute	domain	846-5
domain	if	constraint	ϕ	846-5
domain	if	constraint	ϕ	846-5
domain	and	conjunctive	ϕ	846-5
ϕ	is	attribute	unsatisfiable	846-5
The preceding techniques	to	constraint	optimization	847-1
The preceding techniques	that	constraint	optimization	847-1
The preceding techniques	can also be used	attribute	true	847-1
The preceding techniques	show	attribute	true	847-1
optimization	for	constraint	first order	847-1
optimization	can not be performed	action	first order	847-1
first order		sequential	the queries	847-1
the queries	see	action	Exercise 6.20d	847-1
Static Analysis	and	conjunctive	Optimization	848-1
Optimization		sequential	Computing	848-1
Computing	with	constraint	Acyclic Joins	848-1
<B>	In	constraint	the general case	848-2
the general case	if	constraint	the data	848-2
the general case	both	conjunctive	the data	848-2
the data	and	conjunctive	the join expression	848-2
the data	set	action	the join expression	848-2
the join expression	to	constraint	the time	848-2
the join expression	are allowed	action	the time	848-2
the join expression	vary	action	the time	848-2
the time	to	constraint	such expressions	848-2
the time	needed	action	such expressions	848-2
the time	evaluate	action	such expressions	848-2
such expressions	to	constraint	<B>	848-2
such expressions	appears	attribute	exponential	848-2
such expressions	be	attribute	exponential	848-2
The measure	of	constraint	complexity here	849-1
complexity here	is	attribute	a combination	849-1
a combination	of	constraint	data	849-1
a combination	both	conjunctive	data	849-1
data	and	conjunctive	expression	849-1
expression		sequential	complexity	849-1
complexity	and	conjunctive	Part D.	849-1
complexity	is	attribute	somewhat non-standard	849-1
complexity	see Interestingly	action	Part D.	849-1
Part D.		sequential	there	849-1
there	is	attribute	a special class	849-1
a special class	of	constraint	joins	849-1
joins	called	action	acyclic	849-1
acyclic	for	constraint	which	849-1
which		sequential	this evaluation	849-1
this evaluation	is	attribute	polynomial	849-1
A number	of	constraint	interesting properties	849-2
interesting properties	of	constraint	acyclic joins	849-2
acyclic joins	are also presented	action	<B>	849-2
<B>	For	constraint	this section	850-1
this section		sequential	we	850-1
we	use	action	the named perspective	850-1
the named perspective	on	constraint	project	850-1
the named perspective	and	conjunctive	project	850-1
the named perspective	focus exclusively	action	project	850-1
project	join	action	flat queries	850-1
flat queries	of	constraint	the form q	850-1
the form q		sequential	πX	850-1
πX		sequential	R1	850-1
R1		sequential	⊲⊳	850-1
⊲⊳		sequential	⊲⊳ Rn	850-1
⊲⊳ Rn	involving	action	projection	850-1
projection	and	conjunctive	natural join	850-1
<B>	For	constraint	this discussion	850-2
this discussion		sequential	we	850-2
we	that	constraint	R	850-2
we	assume	action	R	850-2
R	=	sequential	R1	850-2
<B>	.	sequential	<B>	850-3
<B>	.	sequential	<B>	850-4
Rn	is	attribute	a fixed database schema	850-5
a fixed database schema	and	conjunctive	we	850-5
we	use	action	I	850-5
I	=	sequential	I1	850-5
<B>	.	sequential	<B>	850-6
<B>	.	sequential	<B>	850-7
<B>	In	constraint	instances	850-8
<B>	to	constraint	instances	850-8
<B>	to	constraint	instances	850-8
<B>	refer	action	instances	850-8
instances	over	constraint	it	850-8
One	of	constraint	the historical motivations	851-1
the historical motivations	for	constraint	this problem	851-1
the historical motivations	studying	action	this problem	851-1
this problem	from	constraint	the pure universal relation assumption	851-1
this problem	stems	action	the pure universal relation assumption	851-1
the pure universal relation assumption		sequential	pure URA	851-1
An instance		sequential	I	851-2
I	=	sequential	I1	851-2
<B>	.	sequential	<B>	851-3
<B>	.	sequential	<B>	851-4
<B>	In	constraint	schema	851-5
<B>	over	constraint	schema	851-5
schema		sequential	R	851-5
R	satisfies	action	the pure URA	851-5
the pure URA	if	constraint	I	851-5
I	=	sequential	πR	851-5
πR		sequential	I	851-5
<B>	.	sequential	<B>	851-6
<B>	.	sequential	<B>	851-7
π		sequential	I	851-8
I	for	constraint	some instance	851-8
some instance		sequential	I	851-8
I	∪n	constraint	R Rn j	851-8
R Rn j	=1	sequential	j	851-8
<B>	If	constraint	I	852-1
I	satisfies	action	the pure URA	852-1
the pure URA		sequential	I	852-1
I	and	conjunctive	queries	852-1
I	can be stored	action	queries	852-1
queries	against	constraint	the corresponding instance	852-1
the corresponding instance		sequential	I	852-1
I	can be answered	action	joins	852-1
I	using	action	joins	852-1
joins	of	constraint	components	852-1
components	in	constraint	I	852-1
The URA	in	constraint	more depth	852-2
The URA	will be considered	action	more depth	852-2
more depth	in	constraint	Chapter 11	852-2
Worst Case		sequential	Results	853-1
Example		sequential	6.4.1	854-1
6.4.1	Let	action	n	854-1
6.10		sequential	<B>	854-2
It	that	constraint	the natural join	854-3
It	is easily seen	action	the natural join	854-3
the natural join	of	constraint	R1	854-3
<B>	.	sequential	<B>	854-4
<B>	.	sequential	<B>	854-5
Rn−1	in	constraint	the size	854-6
Rn−1	in	constraint	the size	854-6
Rn−1	n	conjunctive	the size	854-6
Rn−1	and	conjunctive	the size	854-6
Rn−1	is	attribute	exponential	854-6
the size	of	constraint	the input query	854-6
the input query	and	conjunctive	data	854-6
<B>	that	constraint	<B>	855-1
<B>	n	conjunctive	<B>	855-1
<B>	Now suppose	attribute	odd	855-1
<B>	is	attribute	odd	855-1
<B>	Let	action	Rn	855-2
Rn	as	constraint	Fig	855-2
Rn	in	constraint	Fig	855-2
Rn	be	attribute	Fig	855-2
6.10	and	conjunctive	the natural join	855-3
6.10	consider	action	the natural join	855-3
the natural join	of	constraint	R1	855-3
<B>	.	sequential	<B>	855-4
<B>	.	sequential	<B>	855-5
Rn		sequential	Rn	855-6
<B>	is	attribute	empty	855-7
<B>	On	constraint	the other hand	855-8
the other hand		sequential	the join	855-8
the join	of	constraint	i	855-8
i	of	constraint	i	855-8
i	for	constraint	i	855-8
i	n	conjunctive	size	855-8
i	has	action	size	855-8
size	in	constraint	i	855-8
It	that	constraint	the algorithms	855-9
It	follows	action	the algorithms	855-9
the algorithms	of	constraint	R	855-9
R	and	conjunctive	INGRES	855-9
INGRES		sequential	the System optimizers	855-9
the System optimizers	take	action	time	855-9
time	in	constraint	the size	855-9
the size	of	constraint	the input	855-9
the input	and	conjunctive	output	855-9
output	to	constraint	this query	855-9
output	evaluate	action	this query	855-9
The following result	that	constraint	it	856-1
The following result	implies	action	it	856-1
it	that	constraint	there	856-1
it	is	attribute	unlikely	856-1
there	is	attribute	an algorithm	856-1
an algorithm	for	constraint	computing projections	856-1
computing projections	of	constraint	joins	856-1
joins	in	constraint	time polynomial	856-1
time polynomial	in	constraint	the size	856-1
the size	of	constraint	the query	856-1
the query	and	conjunctive	the data	856-1
Theorem		sequential	6.4.2	857-1
<B>	if	constraint	q0	857-2
<B>	remains	attribute	true	857-2
q0	and	conjunctive	I	857-2
I	that	constraint	so |q0	857-2
I	are restricted	action	so |q0	857-2
so |q0		sequential	I	857-2
I	≤ 1	sequential	<B>	857-2
Proof		sequential	Proof	858-1
<B>	For	constraint	the converse	858-2
the converse	from	constraint	Theorem 6.2.10	858-2
the converse	recall	action	Theorem 6.2.10	858-2
Theorem 6.2.10	that	constraint	the problem	858-2
the problem	of	constraint	tableau containment	858-2
tableau containment	for	constraint	Ri	858-2
tableau containment	is	attribute	a np complete	858-2
Ri		sequential	even Rn b b b b b b b b Figure 6.10	858-2
even Rn b b b b b b b b Figure 6.10		sequential	Relations	858-2
Relations	to	constraint	join sizes relation typed tableaux	858-2
Relations	illustrate	action	join sizes relation typed tableaux	858-2
join sizes relation typed tableaux	having	action	no constants	858-2
We	to	constraint	the current problem	858-3
We	reduce	attribute	this	858-3
<B>	Let	action	q	858-4
q		sequential	T	858-4
T		sequential	u	858-4
u	and	conjunctive	q′	858-4
q′	=	sequential	T ′	858-4
T ′		sequential	u′	858-4
u′	be	attribute	constant	858-4
two typed tableau queries	over	constraint	the same relation schema	858-4
<B>	from	constraint	the Homomorphism Theorem	858-5
<B>	Recall	action	the Homomorphism Theorem	858-5
the Homomorphism Theorem		sequential	that	858-5
that	q	action	⊆	858-5
⊆	iff	constraint	there	858-5
there	is	attribute	a homomorphism	858-5
a homomorphism	of	constraint	q′	858-5
q′	to	constraint	q	858-5
q		sequential	which	858-5
which	holds	action	iff	858-5
iff		sequential	u ∈ q′	858-5
u ∈ q′		sequential	T	858-5
<B>	be	attribute	a copy	859-1
a copy	of	constraint	T	859-1
T		sequential	the ith attribute	859-1
the ith attribute	to	constraint	A	859-1
the ith attribute	where is renamed	action	A	859-1
<B>	Letting	action	xn	859-2
xn		sequential	xi	859-2
xi		sequential	u′	859-2
u′	=	sequential	<B>	859-2
<B>	.	sequential	<B>	859-3
<B>	.	sequential	<B>	859-4
<B>		sequential	it	859-5
it	to	constraint	m q′	859-5
it	that	constraint	m q′	859-5
it	is	attribute	straightforward	859-5
it	verify	action	m q′	859-5
m q′		sequential	T	859-5
T	=	sequential	π A	859-5
π A		sequential	⊲⊳	859-5
⊲⊳		sequential	Iv	859-5
Iv		sequential	v	859-5
v		sequential	∈ T	859-5
∈ T		sequential	}	859-5
<B>		sequential	m	860-1
<B>	To	constraint	the last sentence	861-1
<B>	see	action	the last sentence	861-1
the last sentence	of	constraint	the theorem	861-1
the theorem	let	action	u	861-1
u	=	sequential	u1	861-1
<B>	.	sequential	<B>	861-2
<B>	.	sequential	<B>	861-3
<B>	and	conjunctive	the query π A	861-4
<B>	use	action	the query π A	861-4
the query π A		sequential	A	861-4
A		sequential	⊲⊳	861-4
<B>	.	sequential	<B>	861-5
<B>	.	sequential	<B>	861-6
A		sequential	A	861-7
<B>		sequential	u′	862-1
u′		sequential	m Theorem 6.2.10	862-1
m Theorem 6.2.10	a considers	action	complexity	862-1
complexity	to	constraint	the size	862-1
the size	of	constraint	queries	862-1
<B>	As	constraint	the foregoing result	862-2
<B>	in	constraint	the foregoing result	862-2
<B>	applied	action	the foregoing result	862-2
the foregoing result		sequential	the queries	862-2
the queries	of	constraint	Theorem 6.2.10	862-2
Theorem 6.2.10		sequential	a form	862-2
a form		sequential	the basis	862-2
the basis	for	constraint	a database instance	862-2
the basis	constructing	action	a database instance	862-2
<B>	In	constraint	contrast	862-3
contrast	with	constraint	the earlier theorem	862-3
the earlier theorem		sequential	the preceding result	862-3
the preceding result	that	constraint	computing projections	862-3
the preceding result	suggests	action	computing projections	862-3
computing projections	of	constraint	joins	862-3
joins	to	constraint	the size	862-3
joins	is	attribute	intractable	862-3
the size	of	constraint	the query	862-3
the query		sequential	the stored data	862-3
the stored data	and	conjunctive	the output	862-3
<B>	In	constraint	Example 6.4.1	863-1
Example 6.4.1		sequential	we	863-1
we	may ask	action	what	863-1
what	is	attribute	the fundamental difference	863-1
the fundamental difference	between	constraint	R1	863-1
R1		sequential	Rn−1	863-1
Rn−1	and	conjunctive	R1	863-1
R1		sequential	Rn	863-1
One answer	that	constraint	the relation schemas	863-2
One answer	is	attribute	the relation schemas	863-2
the relation schemas	of	constraint	a cycle	863-2
the relation schemas	join	action	a cycle	863-2
the relation schemas	form	action	a cycle	863-2
a cycle	whereas	constraint	the relation schemas	863-2
the relation schemas	of	constraint	<B>	863-2
the relation schemas	do not	action	<B>	863-2
We	now develop	action	a formal notion	864-1
a formal notion	of	constraint	acyclicity	864-1
acyclicity	for	constraint	joins	864-1
joins	and	conjunctive	four properties	864-1
four properties		sequential	equivalent Static Analysis	864-1
equivalent Static Analysis	and	conjunctive	Optimization	864-1
Optimization	to	constraint	it	864-1
<B>	of	constraint	the context	864-2
<B>	in	constraint	the context	864-2
<B>	are expressed most naturally	action	the context	864-2
the context	of	constraint	the named perspective	864-2
the named perspective	for	constraint	the relational model	864-2
<B>	In	constraint	addition	864-3
addition		sequential	the notion	864-3
the notion	of	constraint	acyclicity	864-3
acyclicity	to	constraint	database schemas R=	864-3
acyclicity	is sometimes applied	action	database schemas R=	864-3
database schemas R=	{	sequential	R1	864-3
<B>	.	sequential	<B>	864-4
<B>	.	sequential	<B>	864-5
Rn	because of	constraint	the natural correspondence	864-6
the natural correspondence	between	constraint	the schema R	864-6
We	by	constraint	four interesting properties	865-1
We	begin	action	four interesting properties	865-1
We	describing	action	four interesting properties	865-1
four interesting properties		sequential	that	865-1
that	to	constraint	acyclicity	865-1
that	are	attribute	equivalent	865-1
<B>	Let	action	R	866-1
R	{	sequential	R1	866-1
<B>	.	sequential	<B>	866-2
<B>	.	sequential	<B>	866-3
Rn		sequential	}	866-4
}	be	attribute	a database schema	866-4
a database schema		sequential	each relation schema	866-4
each relation schema	where has	action	a different sort	866-4
An instance		sequential	I	866-5
I	of	constraint	R	866-5
R	to	constraint	each pair	866-5
R	if	constraint	each pair	866-5
R	for	constraint	each pair	866-5
R	is said	attribute	pairwise	866-5
R	be	attribute	pairwise	866-5
each pair		sequential	j	866-5
j		sequential	k	866-5
k		sequential	∈	866-5
∈		sequential	1	866-5
1		sequential	n	866-5
n		sequential	πR	866-5
πR		sequential	I j	866-5
I j		sequential	j	866-5
j		sequential	⊲⊳ Ik	866-5
⊲⊳ Ik		sequential	Ij	866-5
<B>	that	constraint	no tuple	866-6
<B>	Intuitively means	action	no tuple	866-6
no tuple	of	constraint	Ij	866-6
Ij	after	constraint	Ik	866-6
Ij	with	constraint	Ik	866-6
Ij	or	conjunctive	Ik	866-6
Ij	is dangling	action	Ik	866-6
Ij	lost	action	Ik	866-6
Ij	joining	action	Ik	866-6
Instance		sequential	I	866-7
I	if	constraint	each j	866-7
I	for	constraint	each j	866-7
I	is	attribute	globally consistent	866-7
each j		sequential	∈	866-7
∈		sequential	1	866-7
1		sequential	n	866-7
n		sequential	πR	866-7
πR	⊲	sequential	⊳I	866-7
Pairwise consistency	in	constraint	ptime	866-8
Pairwise consistency	can be checked	action	ptime	866-8
ptime	but	conjunctive	global consistency	866-8
ptime	checking	action	global consistency	866-8
global consistency	is	attribute	np- complete	866-8
Exercise		sequential	6.25	866-8
The first property		sequential	that	866-9
that	to	constraint	acyclicity	866-9
that	is	attribute	equivalent	866-9
acyclicity	is	attribute	Property	866-9
Property		sequential	1	866-9
1		sequential	Each instance	866-9
Each instance		sequential	I	866-9
I		sequential	that	866-9
that	is pairwise	attribute	consistent	866-9
that	is	attribute	globally consistent	866-9
<B>	that	constraint	the instance	867-1
<B>	Note	action	the instance	867-1
the instance	for	constraint	schema	867-1
schema	{	sequential	R1	867-1
<B>	.	sequential	<B>	867-2
<B>	.	sequential	<B>	867-3
Rn−1 }	of	constraint	Example 6.4.1	867-4
Example 6.4.1	whereas	constraint	the instance	867-4
Example 6.4.1	both	conjunctive	the instance	867-4
Example 6.4.1	and	conjunctive	the instance	867-4
Example 6.4.1	is	attribute	pairwise	867-4
the instance	for	constraint	{ R1	867-4
<B>	.	sequential	<B>	867-5
<B>	.	sequential	<B>	867-6
Rn }	but	conjunctive	<B>	867-7
Rn }	is	attribute	pairwise	867-7
The second property		sequential	we	868-1
we	by	constraint	query processing	868-1
we	consider	action	query processing	868-1
we	is motivated	action	query processing	868-1
query processing	in	constraint	a distributed environment	868-1
<B>	that	constraint	each relation	868-2
<B>	Suppose	action	each relation	868-2
each relation	of	constraint	I	868-2
I	at	constraint	a different site	868-2
I	is stored	action	a different site	868-2
a different site	that	constraint	⊳I	868-2
a different site	join	action	⊳I	868-2
⊳I	to	constraint	communication costs	868-2
⊳I	that	constraint	communication costs	868-2
⊳I	and	conjunctive	communication costs	868-2
⊳I	is	attribute	communication costs	868-2
⊳I	be computed	action	communication costs	868-2
communication costs	to	constraint	<B>	868-2
communication costs	are be minimized	action	<B>	868-2
A very naive algorithm	to	constraint	the join	868-3
A very naive algorithm	compute	action	the join	868-3
the join	to	constraint	the Ij	868-3
the join	of	constraint	the Ij	868-3
the join	is	attribute	each	868-3
the join	send	attribute	each	868-3
the Ij	to	constraint	a specific site	868-3
a specific site	and	conjunctive	the join	868-3
a specific site	form	action	the join	868-3
<B>	In	constraint	the general case	868-4
the general case	may cause	action	the shipment	868-4
the shipment	of	constraint	many unneeded tuples	868-4
many unneeded tuples	because	constraint	they	868-4
they	in	constraint	the full join	868-4
they	are dangling	action	the full join	868-4
The semi-join operator	to	constraint	this problem	869-1
The semi-join operator	can be used	action	this problem	869-1
The semi-join operator	alleviate	action	this problem	869-1
Given instances		sequential	Given instances	869-2
It	that	constraint	I	870-1
It	is easily verified	action	I	870-1
I	⊲⊳	action	J	870-1
J		sequential	I	870-1
I		sequential	J	870-1
J		sequential	J	870-1
J		sequential	J	870-1
J		sequential	I	870-1
I		sequential	I	870-1
there	Furthermore are	action	many cases	870-2
many cases	in	constraint	which	870-2
which	computing	action	the join	870-2
the join	in	constraint	one	870-2
one	of	constraint	these ways	870-2
these ways	can reduce	action	data transmission costs	870-2
data transmission costs	if	constraint	I	870-2
I	and	conjunctive	J	870-2
J	at	constraint	different nodes	870-2
J	are	attribute	different nodes	870-2
different nodes	of	constraint	a distributed database	870-2
a distributed database	see	action	Exercise 6.24	870-2
<B>	that	constraint	R	871-1
<B>	Suppose now	action	R	871-1
R	satisfies	action	Property	871-1
Property		sequential	1	871-1
<B>	Given	action	an instance	871-2
an instance		sequential	I	871-2
I	across	constraint	the network	871-2
I	distributed	action	the network	871-2
the network		sequential	one	871-2
one	can imagine	action	each relation	871-2
one	replacing	action	each relation	871-2
<B>	If	constraint	communication cost polynomial	871-3
<B>	with	constraint	communication cost polynomial	871-3
<B>	done cleverly	attribute	this	871-3
<B>	might be done	action	communication cost polynomial	871-3
communication cost polynomial	in	constraint	the size	871-3
the size	of	constraint	I	871-3
I	with	constraint	the result	871-3
the result	of	constraint	the replacements	871-3
the replacements	satisfying	action	pairwise consistency	871-3
<B>	Given	action	Property	871-4
Property		sequential	all relations	871-4
all relations	to	constraint	a common site	871-4
all relations	1 can now be shipped	action	a common site	871-4
a common site	in	constraint	the knowledge	871-4
the knowledge	that	constraint	no dangling tuples	871-4
no dangling tuples	have been shipped	action	<B>	871-4
<B>		sequential	a semi-join program	872-1
a semi-join program	for	constraint	R	872-1
R	is	attribute	a sequence Ri	872-1
a sequence Ri	of	constraint	commands	872-1
commands	=	sequential	R ⊲	872-1
R ⊲		sequential	R	872-1
R		sequential	i1	872-1
i1		sequential	Ri	872-1
Ri	=	sequential	R ⊲	872-1
R ⊲		sequential	R	872-1
R		sequential	i2 j2	872-1
Ri	=	sequential	R ⊲	873-1
R ⊲		sequential	R	873-1
R		sequential	p	873-1
p		sequential	ip	873-1
ip		sequential	jp R1 B C R2 B C D E	873-1
jp R1 B C R2 B C D E		sequential	R3 B C D G R4 C D E F	873-1
R3 B C D G R4 C D E F		sequential	Figure 6.11	873-1
Figure 6.11		sequential	Instance	873-1
Instance	for	constraint	Example 6.4.3	873-1
Example 6.4.3	would be made	action	<B>	873-1
<B>	is	attribute	a full reducer	873-2
a full reducer	for	constraint	R	873-2
R	if	constraint	each instance	873-2
R	for	constraint	each instance	873-2
each instance		sequential	I	873-2
I	over	constraint	R	873-2
R	applying	action	this program	873-2
this program	yields	action	an instance	873-2
Example Let		sequential	6.4.3	874-1
6.4.3		sequential	R	874-1
R	=	sequential	ABC	874-1
ABC		sequential	BCDE	874-1
BCDE		sequential	BCDG	874-1
BCDG		sequential	CDEF }	874-1
CDEF }	=	sequential	R1	874-1
R1		sequential	R2	874-1
R2		sequential	R3	874-1
R3		sequential	R4 }	874-1
R4 }	and	conjunctive	con- sider	874-1
con- sider		sequential	the instance	874-1
the instance		sequential	I	874-1
I	of	constraint	R	874-1
R	in	constraint	Fig	874-1
R	shown	action	Fig	874-1
6.11		sequential	6.11	874-2
I	nor	conjunctive	it	874-3
I	is	attribute	not globally consistent	874-3
I	is	attribute	it	874-3
it		sequential	<B>	874-3
R2	=	sequential	R2 ⊲	875-1
R2 ⊲		sequential	R1	875-1
R1		sequential	R2	875-1
R2	=	sequential	R2 ⊲	875-1
R2 ⊲		sequential	R4	875-1
R4		sequential	R3	875-1
R3	=	sequential	R3 ⊲	875-1
R3 ⊲		sequential	R2	875-1
R2		sequential	R2	875-1
R2	=	sequential	R2	875-1
R2	⊲	sequential	R3	875-1
R3		sequential	R4	875-1
R4	=	sequential	R4	875-1
R4	⊲	sequential	R2	875-1
R2		sequential	R1	875-1
R1	=	sequential	R1	875-1
R1		sequential	⊲	875-1
⊲		sequential	R2	875-1
R2	Note	action	that application	875-1
that application	of	constraint	this program	875-1
this program	to	constraint	I	875-1
I	has	action	the effect	875-1
the effect	of	constraint	the first tuple	875-1
the effect	removing	action	the first tuple	875-1
the first tuple	from	constraint	each relation	875-1
We	can now state	action	the second property	876-1
the second property		sequential	Property	876-1
Property		sequential	2	876-1
2		sequential	R	876-1
R	has	action	a full reducer	876-1
It	that	constraint	the schema	877-1
It	can be shown	action	the schema	877-1
the schema	{	sequential	R1	877-1
<B>	.	sequential	<B>	877-2
<B>	.	sequential	<B>	877-3
Rn−1 }	of	constraint	Example 6.4.1	877-4
Example 6.4.1	has	action	a full reducer	877-4
a full reducer	but	conjunctive	R1	877-4
a full reducer	{	sequential	R1	877-4
<B>	.	sequential	<B>	877-5
<B>	.	sequential	<B>	877-6
Rn	does not	action	Exercise 6.26	877-7
Rn	see	action	Exercise 6.26	877-7
The next property	provides	action	a way	878-1
a way	to	constraint	a schema	878-1
a way	view	action	a schema	878-1
a schema	as	constraint	a tree	878-1
a tree	with	constraint	certain properties	878-1
Property		sequential	3	879-1
3		sequential	R	879-1
R	has	action	a join tree	879-1
<B>	For	constraint	example	880-1
example		sequential	two join trees	880-1
two join trees	of	constraint	the schema R	880-1
the schema R	of	constraint	Figure 6.11	880-1
Figure 6.11	are	attribute	T1	880-1
T1	=	sequential	R	880-1
R		sequential	{	880-1
{		sequential	R1	880-1
R1		sequential	R2	880-1
R2		sequential	R2	880-1
R2		sequential	R3	880-1
R3		sequential	R2	880-1
R2		sequential	R4	880-1
R4		sequential	}	880-1
}	and	conjunctive	T2	880-1
T2	=	sequential	R	880-1
R		sequential	{	880-1
{		sequential	R1	880-1
R1		sequential	R3	880-1
R3		sequential	R3	880-1
R3		sequential	R2	880-1
R2		sequential	R2	880-1
R2		sequential	R4	880-1
R4		sequential	}	880-1
The edge labels	are not shown	action	<B>	880-2
Static Analysis	and	conjunctive	Optimization B F	881-1
Optimization B F		sequential	B	881-1
B		sequential	C	881-1
C		sequential	C D E	881-1
C D E		sequential	R	881-1
R		sequential	1	881-1
1		sequential	AB	881-1
AB		sequential	R 2	881-1
R 2		sequential	BC	881-1
BC		sequential	R 3	881-1
R 3		sequential	AC	881-1
AC		sequential	S 1	881-1
S 1		sequential	ABC	881-1
ABC		sequential	S 2	881-1
S 2		sequential	CDE	881-1
CDE		sequential	S 3	881-1
S 3		sequential	AFE	881-1
AFE		sequential	S 4	881-1
S 4		sequential	ACE	881-1
ACE		sequential	B	881-1
B		sequential	D C T	881-1
D C T		sequential	1	881-1
1		sequential	ABC	881-1
ABC		sequential	T 2	881-1
T 2		sequential	BCD	881-1
BCD		sequential	T 3	881-1
T 3		sequential	ABD	881-1
ABD		sequential	T	881-1
T		sequential	4	881-1
4		sequential	ACD	881-1
The hypergraph	of	constraint	schema R	881-2
schema R	is	attribute	the pair	881-2
the pair		sequential	U	881-2
U		sequential	R	881-2
R		sequential	U	881-2
U	where =	sequential	∪R	881-2
<B>	In	constraint	what	881-3
what	follows	action	we	881-3
we	to	constraint	database	881-3
we	often refer	action	database	881-3
database		sequential	a schema R	881-3
a schema R	as	constraint	a hypergraph	881-3
Three schemas	and	conjunctive	their hypergraphs	881-4
their hypergraphs	in	constraint	Fig	881-4
their hypergraphs	are shown	action	Fig	881-4
6.12		sequential	6.12	881-5
<B>	that	constraint	R	882-1
<B>	Suppose	action	R	882-1
R	is	attribute	a schema	882-1
a schema	and	conjunctive	I	882-1
I	over	constraint	R	882-1
R	satisfies	action	the pure URA	882-1
<B>	If	constraint	Rj	882-2
Rj		sequential	⊂ Rk	882-2
⊂ Rk		sequential	Ij	882-2
Ij	=	sequential	<B>	882-2
j k	and	conjunctive	<B>	883-1
It	in	constraint	this context	883-2
It	is	attribute	thus natural	883-2
this context	to	constraint	R	883-2
this context	that	constraint	R	883-2
this context	assume	action	R	883-2
R	as	constraint	a hypergraph	883-2
R	viewed	action	a hypergraph	883-2
a hypergraph	is reduced	action	<B>	883-2
<B>	In	constraint	this case	884-1
this case		sequential	f	884-1
f	is called	action	a witness	884-1
a witness		sequential	that	884-1
that		sequential	f	884-1
f	is	attribute	an ear	884-1
<B>	As	constraint	a special case	884-2
a special case	if	constraint	there	884-2
there	is	attribute	an edge	884-2
an edge	f	constraint	F	884-2
an edge	of	constraint	F	884-2
F		sequential	that	884-2
that	intersects	action	no other edge	884-2
no other edge		sequential	f	884-2
f	is also considered	action	an ear	884-2
<B>	For	constraint	example	885-1
example	in	constraint	the hypergraph	885-1
the hypergraph	of	constraint	Fig	885-1
edge		sequential	ABC	885-2
ABC	is	attribute	6.12 b an ear	885-2
6.12 b an ear	with	constraint	witness ACE	885-2
<B>	On	constraint	the other hand	886-1
the other hand		sequential	the hypergraph	886-1
the hypergraph	of	constraint	Fig	886-1
6.12	a has	action	no ears	886-2
We	now have	action	Input	887-1
Input		sequential	Hypergraph F	887-1
Hypergraph F	=	sequential	V	887-1
V		sequential	F	887-1
F		sequential	Output	887-1
The output	of	constraint	the GYO algorithm	888-1
the GYO algorithm	is always reduced	action	<B>	888-1
We	now state	attribute	the	889-1
following Property		sequential	4	889-1
<B>	Speaking informally	action	Example 6.4.1	890-1
Example 6.4.1	that	constraint	an absence	890-1
Example 6.4.1	suggests	action	an absence	890-1
an absence	of	constraint	cycles	890-1
cycles	yields	action	Properties	890-1
Properties		sequential	1	890-1
1	to	constraint	4	890-1
4	whereas	constraint	the presence	890-1
the presence	of	constraint	a cycle	890-1
a cycle	makes	action	these properties	890-1
these properties	fail	action	<B>	890-1
<B>	led	action	researchers	890-2
researchers	in	constraint	the late 1970s	890-2
the late 1970s	to	constraint	a notion	890-2
the late 1970s	for	constraint	a notion	890-2
the late 1970s	search	action	a notion	890-2
a notion	of	constraint	acyclicity	890-2
acyclicity	for	constraint	hypergraphs	890-2
hypergraphs		sequential	that	890-2
that	generalized	action	the usual notion	890-2
the usual notion	of	constraint	acyclicity	890-2
acyclicity	for	constraint	conventional undirected graphs	890-2
conventional undirected graphs	to	constraint	one	890-2
conventional undirected graphs	and	conjunctive	one	890-2
conventional undirected graphs	was	attribute	equivalent	890-2
one	of	constraint	the aforementioned properties	890-2
one	or	conjunctive	the aforementioned properties	890-2
<B>	For	constraint	example	890-3
example		sequential	the conventional notion	890-3
the conventional notion	of	constraint	hypergraph acyclicity	890-3
hypergraph acyclicity	from	constraint	graph theory	890-3
graph theory	due to	constraint	C. Berge	890-3
graph theory	is	attribute	C. Berge	890-3
C. Berge	but	conjunctive	it	890-3
it	that	constraint	this condition	890-3
it	turns out	action	this condition	890-3
this condition	for	constraint	the four properties	890-3
this condition	but	conjunctive	the four properties	890-3
this condition	is	attribute	necessary	890-3
the four properties	see	action	Exercise 6.32	890-3
We	now define	action	the notion	891-1
the notion	of	constraint	acyclicity	891-1
acyclicity		sequential	that	891-1
that	to	constraint	the four aforementioned properties	891-1
that	to	constraint	the four aforementioned properties	891-1
that	was found	attribute	equivalent	891-1
that	be	attribute	equivalent	891-1
<B>	Let	action	F	891-2
F		sequential	V	891-2
V		sequential	F	891-2
F	be	attribute	a hypergraph	891-2
A path	in	constraint	F	891-3
F	from	constraint	vertex v	891-3
vertex v	to	constraint	vertex v′	891-3
vertex v′	is	attribute	a sequence f1	891-3
a sequence f1	of	constraint	k	891-3
k	≥	sequential	1 edges	891-3
<B>	.	sequential	<B>	891-4
<B>	.	sequential	<B>	891-5
<B>	fk	attribute	such	891-6
Two vertexes	in	constraint	F	892-1
Two vertexes	are connected	action	F	892-1
F	if	constraint	there	892-1
there	is	attribute	a path	892-1
a path	between	constraint	them	892-1
The notions	of	constraint	connected pair	892-2
connected pair	of	constraint	edges	892-2
edges		sequential	connected component	892-2
connected component	and	conjunctive	connected hypergraph	892-2
connected hypergraph	in	constraint	the usual manner	892-2
connected hypergraph	are now defined	action	the usual manner	892-2
<B>	Now let	action	F	893-1
F		sequential	V	893-1
V		sequential	F	893-1
F	be	attribute	a hypergraph	893-1
a hypergraph	and	conjunctive	U ⊆ V	893-1
The restriction	of	constraint	F	893-2
F	to	constraint	U	893-2
U	denoted	action	F |U	893-2
F |U	is	attribute	the result	893-2
the result	of	constraint	the reduction	893-2
the result	forming	action	the reduction	893-2
the reduction	of	constraint	U	893-2
U		sequential	f	893-2
f	∩	sequential	U	893-2
U		sequential	f ∈ F	893-2
f ∈ F	}	sequential	}	893-2
f ∈ F	−	sequential	}	893-2
f ∈ F	{	sequential	}	893-2
f ∈ F	∅	sequential	}	893-2
Static Analysis F	and	conjunctive	Optimization	894-1
Optimization		sequential	Let	894-1
Let	=	sequential	V	894-1
V		sequential	F	894-1
F	be	attribute	a reduced hypergraph	894-1
a reduced hypergraph	let	action	f	894-1
f		sequential	f	894-1
f		sequential	′	894-1
′	be	attribute	distinct edges	894-1
distinct edges	and	conjunctive	g	894-1
distinct edges	let	action	g	894-1
g	=	sequential	f	894-1
f		sequential	∩ f ′	894-1
g	is	attribute	Then an articulation set	894-2
Then an articulation set	of	constraint	F	894-2
F	if	constraint	the number	894-2
the number	of	constraint	connected components	894-2
connected components	of	constraint	F |V −g	894-2
F |V −g	than	constraint	the number	894-2
F |V −g	is	attribute	greater	894-2
the number	of	constraint	connected components	894-2
connected components	of	constraint	F	894-2
<B>	generalizes	action	the notion	894-3
the notion	of	constraint	articulation point	894-3
articulation point	for	constraint	ordinary graphs	894-3
a reduced hypergraph F		sequential	V	895-1
V		sequential	F	895-1
F	if	constraint	each U ⊆ V	895-1
F	for	constraint	each U ⊆ V	895-1
F	is	attribute	Finally acyclic	895-1
each U ⊆ V	if	constraint	F |U	895-1
F |U	and	conjunctive	more than one edge	895-1
F |U	is connected	action	more than one edge	895-1
F |U	has	action	more than one edge	895-1
more than one edge		sequential	it	895-1
it	has	action	an articulation set	895-1
an articulation set		sequential	it	895-1
it	is	attribute	cyclic otherwise	895-1
<B>	that	constraint	F	896-1
<B>	if	constraint	F	896-1
<B>	Note	action	F	896-1
F		sequential	V	896-1
V		sequential	F	896-1
F	is	attribute	an acyclic hypergraph	896-1
an acyclic hypergraph	is	attribute	F |U	896-1
F |U	for	constraint	each U ⊆ V	896-1
Property		sequential	5	897-1
We	now present	action	the theorem	898-1
the theorem	stating	action	the equivalence	898-1
the equivalence	of	constraint	these five properties	898-1
Additional equivalent properties	in	constraint	Exercise 6.31	898-2
Additional equivalent properties	are presented	action	Exercise 6.31	898-2
Exercise 6.31	in	constraint	Chapter 8	898-2
Exercise 6.31	and	conjunctive	Chapter 8	898-2
Chapter 8		sequential	the relationship	898-2
the relationship	of	constraint	acyclicity	898-2
acyclicity	with	constraint	dependencies	898-2
dependencies	where is explored	action	<B>	898-2
Theorem		sequential	6.4.5 Properties	899-1
6.4.5 Properties		sequential	1	899-1
1	through	constraint	5	899-1
5	are	attribute	equivalent	899-1
Proof		sequential	Proof	900-1
The equivalence	of	constraint	3	900-2
3	and	conjunctive	4	900-2
4	as	constraint	Exercise 6.30	900-2
4	is left	action	Exercise 6.30	900-2
Exercise 6.30		sequential	<B>	900-2
We	in	constraint	this proof	901-1
We	assume	action	this proof	901-1
this proof	that	constraint	the hypergraphs	901-1
the hypergraphs	considered	action	generalization	901-1
the hypergraphs	are connected	action	generalization	901-1
generalization	to	constraint	the disconnected case	901-1
the disconnected case	is	attribute	straightforward	901-1
T1 =		sequential	T1 ⊲	902-1
T1 ⊲		sequential	S1	902-1
S1		sequential	T2	902-1
T2	=	sequential	T2	902-1
T2		sequential	S2	902-1
Tn−1	=	sequential	Tn−1	903-1
Tn−1		sequential	Sn−1	903-1
Sn−1		sequential	Sn−1	903-1
Sn−1	=	sequential	Sn−1	903-1
Sn−1		sequential	Tn−1	903-1
S2	=	sequential	S2	904-1
S2		sequential	⊲	904-1
⊲		sequential	T2	904-1
T2		sequential	S1	904-1
S1	=	sequential	S1	904-1
S1	⊲	sequential	T1	904-1
<B>	by	constraint	pairwise consistency	905-1
<B>	But	conjunctive	pairwise consistency	905-1
pairwise consistency		sequential	each step	905-1
each step	of	constraint	the full reducer	905-1
the full reducer	leaves	action	I	905-1
I		sequential	<B>	905-1
It	that	constraint	I	905-2
It	follows	action	I	905-2
I	=	sequential	I′	905-2
I′	is	attribute	globally consistent	905-2
I		sequential	I	906-1
B1		sequential	B1	907-1
Bq		sequential	Bq	908-1
p		sequential	p	909-1
p Figure		sequential	6.13	910-1
6.13		sequential	Instance	910-1
Instance	for	constraint	proof	910-1
proof	of	constraint	Theorem 6.4.5	910-1
<B>	In	constraint	addition	910-2
addition	by	constraint	minimality	910-2
minimality		sequential	no vertex	910-2
no vertex		sequential	attribute	910-2
attribute	in	constraint	U	910-2
U	in	constraint	only one edge	910-2
U	is	attribute	only one edge	910-2
only one edge		sequential	relation schema	910-2
<B>	Consider now	action	the schema R′	911-1
the schema R′	=	sequential	R2	911-1
R2	−	sequential	R1	911-1
<B>	.	sequential	<B>	911-2
<B>	.	sequential	<B>	911-3
Rn		sequential	R1 }	911-4
Two cases	arise	action	Case 1	911-5
Case 1		sequential	R′	911-5
R′	is connected	action	<B>	911-5
<B>	that	constraint	R1	911-6
<B>	Suppose	action	R1	911-6
R1	=	sequential	A1	911-6
R1	{	sequential	A1	911-6
<B>	.	sequential	<B>	911-7
<B>	.	sequential	<B>	911-8
Ap		sequential	}	911-9
}	and	conjunctive	U − R1	911-9
U − R1	=	sequential	<B>	911-9
U − R1	{ B1	sequential	<B>	911-9
<B>	.	sequential	<B>	911-10
<B>	.	sequential	<B>	911-11
Bq }		sequential	Bq }	911-12
<B>	Consider	action	the instance	912-1
the instance		sequential	I	912-1
I		sequential	U	912-1
U	in	constraint	Fig	912-1
U	shown	action	Fig	912-1
6.13		sequential	6.13	912-2
<B>	Define	action	I	912-3
I	=	sequential	I1	912-3
I	{	sequential	I1	912-3
<B>	.	sequential	<B>	912-4
<B>	.	sequential	<B>	912-5
<B>	In	constraint	}	912-6
}	that	constraint	Ij	912-6
Ij	so =	sequential	πR	912-6
πR		sequential	I	912-6
I	for	constraint	j ∈	912-6
j ∈		sequential	2	912-6
2		sequential	n	912-6
n	and	conjunctive	j I1	912-6
j I1	=	sequential	πR	912-6
πR		sequential	I	912-6
I		sequential	∪	912-6
∪	{	sequential	0	912-6
0		sequential	0	912-6
<B>	.	sequential	<B>	912-7
<B>	.	sequential	<B>	912-8
0 }		sequential	0 }	912-9
<B>	Using	action	the facts	913-1
the facts		sequential	that	913-1
that		sequential	R′	913-1
R′	that	constraint	each vertex	913-1
R′	and	conjunctive	each vertex	913-1
R′	is connected	action	each vertex	913-1
each vertex	of	constraint	R	913-1
R	in	constraint	two edges	913-1
R	at	constraint	two edges	913-1
R	occurs	attribute	least	913-1
two edges		sequential	it	913-1
it	to	constraint	I	913-1
it	that	constraint	I	913-1
it	is	attribute	straightforward	913-1
it	verify	action	I	913-1
I	but	conjunctive	which	913-1
I	is	attribute	pairwise consistent	913-1
which	is	attribute	a contradiction	913-1
a contradiction	see	action	Exercise	913-1
Exercise		sequential	6.30 b	913-1
Case		sequential	2	914-1
2		sequential	R′	914-1
R′	is not connected	action	<B>	914-1
<B>	Choose	action	a connected component	914-2
a connected component	of	constraint	R′	914-2
R′	and	conjunctive	{ S1	914-2
R′	let	action	{ S1	914-2
<B>	.	sequential	<B>	914-3
<B>	.	sequential	<B>	914-4
Sk		sequential	}	914-5
}	be	attribute	the set	914-5
the set	of	constraint	edges	914-5
edges	of	constraint	R −	914-5
R −		sequential	R1 }	914-5
R1 }	in	constraint	that connected component	914-5
R1 }	involved	action	that connected component	914-5
<B>	Let	action	S	914-6
S		sequential	∪k	914-6
∪k		sequential	S	914-6
S		sequential	i=1	914-6
i=1		sequential	i	914-6
i	and	conjunctive	R′	914-6
i	let	action	R′	914-6
R′		sequential	R Subcase	914-6
R Subcase		sequential	2.a	914-6
2.a		sequential	R′ ⊆ S j	914-6
R′ ⊆ S j	for	constraint	some j ∈	914-6
some j ∈		sequential	1	914-6
1		sequential	k	914-6
<B>	If	constraint	R′1 j	914-7
<B>	holds	action	R′1 j	914-7
R′1 j	is	attribute	an articulation set	914-7
an articulation set	for	constraint	R	914-7
R		sequential	which	914-7
which	is	attribute	a contradiction	914-7
a contradiction	see	action	Exercise	914-7
Exercise		sequential	6.30 b	914-7
Subcase		sequential	2.b	915-1
2.b		sequential	R′ ⊆	915-1
R′ ⊆		sequential	S j	915-1
S j	for	constraint	each j ∈	915-1
each j ∈		sequential	1	915-1
1		sequential	k	915-1
<B>	In	constraint	this case	915-2
this case		sequential	R′′	915-2
R′′	{	sequential	S1	915-2
<B>	.	sequential	<B>	915-3
<B>	.	sequential	<B>	915-4
Sk		sequential	R′1 hypergraph	915-5
R′1 hypergraph	with	constraint	fewer edges	915-5
fewer edges	than	constraint	R	915-5
<B>	By	constraint	minimality	915-6
minimality	of	constraint	R′′	915-6
minimality	that	constraint	R′′	915-6
minimality	n	conjunctive	R′′	915-6
minimality	implies	action	R′′	915-6
R′′	is	attribute	acyclic	915-6
<B>	Because	constraint	it	915-7
it	at	constraint	two edges	915-7
it	and	conjunctive	two edges	915-7
it	is connected	attribute	least	915-7
it	has	attribute	least	915-7
two edges		sequential	it	915-7
it	has	action	an articulation set	915-7
Two nested subcases	arise	action	Subcase 2.b.i	915-8
Subcase 2.b.i		sequential	Si	915-8
Si	∩	sequential	<B>	915-8
We	in	constraint	this case	915-9
We	argue	action	this case	915-9
this case	that	constraint	Si	915-9
Si	∩	sequential	<B>	915-9
<B>	that	constraint	Ri1 il y	915-10
<B>	Suppose	action	Ri1 il y	915-10
Ri1 il y	to	constraint	x	915-10
<B>	Let	action	Ri	915-11
Ri	be	attribute	the first edge	915-11
the first edge	in	constraint	this path	915-11
this path		sequential	that	915-11
that	in	constraint	not S p p	915-11
that	is	attribute	not S p p	915-11
Subcase 2.b.ii		sequential	R′ ∩ S	916-1
R′ ∩ S		sequential	i	916-1
i	is	attribute	an articulation pair	916-1
an articulation pair	for	constraint	i	916-1
<B>	In	constraint	this case	916-2
this case		sequential	R1	916-2
R1		sequential	∩ Si	916-2
∩ Si	is	attribute	an	916-2
Static Analysis	and	conjunctive	Optimization	917-1
It	that	constraint	g′	918-1
It	is easily verified	action	g′	918-1
g′	is	attribute	an ear	918-1
an ear	of	constraint	F	918-1
F	see	action	Exercise	918-1
Exercise		sequential	6.30 b	918-1
<B>	Because	constraint	F |V	918-2
F |V		sequential	−h	918-2
−h	has	action	more than two connected components	918-2
more than two connected components		sequential	it	918-2
it	that	constraint	F	918-2
it	follows	action	F	918-2
F	at	constraint	two ears	918-2
F	has	attribute	least	918-2
<B>	that	constraint	F	919-1
<B>	Finally suppose	action	F	919-1
F		sequential	V F	919-1
V F	is	attribute	acyclic	919-1
<B>	If	constraint	there	919-2
there	is	attribute	only one edge	919-2
only one edge		sequential	the GYO	919-2
<B>	from	constraint	Theorem 6.4.2	920-1
<B>	Recall	action	Theorem 6.4.2	920-1
Theorem 6.4.2	that	constraint	computing projections	920-1
computing projections	of	constraint	arbitrary joins	920-1
arbitrary joins	if	constraint	query	920-1
arbitrary joins	both	conjunctive	query	920-1
arbitrary joins	is	attribute	probably intractable	920-1
query	and	conjunctive	data size	920-1
data size	are considered	action	<B>	920-1
<B>	that	constraint	not the case	920-2
<B>	shows	attribute	this	920-2
<B>	is	attribute	not the case	920-2
not the case		sequential	the join	920-2
the join	is	attribute	when acyclic	920-2
Corollary		sequential	6.4.6	921-1
Proof	Because	constraint	the computation	922-1
the computation	for	constraint	each connected component	922-1
each connected component	of	constraint	R	922-1
R	can be performed separately	action	we	922-1
we	without	constraint	loss	922-1
we	assume	action	loss	922-1
loss	of	constraint	generality	922-1
generality		sequential	that	922-1
that		sequential	R	922-1
R	is connected	action	<B>	922-1
<B>	Let	action	R=	922-2
R=		sequential	R1	922-2
<B>	.	sequential	<B>	922-3
<B>	.	sequential	<B>	922-4
Rn	and	conjunctive	I	922-5
I	=	sequential	I1	922-5
<B>	.	sequential	<B>	922-6
<B>	.	sequential	<B>	922-7
<B>	In	constraint	<B>	922-8
<B>	First apply	action	a full reducer	922-9
a full reducer	to	constraint	I	922-9
I	to	constraint	<B>	922-9
I	obtain	action	<B>	922-9
<B>	.	sequential	<B>	922-10
<B>	.	sequential	<B>	922-11
I	′	action	n	922-12
<B>	takes	action	time polynomial	922-13
time polynomial	in	constraint	the size	922-13
the size	of	constraint	the query	922-13
the query	and	conjunctive	the input	922-13
the input		sequential	the result	922-13
the result	and	conjunctive	<B>	922-13
the result	is	attribute	globally consistent	922-13
<B>	Because	constraint	R	923-1
R	by	constraint	Theorem 6.4.5	923-1
R	is	attribute	acyclic	923-1
Theorem 6.4.5		sequential	there	923-1
there	is	attribute	a join tree T	923-1
a join tree T	for	constraint	R.	923-1
R.	Choose	action	a root	923-1
a root	for	constraint	T	923-1
T	say	action	R1	923-1
<B>	For	constraint	each subtree	923-2
<B>	Let	action	Jk	923-3
Jk	=	sequential	<B>	923-3
<B>	Inductively remove	action	nodes R k k	923-4
nodes R k k		sequential	J kZk k	923-4
It	that	constraint	the end kRk Rl∈Tk l	923-5
It	at	constraint	the end kRk Rl∈Tk l	923-5
It	follows	action	the end kRk Rl∈Tk l	923-5
the end kRk Rl∈Tk l	of	constraint	this process	923-5
this process		sequential	the answer	923-5
the answer	is	attribute	πXJ1	923-5
πXJ1	that	constraint	each intermediate stage	923-5
πXJ1	at	constraint	each intermediate stage	923-5
πXJ1	and	conjunctive	each intermediate stage	923-5
each intermediate stage		sequential	each instance	923-5
each instance		sequential	Jk	923-5
Jk	has	action	size	923-5
size	by	constraint	I	923-5
size	bounded	action	I	923-5
I	′|	action	|π k	923-5
|π k		sequential	X	923-5
X	⊲	sequential	IIk	923-5
X	⊳	sequential	IIk	923-5
IIk	see	action	Exercise 6.33	923-5
Bibliographic Notes		sequential	Bibliographic Notes	924-1
The paper		sequential	SAC+79	925-1
SAC+79	describes	action	query optimization	925-1
query optimization	in	constraint	System	925-1
System	/	sequential	R	925-1
R	including	action	a discussion	925-1
a discussion	of	constraint	multiple evaluation plans	925-1
a discussion	and	conjunctive	multiple evaluation plans	925-1
a discussion	generating	action	multiple evaluation plans	925-1
a discussion	analyzing	action	multiple evaluation plans	925-1
multiple evaluation plans	and	conjunctive	a thorough discussion	925-1
a thorough discussion	of	constraint	tuples	925-1
a thorough discussion	accessing	action	tuples	925-1
tuples	from	constraint	a single relation	925-1
a single relation	as from	constraint	a projection	925-1
a projection	and	conjunctive	selection	925-1
System	/	sequential	R	925-2
R	is	attribute	the precursor	925-2
the precursor	of	constraint	IBM	925-2
IBM		sequential	DB2 database management system	925-2
The optimizer	for	constraint	INGRES	925-3
INGRES	introduces	action	query decomposition	925-3
query decomposition	including	attribute	both	925-3
query decomposition	join	action	detachment	925-3
detachment	and	conjunctive	tuple	925-3
tuple		sequential	substitution	925-3
substitution		sequential	WY76	925-3
WY76		sequential	SWKH76	925-3
Bibliographic Notes		sequential	Bibliographic Notes	926-1
Research	on	constraint	buffer management policies	926-2
Research	optimizing	action	buffer management policies	926-2
buffer management policies	includes	action	FNS91	926-2
FNS91		sequential	INSS92	926-2
INSS92		sequential	NCS91	926-2
NCS91		sequential	Sto81	926-2
Other system optimizers	for	constraint	Exodus	926-3
Other system optimizers	include	attribute	those	926-3
Exodus		sequential	GD87	926-3
GD87	distributed	action	INGRES	926-3
INGRES		sequential	ESW78	926-3
ESW78		sequential	SDD	926-3
The recent work		sequential	IK90	927-1
IK90	on	constraint	evaluation plans	927-1
IK90	and	conjunctive	evaluation plans	927-1
IK90	focuses	attribute	optimal	927-1
IK90	finding	attribute	optimal	927-1
evaluation plans	for	constraint	n-way	927-1
n-way	in	constraint	where the hundreds	927-1
n-way	n	conjunctive	where the hundreds	927-1
n-way	is	attribute	where the hundreds	927-1
n-way	joins	action	where the hundreds	927-1
where the hundreds	using	action	simulated annealing	927-1
simulated annealing	and	conjunctive	techniques	927-1
<B>	about	constraint	this work	927-2
this work	are	attribute	characterizations	927-2
characterizations	of	constraint	the space	927-2
the space	of	constraint	evaluation plans	927-2
evaluation plans		sequential	properties	927-2
properties	of	constraint	evaluation plan cost	927-2
evaluation plan cost	in	constraint	relation	927-2
relation	to	constraint	natural metrics	927-2
natural metrics	on	constraint	this space	927-2
Early research	on	constraint	generation	928-1
generation	and	conjunctive	selection	928-1
selection	of	constraint	query evaluation plans	928-1
query evaluation plans	in	constraint	<B>	928-1
query evaluation plans	is found	action	<B>	928-1
<B>	forward chaining	action	Many expert systems	929-1
Many expert systems	in	constraint	AI	929-1
AI	also face	action	the problem	929-1
the problem	of	constraint	what	929-1
the problem	evaluating	action	what	929-1
what	to	constraint	conjunctive queries	929-1
what	amounts	action	conjunctive queries	929-1
The most common technique	for	constraint	conjunctive queries	929-2
The most common technique	evaluating	action	conjunctive queries	929-2
conjunctive queries	in	constraint	this context	929-2
this context	on	constraint	generate	929-2
this context	is based	action	generate	929-2
generate	and	conjunctive	test	929-2
test		sequential	a sequential algorithm	929-2
The paper		sequential	The paper	929-3
The technique	of	constraint	tableau query minimization	930-1
tableau query minimization	in	constraint	connection	930-1
tableau query minimization	was first developed	action	connection	930-1
connection	with	constraint	database queries	930-1
database queries	in	constraint	CM77	930-1
CM77	including	action	the Homomorphism Theorem	930-1
the Homomorphism Theorem		sequential	Theorem	930-1
Theorem		sequential	6.2.3	930-1
6.2.3	and	conjunctive	Theorem 6.2.6	930-1
Theorem 6.2.10	to	constraint	CM77	930-2
Theorem 6.2.10	is	attribute	also due	930-2
CM77		sequential	the proofs	930-2
the proofs	in	constraint	the exercises	930-2
the proofs	sketched	action	the exercises	930-2
the exercises	to	constraint	SY80	930-2
the exercises	are	attribute	due	930-2
SY80	and	conjunctive	ASU79 b	930-2
Refinements	of	constraint	this result	930-3
this result	to	constraint	subclasses	930-3
subclasses	of	constraint	typed tableau queries	930-3
typed tableau queries	in	constraint	ASU79 b	930-3
typed tableau queries	are presented	action	ASU79 b	930-3
ASU79 b		sequential	ASU79a	930-3
The notion	of	constraint	tableau homomorphism	931-1
tableau homomorphism	is	attribute	a special case	931-1
a special case	of	constraint	the notion	931-1
the notion	of	constraint	subsumption	931-1
subsumption	in	constraint	resolution theorem	931-1
subsumption	used	action	resolution theorem	931-1
resolution theorem	proving	action	CL73	931-1
That work	on	constraint	clauses	931-2
That work	focuses	action	clauses	931-2
clauses		sequential	disjunctions	931-2
disjunctions	of	constraint	literals	931-2
disjunctions	and	conjunctive	literals	931-2
literals	and	conjunctive	function symbols	931-2
literals	permits	action	function symbols	931-2
A clause C		sequential	L1	931-3
L1		sequential	∨ Ln	931-3
∨ Ln	subsumes	action	a clause D	931-3
a clause D	=	sequential	M1	931-3
M1		sequential	∨ Mk	931-3
∨ Mk	if	constraint	there	931-3
there	is	attribute	a substitution σ such	931-3
a substitution σ such	that	constraint	C	931-3
C		sequential	σ	931-3
σ	is	attribute	a subclause	931-3
a subclause	of	constraint	D.	931-3
D.		sequential	A generalized version	931-3
A generalized version	of	constraint	tableau minimization	931-3
tableau minimization	called	action	condensation	931-3
condensation	in	constraint	this connection	931-3
condensation	also arises	action	this connection	931-3
A condensation	of	constraint	a clause C	931-4
a clause C		sequential	L1	931-4
L1		sequential	Ln	931-4
Ln	is	attribute	a clause	931-4
a clause		sequential	C′	931-4
C′	=	sequential	Li	931-4
Li		sequential	∨ L	931-4
∨ L	with	constraint	C′	931-4
∨ L	that	constraint	C′	931-4
∨ L	m	attribute	minimal such	931-4
C′	=	sequential	<B>	931-4
<B>	As	constraint	1 im	931-5
1 im	in	constraint	Joy76	931-5
1 im	observed	action	Joy76	931-5
Joy76		sequential	condensations	931-5
condensations	up to	constraint	variable substitution	931-5
condensations	are	attribute	unique	931-5
Reference		sequential	SY80	932-1
SY80	studies	action	usage	932-1
SY80	restricted	action	usage	932-1
usage	of	constraint	difference	932-1
difference	with	constraint	SPCU queries	932-1
SPCU queries	for	constraint	which	932-1
which		sequential	several positive results	932-1
several positive results	can be obtained	action	decidability	932-1
decidability	of	constraint	containment	932-1
containment	see	action	Exercise 6.22	932-1
The undecidability results	for	constraint	the relational calculus	933-1
the relational calculus	from	constraint	results	933-1
the relational calculus	derive	action	results	933-1
results	in	constraint	DiP69	933-1
DiP69		sequential	Static Analysis	933-1
Static Analysis	and	conjunctive	Optimization	933-1
Optimization		sequential	instance	933-1
instance		sequential	the test	933-1
the test	for	constraint	containment	933-1
containment	is	attribute	co-r.e	933-1
<B>	in	constraint	our context	933-2
our context	whereas	constraint	it	933-2
it	is	attribute	r.e	933-2
infinite structures	when possibly are considered	action	<B>	933-3
<B>	by	constraint	reduction	933-4
<B>	is	attribute	reduction	933-4
reduction	to	constraint	the validity	933-4
the validity	of	constraint	a formula	933-4
a formula	in	constraint	first order	933-4
first order		sequential	predicate logic	933-4
predicate logic	with	constraint	equality	933-4
equality	using	action	the Gödel Completeness Theorem	933-4
The complexity	of	constraint	query languages	934-1
query languages	in	constraint	CH82	934-1
query languages	is studied	action	CH82	934-1
CH82		sequential	Var82a	934-1
Var82a	in	constraint	Part E	934-1
Var82a	and	conjunctive	Part E	934-1
Var82a	is considered	action	Part E	934-1
Part E	of	constraint	this volume	934-1
D -hard		sequential	D -hard	935-1
<B>	On	constraint	the other hand	935-2
the other hand		sequential	two conjunctive queries	935-2
two conjunctive queries	under	constraint	the bag semantics iff	935-2
two conjunctive queries	are	attribute	equivalent	935-2
the bag semantics iff		sequential	they	935-2
they	are	attribute	isomorphic	935-2
The notion	of	constraint	Berge acyclic	936-1
Berge acyclic	to	constraint	Ber76a	936-1
Berge acyclic	is	attribute	due	936-1
Fag83	investigates	action	several notions	936-2
several notions	of	constraint	acyclicity	936-2
acyclicity	including	action	the notion	936-2
the notion	in	constraint	this chapter	936-2
the notion	studied	action	this chapter	936-2
this chapter	and	conjunctive	Berge acyclicity	936-2
Further investigation	of	constraint	these alternative notions	936-3
these alternative notions	of	constraint	acyclicity	936-3
acyclicity	in	constraint	ADM85	936-3
acyclicity	is presented	action	ADM85	936-3
ADM85		sequential	DM86 b	936-3
DM86 b		sequential	GR86	936-3
Early attempts	to	constraint	a notion	936-4
Early attempts	develop	action	a notion	936-4
a notion	of	constraint	acyclic	936-4
acyclic		sequential	that	936-4
that	captured	action	desirable database characteristics	936-4
desirable database characteristics	include	action	Zan76	936-4
Zan76		sequential	Gra79	936-4
The relationship	of	constraint	acyclicity	937-1
acyclicity	with	constraint	dependencies	937-1
dependencies	in	constraint	Chapter 8	937-1
dependencies	is considered	action	Chapter 8	937-1
Many variations	of	constraint	the universal relation assumption	938-1
the universal relation assumption	in	constraint	the late 1970s	938-1
the universal relation assumption	arose	action	the late 1970s	938-1
the late 1970s	and	conjunctive	early 1980s	938-1
We	to	constraint	this topic	938-2
We	return	action	this topic	938-2
this topic	in	constraint	Chapter 11	938-2
Chapter 11		sequential	surveys	938-2
surveys	of	constraint	these notions	938-2
these notions	include	action	AP82	938-2
AP82		sequential	Ull82a	938-2
Ull82a		sequential	MRW86	938-2
Exercises Exercise		sequential	6.1	939-1
Exercises Exercise 6.2	Consider	action	the transformation σF	940-1
the transformation σF	⊲	sequential	⊳G	940-1
⊳G		sequential	q1 q2	940-1
q1 q2	→	sequential	σ F	940-1
σ F		sequential	q1	940-1
q1		sequential	⊲⊳G q2	940-1
⊲⊳G q2	of	constraint	Fig	940-1
6.2		sequential	6.2	940-2
<B>	Describe	action	query q	940-3
query q	and	conjunctive	database	940-3
database		sequential	a instance	940-3
a instance	for	constraint	which	940-3
which	applying	action	this transformation	940-3
this transformation	yields	action	a query	940-3
a query		sequential	whose direct implementation	940-3
whose direct implementation	than	constraint	q	940-3
whose direct implementation	of	constraint	q	940-3
whose direct implementation	is	attribute	dramatically more expensive	940-3
Exercise		sequential	6.3	941-1
Exercise		sequential	6.4	942-1
Exercise		sequential	6.5	943-1
6.5	Describe	action	a generalization	943-1
a generalization	of	constraint	sip strategies	943-1
sip strategies		sequential	that	943-1
that	permits	action	evaluation	943-1
evaluation	of	constraint	multiway	943-1
multiway	joins	action	an arbitrary binary tree	943-1
multiway	according to	action	an arbitrary binary tree	943-1
an arbitrary binary tree	to	constraint	only join processing	943-1
an arbitrary binary tree	using	action	only join processing	943-1
an arbitrary binary tree	left	action	only join processing	943-1
<B>	Give	action	an example	944-1
an example	in	constraint	which	944-1
which	yields	action	an evaluation plan	944-1
an evaluation plan	than	constraint	<B>	944-1
an evaluation plan	to	constraint	<B>	944-1
an evaluation plan	any join	action	<B>	944-1
Exercise		sequential	6.6	945-1
6.6	Consider	action	query expressions	945-1
query expressions		sequential	that	945-1
that	have	action	the form	945-1
the form		sequential	†	945-1
†	in	constraint	the discussion	945-1
†	mentioned	action	the discussion	945-1
the discussion	of	constraint	detachment	945-1
the discussion	join	action	detachment	945-1
detachment	in	constraint	Section 6.1	945-1
Exercise		sequential	6.7	946-1
Exercise		sequential	6.8	947-1
6.8	Prove	action	Corollary 6.2.4	947-1
Exercise		sequential	6.9	948-1
Exercise		sequential	6.10	949-1
The meaning q	of	constraint	q′	949-2
q′	is defined analogously	action	<B>	949-2
Static Analysis	and	conjunctive	Optimization	950-1
<B>		sequential	no constants	951-1
no constants	over	constraint	a single relation	951-1
a single relation		sequential	that q′ ⊆	951-1
that q′ ⊆		sequential	q′	951-1
q′	and	conjunctive	q′	951-1
q′		sequential	⊆ q′	951-1
⊆ q′	for	constraint	each pair	951-1
each pair		sequential	i	951-1
i		sequential	j j	951-1
j j		sequential	i	951-1
i		sequential	i	951-1
i	=	sequential	j	951-1
<B>		sequential	no constants	952-1
no constants	over	constraint	a single relation	952-1
a single relation	with	constraint	the property	952-1
the property		sequential	that	952-1
that		sequential	q′′	952-1
q′′		sequential	<B>	952-1
<B>	.	sequential	<B>	952-2
<B>	.	sequential	<B>	952-3
<B>	.	sequential	<B>	952-4
Exercise		sequential	6.11	953-1
Exercise		sequential	6.12	954-1
<B>	to	constraint	q	955-1
<B>	In	constraint	addition	955-2
addition	do	attribute	this	955-2
addition	using	action	typed tableau queries	955-2
Exercise		sequential	6.13	956-1
<B>	For	constraint	the following SPJR queries	956-2
<B>	of	constraint	the following SPJR queries	956-2
the following SPJR queries	over	constraint	R	956-2
R	construct	action	an equivalent tableau	956-2
an equivalent tableau	see	action	Exercise 4.19	956-2
Exercise 4.19	minimize	action	the tableau	956-2
the tableau	from	constraint	the minimized tableau	956-2
the tableau	and	conjunctive	the minimized tableau	956-2
the tableau	construct	action	the minimized tableau	956-2
the minimized tableau		sequential	an equivalent SPJR query	956-2
an equivalent SPJR query	with	constraint	minimal number	956-2
minimal number	of	constraint	joins	956-2
Exercise 6.15 Exhibit		sequential	a pair	957-1
a pair	of	constraint	typed restricted SPJ algebra queries q1	957-1
typed restricted SPJ algebra queries q1		sequential	q2	957-1
q2	over	constraint	a relation R	957-1
Exercises		sequential	Exercises	958-1
<B>	≡	sequential	<B>	959-1
Exercise		sequential	6.17	960-1
Exercise		sequential	6.18	961-1
i=1 Xi operations	among	constraint	all such queries	962-1
all such queries	is	attribute	np hard	962-1
Exercise		sequential	6.19	963-1
Exercise		sequential	6.20	964-1
Static Analysis	and	conjunctive	Optimization	965-1
Optimization	is	attribute	not simple	965-1
Exercise		sequential	6.23 Recall	966-1
6.23 Recall	from	constraint	Exercise 5.9	966-1
Exercise 5.9	that	constraint	an arbitrary nonrecursive datalog¬ rule	966-1
an arbitrary nonrecursive datalog¬ rule	as	constraint	a difference q1	966-1
an arbitrary nonrecursive datalog¬ rule	can be described	action	a difference q1	966-1
a difference q1		sequential	q2	966-1
q2		sequential	q1	966-1
q1	is	attribute	where an SPC query	966-1
where an SPC query	and	conjunctive	q2	966-1
q2	is	attribute	an SPCU query	966-1
Hint	Use	action	Exercise 6.22	967-1
programs		sequential	programs	968-1
Exercise		sequential	6.24	969-1
Exercise		sequential	6.25	970-1
Exercise		sequential	6.26	971-1
Exercise		sequential	6.27	972-1
Exercises Exercise 6.28		sequential	Exercises Exercise 6.28	973-1
<B>	Exercise	action	6.29	974-1
6.29	until	constraint	F	974-1
6.29	can be applied	action	F	974-1
F	=	sequential	V	974-1
V	−	sequential	v	974-1
V	{	sequential	v	974-1
v		sequential	}	974-1
}		sequential	F	974-1
F	−	sequential	f	974-1
f	}	sequential	∪	974-1
∪		sequential	f	974-1
f	−	sequential	v	974-1
f	{	sequential	v	974-1
v		sequential	}	974-1
}		sequential	}	974-1
}	−	sequential	}	974-1
}	∅	sequential	}	974-1
F	=	sequential	V	975-1
V		sequential	F	975-1
F	−	sequential	f	975-1
F	{	sequential	f	975-1
f		sequential	}	975-1
The result	of	constraint	the original GYO algorithm	976-1
The result	applying	action	the original GYO algorithm	976-1
the original GYO algorithm	to	constraint	a schema R	976-1
a schema R	is	attribute	the GYO reduction	976-1
the GYO reduction	of	constraint	R	976-1
Exercise 6.30		sequential	Exercise 6.30	977-1
Exercise		sequential	6.31 Rj	978-1
<B>	In	constraint	other words	978-2
other words		sequential	the intersection	978-2
the intersection	of	constraint	each R	978-2
each R	is contained	action	i	978-2
i		sequential	i	978-2
i	with	constraint	the union	978-2
the union	of	constraint	the previous R′j	978-2
the previous R′j	in	constraint	one	978-2
one	of	constraint	<B>	978-2
<B>	that	constraint	R	978-3
<B>	Prove	action	R	978-3
R	has	action	the running intersection property	978-3
the running intersection property		sequential	iff	978-3
iff		sequential	R	978-3
R	is	attribute	acyclic	978-3
Exercise		sequential	6.32	979-1
Exercise		sequential	6.33	980-1
Languages		sequential	Languages	981-1
Riccardo	from	constraint	<B>	982-1
Riccardo	select	action	<B>	982-1
<B>	s	action	it	983-1
Vittorio		sequential	there	984-1
there	are of course	action	lots	984-1
lots	of	constraint	bells	984-1
bells	and	conjunctive	whistles	984-1
Sergio		sequential	Sergio	985-1
<B>	In	constraint	this chapter	986-1
this chapter		sequential	we	986-1
we	discuss	action	the relationship	986-1
the relationship	of	constraint	the abstract query languages	986-1
the abstract query languages	to	constraint	three representative commercial relational query languages	986-1
the abstract query languages	discussed so far	action	three representative commercial relational query languages	986-1
three representative commercial relational query languages		sequential	Structured Query Language	986-1
Structured Query Language		sequential	SQL	986-1
SQL		sequential	Query	986-1
Query	By	constraint	Example	986-1
Example		sequential	QBE	986-1
QBE	and	conjunctive	Microsoft Access	986-1
SQL	by	constraint	the dominant relational query language	986-2
SQL	is	attribute	the dominant relational query language	986-2
the dominant relational query language	and	conjunctive	the basis	986-2
the dominant relational query language	provides as well	action	the basis	986-2
the basis	for	constraint	languages	986-2
languages	in	constraint	extensions	986-2
extensions	of	constraint	the relational model	986-2
<B>	Although	constraint	QBE	986-3
QBE	is	attribute	less widespread	986-3
it	illustrates nicely	action	the basic capabilities	986-3
the basic capabilities	and	conjunctive	problems	986-3
problems	of	constraint	graphic query languages	986-3
Access	is	attribute	a popular database management system	986-4
a popular database management system	for	constraint	personal computers	986-4
personal computers		sequential	PCs	986-4
PCs	and	conjunctive	many elements	986-4
PCs	uses	action	many elements	986-4
many elements	of	constraint	QBE	986-4
Our discussion	of	constraint	the practical languages	987-1
the practical languages	to	constraint	a complete description	987-1
the practical languages	is not intended	action	a complete description	987-1
the practical languages	provide	action	a complete description	987-1
a complete description	of	constraint	them	987-1
them	to	constraint	the similarities	987-1
them	of	constraint	the similarities	987-1
them	but	conjunctive	the similarities	987-1
them	rather indicate	attribute	some	987-1
the similarities	and	conjunctive	differences	987-1
differences	between	constraint	theory	987-1
theory	and	conjunctive	practice	987-1
We	on	constraint	the central aspects	987-2
We	focus here	action	the central aspects	987-2
the central aspects	of	constraint	these languages	987-2
Many features		sequential	string	987-3
string		sequential	comparison	987-3
comparison		sequential	operators	987-3
operators		sequential	iteration	987-3
iteration	and	conjunctive	embeddings	987-3
embeddings	into	constraint	a host language	987-3
a host language	on	constraint	<B>	987-3
a host language	or	conjunctive	<B>	987-3
a host language	are not mentioned	action	<B>	987-3
a host language	are touched only briefly	action	<B>	987-3
We	first present	action	highlights	988-1
highlights	of	constraint	the three languages	988-1
the three languages	and	conjunctive	considerations	988-1
the three languages	discuss	action	considerations	988-1
considerations		sequential	that	988-1
that	from	constraint	their use	988-1
that	arise	action	their use	988-1
their use	in	constraint	the real world	988-1
SQL		sequential	The Structured Query Language SQL	989-1
The Structured Query Language SQL	as	constraint	the preeminent query language	989-1
The Structured Query Language SQL	has emerged	action	the preeminent query language	989-1
the preeminent query language	for	constraint	mainframe	989-1
mainframe	and	conjunctive	client	989-1
client		sequential	server	989-1
server		sequential	relational dbms	989-1
relational dbms		sequential	s	989-1
This language	combines	action	the flavors	989-2
the flavors	of	constraint	the algebra	989-2
the flavors	both	conjunctive	the algebra	989-2
the algebra	and	conjunctive	the calculus	989-2
the calculus	for	constraint	the specification	989-2
the calculus	and	conjunctive	the specification	989-2
the calculus	is well suited	action	the specification	989-2
the specification	of	constraint	conjunctive queries	989-2
This section	by	constraint	conjunctive queries	990-1
This section	begins	action	conjunctive queries	990-1
This section	describing	action	conjunctive queries	990-1
conjunctive queries	how are expressed	action	SQL	990-1
conjunctive queries	using	action	SQL	990-1
We	to	constraint	additional features	991-1
We	progress	action	additional features	991-1
additional features	including	action	nested queries	991-1
nested queries	and	conjunctive	various forms	991-1
various forms	of	constraint	negation	991-1
Conjunctive Queries	in	constraint	SQL name	992-1
SQL name		sequential	Sequel	992-1
Sequel	at	constraint	the IBM San Jose Research Laboratory	992-1
It	by	constraint	the dominant mainframe commercial relational systems	992-2
It	of	constraint	the dominant mainframe commercial relational systems	992-2
It	is currently supported	attribute	most	992-2
the dominant mainframe commercial relational systems	by	constraint	increasingly relational dbms	992-2
the dominant mainframe commercial relational systems	and	conjunctive	increasingly relational dbms	992-2
increasingly relational dbms	for	constraint	PCs	992-2
The basic building block	of	constraint	SQL queries	993-1
SQL queries	from	constraint	the clause	993-1
SQL queries	is	attribute	select	993-1
<B>	Speaking loosely	attribute	these	993-2
<B>	have	action	the form select	993-2
the form select	from	constraint	example	993-2
the form select	For	constraint	example	993-2
example		sequential	queries	993-2
queries		sequential	4.1	993-2
4.1	and	conjunctive	4.4	993-2
4.4	of	constraint	Chapter 4	993-2
Chapter 4	by	constraint	select Director	993-2
Chapter 4	are expressed	action	select Director	993-2
select Director	from	constraint	Movies	993-2
Movies		sequential	Title	993-2
Title	where =	sequential	Cries	993-2
Cries	and	conjunctive	Whispers	993-2
Whispers	select	action	Location	993-2
<B>	For	constraint	example	993-3
example	in	constraint	the preceding queries	993-3
the preceding queries		sequential	the identifier Movies	993-3
the identifier Movies	as	constraint	tuples	993-3
the identifier Movies	over	constraint	tuples	993-3
the identifier Movies	can be viewed	action	tuples	993-3
the identifier Movies	ranging	action	tuples	993-3
tuples	in	constraint	relation Movies	993-3
Relation name	and	conjunctive	name pairs	993-4
Relation name	attribute	action	name pairs	993-4
name pairs		sequential	Location	993-4
The select keyword	has	action	the effect	994-1
the effect	of	constraint	the relational algebra projection operator	994-1
the relational algebra projection operator	from	constraint	keyword	994-1
keyword	has	action	the effect	994-1
the effect	of	constraint	the cross- product operator	994-1
the cross- product operator	and	conjunctive	keyword	994-1
keyword	has	action	the effect	994-1
the effect	of	constraint	the selection operator	994-1
the selection operator	see	action	Exercise 7.3	994-1
<B>	For	constraint	example	994-2
example		sequential	the second query	994-2
the second query	to	constraint	abbreviated attribute names	994-2
the second query	translates	action	abbreviated attribute names	994-2
the second query	using	action	abbreviated attribute names	994-2
D= Bergman		sequential	∧	995-1
∧		sequential	M.T	995-1
M.T		sequential	i=P	995-1
i=P		sequential	i∧P	995-1
i∧P		sequential	h=L.T	995-1
h=L.T	If	constraint	the attributes	995-1
h=L.T	of	constraint	the attributes	995-1
the attributes	in	constraint	clause	995-1
the attributes	from	constraint	clause	995-1
the attributes	mentioned	attribute	the	995-1
clause	to	constraint	output	995-1
clause	are	attribute	output	995-1
clause	be	attribute	output	995-1
output	in	constraint	place	995-1
output	can be used	action	place	995-1
place	of	constraint	an attribute list	995-1
an attribute list	in	constraint	the select clause	995-1
<B>	In	constraint	the where condition	995-2
the where condition	may include	action	conjunction	995-2
conjunction		sequential	disjunction	995-2
disjunction		sequential	negation	995-2
negation	as	constraint	blocks	995-2
negation	of	constraint	blocks	995-2
negation	from	constraint	blocks	995-2
negation	and	conjunctive	blocks	995-2
negation	will be seen shortly	attribute	select	995-2
negation	nesting	attribute	select	995-2
<B>	If	constraint	the clause	995-3
the clause	where is omitted	action	it	995-3
it	as	constraint	value true	995-3
it	is viewed	action	value true	995-3
it	having	action	value true	995-3
value true	for	constraint	all tuples	995-3
all tuples	of	constraint	the cross-product	995-3
<B>	In	constraint	implementations	995-4
implementations	as	constraint	Chapter 6	995-4
implementations	in	constraint	Chapter 6	995-4
implementations	suggested	action	Chapter 6	995-4
Chapter 6		sequential	optimizations	995-4
optimizations	for	constraint	example	995-4
optimizations	will be used	action	example	995-4
example	from	constraint	clauses	995-4
example	and	conjunctive	clauses	995-4
clauses	to	constraint	the effect	995-4
clauses	will typically be merged	action	the effect	995-4
clauses	have	action	the effect	995-4
the effect	of	constraint	an equi-join operator	995-4
<B>	In	constraint	SQL	996-1
SQL	as	constraint	most practical languages	996-1
SQL	with	constraint	most practical languages	996-1
most practical languages		sequential	duplicates	996-1
duplicates	in	constraint	a query answer	996-1
duplicates	may occur	action	a query answer	996-1
Notes Technically	on	constraint	Practical Languages	997-1
Practical Languages		sequential	the output	997-1
the output	of	constraint	an SQL query	997-1
an SQL query	be	attribute	may a bag	997-1
may a bag	also called	action	multiset	997-1
<B>	If	constraint	more than one variable	998-1
more than one variable	over	constraint	the same relation	998-1
more than one variable	ranging	action	the same relation	998-1
the same relation	is needed	action	variables	998-1
variables	in	constraint	clause	998-1
variables	from	constraint	clause	998-1
variables	can be introduced	attribute	the	998-1
<B>	For	constraint	example	998-2
example		sequential	query	998-2
query		sequential	4.7	998-2
4.7		sequential	which	998-2
which	for	constraint	pairs	998-2
which	asks	action	pairs	998-2
pairs	of	constraint	persons	998-2
persons	as	constraint	select M1	998-2
persons	and	conjunctive	select M1	998-2
persons	directed	attribute	the second	998-2
persons	directed	attribute	the first	998-2
persons	can be expressed	action	select M1	998-2
Director		sequential	M1	998-3
Actor	from	constraint	Movies M1	998-4
Movies M1		sequential	Movies M2	998-4
Movies M2		sequential	where M1	998-4
Director	=	sequential	M2	998-5
Actor	create	action	table Movies Director character	998-6
table Movies Director character		sequential	30	998-6
Other scalar types	in	constraint	SQL	998-7
Other scalar types	supported	action	SQL	998-7
SQL	include	action	integer	998-7
integer		sequential	small integer	998-7
small integer		sequential	float	998-7
float	and	conjunctive	date	998-7
Example		sequential	7.1.1	999-1
7.1.1	Let	action	R	999-1
R		sequential	A	999-1
A		sequential	S	999-1
S		sequential	B	999-1
B		sequential	T	999-1
T		sequential	C	999-1
C	be	attribute	a database schema	999-1
a database schema	and	conjunctive	the following query	999-1
a database schema	consider	action	the following query	999-1
the following query	from	constraint	R	999-1
the following query	select	action	R	999-1
R		sequential	S	999-1
S		sequential	T	999-1
T		sequential	where R.A S.B	999-1
where R.A S.B	or	conjunctive	R.A	999-1
R.A	=	sequential	T .C	999-1
T .C		sequential	which	999-1
which	yields	action	the empty answer	999-1
the empty answer	if	constraint	S	999-1
S	if	constraint	T	999-1
S	or	conjunctive	T	999-1
S	is	attribute	empty	999-1
T	is	attribute	empty	999-1
the foregoing SQL query	to	constraint	the calculus query	999-2
the foregoing SQL query	is	attribute	Thus not equivalent	999-2
select	from	constraint	The blocks	1000-1
The blocks	of	constraint	SQL	1000-1
SQL	in	constraint	a variety	1000-1
SQL	can be combined	action	a variety	1000-1
a variety	of	constraint	ways	1000-1
We	describe first	action	the incorporation	1000-2
the incorporation	of	constraint	the set operators	1000-2
the set operators		sequential	union	1000-2
union		sequential	intersect	1000-2
intersect	and	conjunctive	difference	1000-2
<B>	For	constraint	example	1000-3
example		sequential	the query List	1000-3
the query List		sequential	all actors	1000-3
all actors	and	conjunctive	director	1000-3
director	of	constraint	the movie	1000-3
the movie		sequential	Apocalypse Now	1000-3
Apocalypse Now	as	constraint	Movies	1000-3
Apocalypse Now	from	constraint	Movies	1000-3
Apocalypse Now	can be expressed	action	Movies	1000-3
Movies		sequential	Title	1000-3
Title	where =	sequential	Apocalypse	1000-3
Apocalypse		sequential	union	1000-3
union		sequential	Director Participant	1000-3
Director Participant	from	constraint	Movies	1000-3
Movies		sequential	Title	1000-3
Title	where =	sequential	Apocalypse	1000-3
Apocalypse		sequential	<B>	1000-3
<B>	illustrates	action	renaming	1000-4
renaming	of	constraint	attributes	1000-4
attributes	to	constraint	relation	1000-4
relation		sequential	variable renaming	1000-4
<B>	so that	constraint	the two relations	1000-5
<B>	is needed here	action	the two relations	1000-5
the two relations		sequential	that	1000-5
that	are unioned	action	compatible sort	1000-5
that	have	action	compatible sort	1000-5
SQL	also includes	action	a keyword	1001-1
a keyword	contains	action	which	1001-1
which	in	constraint	a selection condition	1001-1
which	can be used	action	a selection condition	1001-1
a selection condition	to	constraint	containment	1001-1
a selection condition	test	action	containment	1001-1
containment	between	constraint	the output	1001-1
the output	of	constraint	two nested expressions	1001-1
the output	from	constraint	two nested expressions	1001-1
Nested SQL Queries		sequential	Nested SQL Queries	1002-1
A simple illustration	of	constraint	nesting	1002-2
nesting	by	constraint	this alternative formulation	1002-2
nesting	is given	action	this alternative formulation	1002-2
this alternative formulation	of	constraint	query	1002-2
query		sequential	4.4	1002-2
4.4		sequential	Notes	1002-2
Notes	on	constraint	Practical Languages	1002-2
Practical Languages	select	action	Theater	1002-2
Theater	from	constraint	Pariscope	1002-2
Pariscope		sequential	where Title	1002-2
where Title	in	constraint	Title	1002-2
Title	from	constraint	Movies	1002-2
Movies		sequential	Director	1002-2
Director	where =	sequential	Bergman	1002-2
The keyword in	to	constraint	membership	1002-3
The keyword in	can also be used	action	membership	1002-3
The keyword in	test	action	membership	1002-3
membership	for	constraint	arbitrary arities	1002-3
The symbols	and	conjunctive	<B>	1002-4
<B>	in	constraint	SQL	1003-1
<B>	can be expressed	action	SQL	1003-1
SQL	by	constraint	select Title	1003-1
select Title		sequential	Theater	1003-1
Theater	from	constraint	Pariscope	1003-1
Pariscope		sequential	Title	1003-1
Title		sequential	Theater	1003-1
Theater	in	constraint	where not P1.	1003-1
<B>	from	constraint	Chapter 5	1003-2
<B>	Recall	action	Chapter 5	1003-2
Chapter 5	that	constraint	the family	1003-2
the family	of	constraint	nr-datalog¬ programs	1003-2
nr-datalog¬ programs	to	constraint	the calculus	1003-2
nr-datalog¬ programs	is	attribute	equivalent	1003-2
the calculus	and	conjunctive	algebra	1003-2
We	to	constraint	nr-datalog¬	1003-3
We	shall show	action	nr-datalog¬	1003-3
We	simulate	action	nr-datalog¬	1003-3
nr-datalog¬	using	action	SQL	1003-3
the result	from	constraint	the facts	1003-4
the result	Intuitively follows	action	the facts	1003-4
the facts	that	constraint	each rule	1003-4
each rule	a can be simulated	action	select	1003-4
each rule	using	action	select	1003-4
select	from	constraint	multiple rules	1003-4
select	the construct	action	multiple rules	1003-4
multiple rules	defining	action	the same predicate	1003-4
the same predicate	b can be simulated	action	union	1003-4
the same predicate	using	action	union	1003-4
union	and	conjunctive	c	1003-4
c		sequential	negation	1003-4
negation	in	constraint	rule bodies	1003-4
rule bodies	can be simulated	action	<B>	1003-4
rule bodies	using not in	action	<B>	1003-4
We	present here	action	an example	1004-1
an example	and	conjunctive	the formal proof	1004-1
an example	leave	action	the formal proof	1004-1
the formal proof	for	constraint	Exercise 7.4	1004-1
Example		sequential	7.1.2	1005-1
Pariscope′		sequential	xth	1006-1
xth		sequential	x title	1006-1
x title		sequential	Pariscope	1006-1
Pariscope		sequential	xth	1006-1
xth		sequential	x title	1006-1
x title		sequential	x sch	1006-1
<B>	In	constraint	the program	1007-1
the program		sequential	Bad_th	1007-1
Bad_th	holds	action	the list	1007-1
the list	of	constraint	theaters	1007-1
theaters	for	constraint	which	1007-1
which		sequential	one	1007-1
one	can find	action	a movie	1007-1
a movie	by	constraint	Hitchcock	1007-1
Hitchcock		sequential	that	1007-1
that		sequential	the theater	1007-1
the theater	is not showing	action	<B>	1007-1
The last rule	takes	action	the complement	1007-2
the complement	of	constraint	Bad_th	1007-2
Bad_th	with	constraint	respect	1007-2
respect	to	constraint	the list	1007-2
the list	of	constraint	theaters	1007-2
theaters	by	constraint	Location	1007-2
theaters	provided	action	Location	1007-2
Pariscope′	select	action	Theater	1008-1
Theater		sequential	Title	1008-1
Title	from	constraint	Pariscope	1008-1
Pariscope		sequential	Bad_th	1008-1
Bad_th	select	action	Theater	1008-1
Theater	from	constraint	Movies	1008-1
Movies		sequential	Location	1008-1
Location		sequential	Director	1008-1
Director	where =	sequential	Hitchcock	1008-1
Hitchcock	not in	constraint	Pariscope′	1008-1
Hitchcock	from	constraint	Pariscope′	1008-1
Pariscope′	select	action	Theater	1008-1
Theater	from	constraint	Location	1008-1
Location		sequential	Theater	1008-1
Theater	from	constraint	Bad_th	1008-1
<B>	In	constraint	nested queries	1008-2
<B>	involves	action	nested queries	1008-2
<B>	replacing	action	nested queries	1008-2
nested queries	by	constraint	their definitions	1008-2
their definitions	from	constraint	the answer relation	1008-2
their definitions	starting	action	the answer relation	1008-2
the answer relation	and	conjunctive	<B>	1008-2
the answer relation	working backward	action	<B>	1008-2
<B>	In	constraint	this example	1008-3
this example		sequential	we	1008-3
we	have	action	select Theater	1008-3
select Theater	from	constraint	Location	1008-3
Location		sequential	Theater	1008-3
Theater	in	constraint	where not Theater	1008-3
where not Theater	from	constraint	Movies	1008-3
Movies		sequential	Location	1008-3
Location		sequential	Director	1008-3
Director	=	sequential	Hitchcock	1008-3
Hitchcock	in	constraint	where not Theater	1008-3
where not Theater		sequential	Title	1008-3
Title	from	constraint	Pariscope	1008-3
<B>	As	constraint	a result	1008-4
a result		sequential	all variables	1008-4
all variables		sequential	that	1008-4
that	in	constraint	the rule	1008-4
that	occur	action	the rule	1008-4
the rule	by	constraint	edb relations	1008-4
the rule	are bound	action	edb relations	1008-4
edb relations	from	constraint	part	1008-4
edb relations	and	conjunctive	part	1008-4
part	of	constraint	the query	1008-4
part	possibly nested	action	the query	1008-4
the query	to	constraint	the rule	1008-4
the query	corresponding	action	the rule	1008-4
the rule	to	constraint	only edb relations	1008-4
the rule	so refers	action	only edb relations	1008-4
<B>	In	constraint	variables	1008-5
variables	in	constraint	rule bodies	1008-5
rule bodies	by	constraint	positively occurring idb relations	1008-5
rule bodies	however might be bound	action	positively occurring idb relations	1008-5
positively occurring idb relations		sequential	which	1008-5
which	in	constraint	clause	1008-5
which	from	constraint	clause	1008-5
which	can not be used	attribute	any	1008-5
clause	in	constraint	the final SQL query	1008-5
<B>	To	constraint	this problem	1009-1
<B>	resolve	action	this problem	1009-1
this problem		sequential	the nr-datalog¬ program	1009-1
the nr-datalog¬ program	so that	constraint	all positively occurring relations	1009-1
the nr-datalog¬ program	should be rewritten	action	all positively occurring relations	1009-1
all positively occurring relations	in	constraint	rule bodies	1009-1
rule bodies	are	attribute	edb relations	1009-1
edb relations	see	action	Exercise 7.4a	1009-1
View Creation	and	conjunctive	Updates	1010-1
SQL	includes	action	an explicit mechanism	1011-1
an explicit mechanism	for	constraint	view creation	1011-1
The relation		sequential	Champo info	1011-2
Champo info	from	constraint	Example 4.3.4	1011-2
Example 4.3.4	in	constraint	SQL	1011-2
Example 4.3.4	is created	action	SQL	1011-2
SQL	by	constraint	view Le Champo	1011-2
SQL	create	action	view Le Champo	1011-2
view Le Champo	as	constraint	select Pariscope	1011-2
We	briefly illustrate here	attribute	these	1012-1
some theoretical aspects	concerning	action	updates	1012-1
updates	in	constraint	Chapter 22	1012-1
updates	are presented	action	Chapter 22	1012-1
SQL	provides	action	three primitive commands	1013-1
three primitive commands	for	constraint	the contents	1013-1
three primitive commands	modifying	action	the contents	1013-1
the contents	of	constraint	a database	1013-1
a database		sequential	insert	1013-1
insert		sequential	delete	1013-1
delete	in	constraint	the sense	1013-1
delete	and	conjunctive	the sense	1013-1
delete	update	action	the sense	1013-1
the sense	of	constraint	individual tuples	1013-1
the sense	modifying	action	individual tuples	1013-1
individual tuples	of	constraint	a relation	1013-1
<B>	to	constraint	a new tuple	1014-1
<B>	following	action	a new tuple	1014-1
<B>	can be used	action	a new tuple	1014-1
<B>	insert	action	a new tuple	1014-1
a new tuple	into	constraint	the Movies database	1014-1
the Movies database	into	constraint	Movies values	1014-1
the Movies database	insert	action	Movies values	1014-1
Movies values		sequential	Apocalypse	1014-1
Apocalypse		sequential	Coppola	1014-1
Coppola		sequential	Duvall	1014-1
Duvall	delete	action	Movies	1014-1
Movies		sequential	Director	1014-1
Director	where =	sequential	Hitchcock	1014-1
<B>	In	constraint	subexpressions	1014-2
subexpressions	of	constraint	an algebra expression	1014-2
an algebra expression	in	constraint	intermediate temporary relations	1014-2
an algebra expression	can be computed	action	intermediate temporary relations	1014-2
intermediate temporary relations	see	action	Exercise 7.6	1014-2
This approach	does not allow	action	the same degree optimization	1014-3
the same degree optimization	as	constraint	the one	1014-3
the one	on	constraint	views	1014-3
the one	based	action	views	1014-3
views	because	constraint	the SQL interpreter	1014-3
the SQL interpreter	to	constraint	the intermediate relations	1014-3
the SQL interpreter	of	constraint	the intermediate relations	1014-3
the SQL interpreter	is required	attribute	each	1014-3
the SQL interpreter	materialize	attribute	each	1014-3
Query	by	constraint	Example	1015-1
Example	and	conjunctive	Microsoft Access	1015-1
<B>		sequential	Query	1015-2
Query	by	constraint	Example	1015-2
Example		sequential	QBE	1015-2
QBE	presents	action	a visual display	1015-2
a visual display	for	constraint	conjunctive queries	1015-2
a visual display	expressing	action	conjunctive queries	1015-2
conjunctive queries		sequential	that	1015-2
that	to	constraint	the perspective	1015-2
that	is	attribute	close	1015-2
the perspective	of	constraint	tableau queries	1015-2
The second language Access	on	constraint	personal computers	1015-3
The second language Access	is	attribute	available	1015-3
personal computers		sequential	it	1015-3
it	uses	action	elements	1015-3
elements	of	constraint	QBE	1015-3
QBE	with	constraint	a more graphical presentation	1015-3
QBE	but	conjunctive	a more graphical presentation	1015-3
a more graphical presentation	of	constraint	relationships	1015-3
a more graphical presentation	join	action	relationships	1015-3
QBE		sequential	QBE	1016-1
What films	with	constraint	Allen	1017-1
Allen	as	constraint	actor	1017-1
actor	or	conjunctive	director	1017-1
director	at	constraint	the Concorde	1017-1
director	are currently featured	action	the Concorde	1017-1
<B>	Under	constraint	one natural semantics	1018-1
one natural semantics	for	constraint	QBE queries	1018-1
QBE queries		sequential	which	1018-1
which	parallels	action	the semantics	1018-1
the semantics	of	constraint	conjunctive queries	1018-1
conjunctive queries	of	constraint	SQL	1018-1
conjunctive queries	and	conjunctive	SQL	1018-1
SQL		sequential	this query	1018-1
this query	will yield	action	the empty answer	1018-1
the empty answer	if	constraint	σ	1018-1
the empty answer	either	conjunctive	σ	1018-1
σ		sequential	Allen	1018-1
Allen		sequential	Director= Movies	1018-1
Director= Movies	or	conjunctive	σ Actor=	1018-1
σ Actor=		sequential	Allen	1018-1
Allen		sequential	Movies	1018-1
Movies	is	attribute	empty	1018-1
Movies	see	action	Example 7.1.1	1018-1
QBE	also includes	action	a capability	1019-1
a capability	of	constraint	condition boxes	1019-1
condition boxes		sequential	which	1019-1
which	as	constraint	an extension	1019-1
which	can be viewed	action	an extension	1019-1
an extension	of	constraint	the incorporation	1019-1
the incorporation	of	constraint	equality atoms	1019-1
equality atoms	into	constraint	tableau queries	1019-1
QBE	does not provide	action	a mechanism	1020-1
a mechanism	to	constraint	SQL	1020-1
SQL	for	constraint	nesting	1020-1
nesting	of	constraint	queries	1020-1
It	to	constraint	an appropriate visual representation	1020-2
It	is	attribute	hard	1020-2
It	develop	action	an appropriate visual representation	1020-2
an appropriate visual representation	of	constraint	such nesting	1020-2
such nesting	within	constraint	the QBE framework	1020-2
the QBE framework	in	constraint	part	1020-2
part	due to	constraint	the lack	1020-2
the lack	of	constraint	scoping rules	1020-2
More recent extensions	of	constraint	QBE	1020-3
QBE	address	action	this issue	1020-3
this issue	by	constraint	example	1020-3
this issue	for	constraint	example	1020-3
this issue	incorporating	action	example	1020-3
example		sequential	hierarchical windows	1020-3
QBE	also provides	action	mechanisms	1020-4
mechanisms	for	constraint	view definition	1020-4
mechanisms	both	conjunctive	view definition	1020-4
view definition	and	conjunctive	database	1020-4
database		sequential	update	1020-4
Negation	into	constraint	QBE queries	1021-1
Negation	can be incorporated	action	QBE queries	1021-1
QBE queries	in	constraint	a variety	1021-1
a variety	of	constraint	ways	1021-1
The use	of	constraint	database update	1021-2
database update	is	attribute	an obvious mechanism	1021-2
an obvious mechanism	although	constraint	<B>	1021-2
Two restricted Notes Director Concorde	on	constraint	Practical Languages Movies Title	1021-3
Practical Languages Movies Title		sequential	Pariscope Theater Title Schedule Concorde P._X	1021-3
Pariscope Theater Title Schedule Concorde P._X		sequential	P._Y	1021-3
P._Y		sequential	Figure	1021-3
Figure		sequential	7.1	1021-3
7.1		sequential	One form	1021-3
One form	of	constraint	union	1021-3
union	in	constraint	QBE Movies Title Director	1021-3
QBE Movies Title Director		sequential	Bergman Pariscope Theater Title Schedule P._champio	1021-3
Bergman Pariscope Theater Title Schedule P._champio		sequential	¬ Concorde Figure 7.2	1021-3
¬ Concorde Figure 7.2		sequential	forms	1021-3
forms	of	constraint	negation	1021-3
negation	in	constraint	Fig	1021-3
negation	are illustrated	action	Fig	1021-3
7.2		sequential	which	1021-4
which	expresses	action	the following query	1021-4
the following query	that	constraint	each film	1021-4
the following query	assuming	action	each film	1021-4
each film	has	action	only one director	1021-4
only one director		sequential	what theaters	1021-4
what theaters	than	constraint	the Concorde	1021-4
the Concorde	feature	action	a film	1021-4
a film	by	constraint	Bergman	1021-4
a film	not directed	action	Bergman	1021-4
The ¬	in	constraint	the Pariscope relation	1021-5
the Pariscope relation	restricts	action	attention	1021-5
attention	to	constraint	those tuples	1021-5
those tuples	with	constraint	Theater coordinate	1021-5
Theater coordinate	to	constraint	Concorde	1021-5
Concorde	and	conjunctive	the ¬	1021-5
the ¬	preceding	action	the tuple	1021-5
the tuple	in	constraint	the Movies relation	1021-5
the Movies relation	to	constraint	a negative literal	1021-5
the Movies relation	is	attribute	analogous	1021-5
a negative literal	in	constraint	a datalog rule	1021-5
a datalog rule	and	conjunctive	a limited form	1021-5
a datalog rule	captures	action	a limited form	1021-5
a limited form	of	constraint	¬∃	1021-5
¬∃	from	constraint	the calculus	1021-5
the calculus	in	constraint	this case	1021-5
this case		sequential	it	1021-5
it	excludes	action	all films	1021-5
all films	by	constraint	Bergman	1021-5
all films	directed	action	Bergman	1021-5
such negation	When is used	action	it	1021-6
it	that	constraint	all variables	1021-6
it	is required	action	all variables	1021-6
all variables		sequential	that	1021-6
that	in	constraint	a row	1021-6
that	occur	action	a row	1021-6
a row	by	constraint	positive rows	1021-6
a row	in	constraint	positive rows	1021-6
a row	preceded	action	positive rows	1021-6
a row	also appear	action	positive rows	1021-6
Other restricted forms	of	constraint	negation	1021-7
negation	in	constraint	QBE	1021-7
QBE	include	action	negative literals	1021-7
QBE	using	action	negative literals	1021-7
negative literals	in	constraint	condition boxes	1021-7
condition boxes	and	conjunctive	an operator	1021-7
condition boxes	supporting	action	an operator	1021-7
an operator	to	constraint	relational division	1021-7
relational division	as	constraint	Exercise	1021-7
relational division	in	constraint	Exercise	1021-7
relational division	defined	action	Exercise	1021-7
Exercise		sequential	5.8	1021-7
The following example	shows more generally how	action	view definition	1022-1
view definition	to	constraint	relational completeness	1022-1
view definition	can be used	action	relational completeness	1022-1
view definition	obtain	action	relational completeness	1022-1
Example		sequential	7.2.1	1023-1
<B>	As with	constraint	SQL	1023-2
SQL		sequential	the QBE query	1023-2
the QBE query	to	constraint	an nr-datalog¬	1023-2
the QBE query	corresponding	action	an nr-datalog¬	1023-2
an nr-datalog¬	or	conjunctive	one views	1023-2
an nr-datalog¬	will involve	attribute	more	1023-2
one views	for	constraint	each rule	1023-2
each rule	see	action	Exercise 7.5	1023-2
<B>	For	constraint	this example	1023-3
this example		sequential	it	1023-3
it	that	constraint	we	1023-3
it	turns out	action	we	1023-3
we	can compute	action	the effect	1023-3
the effect	of	constraint	the first two rules	1023-3
the first two rules	with	constraint	a single QBE query	1023-3
the two stages	of	constraint	the full query	1023-4
the full query	in	constraint	Fig	1023-4
the full query	Thus are shown	action	Fig	1023-4
7.3		sequential	the symbol I.	1023-5
the symbol I.	that	constraint	the associated tuples	1023-5
the symbol I.	where indicates	action	the associated tuples	1023-5
the associated tuples	to	constraint	the answer	1023-5
the associated tuples	into	constraint	the answer	1023-5
the associated tuples	are	attribute	the answer	1023-5
the associated tuples	be inserted	action	the answer	1023-5
The creation	of	constraint	the view Bad_th	1023-6
the view Bad_th	is accomplished	action	the Stage Movies Title Director Hitchcock Location Theater Phone Pariscope Theater Title Schedule th title I.VIEW Bad_th I	1023-6
the view Bad_th	using	action	the Stage Movies Title Director Hitchcock Location Theater Phone Pariscope Theater Title Schedule th title I.VIEW Bad_th I	1023-6
the Stage Movies Title Director Hitchcock Location Theater Phone Pariscope Theater Title Schedule th title I.VIEW Bad_th I		sequential	I	1023-6
Theater		sequential	I	1024-1
Stage		sequential	II	1025-1
II		sequential	Location Theater Phone Theater	1025-1
Location Theater Phone Theater		sequential	I	1025-1
Bad_th Theater		sequential	Figure	1026-1
Figure		sequential	7.3	1026-1
7.3		sequential	Illustration	1026-1
Illustration	of	constraint	relational completeness	1026-1
relational completeness	of	constraint	QBE expression I	1026-1
<B>		sequential	which	1026-2
which	creates	action	the view	1026-2
the view	and	conjunctive	the attribute names	1026-2
the view	establishes	action	the attribute names	1026-2
the attribute names	for	constraint	the view relation	1026-2
Microsoft Access		sequential	A Query Language	1027-1
A Query Language	for	constraint	PCs	1027-1
<B>	includes	action	a tabular display	1028-1
a tabular display	to	constraint	the form	1028-1
a tabular display	indicate	action	the form	1028-1
the form	and	conjunctive	content	1028-1
content	of	constraint	desired output tuples	1028-1
desired output tuples		sequential	the use	1028-1
the use	of	constraint	attribute	1028-1
attribute		sequential	conditions	1028-1
conditions	within	constraint	this display	1028-1
this display	in	constraint	the rows	1028-1
the rows	named	action	Criteria	1028-1
Criteria	and	conjunctive	<B>	1028-1
Notes Pariscope Location	on	constraint	Practical Languages SelectQuery	1029-1
Practical Languages SelectQuery		sequential	Query4 Movies Title	1029-1
Query4 Movies Title		sequential	Theater	1029-1
Theater		sequential	Theater Director Title Schedule	1029-1
Theater Director Title Schedule		sequential	Phone Field Theater Director	1029-1
Phone Field Theater Director		sequential	Table Location Location Movies Sort Show Criteria	1029-1
Table Location Location Movies Sort Show Criteria	Or	conjunctive	Figure	1029-1
Figure		sequential	7.4	1029-1
7.4		sequential	Example query	1029-1
Example query	in	constraint	Access	1029-1
Limited forms	of	constraint	negation	1030-1
negation	and	conjunctive	union	1030-1
union	into	constraint	the condition part	1030-1
union	can be incorporated	action	the condition part	1030-1
the condition part	of	constraint	an Access query	1030-1
<B>	For	constraint	more general forms	1030-2
more general forms	of	constraint	negation	1030-2
negation	and	conjunctive	union	1030-2
union		sequential	the technique	1030-2
the technique	of	constraint	views	1030-2
the technique	building	action	views	1030-2
views	to	constraint	intermediate relations	1030-2
views	as	constraint	intermediate relations	1030-2
views	serve	action	intermediate relations	1030-2
intermediate relations	can be used	action	<B>	1030-2
<B>	Confronting	action	the Real World	1031-1
the Real World	Because	constraint	they	1031-1
they	to	constraint	practical situations	1031-1
they	in	constraint	practical situations	1031-1
they	are be used	action	practical situations	1031-1
practical situations		sequential	the languages	1031-1
the languages	in	constraint	this chapter	1031-1
the languages	presented	action	this chapter	1031-1
this chapter	incorporate	action	a number	1031-1
a number	of	constraint	features	1031-1
features	in	constraint	their formal counterparts	1031-1
features	not included	action	their formal counterparts	1031-1
<B>	In	constraint	this section	1031-2
this section		sequential	we	1031-2
we	on	constraint	these extensions	1031-2
we	of	constraint	these extensions	1031-2
we	touch	attribute	some	1031-2
these extensions	on	constraint	fundamental issues	1031-2
these extensions	and	conjunctive	fundamental issues	1031-2
fundamental issues	by	constraint	them	1031-2
fundamental issues	raised	action	them	1031-2
<B>	include	action	domain independence	1031-3
domain independence		sequential	the implications	1031-3
the implications	of	constraint	atomic objects	1031-3
the implications	incorporating	attribute	many	1031-3
the implications	sorted	action	atomic objects	1031-3
atomic objects		sequential	the use	1031-3
the use	of	constraint	arithmetic	1031-3
arithmetic	and	conjunctive	the incorporation	1031-3
the incorporation	of	constraint	aggregate operators	1031-3
Queries	from	constraint	the practical languages	1032-1
Queries	of	constraint	the practical languages	1032-1
the practical languages	in	constraint	this chapter	1032-1
the practical languages	described	action	this chapter	1032-1
this chapter	are	attribute	domain	1032-1
domain		sequential	<B>	1032-1
<B>	from	constraint	the form	1032-2
<B>	is easily verified	action	the form	1032-2
the form	of	constraint	queries	1032-2
queries	in	constraint	these languages	1032-2
<B>		sequential	the specific semantics	1032-3
the specific semantics	with	constraint	clauses	1032-3
the specific semantics	in	constraint	clauses	1032-3
the specific semantics	or	conjunctive	clauses	1032-3
the specific semantics	associated	action	clauses	1032-3
the specific semantics	s occurring	action	clauses	1032-3
clauses	see	action	Example 7.1.1	1032-3
Example 7.1.1	prevent	action	the kind	1032-3
the kind	of	constraint	safety problem	1032-3
safety problem	by	constraint	Section 5.3	1032-3
safety problem	of	constraint	Section 5.3	1032-3
safety problem	illustrated	attribute	query unsafe 2	1032-3
Most practical languages	permit	action	the underlying domain	1033-1
the underlying domain	of	constraint	values	1033-1
values	to	constraint	example	1033-1
values	for	constraint	example	1033-1
values	be	attribute	many	1033-1
values	sorted	action	example	1033-1
example	including	action	distinct scalar domains	1033-1
distinct scalar domains	for	constraint	the types	1033-1
the types		sequential	integer	1033-1
integer		sequential	character string	1033-1
character string	and	conjunctive	some constructed types	1033-1
some constructed types		sequential	date	1033-1
date	in	constraint	some languages	1033-1
More recent systems		sequential	POSTGRES	1033-2
POSTGRES	permit	action	the user	1033-2
the user	to	constraint	abstract data types	1033-2
the user	incorporate as well	action	abstract data types	1033-2
<B>	For	constraint	the theoretical treatment	1033-3
<B>	of	constraint	the theoretical treatment	1033-3
the theoretical treatment		sequential	we	1033-3
we	that	constraint	there	1033-3
we	assumed	action	there	1033-3
there	was	attribute	one underlying domain	1033-3
one underlying domain	of	constraint	values	1033-3
values		sequential	dom	1033-3
dom		sequential	which	1033-3
which	by	constraint	all relational attributes	1033-3
which	was shared equally	action	all relational attributes	1033-3
<B>	As	constraint	the discussion	1033-4
<B>	in	constraint	the discussion	1033-4
<B>	noted	action	the discussion	1033-4
the discussion	of	constraint	SQL	1033-4
SQL		sequential	the typing	1033-4
the typing	of	constraint	attributes	1033-4
attributes	to	constraint	comparisons	1033-4
attributes	that	constraint	comparisons	1033-4
attributes	can be used	action	comparisons	1033-4
attributes	ensure	action	comparisons	1033-4
comparisons	make	action	sense	1033-4
sense	in that	constraint	they	1033-4
they	compare	action	values	1033-4
values	of	constraint	comparable type	1033-4
<B>	of	constraint	the theory	1033-5
the theory	for	constraint	a single underlying domain	1033-5
the theory	developed here	action	a single underlying domain	1033-5
a single underlying domain	to	constraint	the case	1033-5
a single underlying domain	can be generalized	action	the case	1033-5
the case	of	constraint	a underlying domain	1033-5
the case	many sorted	action	a underlying domain	1033-5
a underlying domain	see	action	Exercise 7.8	1033-5
Exercise 4.30	explores	action	the impact	1034-1
the impact	of	constraint	comparators	1034-1
the impact	incorporating	action	comparators	1034-1
comparators	into	constraint	the conjunctive queries	1034-1
Many languages	also incorporate	action	string	1034-2
string		sequential	comparison	1034-2
comparison		sequential	operators	1034-2
<B>	Given	action	the presence	1035-1
the presence	of	constraint	integers	1035-1
integers	and	conjunctive	reals	1035-1
reals		sequential	it	1035-1
it	to	constraint	arithmetic operators	1035-1
it	is	attribute	natural	1035-1
it	incorporate	action	arithmetic operators	1035-1
<B>	yields	action	a fundamental increase	1035-2
a fundamental increase	in	constraint	expressive power	1035-2
<B>	select	action	count	1036-1
count		sequential	distinct Title	1036-1
distinct Title	from	constraint	Movies	1036-1
Movies		sequential	Director	1036-1
Director	where =	sequential	Hitchcock	1036-1
<B>	In	constraint	the preceding example	1037-1
the preceding example		sequential	the aggregate operator	1037-1
the aggregate operator	to	constraint	an entire relation	1037-1
the aggregate operator	was applied	action	an entire relation	1037-1
<B>	By	constraint	the group	1038-1
<B>	using	action	the group	1038-1
the group	by	constraint	command	1038-1
command		sequential	aggregate operators	1038-1
aggregate operators	to	constraint	clusters	1038-1
aggregate operators	can be applied	action	clusters	1038-1
clusters	of	constraint	tuples	1038-1
tuples		sequential	each common values	1038-1
each common values	on	constraint	a specified set	1038-1
a specified set	of	constraint	attributes	1038-1
<B>	For	constraint	example	1038-2
example		sequential	the following SQL query	1038-2
the following SQL query	determines	action	the number	1038-2
the number	of	constraint	movies	1038-2
movies	by	constraint	each director	1038-2
movies	directed	action	each director	1038-2
each director	select	action	Director	1038-2
Director	count	action	distinct Title	1038-2
distinct Title	from	constraint	Movies group	1038-2
Movies group	by	constraint	Director	1038-2
Notes	on	constraint	Practical Languages Bibliographic Notes General descriptions	1039-1
Practical Languages Bibliographic Notes General descriptions	of	constraint	SQL	1039-1
SQL	and	conjunctive	QBE	1039-1
QBE	in	constraint	EN89	1039-1
QBE	may be found	action	EN89	1039-1
EN89		sequential	KS91	1039-1
KS91		sequential	Ull88	1039-1
Ull88		sequential	more details	1039-1
more details	on	constraint	SQL	1039-1
SQL	in	constraint	C+76	1039-1
SQL	can be found	action	C+76	1039-1
C+76	on	constraint	QBE	1039-1
C+76	and	conjunctive	QBE	1039-1
QBE	in	constraint	Zlo77	1039-1
Another language	in	constraint	spirit	1039-2
spirit	to	constraint	SQL	1039-2
SQL	is	attribute	Quel	1039-2
Quel		sequential	which	1039-2
which	with	constraint	the original INGRES system	1039-2
which	was provided	action	the original INGRES system	1039-2
A description	of	constraint	Quel	1039-3
Quel	in	constraint	SWKH76	1039-3
Quel	can be found	action	SWKH76	1039-3
Reference		sequential	OW93	1039-4
OW93	presents	action	a survey	1039-4
a survey	of	constraint	QBE langauges	1039-4
QBE langauges	and	conjunctive	extensions	1039-4
A reference	on	constraint	Microsoft Access	1039-5
Microsoft Access	is	attribute	Cam92	1039-5
<B>	In	constraint	Unix	1039-6
Unix		sequential	the command awk	1039-6
the command awk	provides	action	a basic relational tool	1039-6
The formal semantics	for	constraint	SQL	1040-1
SQL	in	constraint	NPS91	1040-1
SQL	are presented	action	NPS91	1040-1
Example 7.1.1	from	constraint	studies containment	1040-2
Example 7.1.1	is	attribute	studies containment	1040-2
studies containment	and	conjunctive	equivalence	1040-2
equivalence	of	constraint	conjunctive queries	1040-2
conjunctive queries	under	constraint	the bag semantics	1040-2
the bag semantics	see	action	<B>	1040-2
SQL	has become	action	the standard relational query language	1041-1
the standard relational query language		sequential	57391	1041-1
57391		sequential	69392	1041-1
69392		sequential	reference	1041-1
QBE	as	constraint	part	1042-1
QBE	is	attribute	available	1042-1
part	of	constraint	IBM	1042-1
IBM		sequential	product	1042-1
product		sequential	QMF	1042-1
QMF		sequential	Query Management Facility	1042-1
Some personal computer products	support	action	more restricted graphical query languages	1042-2
more restricted graphical query languages	including	action	Microsoft Access	1042-2
Microsoft Access	and	conjunctive	Paradox	1042-2
Paradox		sequential	which	1042-2
which	supports	action	form	1042-2
form	based	action	a language	1042-2
Exercises Exercise 7.1	Write	action	SQL	1043-1
SQL		sequential	QBE	1043-1
QBE	and	conjunctive	Access queries	1043-1
Access queries	expressing	action	queries	1043-1
queries		sequential	4.1	1043-1
4.1	to	constraint	4.14	1043-1
4.14	from	constraint	Chapter 4	1043-1
<B>	by	constraint	them	1043-2
<B>	Start	action	them	1043-2
<B>	expressing	action	them	1043-2
them	as	constraint	nr-datalog¬ programs	1043-2
<B>	Exercise	action	7.2	1044-1
7.2	Consider again	action	the queries	1044-1
the queries		sequential	5.2	1044-1
5.2	and	conjunctive	5.3	1044-1
5.3	of	constraint	Chapter 5	1044-1
<B>	in	constraint	SQL	1044-2
<B>	Express	attribute	these	1044-2
SQL		sequential	QBE	1044-2
QBE	and	conjunctive	Access	1044-2
Exercise		sequential	7.3	1045-1
7.3	Describe formally	action	the mapping	1045-1
the mapping	of	constraint	select	1045-1
select	from	constraint	SQL blocks	1045-1
SQL blocks	into	constraint	the SPJR	1045-1
Exercise		sequential	7.5	1046-1
7.5	Following	action	Example 7.2.1	1046-1
Example 7.2.1	that	constraint	QBE	1046-1
Example 7.2.1	show	action	QBE	1046-1
QBE	is	attribute	relationally complete	1046-1
Exercise		sequential	7.6	1047-1
Exercises Exercise		sequential	7.7	1048-1
Dependency		sequential	Dependency	1049-1
Vittorio		sequential	Vittorio	1050-1
Sergio		sequential	Sergio	1051-1
Riccardo		sequential	Riccardo	1052-1
Vittorio	wait	action	we	1053-1
we	to	constraint	it	1053-1
we	are going	action	it	1053-1
we	fix	action	it	1053-1
Thischapterbeginswithaninformaldiscussionthatintroducessomesimpledependencies	and	conjunctive	the primary motivations	1054-1
Thischapterbeginswithaninformaldiscussionthatintroducessomesimpledependencies	illustrates	action	the primary motivations	1054-1
the primary motivations	for	constraint	their development	1054-1
their development	and	conjunctive	study	1054-1
The two following sections	of	constraint	the chapter	1054-2
the chapter	to	constraint	two	1054-2
the chapter	are devoted	action	two	1054-2
two	of	constraint	the simple kinds	1054-2
the simple kinds	of	constraint	dependencies	1054-2
dependencies	and	conjunctive	the final section	1054-2
the final section	introduces	action	the chase	1054-2
the chase		sequential	an important tool	1054-2
an important tool	for	constraint	these dependencies	1054-2
an important tool	analyzing	action	these dependencies	1054-2
these dependencies	and	conjunctive	their effect	1054-2
their effect	on	constraint	queries	1054-2
<B>	of	constraint	the early dependencies	1055-1
the early dependencies	in	constraint	the literature	1055-1
the early dependencies	introduced	action	the literature	1055-1
the literature	as opposed to	constraint	the perspective	1055-1
the literature	use	attribute	unnamed	1055-1
the literature	named	attribute	unnamed	1055-1
the perspective	on	constraint	tuples	1055-1
tuples	and	conjunctive	relations	1055-1
Dependency theory	was	attribute	one	1055-2
one	of	constraint	the main reasons	1055-2
the main reasons	for	constraint	this perspective	1055-2
the main reasons	adopting	action	this perspective	1055-2
this perspective	in	constraint	theoretical investigations	1055-2
<B>	because	constraint	dependencies	1055-3
<B>	is	attribute	dependencies	1055-3
dependencies	concern	action	the semantics	1055-3
the semantics	of	constraint	data	1055-3
data	and	conjunctive	names	1055-3
data	attribute	action	names	1055-3
names	carry	action	more semantics	1055-3
more semantics	than	constraint	column numbers	1055-3
The general view	of	constraint	dependencies	1055-4
dependencies	on	constraint	logic	1055-4
dependencies	based	action	logic	1055-4
logic		sequential	which	1055-4
which	in	constraint	Chapter	1055-4
which	is considered	action	Chapter	1055-4
Chapter		sequential	10	1055-4
10	uses	action	column number	1055-4
column number		sequential	the perspective	1055-4
the perspective	but	conjunctive	a special subcase	1055-4
a special subcase	called	action	the spirit	1055-4
a special subcase	typed	action	the spirit	1055-4
a special subcase	retains	action	the spirit	1055-4
the spirit	of	constraint	attribute	1055-4
attribute		sequential	name	1055-4
name		sequential	the perspective	1055-4
Motivation	Consider	action	the database	1056-1
the database	in	constraint	Fig	1056-1
the database	shown	action	Fig	1056-1
8.1		sequential	8.1	1056-2
<B>	Although	constraint	the schema itself	1056-3
the schema itself	makes	action	no restrictions	1056-3
no restrictions	on	constraint	properties	1056-3
properties	of	constraint	data	1056-3
data		sequential	that	1056-3
that	might be stored	action	the intended application	1056-3
the intended application	for	constraint	the schema	1056-3
the schema	may involve	action	several such restrictions	1056-3
<B>	For	constraint	example	1056-4
example		sequential	we	1056-4
we	that	constraint	there	1056-4
we	may know	action	there	1056-4
there	is	attribute	only one director	1056-4
only one director	with	constraint	each movie title	1056-4
only one director	associated	action	each movie title	1056-4
each movie title	in	constraint	Showings	1056-4
each movie title	and	conjunctive	Showings	1056-4
Showings		sequential	only one movie title	1056-4
only one movie title	with	constraint	theater	1056-4
only one movie title	is associated	action	theater	1056-4
theater		sequential	screen	1056-4
screen		sequential	a given pair	1056-4
<B>	In	constraint	the syntax	1056-5
the syntax	to	constraint	this chapter	1056-5
the syntax	in	constraint	this chapter	1056-5
the syntax	be developed	action	this chapter	1056-5
this chapter		sequential	the 1 Gone	1056-5
the 1 Gone	are	attribute	the days	1056-5
the days	of	constraint	two movies	1056-5
the days	seeing	action	two movies	1056-5
two movies	for	constraint	the price	1056-5
the price	of	constraint	one	1056-5
<B>	and	conjunctive	Dependency Movies Title Director	1057-1
<B>	Join	action	Dependency Movies Title Director	1057-1
Dependency Movies Title Director		sequential	The Birds Hitchcock Hedren The Birds Hitchcock Taylor Bladerunner Scott Hannah Coppola Brando Showings Theater Screen Title Snack	1057-1
The Birds Hitchcock Hedren The Birds Hitchcock Taylor Bladerunner Scott Hannah Coppola Brando Showings Theater Screen Title Snack		sequential	Rex The Birds coffee Rex	1057-1
Rex The Birds coffee Rex		sequential	The Birds popcorn Rex Bladerunner coffee Rex Bladerunner popcorn Le Champo The Birds tea Le Champo The Birds popcorn Cinoche The Birds Coke Cinoche	1057-1
The Birds popcorn Rex Bladerunner coffee Rex Bladerunner popcorn Le Champo The Birds tea Le Champo The Birds popcorn Cinoche The Birds Coke Cinoche		sequential	The Birds wine Cinoche Bladerunner Coke Cinoche Bladerunner wine The Birds tea The Birds popcorn	1057-1
The Birds wine Cinoche Bladerunner Coke Cinoche Bladerunner wine The Birds tea The Birds popcorn		sequential	Figure	1057-1
Figure		sequential	8.1	1057-1
8.1		sequential	Sample database	1057-1
Sample database	illustrating	action	simple dependencies dependency	1057-1
simple dependencies dependency	in	constraint	the Movies relation	1057-1
the Movies relation	as	constraint	Movies	1057-1
the Movies relation	is written	action	Movies	1057-1
Movies		sequential	Title Director Showings	1057-1
Title Director Showings	→	sequential	Theater Screen	1057-1
Theater Screen	→	constraint	Title	1057-1
<B>		sequential	there	1058-1
there	are	attribute	sets	1058-1
sets	of	constraint	attributes	1058-1
attributes	on	constraint	left	1058-1
left	and	conjunctive	right hand	1058-1
right hand		sequential	the sides	1058-1
the sides	of	constraint	the arrow	1058-1
the arrow	but	conjunctive	we	1058-1
we	with	constraint	the convention	1058-1
we	continue	action	the convention	1058-1
the convention	of	constraint	omitting set braces	1058-1
omitting set braces	from	constraint	the context	1058-1
omitting set braces	when understood	action	the context	1058-1
there	When is	action	no confusion	1059-1
no confusion	from	constraint	the context	1059-1
the context		sequential	a dependency R X → Y	1059-1
a dependency R X → Y	is simply denoted	action	X	1059-1
X		sequential	→ Y	1059-1
A relation		sequential	I	1059-2
I	satisfies	action	a functional dependency X → Y	1059-2
a functional dependency X → Y	if	constraint	each pair	1059-2
a functional dependency X → Y	for	constraint	each pair	1059-2
each pair		sequential	t	1059-2
t	of	constraint	tuples	1059-2
tuples	in	constraint	I	1059-2
Title	→	sequential	Director Title	1060-1
Director Title		sequential	Actor	1060-1
Actor	→	sequential	Director	1060-1
We	that	constraint	dependency a	1061-1
We	will say	action	dependency a	1061-1
dependency a	implies b	action	dependency	1061-1
It	that	constraint	dependency	1062-1
It	turns out	action	dependency	1062-1
dependency	to	constraint	the key dependency Title	1062-1
dependency	is	attribute	b equivalent	1062-1
the key dependency Title		sequential	Actor	1062-1
Actor		sequential	→ Title	1062-1
→ Title		sequential	Director	1062-1
Director		sequential	Actor	1062-1
I		sequential	π Theater	1063-1
π Theater		sequential	Screen	1063-1
Screen		sequential	Title	1063-1
Title		sequential	I	1063-1
I		sequential	⊲⊳ π Theater	1063-1
⊲⊳ π Theater		sequential	Snack	1063-1
Snack		sequential	I	1063-1
<B>	is	attribute	a simple example	1064-1
a simple example	of	constraint	a join dependency	1064-1
a join dependency		sequential	jd	1064-1
jd		sequential	which	1064-1
which	by	constraint	Showings	1064-1
which	is formally expressed	action	Showings	1064-1
Showings		sequential	{ Theater	1064-1
{ Theater		sequential	Screen	1064-1
Screen		sequential	Title }	1064-1
Title }		sequential	{ Theater	1064-1
{ Theater		sequential	Snacks	1064-1
Snacks		sequential	}	1064-1
<B>	In	constraint	a jd	1065-1
a jd	may involve	action	more than two attribute sets	1065-1
Multivalued dependency		sequential	mvd	1065-2
mvd	is	attribute	the special case	1065-2
the special case	of	constraint	jd	1065-2
jd		sequential	s	1065-2
s		sequential	that	1065-2
that	at	constraint	most two attribute sets	1065-2
that	have	action	most two attribute sets	1065-2
<B>	Due to	constraint	their naturalness	1065-3
their naturalness		sequential	s	1065-3
s	before	constraint	jd	1065-3
s	were introduced	action	jd	1065-3
jd	and	conjunctive	several interesting properties	1065-3
jd	have	action	several interesting properties	1065-3
several interesting properties		sequential	which	1065-3
which	makes	action	them	1065-3
them	on	constraint	<B>	1065-3
them	studying	attribute	their own	1065-3
<B>	is	attribute	also satisfied	1066-1
We	will also study	action	such interaction	1066-2
such interaction	between	constraint	fd	1066-2
fd	and	conjunctive	jd	1066-2
jd		sequential	<B>	1066-2
we	So far have considered	action	dependencies	1067-1
dependencies		sequential	that	1067-1
that	to	constraint	individual relations	1067-1
that	apply	action	individual relations	1067-1
these dependencies	in	constraint	the context	1067-2
these dependencies	Typically are used	action	the context	1067-2
the context	of	constraint	a database schema	1067-2
a database schema	in	constraint	which	1067-2
which		sequential	case	1067-2
case		sequential	one	1067-2
one	to	constraint	the relation	1067-2
one	has	action	the relation	1067-2
one	specify	action	the relation	1067-2
the relation	by	constraint	each dependency	1067-2
the relation	concerned	action	each dependency	1067-2
We	will also consider	action	a third fundamental kind	1067-3
a third fundamental kind	of	constraint	dependency	1067-3
dependency	called	action	inclusion dependency	1067-3
inclusion dependency		sequential	ind	1067-3
ind	to	constraint	Showings	1067-3
ind	as	constraint	Showings	1067-3
ind	and	conjunctive	Showings	1067-3
ind	also referred	action	Showings	1067-3
Showings		sequential	Title	1067-3
Title		sequential	⊆ Movies	1067-3
⊆ Movies		sequential	Title	1067-3
<B>	and	conjunctive	Dependency	1068-1
<B>	Join	action	Dependency	1068-1
Inclusion dependencies	in	constraint	depth	1068-2
Inclusion dependencies	will be studied	action	depth	1068-2
depth	in	constraint	Chapter 9	1068-2
Data dependencies		sequential	the ones	1069-1
the ones	just presented	action	a formal mechanism	1069-1
the ones	provide	action	a formal mechanism	1069-1
a formal mechanism	for	constraint	properties	1069-1
a formal mechanism	expressing	action	properties	1069-1
properties	from	constraint	the stored data	1069-1
properties	expected	action	the stored data	1069-1
<B>	If	constraint	the database	1069-2
the database	to	constraint	a set	1069-2
the database	is known	action	a set	1069-2
the database	satisfy	action	a set	1069-2
a set	of	constraint	dependencies	1069-2
dependencies		sequential	this information	1069-2
this information	to	constraint	schema design	1069-2
this information	can be used	action	schema design	1069-2
this information	1 improve	action	schema design	1069-2
schema design	2 protect	action	data	1069-2
data	by	constraint	certain erroneous updates	1069-2
data	preventing	action	certain erroneous updates	1069-2
certain erroneous updates	and	conjunctive	performance	1069-2
certain erroneous updates	3 improve	action	performance	1069-2
These aspects	in	constraint	turn	1069-3
These aspects	are considered next	action	turn	1069-3
Schema Design	and	conjunctive	Update Anomalies	1070-1
Dependencies	to	constraint	information	1070-2
Dependencies	are used	action	information	1070-2
Dependencies	provide	action	information	1070-2
information	about	constraint	the semantics	1070-2
the semantics	of	constraint	the application	1070-2
the application	so that	constraint	the system	1070-2
the system	may help	action	the user	1070-2
the user	among	constraint	all possible schemas	1070-2
the user	choose	action	all possible schemas	1070-2
all possible schemas		sequential	the most appropriate one	1070-2
There	are	attribute	various ways	1071-1
various ways	in	constraint	which	1071-1
which		sequential	a schema	1071-1
a schema	be	attribute	may not appropriate	1071-1
The relations		sequential	Movies	1071-2
Movies	and	conjunctive	Showings	1071-2
Showings	illustrate	action	the most prominent kinds	1071-2
the most prominent kinds	of	constraint	problems	1071-2
problems	with	constraint	fd	1071-2
problems	associated	action	fd	1071-2
fd	and	conjunctive	jd	1071-2
jd		sequential	Incomplete information	1071-2
Incomplete information	that	constraint	one	1071-2
Incomplete information	Suppose	action	one	1071-2
one	to	constraint	the title	1071-2
one	is	attribute	the title	1071-2
one	insert	action	the title	1071-2
the title	of	constraint	a new movie	1071-2
a new movie	and	conjunctive	its director	1071-2
its director	without	constraint	any actor	1071-2
its director	yet	conjunctive	any actor	1071-2
its director	knowing	action	any actor	1071-2
any actor	of	constraint	the movie	1071-2
<B>	to	constraint	the foregoing schema	1071-3
<B>	with	constraint	the foregoing schema	1071-3
<B>	turns out	attribute	impossible	1071-3
<B>	be	attribute	impossible	1071-3
the foregoing schema	and	conjunctive	it	1071-3
it	is	attribute	an insertion anomaly	1071-3
An analogue	for	constraint	deletion	1071-4
deletion		sequential	a deletion anomaly	1071-4
a deletion anomaly	if	constraint	actor Marlon Brando	1071-4
a deletion anomaly	occurs	action	actor Marlon Brando	1071-4
actor Marlon Brando	with	constraint	the movie	1071-4
actor Marlon Brando	is no longer associated	action	the movie	1071-4
Redundancy		sequential	Redundancy	1072-1
<B>	that	constraint	the management	1073-1
<B>	Furthermore suppose	action	the management	1073-1
the management	of	constraint	the Cinoche	1073-1
the Cinoche	to	constraint	Pepsi	1073-1
the Cinoche	decided	action	Pepsi	1073-1
the Cinoche	sell	action	Pepsi	1073-1
Pepsi		sequential	Coke	1073-1
It	to	constraint	the tuple Cinoche	1073-2
It	is	attribute	not sufficient	1073-2
It	modify	action	the tuple Cinoche	1073-2
the tuple Cinoche		sequential	1	1073-2
1		sequential	The Birds	1073-2
The Birds		sequential	Coke	1073-2
Coke	to	constraint	Cinoche	1073-2
Cinoche		sequential	1	1073-2
1		sequential	The Birds	1073-2
The Birds		sequential	Pepsi	1073-2
Pepsi	because	constraint	a violation	1073-2
Pepsi	to	constraint	a violation	1073-2
Pepsi	would lead	action	a violation	1073-2
a violation	of	constraint	the jd	1073-2
We	to	constraint	several tuples	1073-3
We	have	action	several tuples	1073-3
We	modify	action	several tuples	1073-3
<B>	is	attribute	a modification anomaly	1073-4
Insertion	and	conjunctive	deletion	1073-5
deletion		sequential	anomalies	1073-5
anomalies	by	constraint	redundancy	1073-5
anomalies	are also caused	action	redundancy	1073-5
<B>	because of	constraint	Thus a bad choice	1074-1
Thus a bad choice	for	constraint	the schema	1074-1
the schema		sequential	updates	1074-1
updates	to	constraint	loss	1074-1
updates	can lead	action	loss	1074-1
loss	of	constraint	information	1074-1
information		sequential	inconsistency	1074-1
inconsistency	in	constraint	the data	1074-1
the data	and	conjunctive	more difficulties	1074-1
more difficulties	in	constraint	correct updates	1074-1
more difficulties	writing	action	correct updates	1074-1
These problems	by	constraint	a more appropriate schema	1074-2
These problems	can be prevented	action	a more appropriate schema	1074-2
These problems	choosing	action	a more appropriate schema	1074-2
<B>	In	constraint	the example	1074-3
the example		sequential	the relation Movies	1074-3
the relation Movies	into	constraint	two relations	1074-3
the relation Movies	should be decomposed	action	two relations	1074-3
two relations		sequential	M	1074-3
M		sequential	Director	1074-3
Director		sequential	Title	1074-3
Title		sequential	Director	1074-3
Director	and	conjunctive	M Actor	1074-3
M Actor		sequential	Title	1074-3
Title		sequential	Actor	1074-3
Actor		sequential	M	1074-3
M		sequential	Director	1074-3
Director	where satisfies	action	the fd Title → Director	1074-3
the relation Showings	by	constraint	two relations	1074-4
the relation Showings	Similarly should be replaced	action	two relations	1074-4
two relations		sequential	ST Showings	1074-4
ST Showings		sequential	Theater	1074-4
Theater		sequential	Screen	1074-4
Screen		sequential	Title	1074-4
This approach	to	constraint	schema design	1074-5
schema design	in	constraint	Chapter 11	1074-5
schema design	is explored	action	Chapter 11	1074-5
Data Integrity Data dependencies	as	constraint	a filter	1075-1
Data Integrity Data dependencies	also serve	action	a filter	1075-1
a filter	on	constraint	proposed updates	1075-1
proposed updates	in	constraint	a natural fashion	1075-1
<B>	In	constraint	fact	1075-2
fact		sequential	the system	1075-2
the system	supports	action	transactions	1075-2
<B>	During	constraint	a transaction	1075-3
a transaction		sequential	the database	1075-3
the database	in	constraint	can an inconsistent state	1075-3
the database	be	attribute	can an inconsistent state	1075-3
can an inconsistent state	at	constraint	the end	1075-3
can an inconsistent state	but	conjunctive	the end	1075-3
the end	of	constraint	a transaction	1075-3
a transaction		sequential	the system	1075-3
the system	checks	action	the integrity	1075-3
the integrity	of	constraint	the database	1075-3
<B>	If	constraint	dependencies	1075-4
dependencies	are violated	action	the whole transaction	1075-4
the whole transaction	is rejected	action	it	1075-4
the whole transaction	aborted	action	it	1075-4
it	otherwise is accepted	action	<B>	1075-4
it	validated	action	<B>	1075-4
Efficient Implementation	and	conjunctive	Query Optimization	1076-1
which	without	constraint	a join	1077-1
which	can be evaluated	action	a join	1077-1
the pattern	of	constraint	tuples	1077-2
tuples		sequential	t	1077-2
t		sequential	a }	1077-2
a }	in	constraint	relation Movies	1077-2
a }	Whenever is found	action	relation Movies	1077-2
relation Movies		sequential	it	1077-2
it	be	attribute	must the case	1077-2
must the case	that	constraint	d	1077-2
d		sequential	d′	1077-2
d′		sequential	one	1077-2
one	so may as well use	action	just the pattern	1077-2
just the pattern		sequential	t	1077-2
t		sequential	d	1077-2
d		sequential	a }	1077-2
a }	yielding	action	the simplified query	1077-2
This technique	for	constraint	query optimization	1077-3
query optimization	on	constraint	the chase	1077-3
query optimization	is based	action	the chase	1077-3
the chase	in	constraint	the last section	1077-3
the chase	and	conjunctive	the last section	1077-3
the chase	is considered	action	the last section	1077-3
the last section	of	constraint	this chapter	1077-3
<B>	and	conjunctive	Dependencies Functional dependencies	1078-1
Dependencies Functional dependencies	are	attribute	the most prominent form	1078-1
the most prominent form	of	constraint	dependency	1078-1
dependency	and	conjunctive	several elegant results	1078-1
several elegant results	for	constraint	them	1078-1
several elegant results	have been developed	action	them	1078-1
Key dependencies	are	attribute	a special case	1078-2
a special case	of	constraint	functional dependencies	1078-2
<B>	are	attribute	the dependencies	1078-3
the dependencies	by	constraint	relational systems	1078-3
the dependencies	perhaps most universally supported	action	relational systems	1078-3
relational systems	in	constraint	database applications	1078-3
relational systems	and	conjunctive	database applications	1078-3
relational systems	used	action	database applications	1078-3
Many issues	in	constraint	dependency theory	1078-4
dependency theory	have	action	nice solutions	1078-4
nice solutions	in	constraint	the context	1078-4
the context	of	constraint	functional dependencies	1078-4
functional dependencies	and	conjunctive	these dependencies	1078-4
these dependencies	at	constraint	the origin	1078-4
these dependencies	lie	action	the origin	1078-4
the origin	of	constraint	the decomposition approach	1078-4
the decomposition approach	to	constraint	schema design	1078-4
<B>	To	constraint	a class	1079-1
<B>	specify	action	a class	1079-1
a class	of	constraint	dependencies	1079-1
dependencies		sequential	one	1079-1
one	must define	action	the syntax	1079-1
the syntax	and	conjunctive	the semantics	1079-1
the semantics	of	constraint	the dependencies	1079-1
the dependencies	of	constraint	concern	1079-1
<B>	for	constraint	fd	1079-2
<B>	is done next	action	fd	1079-2
fd		sequential	<B>	1079-2
Definition		sequential	8.2.1	1080-1
A key dependency	over	constraint	U	1080-2
U	is	attribute	an fd	1080-2
an fd	of	constraint	the form	1080-2
the form		sequential	X	1080-2
X	→	sequential	U	1080-2
A relation		sequential	I	1080-3
I		sequential	U	1080-3
U	satisfies	action	X	1080-3
X	→	sequential	Y	1080-3
Y	denoted	action	I	1080-3
I		sequential	X	1080-3
X	→	sequential	Y	1080-3
Y	if	constraint	Join	1080-3
Y	for	constraint	Join	1080-3
Y	and	conjunctive	Join	1080-3
Join		sequential	Dependency	1080-3
Dependency		sequential	each pair	1080-3
each pair		sequential	t	1080-3
t	of	constraint	tuples	1080-3
tuples	in	constraint	I	1080-3
I		sequential	πX s	1080-3
πX s	=	sequential	πX	1080-3
πX		sequential	t	1080-3
t	implies	action	πY s	1080-3
πY s	=	sequential	πY	1080-3
πY		sequential	t	1080-3
<B>	For	constraint	a set F	1080-4
a set F	of	constraint	fd	1080-4
fd		sequential	I	1080-4
I	satisfies	action	F	1080-4
F	denoted	action	I	1080-4
I	|=	sequential	F	1080-4
F	if	constraint	I	1080-4
I		sequential	σ	1080-4
σ	for	constraint	each σ ∈ F	1080-4
The notion	of	constraint	satisfaction	1081-1
satisfaction	of	constraint	fd	1081-1
fd	by	constraint	instances	1081-1
instances	over	constraint	R	1081-1
R	in	constraint	the obvious way	1081-1
R	is defined	action	the obvious way	1081-1
<B>	In	constraint	the remainder	1081-2
the remainder	of	constraint	this chapter	1081-2
this chapter		sequential	we	1081-2
we	consider	action	only relational schemas	1081-2
<B>	to	constraint	database schemas	1081-3
<B>	can be extended easily	action	database schemas	1081-3
The following simple property	provides	action	the basis	1082-1
the basis	for	constraint	the decomposition approach	1082-1
the decomposition approach	to	constraint	schema design	1082-1
it	that	constraint	a certain fd	1082-2
it	if	constraint	a certain fd	1082-2
it	Intuitively says	action	a certain fd	1082-2
a certain fd	in	constraint	a relation	1082-2
a certain fd	holds	action	a relation	1082-2
a relation		sequential	one	1082-2
one	can store	action	the relation	1082-2
the relation		sequential	two projections	1082-2
two projections	of	constraint	it	1082-2
it	without	constraint	loss	1082-2
loss	of	constraint	information	1082-2
the original relation	by	constraint	the projections	1082-3
the original relation	More precisely can be reconstructed	action	the projections	1082-3
the original relation	joining	action	the projections	1082-3
Such joins	have been termed	action	lossless joins	1082-4
lossless joins	in	constraint	some depth	1082-4
lossless joins	and	conjunctive	some depth	1082-4
lossless joins	will be discussed	action	some depth	1082-4
some depth	in	constraint	Section 11.2	1082-4
Proposition		sequential	8.2.2	1083-1
Then I		sequential	π XY	1084-1
π XY		sequential	I	1084-1
I		sequential	πXZ	1084-1
πXZ		sequential	I	1084-1
Proof		sequential	Proof	1085-1
<B>	For	constraint	the opposite inclusion	1085-2
the opposite inclusion	let	action	r	1085-2
r	be	attribute	a tuple	1085-2
a tuple	in	constraint	the join	1085-2
there	Then are	action	tuples	1085-3
tuples		sequential	t ∈	1085-3
t ∈		sequential	I	1085-3
I		sequential	such that πXY	1085-3
such that πXY		sequential	r	1085-3
It	that	constraint	r	1086-1
It	follows	action	r	1086-1
r	=	sequential	t	1086-1
t		sequential	r	1086-1
r	in	constraint	so I	1086-1
r	is	attribute	so I	1086-1
Logical Implication		sequential	Logical Implication	1087-1
A natural question	is	attribute	<B>	1087-2
<B>	by	constraint	the following definition	1087-3
<B>	is captured	action	the following definition	1087-3
Definition		sequential	8.2.3	1088-1
F	Then implies	action	F	1088-2
F	denoted	action	F	1088-2
F	or	conjunctive	simply F	1088-2
simply F	if	constraint	U	1088-2
simply F	Ŵ	sequential	U	1088-2
U	from	constraint	the context	1088-2
U	is understood	action	the context	1088-2
the context	if	constraint	all relations	1088-2
the context	for	constraint	all relations	1088-2
all relations		sequential	I	1088-2
I	over	constraint	U	1088-2
U		sequential	I	1088-2
I	|=	sequential	F	1088-2
F	implies	action	I	1088-2
I	|=	sequential	<B>	1088-2
I	Ŵ	sequential	<B>	1088-2
Two sets		sequential	F	1088-3
F	if	constraint	F	1088-3
F	≡ F	sequential	F	1088-3
F	are	attribute	equivalent	1088-3
F	denoted	action	F	1088-3
F	and	conjunctive	F	1088-3
F		sequential	Ŵ	1088-3
Example		sequential	8.2.4	1089-1
8.2.4	Consider	action	the set	1089-1
the set		sequential	F1	1089-1
F1	=	sequential	A	1089-1
F1	{	sequential	A	1089-1
A	→	sequential	C	1089-1
C		sequential	B	1089-1
B	→	sequential	C	1089-1
C		sequential	CD E	1089-1
CD E	→	sequential	}	1089-1
}	of	constraint	fd	1089-1
fd		sequential	<B>	1089-1
Then2		sequential	a simple argument	1089-2
a simple argument	to	constraint	F1	1089-2
a simple argument	that	constraint	F1	1089-2
a simple argument	allows	action	F1	1089-2
a simple argument	show	action	F1	1089-2
F1	|=	sequential	AD → E	1089-2
The fd closure	of	constraint	a set F	1090-1
a set F	of	constraint	fd	1090-1
fd	over	constraint	an attribute set	1090-1
an attribute set		sequential	U	1090-1
U	denoted	action	F∗	1090-1
F∗		sequential	U	1090-1
U	or	conjunctive	simply F∗	1090-1
simply F∗	if	constraint	U	1090-1
U	from	constraint	the context	1090-1
U	is understood	action	the context	1090-1
the context	is	attribute	the set	1090-1
It	that	constraint	any set F	1091-1
It	for	constraint	any set F	1091-1
It	is easily verified	action	any set F	1091-1
any set F	of	constraint	fd	1091-1
fd	over	constraint	U	1091-1
U	and	conjunctive	any sets Y ⊆	1091-1
any sets Y ⊆		sequential	X ⊆	1091-1
X ⊆		sequential	U	1091-1
U		sequential	X	1091-1
X	→	sequential	Y ∈ F∗	1091-1
Y ∈ F∗		sequential	U	1091-1
<B>	that	constraint	the closure	1091-2
<B>	implies	action	the closure	1091-2
the closure	of	constraint	a set	1091-2
a set	of	constraint	fd s	1091-2
fd s	on	constraint	the underlying set	1091-2
fd s	depends	action	the underlying set	1091-2
the underlying set	of	constraint	attributes	1091-2
It	that	constraint	F∗ U	1091-3
It	also implies	action	F∗ U	1091-3
F∗ U	has	action	size	1091-3
size	than	constraint	2|U|	1091-3
It	by	constraint	22	1091-4
It	is bounded	action	22	1091-4
22	|	sequential	U|	1091-4
U|	by	constraint	definition	1091-4
Other properties	of	constraint	fd closures	1091-5
fd closures	in	constraint	Exercise 8.3	1091-5
fd closures	are considered	action	Exercise 8.3	1091-5
<B>	Determining	action	Implication	1092-1
Implication	for	constraint	fd	1092-1
fd	Is	action	Linear Time	1092-1
<B>	Although	constraint	a set	1092-2
a set		sequential	F	1092-2
F	of	constraint	fd	1092-2
fd	in	constraint	terms	1092-2
fd	implies	attribute	an exponential	1092-2
terms	of	constraint	the number	1092-2
the number	of	constraint	attributes	1092-2
attributes	in	constraint	the underlying schema	1092-2
the underlying schema		sequential	number s	1092-2
number s	of	constraint	fd	1092-2
fd		sequential	it	1092-2
it	to	constraint	F	1092-2
it	whether	constraint	F	1092-2
it	is	attribute	possible	1092-2
it	test	action	F	1092-2
F	implies	action	an fd X → Y	1092-2
an fd X → Y	in	constraint	time	1092-2
time		sequential	that	1092-2
that	in	constraint	the size	1092-2
that	is	attribute	linear	1092-2
the size	of	constraint	F	1092-2
F	and	conjunctive	X	1092-2
X	→	sequential	Y	1092-2
Y		sequential	the space	1092-2
the space	to	constraint	them	1092-2
the space	needed	action	them	1092-2
the space	write	action	them	1092-2
Example		sequential	8.2.5	1093-1
A∗	Then =	sequential	AC	1093-2
AC		sequential	AB	1093-2
AB		sequential	∗	1093-2
∗	=	sequential	<B>	1093-2
<B>	is easily verified	action	Exercise 8.4	1094-1
<B>	see	action	Exercise 8.4	1094-1
Exercise 8.4		sequential	Lemma	1094-1
Lemma		sequential	8.2.6	1094-1
Then F Y iff Y ⊆ X∗		sequential	X	1094-2
X	→	sequential	<B>	1094-2
<B>	whether	constraint	F	1095-1
<B>	Thus testing	action	F	1095-1
F	|=	sequential	X	1095-1
X		sequential	→ Y	1095-1
→ Y	by	constraint	X∗	1095-1
→ Y	can be accomplished	action	X∗	1095-1
→ Y	computing	action	X∗	1095-1
The following algorithm	to	constraint	this set	1095-2
The following algorithm	can be used	action	this set	1095-2
The following algorithm	compute	action	this set	1095-2
Input		sequential	a set F s	1096-1
a set F s	of	constraint	fd	1096-1
fd	and	conjunctive	a set X	1096-1
a set X	of	constraint	attributes	1096-1
Output		sequential	the closure X∗	1097-1
the closure X∗	of	constraint	X	1097-1
X	under	constraint	F	1097-1
<B>	if	constraint	W →	1098-1
W →		sequential	Z ∈	1098-1
Z ∈	and	conjunctive	W ⊆ closure	1098-1
W ⊆ closure	=	sequential	W }	1098-1
W }	→	sequential	Z	1098-1
Z		sequential	ii	1098-1
closure	=	sequential	closure	1098-2
closure		sequential	∪ Z	1098-2
<B>	and	conjunctive	Dependency Proposition	1099-1
<B>	Join	action	Dependency Proposition	1099-1
Dependency Proposition		sequential	8.2.8	1099-1
Proof	Let	action	U	1100-1
U	be	attribute	a set	1100-1
a set	of	constraint	attributes	1100-1
attributes	containing	action	the attributes	1100-1
the attributes	in	constraint	F	1100-1
the attributes	occurring	action	F	1100-1
F	or	conjunctive	X	1100-1
X	and	conjunctive	result	1100-1
X	let	action	result	1100-1
result	be	attribute	the output	1100-1
the output	of	constraint	the algorithm	1100-1
<B>	Using	action	properties	1100-2
properties	in	constraint	Exercise 8.5	1100-2
properties	established	action	Exercise 8.5	1100-2
Exercise 8.5		sequential	an easy induction	1100-2
an easy induction	shows	attribute	that	1100-2
an easy induction	result	action	<B>	1100-2
<B>	For	constraint	the opposite inclusion	1101-1
the opposite inclusion	for	constraint	attribute sets Y	1101-1
the opposite inclusion	note first	attribute	that	1101-1
attribute sets Y		sequential	Z	1101-1
Z	if	constraint	Y	1101-1
Y		sequential	⊆	1101-1
⊆		sequential	Y ⊆ Z Z∗	1101-1
<B>	Because	constraint	X ⊆ result	1102-1
X ⊆ result		sequential	it	1102-1
it	to	constraint	that result∗ ⊆ result	1102-1
it	now suffices	action	that result∗ ⊆ result	1102-1
it	show	action	that result∗ ⊆ result	1102-1
It	to	constraint	A ∈ U	1102-2
It	that	constraint	A ∈ U	1102-2
It	if	constraint	A ∈ U	1102-2
It	is	attribute	enough	1102-2
It	show	action	A ∈ U	1102-2
A ∈ U		sequential	−	1102-2
−	result	action	F	1102-2
F	result	action	→ A	1102-2
<B>	To	constraint	we	1102-3
<B>	show	attribute	this	1102-3
we	construct	action	an instance	1102-3
an instance		sequential	I	1102-3
I	over	constraint	U	1102-3
U		sequential	that	1102-3
that		sequential	I	1102-3
I	|=	sequential	F	1102-3
F	but	conjunctive	I	1102-3
I	result	action	→ A	1102-3
→ A	for	constraint	U	1102-3
U		sequential	A ∈ result	1102-3
<B>	Let	action	I	1102-4
I	{	sequential	t }	1102-4
t }		sequential	π	1102-4
π	where result s	action	<B>	1102-4
The algorithm	provides	action	the means	1103-1
the means	for	constraint	a set	1103-1
the means	whether	constraint	a set	1103-1
the means	checking	action	a set	1103-1
a set	of	constraint	dependencies	1103-1
dependencies	implies	action	a single dependency	1103-1
<B>	To	constraint	implication	1103-2
<B>	test	action	implication	1103-2
implication	of	constraint	a set	1103-2
a set	of	constraint	dependencies	1103-2
dependencies		sequential	it	1103-2
it	to	constraint	the implication	1103-2
it	suffices	action	the implication	1103-2
it	test independently	action	the implication	1103-2
the implication	of	constraint	each dependency	1103-2
each dependency	in	constraint	the set	1103-2
<B>	In	constraint	addition	1103-3
addition		sequential	one	1103-3
one	that	constraint	the preceding algorithm	1103-3
one	can check	action	the preceding algorithm	1103-3
the preceding algorithm	in	constraint	time	1103-3
the preceding algorithm	runs	action	time	1103-3
time		sequential	O	1103-3
O	n	conjunctive	2	1103-3
2	n	conjunctive	where the length	1103-3
2	is	attribute	where the length	1103-3
where the length	of	constraint	F	1103-3
F	and	conjunctive	X	1103-3
<B>	As	constraint	Exercise 8.7	1103-4
<B>	in	constraint	Exercise 8.7	1103-4
<B>	shown	action	Exercise 8.7	1103-4
Exercise 8.7		sequential	this algorithm	1103-4
this algorithm	to	constraint	linear time	1103-4
this algorithm	can be improved	action	linear time	1103-4
<B>	summarizes	action	this development	1103-5
Theorem		sequential	8.2.9	1104-1
8.2.9	Given	action	a set F	1104-1
a set F	of	constraint	fd	1104-1
fd	and	conjunctive	a single fd σ	1104-1
a single fd σ	whether	constraint	F	1104-1
a single fd σ	determine	action	F	1104-1
F	|=	sequential	σ	1104-1
σ	in	constraint	linear time	1104-1
σ	can be decided	action	linear time	1104-1
Several interesting properties	of	constraint	fd- closure sets	1105-1
fd- closure sets	in	constraint	Exercises 8.11	1105-1
fd- closure sets	are considered	action	Exercises 8.11	1105-1
Exercises 8.11	and	conjunctive	8.12	1105-1
<B>	In	constraint	addition	1106-1
addition	to	constraint	algorithms	1106-1
addition	developing	action	algorithms	1106-1
algorithms	for	constraint	logical implication	1106-1
algorithms	determining	action	logical implication	1106-1
logical implication		sequential	the second fundamental theme	1106-1
the second fundamental theme	in	constraint	dependency theory	1106-1
dependency theory	been	action	has the development	1106-1
has the development	of	constraint	inference rules	1106-1
inference rules		sequential	which	1106-1
which	to	constraint	symbolic proofs	1106-1
which	can be used	action	symbolic proofs	1106-1
which	generate	action	symbolic proofs	1106-1
symbolic proofs	of	constraint	logical implication	1106-1
<B>	Although	constraint	the inference rules	1106-2
the inference rules	do not typically yield	action	the most efficient mechanisms	1106-2
the most efficient mechanisms	for	constraint	logical implication	1106-2
the most efficient mechanisms	deciding	action	logical implication	1106-2
logical implication	in	constraint	many cases	1106-2
many cases		sequential	they	1106-2
they	capture concisely	action	the essential properties	1106-2
the essential properties	of	constraint	the dependencies	1106-2
the dependencies	under	constraint	study	1106-2
The study	of	constraint	inference rules	1106-3
inference rules	because	constraint	the next section	1106-3
inference rules	as	constraint	the next section	1106-3
inference rules	in	constraint	the next section	1106-3
inference rules	is	attribute	especially intriguing	1106-3
inference rules	will be seen	action	the next section	1106-3
the next section		sequential	there	1106-3
there	are	attribute	several classes	1106-3
several classes	of	constraint	dependencies	1106-3
dependencies	for	constraint	which	1106-3
which		sequential	there	1106-3
there	is	attribute	no finite set	1106-3
no finite set	of	constraint	inference rules	1106-3
inference rules		sequential	that	1106-3
that	characterizes	action	logical implication	1106-3
Inference rules	and	conjunctive	algorithms	1107-1
algorithms	for	constraint	testing implication	1107-1
testing implication	provide	action	alternative approaches	1107-1
alternative approaches	to	constraint	logical implication	1107-1
alternative approaches	showing	action	logical implication	1107-1
logical implication	between	constraint	dependencies	1107-1
<B>	In	constraint	the existence	1107-2
the existence	of	constraint	a finite set	1107-2
a finite set	of	constraint	inference rules	1107-2
inference rules	for	constraint	a class	1107-2
a class	of	constraint	dependencies	1107-2
dependencies	is	attribute	a stronger property	1107-2
a stronger property	than	constraint	the existence	1107-2
the existence	of	constraint	an algorithm	1107-2
an algorithm	for	constraint	testing implication	1107-2
It	in	constraint	Chapter 9 that	1107-3
It	will be shown	action	Chapter 9 that	1107-3
We	now present	action	the inference rules	1108-1
the inference rules	for	constraint	fd	1108-1
fd		sequential	<B>	1108-1
FD1		sequential	reflexivity	1109-1
FD2		sequential	augmentation	1110-1
FD3		sequential	transitivity	1111-1
The variables		sequential	X	1112-1
X		sequential	Y	1112-1
Y		sequential	Z range	1112-1
Z range	over	constraint	sets	1112-1
sets	of	constraint	attributes	1112-1
The first rule	is sometimes called	action	an axiom	1112-2
an axiom	because	constraint	it	1112-2
it	in	constraint	the sense	1112-2
it	is	attribute	degenerate	1112-2
the sense	that	constraint	no fd	1112-2
no fd	in	constraint	the antecedent	1112-2
no fd	s occur	action	the antecedent	1112-2
The inference rules	to	constraint	proofs	1113-1
The inference rules	are used	action	proofs	1113-1
The inference rules	form	action	proofs	1113-1
proofs	about	constraint	logical implication	1113-1
logical implication	between	constraint	fd	1113-1
fd	in	constraint	a manner	1113-1
a manner	to	constraint	the proofs	1113-1
the proofs	in	constraint	mathematical logic	1113-1
the proofs	found	action	mathematical logic	1113-1
It	that	constraint	the resulting proof system	1113-2
It	will be shown	action	the resulting proof system	1113-2
the resulting proof system	is	attribute	sound	1113-2
sound	for	constraint	fd	1113-2
sound	and	conjunctive	fd	1113-2
fd		sequential	two classical notions	1113-2
two classical notions	to	constraint	<B>	1113-2
two classical notions	be recalled soon	action	<B>	1113-2
<B>	Before	constraint	the notion	1113-3
<B>	formally presenting	action	the notion	1113-3
the notion	of	constraint	proof	1113-3
proof		sequential	we	1113-3
we	give	action	an example	1113-3
Example		sequential	8.2.10	1114-1
<B>	from	constraint	σ 1	1115-1
σ 1	using	action	FD2	1115-1
FD2		sequential	CD	1115-1
CD	→	sequential	E	1115-1
E	from	constraint	σ 2	1115-1
σ 2	and	conjunctive	σ 3	1115-1
σ 3	using	action	FD3	1115-1
<B>	Let	action	U	1116-1
U	be	attribute	a set	1116-1
a set	of	constraint	attributes	1116-1
A substitution	for	constraint	an inference rule ρ	1116-2
an inference rule ρ	to	constraint	U	1116-2
U	is	attribute	a function	1116-2
a function		sequential	that	1116-2
that	in	constraint	ρ	1116-2
that	maps	attribute	each variable	1116-2
that	appearing	action	ρ	1116-2
ρ	to	constraint	a subset	1116-2
a subset	of	constraint	U	1116-2
U		sequential	each set inclusion	1116-2
each set inclusion	in	constraint	the antecedent	1116-2
each set inclusion	indicated	action	the antecedent	1116-2
the antecedent	of	constraint	ρ	1116-2
ρ	by	constraint	the associated sets	1116-2
ρ	is	attribute	satisfied	1116-2
<B>	Now let	action	F	1116-3
F	be	attribute	a set	1116-3
a set	of	constraint	fd	1116-3
fd	over	constraint	U	1116-3
U	and	conjunctive	σ	1116-3
σ		sequential	an fd	1116-3
an fd	over	constraint	U	1116-3
A proof	of	constraint	σ	1116-4
σ	from	constraint	F	1116-4
F	using	action	the set	1116-4
the set		sequential	I	1116-4
I	=	sequential	FD1	1116-4
FD1		sequential	FD2	1116-4
FD2		sequential	FD3	1116-4
FD3	is	attribute	a sequence	1116-4
a sequence	of	constraint	fd	1116-4
fd		sequential	σ	1116-4
σ		sequential	1	1116-4
<B>	.	sequential	<B>	1116-5
<B>	.	sequential	<B>	1116-6
σn	=	sequential	σ that	1116-7
σ that		sequential	n	1116-7
n	for	constraint	i	1116-7
i		sequential	∈	1116-7
∈		sequential	1	1116-7
1	n	conjunctive	a σi ∈ F	1116-7
1	either	conjunctive	a σi ∈ F	1116-7
a σi ∈ F	or	conjunctive	<B>	1116-7
The fd σ	from	constraint	F	1117-1
The fd σ	is	attribute	provable	1117-1
F	using	action	I	1117-1
I	to	constraint	U	1117-1
U	denoted	action	F	1117-1
F		sequential	I	1117-1
I	from	constraint	the context	1117-1
I	understood	action	the context	1117-1
the context	if	constraint	there	1117-1
there	is	attribute	a proof	1117-1
a proof	of	constraint	σ	1117-1
σ	from	constraint	F	1117-1
F	using	action	I	1117-1
<B>	Let	action	I	1118-1
I	be	attribute	a set	1118-1
a set	of	constraint	inference rules	1118-1
I	for	constraint	logical implication	1118-2
I	is	attribute	Then sound	1118-2
logical implication	of	constraint	fd	1118-2
fd	if	constraint	F I	1118-2
F I		sequential	I	1118-2
I	for	constraint	logical implication	1118-2
I	is	attribute	complete	1118-2
logical implication	of	constraint	fd	1118-2
fd	if	constraint	F σ	1118-2
F σ	implies	action	F I	1118-2
We	will generalize	action	these definitions	1119-1
these definitions	to	constraint	other dependencies	1119-1
other dependencies	and	conjunctive	other sets	1119-1
other sets	of	constraint	inference rules	1119-1
<B>	In	constraint	finite sound	1120-1
finite sound	and	conjunctive	a set	1120-1
a set	of	constraint	inference rules	1120-1
inference rules	for	constraint	a class C	1120-1
a class C	of	constraint	dependencies	1120-1
dependencies	is called	action	a finite axiomatization	1120-1
a finite axiomatization	of	constraint	C	1120-1
We	and	conjunctive	Dependency Theorem 8.2.11	1121-1
We	now state	attribute	the	1121-1
We	Join	action	Dependency Theorem 8.2.11	1121-1
Proof	that	constraint	F	1122-1
Proof	Suppose	action	F	1122-1
F	is	attribute	a set	1122-1
a set	of	constraint	fd	1122-1
fd	over	constraint	an attribute	1122-1
an attribute	set	action	U	1122-1
The proof	of	constraint	soundness	1122-2
soundness	involves	action	a straightforward induction	1122-2
a straightforward induction	on	constraint	proofs σ	1122-2
proofs σ		sequential	1	1122-2
<B>	.	sequential	<B>	1122-3
<B>	.	sequential	<B>	1122-4
σn	from	constraint	F	1122-5
F	that	constraint	F σi	1122-5
F	showing	action	F σi	1122-5
F σi	for	constraint	i	1122-5
F σi	|=	sequential	i	1122-5
i		sequential	∈	1122-5
∈		sequential	1	1122-5
1		sequential	n	1122-5
n	see	action	Exercise 8.5	1122-5
<B>	For	constraint	the proof	1123-1
the proof	of	constraint	completeness	1123-1
completeness		sequential	we	1123-1
we	that	constraint	F	1123-1
we	show	action	F	1123-1
F		sequential	X → Y	1123-1
X → Y	implies	action	F X	1123-1
F X	→	sequential	Y	1123-1
<B>	As	constraint	a first step	1123-2
a first step		sequential	we	1123-2
we	that	constraint	F ⊢ X → X∗	1123-2
we	show	action	F ⊢ X → X∗	1123-2
F ⊢ X → X∗	using	action	an induction	1123-2
an induction	on	constraint	Algorithm 8.2.7	1123-2
an induction	based	action	Algorithm 8.2.7	1123-2
<B>	In	constraint	closure	1123-3
<B>	let	action	closure	1123-3
closure		sequential	i	1123-3
i	be	attribute	the value	1123-3
the value	of	constraint	closure	1123-3
closure	after	constraint	i iterations	1123-3
i iterations	of	constraint	step 3	1123-3
step 3	for	constraint	some fixed execution	1123-3
some fixed execution	of	constraint	that algorithm	1123-3
that algorithm	on	constraint	input	1123-3
input		sequential	F	1123-3
F	and	conjunctive	X	1123-3
We	set	action	closure	1123-4
closure		sequential	0	1123-4
0	=	sequential	X	1123-4
<B>	that	constraint	a proof	1123-5
<B>	Suppose inductively	action	a proof	1123-5
a proof		sequential	σ 1	1123-5
<B>	.	sequential	<B>	1123-6
<B>	.	sequential	<B>	1123-7
σk	of	constraint	X → closure	1123-8
X → closure		sequential	i	1123-8
i		sequential	i	1123-8
i	has been constructed	action	<B>	1123-8
The case	for	constraint	i	1123-9
i	=	sequential	0	1123-9
0	from	constraint	FD1	1123-9
0	follows	action	FD1	1123-9
<B>	that	constraint	W → Z	1123-10
<B>	Suppose	attribute	further	1123-10
W → Z	for	constraint	1	1123-10
W → Z	+	sequential	1	1123-10
W → Z	is chosen	action	1	1123-10
1		sequential	the i st iteration	1123-10
It	that	constraint	W ⊆ closure	1123-11
It	follows	action	W ⊆ closure	1123-11
W ⊆ closure		sequential	i	1123-11
i	and	conjunctive	closure	1123-11
closure		sequential	i+1 closure	1123-11
i+1 closure		sequential	i	1123-11
i	∪	action	Z	1123-11
<B>	Extend	action	the proof	1123-12
the proof	by	constraint	the following steps	1123-12
the proof	adding	action	the following steps	1123-12
the following steps	in	constraint	F	1123-12
F	by	constraint	FD1	1123-12
FD1	by	constraint	FD3	1123-12
FD3	by	constraint	FD2	1123-12
FD2	by	constraint	FD3	1123-12
Other inference rules	for	constraint	fd	1124-1
fd	in	constraint	Exercise 8.9	1124-1
fd	are considered	action	Exercise 8.9	1124-1
<B>	In	constraint	the proof	1125-1
the proof	of	constraint	Proposition 8.2.8	1125-1
Proposition 8.2.8		sequential	an instance	1125-1
an instance		sequential	I	1125-1
I	that	constraint	I	1125-1
I	is created	attribute	such	1125-1
I	|=	sequential	F	1125-1
F	but	conjunctive	I	1125-1
I		sequential	X → A	1125-1
this instance	Intuitively witnesses	action	the fact	1126-1
the fact	that	constraint	F	1126-1
F		sequential	X	1126-1
X		sequential	→ A	1126-1
<B>	raises	action	the following natural question	1126-2
the following natural question	Given	action	a set F	1126-2
a set F	of	constraint	fd	1126-2
fd	over	constraint	U	1126-2
U	is	attribute	there	1126-2
there		sequential	a single instance	1126-2
a single instance		sequential	I	1126-2
I		sequential	that	1126-2
that	satisfies	action	F	1126-2
F	and	conjunctive	every fd	1126-2
F	violates	action	every fd	1126-2
every fd	in	constraint	not F∗	1126-2
It	that	constraint	each set	1126-3
It	for	constraint	each set	1126-3
It	turns out	action	each set	1126-3
each set	of	constraint	fd	1126-3
fd		sequential	there	1126-3
there	is	attribute	such an instance	1126-3
such an instance	are called	action	Armstrong relations	1126-3
Proposition		sequential	8.2.12	1127-1
Crux	that	constraint	F	1128-1
Crux	Suppose first	action	F	1128-1
F	∅	sequential	A	1128-1
F	→	sequential	A	1128-1
A	for	constraint	any A	1128-1
any A		sequential	∅∗	1128-1
∅∗	=	sequential	∅	1128-1
<B>	For	constraint	each set	1128-2
each set		sequential	X ⊆	1128-2
X ⊆		sequential	U	1128-2
U		sequential	X	1128-2
X	=	sequential	X∗	1128-2
X∗	choose	action	an instance	1128-2
an instance		sequential	IX	1128-2
IX	=	sequential	sX	1128-2
sX		sequential	tX } such	1128-2
tX } such		sequential	that	1128-2
that		sequential	sX	1128-2
sX		sequential	A	1128-2
A	=	sequential	tX A iff A ∈ X	1128-2
<B>	In	constraint	addition	1128-3
addition	choose	action	these instances	1128-3
these instances	so that	constraint	adom	1128-3
adom		sequential	IX	1128-3
IX		sequential	∩ adom	1128-3
∩ adom		sequential	IY	1128-3
IY	for	constraint	Y	1128-3
IY	=	sequential	Y	1128-3
IY	∅	sequential	Y	1128-3
IY	X =	sequential	Y	1128-3
<B>	is	attribute	Then an Armstrong relation	1128-4
Then an Armstrong relation	for	constraint	F	1128-4
<B>	If	constraint	∅∗	1129-1
∅∗	=	sequential	the instances	1129-1
the instances		sequential	IX	1129-1
IX	so that	constraint	πA	1129-1
IX	should be modified	action	πA	1129-1
πA		sequential	IX	1129-1
IX	=	sequential	π A	1129-1
π A		sequential	IY	1129-1
IY	for	constraint	each X	1129-1
each X		sequential	Y	1129-1
Y	and	conjunctive	A ∈	1129-1
A ∈		sequential	∅∗	1129-1
<B>	In	constraint	some applications	1130-1
some applications		sequential	the domains	1130-1
the domains	of	constraint	certain attributes	1130-1
certain attributes	be	attribute	may finite	1130-1
Sex	conventionally has	action	two values	1130-1
two values	and	conjunctive	Grade	1130-1
Grade	of	constraint	a finite set	1130-1
Grade	typically consists	action	a finite set	1130-1
a finite set	of	constraint	values	1130-1
<B>	In	constraint	such cases	1130-2
such cases		sequential	the construction	1130-2
the construction	of	constraint	an Armstrong relation	1130-2
an Armstrong relation	be	attribute	may not possible	1130-2
<B>	in	constraint	Exercise 8.13	1130-3
<B>	is explored	action	Exercise 8.13	1130-3
<B>	and	conjunctive	Dependencies	1131-1
<B>	Join	attribute	Multivalued	1131-1
<B>	As	constraint	Section 8.1	1131-2
<B>	in	constraint	Section 8.1	1131-2
<B>	mentioned	action	Section 8.1	1131-2
Section 8.1		sequential	a basic motivation	1131-2
a basic motivation	for	constraint	dependency	1131-2
a basic motivation	join	action	dependency	1131-2
dependency	from	constraint	its usefulness	1131-2
dependency	stems	action	its usefulness	1131-2
its usefulness	in	constraint	connection	1131-2
connection	with	constraint	relation decomposition	1131-2
This section	also discusses	action	multivalued dependency	1131-3
multivalued dependency		sequential	mvd	1131-3
mvd		sequential	an important special case	1131-3
an important special case	of	constraint	join dependency	1131-3
join dependency		sequential	that	1131-3
that	to	constraint	<B>	1131-3
that	was	attribute	historically the first	1131-3
that	be introduced	action	<B>	1131-3
The central results	and	conjunctive	tools	1132-1
tools	for	constraint	jd	1132-1
tools	studying	action	jd	1132-1
jd		sequential	s	1132-1
s	from	constraint	fd	1132-1
s	for	constraint	fd	1132-1
s	are	attribute	different	1132-1
fd		sequential	<B>	1132-1
It	that	constraint	there	1132-2
It	has been shown	action	there	1132-2
there	is	attribute	no sound	1132-2
no sound	and	conjunctive	complete set	1132-2
complete set	of	constraint	inference rules	1132-2
inference rules	for	constraint	jd	1132-2
jd	to	constraint	fd	1132-2
jd	for	constraint	fd	1132-2
jd	s	attribute	analogous	1132-2
fd		sequential	<B>	1132-2
An axiomatization	for	constraint	a much larger family	1132-3
a much larger family	of	constraint	dependencies	1132-3
dependencies	in	constraint	Chapter 10	1132-3
dependencies	will be presented	action	Chapter 10	1132-3
<B>	In	constraint	addition	1132-4
addition	as	constraint	the following section	1132-4
addition	in	constraint	the following section	1132-4
addition	shown	action	the following section	1132-4
the following section		sequential	logical implication	1132-4
logical implication	for	constraint	jd	1132-4
jd	is	attribute	decidable	1132-4
The complexity	of	constraint	implication	1132-5
implication	for	constraint	a fixed database schema	1132-5
implication	is	attribute	polynomial	1132-5
a fixed database schema	if	constraint	the schema	1132-5
a fixed database schema	but	conjunctive	the schema	1132-5
a fixed database schema	becomes	attribute	np hard	1132-5
the schema	is considered	action	part	1132-5
part	of	constraint	the input	1132-5
An exact characterization	of	constraint	the complexity	1132-6
the complexity	remains	attribute	open	1132-6
The following section	also presents	action	an interesting correspondence	1133-1
an interesting correspondence	between	constraint	join dependencies	1133-1
an interesting correspondence	and	conjunctive	join dependencies	1133-1
join dependencies	on	constraint	that	1133-1
join dependencies	based	action	that	1133-1
join dependencies	joins	action	that	1133-1
that	in	constraint	the sense	1133-1
that	are	attribute	acyclic	1133-1
the sense	in	constraint	Chapter	1133-1
the sense	introduced	action	Chapter	1133-1
Chapter		sequential	6	1133-1
<B>	Join	action	Dependency	1134-1
Dependency	and	conjunctive	Decomposition	1134-1
Decomposition	Before	constraint	dependency	1134-1
Decomposition	defining	action	dependency	1134-1
Decomposition	join	action	dependency	1134-1
dependency		sequential	we	1134-1
we	recall	action	the definition	1134-1
the definition	of	constraint	natural join	1134-1
<B>	For	constraint	attribute set	1134-2
attribute set		sequential	U	1134-2
U	sets	action	X1	1134-2
<B>	.	sequential	<B>	1134-3
<B>	.	sequential	<B>	1134-4
Xn		sequential	⊆ U	1134-5
⊆ U	and	conjunctive	instances	1134-5
<B>	and	conjunctive	Dependency Definition 8.3.1 i=1	1135-1
<B>	Join	action	Dependency Definition 8.3.1 i=1	1135-1
Dependency Definition 8.3.1 i=1		sequential	i	1135-1
i	=	sequential	U	1135-1
A relation		sequential	I	1135-2
I	over	constraint	U	1135-2
U	satisfies	action	<B>	1135-2
j		sequential	=1	1136-1
=1		sequential	Xj	1136-1
2 ary		sequential	jd	1137-1
jd		sequential	The s	1137-1
The s	are also called	action	multivalued dependencies	1137-1
multivalued dependencies		sequential	<B>	1137-1
<B>	in	constraint	a style	1137-2
<B>	are often denoted	action	a style	1137-2
a style	of	constraint	fd	1137-2
fd		sequential	<B>	1137-2
Definition		sequential	8.3.2	1138-1
<B>	In	constraint	the preceding definition	1139-1
the preceding definition		sequential	it	1139-1
it	to	constraint	⊲⊳	1139-1
it	be	attribute	would equivalent	1139-1
it	write	action	⊲⊳	1139-1
⊲⊳		sequential	XY	1139-1
XY		sequential	U	1139-1
U	−	sequential	Y	1139-1
Y		sequential	we	1139-1
we	choose	action	the foregoing form	1139-1
the foregoing form	to	constraint	the importance	1139-1
the foregoing form	emphasize	action	the importance	1139-1
the importance	of	constraint	X	1139-1
<B>	For	constraint	instance	1139-2
instance		sequential	the jd	1139-2
the jd	as	constraint	an mvd	1139-2
the jd	can be written	action	an mvd	1139-2
an mvd	using	action	Theater	1139-2
Theater	or	conjunctive	Theater	1139-2
Theater	→	sequential	Theater	1139-2
Exercise 8.16	explores	action	the original definition	1140-1
the original definition	of	constraint	satisfaction	1140-1
satisfaction	of	constraint	an mvd	1140-1
Figure		sequential	8.2	1141-1
8.2	shows	action	a relation schema SDT	1141-1
a relation schema SDT	and	conjunctive	an instance	1141-1
an instance		sequential	that	1141-1
that	satisfies	action	3 ary	1141-1
3 ary		sequential	a jd	1141-1
This relation	on	constraint	snacks	1141-2
This relation	focuses	action	snacks	1141-2
snacks		sequential	distributors	1141-2
distributors	and	conjunctive	theaters	1141-2
We	for	constraint	this example	1141-3
We	assume	action	this example	1141-3
this example	that	constraint	a tuple s	1141-3
a tuple s		sequential	d	1141-3
d		sequential	p	1141-3
p		sequential	t	1141-3
t	in	constraint	SDT	1141-3
t	is	attribute	SDT	1141-3
SDT	if	constraint	the conjunction	1141-3
the conjunction	of	constraint	the following predicates	1141-3
the following predicates	is	attribute	true	1141-3
P1 s		sequential	d	1141-3
d		sequential	p	1141-3
P2		sequential	d	1142-1
d		sequential	t	1142-1
P3 s		sequential	t	1143-1
<B>	Under	constraint	these assumptions	1144-1
these assumptions		sequential	each instance	1144-1
each instance	of	constraint	SDT	1144-1
SDT	must satisfy	action	the jd	1144-1
<B>	For	constraint	example	1145-1
example	for	constraint	the instance	1145-1
example	holds	action	the instance	1145-1
the instance	in	constraint	Fig	1145-1
8.2		sequential	8.2	1145-2
<B>	that	constraint	tuple coffee	1145-3
<B>	if	constraint	tuple coffee	1145-3
<B>	Note	action	tuple coffee	1145-3
tuple coffee		sequential	Smart	1145-3
Smart		sequential	2.35	1145-3
2.35		sequential	Cinoche	1145-3
Cinoche	were removed	action	the instance	1145-3
the instance	would no longer satisfy	action	the jd	1145-3
the jd	because	constraint	coffee	1145-3
coffee		sequential	Smart	1145-3
Smart		sequential	2.35	1145-3
2.35		sequential	coffee	1145-3
coffee		sequential	Cinoche	1145-3
Cinoche	and	conjunctive	Smart	1145-3
Smart		sequential	Cinoche	1145-3
Cinoche	in	constraint	the appropriate projections	1145-3
Cinoche	would remain	action	the appropriate projections	1145-3
We	also expect	action	the instances	1145-4
the instances	of	constraint	SDT	1145-4
SDT	to	constraint	Snack	1145-4
SDT	satisfy	action	Snack	1145-4
Snack		sequential	Distributor	1145-4
Distributor	→	sequential	Price	1145-4
It	that	constraint	schema SDT	1146-1
It	can be argued	action	schema SDT	1146-1
schema SDT	with	constraint	the aforementioned constraint	1146-1
the aforementioned constraint	in	constraint	the following sense	1146-1
the aforementioned constraint	is	attribute	unnatural	1146-1
<B>	if	constraint	we	1146-2
we	choose	action	such a schema	1146-2
such a schema		sequential	the presence Smart Rex coffee Smart Le coffee	1146-2
the presence Smart Rex coffee Smart Le coffee	of	constraint	a tuple SDT Snack Distributor Price Theater coffee Champo Smart Cinoche coffee	1146-2
a tuple SDT Snack Distributor Price Theater coffee Champo Smart Cinoche coffee		sequential	Leclerc Cinoche wine Smart Rex wine Smart Cinoche popcorn Leclerc Cinoche Figure	1146-2
Leclerc Cinoche wine Smart Rex wine Smart Cinoche popcorn Leclerc Cinoche Figure		sequential	8.2	1146-2
8.2		sequential	Illustration	1146-2
Illustration	of	constraint	join dependency	1146-2
join dependency		sequential	d	1146-2
d		sequential	p	1146-2
p		sequential	t	1146-2
t	to	constraint	t	1146-2
t	that	constraint	t	1146-2
t	seems	action	t	1146-2
t	indicate	action	t	1146-2
t	from	constraint	d	1146-2
t	buys s	action	d	1146-2
The jd	that	constraint	no information	1146-3
The jd	guarantees	action	no information	1146-3
no information	in	constraint	the decomposition	1146-3
no information	is lost	action	the decomposition	1146-3
the decomposition	because	constraint	the original relation	1146-3
the original relation	by	constraint	the projections	1146-3
the original relation	can be reconstructed	action	the projections	1146-3
the original relation	joining	action	the projections	1146-3
<B>	Join	action	Dependencies	1147-1
Dependencies	and	conjunctive	Dependencies	1147-1
<B>	Although	constraint	more depth	1147-2
<B>	in	constraint	more depth	1147-2
<B>	is explored	action	more depth	1147-2
more depth	in	constraint	Chapter 11	1147-2
Chapter 11		sequential	we	1147-2
we	present here	action	one	1147-2
one	of	constraint	the first results	1147-2
the first results	on	constraint	the interaction	1147-2
the interaction	of	constraint	the two kinds	1147-2
the two kinds	of	constraint	dependencies	1147-2
Proposition		sequential	8.3.3	1148-1
Then F		sequential	XY	1148-2
XY		sequential	XZ	1148-2
XZ		sequential	iff	1148-2
iff	either	conjunctive	F	1148-2
F		sequential	X	1148-2
X		sequential	→ Y	1148-2
→ Y	or	conjunctive	F	1148-2
F		sequential	X	1148-2
X	→	sequential	Z	1148-2
Crux Sufficiency	from	constraint	Proposition 8.2.2	1149-1
Crux Sufficiency	follows immediately	action	Proposition 8.2.2	1149-1
<B>	For	constraint	necessity	1149-2
necessity	that	constraint	F	1149-2
necessity	suppose	action	F	1149-2
F	of	constraint	the fd	1149-2
F	does not imply	attribute	either	1149-2
the fd		sequential	<B>	1149-2
Then Y X∗		sequential	∅	1149-3
∅	and	conjunctive	Z	1149-3
Z		sequential	X∗	1149-3
X∗	=	sequential	∅	1149-3
∅	say	action	C	1149-3
C		sequential	∈ Y	1149-3
∈ Y		sequential	X∗	1149-3
X∗	if	constraint	A	1149-3
A	in	constraint	X∗	1149-3
A	is	attribute	X∗	1149-3
X∗	and	conjunctive	u	1149-3
u		sequential	A	1149-3
A	=	sequential	0	1149-3
0		sequential	v	1149-3
v		sequential	A	1149-3
A	= otherwise	sequential	1	1149-3
I	Clearly satisfies	action	F	1149-4
F	and	conjunctive	one	1149-4
one	that	constraint	π XY	1149-4
one	can verify	action	π XY	1149-4
π XY		sequential	I	1149-4
I	⊲⊳	sequential	πXZ	1149-4
πXZ		sequential	I	1149-4
I	contains	action	a tuple	1149-4
a tuple	w	constraint	C	1149-4
a tuple	with	constraint	C	1149-4
a tuple	w	constraint	C	1149-4
C	=	sequential	0	1149-4
0	w	constraint	C′	1149-4
0	and	conjunctive	C′	1149-4
C′	=	sequential	1	1149-4
<B>	in	constraint	Thus w not I	1149-5
<B>	is	attribute	Thus w not I	1149-5
Thus w not I		sequential	I	1149-5
I	so violates	action	XY	1149-5
XY		sequential	XZ	1149-5
We	state first	action	the following result	1150-1
the following result	without	constraint	proof	1150-1
Theorem		sequential	8.3.4	1151-1
<B>	and	conjunctive	Dependency	1152-1
<B>	Join	action	Dependency	1152-1
<B>	Note first	action	that implication	1152-2
that implication	for	constraint	fd	1152-2
fd		sequential	s	1152-2
s	of	constraint	the underlying set	1152-2
s	is	attribute	independent	1152-2
the underlying set	of	constraint	attributes	1152-2
attributes	if	constraint	F ∪	1152-2
F ∪	{	sequential	σ	1152-2
σ	is	attribute	a set	1152-2
a set	of	constraint	fd	1152-2
fd		sequential	s	1152-2
s	over	constraint	U	1152-2
U	and	conjunctive	V	1152-2
V		sequential	U	1152-2
U		sequential	F	1152-2
F		sequential	σ	1152-2
σ	to	constraint	U iff F	1152-2
U iff F		sequential	σ	1152-2
σ	to	constraint	V	1152-2
V	see	action	Exercise 8.6	1152-2
An important difference	between	constraint	fd	1152-3
fd	and	conjunctive	mvd	1152-3
mvd	that	constraint	not the case	1152-3
mvd	is	attribute	this	1152-3
mvd	is	attribute	not the case	1152-3
not the case	for	constraint	mvd	1152-3
mvd		sequential	<B>	1152-3
the inference rules	for	constraint	mvd	1152-4
mvd		sequential	s	1152-4
s	in	constraint	connection	1152-4
s	Thus must be used	action	connection	1152-4
connection	with	constraint	a fixed underlying set	1152-4
a fixed underlying set	of	constraint	attributes	1152-4
attributes	and	conjunctive	a variable denoted U	1152-4
a variable denoted U	to	constraint	this set	1152-4
a variable denoted U	referring	action	this set	1152-4
this set	in	constraint	one	1152-4
this set	is used	action	one	1152-4
one	of	constraint	the rules	1152-4
<B>	lists	action	the four rules	1153-1
the four rules	for	constraint	an additional pair	1153-1
the four rules	and	conjunctive	an additional pair	1153-1
an additional pair	of	constraint	rules	1153-1
rules	needed	action	fd	1153-1
fd	when are incorporated	action	<B>	1153-1
MVD0		sequential	complementation	1154-1
MVD1		sequential	reflexivity	1155-1
MVD2		sequential	augmentation	1156-1
MVD3		sequential	transitivity	1157-1
FMVD1		sequential	conversion	1158-1
FMVD2		sequential	interaction	1159-1
Theorem		sequential	8.3.5	1160-1
Crux Soundness	is easily verified	action	<B>	1161-1
<B>	For	constraint	completeness	1161-2
completeness	let	action	an underlying set	1161-2
an underlying set		sequential	U	1161-2
U	of	constraint	attributes	1161-2
attributes	that	constraint	F ⊢ σ	1161-2
attributes	and	conjunctive	F ⊢ σ	1161-2
attributes	be fixed	action	F ⊢ σ	1161-2
attributes	assume	action	F ⊢ σ	1161-2
F ⊢ σ		sequential	σ	1161-2
σ	where =	sequential	X	1161-2
X		sequential	→ Y	1161-2
→ Y	or	conjunctive	σ	1161-2
σ	=	sequential	X	1161-2
The dependency set	of	constraint	X	1162-1
X	is	attribute	dep	1162-1
dep		sequential	X	1162-1
X	=	sequential	Y	1162-1
Y		sequential	⊆ U	1162-1
⊆ U		sequential	F	1162-1
F	⊢	sequential	X	1162-1
X	→	sequential	<B>	1162-1
<B>	is	attribute	it	1163-1
it	contains	action	U	1163-1
U	under	constraint	intersection	1163-1
U	and	conjunctive	intersection	1163-1
U	is closed	action	intersection	1163-1
intersection		sequential	union	1163-1
union	and	conjunctive	difference	1163-1
difference	see	action	Exercise 8.17	1163-1
<B>	In	constraint	addition	1163-2
addition		sequential	X+	1163-2
X+	where denotes	action	A ∈ U F	1163-2
A ∈ U F		sequential	⊢ X → A }	1163-2
i=1		sequential	i	1164-1
i	=	sequential	U	1164-1
U		sequential	2	1164-1
2		sequential	Wi	1164-1
Wi	=	sequential	∅	1164-1
∅	for	constraint	i	1164-1
i		sequential	∈	1164-1
∈		sequential	1	1164-1
1		sequential	n	1164-1
n		sequential	3 Wi	1164-1
One	proves	action	<B>	1164-2
<B>	Now construct	action	an instance	1165-1
an instance		sequential	I	1165-1
I		sequential	U	1165-1
U		sequential	that	1165-1
that	contains	action	all tuples	1165-1
all tuples	t satisfying	action	the following conditions	1165-1
<B>	for	constraint	all B ∈ Wi	1166-1
all B ∈ Wi	or	conjunctive	t	1166-1
t		sequential	B	1166-1
B	=	sequential	1	1166-1
1	for	constraint	all B ∈ Wi	1166-1
It	that	constraint	I	1167-1
It	can be shown	action	I	1167-1
I	|=	sequential	F	1167-1
F	but	conjunctive	I	1167-1
I	|=	sequential	σ	1167-1
σ	see	action	Exercise 8.17	1167-1
<B>	easily implies	attribute	the	1168-1
<B>	following	action	Exercise 8.18	1168-1
<B>	see	action	Exercise 8.18	1168-1
Exercise 8.18		sequential	Corollary 8.3.6	1168-1
The Chase This section	presents	action	the chase	1169-1
the chase		sequential	a remarkable tool	1169-1
a remarkable tool	for	constraint	reasoning	1169-1
reasoning	about	constraint	dependencies	1169-1
dependencies		sequential	that	1169-1
that	highlights	action	a strong connection	1169-1
a strong connection	between	constraint	dependencies	1169-1
dependencies	and	conjunctive	tableau queries	1169-1
The discussion here	in	constraint	terms	1169-2
The discussion here	is cast	action	terms	1169-2
terms	of	constraint	fd	1169-2
fd		sequential	s	1169-2
s	and	conjunctive	jd	1169-2
jd		sequential	s	1169-2
s	as	constraint	Chapter 10	1169-2
s	in	constraint	Chapter 10	1169-2
s	but	conjunctive	Chapter 10	1169-2
s	will be seen	action	Chapter 10	1169-2
Chapter 10		sequential	the chase	1169-2
the chase	to	constraint	a broader class	1169-2
the chase	generalizes naturally	action	a broader class	1169-2
a broader class	of	constraint	dependencies	1169-2
<B>	At	constraint	the end	1169-3
the end	of	constraint	this section	1169-3
this section		sequential	we	1169-3
we	explore	action	important applications	1169-3
important applications	of	constraint	the chase technique	1169-3
We	show	action	it	1169-4
it	to	constraint	logical implication	1169-4
it	how can also be used	action	logical implication	1169-4
it	determine	action	logical implication	1169-4
logical implication	between	constraint	sets	1169-4
sets	of	constraint	dependencies	1169-4
dependencies	to	constraint	conjunctive queries	1169-4
dependencies	and	conjunctive	conjunctive queries	1169-4
dependencies	optimize	action	conjunctive queries	1169-4
The following example	illustrates	action	an intriguing connection	1170-1
an intriguing connection	between	constraint	dependencies	1170-1
dependencies	and	conjunctive	tableau queries	1170-1
Example		sequential	8.4.1	1171-1
8.3		sequential	<B>	1171-2
<B>	Suppose	action	the query	1171-3
the query	to	constraint	only instances	1171-3
the query	is applied	action	only instances	1171-3
only instances		sequential	I	1171-3
I	satisfying	action	some set F	1171-3
some set F	of	constraint	fd	1171-3
fd	and	conjunctive	jd	1171-3
jd		sequential	<B>	1171-3
The chase	on	constraint	the following simple idea	1171-4
The chase	is based	action	the following simple idea	1171-4
<B>	If	constraint	ν	1171-5
ν	is	attribute	a valuation	1171-5
a valuation	embedding	action	T	1171-5
T	into	constraint	an instance	1171-5
an instance		sequential	I	1171-5
I	satisfying	action	F	1171-5
F		sequential	ν	1171-5
ν		sequential	T	1171-5
T	must satisfy	action	F. Valuations	1171-5
F. Valuations		sequential	that	1171-5
that	do not satisfy	action	F	1171-5
F	of	constraint	therefore no use	1171-5
F	are	attribute	therefore no use	1171-5
The chase	is	attribute	a procedure	1172-1
a procedure		sequential	that	1172-1
that	eliminates	action	the useless valuations	1172-1
the useless valuations	by	constraint	T itself	1172-1
the useless valuations	changing	action	T itself	1172-1
T itself		sequential	t	1172-1
t	so that	constraint	T	1172-1
T	as	constraint	an instance	1172-1
T	viewed	action	an instance	1172-1
an instance	satisfies	action	F	1172-1
<B>	Let	action	us	1173-1
us	to	constraint	the example	1173-1
us	return	action	the example	1173-1
<B>	that	constraint	F	1173-2
<B>	Suppose first	action	F	1173-2
F		sequential	B }	1173-2
B }	→	sequential	D	1173-2
<B>	Suppose	action	T	1173-3
T		sequential	t	1173-3
t	to	constraint	an instance	1173-3
t	is applied	action	an instance	1173-3
an instance		sequential	I	1173-3
I		sequential	F	1173-3
<B>	in	constraint	this context	1173-4
this context		sequential	one	1173-4
one	Thus might as well replace	action	T	1173-4
T	by	constraint	the tableau	1173-4
the tableau		sequential	z	1173-4
z	where =	sequential	z′	1173-4
This transformation	is called	action	the fd B	1173-5
This transformation	applying	action	the fd B	1173-5
the fd B		sequential	D	1173-5
D	to	constraint	T	1173-5
T		sequential	t	1173-5
It	to	constraint	the resulting tableau query	1173-6
It	that	constraint	the resulting tableau query	1173-6
It	is	attribute	easy	1173-6
It	see	action	the resulting tableau query	1173-6
the resulting tableau query	in	constraint	fact	1173-6
the resulting tableau query	is	attribute	fact	1173-6
fact	to	constraint	the identity	1173-6
the identity	because	constraint	T	1173-6
T	contains	action	an entire row	1173-6
an entire row	of	constraint	distinguished variables	1173-6
<B>	Consider	action	next an example	1174-1
next an example	both	conjunctive	fd	1174-1
next an example	involving	action	fd	1174-1
fd		sequential	s	1174-1
s	and	conjunctive	jd	1174-1
jd		sequential	s	1174-1
<B>	Let	action	F	1174-2
F	of	constraint	the following two dependencies	1174-2
F	consist	action	the following two dependencies	1174-2
the following two dependencies	over	constraint	ABCD	1174-2
ABCD		sequential	the jd ⊲⊳	1174-2
the jd ⊲⊳		sequential	AB	1174-2
AB		sequential	BCD	1174-2
BCD	and	conjunctive	the fd	1174-2
the fd		sequential	A C	1174-2
A C	→	sequential	<B>	1174-2
<B>	Let	action	I	1175-1
I	be	attribute	an instance	1175-1
an instance	over	constraint	ABCD	1175-1
ABCD	satisfying	action	the two dependencies	1175-1
We	first explain	action	T	1175-2
T		sequential	t	1175-2
t		sequential	I	1175-2
I	why =	sequential	T ′	1175-2
T ′		sequential	t	1175-2
t		sequential	I	1175-2
I	for	constraint	the tableau query	1175-2
the tableau query		sequential	T ′	1175-2
T ′		sequential	t	1175-2
t	of	constraint	Fig	1175-2
8.3		sequential	<B>	1175-3
It	that	constraint	T ′	1175-4
It	is	attribute	clear	1175-4
T ′		sequential	t	1175-4
t		sequential	I	1175-4
I		sequential	⊆	1175-4
⊆		sequential	T	1175-4
T		sequential	t	1175-4
t		sequential	I	1175-4
I	because	constraint	T	1175-4
T	is	attribute	a superset	1175-4
a superset	of	constraint	T	1175-4
<B>	For	constraint	the opposite inclusion	1175-5
the opposite inclusion	that	constraint	ν	1175-5
the opposite inclusion	suppose	action	ν	1175-5
ν	is	attribute	a valuation	1175-5
a valuation	for	constraint	T	1175-5
T	with	constraint	ν ⊆ I	1175-5
ν ⊆ I		sequential	T	1175-5
<B>	in	constraint	both ν	1175-6
both ν		sequential	x	1175-6
x		sequential	y	1175-6
y	and	conjunctive	ν	1175-6
ν		sequential	x	1175-6
x		sequential	z	1175-6
z	in	constraint	I	1175-6
z	are	attribute	I	1175-6
<B>	Because	constraint	I	1175-7
I		sequential	AB	1175-7
AB		sequential	BCD	1175-7
BCD		sequential	it	1175-7
it	that	constraint	ν I	1175-7
it	follows	action	ν I	1175-7
ν I	w	constraint	x	1175-7
x		sequential	y′	1175-7
y′		sequential	z	1175-7
z		sequential	∈	1175-7
Thus ν		sequential	T	1176-1
T		sequential	′	1176-1
The transformation	from	constraint	T	1176-2
T		sequential	t	1176-2
t	to	constraint	T ′	1176-2
T ′		sequential	t	1176-2
t	and	conjunctive	Dependency B C D B	1176-2
t	is termed	attribute	Functional	1176-2
t	Join	action	Dependency B C D B	1176-2
Dependency B C D B		sequential	C D B C D	1176-2
C D B C D		sequential	T	1176-2
T	w	constraint	x	1176-2
The tableau T ′′	of	constraint	Fig	1177-1
8.3		sequential	c	1177-2
c	is	attribute	the result	1177-2
the result	of	constraint	chasing	1177-2
chasing		sequential	T	1177-2
T	′	sequential	t	1177-2
t	with	constraint	the fd A	1177-2
the fd A	→	sequential	C	1177-2
C	replacing	action	all occurrences	1177-2
all occurrences	of	constraint	y′	1177-2
y′	by	constraint	y	1177-2
We	that	constraint	T ′	1177-3
We	now argue	action	T ′	1177-3
T ′		sequential	t	1177-3
t		sequential	I	1177-3
I	=	sequential	T ′′	1177-3
T ′′		sequential	t	1177-3
t		sequential	I	1177-3
<B>	by	constraint	Theorem	1177-4
Theorem		sequential	6.2.3	1177-4
6.2.3		sequential	T ′	1177-4
T ′		sequential	t	1177-4
t		sequential	I	1177-4
I		sequential	T ′′	1177-4
T ′′		sequential	t	1177-4
t		sequential	I	1177-4
I	because	constraint	there	1177-4
there	is	attribute	a homomorphism	1177-4
a homomorphism	from	constraint	T ′	1177-4
T ′		sequential	t	1177-4
t	to	constraint	T ′′	1177-4
T ′′		sequential	t	1177-4
<B>	For	constraint	the opposite inclusion	1177-5
the opposite inclusion	that	constraint	ν ⊆ I	1177-5
the opposite inclusion	suppose now	action	ν ⊆ I	1177-5
ν ⊆ I		sequential	T ′	1177-5
<B>	that	constraint	ν	1177-6
<B>	implies	action	ν	1177-6
ν	embeds	action	the first tuple	1177-6
the first tuple	of	constraint	T ′′	1177-6
T ′′	into	constraint	I	1177-6
<B>	In	constraint	addition	1177-7
addition	because	constraint	ν	1177-7
ν		sequential	x	1177-7
x		sequential	y	1177-7
y		sequential	z′	1177-7
z′	and	conjunctive	ν	1177-7
ν		sequential	x	1177-7
x		sequential	y′	1177-7
y′		sequential	z	1177-7
z	in	constraint	I	1177-7
z	are	attribute	I	1177-7
I	and	conjunctive	I	1177-7
I	|=	sequential	A C	1177-7
I	→	sequential	A C	1177-7
A C		sequential	it	1177-7
it	follows	action	that ν	1177-7
that ν		sequential	y	1177-7
y	=	sequential	ν	1177-7
ν		sequential	y′	1177-7
Thus ν		sequential	w′	1177-8
w′		sequential	x	1177-8
x		sequential	y	1177-8
y		sequential	z	1177-8
z	=	sequential	ν	1177-8
ν		sequential	w′	1177-8
w′		sequential	x	1177-8
x		sequential	y′	1177-8
y′		sequential	z	1177-8
z		sequential	∈	1177-8
∈		sequential	I	1177-8
I	and	conjunctive	ν	1177-8
ν		sequential	x	1177-8
x		sequential	y	1177-8
y		sequential	z	1177-8
z	=	sequential	ν	1177-8
ν		sequential	x	1177-8
x		sequential	z	1177-8
z		sequential	∈	1177-8
∈		sequential	I	1177-8
I		sequential	ν	1177-8
ν	and	conjunctive	the tuples	1177-8
ν	embeds	attribute	second	1177-8
the tuples	of	constraint	T ′′	1177-8
T ′′	into	constraint	I	1177-8
I		sequential	ν	1177-8
ν		sequential	T	1177-8
T	′′	sequential	⊆	1177-8
⊆		sequential	I	1177-8
<B>	that	constraint	T ′′	1177-9
<B>	Note	action	T ′′	1177-9
T ′′		sequential	t	1177-9
t	is	attribute	the result	1177-9
the result	of	constraint	a pair	1177-9
the result	identifying	action	a pair	1177-9
a pair	of	constraint	variables	1177-9
variables		sequential	that	1177-9
that	caused	action	a violation	1177-9
a violation	of	constraint	A	1177-9
A	→	sequential	C	1177-9
C	in	constraint	T ′	1177-9
We	that	constraint	repeated applications	1177-10
We	by	constraint	repeated applications	1177-10
We	will see	action	repeated applications	1177-10
repeated applications	of	constraint	an fd	1177-10
an fd		sequential	one	1177-10
one	can eventually force	action	a tableau	1177-10
a tableau	to	constraint	the fd	1177-10
a tableau	satisfy	action	the fd	1177-10
<B>	that	constraint	this case	1177-11
<B>	in	constraint	this case	1177-11
<B>	Note	action	this case	1177-11
this case	with	constraint	respect A	1177-11
this case	chasing	action	respect A	1177-11
respect A	to	constraint	C	1177-11
respect A	→	constraint	C	1177-11
C	has	action	no effect	1177-11
no effect	before	constraint	respect	1177-11
no effect	with	constraint	respect	1177-11
no effect	chasing	action	respect	1177-11
<B>	that	constraint	the Homomorphism	1178-1
<B>	by	constraint	the Homomorphism	1178-1
<B>	Finally note	action	the Homomorphism	1178-1
the Homomorphism		sequential	Theorem 6.2.3	1178-1
Theorem 6.2.3	of	constraint	Chapter 6	1178-1
Chapter 6		sequential	T ′′	1178-1
T ′′		sequential	t	1178-1
<B>	Defining	action	the Chase	1179-1
the Chase	sat	action	F	1179-1
F	=	sequential	I	1179-1
I	over	constraint	R	1179-1
R		sequential	I	1179-1
I	|=	sequential	F }	1179-1
Query q1	in	constraint	q2	1180-1
Query q1	is contained	action	q2	1180-1
q2	to	constraint	F	1180-1
F	denoted	action	q1 ⊆F q2	1180-1
q1 ⊆F q2	if	constraint	q1	1180-1
q1		sequential	⊆	1180-1
⊆	sat	action	F	1180-1
F		sequential	q2	1180-1
Equivalence	to	constraint	a family	1180-2
a family	of	constraint	instances	1180-2
instances	to	constraint	a set	1180-2
instances	and	conjunctive	a set	1180-2
instances	≡ F	sequential	a set	1180-2
a set	of	constraint	dependencies	1180-2
dependencies	≡ F	sequential	<B>	1180-2
dependencies	are defined similarly	action	<B>	1180-2
The chase	is	attribute	a general technique	1181-1
a general technique		sequential	that	1181-1
that	can be used	action	a set	1181-1
that	given	action	a set	1181-1
a set	of	constraint	dependencies F	1181-1
dependencies F	to	constraint	a tableau query q	1181-1
dependencies F	transform	action	a tableau query q	1181-1
a tableau query q	into	constraint	a query	1181-1
a query	q′	constraint	that q ≡F q′	1181-1
The chase	as	constraint	a nondeterministic procedure	1181-2
The chase	is defined	action	a nondeterministic procedure	1181-2
a nondeterministic procedure	on	constraint	the successive application	1181-2
a nondeterministic procedure	based	action	the successive application	1181-2
the successive application	of	constraint	individual dependencies	1181-2
individual dependencies	from	constraint	F	1181-2
F	as	constraint	this process	1181-2
F	but	conjunctive	this process	1181-2
F	will be seen	action	this process	1181-2
this process	is	attribute	Church Rosser	1181-2
Church Rosser	in	constraint	the sense	1181-2
the sense	that	constraint	the procedure	1181-2
the procedure	with	constraint	a unique end result	1181-2
the procedure	necessarily terminates	action	a unique end result	1181-2
<B>	As	constraint	a final step	1181-3
a final step	in	constraint	this development	1181-3
this development		sequential	the chase	1181-3
the chase	to	constraint	equivalence	1181-3
the chase	will be used	action	equivalence	1181-3
the chase	characterize	action	equivalence	1181-3
equivalence	of	constraint	conjunctive queries	1181-3
conjunctive queries	with	constraint	respect	1181-3
respect	to	constraint	a set F	1181-3
a set F	of	constraint	dependencies	1181-3
dependencies	≡	sequential	F	1181-3
<B>	In	constraint	we	1182-1
<B>	following	action	we	1182-1
we	let	action	R	1182-1
R	be	attribute	a fixed relation schema	1182-1
a fixed relation schema	and	conjunctive	we	1182-1
we	on	constraint	sets	1182-1
we	focus	action	sets	1182-1
sets		sequential	F	1182-1
F	of	constraint	fd	1182-1
fd	and	conjunctive	jd	1182-1
jd	over	constraint	R	1182-1
R	and	conjunctive	tableau	1182-1
tableau		sequential	queries	1182-1
queries	with	constraint	no constants	1182-1
no constants	over	constraint	R	1182-1
<B>	For	constraint	technical convenience	1183-1
technical convenience		sequential	we	1183-1
we	that	constraint	there	1183-1
we	assume	action	there	1183-1
there	is	attribute	a total order ≤	1183-1
a total order ≤	on	constraint	the set var	1183-1
<B>	Let	action	R	1183-2
R	be	attribute	a fixed relation schema	1183-2
a fixed relation schema	that	constraint	T	1183-2
a fixed relation schema	and	conjunctive	T	1183-2
a fixed relation schema	suppose	action	T	1183-2
T		sequential	t	1183-2
t	is	attribute	a tableau query	1183-2
a tableau query	over	constraint	R	1183-2
<B>	x	constraint	the lesser variable	1183-3
<B>	be	attribute	the lesser variable	1183-3
<B>	Let	action	the lesser variable	1183-3
the lesser variable	in	constraint	u	1183-3
u		sequential	v	1183-3
v		sequential	A }	1183-3
A }	under	constraint	the ordering ≤	1183-3
the ordering ≤	and	conjunctive	y	1183-3
the ordering ≤	let	action	y	1183-3
y	be	attribute	the other one	1183-3
the other one		sequential	x	1183-3
x		sequential	y	1183-3
y	}	sequential	u	1183-3
y	=	sequential	u	1183-3
y	{	sequential	u	1183-3
u		sequential	A	1183-3
A		sequential	v	1183-3
v		sequential	A }	1183-3
A }	and	conjunctive	x	1183-3
x		sequential	y	1183-3
The result	of	constraint	the fd σ	1183-4
The result	applying	action	the fd σ	1183-4
the fd σ	to	constraint	u	1183-4
u		sequential	v	1183-4
v	in	constraint	T	1183-4
T		sequential	t	1183-4
t	is	attribute	the tableau query	1183-4
the tableau query		sequential	θ	1183-4
θ		sequential	T	1183-4
T		sequential	θ	1183-4
θ		sequential	t	1183-4
t		sequential	θ	1183-4
θ	is	attribute	where the substitution	1183-4
where the substitution		sequential	that	1183-4
that	maps	action	y	1183-4
y	to	constraint	x	1183-4
x	and	conjunctive	the identity elsewhere	1183-4
x	is	attribute	the identity elsewhere	1183-4
jd rule	Let	action	σ	1184-1
σ	=⊲⊳	sequential	X1	1184-1
<B>	.	sequential	<B>	1184-2
<B>	.	sequential	<B>	1184-3
Xn	be	attribute	a jd	1184-4
a jd	over	constraint	R	1184-4
R	let	action	u	1184-4
u	be	attribute	a free tuple	1184-4
a free tuple	over	constraint	R	1184-4
R	in	constraint	not T	1184-4
not T	that	constraint	u1	1184-4
not T	and	conjunctive	u1	1184-4
not T	suppose	action	u1	1184-4
<B>	.	sequential	<B>	1184-5
<B>	.	sequential	<B>	1184-6
un ∈		sequential	T satisfy πX	1184-7
T satisfy πX		sequential	u	1184-7
u		sequential	i	1184-7
i		sequential	i	1184-7
i		sequential	π Xi	1184-7
<B>	Following	action	the lead	1185-1
the lead	of	constraint	Example 8.4.1	1185-1
Example 8.4.1	is easily verified	action	Exercise 8.24a	1185-1
Example 8.4.1	see	action	Exercise 8.24a	1185-1
Proposition		sequential	8.4.2	1186-1
<B>	that	constraint	i	1187-1
<B>	for	constraint	i	1187-1
The sequence	if	constraint	it	1187-2
The sequence	is	attribute	terminal	1187-2
it	and	conjunctive	no dependency	1187-2
it	is	attribute	finite	1187-2
no dependency	in	constraint	F	1187-2
F	to	constraint	it	1187-2
F	can be applied	action	it	1187-2
The last element	of	constraint	the terminal sequence	1187-3
the terminal sequence	is called	action	its result	1187-3
The notion	of	constraint	satisfaction	1187-4
satisfaction	of	constraint	a dependency	1187-4
a dependency	to	constraint	tableaux	1187-4
a dependency	is extended naturally	action	tableaux	1187-4
<B>	is	attribute	an important property	1187-5
an important property	of	constraint	terminal chasing sequences	1187-5
terminal chasing sequences		sequential	Exercise	1187-5
Exercise		sequential	8.24 b	1187-5
Lemma		sequential	8.4.3	1188-1
T	as	constraint	an instance	1189-1
T	considered	action	an instance	1189-1
an instance	Then satisfies	action	F	1189-1
<B>	and	conjunctive	Dependency	1190-1
<B>	Join	action	Dependency	1190-1
<B>	is easily verified	action	Exercise 8.24	1190-2
Exercise 8.24		sequential	c	1190-2
c		sequential	Lemma	1190-2
Lemma		sequential	8.4.4	1190-2
each chasing sequence	of	constraint	T	1191-1
T		sequential	t	1191-1
t	by	constraint	F	1191-1
F	and	conjunctive	the initial subsequence	1191-1
F	is	attribute	Then finite	1191-1
F	is	attribute	the initial subsequence	1191-1
the initial subsequence	of	constraint	a terminal chasing sequence	1191-1
<B>	Because	constraint	Church Rosser	1192-1
Church Rosser		sequential	the property	1192-1
the property	holds	action	we	1192-1
we	without	constraint	ambiguity	1192-1
we	can define	action	ambiguity	1192-1
ambiguity		sequential	the result	1192-1
the result	of	constraint	a tableau query	1192-1
the result	chasing	action	a tableau query	1192-1
a tableau query	by	constraint	a set	1192-1
a set	of	constraint	fd	1192-1
fd		sequential	s	1192-1
s	and	conjunctive	jd	1192-1
jd		sequential	<B>	1192-1
Definition		sequential	8.4.5	1193-1
<B>	From	constraint	the previous discussion	1194-1
the previous discussion		sequential	chase	1194-1
chase		sequential	T	1194-1
T		sequential	t	1194-1
t		sequential	F	1194-1
F	as	constraint	<B>	1194-1
F	can be computed	action	<B>	1194-1
F	follows	action	<B>	1194-1
The dependencies	in	constraint	some arbitrary order	1194-2
The dependencies	are picked	action	some arbitrary order	1194-2
some arbitrary order	to	constraint	the tableau	1194-2
some arbitrary order	and	conjunctive	the tableau	1194-2
some arbitrary order	arbitrarily applied	action	the tableau	1194-2
<B>	Applying	action	an fd	1194-3
an fd	to	constraint	a tableau query q	1194-3
a tableau query q	within	constraint	time polynomial	1194-3
a tableau query q	can be performed	action	time polynomial	1194-3
time polynomial	in	constraint	the size	1194-3
the size	of	constraint	q	1194-3
<B>	whether	constraint	a jd	1194-4
<B>	determining	action	a jd	1194-4
a jd	to	constraint	q	1194-4
a jd	can be applied	action	q	1194-4
q	is	attribute	np	1194-4
np	in	constraint	the size	1194-4
the size	of	constraint	q	1194-4
<B>	best known	action	the algorithm	1194-5
the algorithm	for	constraint	the chase	1194-5
the algorithm	computing	action	the chase	1194-5
the chase	is	attribute	Thus exponential	1194-5
the chase	see	action	Exercise 8.25	1194-5
the complexity	if	constraint	the schema	1194-6
the complexity	is	attribute	However polynomial	1194-6
the schema	is considered	action	<B>	1194-6
the schema	fixed	action	<B>	1194-6
<B>	Until	constraint	the informal discussion	1195-1
<B>	besides	constraint	the informal discussion	1195-1
the informal discussion	in	constraint	Section 8.1	1195-1
Section 8.1		sequential	the chase	1195-1
the chase	remains	action	a purely syntactic technique	1195-1
We	next state	action	a result	1195-2
a result		sequential	that	1195-2
that	that	constraint	the chase	1195-2
that	shows	action	the chase	1195-2
the chase	in	constraint	fact	1195-2
fact	by	constraint	the semantics	1195-2
fact	is determined	action	the semantics	1195-2
the semantics	of	constraint	the dependencies	1195-2
the dependencies	in	constraint	F	1195-2
F	and	conjunctive	not just their syntax	1195-2
<B>	In	constraint	the following proposition	1196-1
the following proposition	that	constraint	definition	1196-1
the following proposition	by	constraint	definition	1196-1
the following proposition	recall	action	definition	1196-1
definition		sequential	F ≡ F′	1196-1
F ≡ F′	if	constraint	F	1196-1
F		sequential	F′	1196-1
F′	and	conjunctive	F′	1196-1
F′	|= F	sequential	<B>	1196-1
Proposition		sequential	8.4.6	1197-1
We	next consider	action	several important uses	1198-1
several important uses	of	constraint	the chase	1198-1
the chase		sequential	that	1198-1
that	illustrate	action	the power	1198-1
the power	of	constraint	this technique	1198-1
Query Equivalence		sequential	Query Equivalence	1199-1
<B>	for	constraint	example	1199-2
<B>	allows	action	example	1199-2
example	whether	constraint	a tableau query	1199-2
example	checking	action	a tableau query	1199-2
a tableau query	by	constraint	a simpler tableau query	1199-2
a tableau query	can be replaced	action	a simpler tableau query	1199-2
a simpler tableau query		sequential	the dependencies	1199-2
the dependencies	are	attribute	when satisfied	1199-2
<B>	that	constraint	T	1199-3
<B>	Suppose now	action	T	1199-3
T		sequential	t′	1199-3
t′	and	conjunctive	T ′′	1199-3
T ′′		sequential	t′′	1199-3
t′′	are	attribute	two tableau queries	1199-3
two tableau queries	and	conjunctive	F	1199-3
F		sequential	a set such that	1199-3
a set such that	of	constraint	fd	1199-3
fd		sequential	s	1199-3
s	and	conjunctive	jd	1199-3
jd		sequential	T	1199-3
T		sequential	t	1199-3
t		sequential	′	1199-3
′		sequential	≡F	1199-3
≡F		sequential	T ′′	1199-3
T ′′		sequential	t′′	1199-3
<B>	From	constraint	the preceding development	1199-4
the preceding development		sequential	Proposition	1199-4
Proposition		sequential	8.4.2	1199-4
8.4.2		sequential	it	1199-4
it	follows	action	that chase	1199-4
that chase		sequential	T ′	1199-4
T ′		sequential	t′	1199-4
t′		sequential	F	1199-4
F		sequential	≡F	1199-4
≡F		sequential	T	1199-4
T		sequential	′	1199-4
′		sequential	t′	1199-4
t′		sequential	≡F	1199-4
≡F		sequential	T ′′	1199-4
T ′′		sequential	t′′	1199-4
t′′		sequential	F chase	1199-4
F chase		sequential	T ′′	1199-4
T ′′		sequential	t′′	1199-4
t′′		sequential	F	1199-4
We	that	constraint	fact	1200-1
We	in	constraint	fact	1200-1
We	now show	action	fact	1200-1
fact	chase	action	T	1200-1
T		sequential	F	1200-1
F		sequential	chase	1200-1
chase		sequential	T ′′	1200-1
T ′′		sequential	t′′	1200-1
t′′		sequential	F	1200-1
this condition	is	attribute	Furthermore sufficient	1200-2
<B>	To	constraint	this result	1201-1
<B>	demonstrate	action	this result	1201-1
this result		sequential	we	1201-1
we	first establish	action	the following more general fact	1201-1
Theorem		sequential	8.4.7	1202-1
Proof		sequential	Proof	1203-1
<B>	For	constraint	the only direction	1203-2
<B>	if	constraint	the only direction	1203-2
the only direction	that	constraint	T1	1203-2
the only direction	suppose	action	T1	1203-2
T1		sequential	t1	1203-2
t1		sequential	⊆F t	1203-2
⊆F t		sequential	∈	1203-2
It	that	constraint	there	1204-1
It	follows	action	there	1204-1
there	is	attribute	homomorphism	1204-1
homomorphism		sequential	a h	1204-1
a h	that	constraint	h	1204-1
h		sequential	T	1204-1
T		sequential	′	1204-1
′		sequential	⊆ T	1204-1
⊆ T	and	conjunctive	h	1204-1
h		sequential	t′	1204-1
t′	=	sequential	t′	1204-1
Thus 2		sequential	Thus 2	1204-2
<B>	with	constraint	Lemma	1205-1
Lemma		sequential	8.4.3	1205-1
8.4.3	Together implies Then	attribute	the	1205-1
following Theorem		sequential	8.4.8 Let	1205-1
8.4.8 Let		sequential	T1	1205-1
T1		sequential	t1	1205-1
t1	and	conjunctive	T2	1205-1
T2	be	attribute	tableau queries	1205-1
tableau queries	over	constraint	R	1205-1
R	and	conjunctive	F	1205-1
F		sequential	a set	1205-1
a set	of	constraint	fd	1205-1
fd		sequential	s	1205-1
s	and	conjunctive	jd	1205-1
jd	over	constraint	R	1205-1
Query Optimization		sequential	Query Optimization	1206-1
We	by	constraint	the effect	1207-1
We	at	constraint	the effect	1207-1
We	start	action	the effect	1207-1
We	looking	action	the effect	1207-1
the effect	on	constraint	tableau minimization	1207-1
tableau minimization	of	constraint	the chase	1207-1
the chase	using	action	fd	1207-1
fd		sequential	<B>	1207-1
<B>	In	constraint	we	1208-1
<B>	following	action	we	1208-1
we	by	constraint	min	1208-1
we	denote	action	min	1208-1
min		sequential	T	1208-1
T		sequential	t	1208-1
t		sequential	the tableau	1208-1
the tableau	from	constraint	the minimization	1208-1
the tableau	resulting	action	the minimization	1208-1
the minimization	of	constraint	3	1208-1
<B>	and	conjunctive	Dependency	1209-1
<B>	Join	action	Dependency	1209-1
Dependency		sequential	the tableau	1209-1
the tableau		sequential	T	1209-1
T		sequential	t	1209-1
t	using	action	the Homomorphism Theorem 6.2.3	1209-1
the Homomorphism Theorem 6.2.3	for	constraint	tableau queries	1209-1
tableau queries	by	constraint	<B>	1209-1
tableau queries	and	conjunctive	<B>	1209-1
Lemma		sequential	8.4.9	1210-1
Then min		sequential	chase	1210-2
chase		sequential	T	1210-2
T		sequential	t	1210-2
t		sequential	F	1210-2
F		sequential	min	1210-2
min		sequential	T	1210-2
T		sequential	t	1210-2
Crux		sequential	Crux	1211-1
it	to	constraint	each tableau query	1211-2
it	that	constraint	each tableau query	1211-2
it	for	constraint	each tableau query	1211-2
it	is	attribute	Clearly sufficient	1211-2
it	show	action	each tableau query	1211-2
each tableau query		sequential	T ′	1211-2
T ′		sequential	t ′	1211-2
t ′	and	conjunctive	σ ∈ F	1211-2
σ ∈ F		sequential	min	1211-2
min		sequential	chase	1211-2
chase		sequential	T ′	1211-2
T ′		sequential	t′	1211-2
t′		sequential	σ	1211-2
σ		sequential	min	1211-2
min		sequential	T ′	1211-2
T ′		sequential	t′	1211-2
We	without	constraint	loss	1211-3
We	can assume	action	loss	1211-3
loss	of	constraint	generality	1211-3
generality		sequential	that	1211-3
that		sequential	σ	1211-3
σ	of	constraint	the form	1211-3
σ	is	attribute	the form	1211-3
the form		sequential	X	1211-3
X	→	sequential	A	1211-3
A		sequential	A	1211-3
A	is	attribute	where a single attribute	1211-3
<B>	Let	action	T ′′	1212-1
T ′′		sequential	t′′	1212-1
t′′	=	sequential	chase	1212-1
chase		sequential	T ′	1212-1
T ′		sequential	t′	1212-1
t′		sequential	X	1212-1
X	→	sequential	A	1212-1
A		sequential	}	1212-1
}	and	conjunctive	θ	1212-1
}	let	action	θ	1212-1
θ	be	attribute	the chase homomorphism	1212-1
the chase homomorphism	of	constraint	a chasing sequence	1212-1
a chasing sequence	for	constraint	chase	1212-1
chase		sequential	T	1212-1
T		sequential	t′	1212-1
t′		sequential	X	1212-1
X		sequential	→ A	1212-1
→ A		sequential	}	1212-1
}		sequential	the homomorphism	1212-1
the homomorphism	by	constraint	the substitutions	1212-1
the homomorphism	obtained	action	the substitutions	1212-1
the homomorphism	composing	action	the substitutions	1212-1
the substitutions	in	constraint	that chasing sequence	1212-1
the substitutions	used	action	that chasing sequence	1212-1
that chasing sequence	see	action	the proof	1212-1
the proof	of	constraint	Theorem	1212-1
Theorem		sequential	8.4.18	1212-1
We	will use here	action	Church	1213-1
Church		sequential	Rosser	1213-1
Rosser		sequential	the property	1213-1
the property	of	constraint	the chase	1213-1
the chase		sequential	Theorem	1213-1
Theorem		sequential	8.4.18	1213-1
8.4.18		sequential	a related property stating	1213-1
a related property stating	that	constraint	the homomorphism θ	1213-1
the homomorphism θ	like	constraint	the result	1213-1
the result	for	constraint	all chase sequences	1213-1
the result	is	attribute	also the same	1213-1
all chase sequences	from	constraint	the proof	1213-1
all chase sequences	follows	action	the proof	1213-1
the proof	of	constraint	Theorem 8.4.18	1213-1
<B>	By	constraint	Theorem 6.2.6	1214-1
Theorem 6.2.6		sequential	there	1214-1
there	is	attribute	some S ⊆ T	1214-1
some S ⊆ T		sequential	S	1214-1
S		sequential	t′	1214-1
t′	is	attribute	a minimal tableau query	1214-1
a minimal tableau query	to	constraint	T ′	1214-1
T ′		sequential	t′	1214-1
t′		sequential	we	1214-1
we	as	constraint	the representative	1214-1
we	shall use	attribute	this	1214-1
the representative	of	constraint	min	1214-1
min		sequential	T ′	1214-1
T ′		sequential	t′	1214-1
<B>	Let	action	h	1214-2
h	be	attribute	a homomorphism	1214-2
a homomorphism		sequential	h	1214-2
h		sequential	T ′	1214-2
T ′		sequential	t′	1214-2
t′	=	sequential	S	1214-2
S		sequential	t′	1214-2
<B>	Consider	action	the mapping f	1214-3
the mapping f	on	constraint	T ′′	1214-3
T ′′		sequential	t′′	1214-3
t′′	by	constraint	f	1214-3
t′′	defined	action	f	1214-3
f		sequential	θ	1214-3
θ		sequential	x	1214-3
x	=	sequential	θ	1214-3
θ		sequential	h	1214-3
h		sequential	x	1214-3
x		sequential	x	1214-3
x	in	constraint	T	1214-3
x	is	attribute	where a variable	1214-3
T		sequential	′	1214-3
′		sequential	t′	1214-3
<B>	If	constraint	we	1214-4
we	that	constraint	f	1214-4
we	show	action	f	1214-4
f	is well defined	action	we	1214-4
we	are	attribute	done	1214-4
<B>	If	constraint	f	1214-5
f	is well defined	action	f	1214-5
f	is	attribute	a homomorphism	1214-5
a homomorphism	from	constraint	T ′′	1214-5
T ′′		sequential	t′′	1214-5
t′′	to	constraint	θ	1214-5
θ		sequential	S	1214-5
S		sequential	t′	1214-5
We	to	constraint	θ	1214-6
We	that	constraint	θ	1214-6
We	have	action	θ	1214-6
We	show	action	θ	1214-6
θ		sequential	h	1214-6
h		sequential	x	1214-6
<B>	Let	action	h	1215-1
h		sequential	ui	1215-1
ui		sequential	h	1215-1
h		sequential	v	1215-1
<B>	.	sequential	<B>	1215-2
<B>	.	sequential	<B>	1215-3
h		sequential	u	1215-4
u		sequential	h	1215-4
h		sequential	v	1215-4
v	be	attribute	the subsequence	1215-4
the subsequence	of	constraint	these pairs	1215-4
these pairs	for	constraint	which X → i1 ik ik i1 ik ik morphism θ	1215-4
which X → i1 ik ik i1 ik ik morphism θ		sequential	′	1215-4
<B>	that	constraint	all x′	1215-5
<B>	for	constraint	all x′	1215-5
<B>	Note	action	all x′	1215-5
all x′	if	constraint	θ	1215-5
θ		sequential	x′	1215-5
x′	=	sequential	θ	1215-5
θ		sequential	y′	1215-5
y′		sequential	θ	1215-5
θ		sequential	h	1215-5
h		sequential	x′	1215-5
x′	=	sequential	θ ′	1215-5
θ ′		sequential	h	1215-5
h		sequential	y′	1215-5
<B>	In	constraint	θ	1215-6
θ		sequential	′	1215-6
′		sequential	h	1215-6
h		sequential	x	1215-6
x	=	sequential	θ ′	1215-6
θ ′		sequential	h	1215-6
h		sequential	y	1215-6
<B>	Because	constraint	h	1215-7
h		sequential	T ′	1215-7
<B>	.	sequential	<B>	1215-8
<B>	.	sequential	<B>	1215-9
σk	of	constraint	T ′	1215-10
T ′		sequential	t′	1215-10
<B>	Let	action	θ′′	1215-11
θ′′	be	attribute	the chase homomorphism	1215-11
the chase homomorphism	from	constraint	a terminal chasing sequence	1215-11
the chase homomorphism	formed	action	a terminal chasing sequence	1215-11
a terminal chasing sequence		sequential	that	1215-11
that	extends	action	σ 1	1215-11
<B>	.	sequential	<B>	1215-12
<B>	.	sequential	<B>	1215-13
<B>		sequential	<B>	1215-14
<B>		sequential	h	1215-15
h		sequential	x	1215-15
x	Then =	sequential	θ′′	1215-15
θ′′		sequential	h	1215-15
h		sequential	y	1215-15
<B>	by	constraint	the uniqueness	1215-16
the uniqueness	of	constraint	the chase homomorphism	1215-16
the chase homomorphism		sequential	θ	1215-16
θ		sequential	′′	1215-16
′′	=	sequential	θ	1215-16
θ	and	conjunctive	θ	1215-16
θ		sequential	h	1215-16
h		sequential	x	1215-16
x	so =	sequential	θ	1215-16
θ		sequential	h	1215-16
h		sequential	y	1215-16
y	as	constraint	<B>	1215-16
y	desired	action	<B>	1215-16
<B>	concludes	action	the proof	1215-17
It	that	constraint	jd	1216-1
It	turns out	action	jd	1216-1
jd	than	constraint	fd	1216-1
jd	behave differently	action	fd	1216-1
fd	with	constraint	respect	1216-1
respect	to	constraint	minimization	1216-1
minimization	of	constraint	tableaux	1216-1
<B>	that	constraint	the chase	1216-2
<B>	shows	action	the chase	1216-2
the chase	using	action	jd	1216-2
jd	but	conjunctive	tableaux	1216-2
jd	may yield	attribute	simpler	1216-2
B C D B C D B C D T w x y′ T′		sequential	w	1217-1
w		sequential	x	1217-1
8.4	and	conjunctive	the jd	1217-2
the jd		sequential	σ	1217-2
σ	=⊲	sequential	<B>	1217-2
σ	⊳	sequential	<B>	1217-2
<B>	Next let	action	T	1218-1
T	′	sequential	the tableau query	1218-1
T	be	attribute	the tableau query	1218-1
the tableau query	in	constraint	Fig	1218-1
8.4	and	conjunctive	σ	1218-2
σ	=⊲⊳	sequential	AB	1218-2
AB		sequential	CD	1218-2
T ′		sequential	t′	1218-3
t′	is	attribute	Again minimal	1218-3
chase		sequential	T	1218-4
T		sequential	t′	1218-4
t′		sequential	σ	1218-4
σ	in	constraint	Fig	1218-4
σ	Now is represented	action	Fig	1218-4
8.4		sequential	c	1218-5
c	and	conjunctive	<B>	1218-5
c	is	attribute	minimal	1218-5
<B>		sequential	<B>	1218-6
<B>	Despite	constraint	the limitations	1219-1
the limitations	by	constraint	the preceding example	1219-1
the limitations	illustrated	action	the preceding example	1219-1
the preceding example		sequential	the chase	1219-1
the chase	in	constraint	conjunction	1219-1
conjunction	with	constraint	tableau minimization	1219-1
tableau minimization	provides	action	a powerful optimization technique	1219-1
a powerful optimization technique		sequential	that	1219-1
that	yields	action	good results	1219-1
good results	in	constraint	many cases	1219-1
<B>	by	constraint	the following example	1219-2
<B>	is illustrated	action	the following example	1219-2
the following example	by	constraint	Exercise 8.28	1219-2
the following example	and	conjunctive	Exercise 8.28	1219-2
Example		sequential	8.4.11	1220-1
<B>	Suppose	action	we	1220-2
we	to	constraint	the query	1220-2
we	wish	action	the query	1220-2
we	optimize	action	the query	1220-2
the query	on	constraint	databases	1220-2
databases	satisfying	action	the dependencies F	1220-2
the dependencies F		sequential	B	1220-2
B	→	sequential	D	1220-2
D		sequential	D	1220-2
D		sequential	C	1220-2
C		sequential	⊲⊳	1220-2
⊲⊳		sequential	AB	1220-2
AB		sequential	ACD	1220-2
The tableau		sequential	T	1221-1
T		sequential	t	1221-1
t	to	constraint	q	1221-1
t	corresponding	action	q	1221-1
q	in	constraint	Fig	1221-1
q	is represented	action	Fig	1221-1
8.5		sequential	<B>	1221-2
<B>	that	constraint	T	1221-3
<B>	Note	action	T	1221-3
T		sequential	t	1221-3
t	is	attribute	minimal	1221-3
we	Next chase	action	T	1221-4
T		sequential	t	1221-4
t	using	action	the dependencies	1221-4
the dependencies	in	constraint	F	1221-4
The chase	and	conjunctive	Dependency B C D B C D T w′ x	1221-5
The chase	using	attribute	the jd Functional	1221-5
The chase	Join	action	Dependency B C D B C D T w′ x	1221-5
Chase	and	conjunctive	The Implication	1222-1
This correspondence	uses	action	tableaux	1222-2
tableaux	to	constraint	dependencies	1222-2
tableaux	represent	action	dependencies	1222-2
We	that	constraint	the chase	1222-3
We	will see	action	the chase	1222-3
the chase	provides	action	an alternative point	1222-3
an alternative point	of	constraint	view	1222-3
view	to	constraint	dependency implication	1222-3
<B>	First consider	action	a jd	1223-1
a jd		sequential	σ	1223-1
σ	=⊲⊳	sequential	X1	1223-1
<B>	.	sequential	<B>	1223-2
<B>	.	sequential	<B>	1223-3
Xn		sequential	Xn	1223-4
It	to	constraint	an instance	1223-5
It	that	constraint	an instance	1223-5
It	is	attribute	immediate	1223-5
It	see	action	an instance	1223-5
an instance		sequential	I	1223-5
I	satisfies	action	qσ	1223-5
qσ		sequential	I	1223-5
I		sequential	σ iff ⊆ qid	1223-5
σ iff ⊆ qid		sequential	I	1223-5
I		sequential	qσ	1223-5
qσ	where =	sequential	X1	1223-5
X1		sequential	Xn	1223-5
Xn		sequential	i	1223-5
i		sequential	i	1223-5
i		sequential	π Xi	1223-5
It	to	constraint	that qσ	1224-1
It	is	attribute	again easy	1224-1
It	see	action	that qσ	1224-1
that qσ		sequential	Tσ	1224-1
Tσ		sequential	t	1224-1
t		sequential	I	1224-1
I	|=	sequential	σ	1224-1
σ		sequential	so iff	1224-1
so iff		sequential	Tσ	1224-1
Tσ		sequential	t	1224-1
t		sequential	I	1224-1
I		sequential	⊆	1224-1
⊆		sequential	t }	1224-1
t }		sequential	t	1224-1
t		sequential	I	1224-1
<B>	For	constraint	fd	1225-1
fd		sequential	the situation	1225-1
the situation	is	attribute	only slightly more complicated	1225-1
<B>	Consider	action	an fd σ	1225-2
an fd σ		sequential	′	1225-2
′	=	sequential	X → A	1225-2
X → A	over	constraint	U	1225-2
It	to	constraint	I	1225-3
It	that	constraint	I	1225-3
It	is	attribute	easy	1225-3
It	see	action	I	1225-3
I		sequential	σ iff	1225-3
σ iff		sequential	Tσ′	1225-3
Tσ′		sequential	tσ′	1225-3
tσ′		sequential	I	1225-3
I		sequential	⊆	1225-3
⊆		sequential	Tσ′	1225-3
Tσ′		sequential	t′σ′	1225-3
t′σ′		sequential	I	1225-3
I		sequential	X u u v2	1225-3
X u u v2		sequential	X	1225-3
X		sequential	Tσ′	1225-3
Tσ′		sequential	x	1225-3
x		sequential	v1	1225-3
v1		sequential	x	1225-3
x		sequential	v1	1225-3
v1		sequential	u	1225-3
u		sequential	x′	1225-3
x′		sequential	u	1225-3
u		sequential	x′	1225-3
x′		sequential	v2	1225-3
v2		sequential	tσ′	1225-3
tσ′		sequential	x	1225-3
x		sequential	x′	1225-3
x′		sequential	t ′σ′ x x	1225-3
t ′σ′ x x		sequential	u	1225-3
u		sequential	v1	1225-3
v1		sequential	v2	1225-3
v2	are	attribute	where vectors	1225-3
where vectors	of	constraint	distinct variables	1225-3
distinct variables	and	conjunctive	x	1225-3
x	are	attribute	x′ distinct variables	1225-3
x′ distinct variables	in	constraint	none	1225-3
x′ distinct variables	occurring	action	none	1225-3
none	of	constraint	these vectors	1225-3
The tableau query	of	constraint	σ ′	1225-4
σ ′	is	attribute	Tσ′	1225-4
Tσ′		sequential	tσ′	1225-4
<B>	In	constraint	Chapter 10	1226-1
Chapter 10		sequential	we	1226-1
we	will consider	action	the general class	1226-1
the general class	of	constraint	algebraic dependencies	1226-1
algebraic dependencies	on	constraint	containment	1226-1
algebraic dependencies	based	action	containment	1226-1
containment	of	constraint	these expressions	1226-1
<B>	to	constraint	the chase	1227-1
<B>	Returning	action	the chase	1227-1
the chase		sequential	we	1227-1
we	next use	action	the tableau representation	1227-1
the tableau representation	of	constraint	dependencies	1227-1
dependencies	to	constraint	a characterization	1227-1
dependencies	obtain	action	a characterization	1227-1
a characterization	of	constraint	logical implication	1227-1
logical implication		sequential	Exercise	1227-1
Exercise		sequential	8.29	1227-1
This result	by	constraint	Corollary 10.2.3	1227-2
This result	is generalized	action	Corollary 10.2.3	1227-2
Theorem		sequential	8.4.12	1228-1
Then F	|=	sequential	σ iff	1228-2
<B>	that	constraint	logical implication	1229-1
<B>	implies	action	logical implication	1229-1
<B>	determining	action	logical implication	1229-1
logical implication	for	constraint	jd	1229-1
jd	for	constraint	fd	1229-1
jd	and	conjunctive	fd	1229-1
fd	and	conjunctive	jd	1229-1
jd	s taken together	attribute	decidable	1229-1
jd	is	attribute	decidable	1229-1
<B>	On	constraint	the other hand	1229-2
the other hand		sequential	tableau techniques	1229-2
tableau techniques	to	constraint	the following complexity results	1229-2
tableau techniques	are also used	action	the following complexity results	1229-2
tableau techniques	obtain	action	the following complexity results	1229-2
the following complexity results	for	constraint	logical implication	1229-2
logical implication	of	constraint	jd	1229-2
jd	see	action	Exercise 8.30	1229-2
<B>	and	conjunctive	Dependency Theorem 8.4.13	1230-1
<B>	Join	action	Dependency Theorem 8.4.13	1230-1
<B>	In	constraint	Section 6.4	1231-1
Section 6.4		sequential	a special family	1231-1
a special family	of	constraint	joins	1231-1
joins	called	action	acyclic	1231-1
acyclic	to	constraint	a number	1231-1
acyclic	and	conjunctive	a number	1231-1
acyclic	was introduced	action	a number	1231-1
acyclic	was shown	action	a number	1231-1
acyclic	enjoy	action	a number	1231-1
a number	of	constraint	desirable properties	1231-1
We	show now	action	a connection	1231-2
a connection	between	constraint	those results	1231-2
those results	join	action	dependencies	1231-2
dependencies	and	conjunctive	multivalued dependencies	1231-2
<B>	Using	action	the chase	1232-1
the chase		sequential	we	1232-1
we	that	constraint	a jd	1232-1
we	show here	action	a jd	1232-1
a jd	is	attribute	acyclic iff	1232-1
acyclic iff		sequential	it	1232-1
it	to	constraint	a set	1232-1
it	is	attribute	equivalent	1232-1
a set	of	constraint	mvd	1232-1
mvd		sequential	<B>	1232-1
The discussion	on	constraint	the notation	1233-1
The discussion	relies	action	the notation	1233-1
the notation	and	conjunctive	techniques	1233-1
techniques	in	constraint	the discussion	1233-1
techniques	developed	action	the discussion	1233-1
the discussion	of	constraint	acyclic	1233-1
acyclic	in	constraint	Section 6.4	1233-1
acyclic	joins	action	Section 6.4	1233-1
We	shall use	action	the following lemma	1234-1
Lemma		sequential	8.4.14	1235-1
8.4.14	Let	action	σ	1235-1
σ	=	sequential	<B>	1235-1
<B>	are	attribute	Then equivalent	1235-2
Proof	Let	action	Z	1236-1
Z	=	sequential	U	1236-1
U	−	sequential	XY	1236-1
<B>	Let	action	τ	1236-2
τ	denote	action	the mvd X → query	1236-2
the mvd X → query	to	constraint	τ	1236-2
the mvd X → query	corresponding	action	τ	1236-2
<B>	Let	action	Tτ	1236-3
Tτ	=	sequential	tY	1236-3
tY		sequential	tZ	1236-3
tZ		sequential	tY	1236-3
tY		sequential	XY	1236-3
XY	where =	sequential	tτ	1236-3
tτ		sequential	XY	1236-3
XY	and	conjunctive	tZ	1236-3
tZ		sequential	XZ	1236-3
XZ	=	sequential	tτ	1236-3
tτ		sequential	XZ	1236-3
We	that	constraint	i	1237-1
We	show now	action	i	1237-1
i	implies	action	ii	1237-1
<B>	By	constraint	Theorem 8.4.12	1237-2
Theorem 8.4.12		sequential	tτ	1237-2
tτ		sequential	∈	1237-2
∈		sequential	T	1237-2
T	=	sequential	chase	1237-2
chase		sequential	Tτ	1237-2
Tτ		sequential	tτ σ	1237-2
<B>	Let	action	Xi ∈ X	1237-3
<B>	that	constraint	t	1237-4
<B>	Suppose	action	t	1237-4
t	is	attribute	a new tuple	1237-4
a new tuple	by	constraint	an application	1237-4
a new tuple	created	action	an application	1237-4
an application	of	constraint	σ	1237-4
σ	during	constraint	the computation	1237-4
the computation	of	constraint	T	1237-4
t		sequential	Xi	1237-5
Xi	with	constraint	t′	1237-5
Xi	Then agrees	action	t′	1237-5
t′		sequential	Xi	1237-5
Xi	for	constraint	some already existing tuple	1237-5
An induction	that	constraint	tτ	1237-6
An induction	implies	action	tτ	1237-6
tτ		sequential	Xi	1237-6
Xi	=	sequential	tY	1237-6
tY		sequential	Xi	1237-6
Xi	or	conjunctive	tτ	1237-6
tτ		sequential	Xi	1237-6
Xi		sequential	tZ	1237-6
tZ		sequential	Xi	1237-6
<B>	Because	constraint	tY	1237-7
tY	and	conjunctive	tZ	1237-7
tZ	on	constraint	only X	1237-7
tZ	agree	action	only X	1237-7
only X	that	constraint	Xi	1237-7
only X	implies	action	Xi	1237-7
Xi	with	constraint	Y	1237-7
Xi	both	conjunctive	Y	1237-7
Xi	can not intersect	action	Y	1237-7
Y	and	conjunctive	Z	1237-7
<B>		sequential	ii	1238-1
ii	implies	attribute	iii immediate	1238-1
ii	is	attribute	iii immediate	1238-1
<B>	To	constraint	iii	1238-2
<B>	that	constraint	iii	1238-2
<B>	see	action	iii	1238-2
iii	implies i	action	an application	1238-2
iii	consider	action	an application	1238-2
an application	of	constraint	the jd ⊲⊳X	1238-2
the jd ⊲⊳X	on	constraint	Tτ	1238-2
Tτ		sequential	Xi ∈ X	1238-2
Xi ∈ X	with	constraint	tY	1238-2
Xi ∈ X	where is associated	action	tY	1238-2
tY	if	constraint	Xi	1238-2
Xi	−	sequential	X ⊆ Y	1238-2
X ⊆ Y	and	conjunctive	Xi	1238-2
Xi	with	constraint	tZ	1238-2
Xi	is associated otherwise	action	tZ	1238-2
<B>	builds	action	the tuple	1238-3
the tuple		sequential	tτ	1238-3
tτ	by	constraint	Theorem 8.4.12	1238-3
tτ	and	conjunctive	Theorem 8.4.12	1238-3
Theorem 8.4.12		sequential	σ	1238-3
σ		sequential	X	1238-3
We	now have	action	the following Theorem 8.4.15	1239-1
Proof		sequential	Proof	1240-1
<B>	For	constraint	i	1241-1
i		sequential	∈	1241-1
∈		sequential	1	1241-1
1	n	conjunctive	1	1241-1
1	−	sequential	1	1241-1
1	let	action	Pi	1241-1
Pi		sequential	∪j∈	1241-1
∪j∈		sequential	1	1241-1
1		sequential	i	1241-1
i		sequential	Xj	1241-1
Xj	and	conjunctive	Qi	1241-1
Qi	=	sequential	∪j∈	1241-1
∪j∈		sequential	i+1	1241-1
i+1		sequential	n	1241-1
<B>	Let	action	F	1241-2
F		sequential	Pi ∩ Qi	1241-2
Pi ∩ Qi	→	sequential	<B>	1241-2
We	by	constraint	t1	1242-1
We	begin	action	t1	1242-1
We	setting	action	t1	1242-1
t1	to	constraint	the tuple	1242-1
t1	be	attribute	the tuple	1242-1
the tuple	of	constraint	T σ	1242-1
T σ		sequential	that	1242-1
that	to	constraint	X1	1242-1
that	corresponds	action	X1	1242-1
t1		sequential	P1	1242-2
P1	Then =	sequential	tσ	1242-2
tσ		sequential	P1	1242-2
P1	because	constraint	P1	1242-2
P1	=	sequential	X1	1242-2
<B>	given	action	ti	1242-3
ti	with	constraint	i	1242-3
i	≥	sequential	1	1242-3
1		sequential	the mvd	1242-3
the mvd		sequential	Pi ∩ Qi	1242-3
Pi ∩ Qi	→	sequential	ti	1242-3
ti	and	conjunctive	the tuple	1242-3
the tuple	to	constraint	Xi+1	1242-3
the tuple	corresponding	action	Xi+1	1242-3
Xi+1	to	constraint	tuple ti+1	1242-3
Xi+1	can be used	action	tuple ti+1	1242-3
Xi+1	construct	action	tuple ti+1	1242-3
tuple ti+1	with	constraint	the desired property	1242-3
The final tuple tn	by	constraint	this process	1242-4
The final tuple tn	constructed	action	this process	1242-4
this process	is	attribute	tσ	1242-4
tσ	and	conjunctive	F	1242-4
F	|=	sequential	σ	1242-4
σ	as	constraint	<B>	1242-4
σ	desired	action	<B>	1242-4
<B>	Let	action	Y=	1243-1
Y=		sequential	Y1	1243-1
<B>	.	sequential	<B>	1243-2
<B>	.	sequential	<B>	1243-3
Ym }		sequential	Ym }	1243-4
<B>	that	constraint	s1	1243-5
<B>	Suppose	action	s1	1243-5
<B>	.	sequential	<B>	1243-6
<B>	.	sequential	<B>	1243-7
<B>	are	attribute	the tuples	1243-8
the tuples	by	constraint	some chasing sequence	1243-8
the tuples	produced	action	some chasing sequence	1243-8
some chasing sequence	of	constraint	Tσ	1243-8
Tσ		sequential	tσ	1243-8
We	by	constraint	induction	1243-9
We	argue	action	induction	1243-9
induction		sequential	that	1243-9
that	for	constraint	each k ≥ 1	1243-9
each k ≥ 1		sequential	sk	1243-9
sk		sequential	W	1243-9
W		sequential	∈ πW	1243-9
∈ πW		sequential	Tσ	1243-9
<B>	and	conjunctive	sk	1243-10
<B>	Suppose otherwise	action	sk	1243-10
<B>	let	action	sk	1243-10
sk	be	attribute	the first	1243-10
sk	where does not hold	action	<B>	1243-10
<B>	that	constraint	sk	1243-11
<B>	Suppose	action	sk	1243-11
sk	is	attribute	the result	1243-11
the result	of	constraint	an mvd X	1243-11
the result	applying	action	an mvd X	1243-11
<B>	Let	action	Z	1244-1
Z	=	sequential	U	1244-1
U	−	sequential	XY	1244-1
<B>	Because	constraint	sk results	1244-2
sk results	from	constraint	X →	1244-2
X →	in	constraint	T σ	1244-2
T σ	or	conjunctive	that sk	1244-2
T σ	already produced	attribute	such	1244-2
that sk		sequential	XY	1244-2
XY	=	sequential	s′	1244-2
s′		sequential	XY	1244-2
XY	and	conjunctive	sk	1244-2
sk		sequential	XZ	1244-2
XZ	=	sequential	s′′	1244-2
s′′		sequential	XZ	1244-2
<B>	Because	constraint	sk	1244-3
sk	to	constraint	there	1244-3
sk	is chosen	action	there	1244-3
sk	be least	action	there	1244-3
there	are	attribute	tuples	1244-3
tuples		sequential	ti	1244-3
ti	and	conjunctive	tj	1244-3
tj	in	constraint	Tσ	1244-3
Tσ		sequential	which	1244-3
which	to	constraint	Xi	1244-3
which	correspond	action	Xi	1244-3
Xi	and	conjunctive	Xj	1244-3
Xj		sequential	s′	1244-3
s′		sequential	W	1244-3
W	=	sequential	ti	1244-3
ti		sequential	W	1244-3
W	and	conjunctive	s′′	1244-3
s′′		sequential	W	1244-3
W	=	sequential	tj	1244-3
tj		sequential	W	1244-3
<B>	Because	constraint	ti	1245-1
ti	and	conjunctive	tj	1245-1
tj	to	constraint	Xi	1245-1
tj	correspond	action	Xi	1245-1
Xi	and	conjunctive	Xj	1245-1
Xj	for	constraint	each attribute	1245-1
each attribute		sequential	A ∈ U	1245-1
A ∈ U		sequential	we	1245-1
we	have	action	ti	1245-1
ti		sequential	A	1245-1
A	=	sequential	tj	1245-1
tj		sequential	A	1245-1
A		sequential	iff A ∈ Xi ∩ Xj	1245-1
Thus X ∩ W ⊆ Xi ∩ Xj		sequential	Thus X ∩ W ⊆ Xi ∩ Xj	1245-2
<B>	Because	constraint	sk	1246-1
sk		sequential	W	1246-1
W	=	sequential	ti	1246-1
ti		sequential	W	1246-1
W		sequential	W	1246-1
W		sequential	XZ	1246-1
XZ	=	sequential	∅	1246-1
∅	because	constraint	sk	1246-1
∅	and	conjunctive	sk	1246-1
sk		sequential	W	1246-1
W	=	sequential	tj	1246-1
tj		sequential	W	1246-1
W		sequential	W	1246-1
W		sequential	XY	1246-1
XY	=	sequential	<B>	1246-1
XY	∅	sequential	<B>	1246-1
<B>	by	constraint	Lemma 8.4.14	1247-1
Lemma 8.4.14	because	constraint	X	1247-1
X		sequential	that	1247-1
that		sequential	Xk	1247-1
Xk		sequential	∩	1247-1
∩		sequential	Y	1247-1
Y	=	sequential	∅	1247-1
∅	and	conjunctive	Xk ∩	1247-1
Xk ∩		sequential	Z	1247-1
Z	=	sequential	∅	1247-1
It	that	constraint	Y|W−X	1247-2
It	follows	action	Y|W−X	1247-2
Y|W−X	is disconnected	action	<B>	1247-2
<B>	Finally let	action	Y	1247-3
Y		sequential	Xi ∩ W	1247-3
Xi ∩ W	and	conjunctive	Y ′	1247-3
Y ′	=	sequential	<B>	1247-3
<B>	Because	constraint	X ∩ W ⊆ Xi	1247-4
X ∩ W ⊆ Xi		sequential	∩	1247-4
We	with	constraint	a complexity result	1248-1
We	conclude	action	a complexity result	1248-1
a complexity result	about	constraint	acyclic jd	1248-1
acyclic jd		sequential	<B>	1248-1
The first part	from	constraint	the proof	1248-2
The first part	follows	action	the proof	1248-2
the proof	of	constraint	the preceding theorem	1248-2
the preceding theorem	and	conjunctive	the fact	1248-2
the fact	that	constraint	the GYO algorithm	1248-2
the GYO algorithm	in	constraint	polynomial time	1248-2
the GYO algorithm	runs	action	polynomial time	1248-2
The second part	without	constraint	proof	1248-3
The second part	stated	action	proof	1248-3
proof	is	attribute	an interesting converse	1248-3
an interesting converse	of	constraint	the first part	1248-3
Proposition		sequential	8.4.16	1249-1
The Chase		sequential	Church	1250-1
Church		sequential	Rosser	1250-1
<B>	To	constraint	this end	1250-2
this end		sequential	we	1250-2
we	first introduce	action	tools	1250-2
tools	to	constraint	correspondences	1250-2
tools	describe	action	correspondences	1250-2
correspondences	between	constraint	the free tuples	1250-2
the free tuples	in	constraint	the different elements	1250-2
the free tuples	occurring	action	the different elements	1250-2
the different elements	of	constraint	chasing sequences	1250-2
<B>	and	conjunctive	Dependency Let	1251-1
<B>	Join	action	Dependency Let	1251-1
Dependency Let		sequential	T	1251-1
T		sequential	t	1251-1
t	=	sequential	T0	1251-1
T0		sequential	t0	1251-1
<B>	.	sequential	<B>	1251-2
<B>	.	sequential	<B>	1251-3
Tn		sequential	tn	1251-4
tn	be	attribute	a chasing sequence	1251-4
a chasing sequence	of	constraint	T	1251-4
T		sequential	t	1251-4
t	by	constraint	F	1251-4
The chase homomorphism	of	constraint	this chasing sequence	1252-1
this chasing sequence	is	attribute	θ	1252-1
θ	=	sequential	θ	1252-1
θ		sequential	1	1252-1
1		sequential	θn	1252-1
<B>	If	constraint	∈ T ∪	1252-2
<B>	w	constraint	∈ T ∪	1252-2
∈ T ∪		sequential	t }	1252-2
t }		sequential	the tuple	1252-2
the tuple	to	constraint	Ti	1252-2
the tuple	w	constraint	Ti	1252-2
the tuple	in	constraint	Ti	1252-2
the tuple	corresponding	action	Ti	1252-2
Ti		sequential	ti	1252-2
ti	is	attribute	wi	1252-2
wi	=	sequential	1	1252-2
1		sequential	θi	1252-2
θi		sequential	w	1252-2
It	that	constraint	ui	1252-3
It	may arise	action	ui	1252-3
ui		sequential	vi	1252-3
vi	for	constraint	distinct tuples	1252-3
distinct tuples		sequential	u	1252-3
u		sequential	v	1252-3
v	in	constraint	T	1252-3
<B>	that	constraint	θ	1252-4
<B>	Observe	action	θ	1252-4
θ		sequential	1	1252-4
1		sequential	θi	1252-4
θi		sequential	T	1252-4
We	now have	action	the following Lemma 8.4.17	1253-1
<B>	.	sequential	<B>	1253-2
<B>	.	sequential	<B>	1253-3
Tn		sequential	tn	1253-4
tn	is	attribute	a chasing sequence	1253-4
a chasing sequence	of	constraint	T	1253-4
T		sequential	t	1253-4
t	by	constraint	F	1253-4
Crux	Use	action	an induction	1254-1
an induction	on	constraint	the chasing sequence	1254-1
the chasing sequence		sequential	Exercise	1254-1
Exercise		sequential	8.24d	1254-1
<B>	that	constraint	I	1255-1
<B>	if	constraint	I	1255-1
<B>	Observe	attribute	this	1255-1
<B>	also holds	action	I	1255-1
I	is	attribute	a tableau	1255-1
a tableau	over	constraint	R	1255-1
R		sequential	that	1255-1
that	satisfies	action	F	1255-1
Theorem		sequential	8.4.18	1256-1
8.4.18	Let	action	T	1256-1
T	be	attribute	t a tableau query	1256-1
t a tableau query	over	constraint	R	1256-1
R	and	conjunctive	F	1256-1
F		sequential	a set fd	1256-1
a set fd	of	constraint	s	1256-1
s	and	conjunctive	jd	1256-1
jd	over	constraint	R	1256-1
Proof	Let	action	T ′	1257-1
T ′		sequential	t′	1257-1
t′	and	conjunctive	T ′′	1257-1
T ′′		sequential	t′′	1257-1
t′′	be	attribute	the results	1257-1
the results	of	constraint	two terminal chasing sequences	1257-1
two terminal chasing sequences	on	constraint	T	1257-1
T		sequential	t	1257-1
t	using	action	F	1257-1
F	and	conjunctive	θ	1257-1
F	let	action	θ	1257-1
θ		sequential	′	1257-1
′	θ	action	′′	1257-1
′′	be	attribute	the chase homomorphisms	1257-1
the chase homomorphisms	of	constraint	these chasing sequences	1257-1
<B>	For	constraint	each tuple ∈	1257-2
each tuple ∈	w	constraint	T	1257-2
T	let	action	w′	1257-2
w′	denote	action	the tuple	1257-2
the tuple	of	constraint	T ′	1257-2
T ′		sequential	that	1257-2
that	to	constraint	T ′′	1257-2
that	w	constraint	T ′′	1257-2
that	for	constraint	T ′′	1257-2
that	and	conjunctive	T ′′	1257-2
that	corresponds	action	T ′′	1257-2
<B>	By	constraint	construction	1258-1
construction		sequential	θ	1258-1
θ		sequential	T	1258-1
T		sequential	⊆ T ′′	1258-1
⊆ T ′′	and	conjunctive	θ	1258-1
θ	′′	sequential	t	1258-1
t	=	sequential	t′′	1258-1
<B>	Because	constraint	T ′′	1258-2
T ′′	|=	sequential	F	1258-2
F	and	conjunctive	θ	1258-2
θ		sequential	′′	1258-2
′′		sequential	T	1258-2
T		sequential	⊆	1258-2
⊆		sequential	T	1258-2
T		sequential	θ	1258-2
θ		sequential	′′	1258-2
′′		sequential	T	1258-2
T		sequential	′	1258-2
The same argument	that	constraint	w′′	1258-3
The same argument	′′	sequential	w′′	1258-3
The same argument	=	sequential	w′′	1258-3
The same argument	shows	attribute	θ	1258-3
w′′	for	constraint	T	1258-3
w′′	w	constraint	T	1258-3
w′′	in	constraint	T	1258-3
T	and	conjunctive	θ	1258-3
θ		sequential	′′	1258-3
′′		sequential	t′	1258-3
t′	=	sequential	t′′	1258-3
<B>	By	constraint	symmetry	1258-4
symmetry		sequential	θ ′	1258-4
θ ′		sequential	T ′′	1258-4
We	that	constraint	<B>	1259-1
We	next prove	action	<B>	1259-1
<B>	Let	action	w′′	1260-1
w′′	in	constraint	T ′′	1260-1
w′′	be	attribute	T ′′	1260-1
T ′′	for	constraint	T	1260-1
T ′′	w	constraint	T	1260-1
T ′′	in	constraint	T	1260-1
<B>		sequential	<B>	1260-2
Bibliographic Notes	that	constraint	each variable x	1261-1
Bibliographic Notes	Observe	action	each variable x	1261-1
each variable x	in	constraint	var	1261-1
var		sequential	T ′′	1261-1
T ′′	in	constraint	w′′	1261-1
T ′′	occurs	action	w′′	1261-1
w′′	for	constraint	T	1261-1
w′′	w	constraint	T	1261-1
w′′	in	constraint	T	1261-1
θ		sequential	′′	1261-2
′′	is	attribute	Thus the identity	1261-2
Thus the identity	over	constraint	var	1261-2
var		sequential	T	1261-2
T		sequential	′′	1261-2
We	therefore have	action	<B>	1261-3
<B>	By	constraint	symmetry	1262-1
symmetry		sequential	θ	1262-1
θ	is	attribute	the identity	1262-1
the identity	over	constraint	var	1262-1
var		sequential	T	1262-1
T		sequential	′	1262-1
′	and	conjunctive	<B>	1262-1
<B>		sequential	′′|	1263-1
′′|	=	sequential	|T	1263-1
|T		sequential	′|	1263-1
<B>	Because	constraint	θ	1263-2
θ		sequential	′′	1263-2
′′		sequential	T	1263-2
T		sequential	′	1263-2
<B>	To	constraint	we	1264-1
<B>	conclude	action	we	1264-1
we	prove	action	<B>	1264-1
We	that	constraint	each pair x	1265-1
We	for	constraint	each pair x	1265-1
We	first show	action	each pair x	1265-1
each pair x		sequential	y	1265-1
y	of	constraint	variables	1265-1
variables	in	constraint	T	1265-1
variables	occurring	action	T	1265-1
T	†	sequential	<B>	1265-1
<B>	that	constraint	θ	1266-1
<B>	Suppose	action	θ	1266-1
θ	′′	sequential	x	1266-1
x	=	sequential	θ	1266-1
θ	′′	sequential	y	1266-1
<B>	for	constraint	some tuples u	1266-2
some tuples u		sequential	v ∈ T	1266-2
v ∈ T	and	conjunctive	attributes	1266-2
attributes		sequential	A	1266-2
A		sequential	B	1266-2
B		sequential	we	1266-2
we	Then have	action	u	1266-2
u		sequential	A	1266-2
A	=	sequential	x	1266-2
x		sequential	v	1266-2
v		sequential	B	1266-2
B	=	sequential	y	1266-2
y	and	conjunctive	u′′	1266-2
u′′		sequential	A	1266-2
A	=	sequential	θ	1266-2
θ		sequential	x	1266-2
x	=	sequential	θ	1266-2
θ		sequential	y	1266-2
y	=	sequential	v′′	1266-2
v′′		sequential	B	1266-2
Next θ		sequential	′	1266-3
′		sequential	x	1266-3
x	=	sequential	u′	1266-3
u′		sequential	A	1266-3
A	and	conjunctive	θ	1266-3
θ		sequential	y	1266-3
y	=	sequential	v′	1266-3
v′		sequential	B	1266-3
<B>	Because	constraint	θ	1266-4
θ		sequential	′	1266-4
′	is	attribute	an isomorphism	1266-4
an isomorphism	from	constraint	T ′′	1266-4
T ′′		sequential	t′′	1266-4
t′′	to	constraint	T ′	1266-4
T ′		sequential	t′	1266-4
t′	and	conjunctive	θ	1266-4
θ		sequential	u′′	1266-4
u′′	=	sequential	θ	1266-4
θ		sequential	v′′	1266-4
v′′	=	sequential	v′	1266-4
v′		sequential	it	1266-4
it	that	constraint	u′	1266-4
it	follows	action	u′	1266-4
u′		sequential	A	1266-4
A	=	sequential	v′	1266-4
v′		sequential	B	1266-4
θ		sequential	x	1266-5
x	Hence =	sequential	u′	1266-5
u′		sequential	A	1266-5
A	=	sequential	v′	1266-5
v′		sequential	B	1266-5
B	=	sequential	θ ′	1266-5
θ ′		sequential	y	1266-5
y	as	constraint	<B>	1266-5
y	desired	action	<B>	1266-5
<B>	if	constraint	direction	1266-6
direction	by	constraint	symmetry	1266-6
direction	follows	action	symmetry	1266-6
<B>	Now let	action	x ∈ var	1267-1
x ∈ var		sequential	T	1267-1
T		sequential	′	1267-1
<B>	To	constraint	the theorem	1267-2
<B>	and	conjunctive	the theorem	1267-2
<B>	prove	action	the theorem	1267-2
the theorem		sequential	it	1267-2
it	to	constraint	θ ′′	1267-2
it	that	constraint	θ ′′	1267-2
it	now suffices	action	θ ′′	1267-2
it	show	action	θ ′′	1267-2
θ ′′		sequential	x	1267-2
x	=	sequential	x	1267-2
<B>	Let	action	<B>	1267-3
<B>	that	constraint	A′	1268-1
<B>	First † implies	action	A′	1268-1
A′	=	sequential	A′′	1268-1
an induction	on	constraint	the chasing sequence	1268-2
the chasing sequence	for	constraint	T	1268-2
T		sequential	t′	1268-2
t′	that	constraint	each z ∈	1268-2
t′	for	constraint	each z ∈	1268-2
t′	Furthermore shows	action	each z ∈	1268-2
θ		sequential	′	1268-3
′	and	conjunctive	θ	1268-3
θ		sequential	′′	1268-3
′′	Thus map	action	all elements	1268-3
all elements	of	constraint	A′	1268-3
A′	and	conjunctive	A′′	1268-3
A′′	to	constraint	the same variable z	1268-3
<B>	Because	constraint	x ∈ var	1268-4
x ∈ var		sequential	T ′	1268-4
T ′		sequential	it	1268-4
it	follows	action	that z	1268-4
that z	in	constraint	θ	1268-4
that z	x	sequential	θ	1268-4
θ	′	sequential	x	1268-4
x	=	sequential	<B>	1268-4
Bibliographic Notes		sequential	Bibliographic Notes	1269-1
A more dense presentation	in	constraint	Kan91	1269-2
A more dense presentation	is provided	action	Kan91	1269-2
Dependency theory	is	attribute	also the topic	1270-1
also the topic	of	constraint	the book	1270-1
the book		sequential	Tha91	1270-1
Research	on	constraint	general integrity constraints	1271-1
general integrity constraints	from	constraint	the perspective	1271-1
general integrity constraints	considered	action	the perspective	1271-1
the perspective	of	constraint	order	1271-1
order		sequential	logic	1271-1
logic	in	constraint	GM78	1271-1
logic	is presented	action	GM78	1271-1
Other early work	in	constraint	this framework	1271-2
this framework	includes	action	Nic78	1271-2
Nic78		sequential	which	1271-2
which	that	constraint	fd	1271-2
which	observes	action	fd	1271-2
fd	and	conjunctive	mvd	1271-2
mvd	have	action	a natural representation	1271-2
a natural representation	in	constraint	logic	1271-2
logic	and	conjunctive	Nic82	1271-2
Nic82		sequential	which	1271-2
which		sequential	Functional	1271-2
Functional	and	conjunctive	Join	1271-2
Join		sequential	Dependency	1271-2
Dependency	considers	action	incremental maintanence	1271-2
incremental maintanence	of	constraint	integrity constraints	1271-2
integrity constraints	under	constraint	updates	1271-2
updates	to	constraint	the underlying state	1271-2
Functional dependencies	by	constraint	Codd	1272-1
Functional dependencies	were introduced	action	Codd	1272-1
Codd		sequential	Cod72 b	1272-1
The axiomatization	to	constraint	Arm74	1272-2
The axiomatization	is	attribute	due	1272-2
The problem	of	constraint	implication	1272-3
implication	in	constraint	BB79	1272-3
implication	is studied	action	BB79	1272-3
BB79		sequential	Mai80	1272-3
Several alternative formulations	of	constraint	fd implication	1272-4
fd implication	including	action	formulation	1272-4
formulation	in	constraint	terms	1272-4
terms	of	constraint	the propositional calculus perspective	1272-4
the propositional calculus perspective	see	action	Exercise 8.22	1272-4
Exercise 8.22	in	constraint	Kan91	1272-4
Exercise 8.22	are mentioned	action	Kan91	1272-4
Kan91		sequential	they	1272-4
they	due	constraint	SDPF81	1272-4
they	to	constraint	SDPF81	1272-4
they	are	attribute	SDPF81	1272-4
SDPF81		sequential	CK85	1272-4
CK85		sequential	CKS86	1272-4
The structure	of	constraint	families	1273-1
families	of	constraint	instances	1273-1
instances	by	constraint	a set	1273-1
instances	specified	action	a set	1273-1
a set	of	constraint	fd s	1273-1
fd s	in	constraint	GZ82	1273-1
fd s	is studied	action	GZ82	1273-1
GZ82		sequential	Hul84	1273-1
Multivalued dependencies	in	constraint	Zan76	1274-1
Multivalued dependencies	were discovered independently	action	Zan76	1274-1
Zan76		sequential	Fag77b	1274-1
Fag77b		sequential	Del78	1274-1
They	in	constraint	Ris77	1275-1
They	were generalized	action	Ris77	1275-1
Ris77		sequential	Nic78	1275-1
Nic78		sequential	ABU79	1275-1
The axiomatization	of	constraint	fd	1275-2
fd		sequential	s	1275-2
s	and	conjunctive	mvd	1275-2
mvd	from	constraint	BFH77	1275-2
mvd	is	attribute	BFH77	1275-2
A probabilistic view	of	constraint	mvd	1275-3
mvd	in	constraint	terms	1275-3
terms	of	constraint	conditional independence	1275-3
conditional independence	in	constraint	PV88	1275-3
conditional independence	is presented	action	PV88	1275-3
PV88		sequential	Pea88	1275-3
<B>	provides	action	an alternative motivation	1275-4
an alternative motivation	for	constraint	the study	1275-4
the study	of	constraint	such dependencies	1275-4
The issue	of	constraint	there	1276-1
The issue	whether	constraint	there	1276-1
there	is	attribute	an axiomatization	1276-1
an axiomatization	for	constraint	jd	1276-1
jd		sequential	s	1276-1
s	has	action	a lengthy history	1276-1
<B>	As	constraint	Chapter 10	1276-2
<B>	in	constraint	Chapter 10	1276-2
<B>	be	attribute	will detailed	1276-2
Chapter 10		sequential	the family	1276-2
the family	of	constraint	full typed dependencies	1276-2
full typed dependencies	subsumes	action	the family	1276-2
the family	of	constraint	jd	1276-2
jd		sequential	s	1276-2
s	and	conjunctive	an axiomatization	1276-2
an axiomatization	for	constraint	BV84a	1276-2
an axiomatization	in	constraint	BV84a	1276-2
an axiomatization	was presented	action	BV84a	1276-2
BV84a		sequential	YP82	1276-2
YP82	see also	action	SU82	1276-2
More focused axiomatizations		sequential	which	1277-1
which	with	constraint	jd	1277-1
which	start	action	jd	1277-1
jd	and	conjunctive	end	1277-1
end	with	constraint	jd	1277-1
jd		sequential	s	1277-1
s	but	conjunctive	slightly more general dependencies	1277-1
s	use	action	slightly more general dependencies	1277-1
slightly more general dependencies	at	constraint	intermediate stages	1277-1
intermediate stages	in	constraint	Sci82	1277-1
intermediate stages	are presented	action	Sci82	1277-1
Sci82	and	conjunctive	BV85	1277-1
BV85	see also	action	<B>	1277-1
The connection	between	constraint	the chase	1278-1
the chase	and	conjunctive	the more general technique	1278-1
the chase	theorem proving	action	the more general technique	1278-1
the more general technique	of	constraint	resolution	1278-1
resolution	with	constraint	paramodulation	1278-1
paramodulation	see	action	CL73	1278-1
CL73	in	constraint	BV80 b	1278-1
CL73	and	conjunctive	BV80 b	1278-1
CL73	is observed	action	BV80 b	1278-1
CL73	analyzed	action	BV80 b	1278-1
The chase technique	to	constraint	datalog programs	1278-2
The chase technique	is applied	action	datalog programs	1278-2
datalog programs	in	constraint	RSUV89	1278-2
RSUV89		sequential	RSUV93	1278-2
Exercises Exercise		sequential	8.1	1279-1
Exercises Exercise 8.2	Let	action	F1	1280-1
F1	as	constraint	Example 8.2.4	1280-1
F1	in	constraint	Example 8.2.4	1280-1
F1	be	attribute	Example 8.2.4	1280-1
<B>	that	constraint	F1 AD E	1280-2
<B>	Prove	action	F1 AD E	1280-2
F1 AD E	and	conjunctive	F1	1280-2
F1 AD E	→	sequential	F1	1280-2
F1		sequential	CDE → C	1280-2
<B>	Exercise	action	8.3	1281-1
<B>	Show	attribute	that	1281-2
State	and	conjunctive	analogous results	1282-1
State	prove	action	analogous results	1282-1
analogous results	for	constraint	fd closures	1282-1
fd closures	of	constraint	attribute sets	1282-1
Exercise Prove Lemma 8.2.6		sequential	8.4	1283-1
<B>	Exercise	action	8.5	1284-1
<B>	Prove	action	the soundness	1284-2
the soundness	of	constraint	FD1	1284-2
FD1		sequential	FD2	1284-2
FD2		sequential	FD3	1284-2
FD3	and	conjunctive	that	1284-2
FD3	show	action	that	1284-2
that	If	constraint	F ⊢ X	1284-2
F ⊢ X		sequential	Y	1284-2
Y	and	conjunctive	F X	1284-2
F X		sequential	Z	1284-2
Z		sequential	F	1284-2
F		sequential	⊢ X	1284-2
⊢ X	→	sequential	Y Z	1284-2
Exercise		sequential	8.6	1285-1
Hint		sequential	Hint	1286-1
<B>	To	constraint	a list	1287-1
<B>	do efficiently	attribute	this	1287-1
<B>	maintain	action	a list	1287-1
a list	for	constraint	each attribute	1287-1
each attribute		sequential	A	1287-1
A	of	constraint	those unused fd	1287-1
those unused fd		sequential	s	1287-1
s	of	constraint	F	1287-1
F	for	constraint	which	1287-1
which		sequential	A	1287-1
A	in	constraint	left hand	1287-1
A	occurs	action	left hand	1287-1
left hand		sequential	the side	1287-1
Exercise		sequential	8.8	1288-1
Exercise		sequential	8.9	1289-1
FD5		sequential	union	1290-1
FD6		sequential	decomposition	1291-1
MVD4		sequential	pseudo transitivity	1292-1
MVD5		sequential	union	1293-1
MVD6		sequential	decomposition	1294-1
bad-FD1	If	constraint	XW	1295-1
XW	→	sequential	Y	1295-1
Y	and	conjunctive	XY	1295-1
XY	→	sequential	Z	1295-1
Z		sequential	X →	1295-1
X →		sequential	Z W	1295-1
Z W	−	sequential	<B>	1295-1
bad-MVD1	If	constraint	X	1296-1
bad-FMVD1	If	constraint	X	1297-1
<B>	Exercise	action	8.10	1298-1
8.10	with	constraint	Exercise 8.9	1298-1
8.10	Continuing	action	Exercise 8.9	1298-1
<B>	and	conjunctive	Dependency	1299-1
<B>	Join	action	Dependency	1299-1
Exercise		sequential	8.11	1300-1
S2	If	constraint	Y ∈	1301-1
Y ∈	and	conjunctive	Z ∈ satset	1301-1
Y ∈	satset	action	Z ∈ satset	1301-1
Z ∈ satset		sequential	Y ∩ Z ∈ satset	1301-1
<B>	that	constraint	satset	1302-1
<B>	Prove	action	satset	1302-1
satset	=	sequential	satset Ŵ	1302-1
satset Ŵ	for	constraint	some set	1302-1
some set	of	constraint	fd	1302-1
fd	over	constraint	U	1302-1
Hint	Use	action	Ŵ	1302-2
Ŵ	=	sequential	Y	1302-2
Y	→	sequential	Z|	1302-2
Z|	for	constraint	each X ∈ satset	1302-2
each X ∈ satset	if	constraint	Y ⊆ X Z ⊆ X }	1302-2
Exercise		sequential	8.12	1303-1
<B>	Using	action	the notation	1303-2
the notation	of	constraint	Exercise 8.11	1303-2
Exercise 8.11		sequential	<B>	1303-2
Exercise		sequential	8.13	1304-1
i=1		sequential	i	1305-1
i	n	conjunctive	each Xi ∈ F	1305-1
i	and	conjunctive	each Xi ∈ F	1305-1
i	≥ 0	sequential	each Xi ∈ F	1305-1
Exercise		sequential	8.14	1306-1
<B>	Develop	action	O	1307-1
O		sequential	n2	1307-1
n2		sequential	an algorithm	1307-1
an algorithm		sequential	that	1307-1
that	as	constraint	input	1307-1
that	takes	action	input	1307-1
input		sequential	a set	1307-1
a set		sequential	F	1307-1
F	of	constraint	fd	1307-1
fd	as	constraint	output	1307-1
fd	and	conjunctive	output	1307-1
fd	produces	action	output	1307-1
output		sequential	a set	1307-1
a set	F′ ≡ F	sequential	F′	1307-1
F′	where has	action	no extraneous attributes	1307-1
Exercise		sequential	8.15	1308-1
Hint		sequential	Hint	1308-2
Exercise		sequential	8.16	1309-1
8.16	be	attribute	a set	1309-1
a set	of	constraint	attributes	1309-1
attributes	and	conjunctive	X	1309-1
X		sequential	Y ⊆ U	1309-1
<B>	Given	action	an instance	1309-2
an instance		sequential	I	1309-2
I	over	constraint	U	1309-2
U	and	conjunctive	a tuple x ∈ πX	1309-2
a tuple x ∈ πX		sequential	I	1309-2
I		sequential	the image Exercises I	1309-2
the image Exercises I	of	constraint	x	1309-2
x	on	constraint	Y	1309-2
Y	in	constraint	the set image	1309-2
Y	is	attribute	the set image	1309-2
the set image		sequential	Y	1309-2
Y		sequential	x	1309-2
x		sequential	I	1309-2
I	=	sequential	πY	1309-2
πY		sequential	σ X=x	1309-2
σ X=x		sequential	I	1309-2
I	of	constraint	tuples	1309-2
tuples	over	constraint	Y	1309-2
<B>	that	constraint	I	1309-3
<B>	Prove	action	I	1309-3
I	→	sequential	X iff	1309-3
X iff	for	constraint	∈	1309-3
X iff	x	sequential	∈	1309-3
∈		sequential	each πX	1309-3
each πX		sequential	I	1309-3
I	and	conjunctive	each z ∈ image	1309-3
each z ∈ image		sequential	Z	1309-3
Z		sequential	x	1309-3
x		sequential	I	1309-3
I		sequential	image	1309-3
image		sequential	Y	1309-3
Y		sequential	x	1309-3
x		sequential	I	1309-3
I	=	sequential	image	1309-3
image		sequential	Y	1309-3
Y		sequential	xz	1309-3
xz		sequential	I	1309-3
I		sequential	Z	1309-3
Z		sequential	U	1309-3
U		sequential	XY	1309-3
XY	and	conjunctive	xz	1309-3
xz	denotes	action	the tuple	1309-3
the tuple	w	constraint	XZ	1309-3
the tuple	over	constraint	XZ	1309-3
XZ	that	constraint	πX	1309-3
πX		sequential	w	1309-3
w	=	sequential	x	1309-3
x	and	conjunctive	πZ	1309-3
πZ		sequential	w	1309-3
w	=	sequential	z	1309-3
Claim		sequential	2	1310-1
2	If	constraint	A	1310-1
A		sequential	B	1310-1
B		sequential	∈ Wi	1310-1
∈ Wi	for	constraint	i	1310-1
i		sequential	∈	1310-1
∈		sequential	1	1310-1
1		sequential	n	1310-1
n		sequential	I	1310-1
I	→	sequential	A B	1310-1
Claim		sequential	3	1311-1
3	For	constraint	i	1311-1
i		sequential	∈	1311-1
∈		sequential	1	1311-1
1	n	conjunctive	I	1311-1
I	→	sequential	<B>	1311-1
Exercise		sequential	8.18	1312-1
8.18	Prove	action	Corollary 8.3.6	1312-1
Exercise		sequential	8.19	1313-1
8.19		sequential	MVD7	1313-1
MVD7		sequential	X	1313-1
MVD8	If	constraint	Y ∩	1314-1
Y ∩		sequential	Z	1314-1
Z	=	sequential	∅	1314-1
∅		sequential	X	1314-1
FMVD3	If	constraint	Y ∩	1315-1
Y ∩		sequential	Z	1315-1
Z	=	sequential	∅	1315-1
∅		sequential	X	1315-1
<B>	that	constraint	MVD7	1316-1
<B>	Prove	action	MVD7	1316-1
MVD7		sequential	MVD2	1316-1
MVD2		sequential	MVD8	1316-1
MVD8		sequential	}	1316-1
}	are	attribute	sound	1316-1
sound	for	constraint	inferring implication	1316-1
sound	and	conjunctive	inferring implication	1316-1
inferring implication	for	constraint	mvd	1316-1
mvd		sequential	s	1316-1
s	and	conjunctive	that FD1	1316-1
that FD1		sequential	FD2	1316-1
FD2		sequential	FD3	1316-1
FD3		sequential	MVD7	1316-1
MVD7		sequential	MVD2	1316-1
MVD2		sequential	MVD8	1316-1
MVD8		sequential	FMVD1	1316-1
FMVD1		sequential	FMVD3	1316-1
FMVD3		sequential	}	1316-1
}	are	attribute	sound	1316-1
sound	for	constraint	inferring implication	1316-1
sound	and	conjunctive	inferring implication	1316-1
inferring implication	for	constraint	fd	1316-1
fd		sequential	s	1316-1
s	and	conjunctive	mvd	1316-1
mvd	s considered together	action	<B>	1316-1
Exercise 8.20 Y ∈ F }		sequential	∪	1317-1
∪	{	sequential	X	1317-1
Hint	For	constraint	an induction	1318-1
Hint	b do	action	an induction	1318-1
an induction	on	constraint	proofs	1318-1
proofs	using	action	the inference rules	1318-1
Exercise		sequential	8.21	1319-1
It	satisfies	action	an mvd X →	1320-1
an mvd X →	or	conjunctive	ξ	1320-1
ξ		sequential	U	1320-1
U	−	sequential	Y	1320-1
Y	=	sequential	T	1320-1
<B>	Given	action	σ	1320-2
σ		sequential	a set F ∪ }	1320-2
a set F ∪ }	of	constraint	fd	1320-2
fd	and	conjunctive	mvd	1320-2
mvd		sequential	F	1320-2
F	implies	action	σ	1320-2
σ	in	constraint	the propositional calculus	1320-2
the propositional calculus	denoted	action	F |=prop σ	1320-2
F |=prop σ	if	constraint	each truth assignment	1320-2
F |=prop σ	for	constraint	each truth assignment	1320-2
each truth assignment	ξ	sequential	F	1320-2
F	implies	action	ξ	1320-2
ξ	|=	sequential	σ	1320-2
<B>	that	constraint	all sets	1320-3
<B>	for	constraint	all sets	1320-3
<B>	Prove	action	all sets	1320-3
all sets		sequential	F ∪ σ	1320-3
F ∪ σ		sequential	}	1320-3
}	of	constraint	fd	1320-3
fd	and	conjunctive	mvd	1320-3
mvd		sequential	F	1320-3
F		sequential	σ iff F |=prop σ	1320-3
<B>	and	conjunctive	Dependency	1321-1
<B>	Join	action	Dependency	1321-1
Exercise		sequential	8.26	1322-1
8.26	Prove	action	Proposition 8.4.6	1322-1
Hint		sequential	Hint	1322-2
Exercise		sequential	8.27	1323-1
Exercise		sequential	8.28	1324-1
Exercise 8.31 Exercises		sequential	Exercise 8.31 Exercises	1325-1
Exercise		sequential	8.32	1326-1
SSD1	If	constraint	A	1327-1
A	is	attribute	an attribute	1327-1
an attribute		sequential	A	1327-1
SSD2	If	constraint	X	1328-1
X	and	conjunctive	Y ⊆	1328-1
Y ⊆		sequential	X	1328-1
X		sequential	Y	1328-1
SSD3	If	constraint	X	1329-1
X		sequential	Y	1329-1
Y	and	conjunctive	X △ Y	1329-1
X △ Y		sequential	XY	1329-1
XY		sequential	X △ Y	1329-1
X △ Y	where denotes	action	X	1329-1
X	−	sequential	Y	1329-1
Y		sequential	∪	1329-1
∪		sequential	Y	1329-1
Y	−	sequential	X	1329-1
X		sequential	the symmetric difference	1329-1
the symmetric difference	of	constraint	X	1329-1
X	and	conjunctive	Y	1329-1
Vittorio		sequential	Fd	1330-1
Fd	and	conjunctive	jd	1330-1
jd	give	action	some structure	1330-1
some structure	to	constraint	relations	1330-1
<B>	But	conjunctive	there	1331-1
there	are	attribute	no connections	1331-1
no connections	between	constraint	them	1331-1
Sergio		sequential	Sergio	1332-1
<B>	.	sequential	<B>	1332-2
<B>	.	sequential	<B>	1332-3
Riccardo		sequential	Riccardo	1333-1
The story	of	constraint	inclusion dependencies	1334-1
inclusion dependencies	in	constraint	a manner	1334-1
inclusion dependencies	starts	action	a manner	1334-1
a manner	to	constraint	functional dependencies	1334-1
a manner	for	constraint	functional dependencies	1334-1
<B>	But	conjunctive	the story	1334-2
the story	and	conjunctive	inclusion	1334-2
the story	becomes	attribute	much more intriguing	1334-2
inclusion		sequential	dependencies	1334-2
dependencies	when are taken together	action	<B>	1334-2
the notion	of	constraint	logical implication	1335-1
logical implication	to	constraint	the behavior	1335-1
logical implication	because	constraint	the behavior	1335-1
logical implication	First will have	action	the behavior	1335-1
logical implication	be refined	action	the behavior	1335-1
the behavior	of	constraint	these dependencies	1335-1
these dependencies	whether	constraint	infinite instances	1335-1
these dependencies	taken together	attribute	different	1335-1
these dependencies	is	attribute	different	1335-1
these dependencies	depending on	action	infinite instances	1335-1
infinite instances	are permitted	action	<B>	1335-1
both notions	of	constraint	logical implication	1335-2
logical implication	are	attribute	Second nonrecursive	1335-2
<B>	And	conjunctive	it	1335-3
it	in	constraint	a formal sense	1335-3
it	third can be proven	action	a formal sense	1335-3
a formal sense	that	constraint	no axiomatization	1335-3
no axiomatization	for	constraint	notion	1335-3
no axiomatization	either	conjunctive	notion	1335-3
no axiomatization	exists	action	notion	1335-3
notion	of	constraint	logical implication	1335-3
logical implication	of	constraint	the dependencies	1335-3
the dependencies	taken together	action	<B>	1335-3
<B>	At	constraint	the end	1335-4
the end	of	constraint	this chapter	1335-4
this chapter		sequential	two restricted classes	1335-4
two restricted classes	of	constraint	inclusion dependencies	1335-4
inclusion dependencies	are discussed	action	<B>	1335-4
<B>	because	constraint	they	1335-5
<B>	are	attribute	significant	1335-5
they	in	constraint	certain natural relationships	1335-5
they	arise	action	certain natural relationships	1335-5
they	modeling	action	certain natural relationships	1335-5
certain natural relationships	in	constraint	semantic data models	1335-5
certain natural relationships	encountered	action	semantic data models	1335-5
Positive results	for	constraint	inclusion dependencies	1336-1
Positive results	have been obtained	action	inclusion dependencies	1336-1
inclusion dependencies	from	constraint	these restricted classes	1336-1
these restricted classes	with	constraint	fd	1336-1
these restricted classes	considered	action	fd	1336-1
fd		sequential	s	1336-1
s	and	conjunctive	other dependencies	1336-1
<B>	Unlike	constraint	fd	1337-1
fd	or	conjunctive	jd	1337-1
jd		sequential	a single inclusion dependency	1337-1
a single inclusion dependency	to	constraint	more than one relation	1337-1
a single inclusion dependency	may refer	action	more than one relation	1337-1
Inclusion Dependency	in	constraint	Isolation	1338-1
<B>	Let	action	R	1338-2
R	be	attribute	a relation schema	1338-2
a relation schema	and	conjunctive	X	1338-2
X	=	sequential	A1	1338-2
<B>	.	sequential	<B>	1338-3
<B>	.	sequential	<B>	1338-4
An a sequence	of	constraint	attributes	1338-5
attributes	with	constraint	possibly repeats	1338-5
possibly repeats	from	constraint	R	1338-5
R	For	constraint	an instance	1338-5
an instance		sequential	I	1338-5
I	of	constraint	R	1338-5
R		sequential	the projection	1338-5
the projection	of	constraint	I	1338-5
I	onto	constraint	the sequence X	1338-5
the sequence X	denoted	action	I	1338-5
I		sequential	X	1338-5
X	is	attribute	the n-ary relation	1338-5
the n-ary relation		sequential	t	1338-5
t		sequential	A1	1338-5
<B>	.	sequential	<B>	1338-6
<B>	.	sequential	<B>	1338-7
t An		sequential	t ∈	1338-8
t ∈		sequential	I	1338-8
I	}	action	<B>	1338-8
The syntax	and	conjunctive	semantics	1339-1
semantics	of	constraint	inclusion dependencies	1339-1
inclusion dependencies	by	constraint	the following 192 Definition 9.1.1	1339-1
inclusion dependencies	is now given	action	the following 192 Definition 9.1.1	1339-1
An inclusion dependency		sequential	ind	1339-2
ind	over	constraint	R	1339-2
R	is	attribute	an expression	1339-2
an expression	of	constraint	the form	1339-2
the form		sequential	σ	1339-2
σ	=	sequential	R	1339-2
R		sequential	A1	1339-2
<B>	.	sequential	<B>	1339-3
<B>	.	sequential	<B>	1339-4
Am ⊆ S		sequential	B1	1339-5
<B>	.	sequential	<B>	1339-6
<B>	.	sequential	<B>	1339-7
Bm		sequential	R S	1339-8
R S	are	attribute	possibly identical	1339-8
where a relation names	in	constraint	R	1339-8
Satisfaction	of	constraint	a set	1340-1
a set	of	constraint	ind	1340-1
ind	in	constraint	the natural manner	1340-1
ind	is defined	action	the natural manner	1340-1
<B>	To	constraint	this definition	1341-1
<B>	illustrate	action	this definition	1341-1
this definition		sequential	we	1341-1
we	recall	action	an example	1341-1
an example	from	constraint	the previous chapter	1341-1
Example		sequential	9.1.2	1342-1
The generalization	of	constraint	ind	1343-1
ind	to	constraint	repeated attributes	1343-1
ind	permit	action	repeated attributes	1343-1
repeated attributes	on	constraint	left	1343-1
left	or	conjunctive	right hand	1343-1
right hand		sequential	the side	1343-1
the side	in	constraint	Exercise 9.4	1343-1
the side	is considered	action	Exercise 9.4	1343-1
The notion	of	constraint	logical implication	1344-1
logical implication	between	constraint	sets	1344-1
sets	of	constraint	ind	1344-1
ind	in	constraint	analogy	1344-1
ind	is defined	action	analogy	1344-1
analogy	with	constraint	fd	1344-1
analogy	for	constraint	fd	1344-1
fd		sequential	<B>	1344-1
<B>	will be refined later	action	fd	1344-2
fd	and	conjunctive	ind	1344-2
ind	when are considered together	action	<B>	1344-2
Rules	for	constraint	Inferring ind Implication	1344-3
The variables		sequential	X	1344-4
X		sequential	Y	1344-4
Y	and	conjunctive	Z	1344-4
Z	over	constraint	sequences	1344-4
Z	range	action	sequences	1344-4
sequences	of	constraint	distinct attributes	1344-4
distinct attributes	and	conjunctive	R	1344-4
R		sequential	S	1344-4
S	and	conjunctive	T range	1344-4
T range	over	constraint	relation names	1344-4
IND1		sequential	reflexivity	1345-1
reflexivity		sequential	R	1345-1
R		sequential	X	1345-1
X		sequential	⊆ R	1345-1
⊆ R		sequential	X	1345-1
IND2		sequential	projection	1346-1
projection	and	conjunctive	permutation	1346-1
<B>	.	sequential	<B>	1346-2
<B>	.	sequential	<B>	1346-3
Am ⊆ S		sequential	B1	1346-4
<B>	.	sequential	<B>	1346-5
<B>	.	sequential	<B>	1346-6
Bm		sequential	R	1346-7
R		sequential	Ai	1346-7
Ai		sequential	1 k	1346-7
1 k		sequential	i1 ik	1346-7
IND3		sequential	transitivity	1347-1
transitivity	If	constraint	R S	1347-1
R S		sequential	X	1347-1
X		sequential	⊆	1347-1
⊆		sequential	Y	1347-1
Y	and	conjunctive	S	1347-1
S		sequential	Y	1347-1
Y		sequential	⊆ T	1347-1
⊆ T		sequential	Z	1347-1
Z		sequential	R	1347-1
R		sequential	X	1347-1
X		sequential	⊆	1347-1
⊆		sequential	T	1347-1
T		sequential	Z	1347-1
The notions	of	constraint	proof	1348-1
proof	of	constraint	provability	1348-1
proof	and	conjunctive	provability	1348-1
provability	denoted	action	these rules	1348-1
provability	using	action	these rules	1348-1
these rules	in	constraint	analogy	1348-1
these rules	are defined	action	analogy	1348-1
analogy	with	constraint	fd	1348-1
analogy	for	constraint	fd	1348-1
fd		sequential	<B>	1348-1
Theorem		sequential	9.1.3	1349-1
Proof Soundness	of	constraint	the rules	1350-1
the rules	is easily verified	action	<B>	1350-1
<B>	For	constraint	completeness	1350-2
completeness	let	action	F	1350-2
F	be	attribute	a set	1350-2
a set	of	constraint	ind	1350-2
ind	over	constraint	database schema	1350-2
database schema		sequential	R	1350-2
R	=	sequential	R1	1350-2
R	{	sequential	R1	1350-2
<B>	.	sequential	<B>	1350-3
<B>	.	sequential	<B>	1350-4
Rn }	and	conjunctive	σ	1350-5
Rn }	let	action	σ	1350-5
σ		sequential	Ra	1350-5
Ra		sequential	A1	1350-5
<B>	.	sequential	<B>	1350-6
<B>	.	sequential	<B>	1350-7
Am		sequential	⊆ Rb	1350-8
⊆ Rb		sequential	B1	1350-8
<B>	.	sequential	<B>	1350-9
<B>	.	sequential	<B>	1350-10
Bm		sequential	Bm	1350-11
We	construct	action	an instance	1350-12
an instance		sequential	I	1350-12
I	of	constraint	R	1350-12
R	and	conjunctive	it	1350-12
R	use	action	it	1350-12
it	to	constraint	F	1350-12
it	that	constraint	F	1350-12
it	demonstrate	action	F	1350-12
F		sequential	σ	1350-12
<B>	To	constraint	s′	1351-1
<B>	begin	action	s′	1351-1
<B>	let	action	s′	1351-1
s′	be	attribute	the tuple	1351-1
the tuple	over	constraint	Ra such	1351-1
Ra such		sequential	that	1351-1
that		sequential	s′	1351-1
s′		sequential	Ai	1351-1
Ai	=	sequential	i	1351-1
i	for	constraint	i	1351-1
i		sequential	∈	1351-1
∈		sequential	1	1351-1
1		sequential	m	1351-1
m	and	conjunctive	s′	1351-1
s′		sequential	B	1351-1
B	= otherwise	sequential	0	1351-1
<B>	Set	action	I	1351-2
I		sequential	Ra	1351-2
Ra	=	sequential	s′	1351-2
s′		sequential	}	1351-2
}	and	conjunctive	I	1351-2
I		sequential	Rj	1351-2
Rj	for	constraint	j	1351-2
Rj	=	sequential	j	1351-2
j		sequential	a	1351-2
We	now apply	action	the following rule	1351-3
the following rule	to	constraint	I	1351-3
I	until	constraint	it	1351-3
it	can no longer be applied	action	<B>	1351-3
<B>	If	constraint	Ri	1352-1
Ri		sequential	C1	1352-1
<B>	.	sequential	<B>	1352-2
<B>	.	sequential	<B>	1352-3
Ck		sequential	⊆ Rj	1352-4
⊆ Rj		sequential	D1	1352-4
<B>	.	sequential	<B>	1352-5
<B>	.	sequential	<B>	1352-6
Dk ∈		sequential	F	1352-7
F	and	conjunctive	t ∈	1352-7
t ∈		sequential	I	1352-7
I		sequential	Ri	1352-7
Ri	add	action	∗ u	1352-7
∗ u	to	constraint	I	1352-7
I		sequential	Rj	1352-7
Rj		sequential	u	1352-7
u		sequential	Dl	1352-7
Dl	where =	sequential	t	1352-7
t		sequential	Cl	1352-7
Cl	for	constraint	l ∈	1352-7
l ∈		sequential	1	1352-7
1		sequential	k	1352-7
k	and	conjunctive	u	1352-7
u		sequential	D	1352-7
D	=	sequential	0	1352-7
0	for	constraint	D	1352-7
Remark		sequential	9.1.4	1353-1
It	because	constraint	the ind	1353-2
It	differs	action	the ind	1353-2
the ind	may be embedded	action	<B>	1353-2
an ind	Intuitively may not specify	action	all the entries	1353-3
all the entries	of	constraint	the tuples	1353-3
the tuples		sequential	we	1353-3
we	are adding	action	<B>	1353-3
<B>	In	constraint	the preceding rule	1353-4
the preceding rule		sequential	the same value	1353-4
the same value		sequential	0	1353-4
0	for	constraint	tuple entries	1353-4
0	∗ is always used	action	tuple entries	1353-4
tuple entries		sequential	that	1353-4
that	are	attribute	otherwise unspecified	1353-4
It	that	constraint	J	1354-1
It	is easily seen	action	J	1354-1
J	|=	sequential	F.	1354-1
F.	Because	constraint	F	1354-1
F	|=	sequential	σ	1354-1
σ		sequential	we	1354-1
we	have	action	J	1354-1
J	|=	sequential	σ	1354-1
<B>	To	constraint	the proof	1354-2
<B>	conclude	action	the proof	1354-2
the proof		sequential	we	1354-2
we	show	attribute	the following	1354-2
<B>	.	sequential	<B>	1354-3
<B>	.	sequential	<B>	1354-4
Cq ∈	in	constraint	sort	1354-5
sort		sequential	Rj	1354-5
Rj		sequential	u	1354-5
u		sequential	Cp	1354-5
Cp		sequential	0	1354-5
0	for	constraint	p	1354-5
p		sequential	1	1354-5
1		sequential	q	1354-5
q		sequential	F	1354-5
F		sequential	Ra	1354-5
Ra		sequential	Au	1354-5
Au		sequential	C1	1354-5
<B>	.	sequential	<B>	1354-6
<B>	.	sequential	<B>	1354-7
Au		sequential	Cq	1354-8
Cq		sequential	⊆ Rj	1354-8
⊆ Rj		sequential	C1	1354-8
<B>	.	sequential	<B>	1354-9
<B>	.	sequential	<B>	1354-10
Cq		sequential	Cq	1354-11
<B>	that	constraint	<B>	1355-1
<B>	Suppose	action	<B>	1355-1
<B>	∗∗ holds	action	<B>	1355-1
<B>	Let	action	s′′	1355-2
s′′	be	attribute	a tuple	1355-2
a tuple	of	constraint	J	1355-2
J		sequential	Rb	1355-2
Rb		sequential	such that s′′	1355-2
such that s′′		sequential	B1	1355-2
<B>	.	sequential	<B>	1355-3
<B>	.	sequential	<B>	1355-4
Bm	=	sequential	s′	1355-5
s′		sequential	A1	1355-5
<B>	.	sequential	<B>	1355-6
<B>	.	sequential	<B>	1355-7
Am		sequential	Am	1355-8
Such a tuple	because	constraint	J	1355-9
Such a tuple	exists	action	J	1355-9
J		sequential	σ	1355-9
<B>	with	constraint	Rj	1355-10
<B>	Use ∗∗	action	Rj	1355-10
Rj	=	sequential	Rb	1355-10
Rb		sequential	q	1355-10
q	=	sequential	m	1355-10
m		sequential	C1	1355-10
<B>	.	sequential	<B>	1355-11
<B>	.	sequential	<B>	1355-12
Cq	=	sequential	B1	1355-13
<B>	.	sequential	<B>	1355-14
<B>	.	sequential	<B>	1355-15
Bm		sequential	Bm	1355-16
<B>	To	constraint	we	1356-1
<B>	demonstrate	action	we	1356-1
we	that	constraint	it	1356-1
we	∗∗ show inductively	action	it	1356-1
it	for	constraint	all tuples	1356-1
it	holds	action	all tuples	1356-1
all tuples	of	constraint	J	1356-1
J	by	constraint	them	1356-1
J	considering	action	them	1356-1
them	in	constraint	the order	1356-1
the order	in	constraint	which	1356-1
which		sequential	they	1356-1
they	were inserted	action	<B>	1356-1
The claim	for	constraint	J	1356-2
The claim	in	constraint	J	1356-2
The claim	holds	attribute	s	1356-2
J		sequential	Ra	1356-2
Ra	by	constraint	IND1	1356-2
<B>	that	constraint	Rj	1357-1
<B>	Suppose now	action	Rj	1357-1
Rj		sequential	D1	1357-1
<B>	.	sequential	<B>	1357-2
<B>	.	sequential	<B>	1357-3
Dk F		sequential	∈	1357-4
∈	and	conjunctive	tuple t ∈	1357-4
<B>	Now let	action	{	1358-1
{		sequential	E1	1358-1
<B>	.	sequential	<B>	1358-2
<B>	.	sequential	<B>	1358-3
Eq		sequential	}	1358-4
}	be	attribute	a set	1358-4
a set	of	constraint	distinct attributes	1358-4
distinct attributes	in	constraint	sort	1358-4
sort		sequential	Rj	1358-4
Rj	with	constraint	u	1358-4
u		sequential	Ep	1358-4
Ep		sequential	0	1358-4
0	for	constraint	p	1358-4
p		sequential	∈ F	1358-4
∈ F		sequential	Ri	1358-4
Ri		sequential	Cρ	1358-4
Cρ		sequential	1	1358-4
<B>	.	sequential	<B>	1358-5
<B>	.	sequential	<B>	1358-6
Cρ		sequential	q	1358-7
q		sequential	⊆ Rj	1358-7
⊆ Rj		sequential	E1	1358-7
<B>	.	sequential	<B>	1358-8
<B>	.	sequential	<B>	1358-9
Eq		sequential	Eq	1358-10
<B>	By	constraint	the inductive assumption	1359-1
the inductive assumption		sequential	F ⊢ Ra	1359-1
F ⊢ Ra	At	constraint	Cρ	1359-1
Cρ		sequential	1	1359-1
<B>	.	sequential	<B>	1359-2
<B>	.	sequential	<B>	1359-3
<B>	At	constraint	Cρ	1359-4
Cρ		sequential	q	1359-4
q		sequential	⊆ Ri	1359-4
⊆ Ri		sequential	Cρ	1359-4
Cρ		sequential	1	1359-4
<B>	.	sequential	<B>	1359-5
<B>	.	sequential	<B>	1359-6
Cρ		sequential	q	1359-7
<B>	by	constraint	IND3	1360-1
IND3		sequential	F	1360-1
F		sequential	Ra	1360-1
Ra	At	constraint	Cρ	1360-1
Cρ		sequential	1	1360-1
<B>	.	sequential	<B>	1360-2
<B>	.	sequential	<B>	1360-3
<B>	At	constraint	Cρ	1360-4
Cρ		sequential	q	1360-4
q		sequential	⊆ Rj	1360-4
⊆ Rj		sequential	E1	1360-4
<B>	.	sequential	<B>	1360-5
<B>	.	sequential	<B>	1360-6
Eq		sequential	Eq	1360-7
<B>	that	constraint	each p	1361-1
<B>	for	constraint	each p	1361-1
<B>	Finally observe	action	each p	1361-1
each p		sequential	t	1361-1
t		sequential	Cρ	1361-1
Cρ		sequential	p	1361-1
p	=	sequential	u	1361-1
u		sequential	Dρ	1361-1
Dρ		sequential	p	1361-1
p	=	sequential	u	1361-1
u		sequential	Ep	1361-1
Ep		sequential	so F	1361-1
so F		sequential	Ra	1361-1
Ra		sequential	Au	1361-1
Au		sequential	E1	1361-1
<B>	.	sequential	<B>	1361-2
<B>	.	sequential	<B>	1361-3
Au		sequential	Eq	1361-4
Eq		sequential	⊆ Rj	1361-4
⊆ Rj		sequential	E1	1361-4
<B>	.	sequential	<B>	1361-5
<B>	.	sequential	<B>	1361-6
Eq		sequential	Eq	1361-7
<B>	Deciding	action	Logical Implication	1362-1
Logical Implication	for	constraint	ind	1362-1
<B>	To	constraint	we	1362-2
<B>	see	attribute	this	1362-2
we	use	action	the following result	1362-2
the following result		sequential	Proposition 9.1.5	1362-2
<B>	.	sequential	<B>	1362-3
<B>	.	sequential	<B>	1362-4
Am		sequential	⊆ Rb	1362-5
⊆ Rb		sequential	B1	1362-5
<B>	.	sequential	<B>	1362-6
<B>	.	sequential	<B>	1362-7
Bm		sequential	Bm	1362-8
Then F		sequential	Ra	1362-9
Ra		sequential	A1	1362-9
<B>	.	sequential	<B>	1362-10
<B>	.	sequential	<B>	1362-11
Am		sequential	⊆ Rb	1362-12
⊆ Rb		sequential	B1	1362-12
<B>	.	sequential	<B>	1362-13
<B>	.	sequential	<B>	1362-14
Bm		sequential	iff	1362-15
iff		sequential	there	1362-15
there	is	attribute	a sequence Ri	1362-15
a sequence Ri		sequential	C Ri	1362-15
C Ri		sequential	C k k	1362-15
C k k		sequential	such that j	1362-15
<B>	.	sequential	<B>	1362-16
<B>	.	sequential	<B>	1362-17
Bm		sequential	C C j j	1362-18
C C j j		sequential	⊆ Rij+1	1362-18
⊆ Rij+1		sequential	j	1362-18
j		sequential	+1	1362-18
+1	from	constraint	an ind	1362-18
+1	can be obtained	action	an ind	1362-18
an ind	in	constraint	F	1362-18
F	by	constraint	one application	1362-18
one application	of	constraint	rule	1362-18
rule		sequential	IND2	1362-18
IND2	for	constraint	j	1362-18
j		sequential	∈	1362-18
∈		sequential	1	1362-18
1		sequential	k	1362-18
k		sequential	1	1362-18
Crux		sequential	Crux	1363-1
<B>	from	constraint	the tuple s′′	1363-2
<B>	Working backward	action	the tuple s′′	1363-2
the tuple s′′	in	constraint	J	1363-2
J		sequential	Rb	1363-2
Rb		sequential	a chain	1363-2
a chain	of	constraint	relation tuple	1363-2
relation tuple		sequential	pairs	1363-2
pairs		sequential	Ri s	1363-2
Ri s		sequential	j j	1363-2
j j	so that	constraint	1	1363-2
j j	of	constraint	1	1363-2
j j	can be constructed	attribute	each	1363-2
<B>	.	sequential	<B>	1363-3
<B>	.	sequential	<B>	1363-4
m	in	constraint	sj	1363-5
m	occurs	action	sj	1363-5
sj	and	conjunctive	sj 1	1363-5
sj 1	into	constraint	I	1363-5
sj 1	+	sequential	I	1363-5
sj 1	is inserted	action	I	1363-5
I	as	constraint	a result	1363-5
a result	of	constraint	sj	1363-5
sj	and	conjunctive	IND2	1363-5
<B>	on	constraint	it	1364-1
<B>	Based	attribute	this	1364-1
it	to	constraint	the following algorithm	1364-1
it	that	constraint	the following algorithm	1364-1
it	is	attribute	straightforward	1364-1
it	verify	action	the following algorithm	1364-1
the following algorithm	determines	action	logical implication	1364-1
logical implication	between	constraint	ind	1364-1
ind		sequential	<B>	1364-1
<B>	that	constraint	only ind	1364-2
<B>	Note	action	only ind	1364-2
only ind	of	constraint	arity m	1364-2
arity m	in	constraint	the algorithm	1364-2
arity m	are considered	action	the algorithm	1364-2
Input		sequential	A set F	1365-1
A set F	of	constraint	ind	1365-1
ind	over	constraint	R	1365-1
R	and	conjunctive	ind	1365-1
ind		sequential	Ra	1365-1
Ra		sequential	A1	1365-1
<B>	.	sequential	<B>	1365-2
<B>	.	sequential	<B>	1365-3
Am		sequential	⊆ Rb	1365-4
⊆ Rb		sequential	B1	1365-4
<B>	.	sequential	<B>	1365-5
<B>	.	sequential	<B>	1365-6
Bm		sequential	Bm	1365-7
Output	whether	constraint	F	1366-1
Output	Determine	action	F	1366-1
F		sequential	Ra	1366-1
Ra		sequential	A1	1366-1
<B>	.	sequential	<B>	1366-2
<B>	.	sequential	<B>	1366-3
Am		sequential	⊆ Rb	1366-4
⊆ Rb		sequential	B1	1366-4
<B>	.	sequential	<B>	1366-5
<B>	.	sequential	<B>	1366-6
Bm		sequential	Bm	1366-7
Procedure	Build	action	a set E	1367-1
a set E	of	constraint	expressions	1367-1
expressions	of	constraint	the form Ri	1367-1
the form Ri		sequential	C1	1367-1
<B>	.	sequential	<B>	1367-2
<B>	.	sequential	<B>	1367-3
Cm	as	constraint	1	1367-4
Cm	follows	action	1	1367-4
E	=	sequential	Ra	1367-5
Ra		sequential	A1	1367-5
<B>	.	sequential	<B>	1367-6
<B>	.	sequential	<B>	1367-7
Am		sequential	}	1367-8
Inclusion Dependency	If	constraint	Ri	1368-1
Ri		sequential	C1	1368-1
<B>	.	sequential	<B>	1368-2
<B>	.	sequential	<B>	1368-3
Cm ∈ E	and	conjunctive	Ri	1368-4
Ri		sequential	C1	1368-4
<B>	.	sequential	<B>	1368-5
<B>	.	sequential	<B>	1368-6
Cm		sequential	⊆ Rj	1368-7
⊆ Rj		sequential	D1	1368-7
<B>	.	sequential	<B>	1368-8
<B>	.	sequential	<B>	1368-9
Dm	from	constraint	an ind	1368-10
Dm	can be derived	action	an ind	1368-10
an ind	of	constraint	F	1368-10
F	by	constraint	one application	1368-10
one application	of	constraint	IND2	1368-10
IND2	insert	action	Rj	1368-10
Rj		sequential	D1	1368-10
<B>	.	sequential	<B>	1368-11
<B>	.	sequential	<B>	1368-12
Dm	into	constraint	E	1368-13
Theorem		sequential	9.1.7	1369-1
Crux		sequential	Crux	1370-1
Linear Space Acceptance		sequential	LSA	1371-1
LSA		sequential	problem Input	1371-1
The heart	of	constraint	the proof	1372-1
the proof	is	attribute	an instance	1372-1
the proof	given	action	an instance	1372-1
an instance		sequential	M x	1372-1
M x	of	constraint	the LSA problem	1372-1
the LSA problem	to	constraint	a set F	1372-1
the LSA problem	construct	action	a set F	1372-1
a set F	of	constraint	ind	1372-1
ind	and	conjunctive	an ind σ such	1372-1
an ind σ such	that	constraint	F	1372-1
F		sequential	σ	1372-1
σ		sequential	iff x	1372-1
iff x	by	constraint	M	1372-1
iff x	is accepted	action	M	1372-1
<B>	Let	action	M	1373-1
M	=	sequential	K	1373-1
K		sequential	K s	1373-1
K s	be	attribute	a Turing machine	1373-1
a Turing machine	with	constraint	states K	1373-1
states K		sequential	alphabet	1373-1
alphabet		sequential	transition relation K	1373-1
transition relation K	start	action	state	1373-1
state	and	conjunctive	state h	1373-1
state	accepting	action	state h	1373-1
state h	and	conjunctive	x x1	1373-1
state h	let	action	x x1	1373-1
<B>	.	sequential	<B>	1373-2
<B>	.	sequential	<B>	1373-3
xn ∈		sequential	xn ∈	1373-4
Configurations	of	constraint	M	1374-1
M	as	constraint	elements	1374-1
M	are viewed	action	elements	1374-1
elements	of	constraint	Ŵ∗KŴ +	1374-1
Ŵ∗KŴ +	with	constraint	length	1374-1
length	n	conjunctive	the placement	1374-1
length	+ 1	sequential	the placement	1374-1
the placement	of	constraint	the state	1374-1
the state	where indicates	action	the head position	1374-1
the head position		sequential	the state	1374-1
the state	of	constraint	the scanned letter	1374-1
the state	is listed	action	the scanned letter	1374-1
the state	immediately left	action	the scanned letter	1374-1
<B>	that	constraint	transitions	1374-2
<B>	Observe	action	transitions	1374-2
transitions	by	constraint	expressions	1374-2
transitions	can be described	action	expressions	1374-2
expressions	of	constraint	the form α1	1374-2
the form α1		sequential	α2	1374-2
α2		sequential	α3	1374-2
α3	→	sequential	β 1	1374-2
β 1	β	sequential	2	1374-2
2	β	sequential	3	1374-2
3	with	constraint	α1	1374-2
<B>	.	sequential	<B>	1374-3
<B>	.	sequential	<B>	1374-4
β in		sequential	3	1374-5
3		sequential	K ∪ Ŵ	1374-5
<B>	For	constraint	instance	1374-6
instance		sequential	the transition	1374-6
the transition	to	constraint	p	1374-6
the transition	corresponds	attribute	a	1374-6
p		sequential	b	1374-6
b	→	sequential	p	1374-6
p		sequential	c	1374-6
c	for	constraint	Ŵ	1374-6
c	in	constraint	Ŵ	1374-6
<B>	Let	action	χ	1374-7
χ	be	attribute	the set	1374-7
the set	of	constraint	all such expressions	1374-7
all such expressions	to	constraint	transitions	1374-7
all such expressions	corresponding	action	transitions	1374-7
transitions	of	constraint	M	1374-7
The initial configuration	is	attribute	sx	1375-1
The final configuration	is	attribute	h bn	1375-2
h bn	for	constraint	some particular letter b	1375-2
some particular letter b		sequential	iff M	1375-2
iff M	accepts	action	x	1375-2
The ind	of	constraint	F	1376-1
F	over	constraint	a single relation R	1376-1
F	are defined	action	a single relation R	1376-1
a single relation R		sequential	The attributes	1376-1
The attributes	of	constraint	R	1376-1
R	are	attribute	Ai	1376-1
Ai		sequential	j	1376-1
j		sequential	i	1376-1
i		sequential	∈	1376-1
The ind σ	is	attribute	R	1377-1
R		sequential	1	1377-1
1		sequential	x1	1377-1
x1		sequential	2	1377-1
<B>	.	sequential	<B>	1377-2
<B>	.	sequential	<B>	1377-3
xn		sequential	n	1377-4
n	+	sequential	1	1377-4
1		sequential	⊆	1377-4
⊆		sequential	R	1377-4
R		sequential	h	1377-4
h		sequential	1	1377-4
1		sequential	b	1377-4
b		sequential	2	1377-4
<B>	.	sequential	<B>	1377-5
<B>	.	sequential	<B>	1377-6
b		sequential	n	1377-7
n	+	sequential	1	1377-7
The ind	in	constraint	F	1378-1
F	to	constraint	valid moves	1378-1
F	correspond	action	valid moves	1378-1
valid moves	of	constraint	M	1378-1
<B>	.	sequential	<B>	1378-2
<B>	.	sequential	<B>	1378-3
j	−	sequential	1	1378-4
1		sequential	j	1378-4
j	+	sequential	3	1378-4
<B>	.	sequential	<B>	1378-5
<B>	.	sequential	<B>	1378-6
n	+	sequential	1 }	1378-7
each ind	in	constraint	F	1378-8
F	Thus has	action	arity 3 + Ŵ|	1378-8
arity 3 + Ŵ|		sequential	n	1378-8
n	−	sequential	2	1378-8
2	and	conjunctive	F| ≤ n|K|	1378-8
construction	in	constraint	the size	1379-1
construction	is	attribute	still polynomial	1379-1
the size	of	constraint	the linear space automaton problem	1379-1
the linear space automaton problem		sequential	M	1379-1
M		sequential	x	1379-1
<B>	Using	action	Proposition 9.1.5	1380-1
Proposition 9.1.5		sequential	it	1380-1
it	to	constraint	F iff M	1380-1
it	that	constraint	F iff M	1380-1
it	is	attribute	now straightforward	1380-1
it	verify	action	F iff M	1380-1
F iff M	|=	sequential	σ	1380-1
σ	has	action	an accepting computation	1380-1
an accepting computation	of	constraint	x	1380-1
<B>	Exercise	action	9.10	1381-1
The latter case	in	constraint	examples	1381-2
The latter case	arises	action	examples	1381-2
examples		sequential	Grad − Stud	1381-2
Grad − Stud		sequential	Name	1381-2
Name		sequential	Major	1381-2
Major		sequential	⊆ Student	1381-2
⊆ Student		sequential	Name	1381-2
Name		sequential	Major	1381-2
This theme	at	constraint	the end	1381-3
This theme	is also examined	action	the end	1381-3
the end	of	constraint	this chapter	1381-3
<B>	versus	constraint	Infinite Implication	1382-1
<B>	of	constraint	a closer look	1382-2
<B>	requires	action	a closer look	1382-2
a closer look	at	constraint	the notion	1382-2
the notion	of	constraint	logical implication	1382-2
<B>	Consider	action	the notion	1383-1
the notion	of	constraint	logical implication	1383-1
logical implication	until	constraint	F	1383-1
logical implication	used	action	F	1383-1
F	logically implies	action	σ	1383-1
σ	if	constraint	relation	1383-1
σ	for	constraint	relation	1383-1
relation	or	conjunctive	database	1383-1
database		sequential	all instances	1383-1
all instances		sequential	I	1383-1
I		sequential	I	1383-1
I	|=	sequential	F	1383-1
F	implies	action	I	1383-1
I	|=	sequential	σ	1383-1
<B>	Although	constraint	this notion	1383-2
this notion	to	constraint	the corresponding notion	1383-2
this notion	is	attribute	the corresponding notion	1383-2
the corresponding notion	of	constraint	mathematical logic	1383-2
mathematical logic		sequential	it	1383-2
it	in	constraint	a crucial way	1383-2
it	is	attribute	different	1383-2
<B>	From	constraint	the point	1383-3
the point	of	constraint	view	1383-3
view	of	constraint	logic	1383-3
logic		sequential	the study	1383-3
the study	of	constraint	logical implication	1383-3
logical implication	within	constraint	finite model theory	1383-3
logical implication	conducted so far	action	finite model theory	1383-3
logical implication	lies	action	finite model theory	1383-3
It	to	constraint	logical implication	1384-1
It	is	attribute	also interesting	1384-1
It	consider	action	logical implication	1384-1
logical implication	in	constraint	the traditional mathematical logic framework	1384-1
the traditional mathematical logic framework	in	constraint	which	1384-1
which		sequential	infinite database instances	1384-1
infinite database instances	are permitted	action	<B>	1384-1
<B>	As	constraint	fd	1384-2
<B>	will be seen shortly	action	fd	1384-2
fd	or	conjunctive	ind	1384-2
ind	when are considered separately	action	infinite instances	1384-2
ind	permitting	action	infinite instances	1384-2
infinite instances	has	action	no impact	1384-2
no impact	on	constraint	logical implication	1384-2
fd	and	conjunctive	ind	1384-3
ind	when are taken together	action	the two flavors	1384-3
the two flavors	of	constraint	logical implication	1384-3
logical implication	However do not coincide	action	<B>	1384-3
The notion	of	constraint	infinite relation	1385-1
infinite relation	and	conjunctive	database instances	1385-1
database instances	in	constraint	the natural manner	1385-1
database instances	is defined	action	the natural manner	1385-1
Inclusion Dependency R B R B		sequential	Inclusion Dependency R B R B	1386-1
Figure		sequential	9.1	1387-1
9.1		sequential	Instances	1387-1
Instances	for	constraint	|=fin	1387-1
Instances	used	action	|=fin	1387-1
Instances	distinguishing	action	|=fin	1387-1
|=fin	and	conjunctive	|=unr Definition 9.2.1	1387-1
<B>	If	constraint	implication	1388-1
<B>	and	conjunctive	implication	1388-1
implication	if	constraint	the kind	1388-1
implication	or	conjunctive	the kind	1388-1
implication	coincide	action	the kind	1388-1
the kind	of	constraint	implication	1388-1
implication	from	constraint	the context	1388-1
implication	is understood	action	the context	1388-1
the context		sequential	we	1388-1
we	may use	action	|=fin	1388-1
|=fin	or	conjunctive	|=unr	1388-1
<B>	is	attribute	what	1388-2
what		sequential	we	1388-2
we	by	constraint	place	1388-2
we	in	constraint	place	1388-2
we	implicitly did so far	action	place	1388-2
we	using	action	place	1388-2
place	of	constraint	|=fin	1388-2
<B>	if	constraint	F |=unr σ F |=fin	1389-1
F |=unr σ F |=fin		sequential	Of course σ	1389-1
<B>	that	constraint	the converse	1389-2
<B>	shows	action	the converse	1389-2
the converse	need not hold	action	Theorem	1389-2
Theorem		sequential	9.2.2	1389-2
Proof	For	constraint	part	1390-1
part	a let	action	R	1390-1
R	with	constraint	attributes	1390-1
R	be	attribute	binary	1390-1
attributes		sequential	A	1390-1
A		sequential	B	1390-1
B	let	action	F	1390-1
F		sequential	A	1390-1
A	→	sequential	B	1390-1
B		sequential	R	1390-1
R		sequential	A	1390-1
A		sequential	R	1390-1
R		sequential	B	1390-1
B	and	conjunctive	σ	1390-1
B	let	action	σ	1390-1
σ	be	attribute	R ⊆ R	1390-1
R ⊆ R		sequential	B	1390-1
B		sequential	A	1390-1
<B>	To	constraint	F |=fin σ	1390-2
<B>	that	constraint	F |=fin σ	1390-2
<B>	see	action	F |=fin σ	1390-2
F |=fin σ	let	action	I	1390-2
I	be	attribute	a finite instance	1390-2
a finite instance	of	constraint	R	1390-2
R		sequential	that	1390-2
that	satisfies	action	F.	1390-2
F.	Because	constraint	I	1390-2
I	→	sequential	A B	1390-2
A B		sequential	πA	1390-2
πA		sequential	I	1390-2
I		sequential	≥ |πB	1390-2
≥ |πB		sequential	I	1390-2
I	because	constraint	I	1390-2
I	and	conjunctive	I	1390-2
I		sequential	R	1390-2
R		sequential	A	1390-2
A		sequential	R	1390-2
R		sequential	B	1390-2
B		sequential	|πB	1390-2
|πB		sequential	I	1390-2
<B>	On	constraint	the other hand	1391-1
the other hand		sequential	the instance	1391-1
the instance	in	constraint	Fig	1391-1
the instance	shown	action	Fig	1391-1
9.1	that	constraint	F |=unr σ	1391-2
9.1	a demonstrates	action	F |=unr σ	1391-2
<B>	For	constraint	part	1392-1
part	b let	action	F	1392-1
F	and	conjunctive	σ	1392-1
F	be	attribute	σ	1392-1
F	let	action	σ	1392-1
σ	be	attribute	the fd B	1392-1
the fd B	→	sequential	A	1392-1
<B>	if	constraint	I	1392-2
I	|=	sequential	F	1392-2
It	to	constraint	implication	1393-1
It	is	attribute	now natural	1393-1
It	reconsider	action	implication	1393-1
implication	for	constraint	fd	1393-1
fd		sequential	jd	1393-1
jd		sequential	s	1393-1
s	and	conjunctive	inds	1393-1
inds	in	constraint	combinations	1393-1
inds	and	conjunctive	combinations	1393-1
inds	taken	action	combinations	1393-1
<B>	and	conjunctive	implication	1393-2
<B>	Are	attribute	unrestricted	1393-2
implication	in	constraint	these cases	1393-2
The answer	by	constraint	the following Theorem	1393-3
The answer	is given	action	the following Theorem	1393-3
the following Theorem		sequential	9.2.3	1393-3
Proof Unrestricted implication	implies	action	finite implication	1394-1
finite implication	by	constraint	definition	1394-1
<B>	For	constraint	fd	1394-2
fd	and	conjunctive	jd	1394-2
jd	or	conjunctive	Theorem 8.4.12	1394-2
jd	s taken	action	Theorem 8.4.12	1394-2
Theorem 8.4.12	on	constraint	the relationship	1394-2
the relationship	between	constraint	chasing	1394-2
chasing	and	conjunctive	logical implication	1394-2
logical implication	to	constraint	the opposite implication	1394-2
logical implication	can be used	action	the opposite implication	1394-2
logical implication	obtain	action	the opposite implication	1394-2
<B>	For	constraint	ind	1394-3
ind		sequential	Theorem 9.1.3	1394-3
Theorem 9.1.3	that	constraint	finite implication	1394-3
Theorem 9.1.3	shows	action	finite implication	1394-3
finite implication	and	conjunctive	provability	1394-3
provability	by	constraint	the ind inference rules	1394-3
the ind inference rules	are	attribute	equivalent	1394-3
It	that	constraint	these rules	1394-4
It	is easily verified	action	these rules	1394-4
these rules	for	constraint	unrestricted implication	1394-4
these rules	are	attribute	also sound	1394-4
finite implication	Thus implies as well	action	unrestricted implication	1394-5
unrestricted implication	for	constraint	ind	1394-5
ind		sequential	<B>	1394-5
The notion finite	of	constraint	unrestricted implication	1395-1
The notion finite	versus	constraint	unrestricted implication	1395-1
unrestricted implication	in	constraint	Chapter 10	1395-1
unrestricted implication	will be revisited	action	Chapter 10	1395-1
Chapter 10		sequential	dependencies	1395-1
dependencies	into	constraint	logic	1395-1
dependencies	where are recast	action	logic	1395-1
logic	based	action	a formalism	1395-1
Implication	for	constraint	fd	1396-1
Implication	Is	attribute	Undecidable	1396-1
fd		sequential	s	1396-1
s	+	sequential	ind	1396-1
ind		sequential	s	1396-1
The Word Problem	for	constraint	Monoids	1397-1
i	∈	action	1	1398-1
1		sequential	n	1398-1
n	be	attribute	a finite set	1398-1
a finite set	of	constraint	equalities	1398-1
equalities	and	conjunctive	e	1398-1
equalities	let	action	e	1398-1
e	be	attribute	an additional equality	1398-1
an additional equality		sequential	α	1398-1
α	=	sequential	β	1398-1
β		sequential	α	1398-1
α		sequential	β	1398-1
β		sequential	∈	1398-1
∈		sequential	<B>	1398-1
E	Then implies	action	e	1398-2
e	denoted	action	E |=unr e	1398-2
E |=unr e		sequential	E |=fin e	1398-2
E |=fin e	if	constraint	monoid M	1398-2
E |=fin e	for	constraint	monoid M	1398-2
monoid M	and	conjunctive	homomorphism	1398-2
homomorphism		sequential	each h	1398-2
each h	→	sequential	M	1398-2
M	if	constraint	h	1398-2
M	=	sequential	h	1398-2
h		sequential	βi	1398-2
βi	for	constraint	i	1398-2
i		sequential	∈	1398-2
∈		sequential	1	1398-2
1		sequential	n	1398-2
n		sequential	h	1398-2
h		sequential	α	1398-2
α	=	sequential	h	1398-2
h		sequential	β	1398-2
The word problem	for	constraint	monoids	1398-3
monoids	to	constraint	E	1398-3
monoids	is	attribute	E	1398-3
monoids	decide	action	E	1398-3
monoids	given	action	E	1398-3
E	and	conjunctive	e	1398-3
e	whether	constraint	E |=unr e	1398-3
E |=unr e		sequential	E |=fin e	1398-3
<B>	Both	conjunctive	the word problem	1398-4
the word problem	for	constraint	monoids	1398-4
monoids	and	conjunctive	the word problem	1398-4
the word problem	for	constraint	finite monoids	1398-4
finite monoids	are	attribute	undecidable	1398-4
<B>	Using	attribute	this	1399-1
we	have	action	the following Theorem	1399-1
the following Theorem		sequential	9.2.4	1399-1
<B>	In	constraint	F	1399-2
<B>	let	action	F	1399-2
F	over	constraint	sets	1399-2
F	range	action	sets	1399-2
sets	of	constraint	fd	1399-2
fd	and	conjunctive	ind	1399-2
ind		sequential	<B>	1399-2
The following sets	are	attribute	not recursive	1399-3
Crux		sequential	Crux	1400-1
The proof	of	constraint	part	1400-2
part	for	constraint	Exercise 9.5	1400-2
part	and	conjunctive	Exercise 9.5	1400-2
part	is	attribute	b similar	1400-2
part	is left	action	Exercise 9.5	1400-2
We	first consider	action	the unrestricted case	1400-3
<B>	Let	action	Ŵ	1401-1
Ŵ	be	attribute	a fixed alphabet	1401-1
<B>	Let	action	E	1401-2
E	=	sequential	αi	1401-2
αi	=	sequential	βi	1401-2
βi		sequential	i	1401-2
i		sequential	∈	1401-2
∈		sequential	1	1401-2
1	n	conjunctive	a set	1401-2
1	be	attribute	a set	1401-2
a set	of	constraint	equalities	1401-2
equalities	over	constraint	e	1401-2
equalities	and	conjunctive	e	1401-2
equalities	let	action	e	1401-2
e	be	attribute	another equality	1401-2
another equality		sequential	α	1401-2
α	=	sequential	β	1401-2
A prefix	to	constraint	any prefix	1401-3
A prefix	be	attribute	any prefix	1401-3
A prefix	is defined	action	any prefix	1401-3
any prefix	of	constraint	α	1401-3
α	or	conjunctive	β	1401-3
β	including	action	the empty string ε	1401-3
the empty string ε	and	conjunctive	full words α1	1401-3
full words α1		sequential	β	1401-3
β		sequential	1	1401-3
1		sequential	<B>	1401-3
A single relation R	is used	action	which	1401-4
which	has	action	attributes	1401-4
attributes		sequential	x	1401-4
x	and	conjunctive	y	1401-4
y	are	attribute	where two fixed symbols	1401-4
<B>	To	constraint	the correspondence	1402-1
<B>	understand	action	the correspondence	1402-1
the correspondence	between	constraint	constrained relations	1402-1
constrained relations	and	conjunctive	homomorphisms	1402-1
homomorphisms	over	constraint	monoids	1402-1
monoids	that	constraint	there	1402-1
monoids	suppose	action	there	1402-1
there	is	attribute	a homomorphism	1402-1
a homomorphism		sequential	h	1402-1
h	from	constraint	Ŵ∗	1402-1
Ŵ∗	to	constraint	some monoid M	1402-1
<B>		sequential	a tuple	1403-1
a tuple	of	constraint	R	1403-1
R	will hold	action	information	1403-1
information	about	constraint	two elements	1403-1
two elements		sequential	h	1403-1
h		sequential	x	1403-1
x		sequential	h	1403-1
h		sequential	y	1403-1
y	of	constraint	M	1403-1
M	in	constraint	columns	1403-1
columns		sequential	Ax	1403-1
Ax		sequential	Ay	1403-1
Ay	and	conjunctive	their product h	1403-1
their product h		sequential	x	1403-1
x		sequential	h	1403-1
h		sequential	y	1403-1
y	=	sequential	h	1403-1
h		sequential	xy	1403-1
xy	in	constraint	column Axy	1403-1
<B>	For	constraint	Ŵ	1404-1
<B>	in	constraint	Ŵ	1404-1
Ŵ		sequential	tuples	1404-1
tuples	will also hold	action	information	1404-1
information	about	constraint	h	1404-1
h		sequential	ya	1404-1
ya	and	conjunctive	h	1404-1
h		sequential	xya	1404-1
xya	in	constraint	columns	1404-1
columns		sequential	Aya	1404-1
Aya		sequential	Axya	1404-1
<B>		sequential	the instance IM	1404-2
the instance IM	to	constraint	the monoid M	1404-2
the instance IM	corresponding	action	the monoid M	1404-2
the monoid M	and	conjunctive	the homomorphism h	1404-2
<B>	to	constraint	the correspondence	1405-1
<B>	force	action	the correspondence	1405-1
the correspondence	between	constraint	the relations	1405-1
the relations	and	conjunctive	homomorphisms	1405-1
homomorphisms	over	constraint	monoids	1405-1
monoids		sequential	we	1405-1
we	Formally use	action	a set F	1405-1
a set F	of	constraint	dependencies	1405-1
<B>	In	constraint	other words	1405-2
other words		sequential	we	1405-2
we	to	constraint	a set F	1405-2
we	wish	action	a set F	1405-2
we	find	action	a set F	1405-2
a set F	of	constraint	dependencies	1405-2
dependencies		sequential	that	1405-2
that	characterizes	action	precisely the instances	1405-2
precisely the instances	over	constraint	R	1405-2
R		sequential	that	1405-2
that	to	constraint	some homomorphism h	1405-2
that	correspond	action	some homomorphism h	1405-2
some homomorphism h	from	constraint	Ŵ∗	1405-2
Ŵ∗	to	constraint	some monoid M	1405-2
<B>	Strictly speaking	action	the dependencies	1405-3
the dependencies	of	constraint	8	1405-3
8	in	constraint	the following list	1405-3
the following list	because	constraint	an attribute	1405-3
the following list	are	attribute	not ind	1405-3
an attribute	in	constraint	left hand	1405-3
an attribute	is repeated	action	left hand	1405-3
left hand		sequential	the side	1405-3
<B>	As	constraint	Exercise 9.4	1405-4
<B>	in	constraint	Exercise 9.4	1405-4
<B>	discussed	action	Exercise 9.4	1405-4
Exercise 9.4		sequential	e	1405-4
e		sequential	the set	1405-4
the set	of	constraint	dependencies	1405-4
dependencies	to	constraint	a set	1405-4
dependencies	used here	action	a set	1405-4
dependencies	can be modified	action	a set	1405-4
a set	of	constraint	proper ind	1405-4
proper ind		sequential	s	1405-4
s		sequential	that	1405-4
that	has	action	the desired properties	1405-4
<B>	In	constraint	addition	1405-5
addition		sequential	we	1405-5
we	use	action	fd	1405-5
fd	with	constraint	hand	1405-5
hand		sequential	an empty side	1405-5
an empty side		sequential	which	1405-5
which	as	constraint	real fd	1405-5
which	are sometimes not considered	action	real fd	1405-5
real fd		sequential	s	1405-5
The use	of	constraint	such dependencies	1405-6
such dependencies	is	attribute	not crucial	1405-6
A slightly more complicated proof	can be found	action	that	1405-7
that	uses	action	only fd	1405-7
only fd	with	constraint	left hand	1405-7
left hand		sequential	a nonempty side	1405-7
The set F	as	constraint	<B>	1405-8
The set F	is defined	action	<B>	1405-8
The set F	follows	action	<B>	1405-8
i		sequential	The ind σ	1406-1
The ind σ	is	attribute	R ⊆ R	1406-1
R ⊆ R		sequential	Aα	1406-1
Aα		sequential	Aβ	1406-1
<B>	Let	action	I	1407-1
I	be	attribute	an instance satisfying	1407-1
<B>	that	constraint	I	1407-2
<B>	Observe	action	I	1407-2
I	to	constraint	a number	1407-2
I	has	action	a number	1407-2
I	satisfy	action	a number	1407-2
a number	of	constraint	implied properties	1407-2
<B>	In	constraint	one	1407-3
one	that	constraint	I	1407-3
one	can verify	action	I	1407-3
I	also satisfies	action	the following property	1407-3
the following property		sequential	R ⊆ R	1407-3
R ⊆ R		sequential	Axya	1407-3
Axya		sequential	Aya	1407-3
Aya		sequential	⊆	1407-3
⊆		sequential	R	1407-3
R		sequential	Ay	1407-3
Ay	=	sequential	R	1407-3
R		sequential	Axy	1407-3
Axy		sequential	⊆ R	1407-3
⊆ R		sequential	Ax	1407-3
We	that	constraint	|=unr σ iff E |=unr e	1408-1
We	now show	action	|=unr σ iff E |=unr e	1408-1
<B>	For	constraint	the opposite direction	1409-1
the opposite direction	that	constraint	E |=unr e	1409-1
the opposite direction	suppose now	action	E |=unr e	1409-1
E |=unr e	and	conjunctive	I	1409-1
E |=unr e	let	action	I	1409-1
I	be	attribute	possibly infinite	1409-1
a instance	of	constraint	R	1409-1
R		sequential	that	1409-1
that	satisfies	action	<B>	1409-1
<B>	To	constraint	the proof	1409-2
<B>	conclude	action	the proof	1409-2
the proof		sequential	it	1409-2
it	that	constraint	I	1409-2
it	must be shown	action	I	1409-2
I		sequential	Aα	1409-2
Aα		sequential	⊆	1409-2
⊆		sequential	I	1409-2
I		sequential	Aβ	1409-2
We	now define	action	a function	1410-1
a function		sequential	h	1410-1
h	→	sequential	adom	1410-1
adom		sequential	I	1410-1
We	that	constraint	h	1410-2
We	will prove	action	h	1410-2
h	is	attribute	a homomorphism	1410-2
a homomorphism	from	constraint	Ŵ∗	1410-2
Ŵ∗	to	constraint	a free monoid	1410-2
a free monoid		sequential	whose elements	1410-2
whose elements	are	attribute	h	1410-2
h	and	conjunctive	the equations	1410-2
h	Ŵ∗ satisfies	action	the equations	1410-2
the equations	of	constraint	E	1410-2
We	now give	action	an inductive definition	1411-1
an inductive definition	of	constraint	h	1411-1
h	that	constraint	it	1411-1
h	and	conjunctive	it	1411-1
h	show	action	it	1411-1
it	has	action	the property	1411-1
the property		sequential	that	1411-1
that		sequential	h v ∈	1411-1
h v ∈		sequential	I	1411-1
I		sequential	Ay	1411-1
Ay	for	constraint	each v ∈	1411-1
Basis		sequential	Basis	1412-1
<B>	that	constraint	h	1412-2
<B>	Note	action	h	1412-2
h		sequential	ε	1412-2
ε	in	constraint	also I	1412-2
ε	is	attribute	also I	1412-2
also I		sequential	Ay	1412-2
Ay	because	constraint	R	1412-2
R		sequential	Aε	1412-2
Aε		sequential	⊆	1412-2
⊆		sequential	R	1412-2
R		sequential	Ay	1412-2
Ay		sequential	∈	1412-2
Inductive step	Given	action	h	1413-1
h		sequential	v	1413-1
v	and	conjunctive	a ∈	1413-1
a ∈	let	action	t	1413-1
t	∈	action	I	1413-1
I	that	constraint	t	1413-1
I	be	attribute	such	1413-1
t		sequential	Ay	1413-1
Ay	=	sequential	h	1413-1
h		sequential	v	1413-1
<B>	Define	action	h	1413-2
h		sequential	va	1413-2
va	=	sequential	t	1413-2
t		sequential	Aya	1413-2
<B>	because	constraint	Ay	1413-3
<B>	is uniquely determined	action	Ay	1413-3
Ay	→	constraint	Aya	1413-3
Aya		sequential	∈	1413-3
<B>	In	constraint	addition	1413-4
addition		sequential	va	1413-4
va		sequential	∈ I	1413-4
∈ I		sequential	Ay	1413-4
Ay	because	constraint	R	1413-4
R		sequential	Ax	1413-4
Ax		sequential	Aya	1413-4
Aya		sequential	Axya	1413-4
Axya		sequential	⊆	1413-4
⊆		sequential	R	1413-4
R		sequential	Ax	1413-4
Ax		sequential	Ay	1413-4
Ay		sequential	Axy	1413-4
Axy		sequential	∈	1413-4
We	by	constraint	induction	1414-1
We	next show	action	induction	1414-1
induction	on	constraint	v	1414-1
v		sequential	that h	1414-1
that h		sequential	u	1414-1
u		sequential	h	1414-1
h		sequential	v	1414-1
v		sequential	h	1414-1
h		sequential	uv	1414-1
uv		sequential	∈	1414-1
∈		sequential	I	1414-1
I		sequential	Ax	1414-1
Ax		sequential	Ay	1414-1
Ay		sequential	Axy	1414-1
Axy	for	constraint	each u	1414-1
each u		sequential	v ∈	1414-1
<B>	For	constraint	a fixed u	1415-1
a fixed u		sequential	the basis	1415-1
the basis		sequential	v	1415-1
v	=	sequential	ε	1415-1
ε	by	constraint	the fact	1415-1
ε	is provided	action	the fact	1415-1
the fact	that	constraint	u	1415-1
u		sequential	∈	1415-1
∈		sequential	I	1415-1
I		sequential	Ay	1415-1
Ay	and	conjunctive	the ind R	1415-1
the ind R		sequential	Ay	1415-1
Ay		sequential	Aε	1415-1
Aε		sequential	Ay	1415-1
Ay		sequential	⊆	1415-1
⊆		sequential	R	1415-1
R		sequential	Ax	1415-1
Ax		sequential	Ay	1415-1
Ay		sequential	Axy	1415-1
Axy		sequential	∈	1415-1
<B>	For	constraint	the inductive step	1415-2
the inductive step	let	action	h	1415-2
h		sequential	u	1415-2
u		sequential	v	1415-2
v		sequential	uv	1415-2
uv		sequential	∈ I	1415-2
∈ I		sequential	Ax	1415-2
Ax		sequential	Ay	1415-2
Ay		sequential	Axy	1415-2
Axy	and	conjunctive	a ∈	1415-2
<B>	Let	action	t	1415-3
t	∈	action	I	1415-3
I	that	constraint	t	1415-3
I	be	attribute	such	1415-3
t		sequential	Ax	1415-3
Ax		sequential	Ay	1415-3
Ay		sequential	Axy	1415-3
Axy	=	sequential	h	1415-3
h		sequential	u	1415-3
u		sequential	h	1415-3
h		sequential	v	1415-3
v		sequential	h	1415-3
h		sequential	uv	1415-3
Inclusion Dependency		sequential	Inclusion Dependency	1416-1
<B>		sequential	the ind R	1416-2
the ind R		sequential	Ax	1416-2
Ax		sequential	Aya	1416-2
Aya		sequential	Axya	1416-2
Axya		sequential	⊆ R	1416-2
⊆ R		sequential	Ax	1416-2
Ax		sequential	Ay	1416-2
Ay		sequential	Axy	1416-2
Axy	that	constraint	u	1416-2
Axy	implies	action	u	1416-2
u		sequential	h	1416-2
h		sequential	va	1416-2
va		sequential	h	1416-2
h		sequential	uva	1416-2
uva		sequential	∈ I	1416-2
∈ I		sequential	Ax	1416-2
Ax		sequential	Ay	1416-2
Ay		sequential	Axy	1416-2
Axy	as	constraint	<B>	1416-2
Axy	desired	action	<B>	1416-2
<B>	Define	action	the binary operation	1417-1
the binary operation	on	constraint	h	1417-1
h	as	constraint	<B>	1417-1
h	Ŵ∗ follows	action	<B>	1417-1
<B>	For	constraint	b ∈	1417-2
b ∈		sequential	h	1417-2
h	Ŵ∗ let	action	a ◦ b	1417-2
a ◦ b	=	sequential	c	1417-2
c	if	constraint	some t ∈	1417-2
c	for	constraint	some t ∈	1417-2
some t ∈		sequential	I	1417-2
I		sequential	t	1417-2
t		sequential	Ax	1417-2
Ax		sequential	Ay	1417-2
Ay		sequential	Axy	1417-2
Axy	=	sequential	b	1417-2
b		sequential	c	1417-2
There	is	attribute	such a tuple	1418-1
such a tuple	by	constraint	c	1418-1
such a tuple	and	conjunctive	c	1418-1
c	because	constraint	Ax	1418-1
c	† is uniquely defined	action	Ax	1418-1
Ax		sequential	Ay	1418-1
Ay		sequential	Axy ∈	1418-1
<B>	by	constraint	each u	1418-2
<B>	for	constraint	each u	1418-2
each u		sequential	v	1418-2
v		sequential	h	1418-2
h		sequential	u	1418-2
u		sequential	◦ h	1418-2
◦ h		sequential	v	1418-2
v	† =	sequential	h	1418-2
h		sequential	uv	1418-2
<B>	for	constraint	h	1418-3
h		sequential	u	1418-3
u		sequential	v	1418-3
v		sequential	h	1418-3
h		sequential	w	1418-3
w	in	constraint	h	1418-3
h		sequential	Ŵ∗	1418-3
Ŵ∗		sequential	h h	1418-3
h h		sequential	u	1418-3
u		sequential	◦	1418-3
◦		sequential	v	1418-3
v		sequential	◦ h	1418-3
◦ h		sequential	w	1418-3
w	=	sequential	h	1418-3
h		sequential	uvw	1418-3
uvw	=	sequential	h	1418-3
h		sequential	u	1418-3
u		sequential	◦	1418-3
◦		sequential	h	1418-3
h		sequential	v	1418-3
v		sequential	h	1418-3
h		sequential	w	1418-3
w		sequential	h	1418-3
h		sequential	u	1418-3
u		sequential	h	1418-3
h		sequential	ε	1418-3
ε	=	sequential	h	1418-3
h		sequential	u	1418-3
u		sequential	h	1418-3
h		sequential	Ŵ∗	1418-3
Ŵ∗	is	attribute	Thus so a monoid	1418-3
<B>	In	constraint	addition	1418-4
addition		sequential	h	1418-4
h	is	attribute	a homomorphism	1418-4
a homomorphism	from	constraint	the free monoid	1418-4
the free monoid	over	constraint	Ŵ∗	1418-4
Ŵ∗	to	constraint	the monoid	1418-4
the monoid		sequential	h	1418-4
h		sequential	Ŵ∗	1418-4
Ŵ∗		sequential	<B>	1418-4
It	to	constraint	I	1419-1
It	that	constraint	I	1419-1
It	is	attribute	easy	1419-1
It	see	action	I	1419-1
I		sequential	Aα	1419-1
Aα	=	sequential	h	1419-1
h		sequential	α	1419-1
α		sequential	i	1419-1
i		sequential	i	1419-1
i		sequential	}	1419-1
}	and	conjunctive	I	1419-1
I		sequential	Aβi i	1419-1
Aβi i	for	constraint	i	1419-1
i		sequential	∈	1419-1
∈		sequential	1	1419-1
1		sequential	n	1419-1
<B>	Let	action	i	1419-2
i	be fixed	action	<B>	1419-2
<B>	Because	constraint	R	1419-3
R		sequential	Aα	1419-3
Aα		sequential	⊆ R	1419-3
⊆ R		sequential	A	1419-3
A		sequential	h	1419-3
h		sequential	α i	1419-3
α i		sequential	i	1419-3
i	=	sequential	h	1419-3
h		sequential	βi	1419-3
<B>	Because	constraint	E |=unr e	1419-4
E |=unr e		sequential	h	1419-4
h		sequential	α	1419-4
α	=	sequential	h	1419-4
h		sequential	β	1419-4
I		sequential	Aα	1419-5
Aα	Thus =	sequential	h	1419-5
h		sequential	α	1419-5
α		sequential	}	1419-5
}	=	sequential	h	1419-5
h		sequential	β	1419-5
β	=	sequential	I	1419-5
I		sequential	Aβ	1419-5
It	that	constraint	I	1419-6
It	follows	action	I	1419-6
I	|=unr	action	R	1419-6
R		sequential	Aα	1419-6
Aα		sequential	⊆ R	1419-6
⊆ R		sequential	Aβ	1419-6
Aβ	as	constraint	<B>	1419-6
Aβ	desired	action	<B>	1419-6
<B>	completes	action	the proof	1420-1
the proof	for	constraint	the unrestricted case	1420-1
<B>	For	constraint	the finite case	1420-2
the finite case	that	constraint	everything	1420-2
the finite case	note	action	everything	1420-2
everything	to	constraint	<B>	1420-2
everything	has	attribute	finite	1420-2
everything	be	attribute	finite	1420-2
The rest	of	constraint	the argument	1420-3
the argument	is	attribute	the same	1420-3
The issue	of	constraint	decidability	1421-1
decidability	of	constraint	implication	1421-1
decidability	and	conjunctive	implication	1421-1
implication	for	constraint	classes	1421-1
classes	of	constraint	dependencies	1421-1
dependencies	in	constraint	Chapter 10	1421-1
dependencies	is revisited	action	Chapter 10	1421-1
Nonaxiomatizability	of	constraint	fd	1422-1
fd		sequential	s	1422-1
s	+	sequential	ind	1422-1
ind		sequential	s	1422-1
<B>	In	constraint	these cases	1422-2
these cases		sequential	the family	1422-2
the family	of	constraint	inference rule schemas	1422-2
inference rule schemas	and	conjunctive	we	1422-2
inference rule schemas	is	attribute	finite	1422-2
we	to	constraint	them	1422-2
we	informally refer	action	them	1422-2
them	as	constraint	finite axiomatizations	1422-2
ground		sequential	A axiomatization	1422-3
A axiomatization	of	constraint	a family S	1422-3
a family S	of	constraint	dependencies	1422-3
dependencies	is	attribute	a set	1422-3
a set	of	constraint	ground inference rules	1422-3
ground inference rules		sequential	that	1422-3
that	for	constraint	implication	1422-3
that	and	conjunctive	implication	1422-3
that	or	conjunctive	implication	1422-3
that	is	attribute	sound	1422-3
implication	for	constraint	S	1422-3
<B>	if	constraint	S	1423-1
<B>	Speaking intuitively	action	S	1423-1
S	has	action	a finite axiomatization	1423-1
a finite axiomatization	if	constraint	there	1423-1
a finite axiomatization	is	attribute	there	1423-1
there	is	attribute	a finite family R′	1423-1
a finite family R′	of	constraint	inference rule schemas	1423-1
inference rule schemas		sequential	that	1423-1
that	for	constraint	S	1423-1
that	and	conjunctive	S	1423-1
that	is	attribute	sound	1423-1
S		sequential	R′	1423-1
R′	specifies	action	a ground axiomatization	1423-1
a ground axiomatization	for	constraint	S	1423-1
S		sequential	that	1423-1
that	both	conjunctive	k- ary	1423-1
that	and	conjunctive	k- ary	1423-1
that	is	attribute	recursive	1423-1
k- ary	for	constraint	some k	1423-1
It	that	constraint	there	1423-2
It	is also known	action	there	1423-2
there	is	attribute	no k-ary axiomatization	1423-2
no k-ary axiomatization	for	constraint	unrestricted implication	1423-2
unrestricted implication	of	constraint	fd	1423-2
fd	and	conjunctive	ind	1423-2
ind		sequential	<B>	1423-2
The intuitive conclusion	that	constraint	the family	1423-3
The intuitive conclusion	is	attribute	the family	1423-3
the family	of	constraint	fd	1423-3
fd	and	conjunctive	ind	1423-3
ind	does not have	action	<B>	1423-3
<B>	To	constraint	the framework	1424-1
<B>	establish	action	the framework	1424-1
the framework	and	conjunctive	some notation	1424-1
some notation		sequential	we	1424-1
we	that	constraint	we	1424-1
we	assume temporarily	action	we	1424-1
we	with	constraint	a family F	1424-1
we	are dealing	action	a family F	1424-1
a family F	of	constraint	database instances	1424-1
database instances	over	constraint	a fixed database schema R	1424-1
<B>	Let	action	S	1425-1
S	be	attribute	a family	1425-1
a family	of	constraint	dependencies	1425-1
dependencies	over	constraint	R.	1425-1
R.	At	constraint	present	1425-1
present		sequential	S	1425-1
S	be	attribute	would the set	1425-1
would the set	of	constraint	fd	1425-1
fd	and	conjunctive	ind	1425-1
ind	over	constraint	R.	1425-1
<B>	In	constraint	|=unr	1425-2
|=unr	and	conjunctive	|=fin	1425-2
|=fin	by	constraint	F	1425-2
|=fin	are obtained	action	F	1425-2
|=fin	letting	action	F	1425-2
F	be	attribute	the set	1425-2
the set	of	constraint	instances	1425-2
the set	or	conjunctive	instances	1425-2
S ⊆ S	and	conjunctive	∈	1426-1
∈		sequential	where S	1426-1
<B>	Let	action	R	1427-1
R	be	attribute	a set	1427-1
a set	of	constraint	rules	1427-1
rules	over	constraint	R	1427-1
<B>	Let	action	<B>	1427-2
The aforementioned notions	to	constraint	all schemas R.	1428-1
The aforementioned notions	are now generalized	action	all schemas R.	1428-1
The aforementioned notions	permit	action	all schemas R.	1428-1
all schemas R.	In	constraint	we	1428-1
we	consider	action	a set R	1428-1
a set R	of	constraint	rules	1428-1
rules		sequential	that	1428-1
that	is	attribute	a union	1428-1
a union		sequential	∪	1428-1
∪		sequential	RR	1428-1
RR		sequential	R	1428-1
R	is	attribute	a schema }	1428-1
The notions	of	constraint	sound	1428-2
sound		sequential	proof	1428-2
proof	in	constraint	the natural fashion	1428-2
proof	be generalized	action	the natural fashion	1428-2
<B>	that	constraint	the preceding definition	1429-1
<B>	with	constraint	the preceding definition	1429-1
<B>	Note	action	the preceding definition	1429-1
the preceding definition		sequential	every set S	1429-1
every set S	of	constraint	dependencies	1429-1
dependencies	has	action	sound	1429-1
sound	and	conjunctive	a axiomatization	1429-1
<B>	by	constraint	the set R	1429-2
<B>	is provided	action	the set R	1429-2
the set R	of	constraint	all rules	1429-2
all rules	of	constraint	the form	1429-2
the form	if	constraint	S	1429-2
S		sequential	S	1429-2
S	|=	sequential	s.	1429-2
s.		sequential	such trivial axiomatizations	1429-2
such trivial axiomatizations	where Clearly hold	action	no interest	1429-2
<B>	In	constraint	they	1429-3
they	are	attribute	not necessarily effective	1429-3
one	to	constraint	a rule	1429-3
one	if	constraint	a rule	1429-3
one	be	attribute	may not able	1429-3
one	tell	action	a rule	1429-3
a rule	in	constraint	R	1429-3
a rule	is	attribute	R	1429-3
R	so	constraint	one	1429-3
one	to	constraint	proofs	1429-3
one	be	attribute	may not able	1429-3
one	construct	action	proofs	1429-3
proofs		sequential	that	1429-3
that	can be checked	action	<B>	1429-3
It	to	constraint	R	1429-4
It	is	attribute	thus natural	1429-4
It	restrict	action	R	1429-4
R	to	constraint	<B>	1429-4
R	be	attribute	recursive	1429-4
We	now present	action	the first result	1430-1
the first result	of	constraint	this section	1430-1
this section		sequential	which	1430-1
which	that	constraint	there	1430-1
which	will imply	action	there	1430-1
there	is	attribute	no recursive axiomatization	1430-1
no recursive axiomatization	for	constraint	finite implication	1430-1
finite implication	of	constraint	fd	1430-1
fd	and	conjunctive	ind	1430-1
ind		sequential	<B>	1430-1
<B>	In	constraint	this result	1430-2
this result		sequential	we	1430-2
we	that	constraint	the dependencies	1430-2
we	assume	action	the dependencies	1430-2
the dependencies	in	constraint	S	1430-2
S	are	attribute	sentences	1430-2
sentences	in	constraint	first order	1430-2
first order		sequential	logic	1430-2
Proposition		sequential	9.3.1	1431-1
<B>	If	constraint	S	1431-2
S	has	action	a recursive axiomatization	1431-2
a recursive axiomatization	for	constraint	finite implications	1431-2
finite implications		sequential	finite implication	1431-2
finite implication	for	constraint	S	1431-2
finite implication	is	attribute	decidable	1431-2
Crux	that	constraint	S	1432-1
Crux	Suppose	action	S	1432-1
S	has	action	a recursive axiomatization	1432-1
<B>	Consider	action	the set Inclusion Dependency	1432-2
the set Inclusion Dependency		sequential	Implic	1432-2
Implic	=	sequential	S s	1432-2
S s		sequential	S ⊆ S	1432-2
S ⊆ S		sequential	∈ S	1432-2
∈ S	and	conjunctive	S |=fin	1432-2
S |=fin		sequential	}	1432-2
First note	that	constraint	the set Implic	1433-1
the set Implic	is	attribute	r.e	1433-1
<B>	indeed let	action	R	1433-2
R	be	attribute	a recursive axiomatization	1433-2
a recursive axiomatization	for	constraint	S	1433-2
Implic	is	attribute	Thus r.e	1433-3
We	that	constraint	Implic	1433-4
We	argue next	action	Implic	1433-4
Implic	is	attribute	also co-r.e	1433-4
<B>	To	constraint	a pair	1434-1
<B>	that	constraint	a pair	1434-1
<B>	conclude	action	a pair	1434-1
a pair		sequential	S s	1434-1
S s	in	constraint	not Implic	1434-1
S s	is	attribute	not Implic	1434-1
not Implic		sequential	it	1434-1
it	to	constraint	a finite instance	1434-1
it	is	attribute	sufficient	1434-1
it	exhibit	action	a finite instance	1434-1
a finite instance	satisfying	action	S	1434-1
S	and	conjunctive	s.	1434-1
S	violating	action	s.	1434-1
The set	of	constraint	all pairs	1434-2
all pairs		sequential	S s	1434-2
S s	is	attribute	clearly r.e.	1434-2
clearly r.e.	as	constraint	the set	1434-2
clearly r.e.	is	attribute	the set	1434-2
the set	of	constraint	all instances	1434-2
all instances	over	constraint	a fixed schema	1434-2
<B>	for	constraint	all positive integers	1434-3
<B>	Repeat	action	all positive integers	1434-3
all positive integers	n	conjunctive	<B>	1434-3
<B>	Enumerate	action	the first n pairs	1434-4
the first n pairs		sequential	S s	1434-4
S s	and	conjunctive	instances	1434-4
S s	n	conjunctive	instances	1434-4
<B>	For	constraint	S s	1434-5
S s	among	constraint	the n	1434-5
the n	whether	constraint	one	1434-5
the n	check	action	one	1434-5
one	of	constraint	the n instances	1434-5
the n instances	is	attribute	a counterexample	1434-5
a counterexample	to	constraint	the implication S	1434-5
the implication S	in	constraint	which	1434-5
the implication S	|=	sequential	which	1434-5
which		sequential	case output	1434-5
case output		sequential	S s	1434-5
this procedure	Clearly enumerates	action	the complement	1434-6
the complement	of	constraint	Implic	1434-6
Implic		sequential	Implic	1434-6
Implic	is	attribute	so co-r.e	1434-6
<B>	Because	constraint	it	1434-7
it	is	attribute	both r.e	1434-7
It	that	constraint	there	1435-1
It	follows	action	there	1435-1
there	is	attribute	no recursive axiomatization	1435-1
no recursive axiomatization	for	constraint	finite implication	1435-1
finite implication	of	constraint	fd	1435-1
fd	and	conjunctive	ind	1435-1
ind		sequential	<B>	1435-1
<B>	To	constraint	Theorem 9.2.4	1435-2
<B>	that	constraint	Theorem 9.2.4	1435-2
<B>	by	constraint	Theorem 9.2.4	1435-2
<B>	see	attribute	this	1435-2
<B>	note	action	Theorem 9.2.4	1435-2
Theorem 9.2.4		sequential	logical implication	1435-2
logical implication	for	constraint	fd	1435-2
fd	and	conjunctive	ind	1435-2
ind		sequential	s	1435-2
s	is	attribute	undecidable	1435-2
<B>	By	constraint	Proposition 9.3.1	1435-3
Proposition 9.3.1		sequential	it	1435-3
it	that	constraint	there	1435-3
it	follows	action	there	1435-3
there	can be	action	no finite axiomatization	1435-3
no finite axiomatization	for	constraint	fd	1435-3
fd	and	conjunctive	ind	1435-3
ind		sequential	s	1435-3
<B>	Because	constraint	implication	1435-4
implication	for	constraint	jd	1435-4
jd	is	attribute	decidable	1435-4
Theorem		sequential	8.4.12	1435-4
8.4.12	but	conjunctive	there	1435-4
there	is	attribute	no axiomatization	1435-4
no axiomatization	for	constraint	them	1435-4
them		sequential	Theorem	1435-4
Theorem		sequential	8.3.4	1435-4
8.3.4		sequential	the converse	1435-4
the converse	of	constraint	the preceding proposition	1435-4
the preceding proposition	does not hold	action	<B>	1435-4
<B>	Speaking intuitively	action	the preceding development	1436-1
the preceding development	that	constraint	there	1436-1
the preceding development	implies	action	there	1436-1
there	is	attribute	no finite set	1436-1
no finite set	of	constraint	inference rule schemas	1436-1
inference rule schemas		sequential	that	1436-1
that	for	constraint	finite implication	1436-1
that	and	conjunctive	finite implication	1436-1
that	is	attribute	sound	1436-1
finite implication	of	constraint	fd	1436-1
fd	and	conjunctive	ind	1436-1
ind		sequential	<B>	1436-1
the proof	is	attribute	However rather indirect	1436-2
the approach	in	constraint	connection	1436-3
the approach	Furthermore can not be used	action	connection	1436-3
connection	with	constraint	unrestricted implication	1436-3
unrestricted implication	with	constraint	classes	1436-3
unrestricted implication	nor	conjunctive	classes	1436-3
classes	of	constraint	dependencies	1436-3
dependencies	for	constraint	which	1436-3
which		sequential	finite implication	1436-3
finite implication	is	attribute	decidable	1436-3
finite implication	see	action	Exercise 9.9	1436-3
The notion	of	constraint	k-ary axiomatization	1436-4
k-ary axiomatization	developed	action	these objections	1436-4
k-ary axiomatization	now shall overcome	action	these objections	1436-4
We	to	constraint	an analog	1437-1
We	now turn	action	an analog	1437-1
an analog	in	constraint	terms	1437-1
terms	of	constraint	logical implication	1437-1
logical implication	of	constraint	k-ary axiomatizability	1437-1
<B>	under	constraint	implication	1438-1
<B>	closed	action	implication	1438-1
implication	with	constraint	respect	1438-1
respect	to	constraint	S	1438-1
S	if	constraint	σ	1438-1
σ		sequential	∈	1438-1
∈		sequential	whenever a σ	1438-1
whenever a σ		sequential	∈ S	1438-1
∈ S	and	conjunctive	σ	1438-1
σ	under	constraint	k-ary implication	1438-1
σ	b closed	action	k-ary implication	1438-1
k-ary implication	with	constraint	respect	1438-1
respect	to	constraint	S	1438-1
S	if	constraint	σ	1438-1
σ		sequential	∈	1438-1
∈		sequential	whenever a σ ∈ S	1438-1
whenever a σ ∈ S	for	constraint	some ⊆	1438-1
whenever a σ ∈ S	and	conjunctive	some ⊆	1438-1
<B>	if	constraint	implication	1439-1
<B>	under	constraint	implication	1439-1
<B>	is closed	action	implication	1439-1
implication		sequential	it	1439-1
it	under	constraint	k-ary implication	1439-1
it	Clearly is closed	action	k-ary implication	1439-1
k-ary implication	for	constraint	each k ≥ 0	1439-1
each k ≥ 0	if	constraint	Ŵ	1439-1
each k ≥ 0	and	conjunctive	Ŵ	1439-1
Ŵ	under	constraint	k-ary implication	1439-1
Ŵ	is closed	action	k-ary implication	1439-1
k-ary implication		sequential	it	1439-1
it	under	constraint	k′-ary implication	1439-1
it	is closed	action	k′-ary implication	1439-1
k′-ary implication	for	constraint	each k′ ≤ k	1439-1
Proposition		sequential	9.3.2	1440-1
there	Then is	action	k ary	1440-2
k ary		sequential	a axiomatization	1440-2
a axiomatization	for	constraint	S iff	1440-2
S iff		sequential	⊆ S	1440-2
⊆ S	under	constraint	k-ary implication	1440-2
⊆ S	whenever is closed	action	k-ary implication	1440-2
k-ary implication	under	constraint	implication	1440-2
k-ary implication	is closed	action	implication	1440-2
Proof	that	constraint	there	1441-1
Proof	Suppose	action	there	1441-1
there	is	attribute	k ary	1441-1
k ary		sequential	a axiomatization	1441-1
a axiomatization	for	constraint	S	1441-1
S	and	conjunctive	Ŵ	1441-1
S	let	action	Ŵ	1441-1
Ŵ	⊆	action	S	1441-1
S	under	constraint	k-ary implication	1441-1
S	be closed	action	k-ary implication	1441-1
<B>	that	constraint	σ	1441-2
<B>	Suppose	attribute	further	1441-2
σ	for	constraint	some σ ∈	1441-2
some σ ∈		sequential	S. Let σ 1	1441-2
<B>	.	sequential	<B>	1441-3
<B>	.	sequential	<B>	1441-4
<B>	be	attribute	a proof	1441-5
a proof	of	constraint	σ	1441-5
σ	from	constraint	R.	1441-5
σ	using	action	R.	1441-5
R.	Using	action	the fact	1441-5
the fact	that	constraint	R	1441-5
R	that	constraint	k-ary implication	1441-5
R	under	constraint	k-ary implication	1441-5
R	and	conjunctive	k-ary implication	1441-5
R	is	attribute	k-ary	1441-5
R	is closed	action	k-ary implication	1441-5
k-ary implication		sequential	a straightforward induction	1441-5
a straightforward induction	that	constraint	∈ ∈	1441-5
a straightforward induction	shows	action	∈ ∈	1441-5
∈ ∈	for	constraint	i	1441-5
i		sequential	1	1441-5
1		sequential	n	1441-5
<B>	that	constraint	⊆	1442-1
<B>	for	constraint	⊆	1442-1
<B>	Suppose now	action	⊆	1442-1
⊆		sequential	each S	1442-1
each S	if	constraint	k-ary implication	1442-1
each S	under	constraint	k-ary implication	1442-1
each S	is closed	action	k-ary implication	1442-1
k-ary implication	under	constraint	implication	1442-1
k-ary implication	is closed	action	implication	1442-1
<B>	Set	action	R	1442-2
R	if	constraint	S	1442-2
R	=	sequential	S	1442-2
S		sequential	S ⊆ S	1442-2
S ⊆ S		sequential	∈ S	1442-2
∈ S		sequential	S|	1442-2
S|		sequential	≤ k	1442-2
≤ k	and	conjunctive	S	1442-2
S		sequential	|= }	1442-2
<B>	To	constraint	R	1443-1
<B>	that	constraint	R	1443-1
<B>	see	action	R	1443-1
R	that	constraint	σ	1443-1
R	|=	sequential	σ	1443-1
R	is	attribute	complete	1443-1
R	suppose	action	σ	1443-1
<B>	Consider	action	the set	1443-2
the set		sequential	Ŵ∗	1443-2
Ŵ∗	=	sequential	γ	1443-2
γ	Ŵ	sequential	⊢R γ	1443-2
<B>	From	constraint	the construction	1443-3
the construction	of	constraint	R	1443-3
R		sequential	Ŵ∗	1443-3
Ŵ∗	under	constraint	k-ary implication	1443-3
Ŵ∗	is closed	action	k-ary implication	1443-3
<B>	By	constraint	assumption	1443-4
assumption		sequential	it	1443-4
it	under	constraint	implication	1443-4
it	is closed	action	implication	1443-4
implication	and	conjunctive	so ⊢R σ	1443-4
so ⊢R σ	as	constraint	<B>	1443-4
so ⊢R σ	desired	action	<B>	1443-4
<B>	In	constraint	we	1444-1
<B>	following	action	we	1444-1
we	consider	action	finite implication	1444-1
finite implication		sequential	F	1444-1
F	is	attribute	so the set	1444-1
so the set	of	constraint	finite instances	1444-1
Theorem		sequential	9.3.3	1445-1
<B>	for	constraint	each k	1445-2
each k		sequential	there	1445-2
there	More specifically is	action	a schema R	1445-2
a schema R	for	constraint	which	1445-2
which		sequential	there	1445-2
there	is	attribute	no k-ary sound	1445-2
no k-ary sound	and	conjunctive	complete axiomatization	1445-2
complete axiomatization	for	constraint	finite implication	1445-2
finite implication	of	constraint	fd	1445-2
fd	and	conjunctive	ind	1445-2
ind	over	constraint	R	1445-2
Proof	Let	action	k	1446-1
k		sequential	≥ 0	1446-1
≥ 0	be fixed	action	<B>	1446-1
<B>	Let	action	R	1446-2
R	=	sequential	R0	1446-2
R	{	sequential	R0	1446-2
<B>	.	sequential	<B>	1446-3
<B>	.	sequential	<B>	1446-4
Rk }	be	attribute	a database schema	1446-5
a database schema		sequential	sort	1446-5
sort		sequential	Ri	1446-5
Ri	where =	sequential	<B>	1446-5
<B>	Let	action	Ŵ	1447-1
Ŵ	be	attribute	the union	1447-1
the union	of	constraint	all fd	1447-1
the union	with	constraint	all fd	1447-1
all fd	and	conjunctive	ind	1447-1
ind		sequential	that	1447-1
that	are	attribute	tautologies	1447-1
tautologies		sequential	that	1447-1
that	by	constraint	all finite instances	1447-1
that	are	attribute	satisfied	1447-1
all finite instances	over	constraint	R	1447-1
<B>	In	constraint	the remainder	1448-1
the remainder	of	constraint	the proof	1448-1
the proof		sequential	it	1448-1
it	that	constraint	finite implication	1448-1
it	under	constraint	finite implication	1448-1
it	is shown	action	finite implication	1448-1
it	1 is not closed	action	finite implication	1448-1
finite implication	under	constraint	k-ary finite implication	1448-1
finite implication	but	conjunctive	k-ary finite implication	1448-1
finite implication	2 is closed	action	k-ary finite implication	1448-1
Proposition 9.3.2	that	constraint	the family	1448-2
Proposition 9.3.2	will imply	action	the family	1448-2
the family	of	constraint	fd	1448-2
fd	and	conjunctive	ind	1448-2
ind		sequential	s	1448-2
s	has	action	no k-ary sound	1448-2
no k-ary sound	and	conjunctive	complete axiomatization	1448-2
complete axiomatization	for	constraint	R	1448-2
<B>	that	constraint	σ	1449-1
<B>	First observe	action	σ	1449-1
<B>	does not contain	action	σ	1449-1
σ	to	constraint	finite implication	1449-1
σ	that	constraint	finite implication	1449-1
σ	under	constraint	finite implication	1449-1
σ	show	action	finite implication	1449-1
σ	is not closed	action	finite implication	1449-1
finite implication		sequential	it	1449-1
it	to	constraint	that |=fin σ	1449-1
it	so suffices	action	that |=fin σ	1449-1
it	demonstrate	action	that |=fin σ	1449-1
<B>	Let	action	I	1449-2
I	be	attribute	a finite instance	1449-2
a finite instance	of	constraint	R	1449-2
R		sequential	that	1449-2
that	satisfies	action	<B>	1449-2
<B>	By	constraint	the ind	1449-3
the ind	of	constraint	I	1449-3
I		sequential	Ri	1449-3
Ri		sequential	A	1449-3
A		sequential	≤ |I	1449-3
≤ |I		sequential	Ri+1	1449-3
Ri+1		sequential	B	1449-3
B	for	constraint	i	1449-3
i		sequential	∈	1449-3
∈		sequential	0	1449-3
0		sequential	k	1449-3
k	by	constraint	the fd	1449-3
k	and	conjunctive	the fd	1449-3
the fd		sequential	s	1449-3
s	of	constraint	I	1449-3
I		sequential	Ri	1449-3
Ri		sequential	B	1449-3
B		sequential	|I	1449-3
|I		sequential	Ri	1449-3
Ri		sequential	A	1449-3
A	for	constraint	i	1449-3
i		sequential	∈	1449-3
∈		sequential	0	1449-3
0		sequential	k	1449-3
<B>	From	constraint	we	1449-4
we	obtain	action	Inclusion Dependency	1449-4
<B>	In	constraint	I	1450-1
I		sequential	Rk	1450-1
Rk		sequential	A	1450-1
A		sequential	|I	1450-1
|I		sequential	R0	1450-1
R0		sequential	B	1450-1
<B>	Since	constraint	I	1450-2
I	and	conjunctive	we	1450-2
I	is	attribute	finite	1450-2
we	have	action	I	1450-2
I		sequential	Rk	1450-2
Rk		sequential	A	1450-2
A		sequential	I	1450-2
I		sequential	R0	1450-2
R0		sequential	B	1450-2
We	that	constraint	k-ary finite implication	1451-1
We	under	constraint	k-ary finite implication	1451-1
We	now show	action	k-ary finite implication	1451-1
We	is closed	action	k-ary finite implication	1451-1
<B>	that	constraint	<B>	1451-2
<B>	$ ⊆	sequential	<B>	1451-2
<B>	Suppose	action	<B>	1451-2
It	that	constraint	γ	1451-3
It	if	constraint	γ	1451-3
It	must be shown	action	γ	1451-3
γ	is	attribute	an fd	1451-3
an fd	or	conjunctive	ind	1451-3
ind	and	conjunctive	γ	1451-3
ind	$ |=fin	sequential	γ	1451-3
γ	γ	sequential	∈	1451-3
<B>	Because	constraint	k 1 ind	1451-4
<B>	+	sequential	k 1 ind	1451-4
<B>	contains	action	k 1 ind	1451-4
k 1 ind		sequential	s	1451-4
s		sequential	any subset	1451-4
any subset	of	constraint	Ŵ	1451-4
any subset	$	sequential	Ŵ	1451-4
Ŵ		sequential	that	1451-4
that	than	constraint	no more k members	1451-4
that	has	action	no more k members	1451-4
no more k members	must omit	action	some ind δ of	1451-4
We	shall exhibit	action	an instance	1451-5
an instance		sequential	I	1451-5
I	that	constraint	I	1451-5
I		sequential	γ	1451-5
γ		sequential	iff	1451-5
iff		sequential	γ ∈	1451-5
γ ∈		sequential	δ	1451-5
δ		sequential	}	1451-5
I	be	attribute	Thus will an Armstrong instance	1451-6
Thus will an Armstrong instance	for	constraint	δ }	1451-6
It	that	constraint	δ	1451-7
It	will follow	action	δ	1451-7
δ	under	constraint	finite implication	1451-7
δ	is closed	action	finite implication	1451-7
<B>	Because	constraint	δ	1451-8
<B>	$ ⊆ Ŵ	sequential	δ	1451-8
δ		sequential	}	1451-8
}	that	constraint	each fd	1451-8
}	for	constraint	each fd	1451-8
}	will imply	action	each fd	1451-8
each fd	or	conjunctive	ind	1451-8
ind		sequential	γ	1451-8
γ	if	constraint	γ	1451-8
γ	$ |=fin	sequential	γ	1451-8
γ		sequential	δ }	1451-8
δ }		sequential	|=fin	1451-8
|=fin		sequential	γ	1451-8
γ		sequential	so γ ∈	1451-8
<B>	Because	constraint	regard	1452-1
<B>	with	constraint	regard	1452-1
<B>	is	attribute	symmetric	1452-1
regard	to	constraint	ind	1452-1
ind		sequential	we	1452-1
we	without	constraint	loss	1452-1
we	can assume	action	loss	1452-1
loss	of	constraint	generality	1452-1
generality		sequential	that	1452-1
that		sequential	δ	1452-1
δ	is	attribute	the ind Rk ⊆ R0	1452-1
the ind Rk ⊆ R0		sequential	A	1452-1
A		sequential	B	1452-1
<B>	that	constraint	N × N	1452-2
<B>	Assuming	action	N × N	1452-2
N × N	in	constraint	the underlying domain	1452-2
N × N	is contained	action	the underlying domain	1452-2
the underlying domain	define	action	I	1452-2
I	that	constraint	I	1452-2
I		sequential	R0	1452-2
R0	so =	sequential	{	1452-2
{		sequential	0	1452-2
0		sequential	0	1452-2
0		sequential	0	1452-2
0		sequential	k	1452-2
k	+	sequential	1	1452-2
1		sequential	1	1452-2
1		sequential	0	1452-2
0		sequential	1	1452-2
1		sequential	k	1452-2
k	+	sequential	1	1452-2
1		sequential	2	1452-2
2		sequential	0	1452-2
0		sequential	1	1452-2
1		sequential	k	1452-2
k	+	sequential	1	1452-2
1		sequential	}	1452-2
}		sequential	I	1452-2
I		sequential	Ri	1452-2
Ri	=	sequential	0	1452-2
Ri	{	sequential	0	1452-2
0		sequential	i	1452-2
i		sequential	0	1452-2
0		sequential	i	1452-2
i		sequential	1	1452-2
1		sequential	1	1452-2
1		sequential	i	1452-2
i		sequential	1	1452-2
1		sequential	i	1452-2
i		sequential	1	1452-2
<B>	.	sequential	<B>	1452-3
<B>	.	sequential	<B>	1452-4
<B>	,	sequential	<B>	1452-5
Figure		sequential	9.2	1453-1
9.2	shows	action	I	1453-1
I	for	constraint	the case	1453-1
the case		sequential	k	1453-1
k	=	sequential	3	1453-1
We	for	constraint	each fd	1454-1
We	now show	action	each fd	1454-1
each fd	and	conjunctive	γ	1454-1
each fd	ind	action	γ	1454-1
γ	over	constraint	R	1454-1
R		sequential	that	1454-1
that		sequential	I	1454-1
I		sequential	γ	1454-1
γ		sequential	iff	1454-1
iff		sequential	γ ∈	1454-1
γ ∈	−	sequential	δ	1454-1
Three cases	arise	action	γ	1454-2
γ	is	attribute	1 a tautology	1454-2
<B>	Then clearly holds	action	<B>	1454-3
Ri	→	sequential	A B	1455-1
A B		sequential	Ri	1455-1
Ri		sequential	B	1455-1
B	→	sequential	A	1455-1
A		sequential	Ri	1455-1
Ri	→	sequential	A	1455-1
A		sequential	Ri	1455-1
Ri		sequential	→ B	1455-1
→ B	or	conjunctive	Ri	1455-1
Ri	→	sequential	AB	1455-1
<B>	If	constraint	γ	1456-1
γ	is	attribute	Ri	1456-1
Ri	→	sequential	A B	1456-1
A B	γ	sequential	∈	1456-1
∈	and	conjunctive	I	1456-1
I	|=	sequential	γ	1456-1
<B>	In	constraint	the other cases	1456-2
the other cases		sequential	γ ∈	1456-2
γ ∈	and	conjunctive	I	1456-2
I	|=	sequential	γ	1456-2
I		sequential	R1	1457-1
R1		sequential	A	1457-1
A		sequential	I	1457-1
I		sequential	R2	1457-1
R2		sequential	B	1457-1
B		sequential	I	1457-1
I		sequential	Rk−1	1457-1
Rk−1		sequential	A	1457-1
A		sequential	I	1457-1
I		sequential	Rk	1457-1
Rk		sequential	B	1457-1
<B>		sequential	I	1458-1
I		sequential	Ri+1	1458-1
Ri+1		sequential	B	1458-1
B		sequential	⊆	1458-1
⊆		sequential	Ri	1458-1
Ri		sequential	A	1458-1
A	for	constraint	i	1458-1
i		sequential	∈	1458-1
∈		sequential	0	1458-1
0		sequential	k	1458-1
k	and	conjunctive	I	1458-1
I		sequential	Ri	1458-1
Ri		sequential	A	1458-1
A		sequential	Ri+1	1458-1
Ri+1		sequential	B	1458-1
<B>	that	constraint	I	1459-1
<B>	implies	action	I	1459-1
I		sequential	γ iff	1459-1
γ iff		sequential	∈	1459-1
∈		sequential	δ	1459-1
δ		sequential	}	1459-1
}	as	constraint	<B>	1459-1
}	desired	action	<B>	1459-1
R0		sequential	I B	1460-1
I B		sequential	R1	1460-1
R1		sequential	I B I	1460-1
I B I		sequential	R2	1460-1
R2		sequential	B I B	1460-1
B I B		sequential	R3	1460-1
R3		sequential	Figure 9.2	1460-1
<B>	In	constraint	proofs	1461-1
proofs	that	constraint	there	1461-1
there	is	attribute	no k-ary axiomatization	1461-1
no k-ary axiomatization	for	constraint	unrestricted implication	1461-1
unrestricted implication	of	constraint	fd	1461-1
fd	and	conjunctive	ind	1461-1
ind	of	constraint	the ind	1461-1
the ind	at	constraint	two attributes	1461-1
the ind	used	attribute	least	1461-1
the ind	involve	attribute	least	1461-1
two attributes	on	constraint	each side	1461-1
<B>	to	constraint	unary ind	1461-2
<B>	can not be improved	action	unary ind	1461-2
unary ind		sequential	s	1461-2
s	because	constraint	there	1461-2
there	is	attribute	2 ary	1461-2
2 ary		sequential	sound	1461-2
sound	and	conjunctive	a axiomatization	1461-2
a axiomatization	for	constraint	unrestricted implication	1461-2
unrestricted implication	of	constraint	unary ind	1461-2
unary ind	and	conjunctive	fd	1461-2
fd	see	action	Exercise 9.18	1461-2
Restricted Kinds	of	constraint	Inclusion Dependency	1462-1
The first one	on	constraint	sets	1462-2
The first one	focuses	action	sets	1462-2
sets	of	constraint	ind	1462-2
ind		sequential	that	1462-2
that	in	constraint	a natural sense	1462-2
that	are	attribute	acyclic	1462-2
a natural sense	and	conjunctive	the ind	1462-2
a natural sense	restricts	action	the ind	1462-2
the ind	to	constraint	only one attribute	1462-2
the ind	having	action	only one attribute	1462-2
only one attribute	on	constraint	either side	1462-2
The restricted dependencies	because	constraint	they	1462-3
The restricted dependencies	are	attribute	important	1462-3
they	to	constraint	many natural relationships	1462-3
they	are	attribute	sufficient	1462-3
they	model	action	many natural relationships	1462-3
many natural relationships	by	constraint	semantic models	1462-3
many natural relationships	captured	action	semantic models	1462-3
semantic models	see	action	Chapter 11	1462-3
<B>	include	action	subtype relationships	1462-4
subtype relationships	of	constraint	the kind	1462-4
the kind		sequential	every student	1462-4
every student	is	attribute	also a person	1462-4
also a person		sequential	This section	1462-4
This section	also presents	action	a generalization	1462-4
a generalization	of	constraint	the chase	1462-4
the chase		sequential	that	1462-4
that	incorporates	action	ind s	1462-4
<B>	Because	constraint	ind	1462-5
ind	in	constraint	this context	1462-5
ind	are embedded	action	this context	1462-5
ind	chasing	action	this context	1462-5
this context	to	constraint	infinite chasing sequences	1462-5
this context	may lead	action	infinite chasing sequences	1462-5
<B>	In	constraint	the context	1463-1
the context	of	constraint	acyclic sets	1463-1
acyclic sets	of	constraint	ind	1463-1
ind		sequential	the chasing sequences	1463-1
the chasing sequences	to	constraint	<B>	1463-1
the chasing sequences	are guaranteed	action	<B>	1463-1
the chasing sequences	terminate	action	<B>	1463-1
The study	of	constraint	infinite chasing sequences	1463-2
infinite chasing sequences	in	constraint	earnest	1463-2
infinite chasing sequences	will be taken up	action	earnest	1463-2
earnest	in	constraint	Chapter 10	1463-2
Inclusion Dependency Ind	and	conjunctive	the Chase	1464-1
the Chase	Because	constraint	ind	1464-1
ind	may involve	action	more than one relation	1464-1
more than one relation		sequential	the formal notation	1464-1
the formal notation	of	constraint	the chase	1464-1
the chase	must be extended	action	<B>	1464-1
<B>	that	constraint	R	1464-2
<B>	Suppose now	action	R	1464-2
R	is	attribute	a database schema	1464-2
a database schema	and	conjunctive	q	1464-2
a database schema	let	action	q	1464-2
q		sequential	T	1464-2
T		sequential	t	1464-2
t	be	attribute	a tableau query	1464-2
a tableau query	over	constraint	R	1464-2
We	first present	action	an example	1465-1
an example	and	conjunctive	the rule	1465-1
an example	describe	action	the rule	1465-1
the rule		sequential	that	1465-1
that	for	constraint	ind	1465-1
that	is used	action	ind	1465-1
ind		sequential	<B>	1465-1
Example		sequential	9.4.1	1466-1
The following rule	for	constraint	ind	1467-1
The following rule	is used	action	ind	1467-1
ind		sequential	<B>	1467-1
ind rule	Let	action	σ	1468-1
σ	=	sequential	R	1468-1
R		sequential	X	1468-1
X		sequential	⊆ S	1468-1
⊆ S		sequential	Y	1468-1
Y	be	attribute	an ind	1468-1
an ind	let	action	u	1468-1
u		sequential	∈	1468-1
∈		sequential	T	1468-1
T		sequential	R	1468-1
R	that	constraint	there	1468-1
R	and	conjunctive	there	1468-1
R	suppose	action	there	1468-1
there	is	attribute	no free tuple v ∈ T	1468-1
no free tuple v ∈ T		sequential	S	1468-1
S		sequential	that	1468-1
that		sequential	v	1468-1
v		sequential	Y	1468-1
Y	=	sequential	u	1468-1
u		sequential	X	1468-1
<B>	In	constraint	this case	1468-2
this case		sequential	we	1468-2
we	that	constraint	σ	1468-2
we	say	action	σ	1468-2
σ	to	constraint	R	1468-2
σ	is	attribute	applicable	1468-2
R		sequential	u	1468-2
<B>	be	attribute	a free tuple	1469-1
<B>	Let	action	a free tuple	1469-1
a free tuple	over	constraint	S such	1469-1
S such		sequential	that	1469-1
that	w	constraint	Y	1469-1
Y	=	sequential	u	1469-1
u		sequential	X	1469-1
X	and	conjunctive	distinct new variables	1469-1
X	w has	action	distinct new variables	1469-1
distinct new variables	in	constraint	all coordinates	1469-1
all coordinates	of	constraint	sort	1469-1
sort		sequential	S	1469-1
<B>		sequential	<B>	1469-2
<B>	For	constraint	a tableau query q	1470-1
a tableau query q	and	conjunctive	a set	1470-1
a set	of	constraint	ind	1470-1
ind		sequential	s	1470-1
s		sequential	it	1470-1
it	that	constraint	two terminal chasing sequences	1470-1
it	is	attribute	possible	1470-1
two terminal chasing sequences	with	constraint	nonisomorphic tableau queries	1470-1
two terminal chasing sequences	end	action	nonisomorphic tableau queries	1470-1
nonisomorphic tableau queries	that	constraint	there	1470-1
there	are	attribute	no finite terminal chasing sequences	1470-1
no finite terminal chasing sequences	that	constraint	there	1470-1
no finite terminal chasing sequences	or	conjunctive	there	1470-1
there	both	conjunctive	finite terminal chasing sequences	1470-1
there	are	attribute	finite terminal chasing sequences	1470-1
finite terminal chasing sequences	and	conjunctive	infinite chasing sequences	1470-1
infinite chasing sequences	see	action	Exercise 9.12	1470-1
General approaches	to	constraint	this problem	1470-2
General approaches	resolving	action	this problem	1470-2
this problem	in	constraint	Chapter 10	1470-2
this problem	will be considered	action	Chapter 10	1470-2
<B>	In	constraint	the present discussion	1470-3
the present discussion		sequential	we	1470-3
we	on	constraint	acyclic sets	1470-3
we	focus	action	acyclic sets	1470-3
acyclic sets	of	constraint	ind	1470-3
ind	for	constraint	which	1470-3
which		sequential	the chase	1470-3
the chase	after	constraint	a finite number	1470-3
the chase	always terminates	action	a finite number	1470-3
a finite number	of	constraint	steps	1470-3
Definition 9.4.2 Si		sequential	Yi	1471-1
Yi		sequential	i	1471-1
i		sequential	∈	1471-1
∈		sequential	1	1471-1
1		sequential	n	1471-1
n	of	constraint	ind	1471-1
ind	in	constraint	i	1471-1
ind	for	constraint	i	1471-1
i		sequential	1	1471-1
1		sequential	n	1471-1
n		sequential	Ri+1	1471-1
Ri+1	=	sequential	Si	1471-1
Si	for	constraint	i ∈	1471-1
i ∈		sequential	1	1471-1
1		sequential	n	1471-1
n	−	sequential	1	1471-1
1	and	conjunctive	R1	1471-1
R1	=	sequential	Sn	1471-1
A family	of	constraint	dependencies	1471-2
dependencies	has	action	acyclic ind	1471-2
acyclic ind	if	constraint	the set in	1471-2
the set in	of	constraint	ind	1471-2
ind	is	attribute	acyclic	1471-2
<B>	is easily verified	action	Exercise 9.14	1472-1
<B>	see	action	Exercise 9.14	1472-1
Exercise 9.14		sequential	Proposition 9.4.3	1472-1
T		sequential	P	1473-1
P		sequential	B C T D E F	1473-1
B C T D E F		sequential	Q	1473-1
Q		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	1	1473-1
1	x	sequential	y	1473-1
y		sequential	2	1473-1
2		sequential	x	1473-1
x		sequential	t y x T B C E F	1473-1
t y x T B C E F		sequential	1 T	1473-1
1 T		sequential	D x	1473-1
D x		sequential	y	1473-1
y		sequential	w	1473-1
w		sequential	x y	1473-1
x y		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	x	1473-1
x		sequential	w t y x T C F	1473-1
w t y x T C F		sequential	1 T	1473-1
1 T		sequential	B E	1473-1
B E		sequential	D x w	1473-1
D x w		sequential	y	1473-1
y		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	w	1473-1
w		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	x	1473-1
x		sequential	t y	1473-1
t y		sequential	1 x T T B C	1473-1
1 x T T B C		sequential	D E F	1473-1
D E F		sequential	x y	1473-1
x y		sequential	x	1473-1
x		sequential	y	1473-1
y		sequential	w	1473-1
w		sequential	1	1473-1
1		sequential	x	1473-1
x		sequential	t	1473-1
t		sequential	y 1 x	1473-1
y 1 x		sequential	Figure	1473-1
Figure		sequential	9.3	1473-1
9.3	with	constraint	ind	1473-1
9.3	Chasing	action	ind	1473-1
ind		sequential	s	1473-1
One	with	constraint	some syntactic strategy	1473-2
One	can easily come up	action	some syntactic strategy	1473-2
some syntactic strategy	for	constraint	this sequence	1473-2
some syntactic strategy	arbitrarily choosing	action	this sequence	1473-2
<B>	Using	action	an analog	1473-3
an analog	to	constraint	Lemma	1473-3
Lemma		sequential	8.4.3	1473-3
8.4.3		sequential	one	1473-3
one	obtains	action	the following result	1473-3
the following result	on	constraint	tableau query containment	1473-3
tableau query containment		sequential	an analog	1473-3
an analog	to	constraint	Theorem 8.4.8	1473-3
Theorem		sequential	9.4.4	1474-1
we	Next consider	action	the application	1475-1
the application	of	constraint	the chase	1475-1
the chase	to	constraint	implication	1475-1
implication	of	constraint	dependencies	1475-1
<B>	For	constraint	database schema	1475-2
database schema		sequential	R	1475-2
R	and	conjunctive	ind	1475-2
ind		sequential	σ	1475-2
σ	=	sequential	R S	1475-2
R S		sequential	X	1475-2
X		sequential	⊆	1475-2
⊆		sequential	Y	1475-2
Y	over	constraint	R	1475-2
R		sequential	the tableau query	1475-2
the tableau query	of	constraint	σ	1475-2
σ	is	attribute	qσ	1475-2
qσ	=	sequential	Inclusion	1475-2
Inclusion		sequential	Dependency x3	1475-2
Dependency x3		sequential	x4	1475-2
<B>	In	constraint	analogy	1475-3
analogy	with	constraint	Theorem	1475-3
Theorem		sequential	8.4.12	1475-3
8.4.12		sequential	we	1475-3
we	for	constraint	fd	1475-3
we	have	action	fd	1475-3
we	the following	action	fd	1475-3
fd		sequential	jd	1475-3
jd	and	conjunctive	ind	1475-3
ind		sequential	<B>	1475-3
Theorem		sequential	9.4.5	1476-1
<B>	yields	attribute	the	1477-1
Unary Inclusion Dependencies		sequential	Unary Inclusion Dependencies	1478-1
<B>	For	constraint	uind	1479-1
uind	in	constraint	isolation	1479-1
uind	s considered	action	isolation	1479-1
isolation		sequential	the inference rules	1479-1
the inference rules	for	constraint	ind	1479-1
ind	to	constraint	the following two rules	1479-1
ind	are specialized	action	the following two rules	1479-1
ind	yield	action	the following two rules	1479-1
the following two rules		sequential	which	1479-1
which	for	constraint	implication	1479-1
which	and	conjunctive	implication	1479-1
which	and	conjunctive	implication	1479-1
which	are	attribute	sound	1479-1
<B>		sequential	A	1479-2
A		sequential	B	1479-2
B	and	conjunctive	C range	1479-2
C range	over	constraint	attributes	1479-2
attributes	and	conjunctive	R	1479-2
R		sequential	S	1479-2
S	and	conjunctive	T	1479-2
T	over	constraint	relation names	1479-2
relation names		sequential	UIND1	1479-2
UIND1		sequential	reflexivity	1479-2
reflexivity		sequential	R	1479-2
R		sequential	A	1479-2
A		sequential	⊆ R	1479-2
⊆ R		sequential	A	1479-2
UIND2		sequential	transitivity	1480-1
transitivity	If	constraint	R S	1480-1
R S		sequential	A	1480-1
A		sequential	⊆	1480-1
⊆		sequential	B	1480-1
B	and	conjunctive	S	1480-1
S		sequential	B	1480-1
B		sequential	⊆ T	1480-1
⊆ T		sequential	C	1480-1
C		sequential	R	1480-1
R		sequential	A	1480-1
A		sequential	⊆	1480-1
⊆		sequential	T	1480-1
T		sequential	C	1480-1
<B>	To	constraint	the interaction	1481-1
<B>	capture	action	the interaction	1481-1
the interaction	of	constraint	fd	1481-1
fd	and	conjunctive	uind	1481-1
uind	in	constraint	the finite case	1481-1
the finite case		sequential	the following family	1481-1
the following family	of	constraint	rules	1481-1
rules	is used	action	C	1481-1
C		sequential	cycle rules	1481-1
Exercises		sequential	Exercises	1482-1
<B>		sequential	we	1483-1
we	have	attribute	the	1483-1
we	following	action	Exercise 9.16	1483-1
we	see	action	Exercise 9.16	1483-1
Exercise 9.16		sequential	Theorem	1483-1
Theorem		sequential	9.4.7	1483-1
Bibliographic Notes Inclusion dependency	on	constraint	the notion	1484-1
Bibliographic Notes Inclusion dependency	is based	action	the notion	1484-1
the notion	of	constraint	referential integrity	1484-1
referential integrity		sequential	which	1484-1
which	to	constraint	the broader database community	1484-1
which	was known	action	the broader database community	1484-1
the broader database community	during	constraint	the 1970s	1484-1
the 1970s	see	action	Dat81	1484-1
A seminal paper	on	constraint	the theory	1484-2
the theory	of	constraint	ind	1484-2
ind	is	attribute	CFP84	1484-2
CFP84	in	constraint	which	1484-2
which		sequential	inference rules	1484-2
inference rules	for	constraint	ind	1484-2
ind	and	conjunctive	the nonaxiomatizability	1484-2
ind	are presented	action	the nonaxiomatizability	1484-2
the nonaxiomatizability	of	constraint	implication	1484-2
the nonaxiomatizability	both	conjunctive	implication	1484-2
the nonaxiomatizability	and	conjunctive	implication	1484-2
implication	for	constraint	fd	1484-2
fd	and	conjunctive	ind	1484-2
ind	is demonstrated	action	<B>	1484-2
<B>		sequential	sound	1484-3
sound	and	conjunctive	A set	1484-3
A set	of	constraint	inference rules	1484-3
inference rules	for	constraint	finite implication	1484-3
finite implication	of	constraint	fd	1484-3
fd	and	conjunctive	ind	1484-3
ind		sequential	s	1484-3
s	in	constraint	Mit83 b	1484-3
s	is presented	action	Mit83 b	1484-3
Another seminal paper	is	attribute	JK84 b	1484-4
JK84 b		sequential	which	1484-4
which	also observed	action	the distinction	1484-4
the distinction	between	constraint	implication	1484-4
the distinction	and	conjunctive	implication	1484-4
implication	for	constraint	fd	1484-4
fd	and	conjunctive	ind	1484-4
ind	generalized	action	the chase	1484-4
the chase	to	constraint	fd	1484-4
the chase	incorporate	action	fd	1484-4
fd	and	conjunctive	ind	1484-4
ind		sequential	s	1484-4
s	to	constraint	containment	1484-4
s	and	conjunctive	containment	1484-4
s	used	attribute	this	1484-4
s	characterize	action	containment	1484-4
containment	between	constraint	conjunctive queries	1484-4
Related work	in	constraint	LMG83	1484-5
Related work	is reported	action	LMG83	1484-5
Undecidability	of	constraint	implication	1485-1
implication	for	constraint	fd	1485-1
fd		sequential	s	1485-1
s	and	conjunctive	ind	1485-1
ind	by	constraint	CV85	1485-1
ind	taken together	action	CV85	1485-1
ind	was shown independently	action	CV85	1485-1
CV85	and	conjunctive	Mit83a	1485-1
The proof	of	constraint	Theorem 9.2.4	1485-2
Theorem 9.2.4	from	constraint	CV85	1485-2
Theorem 9.2.4	is taken	action	CV85	1485-2
<B>	Given	action	the pspace complexity	1486-1
the pspace complexity	of	constraint	implication	1486-1
implication	for	constraint	ind	1486-1
ind	and	conjunctive	the negative results	1486-1
the negative results	in	constraint	connection	1486-1
connection	with	constraint	fd	1486-1
fd		sequential	unary ind	1486-1
unary ind	as	constraint	a more tractable form	1486-1
unary ind	s emerged	action	a more tractable form	1486-1
a more tractable form	of	constraint	inclusion dependency	1486-1
The decision problems	for	constraint	implication	1487-1
The decision problems	and	conjunctive	implication	1487-1
implication	for	constraint	uind	1487-1
uind		sequential	s	1487-1
s	and	conjunctive	fd	1487-1
fd	although	constraint	polynomial time	1487-1
fd	in	constraint	polynomial time	1487-1
fd	s taken together	attribute	not coextensive	1487-1
fd	lie	action	polynomial time	1487-1
polynomial time		sequential	CKV90	1487-1
This extensive paper	also develops	action	axiomatizations	1487-2
axiomatizations	of	constraint	logical implication	1487-2
axiomatizations	both	conjunctive	logical implication	1487-2
axiomatizations	and	conjunctive	logical implication	1487-2
logical implication	for	constraint	unary ind	1487-2
unary ind		sequential	s	1487-2
s	and	conjunctive	fd	1487-2
fd	and	conjunctive	results	1487-2
fd	considered together	action	results	1487-2
fd	develops	action	results	1487-2
results	for	constraint	uind	1487-2
uind	with	constraint	the more general dependencies	1487-2
uind	of	constraint	the more general dependencies	1487-2
the more general dependencies	in	constraint	Chapter 10	1487-2
the more general dependencies	studied	action	Chapter 10	1487-2
ind		sequential	Typed s	1488-1
Typed s	in	constraint	CK86	1488-1
Typed s	are studied	action	CK86	1488-1
<B>	In	constraint	addition	1488-2
addition	to	constraint	traditional techniques	1488-2
addition	using	action	traditional techniques	1488-2
traditional techniques	from	constraint	dependency theory	1488-2
dependency theory	chasing	action	this work	1488-2
this work	develops	action	tools	1488-2
tools	for	constraint	ind	1488-2
tools	analyzing	action	ind	1488-2
ind	using	action	equational theories	1488-2
Ind	in	constraint	connection	1489-1
connection	with	constraint	other dependencies	1489-1
other dependencies	in	constraint	CV83	1489-1
other dependencies	are also studied	action	CV83	1489-1
Exercises	Exercise	attribute	9.1 Complete	1490-1
the proof	of	constraint	Proposition 9.1.5	1490-1
<B>	Exercise	attribute	9.2 Complete	1491-1
the proof	of	constraint	Theorem 9.1.7	1491-1
Exercise		sequential	9.3 B|	1492-1
9.3 B|	{	sequential	R	1492-1
R		sequential	C	1492-1
C		sequential	⊆	1492-1
⊆		sequential	S	1492-1
S		sequential	B D	1492-1
B D		sequential	S	1492-1
S		sequential	B	1492-1
B		sequential	D	1492-1
D		sequential	|=unr R C	1492-1
Inclusion		sequential	Dependency B|	1493-1
Dependency B|		sequential	R ⊆ S	1493-1
R ⊆ S		sequential	C	1493-1
C		sequential	B D	1493-1
B D		sequential	R	1493-1
R		sequential	E	1493-1
E		sequential	⊆ S	1493-1
⊆ S		sequential	B F	1493-1
B F		sequential	S	1493-1
S		sequential	B	1493-1
B		sequential	D	1493-1
D		sequential	|=unr R	1493-1
|=unr R		sequential	C E B D F	1493-1
B|	=	sequential	R ⊆ S	1494-1
R ⊆ S		sequential	C S	1494-1
C S		sequential	B D	1494-1
B D		sequential	R	1494-1
R		sequential	E	1494-1
E		sequential	⊆	1494-1
⊆		sequential	B D	1494-1
B D		sequential	S	1494-1
S		sequential	B	1494-1
B		sequential	D	1494-1
D		sequential	C	1494-1
C	=	sequential	u	1494-1
u		sequential	E	1494-1
E	for	constraint	each u ∈ I	1494-1
each u ∈ I		sequential	R	1494-1
Exercise		sequential	9.4	1495-1
IND4	If	constraint	R ⊆ S	1496-1
R ⊆ S		sequential	A1A2	1496-1
A1A2		sequential	BB	1496-1
BB	and	conjunctive	R	1496-1
R		sequential	C	1496-1
C		sequential	⊆ T	1496-1
⊆ T		sequential	D	1496-1
D		sequential	R	1496-1
R		sequential	C′	1496-1
C′		sequential	⊆	1496-1
⊆		sequential	T	1496-1
T		sequential	D	1496-1
D		sequential	C′	1496-1
C′	from	constraint	C	1496-1
C′	where is obtained	action	C	1496-1
C	by	constraint	one occurrences	1496-1
C	or	conjunctive	one occurrences	1496-1
C	replacing	attribute	more	1496-1
one occurrences	of	constraint	A2	1496-1
A2	by	constraint	A1	1496-1
IND5	If	constraint	R S where	1497-1
R S where		sequential	A1A2	1497-1
A1A2		sequential	⊆	1497-1
⊆		sequential	BB	1497-1
BB	and	conjunctive	T	1497-1
T		sequential	C	1497-1
C		sequential	⊆	1497-1
⊆		sequential	R	1497-1
R		sequential	D	1497-1
D		sequential	T	1497-1
T		sequential	C	1497-1
C		sequential	⊆ R	1497-1
⊆ R		sequential	D′	1497-1
<B>	that	constraint	the inference rules	1498-1
<B>	Prove	action	the inference rules	1498-1
the inference rules		sequential	IND1	1498-1
IND1		sequential	IND2	1498-1
IND2		sequential	IND3	1498-1
IND3		sequential	IND4	1498-1
IND4		sequential	IND5	1498-1
IND5		sequential	}	1498-1
}	are	attribute	sound	1498-1
sound	for	constraint	finite implication	1498-1
sound	and	conjunctive	finite implication	1498-1
finite implication	of	constraint	sets	1498-1
sets	of	constraint	rind	1498-1
rind		sequential	s	1498-1
Exercise		sequential	9.5	1499-1
Exercise		sequential	9.6	1500-1
<B>	Using	action	the same set	1501-1
the same set	find	action	an fd	1501-1
an fd		sequential	that	1501-1
that	in	constraint	place	1501-1
that	can be used	action	place	1501-1
place	of	constraint	σ	1501-1
σ	in	constraint	the proof	1501-1
Exercise		sequential	9.7	1502-1
Exercise		sequential	9.9	1503-1
Exercises		sequential	Exercises	1504-1
Exercise		sequential	9.10	1505-1
Exercise		sequential	9.11	1506-1
Exercise		sequential	9.12	1507-1
Exercise		sequential	9.14	1508-1
<B>	that	constraint	q	1509-1
<B>	Prove	action	q	1509-1
q		sequential	<B>	1509-1
Exercise 9.15 Inclusion Dependency		sequential	Exercise 9.15 Inclusion Dependency	1510-1
Hint		sequential	Hint	1511-1
S		sequential	S	1512-1
<B>	Given	action	a set	1513-1
a set	of	constraint	fd	1513-1
fd	and	conjunctive	uind	1513-1
uind	over	constraint	R	1513-1
R	define	action	G	1513-1
G	to	constraint	a multigraph R	1513-1
G	be	attribute	a multigraph R	1513-1
a multigraph R	with	constraint	node set	1513-1
Exercise		sequential	9.17	1514-1
FD UIND1	If	constraint	A	1515-1
FD UIND1	→	sequential	A	1515-1
A	and	conjunctive	R	1515-1
R		sequential	B	1515-1
B		sequential	⊆	1515-1
⊆		sequential	R	1515-1
R		sequential	A	1515-1
A	→	sequential	B	1515-1
FD UIND1	If	constraint	A	1516-1
FD UIND1	→	sequential	A	1516-1
A	and	conjunctive	R	1516-1
R		sequential	B	1516-1
B		sequential	⊆	1516-1
⊆		sequential	R	1516-1
R		sequential	A	1516-1
A		sequential	R	1516-1
R		sequential	A	1516-1
A		sequential	⊆ R	1516-1
⊆ R		sequential	B	1516-1
Exercises	for	constraint	unrestricted logical implication	1517-1
Exercises	and	conjunctive	unrestricted logical implication	1517-1
Exercises	is	attribute	sound	1517-1
unrestricted logical implication	of	constraint	fd	1517-1
fd	and	conjunctive	uind	1517-1
uind	over	constraint	a single relation schema R	1517-1
fd s		sequential	s	1518-1
s		sequential	jd	1518-1
jd		sequential	mvd ejd ’ s	1518-1
mvd ejd ’ s		sequential	s	1518-1
s		sequential	emvd	1518-1
emvd		sequential	s	1518-1
s		sequential	ind	1518-1
ind		sequential	s—it	1518-1
s—it	s all getting	attribute	very confusing	1518-1
Vittorio	Wait	action	<B>	1519-1
We	’ ll use	action	logic	1519-2
logic	to	constraint	it all	1519-2
logic	unify	action	it all	1519-2
Sergio		sequential	Sergio	1520-1
Logic	will make	action	everything	1520-2
everything		sequential	crystal	1520-2
crystal		sequential	<B>	1520-2
Riccardo		sequential	Riccardo	1521-1
The dependencies	in	constraint	the previous chapters	1522-1
The dependencies	studied	action	the previous chapters	1522-1
the previous chapters	have	action	a strong practical motivation	1522-1
a strong practical motivation	and	conjunctive	a good setting	1522-1
a strong practical motivation	provide	action	a good setting	1522-1
a good setting	for	constraint	two	1522-1
a good setting	studying	action	two	1522-1
two	of	constraint	the fundamental issues	1522-1
the fundamental issues	in	constraint	dependency theory	1522-1
dependency theory	deciding	action	logical implication	1522-1
logical implication	and	conjunctive	axiomatizations	1522-1
logical implication	constructing	action	axiomatizations	1522-1
Several new dependencies	in	constraint	the late 1970s	1523-1
Several new dependencies	were introduced	action	the late 1970s	1523-1
the late 1970s	and	conjunctive	early 1980s	1523-1
early 1980s	by	constraint	practical examples	1523-1
early 1980s	sometimes motivated	action	practical examples	1523-1
practical examples	by	constraint	a desire	1523-1
practical examples	and	conjunctive	a desire	1523-1
practical examples	later motivated	action	a desire	1523-1
a desire	to	constraint	fundamental theoretical properties	1523-1
a desire	understand	action	fundamental theoretical properties	1523-1
fundamental theoretical properties	of	constraint	unirelational dependencies	1523-1
unirelational dependencies	to	constraint	axiomatizations	1523-1
unirelational dependencies	or	conjunctive	axiomatizations	1523-1
unirelational dependencies	find	action	axiomatizations	1523-1
axiomatizations	for	constraint	known classes	1523-1
known classes	of	constraint	dependencies	1523-1
This process	with	constraint	a rather general perspective	1523-2
This process	culminated	action	a rather general perspective	1523-2
a rather general perspective	on	constraint	dependencies	1523-2
dependencies	from	constraint	mathematical logic	1523-2
dependencies	stemming	action	mathematical logic	1523-2
The purpose	of	constraint	this chapter	1523-3
this chapter	to	constraint	this general class	1523-3
this chapter	is	attribute	this general class	1523-3
this chapter	introduce	action	this general class	1523-3
this general class	of	constraint	dependencies	1523-3
dependencies	and	conjunctive	its natural subclasses	1523-3
its natural subclasses	to	constraint	important results	1523-3
its natural subclasses	and	conjunctive	important results	1523-3
its natural subclasses	present	action	important results	1523-3
important results	and	conjunctive	techniques	1523-3
techniques	for	constraint	them	1523-3
techniques	obtained	action	them	1523-3
The general perspective	in	constraint	the first section	1524-1
The general perspective	is given	action	the first section	1524-1
the first section	along	constraint	a simple application	1524-1
the first section	with	constraint	a simple application	1524-1
a simple application	of	constraint	logic	1524-1
logic	to	constraint	the decidability	1524-1
logic	obtain	action	the decidability	1524-1
the decidability	of	constraint	implication	1524-1
implication	for	constraint	a large class	1524-1
a large class	of	constraint	dependencies	1524-1
It	that	constraint	the chase	1524-2
It	turns out	action	the chase	1524-2
the chase	is	attribute	an invaluable tool	1524-2
an invaluable tool	for	constraint	implication	1524-2
an invaluable tool	analyzing	action	implication	1524-2
implication	in	constraint	the second section	1524-2
implication	is studied	action	the second section	1524-2
Axiomatizations	for	constraint	important subclasses	1524-3
important subclasses	have been developed	action	the chase	1524-3
important subclasses	again using	action	the chase	1524-3
the chase	is	attribute	the topic	1524-3
the topic	of	constraint	the third section	1524-3
We	conclude	action	the chapter	1524-4
the chapter	with	constraint	a provocative alternative view	1524-4
a provocative alternative view	of	constraint	dependencies	1524-4
dependencies	from	constraint	relational algebra	1524-4
dependencies	stemming	action	relational algebra	1524-4
The classes	of	constraint	dependencies	1525-1
dependencies	in	constraint	this chapter	1525-1
dependencies	studied	action	this chapter	1525-1
this chapter	include	action	complex dependencies	1525-1
complex dependencies		sequential	that	1525-1
that	in	constraint	practice	1525-1
that	would not generally arise	action	practice	1525-1
<B>	if	constraint	they	1525-2
they	Even did arise	action	they	1525-2
they	that	constraint	they	1525-2
they	are	attribute	so intricate	1525-2
they	be	attribute	would probably unusable	1525-2
it	that	constraint	database administrators	1525-2
it	is	attribute	unlikely	1525-2
database administrators	to	constraint	them	1525-2
database administrators	would bother	action	them	1525-2
database administrators	write down	action	them	1525-2
them	that	constraint	software	1525-2
them	or	conjunctive	software	1525-2
software	to	constraint	them	1525-2
software	or	conjunctive	them	1525-2
software	would be developed	action	them	1525-2
software	use	action	them	1525-2
software	enforce	action	them	1525-2
it	to	constraint	the perspective	1525-3
it	that	constraint	the perspective	1525-3
it	is	attribute	Nevertheless important	1525-3
it	repeat	action	the perspective	1525-3
the perspective	and	conjunctive	results	1525-3
results	in	constraint	this chapter	1525-3
results	discussed	action	this chapter	1525-3
this chapter	have served	action	the important function	1525-3
the important function	of	constraint	a unified understanding	1525-3
the important function	providing	action	a unified understanding	1525-3
a unified understanding	of	constraint	virtually all dependencies	1525-3
virtually all dependencies	in	constraint	the literature	1525-3
virtually all dependencies	raised	action	the literature	1525-3
the literature	in	constraint	insight	1525-3
the literature	of	constraint	insight	1525-3
the literature	and	conjunctive	insight	1525-3
the literature	providing	action	insight	1525-3
insight	into	constraint	the boundaries	1525-3
the boundaries	between	constraint	problems	1525-3
the boundaries	and	conjunctive	problems	1525-3
problems	in	constraint	the area	1525-3
The fundamental property	of	constraint	the dependencies	1526-1
The fundamental property	of	constraint	the dependencies	1526-1
the dependencies	that	constraint	they	1526-1
the dependencies	is	attribute	they	1526-1
the dependencies	introduced so far	action	they	1526-1
they	essentially say	action	The presence	1526-1
The presence	of	constraint	some tuples	1526-1
some tuples	in	constraint	the instance	1526-1
the instance	implies	action	the presence	1526-1
the presence	of	constraint	certain other tuples	1526-1
certain other tuples	in	constraint	the instance	1526-1
the instance	that	constraint	certain tuple components	1526-1
the instance	or	conjunctive	certain tuple components	1526-1
the instance	implies	action	certain tuple components	1526-1
certain tuple components	are	attribute	equal	1526-1
<B>	In	constraint	any case	1526-2
any case	of	constraint	the dependencies	1526-2
the dependencies	discussed so far	action	first order	1526-2
the dependencies	can be expressed	action	first order	1526-2
the dependencies	using	action	first order	1526-2
first order		sequential	logic sentences	1526-2
logic sentences	of	constraint	the form	1526-2
<B>	Because	constraint	we	1527-1
we	on	constraint	sets	1527-1
we	generally focus	action	sets	1527-1
sets	of	constraint	dependencies	1527-1
dependencies		sequential	we	1527-1
we	make	action	several simplifying assumptions	1527-1
several simplifying assumptions	before	constraint	Exercise 10.1a	1527-1
several simplifying assumptions	continuing	action	Exercise 10.1a	1527-1
several simplifying assumptions	see	action	Exercise 10.1a	1527-1
<B>	that	constraint	we	1527-2
<B>	include	action	we	1527-2
we	1 may eliminate	action	equality atoms	1527-2
equality atoms	from	constraint	expressive power	1527-2
equality atoms	without	constraint	expressive power	1527-2
equality atoms	losing	action	expressive power	1527-2
expressive power	and	conjunctive	we	1527-2
we	without	constraint	loss	1527-2
we	2 can also assume	action	loss	1527-2
loss	of	constraint	generality	1527-2
generality		sequential	that	1527-2
that		sequential	no existentially quantified variable	1527-2
no existentially quantified variable	in	constraint	an equality atom	1527-2
no existentially quantified variable	participates	action	an equality atom	1527-2
an equality atom	in	constraint	ψ	1527-2
we	Thus define where	action	an embedded dependency	1527-3
an embedded dependency	to	constraint	a sentence	1527-3
an embedded dependency	be	attribute	a sentence	1527-3
a sentence	of	constraint	the foregoing form	1527-3
We	now present	action	three fundamental classifications	1528-1
three fundamental classifications	of	constraint	dependencies	1528-1
<B>	versus	constraint	<B>	1529-1
<B>	embedded	action	<B>	1529-1
Tuple	versus	constraint	equality	1530-1
Tuple	generating	action	equality	1530-1
equality	generating	action	<B>	1530-1
<B>	versus	constraint	<B>	1531-1
<B>	Typed	attribute	untyped	1531-1
It	to	constraint	dependencies	1532-1
It	is	attribute	sometimes important	1532-1
It	distinguish	action	dependencies	1532-1
dependencies	with	constraint	a single atom	1532-1
a single atom	in	constraint	right hand	1532-1
right hand		sequential	the formula	1532-1
A dependency	is	attribute	single head	1532-2
single head	if	constraint	hand	1532-2
hand		sequential	the formula	1532-2
the formula	involves	action	a single atom	1532-2
a single atom		sequential	it	1532-2
it	is	attribute	multi- head otherwise	1532-2
The following result	is easily verified	action	Exercise	1533-1
Exercise		sequential	10.1 b	1533-1
Untyped ind		sequential	Embedded Typed jd tgd ’ ’ s tgd s Proposition 10.1.1	1534-1
Embedded Typed jd tgd ’ ’ s tgd s Proposition 10.1.1		sequential	s Full fd ’ s mvd ’ s egd ’ s s	1534-1
s Full fd ’ s mvd ’ s egd ’ s s		sequential	Single	1534-1
Single		sequential	head	1534-1
head		sequential	Multi tgd	1534-1
Multi tgd		sequential	head	1534-1
head		sequential	Figure	1534-1
Figure		sequential	10.1	1534-1
10.1		sequential	Dependencies	1534-1
Dependencies	typed	action	Each dependency	1534-1
Each dependency	to	constraint	a set	1534-1
Each dependency	is	attribute	equivalent	1534-1
a set	of	constraint	typed egd	1534-1
It	to	constraint	the fd	1535-1
It	is	attribute	easy	1535-1
It	classify	action	the fd	1535-1
the fd		sequential	jd s	1535-1
jd s		sequential	mvd s	1535-1
mvd s		sequential	s	1535-1
s		sequential	ejd ’	1535-1
ejd ’		sequential	emvd ’ s	1535-1
emvd ’ s	and	conjunctive	ind	1535-1
ind		sequential	s	1535-1
s	in	constraint	Chapters 8	1535-1
s	studied	action	Chapters 8	1535-1
<B>	for	constraint	negative results	1536-1
negative results		sequential	the typed case	1536-1
the typed case	However sometimes requires	action	more sophisticated proof techniques	1536-1
more sophisticated proof techniques	because	constraint	it	1536-1
it	imposes	action	more restrictions	1536-1
There	is	attribute	a strong relationship	1537-1
a strong relationship	between	constraint	dependencies	1537-1
dependencies	and	conjunctive	tableaux	1537-1
Tableaux	provide	action	a convenient notation	1537-2
a convenient notation	for	constraint	dependencies	1537-2
a convenient notation	with	constraint	dependencies	1537-2
a convenient notation	and	conjunctive	dependencies	1537-2
a convenient notation	expressing	action	dependencies	1537-2
a convenient notation	working	action	dependencies	1537-2
<B>	As	constraint	Section 10.4	1537-3
<B>	in	constraint	Section 10.4	1537-3
<B>	will be seen	action	Section 10.4	1537-3
Section 10.4		sequential	the family	1537-3
the family	of	constraint	typed dependencies	1537-3
typed dependencies	can also be represented	action	a formalism	1537-3
typed dependencies	using	action	a formalism	1537-3
a formalism	on	constraint	algebraic expressions	1537-3
a formalism	based	action	algebraic expressions	1537-3
The tableau representation	of	constraint	egd	1537-4
egd		sequential	two untyped s	1537-4
two untyped s	in	constraint	Figs	1537-4
two untyped s	is shown	action	Figs	1537-4
10.2	and	conjunctive	10.2	1537-5
10.2		sequential	b	1537-5
two egd		sequential	These s	1537-6
These s	are	attribute	equivalent	1537-6
<B>	that	constraint	all egd s	1537-7
<B>	Note	action	all egd s	1537-7
all egd s	as	constraint	a pair	1537-7
all egd s	can be expressed	action	a pair	1537-7
a pair		sequential	T	1537-7
T		sequential	x	1537-7
x	=	sequential	y	1537-7
y		sequential	T	1537-7
T	is	attribute	where a tableau	1537-7
where a tableau	and	conjunctive	x	1537-7
x		sequential	y	1537-7
y		sequential	∈	1537-7
∈		sequential	va r	1537-7
va r		sequential	T	1537-7
<B>	If	constraint	T	1537-8
T		sequential	x	1537-8
x	=	sequential	y	1537-8
y	and	conjunctive	x	1537-8
y	is typed	attribute	unirelational	1537-8
x		sequential	y	1537-8
y	in	constraint	the A column	1537-8
y	are	attribute	the A column	1537-8
the A column	of	constraint	T	1537-8
T	to	constraint	A	1537-8
T	as	constraint	A	1537-8
T	is referred	action	A	1537-8
A		sequential	an egd	1537-8
Parts		sequential	c	1538-1
c	and	conjunctive	d	1538-1
d	of	constraint	Fig	1538-1
10.2	show	action	two full tgd	1538-2
two full tgd		sequential	s	1538-2
s		sequential	that	1538-2
that	are	attribute	equivalent	1538-2
<B>	because	constraint	tableau queries	1538-3
<B>	as	constraint	tableau queries	1538-3
<B>	is	attribute	especially interesting	1538-3
<B>	considered	action	tableau queries	1538-3
tableau queries		sequential	T ′	1538-3
T ′		sequential	t	1538-3
t	properly contains	action	T	1538-3
T		sequential	t	1538-3
t	see	action	Exercise 10.4	1538-3
<B>	As	constraint	each full tgd	1538-4
<B>	suggested earlier	action	each full tgd	1538-4
each full tgd	to	constraint	some set	1538-4
each full tgd	is	attribute	equivalent	1538-4
some set	of	constraint	head	1538-4
head		sequential	full tgd	1538-4
full tgd		sequential	<B>	1538-4
<B>	In	constraint	full tgd	1538-5
<B>	following	action	full tgd	1538-5
<B>	when considering	action	full tgd	1538-5
full tgd		sequential	we	1538-5
we	that	constraint	they	1538-5
we	will assume	action	they	1538-5
they	are	attribute	single head	1538-5
Part		sequential	e	1539-1
e	of	constraint	Fig	1539-1
10.2	shows	action	a typed tgd	1539-2
a typed tgd		sequential	that	1539-2
that	is	attribute	not single head	1539-2
<B>	To	constraint	B C B C S x y x	1539-3
<B>	within	constraint	B C B C S x y x	1539-3
<B>	represent	attribute	these	1539-3
B C B C S x y x	w	constraint	S′	1539-3
S′		sequential	y	1539-3
y		sequential	w	1539-3
w		sequential	y	1539-3
y		sequential	w	1539-3
w		sequential	y	1539-3
y	w	constraint	u	1539-3
u		sequential	y	1539-3
y	w	constraint	3 u	1539-3
3 u		sequential	y	1539-3
y	w	sequential	3 y	1539-3
3 y	w	constraint	x	1539-3
x	=	sequential	z	1539-3
z		sequential	y	1539-3
y	w	constraint	5	1539-3
5	x	sequential	z B B B	1539-3
5	=	sequential	z B B B	1539-3
z B B B		sequential	T	1539-3
T	x	sequential	1	1539-3
T	y	sequential	1	1539-3
This tgd	to	constraint	any set	1540-1
This tgd	is	attribute	not equivalent	1540-1
any set	of	constraint	head	1540-1
head		sequential	tgd s	1540-1
tgd s	see	action	Exercise 10.6 b	1540-1
<B>	versus	constraint	Unrestricted Implication	1541-1
Unrestricted Implication	Revisited	action	<B>	1541-1
<B>	Because	constraint	order	1541-2
<B>	of	constraint	order	1541-2
<B>	within	constraint	order	1541-2
<B>	lie	attribute	first	1541-2
order		sequential	logic	1541-2
logic		sequential	|=fin	1541-2
|=fin	is	attribute	co-r.e	1541-2
<B>	On	constraint	the other hand	1542-1
the other hand	because	constraint	fd	1542-1
fd	and	conjunctive	uind	1542-1
uind	are	attribute	dependencies	1542-1
dependencies		sequential	we	1542-1
we	from	constraint	Theorem 9.2.4	1542-1
we	know	action	Theorem 9.2.4	1542-1
Theorem 9.2.4	that	constraint	the two forms	1542-1
the two forms	of	constraint	implication	1542-1
implication	for	constraint	dependencies	1542-1
implication	do not coincide	action	dependencies	1542-1
implication	embedded	action	dependencies	1542-1
dependencies	and	conjunctive	<B>	1542-1
dependencies	are	attribute	nonrecursive	1542-1
<B>	Although	constraint	these results	1542-2
<B>	not demonstrated here	action	these results	1542-2
these results	to	constraint	the family	1542-2
these results	have been extended	action	the family	1542-2
the family	of	constraint	embedded multivalued dependencies	1542-2
embedded multivalued dependencies		sequential	emvd s	1542-2
emvd s		sequential	<B>	1542-2
<B>	To	constraint	Theorem 10.1.2	1543-1
<B>	summarize	action	Theorem 10.1.2	1543-1
<B>	In	constraint	finite implication	1544-1
finite implication	is	attribute	not r.e.	1544-1
not r.e.	and	conjunctive	unrestricted implication	1544-1
unrestricted implication	is	attribute	not co-r.e	1544-1
The Chase Revisited		sequential	The Chase Revisited	1545-1
<B>	with	constraint	Full Dependencies	1546-1
<B>	Chasing	action	Full Dependencies	1546-1
<B>	In	constraint	this context	1546-2
this context		sequential	we	1546-2
we	with	constraint	a tableau T	1546-2
we	either	conjunctive	a tableau T	1546-2
we	begin	action	a tableau T	1546-2
a tableau T	with	constraint	an arbitrary tgd	1546-2
a tableau T	or	conjunctive	an arbitrary tgd	1546-2
an arbitrary tgd		sequential	T	1546-2
T		sequential	T ′	1546-2
T ′	or	conjunctive	egd	1546-2
egd		sequential	T	1546-2
T		sequential	x	1546-2
x	=	sequential	y	1546-2
The notion	of	constraint	a full dependency	1546-3
The notion	applying	action	a full dependency	1546-3
a full dependency	to	constraint	the natural manner	1546-3
a full dependency	in	constraint	the natural manner	1546-3
a full dependency	is defined	action	the natural manner	1546-3
Lemma		sequential	8.4.17	1546-4
8.4.17	and	conjunctive	the notation	1546-4
the notation	for	constraint	it	1546-4
the notation	developed	action	it	1546-4
it	to	constraint	this context	1546-4
it	generalize naturally	action	this context	1546-4
this context	as	constraint	the following analog	1546-4
this context	does	action	the following analog	1546-4
the following analog	of	constraint	Theorem 8.4.18	1546-4
Theorem 8.4.18		sequential	Theorem 10.2.1	1546-4
Logical implication	of	constraint	dependencies	1547-1
Logical implication	or	conjunctive	dependencies	1547-1
dependencies	by	constraint	sets	1547-1
sets	of	constraint	full dependencies	1547-1
full dependencies	by	constraint	a straightforward application	1547-1
full dependencies	will now be characterized	action	a straightforward application	1547-1
a straightforward application	of	constraint	the techniques	1547-1
the techniques	in	constraint	Section 8.4	1547-1
the techniques	developed	action	Section 8.4	1547-1
Section 8.4	see	action	Exercise 10.8	1547-1
A dependency		sequential	τ	1547-2
τ	if	constraint	τ	1547-2
τ	is	attribute	trivial	1547-2
τ	is	attribute	a an egd	1547-2
a an egd		sequential	T	1547-2
T		sequential	x	1547-2
x	=	sequential	x	1547-2
x	or	conjunctive	the identity	1547-2
x	is	attribute	the identity	1547-2
the identity	on	constraint	var	1547-2
var		sequential	T	1547-2
T		sequential	∩ var	1547-2
∩ var		sequential	T	1547-2
T		sequential	′	1547-2
<B>	that	constraint	τ	1548-1
<B>	if	constraint	τ	1548-1
<B>	Note	action	τ	1548-1
τ	is	attribute	a full tgd	1548-1
a full tgd	that	constraint	T T	1548-1
a full tgd	b simply says	action	T T	1548-1
T T		sequential	⊆	1548-1
<B>	following now provides	action	a simple test	1549-1
a simple test	for	constraint	implication	1549-1
implication	by	constraint	full typed dependencies	1549-1
full typed dependencies		sequential	Theorem 10.2.2	1549-1
<B>	|=	sequential	τ iff chase	1550-1
τ iff chase	is	attribute	Then trivial	1550-1
<B>	that	constraint	the chase	1551-1
<B>	Recall	action	the chase	1551-1
the chase	on	constraint	a total order	1551-1
the chase	relies	action	a total order	1551-1
a total order		sequential	≤	1551-1
≤	on	constraint	var	1551-1
<B>	For	constraint	egd	1551-2
egd		sequential	T	1551-2
T		sequential	x	1551-2
x	=	sequential	y	1551-2
y		sequential	we	1551-2
we	that	constraint	x	1551-2
we	assume	action	x	1551-2
x		sequential	y	1551-2
y	that	constraint	the variables	1551-2
y	to	constraint	the variables	1551-2
y	and	conjunctive	the variables	1551-2
y	and	conjunctive	the variables	1551-2
y	are	attribute	least	1551-2
the variables	in	constraint	the tableau	1551-2
the variables	appearing	action	the tableau	1551-2
the tableau	for	constraint	full tgd	1551-2
the tableau	and	conjunctive	full tgd	1551-2
full tgd		sequential	T	1551-2
T		sequential	t	1551-2
t		sequential	t	1551-2
t	in	constraint	T A	1551-2
t	is	attribute	A least	1551-2
T A	for	constraint	each attribute A	1551-2
<B>	Using	action	this convention	1551-3
this convention		sequential	we	1551-3
we	can obtain	action	the following Corollary 10.2.3	1551-3
var		sequential	chase	1552-1
chase		sequential	T	1552-1
<B>	Using	action	the preceding results	1553-1
the preceding results		sequential	it	1553-1
it	to	constraint	a deterministic exponential time algorithm	1553-1
it	is	attribute	straightforward	1553-1
it	develop	action	a deterministic exponential time algorithm	1553-1
a deterministic exponential time algorithm	for	constraint	testing implication	1553-1
testing implication	of	constraint	full dependencies	1553-1
It	that	constraint	the cases	1553-2
It	for	constraint	the cases	1553-2
It	both	conjunctive	the cases	1553-2
It	and	conjunctive	the cases	1553-2
It	is also known	attribute	untyped	1553-2
It	typed	attribute	untyped	1553-2
the cases		sequential	implication	1553-2
implication	in	constraint	exptime	1553-2
implication	is	attribute	complete	1553-2
<B>	that	constraint	contrast	1553-3
<B>	in	constraint	contrast	1553-3
<B>	Note	action	contrast	1553-3
contrast		sequential	logical implication	1553-3
logical implication	for	constraint	arbitrary sets	1553-3
arbitrary sets	of	constraint	Bernays	1553-3
Bernays		sequential	Schöfinkel	1553-3
Schöfinkel		sequential	initially extended sentences	1553-3
initially extended sentences	to	constraint	nondeterministic exptime	1553-3
initially extended sentences	in	constraint	nondeterministic exptime	1553-3
initially extended sentences	is known	attribute	complete	1553-3
initially extended sentences	be	attribute	complete	1553-3
Dependencies	and	conjunctive	Views	1554-1
<B>	Let	action	R	1554-2
R	{	sequential	R1	1554-2
<B>	.	sequential	<B>	1554-3
<B>	.	sequential	<B>	1554-4
Rn		sequential	}	1554-5
}	be	attribute	a database schema	1554-5
a database schema		sequential	Rj	1554-5
Rj	where has	action	associated set j	1554-5
associated set j	of	constraint	full dependencies j	1554-5
full dependencies j	for	constraint	∈	1554-5
∈		sequential	1	1554-5
1		sequential	n	1554-5
<B>	=	sequential	Ri	1554-6
<B>	Set	action	Ri	1554-6
Ri		sequential	σ	1554-6
σ		sequential	σ ∈	1554-6
σ ∈		sequential	i	1554-6
i	}	action	<B>	1554-6
<B>	that	constraint	the elements	1554-7
<B>	Note	action	the elements	1554-7
the elements	of	constraint	the relation name	1554-7
the elements	by	constraint	the relation name	1554-7
the elements	are tagged	action	the relation name	1554-7
the relation name		sequential	they	1554-7
they	to	constraint	<B>	1554-7
they	refer	action	<B>	1554-7
<B>	that	constraint	a view	1554-8
<B>	Suppose	action	a view	1554-8
a view	by	constraint	algebraic expression E	1554-8
a view	is defined	action	algebraic expression E	1554-8
algebraic expression E		sequential	R → S	1554-8
R → S		sequential	V	1554-8
It	to	constraint	what dependencies	1554-9
It	is	attribute	natural	1554-9
It	ask	action	what dependencies	1554-9
what dependencies	in	constraint	the view	1554-9
what dependencies	will hold	action	the view	1554-9
we	that	constraint	R	1554-10
we	Formally say	action	R	1554-10
R	implies	action	E	1554-10
E		sequential	σ	1554-10
σ	denoted	action	R	1554-10
R	|= E	sequential	σ	1554-10
σ	if	constraint	E	1554-10
E		sequential	I	1554-10
I	satisfies	action	σ	1554-10
σ	for	constraint	I	1554-10
I	satisfies	action	<B>	1554-10
The notion	of	constraint	R	1554-11
R	|=	sequential	E	1554-11
E	for	constraint	a set	1554-11
a set	in	constraint	the natural manner	1554-11
a set	is defined	action	the natural manner	1554-11
<B>	To	constraint	these notions	1555-1
<B>	illustrate	action	these notions	1555-1
these notions	in	constraint	a simple setting	1555-1
a simple setting		sequential	we	1555-1
we	state	action	the following easily verified result	1555-1
the following easily verified result	see	action	Exercise 10.10	1555-1
Proposition		sequential	10.2.4	1556-1
<B>		sequential	<B>	1556-2
<B>	Given	action	a database schema R	1557-1
a database schema R		sequential	a family	1557-1
a family	of	constraint	tagged full dependencies	1557-1
tagged full dependencies	over	constraint	R	1557-1
R		sequential	a view expression E	1557-1
a view expression E		sequential	mapping R	1557-1
mapping R	to	constraint	S	1557-1
S		sequential	V	1557-1
V	and	conjunctive	a full dependency γ	1557-1
a full dependency γ	is	attribute	it	1557-1
it	whether	constraint	R	1557-1
R	|= E γ	sequential	<B>	1557-1
<B>	If	constraint	E	1557-2
E	over	constraint	the full relational algebra	1557-2
E	ranges	action	the full relational algebra	1557-2
the full relational algebra		sequential	the answer	1557-2
the answer	if	constraint	the only dependencies	1557-2
the answer	is	attribute	the only dependencies	1557-2
the only dependencies	are	attribute	even fd	1557-2
the only dependencies	considered	action	even fd	1557-2
even fd		sequential	<B>	1557-2
Theorem		sequential	10.2.5	1558-1
Proof	Let	action	R	1559-1
R	=	sequential	R	1559-1
R		sequential	U	1559-1
U		sequential	S	1559-1
S		sequential	U }	1559-1
U }		sequential	σ	1559-1
σ	=	sequential	R	1559-1
R	∅	sequential	U	1559-1
R	→	sequential	U	1559-1
U	and	conjunctive	σ	1559-1
U	=	sequential	σ	1559-1
σ		sequential	}	1559-1
<B>	Given	action	two algebra expressions E1	1559-2
two algebra expressions E1		sequential	E2	1559-2
E2		sequential	S	1559-2
S	→	sequential	R	1559-2
R	consider	action	E	1559-2
E	=	sequential	R ∪	1559-2
R ∪		sequential	E1	1559-2
E1		sequential	S	1559-2
S		sequential	E2	1559-2
E2		sequential	S	1559-2
S		sequential	∪	1559-2
∪		sequential	E2	1559-2
E2		sequential	S	1559-2
S		sequential	E1	1559-2
E1		sequential	S	1559-2
<B>	by	constraint	Corollary 6.3.2	1559-3
<B>	is	attribute	undecidable	1559-3
<B>	In	constraint	contrast	1560-1
contrast		sequential	we	1560-1
we	now present	action	a decision procedure	1560-1
a decision procedure	on	constraint	the chase	1560-1
a decision procedure	based	action	the chase	1560-1
the chase	for	constraint	view dependencies	1560-1
the chase	inferring	action	view dependencies	1560-1
view dependencies		sequential	the view	1560-1
the view	when is defined	action	the SPCU algebra	1560-1
the view	using	action	the SPCU algebra	1560-1
Theorem		sequential	10.2.6	1561-1
Crux		sequential	Crux	1562-1
<B>	Let	action	E	1563-1
E		sequential	R → S	1563-1
R → S		sequential	V	1563-1
V	be	attribute	an SPC expression	1563-1
an SPC expression		sequential	where S ∈ R. Recall	1563-1
where S ∈ R. Recall	from	constraint	Chapter 4	1563-1
Chapter 4		sequential	Theorem	1563-1
Theorem		sequential	4.4.8	1563-1
4.4.8	see	action	also Exercise 4.18	1563-1
also Exercise 4.18	that	constraint	each such expression E	1563-1
also Exercise 4.18	for	constraint	each such expression E	1563-1
each such expression E		sequential	there	1563-1
there	is	attribute	a tableau mapping	1563-1
a tableau mapping		sequential	τE	1563-1
τE	=	sequential	T	1563-1
T		sequential	t	1563-1
t	to	constraint	E	1563-1
<B>	Set	action	Z	1564-1
Z	=	sequential	∪u ∈W Tu	1564-1
It	that	constraint	R	1564-2
It	can now be verified	action	R	1564-2
R	|=	sequential	E	1564-2
E		sequential	γ iff	1564-2
γ iff	w	constraint	∈ E	1564-2
∈ E		sequential	chase	1564-2
chase		sequential	Z	1564-2
<B>	In	constraint	the case	1565-1
the case		sequential	∪	1565-1
∪		sequential	γ	1565-1
γ	is	attribute	where a set	1565-1
where a set	of	constraint	s	1565-1
s	and	conjunctive	mvd	1565-1
mvd		sequential	fd s	1565-1
fd s	and	conjunctive	the view	1565-1
the view	by	constraint	an SPCU expression	1565-1
the view	is defined	action	an SPCU expression	1565-1
an SPCU expression	testing	action	the implication	1565-1
the implication	of	constraint	a view dependency	1565-1
a view dependency	in	constraint	polynomial time	1565-1
a view dependency	can be done	action	polynomial time	1565-1
polynomial time	if	constraint	jd	1565-1
jd	are involved	action	the problem	1565-1
the problem	is	attribute	np	1565-1
np	if	constraint	full dependencies	1565-1
np	and	conjunctive	full dependencies	1565-1
full dependencies	are considered	action	the problem	1565-1
the problem	is	attribute	exptime	1565-1
exptime		sequential	<B>	1565-1
<B>	from	constraint	Section 8.4	1566-1
<B>	Recall	action	Section 8.4	1566-1
Section 8.4		sequential	that	1566-1
that		sequential	a satisfaction family	1566-1
a satisfaction family	is	attribute	a family	1566-1
a family	sat	action	R	1566-1
R	for	constraint	some set	1566-1
some set	of	constraint	dependencies	1566-1
<B>	that	constraint	SPC expression E	1566-2
<B>	Suppose now	action	SPC expression E	1566-2
SPC expression E		sequential	R	1566-2
R		sequential	U	1566-2
U	→	sequential	S	1566-2
S		sequential	V	1566-2
V	and	conjunctive	a set	1566-2
V	is given	attribute	that	1566-2
V	is	attribute	a set	1566-2
a set	of	constraint	full dependencies	1566-2
full dependencies	over	constraint	R. Theorem	1566-2
R. Theorem		sequential	10.2.6	1566-2
10.2.6	that	constraint	the family	1566-2
10.2.6	suitably generalized	action	the family	1566-2
10.2.6	shows	action	the family	1566-2
the family	of	constraint	full dependencies	1566-2
full dependencies	by	constraint	view E	1566-2
full dependencies	for	constraint	view E	1566-2
full dependencies	implied	action	view E	1566-2
view E	is	attribute	recursive	1566-2
<B>	raises	action	the natural question	1566-3
the natural question		sequential	E	1566-3
E		sequential	sat	1566-3
sat		sequential	R	1566-3
R	Does =	sequential	Ŵ	1566-3
R	sat	attribute	that	1566-3
R	is	attribute	Ŵ	1566-3
Ŵ	Ŵ does completely characterize	action	the image	1566-3
the image	of	constraint	sat	1566-3
sat		sequential	R	1566-3
R	under	constraint	E	1566-3
The affirmative answer	to	constraint	this question	1566-4
this question	is stated next	action	<B>	1566-4
This result	from	constraint	the proof	1566-5
This result	follows	action	the proof	1566-5
the proof	of	constraint	Theorem 10.2.6	1566-5
Theorem 10.2.6	see	action	Exercise 10.13	1566-5
Theorem		sequential	10.2.7	1567-1
<B>	that	constraint	E	1568-1
<B>	Suppose now	action	E	1568-1
E		sequential	R	1568-1
R		sequential	U	1568-1
U	→	sequential	S	1568-1
S		sequential	V	1568-1
V	and	conjunctive	a finite set	1568-1
V	is	attribute	a finite set	1568-1
V	is given	action	a finite set	1568-1
a finite set	of	constraint	dependencies	1568-1
a finite set	that	constraint	E	1569-1
a finite set	Can be found	attribute	such	1569-1
E		sequential	sat	1569-1
sat		sequential	R	1569-1
R	=	sequential	sat	1569-1
sat		sequential	S	1569-1
S		sequential	Ŵ	1569-1
<B>	in	constraint	Even the case	1569-2
Even the case		sequential	E	1569-2
E	is	attribute	where a simple projection	1569-2
where a simple projection	and	conjunctive	a set	1569-2
where a simple projection	is	attribute	a set	1569-2
a set	of	constraint	fd	1569-2
fd		sequential	s	1569-2
s		sequential	the answer	1569-2
the answer	to	constraint	this question	1569-2
this question	is	attribute	sometimes negative	1569-2
Exercise		sequential	10.11 c	1569-2
<B>	with	constraint	Embedded Dependencies	1570-1
<B>	Chasing	action	Embedded Dependencies	1570-1
<B>	From	constraint	Theorem 10.1.2	1570-2
Theorem 10.1.2		sequential	it	1570-2
it	that	constraint	we	1570-2
it	is	attribute	b apparent	1570-2
we	to	constraint	Theorem 10.2.2	1570-2
we	can not hope	action	Theorem 10.2.2	1570-2
we	generalize	action	Theorem 10.2.2	1570-2
Theorem 10.2.2	to	constraint	a decision procedure	1570-2
Theorem 10.2.2	obtain	action	a decision procedure	1570-2
a decision procedure	for	constraint	implication	1570-2
a decision procedure	or	conjunctive	implication	1570-2
implication	of	constraint	dependencies	1570-2
<B>	As	constraint	Chapter 9	1570-3
<B>	in	constraint	Chapter 9	1570-3
<B>	initially discussed	action	Chapter 9	1570-3
Chapter 9		sequential	the chase	1570-3
the chase	if	constraint	dependencies	1570-3
the chase	need not terminate	action	dependencies	1570-3
dependencies	are used	action	<B>	1570-3
<B>	because	constraint	we	1570-4
<B>	is not lost however	action	we	1570-4
we	to	constraint	the chase	1570-4
we	are	attribute	able	1570-4
we	use	action	the chase	1570-4
the chase	to	constraint	a proof procedure	1570-4
the chase	obtain	action	a proof procedure	1570-4
a proof procedure	for	constraint	unrestricted implication	1570-4
a proof procedure	testing	action	unrestricted implication	1570-4
unrestricted implication	of	constraint	a dependency	1570-4
a dependency	by	constraint	a set	1570-4
a set	of	constraint	dependencies	1570-4
<B>	For	constraint	nonfull tgd	1571-1
nonfull tgd		sequential	we	1571-1
we	shall use	action	the following rule	1571-1
We	present	action	the rule	1571-2
the rule	as	constraint	it	1571-2
it	to	constraint	tableaux	1571-2
it	applies	action	tableaux	1571-2
tableaux	but	conjunctive	it	1571-2
it	on	constraint	dependencies	1571-2
it	can also be used	action	dependencies	1571-2
tgd rule	Let	action	T	1572-1
T	be	attribute	a tableau	1572-1
a tableau	and	conjunctive	σ	1572-1
a tableau	let	action	σ	1572-1
σ		sequential	S	1572-1
S		sequential	S′	1572-1
S′	be	attribute	a tgd	1572-1
<B>	that	constraint	there	1572-2
<B>	Suppose	action	there	1572-2
there	is	attribute	a valuation θ	1572-2
a valuation θ	for	constraint	S	1572-2
S		sequential	that	1572-2
that	embeds	action	S	1572-2
S	into	constraint	T	1572-2
T	but	conjunctive	no extension θ ′	1572-2
no extension θ ′	to	constraint	S	1572-2
no extension θ ′	var	action	S	1572-2
S		sequential	∪ var	1572-2
∪ var		sequential	S′	1572-2
S′	of	constraint	θ	1572-2
θ		sequential	that	1572-2
that		sequential	θ ′	1572-2
θ ′		sequential	S′	1572-2
S′		sequential	⊆	1572-2
⊆		sequential	T	1572-2
<B>	In	constraint	this case	1572-3
this case		sequential	σ	1572-3
σ	to	constraint	T	1572-3
σ	can be applied	action	T	1572-3
<B>	Let	action	θ1	1573-1
<B>	.	sequential	<B>	1573-2
<B>	.	sequential	<B>	1573-3
<B>	be	attribute	a list	1573-4
a list	of	constraint	all valuations	1573-4
all valuations	having	action	this property	1573-4
<B>	For	constraint	i	1573-5
i		sequential	∈	1573-5
∈		sequential	1	1573-5
1		sequential	n	1573-5
n	choose	action	a distinct extension	1573-5
a distinct extension	to	constraint	var	1573-5
var		sequential	S	1573-5
S		sequential	an extension θ ′ ∪	1573-5
an extension θ ′ ∪		sequential	i	1573-5
i		sequential	var	1573-5
var		sequential	S′	1573-5
S′	of	constraint	θi	1573-5
θi	that	constraint	each variable	1573-5
each variable	in	constraint	var	1573-5
var		sequential	S′	1573-5
S′		sequential	var	1573-5
var		sequential	S	1573-5
S	is assigned	action	a distinct new variable	1573-5
a distinct new variable	than	constraint	all variables	1573-5
all variables	in	constraint	T	1573-5
The same variable	in	constraint	two extensions	1573-6
The same variable	is not chosen	action	two extensions	1573-6
two extensions		sequential	′	1573-6
′		sequential	θ	1573-6
θ		sequential	′	1573-6
′		sequential	i	1573-6
i	=	sequential	j	1573-6
i	j	action	The result	1574-1
The result	of	constraint	σ	1574-1
The result	applying	action	σ	1574-1
σ	to	constraint	T	1574-1
T	is	attribute	T ∪	1574-1
T ∪		sequential	θ ′	1574-1
θ ′		sequential	S′	1574-1
S′		sequential	i	1574-1
i		sequential	∈	1574-1
∈		sequential	1	1574-1
1		sequential	n	1574-1
i		sequential	This rule	1575-1
This rule	because	constraint	variables	1575-1
This rule	is	attribute	nondeterministic	1575-1
variables	in	constraint	T	1575-1
variables	not occurring	action	T	1575-1
T	for	constraint	the existentially quantified variables	1575-1
T	are chosen	action	the existentially quantified variables	1575-1
the existentially quantified variables	of	constraint	σ	1575-1
We	that	constraint	some fixed mechanism	1575-2
We	assume	action	some fixed mechanism	1575-2
some fixed mechanism	for	constraint	these variables	1575-2
some fixed mechanism	is used	action	these variables	1575-2
some fixed mechanism	selecting	action	these variables	1575-2
these variables	when given	action	T	1575-2
T		sequential	S	1575-2
S		sequential	S′	1575-2
S′	and	conjunctive	θ	1575-2
The notion	of	constraint	a chasing sequence	1576-1
a chasing sequence		sequential	T	1576-1
T	=	sequential	T1	1576-1
T1		sequential	T2	1576-1
<B>	.	sequential	<B>	1576-2
<B>	.	sequential	<B>	1576-3
<B>	of	constraint	a tableau	1576-4
a tableau	or	conjunctive	dependency	1576-4
dependency	by	constraint	a set	1576-4
a set	of	constraint	dependencies	1576-4
dependencies	in	constraint	the obvious manner	1576-4
dependencies	is now defined	action	the obvious manner	1576-4
this sequence	be	attribute	Clearly may infinite	1576-5
Example		sequential	10.2.8	1577-1
10.2.8		sequential	Let	1577-1
Let	=	sequential	τ	1577-1
Let	{	sequential	τ	1577-1
τ		sequential	1	1577-1
1	τ	sequential	2	1577-1
2	τ	sequential	3 }	1577-1
3 }		sequential	where B C D B C D B C D T	1577-1
where B C D B C D B C D T		sequential	w	1577-1
w		sequential	x T′	1577-1
x T′	w	constraint	y	1577-1
<B>		sequential	3	1577-2
3	≡	sequential	B	1577-2
B	→	sequential	D	1577-2
<B>	In	constraint	Fig	1578-1
we	10.3 show	action	some stages	1578-2
some stages	of	constraint	a chasing sequence	1578-2
a chasing sequence		sequential	that	1578-2
that	that	constraint	<B>	1578-2
that	demonstrates	action	<B>	1578-2
<B>	Consider now	action	the typed tgd s	1579-1
the typed tgd s		sequential	B C D B C D T′′′ w	1579-1
B C D B C D T′′′ w		sequential	x	1579-1
10.3	that	constraint	|=unr	1579-2
10.3	also implies	action	|=unr	1579-2
|=unr	τ	sequential	4	1579-2
4	because	constraint	x10	1579-2
x10		sequential	x2	1579-2
x2		sequential	x6	1579-2
x6		sequential	x4	1579-2
x4	in	constraint	the second tableau	1579-2
x4	is	attribute	the second tableau	1579-2
<B>	On	constraint	the other hand	1579-3
the other hand		sequential	we	1579-3
we	that	constraint	|=unr	1579-3
we	now argue	action	|=unr	1579-3
|=unr	τ	sequential	5	1579-3
<B>	Consider	action	the chasing sequence	1579-4
the chasing sequence	as	constraint	the one	1579-4
the chasing sequence	beginning	action	the one	1579-4
the one	in	constraint	Fig	1579-4
the one	shown	action	Fig	1579-4
10.3	by	constraint	the sequence	1579-5
10.3	and	conjunctive	the sequence	1579-5
10.3	continuing	action	the sequence	1579-5
10.3	applying	action	the sequence	1579-5
the sequence	τ 1	sequential	3	1579-5
the sequence	τ	sequential	3	1579-5
3	τ 2	sequential	3	1579-5
3	τ repeatedly	sequential	3	1579-5
It	that	constraint	this chasing sequence	1579-6
It	can be shown	action	this chasing sequence	1579-6
this chasing sequence	that	constraint	x1	1579-6
this chasing sequence	and	conjunctive	x1	1579-6
this chasing sequence	will not terminate	action	x1	1579-6
x1		sequential	x2	1579-6
x2		sequential	x6	1579-6
x6		sequential	v	1579-6
v	in	constraint	the resulting infinite sequence	1579-6
v	does not occur	action	the resulting infinite sequence	1579-6
the resulting infinite sequence	for	constraint	any variable v	1579-6
any variable v	see	action	Exercise 10.16	1579-6
It	follows	action	that |=unr	1579-7
that |=unr	τ	sequential	5	1579-7
5	in	constraint	the infinite result	1579-7
the infinite result	of	constraint	the chasing sequence	1579-7
the chasing sequence	is	attribute	a counterexample	1579-7
a counterexample	to	constraint	this implication	1579-7
<B>	On	constraint	the other hand	1579-8
the other hand		sequential	this chasing sequence	1579-8
this chasing sequence	does not alone provide	action	any information	1579-8
any information	about	constraint	|=fin	1579-8
any information	whether	constraint	|=fin	1579-8
|=fin	τ	sequential	5	1579-8
It	that	constraint	<B>	1579-9
It	can be shown	attribute	this	1579-9
It	also fails	action	<B>	1579-9
<B>	To	constraint	all relevant dependencies	1580-1
<B>	that	constraint	all relevant dependencies	1580-1
<B>	ensure	action	all relevant dependencies	1580-1
all relevant dependencies	have	action	a chance	1580-1
a chance	to	constraint	a chasing sequence	1580-1
a chance	influence	action	a chasing sequence	1580-1
a chasing sequence		sequential	we	1580-1
we	on	constraint	chasing sequences	1580-1
we	focus	action	chasing sequences	1580-1
chasing sequences		sequential	that	1580-1
that	satisfy	action	the following conditions	1580-1
the following conditions		sequential	an egd	1580-1
an egd	Whenever is applied	action	it	1580-1
it	until	constraint	it	1580-1
it	1 is applied repeatedly	action	it	1580-1
it	is	attribute	no longer applicable	1580-1
<B>	if	constraint	these conditions	1581-1
these conditions	are	attribute	Even satisfied	1581-1
it	to	constraint	two chasing sequences	1581-1
it	is	attribute	possible	1581-1
it	have	action	two chasing sequences	1581-1
two chasing sequences	of	constraint	a tableau T	1581-1
a tableau T	by	constraint	typed dependencies	1581-1
typed dependencies		sequential	one	1581-1
one	and	conjunctive	Exercise 10.14	1581-1
one	is	attribute	where finite	1581-1
one	see	action	Exercise 10.14	1581-1
<B>	Now consider	action	an infinite chasing sequence T1	1582-1
an infinite chasing sequence T1		sequential	T T2	1582-1
<B>	.	sequential	<B>	1582-2
<B>	.	sequential	<B>	1582-3
<B>	.	sequential	<B>	1582-4
<B>	Let	action	us	1582-5
us	denote	action	it	1582-5
it	by	constraint	T	1582-5
<B>	Because	constraint	egd	1583-1
egd	in	constraint	T	1583-1
egd	may be applied arbitrarily late	action	T	1583-1
T	for	constraint	tuples	1583-1
T	n	conjunctive	tuples	1583-1
tuples	of	constraint	Tn	1583-1
Tn	as	constraint	the result	1583-1
Tn	may be modified	action	the result	1583-1
the result	of	constraint	later applications	1583-1
later applications	of	constraint	egd	1583-1
egd		sequential	<B>	1583-1
we	Thus can not simply take	action	the union	1583-2
the union	of	constraint	some tail Tn Tn+1	1583-2
<B>	.	sequential	<B>	1583-3
<B>	.	sequential	<B>	1583-4
<B>	to	constraint	the result	1583-5
<B>	obtain	action	the result	1583-5
the result	of	constraint	the chase	1583-5
<B>	As	constraint	an alternative	1583-6
an alternative	for	constraint	the chasing sequence	1583-6
the chasing sequence		sequential	T	1583-6
T	=	sequential	T1	1583-6
T1		sequential	T2	1583-6
<B>	.	sequential	<B>	1583-7
<B>	.	sequential	<B>	1583-8
we	define	action	chase	1583-9
chase		sequential	T	1583-9
T	=	sequential	u	1583-9
u	∃n	sequential	∀m	1583-9
∀m	n	conjunctive	u	1583-9
u		sequential	∈ Tm	1583-9
∈ Tm		sequential	}	1583-9
<B>	because	constraint	the variables	1584-1
<B>	is	attribute	nonempty	1584-1
the variables	by	constraint	the tgd rule	1584-1
the variables	introduced	action	the tgd rule	1584-1
the tgd rule	than	constraint	variables already present	1584-1
the tgd rule	are	attribute	1 always greater	1584-1
variables already present	and	conjunctive	the egd rule	1584-1
the egd rule	when is applied	action	the newer variable	1584-1
the newer variable	by	constraint	the older one	1584-1
the newer variable	2 is replaced	action	the older one	1584-1
<B>	By	constraint	the techniques	1585-1
<B>	generalizing	action	the techniques	1585-1
the techniques	developed	action	it	1585-1
it	that	constraint	the resulting tableau	1585-1
it	is easily seen	attribute	possibly infinite	1585-1
the resulting tableau	satisfies	action	all dependencies in	1585-1
<B>	be	attribute	a set	1585-2
<B>	let	action	a set	1585-2
a set	of	constraint	dependencies	1585-2
dependencies	and	conjunctive	σ	1585-2
σ		sequential	a dependency	1585-2
one	that	constraint	|=unr σ iff	1585-3
one	Then can show	action	|=unr σ iff	1585-3
|=unr σ iff	for	constraint	some chasing sequence	1585-3
some chasing sequence		sequential	σ	1585-3
σ	of	constraint	σ	1585-3
σ	using	action	σ	1585-3
σ	chase	action	σ	1585-3
σ	is	attribute	trivial	1585-3
it	Furthermore can be shown	action	<B>	1585-4
<B>	that	constraint	practical purposes	1586-1
<B>	for	constraint	practical purposes	1586-1
<B>	shows	action	practical purposes	1586-1
practical purposes		sequential	it	1586-1
it	to	constraint	some chasing sequence	1586-1
it	suffices	action	some chasing sequence	1586-1
it	generate	action	some chasing sequence	1586-1
some chasing sequence	of	constraint	σ	1586-1
σ	as	constraint	some tableau	1586-1
σ	and	conjunctive	some tableau	1586-1
σ	using	action	some tableau	1586-1
σ	stop	action	some tableau	1586-1
some tableau	in	constraint	the sequence	1586-1
the sequence	becomes	attribute	trivial	1586-1
This section	presents	action	an axiomatization	1587-1
an axiomatization	for	constraint	the family	1587-1
the family	of	constraint	full typed tgd	1587-1
full typed tgd		sequential	s	1587-1
s	and	conjunctive	egd s	1587-1
s	typed	action	egd s	1587-1
egd s		sequential	which	1587-1
which	for	constraint	implication	1587-1
which	and	conjunctive	implication	1587-1
which	both	conjunctive	implication	1587-1
which	and	conjunctive	implication	1587-1
which	is	attribute	sound	1587-1
A generalization	to	constraint	the embedded case	1587-2
the embedded case	for	constraint	unrestricted implication	1587-2
unrestricted implication	has also been developed	action	Exercise 10.21	1587-2
unrestricted implication	see	action	Exercise 10.21	1587-2
The axiomatization	to	constraint	the chase	1587-3
The axiomatization	presented here	attribute	closely related	1587-3
The axiomatization	is	attribute	closely related	1587-3
<B>	In	constraint	the next section	1587-4
the next section		sequential	a very different kind	1587-4
a very different kind	of	constraint	axiomatization	1587-4
axiomatization	for	constraint	typed dependencies	1587-4
typed dependencies	is discussed	action	<B>	1587-4
We	on	constraint	the full typed dependencies	1588-1
We	now focus	action	the full typed dependencies	1588-1
the full typed dependencies	on	constraint	typed egd	1588-1
typed egd	and	conjunctive	s full typed tgd	1588-1
s full typed tgd		sequential	s	1588-1
The development	with	constraint	the introduction	1588-2
The development	begins	action	the introduction	1588-2
the introduction	of	constraint	a technical tool	1588-2
a technical tool	for	constraint	the composition	1588-2
a technical tool	forming	action	the composition	1588-2
the composition	of	constraint	tableaux queries	1588-2
The axiomatization	follows	action	<B>	1588-3
Composition	of	constraint	Typed Tableaux	1589-1
Typed Tableaux	that	constraint	τ	1589-1
Typed Tableaux	Suppose	action	τ	1589-1
τ	=	sequential	T	1589-1
T		sequential	t	1589-1
t	and	conjunctive	σ	1589-1
σ	=	sequential	S s	1589-1
S s	are	attribute	two full typed tableau queries	1589-1
two full typed tableau queries	over	constraint	relation schema R	1589-1
<B>	Let	action	T	1590-1
T	=	sequential	t1	1590-1
<B>	.	sequential	<B>	1590-2
<B>	.	sequential	<B>	1590-3
tn }	and	conjunctive	S	1590-4
S	=	sequential	s1	1590-4
S	{	sequential	s1	1590-4
<B>	.	sequential	<B>	1590-5
<B>	.	sequential	<B>	1590-6
sm }		sequential	sm }	1590-7
<B>	that	constraint	tuple	1590-8
<B>	Suppose	action	tuple	1590-8
tuple	w	constraint	σ	1590-8
tuple	in	constraint	σ	1590-8
tuple	is	attribute	σ	1590-8
σ		sequential	τ	1590-8
τ		sequential	I	1590-8
there	Then is	action	an embedding	1590-9
an embedding		sequential	ν	1590-9
ν	of	constraint	s1	1590-9
<B>	.	sequential	<B>	1590-10
<B>	.	sequential	<B>	1590-11
<B>	into	constraint	τ	1590-12
<B>	sm	action	τ	1590-12
τ		sequential	I	1590-12
I		sequential	such that ν s	1590-12
such that ν s	w	constraint	<B>	1590-12
such that ν s	=	sequential	<B>	1590-12
<B>	that	constraint	the tableau	1590-13
<B>	suggests	action	the tableau	1590-13
the tableau	of	constraint	τ	1590-13
τ		sequential	σ	1590-13
σ	should have	action	mn tuples	1590-13
mn tuples	with	constraint	a block	1590-13
a block	of	constraint	tuples	1590-13
a block	n	conjunctive	tuples	1590-13
tuples	for	constraint	each sj	1590-13
<B>	To	constraint	each j ∈	1591-1
<B>	for	constraint	each j ∈	1591-1
<B>	be	attribute	more precise	1591-1
each j ∈		sequential	1	1591-1
1		sequential	m	1591-1
m	let	action	Ts	1591-1
Ts	be	attribute	θ j j	1591-1
θ j j		sequential	T	1591-1
T		sequential	θj	1591-1
θj	is	attribute	where a substitution	1591-1
where a substitution		sequential	that	1591-1
that	maps	action	t	1591-1
t	to	constraint	sj	1591-1
sj	for	constraint	each attribute	1591-1
each attribute		sequential	A	1591-1
A	of	constraint	R	1591-1
R	and	conjunctive	each other variable	1591-1
R	maps	action	each other variable	1591-1
each other variable	of	constraint	T	1591-1
T	to	constraint	a new distinct variable	1591-1
a new distinct variable	in	constraint	the construction	1591-1
a new distinct variable	not used elsewhere	action	the construction	1591-1
<B>	Now set	action	<B>	1591-2
j	is now easily verified	action	Exercise 10.18	1592-1
j	see	action	Exercise 10.18	1592-1
Exercise 10.18		sequential	Proposition 10.3.1	1592-1
Example		sequential	10.3.2	1593-1
B C B C B C T x y S u v w′ u v p p		sequential	1 x y′ u′ v	1594-1
1 x y′ u′ v		sequential	w	1594-1
w		sequential	u	1594-1
u		sequential	w′	1594-1
w′		sequential	x	1594-1
x		sequential	y′	1594-1
y′		sequential	s	1594-1
s		sequential	u	1594-1
u		sequential	v	1594-1
v		sequential	w	1594-1
w		sequential	u	1594-1
u		sequential	p	1594-1
p		sequential	p	1594-1
p		sequential	t	1594-1
t		sequential	w	1594-1
w	x	sequential	y	1594-1
y	u′	sequential	p	1594-1
y	v	sequential	p	1594-1
p	u′	sequential	4 p	1594-1
4 p	w	constraint	p	1594-1
4 p	u′	sequential	p	1594-1
p		sequential	p	1594-1
p		sequential	u	1594-1
u		sequential	v	1594-1
v	w	sequential	<B>	1594-1
<B>	that	constraint	τ	1595-1
<B>	Suppose	action	τ	1595-1
τ	and	conjunctive	σ	1595-1
σ	are	attribute	full typed tableau queries	1595-1
It	by	constraint	simple chasing arguments	1595-2
It	can be shown	action	simple chasing arguments	1595-2
simple chasing arguments		sequential	that	1595-2
that		sequential	τ	1595-2
τ		sequential	σ }	1595-2
σ }	and	conjunctive	τ	1595-2
τ		sequential	σ	1595-2
σ	as	constraint	sets	1595-2
σ	are	attribute	equivalent	1595-2
sets	of	constraint	dependencies	1595-2
It	that	constraint	full typed tgd	1595-3
It	follows	action	full typed tgd	1595-3
full typed tgd	under	constraint	finite conjunction	1595-3
full typed tgd	are closed	action	finite conjunction	1595-3
finite conjunction	in	constraint	the sense	1595-3
the sense	that	constraint	each finite set	1595-3
each finite set	of	constraint	full typed tgd	1595-3
full typed tgd	over	constraint	a relation schema R	1595-3
a relation schema R	to	constraint	a single full typed tgd	1595-3
a relation schema R	is	attribute	equivalent	1595-3
This property	in	constraint	the embedded case	1595-4
This property	does not hold	action	the embedded case	1595-4
the embedded case	see	action	Exercise 10.20	1595-4
<B>	For	constraint	full typed tgd s	1596-1
full typed tgd s		sequential	τ	1596-1
τ	=	sequential	T	1596-1
T		sequential	t	1596-1
t	and	conjunctive	σ	1596-1
σ	=	sequential	S s	1596-1
S s		sequential	we	1596-1
we	that	constraint	τ	1596-1
we	say	action	τ	1596-1
τ	into	constraint	σ	1596-1
τ	embeds	action	σ	1596-1
σ	τ	constraint	σ	1596-1
σ	֒→	constraint	σ	1596-1
σ	denoted	action	σ	1596-1
σ	if	constraint	there	1596-1
there	is	attribute	a substitution	1596-1
a substitution		sequential	ν	1596-1
ν		sequential	that	1596-1
that		sequential	ν	1596-1
ν		sequential	T	1596-1
T		sequential	⊆	1596-1
⊆		sequential	S	1596-1
S	and	conjunctive	ν	1596-1
ν		sequential	t	1596-1
t	=	sequential	s. Recall	1596-1
s. Recall	from	constraint	Chapter 4	1596-1
Chapter 4		sequential	that	1596-1
that	τ	constraint	σ	1596-1
σ	as	constraint	tableau queries	1596-1
σ	considered	action	tableau queries	1596-1
tableau queries	iff	constraint	σ	1596-1
tableau queries	τ	constraint	σ	1596-1
tableau queries	֒→	conjunctive	σ	1596-1
<B>	As	constraint	a result	1596-2
a result		sequential	we	1596-2
we	if	constraint	σ	1596-2
we	have	attribute	that	1596-2
σ		sequential	τ	1596-2
τ		sequential	σ	1596-2
σ	although	constraint	the converse	1596-2
the converse	does not necessarily hold	action	<B>	1596-2
<B>	for	constraint	A	1596-3
A		sequential	egd	1596-3
egd		sequential	τ	1596-3
τ	=	sequential	T	1596-3
T		sequential	x	1596-3
x	=	sequential	y	1596-3
y	and	conjunctive	σ	1596-3
σ	=	sequential	S	1596-3
S		sequential	v	1596-3
v	=	sequential	w	1596-3
w		sequential	we	1596-3
we	define	action	τ ֒→ σ	1596-3
τ ֒→ σ	if	constraint	there	1596-3
there	is	attribute	a substitution ν such	1596-3
a substitution ν such		sequential	that ν ⊆ S	1596-3
that ν ⊆ S		sequential	T	1596-3
T	and	conjunctive	ν	1596-3
ν		sequential	x	1596-3
x		sequential	y	1596-3
y		sequential	}	1596-3
}	=	sequential	v	1596-3
}	{	sequential	v	1596-3
v	w	constraint	}	1596-3
<B>	if	constraint	σ	1596-4
σ		sequential	τ	1596-4
τ	|=	sequential	σ	1596-4
We	now list	action	the axioms	1597-1
the axioms	for	constraint	full typed tgd	1597-1
full typed tgd		sequential	FTtgd1	1597-1
FTtgd1		sequential	triviality	1597-1
FTtgd2		sequential	embedding	1598-1
FTtgd3		sequential	composition	1599-1
The following rules	on	constraint	typed egd	1600-1
The following rules	focus exclusively	action	typed egd	1600-1
typed egd		sequential	Tegd1	1600-1
Tegd1		sequential	triviality	1600-1
Tegd2		sequential	embedding	1601-1
The final rules	combining	action	egd	1602-1
egd		sequential	s	1602-1
s	and	conjunctive	tgd	1602-1
s	full typed	action	tgd	1602-1
tgd	use	action	the following notation	1602-1
<B>	Let	action	R	1602-2
R		sequential	U	1602-2
U	be	attribute	a relation schema	1602-2
<B>	For	constraint	A ∈ U	1602-3
A ∈ U		sequential	A	1602-3
A	denotes	action	U	1602-3
U		sequential	−	1602-3
−		sequential	A }	1602-3
<B>	Given	action	A egd	1602-4
<B>	typed	action	A egd	1602-4
A egd		sequential	τ	1602-4
τ	=	sequential	uy	1602-4
uy		sequential	A	1602-4
A	of	constraint	distinct variables	1602-4
A	consists	action	distinct variables	1602-4
distinct variables	in	constraint	T	1602-4
distinct variables	not occurring	action	T	1602-4
<B>	Define	action	two full typed tgd	1602-5
two full typed tgd		sequential	τx	1602-5
FTD1		sequential	conversion	1603-1
FTD2		sequential	composition	1604-1
We	now have	action	the following Theorem 10.3.3	1605-1
Crux Soundness	is easily verified	action	<B>	1606-1
We	illustrate	action	completeness	1606-2
completeness	by	constraint	the FTtgd rules	1606-2
completeness	that	constraint	the FTtgd rules	1606-2
completeness	showing	action	the FTtgd rules	1606-2
the FTtgd rules	for	constraint	tgd	1606-2
the FTtgd rules	are	attribute	complete	1606-2
tgd		sequential	<B>	1606-2
<B>	that	constraint	τ	1606-3
<B>	|=	sequential	τ	1606-3
<B>	Suppose	action	τ	1606-3
τ	=	sequential	T	1606-3
T		sequential	t	1606-3
t	is	attribute	a set	1606-3
a set	of	constraint	full typed tgd	1606-3
full typed tgd	and	conjunctive	T	1606-3
T		sequential	t	1606-3
t	and	conjunctive	<B>	1606-3
t	is	attribute	full	1606-3
t	typed	action	<B>	1606-3
<B>	By	constraint	Theorem 10.2.2	1606-4
Theorem 10.2.2		sequential	there	1606-4
there	is	attribute	a chasing sequence	1606-4
a chasing sequence	of	constraint	T	1606-4
T	by	constraint	T	1606-4
T	yielding	action	T	1606-4
T	with	constraint	t ∈ T	1606-4
<B>	Let	action	σ 1	1606-5
<B>	.	sequential	<B>	1606-6
<B>	.	sequential	<B>	1606-7
σn		sequential	n	1606-8
n	≥	sequential	0	1606-8
0	be	attribute	the sequence	1606-8
the sequence	of	constraint	elements	1606-8
elements	of	constraint	the chasing sequence	1606-8
elements	in	constraint	the chasing sequence	1606-8
elements	used	action	the chasing sequence	1606-8
It	that	constraint	t ∈ σn	1606-9
It	follows	action	t ∈ σn	1606-9
<B>	.	sequential	<B>	1606-10
<B>	.	sequential	<B>	1606-11
σ1		sequential	T	1606-12
<B>	.	sequential	<B>	1606-13
<B>	.	sequential	<B>	1606-14
<B>	by	constraint	Proposition 10.3.1	1606-15
<B>	and	conjunctive	Proposition 10.3.1	1606-15
Proposition 10.3.1		sequential	t ∈	1606-15
t ∈		sequential	σ	1606-15
σ		sequential	1	1606-15
1	•	sequential	σn	1606-15
1	•	sequential	σn	1606-15
σn		sequential	T	1606-15
<B>	that	constraint	σ	1606-16
<B>	implies	action	σ	1606-16
σ		sequential	1	1606-16
1	•	sequential	σn	1606-16
1	•	sequential	σn	1606-16
σn		sequential	֒→	1606-16
֒→		sequential	T	1606-16
T		sequential	t	1606-16
A proof	of	constraint	τ	1606-17
τ	from	constraint	σ	1606-17
τ	by	constraint	σ	1606-17
τ	with	constraint	σ	1606-17
τ	is now obtained	action	σ	1606-17
τ	starting	action	σ	1606-17
σ		sequential	1	1606-17
1	or	conjunctive	} s	1606-17
} s	if	constraint	n	1606-17
n	=	sequential	0	1606-17
0	by	constraint	applications	1606-17
0	n	conjunctive	applications	1606-17
0	− 1	sequential	applications	1606-17
0	followed	action	applications	1606-17
applications	of	constraint	FTtgd3	1606-17
FTtgd3	and	conjunctive	one application	1606-17
one application	of	constraint	FTtgd2	1606-17
FTtgd2	see	action	Exercise	1606-17
Exercise		sequential	10.18 b	1606-17
The preceding techniques	and	conjunctive	the chase	1607-1
the chase	to	constraint	an axiomatization	1607-1
the chase	can be used	action	an axiomatization	1607-1
the chase	develop	action	an axiomatization	1607-1
an axiomatization	of	constraint	unrestricted implication	1607-1
unrestricted implication	for	constraint	the family	1607-1
the family	of	constraint	all typed dependencies	1607-1
This section	develops	action	a very different paradigm	1608-1
a very different paradigm	for	constraint	dependencies	1608-1
a very different paradigm	specifying	action	dependencies	1608-1
dependencies	on	constraint	the use	1608-1
dependencies	based	action	the use	1608-1
the use	of	constraint	algebraic expressions	1608-1
the class	of	constraint	dependencies	1608-2
dependencies	to	constraint	the class	1608-2
dependencies	formed	attribute	Surprisingly equivalent	1608-2
dependencies	is	attribute	Surprisingly equivalent	1608-2
the class	of	constraint	typed dependencies	1608-2
We	also present	action	an axiomatization	1608-3
an axiomatization		sequential	that	1608-3
that	in	constraint	primarily algebraic properties	1608-3
that	is rooted	action	primarily algebraic properties	1608-3
primarily algebraic properties		sequential	chasing	1608-3
chasing	and	conjunctive	tableau	1608-3
tableau		sequential	manipulations	1608-3
We	with	constraint	examples	1609-1
We	begin	action	examples	1609-1
examples		sequential	that	1609-1
that	and	conjunctive	this approach	1609-1
that	motivate	action	this approach	1609-1
that	illustrate	action	this approach	1609-1
Example		sequential	10.4.1	1610-1
10.4.1	Let	action	R	1610-1
R		sequential	ABCD	1610-1
ABCD	be	attribute	a relation schema	1610-1
<B>	Consider	action	the tgd	1610-2
the tgd		sequential	τ	1610-2
τ	of	constraint	Fig	1610-2
10.4	and	conjunctive	the algebraic expression	1610-3
It	to	constraint	each instance	1611-1
It	that	constraint	each instance	1611-1
It	for	constraint	each instance	1611-1
It	is	attribute	straightforward	1611-1
It	verify	action	each instance	1611-1
each instance		sequential	I	1611-1
I	over	constraint	ABCD	1611-1
ABCD		sequential	I	1611-1
I		sequential	τ iff π AC	1611-1
τ iff π AC		sequential	π	1611-1
π		sequential	AB	1611-1
AB		sequential	I	1611-1
I		sequential	π BC	1611-1
π BC		sequential	I	1611-1
I		sequential	⊆	1611-1
⊆		sequential	π AC	1611-1
π AC		sequential	I	1611-1
<B>	Now consider	action	dependency σ	1612-1
One	that	constraint	each instance	1612-2
One	for	constraint	each instance	1612-2
One	can similarly verify	action	each instance	1612-2
each instance		sequential	I	1612-2
I	over	constraint	ABCD	1612-2
ABCD		sequential	I	1612-2
I	|=	sequential	σ	1612-2
σ		sequential	iff	1612-2
iff		sequential	π AC	1612-2
π AC		sequential	π AB	1612-2
π AB		sequential	I	1612-2
I		sequential	π BC	1612-2
π BC		sequential	I	1612-2
I		sequential	⊆ π AC	1612-2
⊆ π AC		sequential	π AD	1612-2
π AD		sequential	I	1612-2
I		sequential	π CD	1612-2
π CD		sequential	I	1612-2
B C D B C D T x y′ S y′		sequential	x	1613-1
x		sequential	y′	1613-1
y′		sequential	y′	1613-1
y′		sequential	t	1613-1
t		sequential	x S′	1613-1
x S′		sequential	w′	1613-1
w′		sequential	w′	1613-1
w′		sequential	Figure	1613-1
Figure		sequential	10.4	1613-1
10.4		sequential	Dependencies	1613-1
Dependencies	of	constraint	Example 10.4.1	1613-1
project		sequential	join	1613-2
join		sequential	PJ	1613-2
PJ		sequential	A expression	1613-2
A expression	is	attribute	an algebraic expression	1613-2
an algebraic expression	over	constraint	a single relation schema	1613-2
a single relation schema	using	action	only projection	1613-2
only projection	and	conjunctive	natural join	1613-2
We	describe next	action	a natural recursive algorithm	1613-3
a natural recursive algorithm	for	constraint	PJ expressions	1613-3
a natural recursive algorithm	translating	action	PJ expressions	1613-3
PJ expressions	into	constraint	tableau queries	1613-3
tableau queries	see	action	Exercise 10.23	1613-3
This algorithm	in	constraint	the equivalence proofs	1613-4
This algorithm	is	attribute	also implicit	1613-4
the equivalence proofs	of	constraint	Chapter 4	1613-4
Input		sequential	a PJ expression	1614-1
a PJ expression		sequential	E	1614-1
E	over	constraint	relation	1614-1
relation		sequential	schema R	1614-1
schema R		sequential	A1	1614-1
<B>	.	sequential	<B>	1614-2
<B>	.	sequential	<B>	1614-3
<B>		sequential	<B>	1614-4
<B>	.	sequential	<B>	1614-5
<B>	.	sequential	<B>	1614-6
xn		sequential	}	1614-7
}		sequential	x1	1614-7
<B>	.	sequential	<B>	1614-8
<B>	.	sequential	<B>	1614-9
xn		sequential	xn	1614-10
Inductive steps		sequential	Inductive steps	1615-1
<B>	Let	action	X	1616-1
X	be	attribute	the intersection	1616-1
the intersection	of	constraint	the output sorts	1616-1
the output sorts	of	constraint	q1	1616-1
q1	and	conjunctive	q2	1616-1
<B>	without	constraint	loss	1616-2
<B>	Assume	action	loss	1616-2
loss	of	constraint	generality	1616-2
generality	that	constraint	the two tableaux	1616-2
the two tableaux	use	action	distinct variables	1616-2
distinct variables	except	constraint	t1	1616-2
distinct variables	that	constraint	t1	1616-2
t1		sequential	A	1616-2
A	= A	sequential	t2	1616-2
t2	for	constraint	A ∈ X	1616-2
<B>	Then return	action	T1	1616-3
T1	∪	sequential	T2	1616-3
T2		sequential	t1	1616-3
t1	⊲⊳	sequential	t2	1616-3
<B>	that	constraint	T	1617-1
<B>	Suppose now	action	T	1617-1
T		sequential	T ′	1617-1
T ′	is	attribute	a typed dependency	1617-1
a typed dependency	with	constraint	the property	1617-1
the property		sequential	that	1617-1
that	for	constraint	some free tuple t	1617-1
some free tuple t		sequential	T	1617-1
T		sequential	t	1617-1
t	is	attribute	the tableau	1617-1
the tableau	by	constraint	this algorithm	1617-1
the tableau	associated	action	this algorithm	1617-1
this algorithm	with	constraint	PJ expression E	1617-1
PJ expression E	and	conjunctive	T ′	1617-1
T ′		sequential	t	1617-1
t	is	attribute	the tableau	1617-1
the tableau	with	constraint	PJ expression	1617-1
the tableau	associated	action	PJ expression	1617-1
PJ expression		sequential	E′	1617-1
<B>	that	constraint	the only variables	1617-2
<B>	Suppose also	action	the only variables	1617-2
the only variables	to	constraint	T ′	1617-2
T ′	and	conjunctive	T	1617-2
T	in	constraint	t	1617-2
T	are	attribute	those	1617-2
<B>	raises	action	three natural questions	1618-1
three natural questions	Is	action	the family	1618-1
the family	of	constraint	PJ inclusions	1618-1
PJ inclusions	to	constraint	the set	1618-1
the set	of	constraint	typed tgd	1618-1
typed tgd		sequential	s	1618-1
<B>	If	constraint	this paradigm	1618-2
this paradigm	to	constraint	all typed tgd	1618-2
this paradigm	2 can be extended	action	all typed tgd	1618-2
this paradigm	capture	action	all typed tgd	1618-2
all typed tgd		sequential	<B>	1618-2
this paradigm	to	constraint	typed egd	1618-3
this paradigm	3 Can be extended	action	typed egd	1618-3
this paradigm	capture	action	typed egd	1618-3
typed egd		sequential	s	1618-3
s		sequential	tgd	1618-3
tgd		sequential	<B>	1618-3
The answer	to	constraint	the first question	1619-1
the first question	is	attribute	Exercise 10.24	1619-1
the first question	see	action	Exercise 10.24	1619-1
The answer	to	constraint	the questions	1620-1
The answer	and	conjunctive	the questions	1620-1
the questions	is	attribute	<B>	1620-1
<B>	on	constraint	the notion	1620-2
<B>	relies	action	the notion	1620-2
the notion	of	constraint	extended relations	1620-2
extended relations	and	conjunctive	project	1620-2
project	join	action	extended expressions	1620-2
<B>	Let	action	R	1620-3
R		sequential	A1	1620-3
<B>	.	sequential	<B>	1620-4
<B>	.	sequential	<B>	1620-5
<B>	be	attribute	a relation schema	1620-6
<B>	For	constraint	i	1620-7
i		sequential	∈	1620-7
∈		sequential	1	1620-7
1	n	conjunctive	we	1620-7
we	that	constraint	there	1620-7
we	suppose	action	there	1620-7
there	is	attribute	an infinite set	1620-7
an infinite set	of	constraint	attributes	1620-7
attributes		sequential	A1	1620-7
A1		sequential	A2	1620-7
<B>	.	sequential	<B>	1620-8
<B>	.	sequential	<B>	1620-9
<B>	called	action	copies	1620-10
copies	of	constraint	A i i i	1620-10
The extended schema	of	constraint	R	1620-11
R	is	attribute	schema	1620-11
schema		sequential	the R	1620-11
the R		sequential	A1	1620-11
<B>	.	sequential	<B>	1620-12
<B>	.	sequential	<B>	1620-13
A1 n		sequential	A2	1620-14
A2		sequential	n	1620-14
<B>	.	sequential	<B>	1620-15
<B>	.	sequential	<B>	1620-16
<B>	]	sequential	<B>	1620-17
<B>	For	constraint	an instance	1620-18
an instance		sequential	I	1620-18
I	of	constraint	R	1620-18
R		sequential	the extended instance	1620-18
the extended instance	of	constraint	R	1620-18
R	to	constraint	j I	1620-18
R	corresponding	action	j I	1620-18
j I	denoted	action	I	1620-18
I	has	action	one tuple	1620-18
one tuple		sequential	u	1620-18
u	for	constraint	each tuple	1620-18
each tuple		sequential	u	1620-18
u		sequential	∈	1620-18
∈		sequential	I	1620-18
I		sequential	u	1620-18
u		sequential	A	1620-18
A	where =	sequential	u	1620-18
u		sequential	A	1620-18
A		sequential	i	1620-18
i		sequential	i	1620-18
i	for	constraint	i	1620-18
i		sequential	∈	1620-18
∈		sequential	1	1620-18
1		sequential	n	1620-18
n	and	conjunctive	j	1620-18
j		sequential	0	1620-18
B x		sequential	C D B	1621-1
C D B		sequential	C	1621-1
C		sequential	D	1621-1
D		sequential	T	1621-1
T		sequential	w′	1621-1
w′		sequential	T	1621-1
T	x	sequential	w′	1621-1
w′		sequential	w′	1621-1
w′		sequential	w′	1621-1
w′	w	constraint	x′	1621-1
<B>	Given	action	two extended PJ expressions E	1621-2
two extended PJ expressions E	and	conjunctive	E′	1621-2
E′	with	constraint	the same target sort	1621-2
the same target sort	and	conjunctive	instance	1621-2
instance		sequential	I	1621-2
I	over	constraint	R	1621-2
R		sequential	E	1621-2
E		sequential	I	1621-2
I		sequential	⊆e	1621-2
⊆e		sequential	E′	1621-2
E′		sequential	I	1621-2
I	denotes	action	E	1621-2
E		sequential	I	1621-2
I		sequential	⊆ E′	1621-2
⊆ E′		sequential	I	1621-2
<B>	is illustrated next	action	<B>	1622-1
Example		sequential	10.4.3	1623-1
10.5		sequential	10.5	1623-2
<B>	Let	action	E	1623-3
E	=	sequential	π ACD	1623-3
π ACD		sequential	1	1623-3
1		sequential	R	1623-3
R		sequential	⊲⊳	1623-3
⊲⊳		sequential	π C1D1	1623-3
π C1D1		sequential	R	1623-3
R		sequential	⊲⊳ π A1C1D	1623-3
⊲⊳ π A1C1D		sequential	R	1623-3
we	Here use	action	A	1624-1
A		sequential	A1	1624-1
<B>	.	sequential	<B>	1624-2
<B>	.	sequential	<B>	1624-3
<B>	to	constraint	different copies	1624-4
<B>	denote	action	different copies	1624-4
different copies		sequential	the attribute A	1624-4
the attribute A		sequential	<B>	1624-4
It	that	constraint	each instance	1625-1
It	for	constraint	each instance	1625-1
It	can be shown	action	each instance	1625-1
each instance		sequential	I	1625-1
I	over	constraint	ABCD	1625-1
ABCD		sequential	I	1625-1
I		sequential	τ iff E1	1625-1
τ iff E1		sequential	I	1625-1
I		sequential	E2	1625-1
E2		sequential	I	1625-1
I		sequential	E1	1625-1
E1	where =	sequential	π ACD	1625-1
π ACD		sequential	E	1625-1
E		sequential	E2	1625-1
E2	=	sequential	π ACD	1625-1
π ACD		sequential	π AB 1	1625-1
π AB 1		sequential	R	1625-1
R		sequential	π B1 CD	1625-1
π B1 CD		sequential	R	1625-1
<B>	Consider now	action	the functional dependency A → BC	1626-1
the functional dependency A → BC	over	constraint	ABCD	1626-1
<B>	to	constraint	π ABC	1626-2
<B>	is	attribute	equivalent	1626-2
π ABC		sequential	R	1626-2
R		sequential	π	1626-2
π		sequential	AB 1C1	1626-2
AB 1C1		sequential	R	1626-2
R		sequential	⊆e π ABCB 1C1	1626-2
⊆e π ABCB 1C1		sequential	R	1626-2
<B>	Finally consider	action	σ	1627-1
σ	of	constraint	Fig	1627-1
10.5		sequential	10.5	1627-2
<B>	to	constraint	F1 ⊆e F2	1627-3
<B>	is	attribute	equivalent	1627-3
F1 ⊆e F2		sequential	F1	1627-3
F1	where =	sequential	π AA 1	1627-3
π AA 1		sequential	E	1627-3
E		sequential	F2	1627-3
F2	=	sequential	π AA 1	1627-3
π AA 1		sequential	R	1627-3
We	that	constraint	algebraic dependencies	1628-1
We	next see	action	algebraic dependencies	1628-1
algebraic dependencies	to	constraint	typed dependencies	1628-1
algebraic dependencies	correspond precisely	action	typed dependencies	1628-1
Theorem		sequential	10.4.4	1629-1
Crux Let R		sequential	A1	1630-1
<B>	.	sequential	<B>	1630-2
<B>	.	sequential	<B>	1630-3
<B>	be	attribute	a relation schema	1630-4
a relation schema	and	conjunctive	E	1630-4
a relation schema	let	action	E	1630-4
E		sequential	⊆e	1630-4
⊆e		sequential	E′	1630-4
E′	be	attribute	an algebraic dependency	1630-4
an algebraic dependency	over	constraint	R	1630-4
R		sequential	E	1630-4
E	and	conjunctive	E′	1630-4
E′	where have	action	target sort X	1630-4
<B>	Without	constraint	loss	1630-5
loss	of	constraint	generality	1630-5
generality		sequential	we	1630-5
we	that	constraint	there	1630-5
we	can assume	action	there	1630-5
there	is	attribute	k	1630-5
k	that	constraint	the sets	1630-5
the sets	of	constraint	attributes	1630-5
attributes	in	constraint	E	1630-5
attributes	involved	action	E	1630-5
E	and	conjunctive	E′	1630-5
E′	in	constraint	U	1630-5
E′	are contained	action	U	1630-5
U	=	sequential	A1	1630-5
U	{	sequential	A1	1630-5
<B>	.	sequential	<B>	1630-6
<B>	.	sequential	<B>	1630-7
A1 n		sequential	A1 n	1630-8
<B>	.	sequential	<B>	1630-9
<B>	.	sequential	<B>	1630-10
Ak	n	conjunctive	U	1630-11
U	to	constraint	E	1630-11
U	corresponding	action	E	1630-11
E	and	conjunctive	E′	1630-11
We	without	constraint	loss	1630-12
We	assume	action	loss	1630-12
loss	of	constraint	generality	1630-12
generality		sequential	that	1630-12
that		sequential	τ	1630-12
τ	and	conjunctive	τ	1630-12
τ	do not share	action	any variables	1630-12
any variables	except	constraint	t	1630-12
any variables	that	constraint	t	1630-12
t		sequential	A	1630-12
A	= A	sequential	t′	1630-12
t′	for	constraint	each A ∈ X	1630-12
<B>	Consider	action	T	1631-1
T	over	constraint	U	1631-1
<B>	For	constraint	each tuple	1631-2
each tuple		sequential	∈	1631-2
∈		sequential	T ∈	1631-2
T ∈	and	conjunctive	j	1631-2
j		sequential	1	1631-2
1		sequential	k	1631-2
k		sequential	j R	1631-2
j R		sequential	x1	1631-2
<B>	.	sequential	<B>	1631-3
<B>	.	sequential	<B>	1631-4
xn		sequential	xi	1631-5
xi	for	constraint	i	1631-5
xi	where = s A	sequential	i	1631-5
i		sequential	∈	1631-5
∈		sequential	1	1631-5
1		sequential	n	1631-5
n		sequential	i	1631-5
i		sequential	j	1631-5
j		sequential	j	1631-5
j	′	sequential	A	1631-5
A	for	constraint	i	1631-5
A	= A	sequential	i	1631-5
i		sequential	∈	1631-5
∈		sequential	1	1631-5
1	n	conjunctive	j	1631-5
1	and	conjunctive	j	1631-5
j		sequential	j	1631-5
j		sequential	i	1631-5
i		sequential	i	1631-5
<B>	Let	action	ϕ	1632-1
ϕ		sequential	x1	1632-1
<B>	.	sequential	<B>	1632-2
<B>	.	sequential	<B>	1632-3
xp	be	attribute	the conjunction	1632-4
the conjunction	of	constraint	all atoms	1632-4
all atoms	from	constraint	τ	1632-4
all atoms	obtained	action	τ	1632-4
τ	in	constraint	this manner	1632-4
<B>	Let	action	ψ	1632-5
ψ		sequential	y1	1632-5
<B>	.	sequential	<B>	1632-6
<B>	.	sequential	<B>	1632-7
<B>	from	constraint	τ ′	1632-8
<B>	be constructed analogously	action	τ ′	1632-8
It	can now be shown	action	Exercise	1632-9
Exercise		sequential	10.26	1632-9
10.26	that	constraint	E ⊆e E′	1632-9
E ⊆e E′	to	constraint	the typed dependency	1632-9
E ⊆e E′	is	attribute	equivalent	1632-9
the typed dependency		sequential	where z1	1632-9
<B>	.	sequential	<B>	1632-10
<B>	.	sequential	<B>	1632-11
zr	is	attribute	the set	1632-12
the set	of	constraint	variables	1632-12
variables	in	constraint	y1	1632-12
variables	{	sequential	y1	1632-12
<B>	.	sequential	<B>	1632-13
<B>	.	sequential	<B>	1632-14
yq	−	sequential	x1	1632-15
yq	{	sequential	x1	1632-15
<B>	.	sequential	<B>	1632-16
<B>	.	sequential	<B>	1632-17
xp		sequential	}	1632-18
<B>	For	constraint	the converse	1633-1
the converse		sequential	we	1633-1
we	generalize	action	the technique	1633-1
the technique	in	constraint	Example 10.4.3	1633-1
the technique	used	action	Example 10.4.3	1633-1
<B>	For	constraint	each attribute A	1633-2
each attribute A		sequential	one distinct copy	1633-2
one distinct copy	of	constraint	A	1633-2
A	for	constraint	each variable	1633-2
A	is used	action	each variable	1633-2
each variable	in	constraint	the A column	1633-2
each variable	occurring	action	the A column	1633-2
Figure		sequential	10.6	1634-1
10.6	shows	action	a family	1634-1
a family	of	constraint	inference rules	1634-1
inference rules	for	constraint	algebraic dependencies	1634-1
<B>	of	constraint	these rules	1634-2
these rules	from	constraint	an algebraic property	1634-2
these rules	stems	action	an algebraic property	1634-2
an algebraic property	of	constraint	join	1634-2
join	and	conjunctive	project	1634-2
project	and	conjunctive	a property	1634-2
project	explicitly uses	action	a property	1634-2
a property	of	constraint	extended instances	1634-2
It	that	constraint	all expressions	1634-3
It	is assumed here	action	all expressions	1634-3
all expressions	are well formed	action	<B>	1634-3
The use	of	constraint	these rules	1634-4
these rules	to	constraint	dependencies	1634-4
these rules	infer	action	dependencies	1634-4
dependencies	in	constraint	Exercises 10.31	1634-4
dependencies	is considered	action	Exercises 10.31	1634-4
Exercises 10.31	and	conjunctive	10.32	1634-4
It	that	constraint	Theorem 10.4.5	1635-1
It	can be shown	action	Theorem 10.4.5	1635-1
<B>	.	sequential	<B>	1635-2
<B>	.	sequential	<B>	1635-3
AD8 }	for	constraint	unrestricted implication	1635-4
AD8 }	and	conjunctive	unrestricted implication	1635-4
AD8 }	is	attribute	sound	1635-4
AD8 }	inferring	action	unrestricted implication	1635-4
unrestricted implication	of	constraint	algebraic dependencies	1635-4
<B>	To	constraint	this discussion	1636-1
<B>	conclude	action	this discussion	1636-1
this discussion	of	constraint	the algebraic perspective	1636-1
the algebraic perspective	on	constraint	dependencies	1636-1
dependencies		sequential	we	1636-1
we	consider	action	a new operation	1636-1
a new operation		sequential	direct product	1636-1
direct product	and	conjunctive	the important notion	1636-1
the important notion	of	constraint	faithfulness	1636-1
Faithfulness	and	conjunctive	Armstrong	1637-1
Armstrong		sequential	Relations	1637-1
<B>	To	constraint	we	1637-2
<B>	accomplish	attribute	this	1637-2
we	first introduce	action	a new way	1637-2
a new way	to	constraint	instances	1637-2
a new way	combine	action	instances	1637-2
instances	and	conjunctive	an important property	1637-2
an important property	of	constraint	it	1637-2
<B>	If	constraint	E	1638-1
E		sequential	⊆e E′ πXE	1638-1
⊆e E′ πXE		sequential	⊆e	1638-1
⊆e		sequential	πXE	1638-1
<B>		sequential	<B>	1638-2
<B>	If	constraint	X ⊆ sort	1639-1
X ⊆ sort		sequential	R	1639-1
R	and	conjunctive	A	1639-1
A		sequential	A′	1639-1
A′	are	attribute	copies	1639-1
copies	of	constraint	the same attribute	1639-1
the same attribute		sequential	πAA′R	1639-1
πAA′R	⊲⊳	constraint	πAXR =e πAA′XR	1639-1
Figure		sequential	10.6	1640-1
10.6	Let	action	R	1640-1
R	be	attribute	a relation schema	1640-1
a relation schema	of	constraint	arity	1640-1
arity	n	conjunctive	<B>	1640-1
<B>	Given	action	tuples	1640-2
tuples		sequential	u	1640-2
u	=	sequential	x1	1640-2
<B>	.	sequential	<B>	1640-3
<B>	.	sequential	<B>	1640-4
xn	and	conjunctive	v	1640-5
v	=	sequential	y1	1640-5
<B>	.	sequential	<B>	1640-6
<B>	.	sequential	<B>	1640-7
<B>		sequential	we	1640-8
we	define	action	the direct product	1640-8
the direct product	of	constraint	u	1640-8
u	and	conjunctive	v	1640-8
v	to	constraint	u	1640-8
v	be	attribute	u	1640-8
u		sequential	v	1640-8
v	=	sequential	x1	1640-8
x1		sequential	y1	1640-8
<B>	.	sequential	<B>	1640-9
<B>	.	sequential	<B>	1640-10
xn		sequential	<B>	1640-11
The direct product	of	constraint	two instances	1641-1
two instances		sequential	I	1641-1
I		sequential	J	1641-1
J	over	constraint	R	1641-1
R	is	attribute	I	1641-1
I	⊗	constraint	J	1641-1
J	=	sequential	u	1641-1
J	{	sequential	u	1641-1
u		sequential	⊗	1641-1
⊗		sequential	v	1641-1
v		sequential	u	1641-1
u		sequential	∈	1641-1
∈		sequential	I	1641-1
I		sequential	v	1641-1
v		sequential	∈ J	1641-1
∈ J		sequential	}	1641-1
<B>	to	constraint	k- ary direct product instances	1642-1
<B>	is generalized	action	k- ary direct product instances	1642-1
<B>	form	action	k- ary direct product instances	1642-1
k- ary direct product instances	for	constraint	each finite k.	1642-1
<B>	because	constraint	the ⊗ operator	1643-1
<B>	following	action	the ⊗ operator	1643-1
<B>	holds	action	the ⊗ operator	1643-1
the ⊗ operator	with	constraint	project	1643-1
the ⊗ operator	commutes	action	project	1643-1
project	and	conjunctive	extension	1643-1
project	join	action	extension	1643-1
extension	see	action	Exercise 10.29	1643-1
Bibliographic Notes Proposition 10.4.6		sequential	Bibliographic Notes Proposition 10.4.6	1644-1
We	that	constraint	each set	1645-1
We	can now prove	action	each set	1645-1
each set	of	constraint	typed dependencies	1645-1
typed dependencies	has	action	an Armstrong relation	1645-1
Theorem		sequential	10.4.7	1646-1
Proof	Let	action	Ŵ	1647-1
Ŵ	be	attribute	the set	1647-1
the set	of	constraint	typed dependencies	1647-1
typed dependencies	over	constraint	R	1647-1
R	in	constraint	not ∗	1647-1
<B>	For	constraint	each γ ∈	1647-2
each γ ∈	let	action	<B>	1647-2
<B>		sequential	<B>	1647-3
This result	to	constraint	finite Armstrong relations	1648-1
This result	can not be strengthened	action	finite Armstrong relations	1648-1
This result	yield	action	finite Armstrong relations	1648-1
finite Armstrong relations	because	constraint	one	1648-1
one	can exhibit	action	a finite set	1648-1
a finite set	of	constraint	typed tgd	1648-1
typed tgd	with	constraint	no finite Armstrong relation	1648-1
Bibliographic Notes		sequential	Bibliographic Notes	1649-1
<B>	Because	constraint	readers	1650-1
readers	by	constraint	the great number	1650-1
readers	could be overwhelmed	action	the great number	1650-1
the great number	of	constraint	dependency theory terms	1650-1
dependency theory terms		sequential	we	1650-1
we	have used	action	a subset	1650-1
a subset	of	constraint	the terminology	1650-1
<B>	For	constraint	instance	1650-2
instance		sequential	head	1650-2
head		sequential	the typed tgd s	1650-2
the typed tgd s		sequential	that	1650-2
that	in	constraint	depth	1650-2
that	were studied	action	depth	1650-2
depth	are called	action	template dependencies	1650-2
<B>	In	constraint	addition	1650-3
addition		sequential	the typed unirelational dependencies	1650-3
the typed unirelational dependencies		sequential	that	1650-3
that	are considered here	action	embedded implicational dependencies	1650-3
that	were historically called	action	embedded implicational dependencies	1650-3
embedded implicational dependencies		sequential	eid	1650-3
eid		sequential	s	1650-3
s	and	conjunctive	their full counterparts	1650-3
their full counterparts	were called	action	implicational dependencies	1650-3
implicational dependencies		sequential	id s	1650-3
id s		sequential	<B>	1650-3
We	use	action	this terminology	1650-4
this terminology	in	constraint	the following notes	1650-4
The proliferation	of	constraint	dependencies	1651-1
dependencies	spawned	action	interest	1651-1
interest	in	constraint	the development	1651-1
the development	of	constraint	a unifying framework	1651-1
a unifying framework		sequential	that	1651-1
that	of	constraint	them	1651-1
that	subsumed	attribute	essentially all	1651-1
Nicolas		sequential	Nic78	1651-2
Nic78	with	constraint	that fd	1651-2
Nic78	is credited	action	that fd	1651-2
Nic78	first observing	action	that fd	1651-2
that fd		sequential	mvd	1651-2
mvd	and	conjunctive	others	1651-2
others	have	action	a natural representation	1651-2
a natural representation	in	constraint	first order	1651-2
first order		sequential	logic	1651-2
<B>	At	constraint	roughly the same time	1651-3
roughly the same time		sequential	several researchers	1651-3
several researchers	reached essentially	action	the same generalized class	1651-3
the same generalized class	of	constraint	dependencies	1651-3
dependencies		sequential	that	1651-3
that	in	constraint	this chapter	1651-3
that	was studied	action	this chapter	1651-3
BV81a	introduced	action	the class	1651-4
the class	of	constraint	tgd	1651-4
tgd	and	conjunctive	egd	1651-4
egd	defined	action	the paradigm	1651-4
egd	using	action	the paradigm	1651-4
the paradigm	of	constraint	tableaux	1651-4
<B>	in	constraint	connection	1651-5
<B>	Chasing	action	connection	1651-5
<B>	was studied	action	connection	1651-5
connection	with	constraint	dependencies	1651-5
connection	both	conjunctive	dependencies	1651-5
connection	and	conjunctive	dependencies	1651-5
connection	embedded	action	dependencies	1651-5
dependencies	in	constraint	BV84 c	1651-5
Reference		sequential	Fag82b	1651-6
Fag82b	introduced	action	the class	1651-6
the class	of	constraint	typed dependencies	1651-6
typed dependencies		sequential	essentially the same family	1651-6
essentially the same family	of	constraint	dependencies	1651-6
dependencies	in	constraint	the paradigm	1651-6
dependencies	but	conjunctive	the paradigm	1651-6
dependencies	presented	action	the paradigm	1651-6
the paradigm	of	constraint	order	1651-6
order		sequential	logic	1651-6
YP82	Simultaneously introduced	action	the algebraic dependencies	1651-7
the algebraic dependencies		sequential	which	1651-7
which	present	action	the same class	1651-7
the same class	in	constraint	algebraic terms	1651-7
A generalization	of	constraint	algebraic dependencies	1651-8
algebraic dependencies	to	constraint	the untyped case	1651-8
the untyped case	in	constraint	Abi83	1651-8
the untyped case	is presented	action	Abi83	1651-8
Related general classes	of	constraint	dependencies	1652-1
dependencies	at	constraint	this time	1652-1
dependencies	introduced	action	this time	1652-1
this time	are	attribute	the general dependencies	1652-1
the general dependencies		sequential	PJ81	1652-1
PJ81		sequential	which	1652-1
which	to	constraint	full typed tgd	1652-1
which	are	attribute	equivalent	1652-1
full typed tgd		sequential	the s	1652-1
the s	and	conjunctive	generalized dependency constraints	1652-1
generalized dependency constraints		sequential	GJ82	1652-1
GJ82		sequential	which	1652-1
which	are	attribute	the full dependencies	1652-1
several kinds	of	constraint	constraints	1653-1
constraints		sequential	that	1653-1
that	outside	constraint	the dependencies	1653-1
that	lie	action	the dependencies	1653-1
the dependencies	in	constraint	this chapter	1653-1
the dependencies	described	action	this chapter	1653-1
this chapter	in	constraint	the literature	1653-1
this chapter	Importantly have been studied	action	the literature	1653-1
Research	on	constraint	the use	1653-2
the use	of	constraint	order	1653-2
order		sequential	arbitrary logic sentences	1653-2
arbitrary logic sentences	as	constraint	constraints	1653-2
constraints	includes	action	GM78	1653-2
GM78		sequential	Nic78	1653-2
Nic78		sequential	Var82 b	1653-2
A different extension	of	constraint	dependencies	1653-3
dependencies	on	constraint	partitioning relationships	1653-3
dependencies	based	action	partitioning relationships	1653-3
partitioning relationships		sequential	which	1653-3
which	in	constraint	order	1653-3
which	are	attribute	not expressible	1653-3
order		sequential	logic	1653-3
logic	in	constraint	Cos87	1653-3
logic	is studied	action	Cos87	1653-3
Another kind	of	constraint	dependency	1653-4
dependency	is	attribute	the afunctional dependency of	1653-4
<B>	On	constraint	the other hand	1654-1
the other hand		sequential	the equivalence	1654-1
the equivalence	of	constraint	implication	1654-1
the equivalence	and	conjunctive	implication	1654-1
implication	for	constraint	full dependencies	1654-1
full dependencies	in	constraint	BV81a	1654-1
full dependencies	was observed	action	BV81a	1654-1
That deciding implication	for	constraint	full typed dependencies	1654-2
full typed dependencies	in	constraint	exptime	1654-2
full typed dependencies	is	attribute	complete	1654-2
exptime	to	constraint	CLM81	1654-2
exptime	is	attribute	due	1654-2
<B>	See also	action	BV84c	1654-3
BV84c		sequential	FUMY83	1654-3
FUMY83		sequential	which	1654-3
which	present	action	numerous results	1654-3
numerous results	on	constraint	typed dependencies	1654-3
numerous results	and	conjunctive	typed dependencies	1654-3
numerous results	embedded	action	typed dependencies	1654-3
The special case	of	constraint	deciding implication	1654-4
deciding implication	of	constraint	a typed dependency	1654-4
a typed dependency	by	constraint	ind	1654-4
ind	to	constraint	<B>	1654-4
ind	has been shown	attribute	pspace complete	1654-4
ind	be	attribute	pspace complete	1654-4
The issue	of	constraint	inferring view dependencies	1655-1
inferring view dependencies	in	constraint	Klu80	1655-1
inferring view dependencies	was first studied	action	Klu80	1655-1
Klu80		sequential	Theorem 10.2.5	1655-1
Theorem 10.2.5	where was presented	action	<B>	1655-1
Reference		sequential	KP82	1655-2
KP82	developed	action	Theorem 10.2.6	1655-2
The issue	of	constraint	view images	1656-1
The issue	to	constraint	view images	1656-1
The issue	attempting	action	view images	1656-1
The issue	characterize	action	view images	1656-1
view images	of	constraint	a satisfaction family	1656-1
a satisfaction family	as	constraint	a satisfaction family	1656-1
a satisfaction family	in	constraint	GZ82	1656-1
a satisfaction family	was first raised	action	GZ82	1656-1
GZ82		sequential	Exercise 10.11b	1656-1
Exercise 10.11b	where was shown	action	<B>	1656-1
Theorem 10.2.7	to	constraint	Fag82	1656-2
Theorem 10.2.7	is	attribute	due	1656-2
Fag82		sequential	b	1656-2
b	although	constraint	a different proof technique	1656-2
a different proof technique	was used	action	<B>	1656-2
Reference		sequential	Hul84	1656-3
Hul84	that	constraint	some projections	1656-3
Hul84	demonstrates	action	some projections	1656-3
some projections	of	constraint	satisfaction families	1656-3
satisfaction families	by	constraint	fd	1656-3
satisfaction families	defined	action	fd	1656-3
fd		sequential	Exercises	1656-3
Exercises	by	constraint	any finite set	1656-3
Exercises	can not be characterized	action	any finite set	1656-3
any finite set	of	constraint	full dependencies	1656-3
full dependencies	see	action	Exercise 10.11	1656-3
Exercise 10.11		sequential	c	1656-3
c		sequential	d	1656-3
That investigation	in	constraint	Hul85	1657-1
That investigation	is extended	action	Hul85	1657-1
Hul85		sequential	it	1657-1
it	that	constraint	a family	1657-1
it	if	constraint	a family	1657-1
it	is	attribute	a family	1657-1
it	where is shown	action	a family	1657-1
a family	of	constraint	fd	1657-1
fd	over	constraint	U	1657-1
U	and	conjunctive	V	1657-1
V		sequential	⊆	1657-1
⊆		sequential	U	1657-1
U	if	constraint	πV	1657-1
U	and	conjunctive	πV	1657-1
πV		sequential	sat	1657-1
sat		sequential	U	1657-1
U	=	sequential	sat	1657-1
sat		sequential	V	1657-1
V	for	constraint	any set s	1657-1
any set s	of	constraint	fd	1657-1
fd		sequential	πV	1657-1
πV	sat	action	U	1657-1
U	=	sequential	sat	1657-1
sat		sequential	V	1657-1
V		sequential	Ŵ	1657-1
Ŵ	for	constraint	any finite set	1657-1
any finite set	of	constraint	full dependencies	1657-1
The direct product construction	from	constraint	Fag82 b	1658-1
The direct product construction	is	attribute	Fag82 b	1658-1
Proposition 10.4.6	to	constraint	<B>	1658-2
Proposition 10.4.6	is	attribute	due	1658-2
The direct product	in	constraint	mathematical logic	1659-1
The direct product	has been studied	action	mathematical logic	1659-1
mathematical logic		sequential	the notion	1659-1
the notion	of	constraint	faithful	1659-1
faithful	presented here	action	Exercise 10.28	1659-1
faithful	see	action	Exercise 10.28	1659-1
Exercise 10.28	to	constraint	the notion	1659-1
Exercise 10.28	is	attribute	equivalent	1659-1
the notion	of	constraint	preservation	1659-1
preservation	under	constraint	direct product	1659-1
direct product	found	action	CK73	1659-1
direct product	see	action	CK73	1659-1
CK73	and	conjunctive	the notion	1659-1
the notion	of	constraint	downward faithful	1659-1
downward faithful	to	constraint	the notion	1659-1
downward faithful	from	constraint	the notion	1659-1
downward faithful	but	conjunctive	the notion	1659-1
downward faithful	is	attribute	related	1659-1
the notion	of	constraint	preservation	1659-1
preservation	under	constraint	direct factors	1659-1
Exercises Exercise 10.1		sequential	Exercises Exercise 10.1	1660-1
<B>	Exercise	action	10.2	1661-1
10.2	Consider	action	the tableaux	1661-1
the tableaux	in	constraint	Example 10.3.2	1661-1
<B>	Give	action	σ	1661-2
σ	•	sequential	σ	1661-2
<B>	Compare	action	it	1661-3
it	as	constraint	a mapping	1661-3
a mapping	to	constraint	σ	1661-3
<B>	Give	action	σ	1661-4
σ	•	sequential	τ	1661-4
<B>	Compare	action	it	1661-5
it	as	constraint	a mapping	1661-5
a mapping	to	constraint	τ	1661-5
τ	•	sequential	σ	1661-5
Exercise		sequential	10.3	1662-1
Exercise		sequential	10.4	1663-1
10.2		sequential	10.2	1663-2
<B>	Exercise	action	R	1664-1
<B>	10.5 Let	action	R	1664-1
R		sequential	ABC	1664-1
ABC	be	attribute	a relation scheme	1664-1
We	construct	action	a family	1664-2
a family	of	constraint	egd	1664-2
egd	over	constraint	R	1664-2
R	as	constraint	<B>	1664-2
R	follows	action	<B>	1664-2
<B>	For	constraint	n 0	1664-3
n 0	let	action	Tn	1664-3
Tn	=	sequential	xi	1664-3
xi		sequential	yi	1664-3
yi		sequential	z	1664-3
z		sequential	2i	1664-3
2i		sequential	xi	1664-3
xi		sequential	yi+1	1664-3
yi+1		sequential	z2i+1	1664-3
z2i+1		sequential	i	1664-3
i		sequential	∈	1664-3
∈		sequential	0	1664-3
0		sequential	n	1664-3
Exercise		sequential	10.6	1665-1
Exercise		sequential	10.8	1666-1
Exercise		sequential	10.9	1667-1
Hint		sequential	Hint	1667-2
Exercise		sequential	10.10	1668-1
Exercise		sequential	10.11	1669-1
10.11		sequential	Let R	1669-1
Let R		sequential	ABCDE	1669-1
ABCDE	and	conjunctive	S	1669-1
S		sequential	ABCD	1669-1
ABCD	be	attribute	relation schemas	1669-1
relation schemas	and	conjunctive	V	1669-1
relation schemas	let	action	V	1669-1
V		sequential	ABCD	1669-1
<B>	=	sequential	A → E → E	1669-2
<B>	Consider	action	A → E → E	1669-2
A → E → E		sequential	B	1669-2
B		sequential	CE	1669-2
CE	→	sequential	D }	1669-2
c		sequential	d1	1670-1
d1		sequential	b	1670-1
b		sequential	c1	1670-1
c1		sequential	d2	1670-1
d2		sequential	a1	1670-1
a1		sequential	b	1670-1
b		sequential	c	1670-1
c		sequential	d3	1670-1
d3		sequential	}	1670-1
}	over	constraint	S	1670-1
Exercises		sequential	Exercises	1671-1
Exercise		sequential	10.12	1672-1
Exercise		sequential	10.13	1673-1
Exercise		sequential	10.14	1674-1
Exercise		sequential	10.15	1675-1
Exercise		sequential	10.18	1676-1
Exercise		sequential	10.19	1677-1
Exercise		sequential	10.20	1678-1
<B>	to	constraint	τ	1679-1
τ		sequential	τ	1679-1
Hint		sequential	Hint	1679-2
<B>	Use	action	part	1679-3
part		sequential	<B>	1679-3
Exercise		sequential	10.22	1680-1
Exercise		sequential	10.23	1681-1
10.23	that	constraint	Algorithm 10.4.2	1681-1
10.23	Prove	action	Algorithm 10.4.2	1681-1
Algorithm 10.4.2	is	attribute	correct	1681-1
<B>	See	action	Exercise 4.18a	1681-2
Exercise		sequential	10.24	1682-1
<B>	that	constraint	there	1683-1
<B>	Prove	action	there	1683-1
there	is	attribute	no pair E	1683-1
no pair E		sequential	E′	1683-1
E′	of	constraint	PJ expressions	1683-1
PJ expressions		sequential	τ	1683-1
τ	to	constraint	E ⊆ E′	1683-1
τ	is	attribute	equivalent	1683-1
E ⊆ E′		sequential	that	1683-1
that		sequential	I	1683-1
I	|=	sequential	τ	1683-1
τ		sequential	iff E	1683-1
iff E		sequential	I	1683-1
I		sequential	⊆ E′	1683-1
⊆ E′		sequential	I	1683-1
expressions		sequential	τ	1684-1
τ	to	constraint	E ⊆ E′	1684-1
τ	is	attribute	equivalent	1684-1
Exercise		sequential	10.25	1685-1
Exercise		sequential	10.27	1686-1
<B>	that	constraint	every algebraic dependency	1686-2
<B>	Prove	action	every algebraic dependency	1686-2
every algebraic dependency	to	constraint	a shallow one	1686-2
every algebraic dependency	is	attribute	equivalent	1686-2
Exercise		sequential	10.28	1687-1
Exercises	but	conjunctive	<B>	1688-1
Exercises	is	attribute	downward faithful	1688-1
<B>	but	conjunctive	<B>	1689-1
<B>	is	attribute	upward faithful	1689-1
Exercise		sequential	10.29	1690-1
Exercise 10.30		sequential	Exercise 10.30	1691-1
<B>	Express	action	this axiom	1692-1
this axiom	in	constraint	the paradigm	1692-1
the paradigm	of	constraint	algebraic dependencies	1692-1
<B>	Prove	action	it	1692-2
it	using	action	axioms	1692-2
axioms		sequential	AD1	1692-2
Exercise		sequential	10.33	1693-1
the only tool		sequential	you	1694-1
you	is	attribute	When a hammer	1694-1
you	have	action	When a hammer	1694-1
When a hammer		sequential	everything	1694-1
everything	to	constraint	a nail	1694-1
everything	like	constraint	a nail	1694-1
everything	begins	action	a nail	1694-1
everything	look	action	a nail	1694-1
we	Will use	action	a hammer	1695-1
a hammer	for	constraint	schema design	1695-1
Riccardo		sequential	decomposition	1696-1
decomposition		sequential	semantic modeling	1696-1
<B>	.	sequential	<B>	1696-2
<B>	.	sequential	<B>	1696-3
Vittorio		sequential	Vittorio	1697-1
Sergio		sequential	Sergio	1698-1
We	have discussed	action	earlier applications	1699-1
earlier applications	of	constraint	dependencies	1699-1
dependencies	in	constraint	connection	1699-1
connection	with	constraint	query optimization	1699-1
query optimization		sequential	Section 8.4	1699-1
Section 8.4	and	conjunctive	user views	1699-1
user views		sequential	Section	1699-1
Section		sequential	10.2	1699-1
<B>	In	constraint	this chapter	1699-2
this chapter		sequential	we	1699-2
we	briefly consider	action	dependencies	1699-2
dependencies	in	constraint	connection	1699-2
dependencies	are used	action	connection	1699-2
connection	with	constraint	the design	1699-2
the design	of	constraint	relational database schemas	1699-2
The problem	of	constraint	database schemas	1700-1
The problem	designing	action	database schemas	1700-1
database schemas	and	conjunctive	the areas	1700-1
database schemas	is	attribute	complex	1700-1
database schemas	spans	action	the areas	1700-1
the areas	of	constraint	cognitive science	1700-1
cognitive science		sequential	knowledge representation	1700-1
knowledge representation		sequential	software practices	1700-1
software practices		sequential	implementation issues	1700-1
implementation issues	and	conjunctive	theoretical considerations	1700-1
<B>	Due to	constraint	the interaction	1700-2
the interaction	of	constraint	these many aspects	1700-2
these many aspects	of	constraint	them	1700-2
them	to	constraint	people	1700-2
people	and	conjunctive	the world	1700-2
people	think	action	the world	1700-2
people	perceive	action	the world	1700-2
the world		sequential	we	1700-2
we	and	conjunctive	a contribution	1700-2
we	can only expect	attribute	relatively narrow	1700-2
a contribution	from	constraint	theoretical techniques	1700-2
<B>	As	constraint	a result	1700-3
a result		sequential	the primary focus	1700-3
the primary focus	of	constraint	this chapter	1700-3
this chapter	to	constraint	the kinds	1700-3
this chapter	is	attribute	the kinds	1700-3
this chapter	introduce	action	the kinds	1700-3
the kinds	of	constraint	formal tools	1700-3
formal tools		sequential	that	1700-3
that	in	constraint	the design process	1700-3
that	are used	action	the design process	1700-3
the design process		sequential	a broader discussion	1700-3
a broader discussion	of	constraint	these tools	1700-3
a broader discussion	to	constraint	these tools	1700-3
a broader discussion	use	action	these tools	1700-3
these tools	in	constraint	practice	1700-3
practice	is not attempted	action	<B>	1700-3
The interested reader	to	constraint	the Bibliographic Notes	1701-1
The interested reader	is referred	action	the Bibliographic Notes	1701-1
the Bibliographic Notes		sequential	which	1701-1
which	indicate	action	treatments	1701-1
which	more broad based	action	treatments	1701-1
treatments	of	constraint	relational schema design	1701-1
relational schema design	where can be found	action	<B>	1701-1
<B>	In	constraint	the following discussion	1702-1
the following discussion	designing	action	a relational schema	1702-1
a relational schema	with	constraint	<B>	1702-1
a relational schema	means	action	<B>	1702-1
a relational schema	coming up	action	<B>	1702-1
The choice	of	constraint	a schema	1703-1
a schema	by	constraint	semantic information	1703-1
a schema	is guided	action	semantic information	1703-1
semantic information	about	constraint	the application data	1703-1
the application data	by	constraint	the designer	1703-1
the application data	provided	action	the designer	1703-1
There	are	attribute	two main ways	1703-2
two main ways	to	constraint	a different approach	1703-2
two main ways	to	constraint	a different approach	1703-2
two main ways	and	conjunctive	a different approach	1703-2
two main ways	do	attribute	this	1703-2
two main ways	leads	action	a different approach	1703-2
a different approach	to	constraint	schema design	1703-2
Semantic data model		sequential	Semantic data model	1704-1
Such models	are called	action	<B>	1704-2
Refinement	of	constraint	relational schema	1705-1
The design process	uses	action	the dependencies	1705-2
the dependencies	to	constraint	the schema	1705-2
the dependencies	improve	action	the schema	1705-2
<B>	But	conjunctive	what	1705-3
what	is	attribute	it	1705-3
it		sequential	that	1705-3
that	makes	action	240 Design	1705-3
240 Design	and	conjunctive	Dependencies	1705-3
Dependencies		sequential	one schema	1705-3
one schema	than	constraint	<B>	1705-3
<B>	by	constraint	the notion	1705-4
<B>	is captured	action	the notion	1705-4
the notion	of	constraint	normal form	1705-4
normal form	for	constraint	relational schemas	1705-4
relational schemas		sequential	a central notion	1705-4
a central notion	in	constraint	design theory	1705-4
<B>	of	constraint	these approaches	1706-1
these approaches	on	constraint	the transformation	1706-1
these approaches	focus	action	the transformation	1706-1
the transformation	of	constraint	a schema S1	1706-1
a schema S1	into	constraint	a relational schema S2	1706-1
<B>	in	constraint	broad terms	1706-2
<B>	Speaking	action	broad terms	1706-2
broad terms		sequential	three criteria	1706-2
three criteria	to	constraint	the result	1706-2
three criteria	are used	action	the result	1706-2
three criteria	evaluate	action	the result	1706-2
the result	of	constraint	this transformation	1706-2
Condition	1 requires	action	that information	1707-1
that information	not be lost	action	instances	1707-1
instances	of	constraint	S1	1707-1
S1	in	constraint	S2	1707-1
S1	when are represented	action	S2	1707-1
<B>	by	constraint	there	1707-2
<B>	that	constraint	there	1707-2
<B>	is usually formalized	action	there	1707-2
<B>	requiring	action	there	1707-2
there	be	attribute	natural	1707-2
a mapping τ		sequential	Inst	1707-2
Inst		sequential	S1	1707-2
S1	→	sequential	Inst	1707-2
Inst		sequential	S2	1707-2
S2	is	attribute	one	1707-2
one	to	constraint	one	1707-2
<B>	As	constraint	we	1707-3
we	shall see	action	the notion	1707-3
the notion	of	constraint	the data model	1707-3
the notion	can vary	action	the data model	1707-3
the notion	depending on	action	the data model	1707-3
the data model	for	constraint	S1	1707-3
the data model	used	action	S1	1707-3
Criterion		sequential	2	1708-1
2	been	action	has the focus	1708-1
has the focus	of	constraint	considerable research	1708-1
considerable research	in	constraint	especially connection	1708-1
especially connection	with	constraint	the approach	1708-1
the approach	on	constraint	relational schemas	1708-1
the approach	based	action	relational schemas	1708-1
the approach	refining	action	relational schemas	1708-1
<B>	In	constraint	this context	1708-2
this context		sequential	the notion	1708-2
the notion	of	constraint	relational schema	1708-2
relational schema	to	constraint	dependencies	1708-2
relational schema	is generalized	action	dependencies	1708-2
relational schema	incorporate	action	dependencies	1708-2
dependencies	as	constraint	<B>	1708-2
dependencies	follows	action	<B>	1708-2
Others		sequential	ind	1708-3
ind	may involve	action	pairs	1708-3
pairs	of	constraint	relations	1708-3
<B>		sequential	some dependencies	1708-4
some dependencies	over	constraint	the full set	1708-4
some dependencies	might range	action	the full set	1708-4
the full set	of	constraint	attributes	1708-4
attributes	in	constraint	R.	1708-4
attributes	occurring	action	R.	1708-4
R.	requires	action	a generalization	1708-4
a generalization	of	constraint	the notion	1708-4
the notion	of	constraint	dependency satisfaction	1708-4
dependency satisfaction		sequential	which	1708-4
which	in	constraint	Section 11.3	1708-4
which	is discussed	action	Section 11.3	1708-4
<B>	With	constraint	this notation	1709-1
this notation	established	action	we	1709-1
we	to	constraint	criterion	1709-1
we	return	action	criterion	1709-1
criterion		sequential	2	1709-1
<B>	In	constraint	one relational schema	1709-2
<B>	whether	constraint	one relational schema	1709-2
<B>	determining	action	one relational schema	1709-2
one relational schema	than	constraint	the main factors	1709-2
one relational schema	is	attribute	better	1709-2
the main factors		sequential	that	1709-2
that	are	attribute	redundancy	1709-2
that	have been considered	action	redundancy	1709-2
redundancy	in	constraint	the representation	1709-2
the representation	of	constraint	data	1709-2
data	and	conjunctive	update	1709-2
update		sequential	anomalies	1709-2
<B>	that	constraint	Section 8.1	1709-3
<B>	in	constraint	Section 8.1	1709-3
<B>	Recall	attribute	these	1709-3
<B>	were illustrated	action	Section 8.1	1709-3
Section 8.1	using	action	the relations Movies	1709-3
the relations Movies	and	conjunctive	Showings	1709-3
We	that	constraint	certain schemas	1709-4
We	concluded	action	certain schemas	1709-4
certain schemas	yielded	action	undesirable behavior	1709-4
<B>	from	constraint	the nature	1709-5
<B>	resulted	action	the nature	1709-5
the nature	of	constraint	the information	1709-5
the information	in	constraint	the database	1709-5
the information	contained	action	the database	1709-5
the database	as	constraint	a set	1709-5
the database	by	constraint	a set	1709-5
the database	specified	action	a set	1709-5
a set	of	constraint	dependencies	1709-5
Movies	→	sequential	Title Director	1710-1
Title Director	that	constraint	the attribute Director	1710-1
Title Director	suggests	action	the attribute Director	1710-1
the attribute Director	is	attribute	a characteristic	1710-1
a characteristic	of	constraint	Title	1710-1
Title		sequential	the two attributes	1710-1
the two attributes	in	constraint	isolation	1710-1
the two attributes	and	conjunctive	isolation	1710-1
the two attributes	so belong together	action	isolation	1710-1
the two attributes	can safely be represented	action	isolation	1710-1
isolation	from	constraint	the other data	1710-1
It	that	constraint	one	1710-2
It	be	attribute	should clear	1710-2
one	always needs	action	some form	1710-2
some form	of	constraint	semantic information	1710-2
semantic information	to	constraint	schema design	1710-2
semantic information	guide	action	schema design	1710-2
schema design	in	constraint	the absence	1710-2
the absence	of	constraint	such information	1710-2
such information		sequential	one	1710-2
one	can not distinguish	attribute	good	1710-2
schemas	from	constraint	ones	1710-2
ones	except	constraint	trivial cases	1710-2
ones	for	constraint	trivial cases	1710-2
<B>	As	constraint	the notion	1710-3
<B>	will be seen	action	the notion	1710-3
the notion	of	constraint	normal form	1710-3
normal form	captures	action	some characteristics	1710-3
some characteristics	of	constraint	schemas	1710-3
schemas	by	constraint	certain kinds	1710-3
schemas	that	constraint	certain kinds	1710-3
schemas	guaranteeing	action	certain kinds	1710-3
certain kinds	of	constraint	redundancies	1710-3
redundancies	and	conjunctive	update anomalies	1710-3
update anomalies	will not occur	action	<B>	1710-3
It	that	constraint	the semantic data model approach	1710-4
It	will also be seen	action	the semantic data model approach	1710-4
the semantic data model approach	to	constraint	schema design	1710-4
schema design	to	constraint	relational schemas	1710-4
schema design	can lead	action	relational schemas	1710-4
relational schemas	in	constraint	normal form	1710-4
Design	and	conjunctive	Dependencies	1711-1
<B>	In	constraint	the context	1711-2
the context	of	constraint	relational schemas	1711-2
the context	refining	action	relational schemas	1711-2
relational schemas		sequential	a precise meaning	1711-2
a precise meaning	for	constraint	this criterion	1711-2
a precise meaning	will be given	action	this criterion	1711-2
this criterion	in	constraint	terms	1711-2
terms	of	constraint	preservation	1711-2
preservation	of	constraint	dependencies	1711-2
We	that	constraint	there	1711-3
We	shall see	action	there	1711-3
there	is	attribute	a kind	1711-3
a kind	of	constraint	trade off	1711-3
trade off	between	constraint	criteria	1711-3
criteria		sequential	2	1711-3
2	and	conjunctive	3	1711-3
The approach	of	constraint	relational schemas	1712-1
The approach	refining	action	relational schemas	1712-1
relational schemas	typically makes	action	a simplifying assumption	1712-1
a simplifying assumption	called	action	the pure universal relation assumption	1712-1
the pure universal relation assumption		sequential	pure URA	1712-1
<B>	that	constraint	the input schema S1	1712-2
<B>	Intuitively states	action	the input schema S1	1712-2
the input schema S1	of	constraint	a single relation schema	1712-2
the input schema S1	consists	action	a single relation schema	1712-2
a single relation schema	with	constraint	possibly some dependencies	1712-2
Section 11.3	briefly considers	action	this assumption	1712-3
this assumption	in	constraint	a more general light	1712-3
<B>	In	constraint	addition	1712-4
addition		sequential	<B>	1712-4
This chapter	in	constraint	more the form	1713-1
This chapter	is	attribute	more the form	1713-1
more the form	of	constraint	a survey	1713-1
a survey	than	constraint	the previous chapters	1713-1
the previous chapters	for	constraint	several reasons	1713-1
<B>	As	constraint	treatments	1713-2
<B>	noted earlier	action	treatments	1713-2
<B>	more broad based	action	treatments	1713-2
treatments	of	constraint	relational schema design	1713-2
relational schema design	and	conjunctive	a variety	1713-2
relational schema design	may be found elsewhere	action	a variety	1713-2
relational schema design	require	action	a variety	1713-2
a variety	of	constraint	tools	1713-2
tools	to	constraint	formal analysis	1713-2
The tools	at	constraint	only part	1713-3
The tools	presented here	action	only part	1713-3
The tools	can provide	action	only part	1713-3
only part	of	constraint	the skeleton	1713-3
the skeleton	of	constraint	a design methodology	1713-3
a design methodology	for	constraint	relational schemas	1713-3
Normal forms	and	conjunctive	the universal relation assumption	1713-4
the universal relation assumption	were	attribute	active research topics	1713-4
active research topics	in	constraint	the 1970s	1713-4
the 1970s	and	conjunctive	early 1980s	1713-4
early 1980s	and	conjunctive	a large body	1713-4
early 1980s	generated	action	a large body	1713-4
a large body	of	constraint	results	1713-4
<B>	of	constraint	that work	1713-5
that work	due to	constraint	primarily the emergence	1713-5
that work	is now considered	attribute	somewhat unfashionable	1713-5
primarily the emergence	of	constraint	new data models	1713-5
we	However mention briefly	action	these topics	1713-6
these topics	because	constraint	they	1713-6
they	to	constraint	interesting theoretical issues	1713-6
they	1 lead	action	interesting theoretical issues	1713-6
interesting theoretical issues	and	conjunctive	we	1713-6
we	from	constraint	a change	1713-6
we	are	attribute	2 never secure	1713-6
a change	of	constraint	fashion	1713-6
Semantic Data Models		sequential	Semantic Data Models	1714-1
Semantic data models	provide	action	a framework	1714-2
a framework	for	constraint	database schemas	1714-2
a framework	specifying	action	database schemas	1714-2
database schemas		sequential	that	1714-2
that	than	constraint	the relational model	1714-2
that	is	attribute	considerably richer	1714-2
<B>	In	constraint	semantic models	1714-3
semantic models	than	constraint	the relational model	1714-3
semantic models	are	attribute	arguably closer	1714-3
the relational model	to	constraint	ways	1714-3
ways		sequential	that	1714-3
that		sequential	humans	1714-3
humans	organize	action	information	1714-3
information	in	constraint	their own thinking	1714-3
The semantic data models	are	attribute	precursors	1714-4
precursors	of	constraint	the recently emerging database models	1714-4
precursors	object oriented	action	the recently emerging database models	1714-4
the recently emerging database models	in	constraint	a more formal fashion	1714-4
the recently emerging database models	presented	action	a more formal fashion	1714-4
a more formal fashion	in	constraint	Chapter 21	1714-4
Chapter 21	of	constraint	thus interest	1714-4
Chapter 21	and	conjunctive	thus interest	1714-4
Chapter 21	are	attribute	thus interest	1714-4
thus interest	in	constraint	their own right	1714-4
<B>	In	constraint	many practical contexts	1715-1
many practical contexts		sequential	the semantic model	1715-1
the semantic model	is	attribute	Entity	1715-1
the semantic model	used	action	Entity	1715-1
Entity		sequential	Relationship	1715-1
Relationship		sequential	the model	1715-1
the model		sequential	ER model	1715-1
ER model	or	conjunctive	one	1715-1
one	of	constraint	its many variants	1715-1
The ER model	is	attribute	arguably the first semantic data model	1715-2
arguably the first semantic data model		sequential	that	1715-2
that	in	constraint	the literature	1715-2
that	appeared	action	the literature	1715-2
We	use	action	the GSM	1715-3
the GSM	because	constraint	it	1715-3
it	incorporates	action	several features	1715-3
several features	of	constraint	the semantic modeling literature	1715-3
the semantic modeling literature	in	constraint	the ER model	1715-3
the ER model	because	constraint	the GSM	1715-3
the ER model	and	conjunctive	the GSM	1715-3
the GSM	presents	action	a style	1715-3
a style	to	constraint	object	1715-3
object	oriented	action	database models	1715-3
GSM Schemas Figure 11.1	shows	action	the schema	1716-1
the schema		sequential	CINEMA	1716-1
CINEMA		sequential	SEM	1716-1
SEM	from	constraint	the GSM	1716-1
the GSM		sequential	which	1716-1
which	to	constraint	information	1716-1
which	can be used	action	information	1716-1
which	represent	action	information	1716-1
information	on	constraint	movies	1716-1
movies	and	conjunctive	theaters	1716-1
The major building blocks	of	constraint	such schemas	1716-2
such schemas	are	attribute	abstract classes	1716-2
abstract classes		sequential	attributes	1716-2
attributes		sequential	complex value classes	1716-2
complex value classes	and	conjunctive	the ISA hierarchy	1716-2
the ISA hierarchy	in	constraint	turn	1716-2
the ISA hierarchy	will be considered briefly	action	turn	1716-2
The schema	of	constraint	Fig	1717-1
11.1	shows	action	five classes	1717-2
five classes		sequential	that	1717-2
that	hold	action	abstract objects	1717-2
abstract objects		sequential	Person	1717-2
Person		sequential	Director	1717-2
Director		sequential	Actor	1717-2
Actor		sequential	Movie	1717-2
Movie	and	conjunctive	Theater	1717-2
<B>	to	constraint	collections	1717-3
<B>	correspond	action	collections	1717-3
collections	of	constraint	similar objects	1717-3
similar objects	in	constraint	the world	1717-3
There	are	attribute	two kinds	1717-4
two kinds	of	constraint	abstract class	1717-4
abstract class		sequential	primary classes	1717-4
primary classes	shown	action	diamonds	1717-4
primary classes	using	action	diamonds	1717-4
diamonds	and	conjunctive	subclasses	1717-4
subclasses	shown	action	circles	1717-4
subclasses	using	action	circles	1717-4
This distinction	will be clarified further	action	ISA relationships	1717-5
ISA relationships	when are discussed	action	<B>	1717-5
Instances	of	constraint	semantic schemas	1718-1
semantic schemas	from	constraint	the usual printable classes	1718-1
semantic schemas	are constructed	action	the usual printable classes	1718-1
the usual printable classes		sequential	string	1718-1
string		sequential	integer	1718-1
integer		sequential	float	1718-1
float		sequential	<B>	1718-1
<B>	and	conjunctive	classes	1718-2
The printable classes	to	constraint	subsets of	1718-3
The printable classes	correspond	action	subsets of	1718-3
subsets of		sequential	the domain dom	1718-3
the domain dom	in	constraint	the relational model	1718-3
the domain dom	used	action	the relational model	1718-3
The printable classes	are indicated	action	squares	1718-4
The printable classes	using	action	squares	1718-4
squares	in	constraint	Fig	1718-4
we	to	constraint	the kind	1718-5
we	11.1 have labeled	attribute	these	1718-5
we	indicate	action	the kind	1718-5
the kind	of	constraint	values	1718-5
values		sequential	that	1718-5
that	populate	action	them	1718-5
the elements	of	constraint	an abstract class	1718-6
an abstract class		sequential	Person	1718-6
Person	are	attribute	Conceptually actual persons	1718-6
Conceptually actual persons	in	constraint	the world	1718-6
the world	in	constraint	the formal model internal representations	1718-6
the formal model internal representations	for	constraint	persons	1718-6
persons	are used	action	<B>	1718-6
These internal representations	to	constraint	object identifiers	1718-7
These internal representations	as	constraint	object identifiers	1718-7
These internal representations	have come	action	object identifiers	1718-7
These internal representations	be known	action	object identifiers	1718-7
object identifiers		sequential	OIDs	1718-7
<B>	Because	constraint	they	1718-8
they	are	attribute	internal	1718-8
it	that	constraint	OIDs	1718-8
it	is usually assumed	action	OIDs	1718-8
OIDs	to	constraint	users	1718-8
OIDs	can not be presented explicitly	action	users	1718-8
users	although	constraint	programming	1718-8
programming	and	conjunctive	query	1718-8
query		sequential	languages	1718-8
languages	can use	action	variables	1718-8
variables		sequential	that	1718-8
that	hold	action	OIDs	1718-8
The notion	of	constraint	instance	1718-9
instance	in	constraint	Example 11.1.1	1718-9
instance	and	conjunctive	Example 11.1.1	1718-9
instance	will be defined more completely later	action	Example 11.1.1	1718-9
instance	is illustrated	action	Example 11.1.1	1718-9
Example 11.1.1	and	conjunctive	Fig	1718-9
11.2		sequential	11.2	1718-10
<B>	are	attribute	examples	1719-1
examples	of	constraint	attributes	1719-1
examples	valued	action	attributes	1719-1
<B>	In	constraint	this schema	1719-2
this schema		sequential	all attributes	1719-2
all attributes	to	constraint	<B>	1719-2
all attributes	are assumed	attribute	total	1719-2
all attributes	be	attribute	total	1719-2
Multivalued attributes	are also allowed	action	these map	1719-3
these map	to	constraint	a set	1719-3
these map	each object	action	a set	1719-3
a set	of	constraint	objects	1719-3
objects	or	conjunctive	printable values	1719-3
printable values	and	conjunctive	arrows	1719-3
printable values	are denoted	action	arrows	1719-3
printable values	using	action	arrows	1719-3
arrows	with	constraint	double heads	1719-3
<B>	For	constraint	example	1719-4
example		sequential	acts_in maps actors	1719-4
acts_in maps actors	to	constraint	the movies	1719-4
the movies		sequential	that	1719-4
that		sequential	they	1719-4
they	in	constraint	<B>	1719-4
they	have acted	action	<B>	1719-4
It	to	constraint	inverse constraints	1719-5
It	is	attribute	common	1719-5
It	permit	action	inverse constraints	1719-5
inverse constraints	between	constraint	pairs	1719-5
pairs	of	constraint	attributes	1719-5
<B>	For	constraint	example	1719-6
example	consider	action	the relationship	1719-6
the relationship	between	constraint	actors	1719-6
actors	and	conjunctive	movies	1719-6
It	can be represented	action	the multivalued attribute acts_in	1719-7
It	using	action	the multivalued attribute acts_in	1719-7
the multivalued attribute acts_in	on	constraint	Actor	1719-7
Actor	or	conjunctive	the multivalued attribute actors	1719-7
the multivalued attribute actors	on	constraint	Movie	1719-7
<B>	In	constraint	this schema	1719-8
this schema		sequential	we	1719-8
we	that	constraint	the attributes	1719-8
we	assume	action	the attributes	1719-8
the attributes		sequential	acts_in	1719-8
acts_in	and	conjunctive	actors	1719-8
actors	to	constraint	inverses	1719-8
actors	be	attribute	inverses	1719-8
actors	are constrained	action	inverses	1719-8
inverses	of	constraint	the sense	1719-8
inverses	in	constraint	the sense	1719-8
the sense	that	constraint	m ∈	1719-8
m ∈	in	constraint	a iff a ∈ actor	1719-8
m ∈	acts	action	a iff a ∈ actor	1719-8
a iff a ∈ actor		sequential	m	1719-8
A similar constraint	between	constraint	the attributes	1719-9
A similar constraint	is assumed	action	the attributes	1719-9
the attributes	associating	action	movies	1719-9
movies	with	constraint	directors	1719-9
<B>	In	constraint	the schema	1720-1
the schema		sequential	CINEMA	1720-1
CINEMA		sequential	SEM	1720-1
SEM		sequential	the Pariscope node	1720-1
the Pariscope node	is	attribute	an example	1720-1
an example	of	constraint	a complex value class	1720-1
Members	of	constraint	the underlying class	1720-2
the underlying class	are	attribute	triples	1720-2
triples		sequential	whose coordinates	1720-2
whose coordinates	from	constraint	the classes Theater respectively	1720-2
whose coordinates	are	attribute	the classes Theater respectively	1720-2
the classes Theater respectively		sequential	Time	1720-2
Time	and	conjunctive	Movie	1720-2
<B>	In	constraint	the GSM	1720-3
the GSM		sequential	each complex value	1720-3
each complex value	is	attribute	the result	1720-3
the result	of	constraint	one application	1720-3
one application	of	constraint	the tuple construct	1720-3
<B>	is indicated	action	a node	1720-4
<B>	using	action	a node	1720-4
a node	of	constraint	the form	1720-4
the form	with	constraint	components	1720-4
components	indicated	action	dashed arrows	1720-4
components	using	action	dashed arrows	1720-4
The components	of	constraint	each complex value	1720-5
each complex value	or	conjunctive	values	1720-5
each complex value	be	attribute	can printable	1720-5
there	However can not be	action	a directed cycle	1720-6
a directed cycle	in	constraint	the set	1720-6
the set	of	constraint	edges	1720-6
edges	to	constraint	the complex values	1720-6
edges	used	action	the complex values	1720-6
edges	define	action	the complex values	1720-6
<B>	As	constraint	the attribute price	1720-7
<B>	by	constraint	the attribute price	1720-7
<B>	suggested	action	the attribute price	1720-7
the attribute price		sequential	a complex value class	1720-7
a complex value class	may have	action	attributes	1720-7
Complex value classes	as	constraint	the range	1720-8
Complex value classes	can also serve	action	the range	1720-8
the range	of	constraint	an attribute	1720-8
an attribute	as	constraint	the class Award	1720-8
an attribute	by	constraint	the class Award	1720-8
an attribute	illustrated	action	the class Award	1720-8
Complex values	of	constraint	independent interest	1721-1
Complex values	are	attribute	independent interest	1721-1
independent interest	in	constraint	some depth	1721-1
independent interest	and	conjunctive	some depth	1721-1
independent interest	are discussed	action	some depth	1721-1
some depth	in	constraint	Chapter 20	1721-1
Complex values	generally include	action	hierarchical structures	1721-2
hierarchical structures	from	constraint	a handful	1721-2
hierarchical structures	built	action	a handful	1721-2
a handful	of	constraint	Design	1721-2
Design	and	conjunctive	Dependencies	1721-2
Dependencies		sequential	Name	1721-2
Name		sequential	Pariscope Citizen	1721-2
Pariscope Citizen		sequential	Price Person ship	1721-2
Price Person ship		sequential	Theater Time Movie Director Name Phone Title Name Prize Figure 11.1	1721-2
Rich complex value models	into	constraint	data models	1721-3
Rich complex value models	are generally incorporated	action	data models	1721-3
Rich complex value models	object oriented	action	data models	1721-3
data models	into	constraint	some semantic data models	1721-3
data models	and	conjunctive	some semantic data models	1721-3
Some constructs	for	constraint	complex values	1721-4
complex values		sequential	set	1721-4
set	can not be simulated	action	the pure relational model	1721-4
set	directly using	action	the pure relational model	1721-4
the pure relational model	see	action	Exercise 11.24	1721-4
The final building block	of	constraint	the GSM	1722-1
the GSM	is	attribute	the ISA relationship	1722-1
the ISA relationship		sequential	which	1722-1
which	represents	action	set inclusion	1722-1
<B>	In	constraint	the example schema	1722-2
the example schema	of	constraint	Fig	1722-2
the ISA relationships	by	constraint	arrows	1722-3
the ISA relationships	11.1 are depicted	attribute	double	1722-3
the ISA relationships	shafted	action	arrows	1722-3
arrows	that	constraint	the set	1722-3
arrows	and	conjunctive	the set	1722-3
arrows	indicate	action	the set	1722-3
the set	of	constraint	Director	1722-3
Director	is	attribute	a subset	1722-3
a subset	of	constraint	Person	1722-3
Person	that	constraint	Actor	1722-3
Person	and	conjunctive	Actor	1722-3
Actor	is	attribute	likewise a subset	1722-3
likewise a subset	of	constraint	Person	1722-3
<B>	In	constraint	addition	1722-4
addition	to	constraint	set inclusion	1722-4
addition	indicating	action	set inclusion	1722-4
set inclusion		sequential	ISA relationships	1722-4
ISA relationships	indicate	action	a form	1722-4
a form	of	constraint	subtyping relationship	1722-4
subtyping relationship	or	conjunctive	inheritance	1722-4
<B>	if	constraint	class B ISA class A	1722-5
class B ISA class A		sequential	each attribute	1722-5
each attribute	of	constraint	A	1722-5
A	for	constraint	elements	1722-5
A	and	conjunctive	elements	1722-5
A	is	attribute	also relevant	1722-5
A	defined	action	elements	1722-5
elements	of	constraint	class B	1722-5
<B>	In	constraint	the context	1722-6
the context	of	constraint	semantic models	1722-6
semantic models	be	attribute	should no surprise	1722-6
should no surprise	because	constraint	the elements	1722-6
the elements	of	constraint	B	1722-6
B	are	attribute	elements	1722-6
elements	of	constraint	A	1722-6
<B>	In	constraint	the GSM	1723-1
the GSM		sequential	the graph	1723-1
the graph	by	constraint	ISA relationships	1723-1
the graph	induced	action	ISA relationships	1723-1
ISA relationships	is	attribute	a directed acyclic graph	1723-1
a directed acyclic graph		sequential	DAG	1723-1
The root nodes	are	attribute	primary abstract classes	1724-1
primary abstract classes	with	constraint	diamonds	1724-1
primary abstract classes	represented	action	diamonds	1724-1
diamonds	and	conjunctive	all other nodes	1724-1
all other nodes	are	attribute	subclass nodes	1724-1
subclass nodes	with	constraint	circles	1724-1
subclass nodes	represented	action	circles	1724-1
Each subclass node	has	action	exactly one primary node	1724-2
exactly one primary node	above	constraint	it	1724-2
Complex value classes	in	constraint	ISA relationships	1724-3
Complex value classes	can not participate	action	ISA relationships	1724-3
<B>	In	constraint	the GSM	1725-1
the GSM		sequential	the tuple	1725-1
the tuple	and	conjunctive	multivalued attribute constructs	1725-1
multivalued attribute constructs	are	attribute	somewhat redundant	1725-1
Such redundancy	of	constraint	semantic models	1725-2
Such redundancy	is	attribute	typical	1725-2
<B>	On	constraint	a bit	1725-3
a bit	of	constraint	a tangent	1725-3
a tangent		sequential	we	1725-3
we	that	constraint	the tuple construct	1725-3
we	also note	action	the tuple construct	1725-3
the tuple construct	of	constraint	GSM	1725-3
GSM	to	constraint	the relationship construct	1725-3
GSM	is	attribute	close	1725-3
the relationship construct	of	constraint	the ER model	1725-3
GSM Instances	Let	action	S	1726-1
S	be	attribute	a GSM schema	1726-1
It	that	constraint	a fixed domain	1726-2
It	or	conjunctive	a fixed domain	1726-2
It	is assumed	attribute	finite	1726-2
a fixed domain	to	constraint	each printable class	1726-2
a fixed domain	is associated	action	each printable class	1726-2
each printable class	in	constraint	S	1726-2
Example 11.1.1		sequential	Example 11.1.1	1727-1
11.2		sequential	11.2	1727-2
The values	of	constraint	complex value Award	1727-3
complex value Award		sequential	the attributes award	1727-3
the attributes award		sequential	address	1727-3
address	and	conjunctive	phone	1727-3
phone	are not shown	action	<B>	1727-3
The symbols		sequential	o1	1727-4
o1		sequential	o2	1727-4
o2	denote	action	OIDs	1727-4
<B>	Consider	action	an instance	1728-1
<B>	Because	constraint	OIDs	1728-2
OIDs	as	constraint	only internal representations	1728-2
OIDs	serve	action	only internal representations	1728-2
only internal representations		sequential	that	1728-2
that	can not be accessed	action	Design	1728-2
Design	and	conjunctive	Dependencies	1728-2
Dependencies		sequential	I1	1728-2
I1		sequential	Person	1728-2
Person	=	sequential	name	1728-2
name		sequential	o1	1728-2
o1	=	sequential	Alice citizenship	1728-2
Alice citizenship		sequential	o1	1728-2
o1	=	sequential	Great Britain name	1728-2
Great Britain name		sequential	o2	1728-2
o2	=	sequential	Allen citizenship	1728-2
Allen citizenship		sequential	o2	1728-2
o2	=	sequential	United States name	1728-2
United States name		sequential	o3	1728-2
o3	=	sequential	Keaton citizenship	1728-2
Keaton citizenship		sequential	o3	1728-2
o3	=	sequential	United States I1	1728-2
United States I1		sequential	Director	1728-2
Director	=	sequential	o2 }	1728-2
Director	{	sequential	o2 }	1728-2
o2 }	directed	action	o2	1728-2
o2	=	sequential	o4	1728-2
o2	{	sequential	o4	1728-2
o4		sequential	o5 } I1	1728-2
o5 } I1		sequential	Actor	1728-2
Actor	=	sequential	o2	1728-2
Actor	{	sequential	o2	1728-2
o2		sequential	o3 }	1728-2
o3 }		sequential	I1	1728-2
I1		sequential	Movie	1728-2
Movie	=	sequential	o4	1728-2
o4		sequential	o5 } title	1728-2
o5 } title		sequential	o4	1728-2
o4	=	sequential	the Money title	1728-2
o4	Take	action	the Money title	1728-2
the Money title		sequential	o5	1728-2
o5	=	sequential	Annie Hall director	1728-2
Annie Hall director		sequential	o4	1728-2
o4	=	sequential	o2 director	1728-2
o2 director		sequential	o5	1728-2
o5	=	sequential	o2	1728-2
o2		sequential	I1	1728-2
I1		sequential	Theater	1728-2
Theater	=	sequential	o6 } name	1728-2
Theater	{	sequential	o6 } name	1728-2
o6 } name		sequential	o6	1728-2
o6	=	sequential	Le Champo	1728-2
Le Champo		sequential	I1	1728-2
I1		sequential	Pariscope	1728-2
Pariscope	=	sequential	price	1728-2
price		sequential	o6	1728-2
o6		sequential	20:00	1728-2
20:00		sequential	o4	1728-2
o4	=	sequential	30 FF	1728-2
30 FF		sequential	Figure	1728-2
Figure		sequential	11.2	1728-2
11.2		sequential	Part	1728-2
Part	of	constraint	an instance	1728-2
an instance		sequential	I1	1728-2
I1	of	constraint	CINEMA SEM explicitly	1728-2
CINEMA SEM explicitly		sequential	I1	1728-2
I1	and	conjunctive	I′	1728-2
I′	to	constraint	terms	1728-2
I′	in	constraint	terms	1728-2
I′	are considered	attribute	identical	1728-2
I′	be	attribute	identical	1728-2
terms	of	constraint	the information	1728-2
the information		sequential	that	1728-2
that		sequential	they	1728-2
they	represent	action	<B>	1728-2
<B>	Let	action	S	1729-1
S	be	attribute	a GSM schema	1729-1
An OID isomorphism	is	attribute	a function µ	1729-2
a function µ	is	attribute	a permutation	1729-2
a permutation	on	constraint	the set obj	1729-2
the set obj	of	constraint	OIDs	1729-2
OIDs	and	conjunctive	all printables	1729-2
OIDs	leaves	action	all printables	1729-2
all printables	fixed	action	<B>	1729-2
Such functions	to	constraint	Inst	1729-3
Such functions	are extended	action	Inst	1729-3
Inst		sequential	S	1729-3
S	in	constraint	the natural fashion	1729-3
Two instances		sequential	I	1729-4
I	and	conjunctive	I′	1729-4
I′	are	attribute	OID	1729-4
OID	denoted	action	I	1729-4
I	≡	action	OID I′	1729-4
OID I′	if	constraint	there	1729-4
there	is	attribute	an OID isomorphism µ	1729-4
an OID isomorphism µ		sequential	that	1729-4
that		sequential	µ I	1729-4
µ I	=	sequential	I′	1729-4
<B>	is	attribute	clearly an equivalence relation	1729-5
The GSM	is	attribute	a very basic semantic data model	1730-1
a very basic semantic data model	and	conjunctive	many variations	1730-1
many variations	on	constraint	the semantic constructs	1730-1
the semantic constructs	in	constraint	the GSM	1730-1
the semantic constructs	included	action	the GSM	1730-1
the GSM	in	constraint	the literature	1730-1
the GSM	have been explored	action	the literature	1730-1
<B>	For	constraint	example	1730-2
example		sequential	a variety	1730-2
a variety	of	constraint	simple constraints	1730-2
simple constraints	can be incorporated	attribute	such as	1730-2
cardinality constraints	on	constraint	attributes	1730-2
attributes	and	conjunctive	disjointness	1730-2
disjointness	between	constraint	subclasses	1730-2
subclasses	that	constraint	Director	1730-2
Director	and	conjunctive	Actor	1730-2
Actor	are	attribute	disjoint	1730-2
Another variation	to	constraint	a class	1730-3
Another variation	that	constraint	a class	1730-3
Another variation	is	attribute	a class	1730-3
Another variation	require	action	a class	1730-3
a class	on	constraint	an attribute	1730-3
a class	be	attribute	dependent	1730-3
an attribute	that	constraint	each Award object	1730-3
each Award object	in	constraint	the image	1730-3
each Award object	must occur	action	the image	1730-3
the image	of	constraint	some Actor	1730-3
some Actor	on	constraint	a complex value class	1730-3
some Actor	or	conjunctive	a complex value class	1730-3
More complex constraints	on	constraint	order	1730-4
More complex constraints	based	attribute	first	1730-4
order		sequential	sentences	1730-4
sentences	have also been explored	action	<B>	1730-4
Some semantic models	support	action	different kinds	1730-5
different kinds	of	constraint	ISA relationships	1730-5
ISA relationships	and	conjunctive	derived data	1730-5
ISA relationships	provide	action	derived data	1730-5
derived data		sequential	a form	1730-5
a form	of	constraint	user view	1730-5
user view	into	constraint	the base schema	1730-5
user view	incorporated	action	the base schema	1730-5
<B>	into	constraint	the Relational Model	1731-1
<B>	Translating	action	the Relational Model	1731-1
<B>	As	constraint	we	1731-2
we	shall see	action	the semantics	1731-2
the semantics	with	constraint	the semantic schema	1731-2
the semantics	associated	action	the semantic schema	1731-2
the semantic schema	will yield	action	dependencies	1731-2
dependencies	of	constraint	various forms	1731-2
various forms	in	constraint	the relational schema	1731-2
a surrogate	of	constraint	an object	1732-1
an object	is	attribute	Informally a unique unchanging printable value	1732-1
Informally a unique unchanging printable value		sequential	that	1732-1
that	with	constraint	the object	1732-1
that	is associated	action	the object	1732-1
<B>		sequential	world	1732-2
world		sequential	Many objects	1732-2
Many objects	have	action	natural surrogates	1732-2
natural surrogates		sequential	Social Security number	1732-2
Social Security number	for	constraint	persons	1732-2
persons	in	constraint	the United States	1732-2
the United States	or	conjunctive	France	1732-2
France	or	conjunctive	Invoice Number	1732-2
Invoice Number	for	constraint	invoices	1732-2
invoices	in	constraint	a commercial enterprise	1732-2
<B>	In	constraint	other cases	1732-3
other cases		sequential	abstract surrogates	1732-3
abstract surrogates	can be used	action	<B>	1732-3
The kernel	of	constraint	the translation	1733-1
the translation	of	constraint	GSM schemas	1733-1
GSM schemas	into	constraint	relational ones	1733-1
relational ones	concerns	action	objects	1733-1
objects	in	constraint	GSM instances	1733-1
GSM instances	can be represented	action	tuples	1733-1
GSM instances	using	action	tuples	1733-1
tuples	of	constraint	printables	1733-1
<B>	For	constraint	each class C	1733-2
each class C	in	constraint	the GSM schema	1733-2
each class C	occurring	action	the GSM schema	1733-2
the GSM schema		sequential	we	1733-2
we	associate	action	a set	1733-2
a set	of	constraint	relational attributes	1733-2
relational attributes	called	action	the representation	1733-2
the representation	of	constraint	C	1733-2
C	and	conjunctive	denoted rep	1733-2
denoted rep		sequential	C	1733-2
<B>	For	constraint	a printable class C	1733-3
a printable class C		sequential	rep	1733-3
rep		sequential	C	1733-3
C	is	attribute	a single attribute	1733-3
a single attribute	having	action	this sort	1733-3
<B>	For	constraint	abstract class C	1733-4
abstract class C		sequential	rep	1733-4
rep		sequential	C	1733-4
C	is	attribute	a set	1733-4
a set	of	constraint	attributes	1733-4
attributes	to	constraint	the key attributes	1733-4
attributes	corresponding	action	the key attributes	1733-4
the key attributes	of	constraint	the primary class	1733-4
the primary class	above	constraint	C	1733-4
<B>	.	sequential	<B>	1733-5
<B>	.	sequential	<B>	1733-6
Cm		sequential	rep	1733-7
rep		sequential	C	1733-7
C	of	constraint	disjoint copies of	1733-7
C	consists	action	disjoint copies of	1733-7
disjoint copies of	of	constraint	the attributes	1733-7
the attributes	in	constraint	rep	1733-7
the attributes	occurring	action	rep	1733-7
rep		sequential	C1	1733-7
<B>	.	sequential	<B>	1733-8
<B>	.	sequential	<B>	1733-9
rep		sequential	Cm	1733-10
Translation	of	constraint	a GSM schema	1734-1
a GSM schema	into	constraint	a relation schema	1734-1
a relation schema	in	constraint	the following example	1734-1
a relation schema	is illustrated	action	the following example	1734-1
Example		sequential	11.1.2	1735-1
11.2		sequential	11.2	1735-2
<B>	In	constraint	schema	1736-1
schema		sequential	CINEMA	1736-1
CINEMA		sequential	REL	1736-1
REL		sequential	both Actor	1736-1
both Actor	and	conjunctive	Acts_in	1736-1
Acts_in	in case	constraint	there	1736-1
Acts_in	are included	action	there	1736-1
there	or	conjunctive	one actors	1736-1
there	are	attribute	more	1736-1
one actors		sequential	that	1736-1
that	in	constraint	any movie	1736-1
that	did not act	action	any movie	1736-1
<B>	For	constraint	similar reasons	1736-2
similar reasons		sequential	Acts_in	1736-2
Acts_in	and	conjunctive	Has_Award	1736-2
Has_Award	are separated	action	<B>	1736-2
<B>	In	constraint	contrast	1737-1
contrast		sequential	we	1737-1
we	that	constraint	each person	1737-1
we	have assumed	action	each person	1737-1
each person	has	action	a citizenship	1737-1
a citizenship	that	constraint	citizenship	1737-1
citizenship	is	attribute	a total function	1737-1
<B>	If	constraint	two relations	1737-2
two relations	in	constraint	place	1737-2
two relations	would be needed	action	place	1737-2
place	of	constraint	Person	1737-2
Analogous remarks	for	constraint	directors	1737-3
Analogous remarks	hold	action	directors	1737-3
directors		sequential	movies	1737-3
movies		sequential	theaters	1737-3
theaters	and	conjunctive	Pariscope objects	1737-3
<B>	In	constraint	schema	1738-1
schema		sequential	CINEMA	1738-1
CINEMA		sequential	REL	1738-1
REL		sequential	we	1738-1
we	have not explicitly provided	action	relations	1738-1
relations	to	constraint	the attributes	1738-1
relations	represent	action	the attributes	1738-1
the attributes	of	constraint	Director	1738-1
the attributes	directed	action	Director	1738-1
Director	or	conjunctive	actors	1738-1
actors	of	constraint	Movie	1738-1
<B>	because	constraint	inverses	1738-2
<B>	of	constraint	inverses	1738-2
<B>	is	attribute	both	1738-2
<B>	are	attribute	inverses	1738-2
inverses	of	constraint	other attributes	1738-2
other attributes		sequential	which	1738-2
which	by	constraint	Movie	1738-2
which	are represented explicitly	action	Movie	1738-2
Movie	and	conjunctive	Acts_in	1738-2
Acts_in		sequential	<B>	1738-2
<B>	If	constraint	we	1739-1
we	to	constraint	the complex value class Awards	1739-1
we	were consider	action	the complex value class Awards	1739-1
the complex value class Awards	of	constraint	CINEMA	1739-1
CINEMA		sequential	SEM	1739-1
SEM	to	constraint	the attribute award	1739-1
SEM	on	constraint	the attribute award	1739-1
SEM	be	attribute	dependent	1739-1
the attribute award		sequential	the relation Award	1739-1
the relation Award	could be omitted	action	<B>	1739-1
<B>	that	constraint	I	1740-1
<B>	Suppose	action	I	1740-1
I	is	attribute	an instance	1740-1
an instance	of	constraint	CINEMA SEM	1740-1
CINEMA SEM	that	constraint	I′	1740-1
CINEMA SEM	and	conjunctive	I′	1740-1
I′	is	attribute	the simulation	1740-1
the simulation	of	constraint	I	1740-1
The semantics CINEMA	of	constraint	SEM	1741-1
SEM	along	constraint	the assumed keys	1741-1
SEM	with	constraint	the assumed keys	1741-1
the assumed keys	that	constraint	I′	1741-1
the assumed keys	imply	action	I′	1741-1
I′	will satisfy	action	several dependencies	1741-1
<B>	includes	action	the following fd	1741-2
the following fd	in	constraint	fact	1741-2
fact		sequential	key dependencies	1741-2
key dependencies		sequential	Person name	1741-2
Person name	→	sequential	citizenship Movie title	1741-2
citizenship Movie title	→	sequential	director	1741-2
director		sequential	name	1741-2
<B>	but	conjunctive	one	1741-3
one	of	constraint	the ind	1741-3
the ind	because	constraint	the keys	1741-3
the ind	of	constraint	the keys	1741-3
the ind	are	attribute	unary	1741-3
the keys	except	constraint	the key	1741-3
the key	for	constraint	Award	1741-3
Award	on	constraint	a single attribute	1741-3
Award	are based	action	a single attribute	1741-3
Preservation	of	constraint	Data	1742-1
Data	that	constraint	S	1742-1
Data	Suppose	action	S	1742-1
S	is	attribute	a GSM schema	1742-1
a GSM schema	with	constraint	keys	1742-1
keys	for	constraint	primary classes	1742-1
primary classes	and	conjunctive	R	1742-1
R		sequential	∪ Ŵ	1742-1
∪ Ŵ	is	attribute	a relational schema	1742-1
a relational schema		sequential	that	1742-1
that	simulates	action	it	1742-1
it	in	constraint	the fashion	1742-1
it	constructed	action	the fashion	1742-1
the fashion	in	constraint	Example 11.1.2	1742-1
the fashion	illustrated	action	Example 11.1.2	1742-1
Example 11.1.2	is	attribute	the set	1742-1
the set	of	constraint	fd	1742-1
fd		sequential	s	1742-1
s	and	conjunctive	the set	1742-1
s	is	attribute	the set	1742-1
the set	of	constraint	ind	1742-1
ind		sequential	<B>	1742-1
<B>	As	constraint	criterion	1742-2
<B>	in	constraint	criterion	1742-2
<B>	noted	action	criterion	1742-2
criterion	at	constraint	the beginning	1742-2
the beginning	of	constraint	this chapter	1742-2
this chapter		sequential	it	1742-2
it	that	constraint	there	1742-2
it	is	attribute	1 desirable	1742-2
there	be	attribute	one	1742-2
one	to	constraint	one	1742-2
one		sequential	a natural mapping	1742-2
a natural mapping	from	constraint	instances	1742-2
a natural mapping	τ	sequential	instances	1742-2
instances	of	constraint	S	1742-2
S	to	constraint	instances	1742-2
instances	of	constraint	R	1742-2
R		sequential	∪	1742-2
∪		sequential	Ŵ	1742-2
<B>	To	constraint	two obstacles	1742-3
<B>	formalize	attribute	this	1742-3
two obstacles	to	constraint	<B>	1742-3
two obstacles	need	action	<B>	1742-3
two obstacles	be overcome	action	<B>	1742-3
we	First have not developed	action	a query language	1743-1
a query language	for	constraint	the GSM	1743-1
<B>	In	constraint	fact	1743-2
fact		sequential	no query language	1743-2
no query language	for	constraint	the semantic data models	1743-2
no query language	of	constraint	the semantic data models	1743-2
no query language	has become	attribute	any	1743-2
no query language	widely accepted	attribute	any	1743-2
<B>	In	constraint	contrast	1743-3
contrast		sequential	some query languages	1743-3
some query languages	for	constraint	object	1743-3
object	oriented	action	database models	1743-3
database models	are now gaining	action	wide acceptance	1743-3
We	shall overcome	action	this obstacle	1743-4
this obstacle	by	constraint	a rather abstract notion	1743-4
this obstacle	developing	action	a rather abstract notion	1743-4
a rather abstract notion	of	constraint	this context	1743-4
a rather abstract notion	for	constraint	this context	1743-4
The second obstacle	from	constraint	the fact	1744-1
The second obstacle	stems	action	the fact	1744-1
the fact	that	constraint	GSM instances	1744-1
GSM instances	hold essentially	action	the same information	1744-1
we	Thus would expect	attribute	OID equivalent	1744-2
instances	to	constraint	the same relational instance	1744-2
instances	to	constraint	the same relational instance	1744-2
instances	map	action	the same relational instance	1744-2
<B>	can be verified	action	Exercise 11.3	1745-1
<B>	see	action	Exercise 11.3	1745-1
Exercise 11.3		sequential	Theorem 11.1.3	1745-1
Theorem 11.1.3		sequential	<B>	1745-1
Properties	of	constraint	the Relational Schema	1746-1
Design	and	conjunctive	Dependencies	1747-1
Dependencies		sequential	Criterion 2	1747-1
Criterion 2	for	constraint	schema transformations	1747-1
schema transformations	concerns	action	desirable properties	1747-1
desirable properties	of	constraint	the target schema	1747-1
We	now describe	action	three such properties	1747-2
three such properties	from	constraint	the transformation	1747-2
three such properties	resulting	action	the transformation	1747-2
the transformation	of	constraint	GSM schemas	1747-2
GSM schemas	into	constraint	relational ones	1747-2
<B>	that	constraint	S	1748-1
<B>	Suppose again	action	S	1748-1
S	is	attribute	a GSM schema	1748-1
a GSM schema	with	constraint	keys	1748-1
keys	and	conjunctive	R	1748-1
R	∪	sequential	Ŵ	1748-1
Ŵ	is	attribute	a relational simulation	1748-1
a relational simulation	of	constraint	it	1748-1
We	as before	constraint	no constraints	1748-2
We	that	constraint	no constraints	1748-2
We	assume	action	no constraints	1748-2
no constraints	for	constraint	S	1748-2
no constraints	hold	action	S	1748-2
S	from	constraint	the constructs	1748-2
S	by	constraint	the constructs	1748-2
S	implied	action	the constructs	1748-2
the constructs	in	constraint	S	1748-2
S	and	conjunctive	the keys	1748-2
The three properties	as	constraint	<B>	1749-1
The three properties	are	attribute	<B>	1749-1
The three properties	follows	action	<B>	1749-1
<B>		sequential	<B>	1750-1
these properties	Together present	action	a number	1751-1
a number	of	constraint	desirable features	1751-1
<B>	In	constraint	dependency implication	1751-2
dependency implication	to	constraint	<B>	1751-2
dependency implication	is	attribute	easy	1751-2
dependency implication	check	action	<B>	1751-2
<B>	Given	action	a database schema R	1751-3
a database schema R	and	conjunctive	sets	1751-3
sets	of	constraint	fd	1751-3
fd		sequential	s	1751-3
s	and	conjunctive	Ŵ	1751-3
Ŵ	of	constraint	ind	1751-3
ind	over	constraint	R	1751-3
R	if	constraint	each fd σ	1751-3
R	for	constraint	each fd σ	1751-3
R	and	conjunctive	each fd σ	1751-3
R	Ŵ	sequential	each fd σ	1751-3
R	are	attribute	independent	1751-3
each fd σ	over	constraint	R	1751-3
R	∪	sequential	σ	1751-3
σ	1 Ŵ implies	action	σ	1751-3
σ	and	conjunctive	2	1751-3
2	for	constraint	each ind	1751-3
each ind		sequential	γ	1751-3
γ	over	constraint	R	1751-3
R	∪	sequential	Ŵ	1751-3
Ŵ		sequential	γ	1751-3
γ	|=	sequential	γ	1751-3
γ	implies	action	γ	1751-3
<B>	that	constraint	S	1751-4
<B>	Suppose	action	S	1751-4
S	is	attribute	a GSM schema	1751-4
a GSM schema	and	conjunctive	R	1751-4
R	∪ Ŵ	sequential	a relational simulation	1751-4
R	is	attribute	a relational simulation	1751-4
a relational simulation	of	constraint	S	1751-4
<B>	To	constraint	this section	1752-1
<B>	conclude	action	this section	1752-1
this section		sequential	we	1752-1
we	consider	action	criterion	1752-1
criterion		sequential	3	1752-1
This criterion	concerns	action	the preservation	1752-2
the preservation	of	constraint	meta-data	1752-2
We	to	constraint	this criterion	1752-3
We	do not attempt	action	this criterion	1752-3
We	formalize	action	this criterion	1752-3
this criterion	for	constraint	this context	1752-3
this context	but	conjunctive	it	1752-3
it	that	constraint	there	1752-3
it	be	attribute	should clear	1752-3
there	is	attribute	a close correspondence	1752-3
a close correspondence	between	constraint	the dependencies	1752-3
the dependencies	in	constraint	∪	1752-3
The preceding discussion	that	constraint	no dependency	1753-1
The preceding discussion	assumes	action	no dependency	1753-1
no dependency	for	constraint	S	1753-1
no dependency	holds	action	S	1753-1
S	from	constraint	the keys	1753-1
S	by	constraint	the keys	1753-1
S	implied	action	the keys	1753-1
the keys	and	conjunctive	the constructs	1753-1
the constructs	in	constraint	S.	1753-1
S.	in	constraint	many cases	1753-1
many cases		sequential	constraints	1753-1
constraints	into	constraint	S	1753-1
constraints	However will be incorporated	action	S	1753-1
S		sequential	that	1753-1
that	by	constraint	the structure	1753-1
that	are not directly implied	action	the structure	1753-1
the structure	of	constraint	S	1753-1
S	For	constraint	instance	1753-1
instance	recall	action	Example 11.1.2	1753-1
Example 11.1.2	that	constraint	the fd Pariscope	1753-1
Example 11.1.2	and	conjunctive	the fd Pariscope	1753-1
Example 11.1.2	suppose	action	the fd Pariscope	1753-1
the fd Pariscope		sequential	theater_name	1753-1
theater_name		sequential	time	1753-1
time	→	sequential	price	1753-1
price	for	constraint	the underlying data	1753-1
price	is	attribute	true	1753-1
The relational simulation	to	constraint	this dependency	1753-2
The relational simulation	will have	action	this dependency	1753-2
The relational simulation	include	action	this dependency	1753-2
this dependency	as	constraint	a result	1753-2
this dependency	and	conjunctive	a result	1753-2
a result		sequential	the resulting relational schema	1753-2
the resulting relational schema	of	constraint	the desirable features	1753-2
the resulting relational schema	may be missing	attribute	some	1753-2
the desirable features		sequential	the family	1753-2
the family	of	constraint	fd	1753-2
fd		sequential	s	1753-2
s	to	constraint	a set	1753-2
s	is	attribute	e.g. not equivalent	1753-2
a set	of	constraint	keys	1753-2
keys	and	conjunctive	the schema	1753-2
the schema	in	constraint	no longer BCNF	1753-2
the schema	is	attribute	no longer BCNF	1753-2
<B>	that	constraint	a semantic model	1754-1
<B>	suggests	action	a semantic model	1754-1
a semantic model	to	constraint	a coarse relational schema	1754-1
a semantic model	might be used	action	a coarse relational schema	1754-1
a semantic model	obtain	action	a coarse relational schema	1754-1
a coarse relational schema		sequential	which	1754-1
which	might be refined further	action	the techniques	1754-1
which	using	action	the techniques	1754-1
the techniques	for	constraint	relational schemas	1754-1
the techniques	improving	action	relational schemas	1754-1
relational schemas	in	constraint	the next section	1754-1
relational schemas	developed	action	the next section	1754-1
Normal Forms		sequential	Normal Forms	1755-1
The articulation	of	constraint	these normal forms	1755-2
these normal forms	is	attribute	arguably the main contribution	1755-2
arguably the main contribution	of	constraint	relational database theory	1755-2
relational database theory	to	constraint	the realm	1755-2
the realm	of	constraint	schema design	1755-2
We	begin	action	the discussion	1755-3
the discussion	by	constraint	two	1755-3
the discussion	presenting	action	two	1755-3
two	of	constraint	the most prominent normal forms	1755-3
the most prominent normal forms	and	conjunctive	a design strategy	1755-3
a design strategy	on	constraint	decomposition	1755-3
a design strategy	based	action	decomposition	1755-3
all the dependencies	in	constraint	a relational schema	1756-1
a relational schema		sequential	R	1756-1
R	to	constraint	one	1756-1
R	When are considered	action	one	1756-1
R	be tagged	action	one	1756-1
one	can view	action	the database schema	1756-1
the database schema	as	constraint	a set	1756-1
a set		sequential	R1	1756-1
R1		sequential	1	1756-1
<B>	.	sequential	<B>	1756-2
<B>	.	sequential	<B>	1756-3
Rn		sequential	n	1756-4
n		sequential	}	1756-4
}		sequential	Rj	1756-4
Rj		sequential	j	1756-4
j	is	attribute	where a relation schema	1756-4
where a relation schema	and	conjunctive	the Rj	1756-4
the Rj	are	attribute	distinct	1756-4
<B>	In	constraint	an fd schema	1756-5
an fd schema	is	attribute	a relation schema	1756-5
a relation schema		sequential	R	1756-5
R	or	conjunctive	database schema	1756-5
database schema		sequential	R	1756-5
R	is	attribute	a set	1756-5
a set	of	constraint	tagged fd	1756-5
tagged fd		sequential	s	1756-5
s	in	constraint	the natural fashion	1756-5
s	is extended	action	the natural fashion	1756-5
the natural fashion	to	constraint	other classes	1756-5
other classes	of	constraint	dependencies	1756-5
<B>	of	constraint	the work	1756-6
the work	on	constraint	refinement	1756-6
refinement	of	constraint	relational schemas	1756-6
relational schemas	on	constraint	fd schemas	1756-6
relational schemas	has focused	action	fd schemas	1756-6
fd schemas	and	conjunctive	fd	1756-6
fd	+	sequential	mvd	1756-6
mvd		sequential	schemas	1756-6
<B>	is	attribute	what	1756-7
what		sequential	we	1756-7
we	consider here	action	<B>	1756-7
The impact	of	constraint	the ind	1756-8
the ind		sequential	s	1756-8
s	at	constraint	the end	1756-8
s	is briefly considered	action	the end	1756-8
the end	of	constraint	this section	1756-8
A normal form	restricts	action	the set	1756-9
the set	of	constraint	dependencies	1756-9
dependencies		sequential	that	1756-9
that	to	constraint	a relation schema	1756-9
that	in	constraint	a relation schema	1756-9
that	are allowed	action	a relation schema	1756-9
that	hold	action	a relation schema	1756-9
The main purpose	of	constraint	the normal forms	1756-10
the normal forms	to	constraint	the redundancies	1756-10
the normal forms	at	constraint	the redundancies	1756-10
the normal forms	of	constraint	the redundancies	1756-10
the normal forms	is	attribute	least	1756-10
the normal forms	eliminate	attribute	least	1756-10
the redundancies	and	conjunctive	anomalies	1756-10
the redundancies	update	action	anomalies	1756-10
anomalies		sequential	that	1756-10
that	might otherwise arise	action	<B>	1756-10
schemas	in	constraint	normal form	1756-11
normal form	are	attribute	good	1756-11
We	introduce	action	next two kinds	1757-1
next two kinds	of	constraint	normal forms	1757-1
normal forms		sequential	namely BCNF	1757-1
namely BCNF	and	conjunctive	4NF	1757-1
We	will consider later	action	a third one	1757-2
a third one		sequential	3NF	1757-2
We	consider	action	techniques	1757-3
techniques	to	constraint	a schema	1757-3
techniques	transform	action	a schema	1757-3
a schema	into	constraint	such desirable normal forms	1757-3
BCNF	Do Not Represent	action	the Same Fact	1758-1
the Same Fact	Twice Recall	action	the schema	1758-1
the schema		sequential	Movies	1758-1
Movies		sequential	T	1758-1
T		sequential	itle	1758-1
itle		sequential	D	1758-1
D		sequential	irector	1758-1
irector		sequential	A	1758-1
A		sequential	actor	1758-1
actor	{	sequential	T	1758-1
T	→	sequential	D }	1758-1
D }	from	constraint	Section 8.1	1758-1
<B>	As	constraint	the Movies relation	1758-2
<B>	discussed	action	the Movies relation	1758-2
the Movies relation	from	constraint	various anomalies	1758-2
the Movies relation	suffers	action	various anomalies	1758-2
various anomalies	because	constraint	there	1758-2
there	primarily is	action	only one Director	1758-2
only one Director	with	constraint	each Title	1758-2
only one Director	associated	action	each Title	1758-2
each Title	but	conjunctive	possibly several Actors	1758-2
<B>	that	constraint	R	1758-3
<B>	Suppose	action	R	1758-3
R		sequential	U	1758-3
U	is	attribute	a relation schema	1758-3
a relation schema	|=	sequential	X Y	1758-3
X Y	→	sequential	Y ⊆ X	1758-3
Y ⊆ X	and	conjunctive	|= X → U	1758-3
It	to	constraint	anomalies	1758-4
It	that	constraint	anomalies	1758-4
It	is	attribute	not hard	1758-4
It	see	action	anomalies	1758-4
anomalies	to	constraint	Movies	1758-4
anomalies	of	constraint	Movies	1758-4
Movies	in	constraint	R. Boyce	1758-4
Movies	can arise	action	R. Boyce	1758-4
R. Boyce		sequential	Codd	1758-4
Codd		sequential	normal form	1758-4
normal form	prohibits	action	this kind	1758-4
this kind	of	constraint	situation	1758-4
Definition		sequential	11.2.1	1759-1
An fd schema		sequential	R	1759-2
R	in	constraint	BCNF	1759-2
R	is	attribute	BCNF	1759-2
BCNF	if	constraint	its relation schemas	1759-2
BCNF	of	constraint	its relation schemas	1759-2
its relation schemas	is	attribute	<B>	1759-2
BCNF	in	constraint	cases	1760-1
BCNF	is most often discussed	action	cases	1760-1
cases	where involves	action	only functional dependencies	1760-1
<B>	In	constraint	such cases	1760-2
such cases	if	constraint	R	1760-2
R	in	constraint	BCNF	1760-2
R	is	attribute	BCNF	1760-2
BCNF		sequential	the anomalies	1760-2
the anomalies	of	constraint	Section 8.1	1760-2
Section 8.1	do not arise	action	<B>	1760-2
An essential intuition	underlying	action	BCNF	1760-3
BCNF	is	attribute	the same fact	1760-3
BCNF	Do not represent twice	action	the same fact	1760-3
the same fact		sequential	The question	1760-3
The question	now arises	action	<B>	1760-3
<B>	In	constraint	many cases	1760-4
many cases		sequential	it	1760-4
it	to	constraint	this schema	1760-4
it	is	attribute	possible	1760-4
it	decompose	action	this schema	1760-4
this schema	into	constraint	subschemas	1760-4
subschemas		sequential	R1	1760-4
R1		sequential	1	1760-4
<B>	.	sequential	<B>	1760-5
<B>	.	sequential	<B>	1760-6
Rn		sequential	n	1760-7
n	without	constraint	information loss	1760-7
<B>	As	constraint	a simple example	1760-8
a simple example		sequential	Movies	1760-8
Movies	into	constraint	Design	1760-8
Movies	can be decomposed	action	Design	1760-8
Design	and	conjunctive	Dependencies	1760-8
<B>	Consider	action	the relation schema	1761-1
the relation schema		sequential	Studios	1761-1
Studios		sequential	N	1761-1
N		sequential	ame	1761-1
ame		sequential	D	1761-1
D		sequential	irector	1761-1
irector		sequential	L	1761-1
L		sequential	ocation	1761-1
ocation		sequential	N	1761-1
N	→	sequential	tuple	1761-1
tuple	n	conjunctive	d	1761-1
d		sequential	l	1761-1
l	in	constraint	Studios	1761-1
l	is	attribute	Studios	1761-1
Studios	if	constraint	director d	1761-1
director d	by	constraint	the studio	1761-1
director d	is employed	action	the studio	1761-1
the studio	with	constraint	name	1761-1
name	if	constraint	this studio	1761-1
name	n	conjunctive	this studio	1761-1
name	and	conjunctive	this studio	1761-1
this studio	has	action	an office	1761-1
an office	in	constraint	location	1761-1
location		sequential	l	1761-1
update anomalies	because	constraint	D	1761-2
update anomalies	However can still arise	action	D	1761-2
D	and	conjunctive	L	1761-2
L		sequential	the values	1761-2
the values	from	constraint	<B>	1761-2
the values	are	attribute	essentially independent	1761-2
<B>	gives	action	rise	1761-3
rise	to	constraint	the following generalization	1761-3
the following generalization	of	constraint	BCNF2	1761-3
BCNF2		sequential	Definition 11.2.2	1761-3
It	that	constraint	a relation schema	1762-1
It	if	constraint	a relation schema	1762-1
It	is	attribute	clear	1762-1
a relation schema	in	constraint	4NF	1762-1
a relation schema	is	attribute	4NF	1762-1
4NF		sequential	it	1762-1
it	in	constraint	BCNF	1762-1
it	is	attribute	BCNF	1762-1
It	that	constraint	Studios	1762-2
It	is easily seen	action	Studios	1762-2
Studios	into	constraint	two 4NF relations	1762-2
Studios	can be decomposed	action	two 4NF relations	1762-2
two 4NF relations	without	constraint	loss	1762-2
loss	of	constraint	information	1762-2
information	that	constraint	the resulting relation schemas	1762-2
information	and	conjunctive	the resulting relation schemas	1762-2
the resulting relation schemas	do not have	action	the update anomalies	1762-2
the update anomalies	mentioned earlier	action	<B>	1762-2
An essential intuition	underlying	action	4NF	1762-3
4NF	is	attribute	unrelated information	1762-3
4NF	Do not store	action	unrelated information	1762-3
unrelated information	in	constraint	the same relation	1762-3
<B>	In	constraint	this approach	1762-4
this approach		sequential	it	1762-4
it	that	constraint	the original schema	1762-4
it	is usually assumed	action	the original schema	1762-4
the original schema	of	constraint	a single wide relation	1762-4
the original schema	consists	action	a single wide relation	1762-4
a single wide relation	containing	action	all attributes	1762-4
all attributes	of	constraint	interest	1762-4
<B>	to	constraint	the pure universal relation assumption	1762-5
<B>	as	constraint	the pure universal relation assumption	1762-5
<B>	is referred	action	the pure universal relation assumption	1762-5
the pure universal relation assumption	or	conjunctive	pure URA	1762-5
A relaxation	of	constraint	the pure URA	1762-6
the pure URA	called	action	the weak URA	1762-6
the weak URA	in	constraint	Section 11.3	1762-6
the weak URA	is considered briefly	action	Section 11.3	1762-6
The pure URA	is	attribute	a simplifying assumption	1763-1
a simplifying assumption	because	constraint	practice	1763-1
a simplifying assumption	in	constraint	practice	1763-1
practice		sequential	the original schema	1763-1
the original schema	to	constraint	several tables	1763-1
the original schema	of	constraint	several tables	1763-1
the original schema	is	attribute	likely	1763-1
the original schema	consist	action	several tables	1763-1
several tables	with	constraint	each its own dependencies	1763-1
<B>	In	constraint	that case	1763-2
that case		sequential	the design process	1763-2
the design process	for	constraint	the pure URA	1763-2
the design process	described	action	the pure URA	1763-2
the pure URA	to	constraint	each table	1763-2
the pure URA	is applied separately	action	each table	1763-2
We	adopt here	action	the pure URA	1763-3
<B>	In	constraint	this context	1763-4
this context		sequential	the schema transformation	1763-4
the schema transformation	by	constraint	the design process	1763-4
the schema transformation	produced	action	the design process	1763-4
the design process	of	constraint	the original table	1763-4
the design process	consists	action	the original table	1763-4
the design process	decomposing	action	the original table	1763-4
the original table	into	constraint	smaller tables	1763-4
smaller tables	by	constraint	the projection operator	1763-4
smaller tables	using	action	the projection operator	1763-4
<B>	with	constraint	dependencies	1764-1
dependencies	∪	sequential	<B>	1764-1
The relation name		sequential	U	1764-2
U	to	constraint	it	1764-2
U	that	constraint	it	1764-2
U	is used	action	it	1764-2
U	suggest	action	it	1764-2
it	is	attribute	universal	1764-2
<B>	In	constraint	the sequel	1764-3
the sequel		sequential	we	1764-3
we	often use	action	relation names	1764-3
relation names		sequential	U	1764-3
U		sequential	Ri	1764-3
Ri	and	conjunctive	sets	1764-3
Ri	attribute interchangeably	action	sets	1764-3
sets		sequential	Z	1764-3
Z		sequential	Xi	1764-3
Xi	if	constraint	ambiguity	1764-3
ambiguity	does not arise	action	<B>	1764-3
We	now consider	action	the three criteria	1765-1
the three criteria	for	constraint	schema transformation	1765-1
schema transformation	in	constraint	the context	1765-1
the context	of	constraint	decomposition	1765-1
<B>	As	constraint	criterion	1765-2
<B>	already suggested	action	criterion	1765-2
criterion		sequential	2	1765-2
2	in	constraint	terms	1765-2
2	is evaluated	action	terms	1765-2
terms	of	constraint	the normal forms	1765-2
<B>	With	constraint	regard	1765-3
regard	to	constraint	the preservation	1765-3
the preservation	of	constraint	data	1765-3
data		sequential	1	1765-3
1		sequential	the mapping	1765-3
the mapping	from	constraint	R	1765-3
R	to	constraint	R	1765-3
R	by	constraint	projection	1765-3
R	is obtained	action	projection	1765-3
Criterion		sequential	1	1765-4
1	that	constraint	the decompo-j sition	1765-4
1	says	action	the decompo-j sition	1765-4
the decompo-j sition	should not lose	action	information	1765-4
information		sequential	I	1765-4
I	by	constraint	its projections	1765-4
I	when is replaced	action	its projections	1765-4
its projections		sequential	it	1765-4
it	be	attribute	should one	1765-4
should one	to	constraint	one	1765-4
Rn I		sequential	U	1766-1
<B>	But	conjunctive	q	1766-2
q		sequential	I	1766-2
we	Thus have	action	Theorem 11.2.3	1766-3
Theorem 11.2.3	Let	action	U	1766-3
U	be	attribute	full dependencies	1766-3
full dependencies		sequential	the following a schema	1766-3
the following a schema	and	conjunctive	R	1766-3
R		sequential	a decomposition	1766-3
a decomposition	for	constraint	U	1766-3
R	Then has	action	the lossless join property iff	1766-4
the lossless join property iff		sequential	R	1766-4
The preceding implication	can be tested	action	the chase	1767-1
The preceding implication	using	action	the chase	1767-1
the chase	see	action	Chapter 8	1767-1
Chapter 8	as	constraint	<B>	1767-1
Chapter 8	illustrated next	action	<B>	1767-1
Example		sequential	11.2.4	1768-1
<B>	As	constraint	a decomposition	1768-2
<B>	suggested earlier	action	a decomposition	1768-2
a decomposition	into	constraint	BCNF	1768-2
BCNF	is	attribute	R	1768-2
R	=	sequential	TD TA }	1768-2
This decomposition	has	action	the lossless join property	1768-3
The tableau	with	constraint	the jd σ	1768-4
The tableau	associated	action	the jd σ	1768-4
the jd σ	=⊲⊳	sequential	TD	1768-4
TD		sequential	TA	1768-4
TA	as	constraint	Tσ T D t d t d1 tσ t	1768-4
TA	is	attribute	Tσ T D t d t d1 tσ t	1768-4
TA	follows	action	Tσ T D t d t d1 tσ t	1768-4
Tσ T D t d t d1 tσ t	Consider	action	the chase	1768-4
the chase	of	constraint	Tσ	1768-4
Tσ		sequential	tσ	1768-4
tσ	with	constraint	T }	1768-4
T }	→	sequential	D	1768-4
<B>	Because	constraint	the two first tuples	1768-5
the two first tuples	on	constraint	the T column	1768-5
the two first tuples	agree	action	the T column	1768-5
the T column		sequential	d	1768-5
d	and	conjunctive	d1	1768-5
d1	because of	constraint	the fd	1768-5
d1	are merged	action	the fd	1768-5
Thus t		sequential	d	1768-6
d		sequential	a ∈ chase	1768-6
a ∈ chase		sequential	Tσ	1768-6
Tσ		sequential	tσ	1768-6
tσ		sequential	T }	1768-6
T }	→	sequential	D	1768-6
T D	Hence implies	action	the jd σ	1769-1
the jd σ		sequential	R	1769-1
R	so has	action	the lossless join property	1769-1
<B>	See also	action	Exercise 11.9	1769-2
<B>	to	constraint	the preceding example	1770-1
<B>	Referring	action	the preceding example	1770-1
the preceding example	that	constraint	it	1770-1
the preceding example	note	action	it	1770-1
it	to	constraint	information	1770-1
it	is	attribute	possible	1770-1
it	represent	action	information	1770-1
information	in	constraint	R	1770-1
R		sequential	that	1770-1
that	in	constraint	Movies	1770-1
that	can not be directly represented	action	Movies	1770-1
<B>	in	constraint	the decomposed schema	1770-2
the decomposed schema		sequential	we	1770-2
we	Specifically can represent	action	a movie	1770-2
a movie	with	constraint	a director	1770-2
a director	but	conjunctive	no actors	1770-2
no actors	and	conjunctive	a movie	1770-2
a movie	with	constraint	an actor	1770-2
an actor	but	conjunctive	no director	1770-2
<B>	that	constraint	a decomposed schema	1771-1
<B>	indicates	action	a decomposed schema	1771-1
a decomposed schema	may have	action	more information capacity Design	1771-1
more information capacity Design	and	conjunctive	Dependencies	1771-1
Dependencies	than	constraint	the original	1771-1
the original	see	action	Exercise 11.23	1771-1
<B>	In	constraint	practice	1771-2
practice		sequential	this additional capacity	1771-2
this additional capacity	in	constraint	fact	1771-2
this additional capacity	is exploited	action	fact	1771-2
fact		sequential	it	1771-2
it	provides	action	part	1771-2
part	of	constraint	the solution	1771-2
the solution	of	constraint	deletion anomalies	1771-2
the solution	so called	action	deletion anomalies	1771-2
Remark		sequential	11.2.5	1772-1
there	Interestingly are	action	cases	1772-2
cases	in	constraint	which	1772-2
which		sequential	the natural join	1772-2
the natural join	does not suffice	action	<B>	1772-2
<B>	To	constraint	a decomposition	1772-3
<B>	that	constraint	a decomposition	1772-3
<B>	show	action	a decomposition	1772-3
a decomposition	is	attribute	one	1772-3
one	to	constraint	one	1772-3
one		sequential	it	1772-3
it	to	constraint	an inverse	1772-3
it	suffices	action	an inverse	1772-3
it	exhibit	action	an inverse	1772-3
an inverse	to	constraint	the projection	1772-3
the projection	called	action	a reconstruction mapping	1772-3
<B>	If	constraint	very general constraints	1772-4
<B>	to	constraint	very general constraints	1772-4
<B>	is permitted	action	very general constraints	1772-4
<B>	include	action	very general constraints	1772-4
very general constraints	in	constraint	first order	1772-4
very general constraints	expressed	action	first order	1772-4
first order		sequential	logic	1772-4
logic		sequential	that	1772-4
that	be	attribute	may not dependencies	1772-4
may not dependencies	per	constraint	se	1772-4
se		sequential	there	1772-4
there	to	constraint	one	1772-4
there	are	attribute	one	1772-4
one		sequential	one decompositions	1772-4
one decompositions		sequential	whose reconstruction mappings	1772-4
whose reconstruction mappings	are	attribute	not the natural join	1772-4
not the natural join	see	action	Exercise 11.20	1772-4
We	now consider	action	criterion	1773-1
criterion		sequential	3	1773-1
3		sequential	the preservation	1773-1
the preservation	of	constraint	meta -data	1773-1
<B>	In	constraint	the context	1773-2
the context	of	constraint	decomposition	1773-2
decomposition	in	constraint	terms	1773-2
decomposition	is formalized	action	terms	1773-2
terms	of	constraint	dependency preservation	1773-2
dependency preservation	Given	action	schema	1773-2
schema		sequential	U	1773-2
U		sequential	which	1773-2
which	by	constraint	a decomposition	1773-2
which	is replaced	action	a decomposition	1773-2
a decomposition		sequential	R	1773-2
R	=	sequential	R1	1773-2
R	{	sequential	R1	1773-2
<B>	.	sequential	<B>	1773-3
<B>	.	sequential	<B>	1773-4
Rn		sequential	}	1773-5
}		sequential	we	1773-5
we	to	constraint	each j	1773-5
we	for	constraint	each j	1773-5
we	would like	action	each j	1773-5
we	find	action	each j	1773-5
each j		sequential	a family Ŵj	1773-5
a family Ŵj	of	constraint	dependencies	1773-5
dependencies	over	constraint	Rj	1773-5
Rj	that	constraint	∪j Ŵj	1773-5
∪j Ŵj	to	constraint	the original	1773-5
∪j Ŵj	is	attribute	equivalent	1773-5
<B>	In	constraint	the case	1773-6
the case	is	attribute	where a set	1773-6
where a set	of	constraint	fd	1773-6
fd		sequential	s	1773-6
s		sequential	we	1773-6
we	can make	attribute	this	1773-6
<B>	For	constraint	V ⊆	1773-7
V ⊆		sequential	U	1773-7
U	let	action	πV	1773-7
πV	=	sequential	X A	1773-7
πV	→	sequential	X A	1773-7
X A		sequential	XA ⊆ V	1773-7
XA ⊆ V	and	conjunctive	X	1773-7
XA ⊆ V	|=	sequential	X	1773-7
X	→	sequential	A	1773-7
A		sequential	}	1773-7
}		sequential	let	1773-7
let		sequential	Ŵj	1773-7
Ŵj		sequential	π	1773-7
π		sequential	X	1773-7
X	and	conjunctive	Ŵ	1773-7
X	let	action	Ŵ	1773-7
Ŵ		sequential	∪ j j Ŵj	1773-7
<B>	Obviously |=	sequential	<B>	1773-8
<B>	See	action	Proposition 10.2.4	1773-9
<B>	of	constraint	the dependencies	1773-10
<B>	consists	action	the dependencies	1773-10
the dependencies	in	constraint	∗	1773-10
∗		sequential	that	1773-10
that	to	constraint	the relations	1773-10
that	are	attribute	local	1773-10
the relations	in	constraint	the decomposition R	1773-10
<B>	In	constraint	other words	1773-11
other words	by	constraint	the dependencies	1773-11
other words	can be enforced	action	the dependencies	1773-11
the dependencies	in	constraint	the decomposition	1773-11
It	to	constraint	the decomposition	1773-12
It	that	constraint	the decomposition	1773-12
It	is	attribute	easy	1773-12
It	see	action	the decomposition	1773-12
the decomposition	of	constraint	Example 11.2.4	1773-12
Example 11.2.4	is	attribute	dependency	1773-12
dependency	preserving	action	<B>	1773-12
<B>	Given	action	an fd schema	1774-1
an fd schema		sequential	U	1774-1
U	and	conjunctive	V ⊆ U	1774-1
V ⊆ U		sequential	πV	1774-1
πV	has	action	size	1774-1
size	in	constraint	V	1774-1
V	because of	constraint	simply trivial fd	1774-1
simply trivial fd		sequential	<B>	1774-1
<B>	But	conjunctive	there	1774-2
there	perhaps is	action	a smaller set	1774-2
a smaller set	of	constraint	fd	1774-2
fd		sequential	s	1774-2
s		sequential	that	1774-2
that	to	constraint	πV	1774-2
that	is	attribute	equivalent	1774-2
A cover	of	constraint	a set	1774-3
a set	of	constraint	fd	1774-3
fd		sequential	s	1774-3
s	is	attribute	a set Ŵ′	1774-3
a set Ŵ′	of	constraint	fd	1774-3
fd	that	constraint	Ŵ′	1774-3
Ŵ′	≡	sequential	<B>	1774-3
<B>	in	constraint	some cases	1774-4
some cases		sequential	the smallest cover	1774-4
the smallest cover	for	constraint	a projection πV	1774-4
a projection πV	in	constraint	the size	1774-4
a projection πV	is	attribute	Unfortunately exponential	1774-4
the size	of	constraint	Exercise 11.11	1774-4
the size	see	action	Exercise 11.11	1774-4
What	about	constraint	projections	1775-1
projections	of	constraint	sets	1775-1
sets	of	constraint	mvd	1775-1
mvd		sequential	<B>	1775-1
<B>	Suppose	attribute	that	1775-2
<B>	is	attribute	a set	1775-2
a set	of	constraint	fd s	1775-2
fd s	and	conjunctive	mvd	1775-2
mvd	over	constraint	U	1775-2
<B>	Let	action	V	1775-3
V		sequential	⊆	1775-3
⊆		sequential	U	1775-3
U	and	conjunctive	<B>	1775-3
<B>	Consider	action	a decomposition R	1776-1
a decomposition R	of	constraint	U	1776-1
<B>	as	constraint	constraints	1776-2
<B>	Viewed	action	constraints	1776-2
constraints	on	constraint	U	1776-2
U		sequential	the sets	1776-2
the sets		sequential	π mvd	1776-2
π mvd	are	attribute	Rj	1776-2
Rj		sequential	now embedded mvd	1776-2
now embedded mvd		sequential	s	1776-2
<B>	As	constraint	we	1776-3
we	in	constraint	Chapter 10	1776-3
we	saw	action	Chapter 10	1776-3
Chapter 10		sequential	testing implication	1776-3
testing implication	for	constraint	embedded mvd	1776-3
embedded mvd	is	attribute	undecidable	1776-3
the issue	of	constraint	testing	1776-4
testing	for	constraint	dependency preservation	1776-4
dependency preservation	in	constraint	the context	1776-4
the context	of	constraint	decompositions	1776-4
decompositions	involving	action	fd	1776-4
fd		sequential	s	1776-4
s	and	conjunctive	mvd	1776-4
mvd	and	conjunctive	<B>	1776-4
mvd	is	attribute	However rather specialized	1776-4
mvd	remains	attribute	open	1776-4
Fd	and	conjunctive	Decomposition	1777-1
Decomposition	into	constraint	BCNF	1777-1
The decomposition	by	constraint	the algorithm	1777-2
The decomposition	produced	action	the algorithm	1777-2
the algorithm	has	action	the lossless join property	1777-2
the lossless join property	to	constraint	dependency	1777-2
the lossless join property	but	conjunctive	dependency	1777-2
the lossless join property	be	attribute	dependency	1777-2
the lossless join property	is not guaranteed	action	dependency	1777-2
dependency	preserving	action	<B>	1777-2
We	with	constraint	a simple example	1778-1
We	begin	action	a simple example	1778-1
Example		sequential	11.2.6	1779-1
We	now present	attribute	the following	1780-1
Input		sequential	A relation schema	1780-1
A relation schema		sequential	U	1780-1
U	is	attribute	a set	1780-1
a set	of	constraint	fd	1780-1
fd		sequential	<B>	1780-1
Output		sequential	A database schema	1781-1
A database schema		sequential	R	1781-1
R		sequential	Ŵ	1781-1
Ŵ	in	constraint	BCNF	1781-1
Design	and	conjunctive	Dependencies	1782-1
<B>	is easily verified	action	Exercise 11.10	1782-2
<B>	see	action	Exercise 11.10	1782-2
Exercise 11.10		sequential	Theorem 11.2.8	1782-2
What	is	attribute	the complexity	1783-1
the complexity	of	constraint	the BCNF Decomposition Algorithm	1783-1
the complexity	running	action	the BCNF Decomposition Algorithm	1783-1
The main expenses	are	attribute	subschemas	1783-2
The main expenses	1 examining	action	subschemas	1783-2
subschemas		sequential	S	1783-2
S		sequential	V	1783-2
V		sequential	L	1783-2
L	to	constraint	they	1783-2
L	if	constraint	they	1783-2
L	see	action	they	1783-2
they	in	constraint	BCNF	1783-2
they	are	attribute	BCNF	1783-2
BCNF	if	constraint	a way	1783-2
BCNF	and	conjunctive	a way	1783-2
BCNF	finding	action	a way	1783-2
a way	to	constraint	them	1783-2
a way	decompose	action	them	1783-2
them	and	conjunctive	the projections	1783-2
them	computing	action	the projections	1783-2
the projections	of	constraint	L.	1783-2
L.		sequential	1	1783-2
1	but	conjunctive	Exercise 11.11	1783-2
1	is	attribute	2 polynomial	1783-2
1	is	attribute	2 inherently exponential	1783-2
1	see	action	Exercise 11.11	1783-2
<B>	suggests	action	a modification	1783-3
a modification	to	constraint	the algorithm	1783-3
the algorithm	in	constraint	which	1783-3
which		sequential	only the relational schemas S	1783-3
only the relational schemas S		sequential	V	1783-3
V	at	constraint	each stage	1783-3
V	are computed	action	each stage	1783-3
each stage	but	conjunctive	L	1783-3
L	=	sequential	π V	1783-3
π V	is not	action	<B>	1783-3
<B>		sequential	the problem	1783-4
the problem	of	constraint	given fd schema	1783-4
the problem	determining	action	given fd schema	1783-4
given fd schema		sequential	U	1783-4
U	and	conjunctive	V ⊆ U	1783-4
V ⊆ U	whether	constraint	V	1783-4
V		sequential	πV	1783-4
πV	in	constraint	BCNF	1783-4
πV	is	attribute	BCNF	1783-4
BCNF	is	attribute	co-np complete	1783-4
BCNF	see	action	Exercise 11.12	1783-4
a polynomial time algorithm	for	constraint	some BCNF decomposition	1783-5
a polynomial time algorithm	Interestingly does exist	action	some BCNF decomposition	1783-5
a polynomial time algorithm	finding	action	some BCNF decomposition	1783-5
some BCNF decomposition	of	constraint	an input schema	1783-5
an input schema		sequential	U	1783-5
U	see	action	Exercise 11.13	1783-5
<B>	When applying	action	BCNF decomposition	1784-1
BCNF decomposition	to	constraint	the schema	1784-1
the schema	of	constraint	Example 11.2.6	1784-1
Example 11.2.6		sequential	the same result	1784-1
the same result	of	constraint	the order	1784-1
the same result	is achieved	action	the order	1784-1
the order	in	constraint	which	1784-1
which		sequential	the dependencies	1784-1
the dependencies	are applied	action	<B>	1784-1
<B>	is	attribute	not always the case	1784-2
not always the case	as	constraint	<B>	1784-2
not always the case	illustrated next	action	<B>	1784-2
Example 11.2.9 Consider		sequential	ABC	1785-1
ABC	{	sequential	A	1785-1
A	→	sequential	B	1785-1
B		sequential	B	1785-1
B	→	sequential	C	1785-1
C		sequential	}	1785-1
<B>	has	action	two BCNF decompo- sitions	1785-2
two BCNF decompo- sitions		sequential	R1	1785-2
R1	=	sequential	AB	1785-2
R1	{	sequential	AB	1785-2
AB	{	sequential	A	1785-2
A	→	sequential	B	1785-2
B		sequential	}	1785-2
}		sequential	BC	1785-2
BC	{	sequential	B	1785-2
B	→	sequential	C	1785-2
C		sequential	}	1785-2
}		sequential	}	1785-2
}		sequential	R2	1785-2
R2	=	sequential	AB	1785-2
AB	{	sequential	A	1785-2
A	→	sequential	B	1785-2
B		sequential	}	1785-2
}		sequential	AC	1785-2
AC		sequential	∅	1785-2
∅		sequential	}	1785-2
<B>	that	constraint	R1	1786-1
<B>	Note	action	R1	1786-1
R1	is	attribute	dependency	1786-1
dependency	but	conjunctive	R2	1786-1
dependency	preserving	action	R2	1786-1
R2	is not	action	<B>	1786-1
Fd		sequential	Dependency Preservation	1787-1
Dependency Preservation	and	conjunctive	3NF	1787-1
<B>	as	constraint	the following example	1787-2
<B>	by	constraint	the following example	1787-2
<B>	is	attribute	However not always achievable	1787-2
<B>	shown	action	the following example	1787-2
Example		sequential	11.2.10	1788-1
11.2.10	Consider	action	a schema Lectures	1788-1
a schema Lectures		sequential	C	1788-1
C		sequential	ourse	1788-1
ourse		sequential	P	1788-1
P		sequential	rofessor	1788-1
rofessor		sequential	H	1788-1
H		sequential	tuple	1788-1
tuple		sequential	c	1788-1
c		sequential	p	1788-1
p		sequential	h	1788-1
h	that	constraint	course c	1788-1
h	indicates	action	course c	1788-1
course c	by	constraint	professor p	1788-1
course c	is taught	action	professor p	1788-1
professor p	at	constraint	hour h	1788-1
<B>	that	constraint	the following two dependencies	1788-2
<B>	Assume	action	the following two dependencies	1788-2
the following two dependencies	to	constraint	<B>	1788-2
the following two dependencies	are	attribute	<B>	1788-2
the following two dependencies	hold	action	<B>	1788-2
C	→	sequential	P	1789-1
PH C	→	sequential	<B>	1790-1
The schema		sequential	Lectures	1791-1
Lectures	in	constraint	not BCNF	1791-1
Lectures	is	attribute	not BCNF	1791-1
not BCNF	because |=	constraint	C	1791-1
C	→	sequential	P	1791-1
P	but	conjunctive	C	1791-1
C	→	sequential	H	1791-1
It	that	constraint	CP C	1792-1
It	is easily seen	action	CP C	1792-1
CP C	→	sequential	P }	1792-1
P }	and	conjunctive	this decomposition	1792-1
this decomposition	so does not preserve	action	dependencies	1792-1
A simple case analysis	that	constraint	there	1792-2
A simple case analysis	shows	action	there	1792-2
there	is	attribute	no BCNF decomposition	1792-2
no BCNF decomposition	of	constraint	Lectures	1792-2
Lectures		sequential	that	1792-2
that	preserves	action	dependencies	1792-2
<B>	raises	action	the question	1793-1
The affirmative answer	on	constraint	third normal form	1793-2
The affirmative answer	is based	action	third normal form	1793-2
third normal form		sequential	3NF	1793-2
<B>	To	constraint	it	1793-3
<B>	define	action	it	1793-3
it		sequential	we	1793-3
we	need	action	some auxiliary notions	1793-3
<B>	that	constraint	R	1793-4
<B>	Suppose	action	R	1793-4
R		sequential	U	1793-4
U	is	attribute	an fd schema	1793-4
A superkey	of	constraint	R	1793-5
R	is	attribute	a set X ⊆ U such that	1793-5
a set X ⊆ U such that	|=	sequential	X	1793-5
X	→	sequential	U	1793-5
A key	of	constraint	R	1793-6
R	is	attribute	a minimal superkey	1793-6
A key attribute	is	attribute	an attribute	1793-7
an attribute		sequential	A ∈ U	1793-7
A ∈ U		sequential	that	1793-7
that	in	constraint	some key	1793-7
that	is	attribute	some key	1793-7
some key	of	constraint	R	1793-7
Example		sequential	11.2.12	1794-1
PH	is	attribute	Here a key	1794-2
Here a key		sequential	P	1794-2
P	is	attribute	so a key attribute	1794-2
the schema	in	constraint	Thus 3NF	1794-3
the schema	is	attribute	Thus 3NF	1794-3
<B>	Given	action	a set fd	1795-1
a set fd	of	constraint	s	1795-1
s		sequential	a minimal cover of	1795-1
a minimal cover of	is	attribute	a set ′	1795-1
a set ′	of	constraint	fd	1795-1
fd	that	constraint	each dependency	1795-1
each dependency	in	constraint	the form	1795-1
each dependency	′	sequential	the form	1795-1
each dependency	a has	action	the form	1795-1
the form		sequential	X	1795-1
X	→	sequential	A	1795-1
A		sequential	A	1795-1
A	is	attribute	where an attribute	1795-1
where an attribute	≡	sequential	<B>	1795-1
We	now have	attribute	the	1796-1
We	following	action	Input	1796-1
Input		sequential	A relation schema	1796-1
A relation schema		sequential	U	1796-1
U	is	attribute	a set	1796-1
a set	of	constraint	fd	1796-1
fd		sequential	that	1796-1
that	is	attribute	a minimal cover	1796-1
We	that	constraint	each attribute	1796-2
We	assume	action	each attribute	1796-2
each attribute	of	constraint	U	1796-2
U	in	constraint	one fd of	1796-2
U	at	constraint	one fd of	1796-2
U	occurs	attribute	least	1796-2
Output		sequential	Output	1797-1
Design	and	conjunctive	Dependencies	1798-1
the output relations	from	constraint	attributes	1799-1
the output relations	or	conjunctive	attributes	1799-1
the output relations	Intuitively result	action	attributes	1799-1
the output relations	combining	action	attributes	1799-1
the output relations	synthesizing	action	attributes	1799-1
attributes	decomposing	action	the full attribute set	1799-1
<B>	is easily verified	action	Exercise 11.17	1800-1
<B>	see	action	Exercise 11.17	1800-1
Exercise 11.17		sequential	Theorem	1800-1
Theorem		sequential	11.2.14	1800-1
Several improvements	to	constraint	the basic 3NF Synthesis Algorithm	1801-1
the basic 3NF Synthesis Algorithm	can be made easily	action	<B>	1801-1
<B>	For	constraint	example	1801-2
example		sequential	different schemas	1801-2
different schemas	in	constraint	step	1801-2
different schemas	obtained	action	step	1801-2
step		sequential	2.a	1801-2
2.a	if	constraint	they	1801-2
2.a	can be merged	action	they	1801-2
they	from	constraint	fd	1801-2
they	come	action	fd	1801-2
fd	with	constraint	left hand	1801-2
left hand		sequential	the same side	1801-2
Step		sequential	2.b	1801-3
2.b	if	constraint	step 2.a	1801-3
2.b	is not needed	action	step 2.a	1801-3
step 2.a	already produced	action	a schema	1801-3
a schema		sequential	whose set	1801-3
whose set	of	constraint	attributes	1801-3
attributes	is	attribute	a superkey	1801-3
a superkey	for	constraint	U	1801-3
<B>	In	constraint	many practical situations	1801-4
many practical situations		sequential	it	1801-4
it	to	constraint	step	1801-4
it	be	attribute	may appropriate	1801-4
it	omit	action	step	1801-4
step		sequential	2.b	1801-4
2.b	of	constraint	the algorithm	1801-4
<B>	In	constraint	that case	1801-5
that case		sequential	the decomposition	1801-5
the decomposition	preserves	action	dependencies	1801-5
dependencies	but	conjunctive	the lossless join property	1801-5
dependencies	does not necessarily satisfy	action	the lossless join property	1801-5
<B>	In	constraint	the preceding algorithm	1802-1
the preceding algorithm		sequential	it	1802-1
it	that	constraint	each attribute	1802-1
it	was assumed	action	each attribute	1802-1
each attribute	of	constraint	U	1802-1
U	in	constraint	one fd of	1802-1
U	at	constraint	one fd of	1802-1
U	occurs	attribute	least	1802-1
<B>	be	attribute	Obviously may not always the case	1802-2
Obviously may not always the case	for	constraint	example	1802-2
example		sequential	the attribute	1802-2
the attribute		sequential	A_NAME	1802-2
A_NAME	in	constraint	Example 11.2.15 b	1802-2
Example 11.2.15 b	in	constraint	fd	1802-2
Example 11.2.15 b	does not participate	action	fd	1802-2
fd		sequential	<B>	1802-2
One approach	to	constraint	this situation	1802-3
One approach	remedy	action	this situation	1802-3
this situation	to	constraint	symbolic fd s	1802-3
this situation	is	attribute	symbolic fd s	1802-3
this situation	introduce	action	symbolic fd s	1802-3
<B>	For	constraint	instance	1802-4
instance	in	constraint	that example	1802-4
that example		sequential	one	1802-4
one	might include	action	the fd TITLE ω 1	1802-4
the fd TITLE ω 1		sequential	A_NAME	1802-4
A_NAME	→	sequential	ω1	1802-4
ω1	is	attribute	where a new attribute	1802-4
One relation	by	constraint	the algorithm	1802-5
One relation	produced	action	the algorithm	1802-5
the algorithm	be	attribute	will TITLE }	1802-5
will TITLE }		sequential	A	1802-5
A		sequential	NAME	1802-5
NAME	ω	sequential	1	1802-5
<B>	As	constraint	a last step	1802-6
a last step		sequential	attributes	1802-6
attributes		sequential	ω1	1802-6
ω1	are removed	action	<B>	1802-6
<B>	In	constraint	Example 11.2.9	1803-1
Example 11.2.9		sequential	we	1803-1
we	that	constraint	the output	1803-1
we	saw	action	the output	1803-1
the output	of	constraint	a BCNF decomposition	1803-1
a BCNF decomposition	on	constraint	the order	1803-1
a BCNF decomposition	may depend	action	the order	1803-1
the order	in	constraint	which	1803-1
which		sequential	fd	1803-1
fd	are applied	action	<B>	1803-1
<B>	In	constraint	the case	1803-2
the case	of	constraint	the preceding algorithm	1803-2
the preceding algorithm	for	constraint	3NF	1803-2
3NF		sequential	the minimal cover	1803-2
the minimal cover	chosen	action	the final result	1803-2
the minimal cover	greatly impacts	action	the final result	1803-2
Mvd	and	conjunctive	Decomposition	1804-1
Decomposition	into	constraint	4NF	1804-1
Example		sequential	11.2.15 D|L	1805-1
11.2.15 D|L		sequential	}	1805-1
}	in	constraint	BCNF	1805-1
}	is	attribute	BCNF	1805-1
BCNF	and	conjunctive	3NF	1805-1
3NF	but	conjunctive	update anomalies	1805-1
3NF	has	action	update anomalies	1805-1
The mvd	suggests	action	a decomposition	1805-2
a decomposition	into	constraint	Name	1805-2
Name		sequential	Director }	1805-2
Director }		sequential	Name	1805-2
Name		sequential	Location	1805-2
Location		sequential	}	1805-2
which	to	constraint	the original schema	1806-1
which	into	constraint	the original schema	1806-1
which	can be further decomposed	action	the original schema	1806-1
which	incorporated	action	the original schema	1806-1
the original schema		sequential	we	1806-1
we	can further decompose	action	the last relation	1806-1
the last relation	and	conjunctive	a step	1806-1
the last relation	apply	action	a step	1806-1
a step	to	constraint	the BCNF Decomposition Algorithm	1806-1
a step	of	constraint	the BCNF Decomposition Algorithm	1806-1
the BCNF Decomposition Algorithm	to	constraint	Fourth normal form	1806-1
the BCNF Decomposition Algorithm	obtain	action	Fourth normal form	1806-1
Fourth normal form		sequential	4NF	1806-1
4NF	to	constraint	these kinds	1806-1
4NF	2d was originally developed	action	these kinds	1806-1
4NF	address	action	these kinds	1806-1
these kinds	of	constraint	situations	1806-1
<B>	As	constraint	the preceding example	1806-2
<B>	by	constraint	the preceding example	1806-2
<B>	suggested	action	the preceding example	1806-2
the preceding example		sequential	an algorithm	1806-2
an algorithm	yielding	action	4NF decompositions	1806-2
4NF decompositions	along	constraint	the lines	1806-2
4NF decompositions	can be developed	action	the lines	1806-2
the lines	of	constraint	the BCNF Decomposition Algorithm	1806-2
<B>	As with	constraint	BCNF	1806-3
BCNF		sequential	the output	1806-3
the output	of	constraint	4NF decomposition	1806-3
4NF decomposition	is	attribute	a lossless join decomposition	1806-3
a lossless join decomposition		sequential	that	1806-3
that	is	attribute	not necessarily dependency	1806-3
not necessarily dependency	preserving	action	<B>	1806-3
<B>	In	constraint	relational schema design	1807-1
relational schema design	with	constraint	a semantic data model	1807-1
relational schema design	starting	action	a semantic data model	1807-1
a semantic data model		sequential	numerous ind	1807-1
numerous ind		sequential	s	1807-1
s	are typically generated	action	<B>	1807-1
<B>	In	constraint	contrast	1807-2
contrast		sequential	decomposition	1807-2
decomposition	and	conjunctive	synthesis	1807-2
synthesis		sequential	the approaches	1807-2
the approaches	for	constraint	relational schemas	1807-2
the approaches	refining	action	relational schemas	1807-2
relational schemas	as	constraint	ind	1807-2
relational schemas	presented earlier	action	ind	1807-2
relational schemas	do not take	action	ind	1807-2
ind	into	constraint	account	1807-2
It	to	constraint	ind	1807-3
It	is	attribute	possible	1807-3
It	incorporate	action	ind	1807-3
ind	into	constraint	these approaches	1807-3
these approaches	but	conjunctive	the specific choice	1807-3
the specific choice	of	constraint	ind	1807-3
ind	on	constraint	the intended semantics	1807-3
ind	is	attribute	dependent	1807-3
the intended semantics	of	constraint	the target schema	1807-3
Example		sequential	11.2.16	1808-1
R1		sequential	T	1809-1
T	should be included	action	<B>	1809-1
Design	and	conjunctive	Dependencies	1810-1
<B>		sequential	what	1811-1
what	if	constraint	one	1811-1
one	to	constraint	a relational schema	1811-1
one	is	attribute	a relational schema	1811-1
one	refine	action	a relational schema	1811-1
a relational schema		sequential	R	1811-1
R	∪	sequential	a set	1811-1
R	is	attribute	a set	1811-1
a set	of	constraint	tagged fd	1811-1
tagged fd		sequential	s	1811-1
s	and	conjunctive	mvd	1811-1
mvd	and	conjunctive	Ŵ a set	1811-1
mvd	is	attribute	Ŵ a set	1811-1
Ŵ a set	of	constraint	ind	1811-1
ind		sequential	<B>	1811-1
It	that	constraint	there	1811-2
It	may occur	action	there	1811-2
there	is	attribute	an ind Ri ⊆ Rj	1811-2
an ind Ri ⊆ Rj		sequential	X	1811-2
X		sequential	Y	1811-2
Y	and	conjunctive	X	1811-2
Y	either	conjunctive	X	1811-2
X	or	conjunctive	Y	1811-2
Y	to	constraint	the result	1811-2
Y	as	constraint	the result	1811-2
Y	is be split	action	the result	1811-2
the result	of	constraint	a decomposition step	1811-2
The desired semantics	of	constraint	the target schema	1812-1
the target schema	to	constraint	a variety	1812-1
the target schema	between	constraint	a variety	1812-1
the target schema	can be used	action	a variety	1812-1
the target schema	select	action	a variety	1812-1
a variety	of	constraint	heuristic approaches	1812-1
heuristic approaches	to	constraint	the semantics	1812-1
heuristic approaches	preserving	action	the semantics	1812-1
the semantics	of	constraint	this ind	1812-1
<B>	If	constraint	unary ind	1812-2
<B>	of	constraint	unary ind	1812-2
<B>	consists	action	unary ind	1812-2
unary ind		sequential	such splitting	1812-2
such splitting	can not occur	action	<B>	1812-2
<B>	if	constraint	the ind	1812-3
<B>	Speaking intuitively	action	the ind	1812-3
the ind	of	constraint	the chances	1812-3
the ind	are key based	action	the chances	1812-3
the chances	of	constraint	such splitting	1812-3
such splitting	are reduced	action	<B>	1812-3
Universal Relation Assumption		sequential	Universal Relation Assumption	1813-1
This section	by	constraint	the implications	1813-2
This section	of	constraint	the implications	1813-2
This section	begins	attribute	some	1813-2
This section	articulating	attribute	some	1813-2
the implications		sequential	that	1813-2
that	underly	action	the pure URA	1813-2
It	presents	action	the weak URA	1813-3
the weak URA		sequential	which	1813-3
which	provides	action	an intuitively natural mechanism	1813-3
an intuitively natural mechanism	for	constraint	a relational database instance	1813-3
an intuitively natural mechanism	viewing	action	a relational database instance	1813-3
a relational database instance		sequential	I	1813-3
I	as	constraint	it	1813-3
I	if	constraint	it	1813-3
it	were	attribute	a universal relation	1813-3
Underlying Assumptions		sequential	Underlying Assumptions	1814-1
One	of	constraint	several different database schemas	1814-2
several different database schemas	of	constraint	them	1814-2
several different database schemas	but	conjunctive	them	1814-2
several different database schemas	might be produced	attribute	all	1814-2
them	presumably carry	action	roughly the same semantics	1814-2
<B>	that	constraint	the attributes	1814-3
<B>	suggests	action	the attributes	1814-3
the attributes	in	constraint	Z	1814-3
Z	into	constraint	relation schemas	1814-3
Z	can be grouped	action	relation schemas	1814-3
relation schemas	in	constraint	several different ways	1814-3
several different ways	without	constraint	their underlying semantics	1814-3
several different ways	substantially affecting	action	their underlying semantics	1814-3
it	is	attribute	Intuitively the attributes	1814-4
Intuitively the attributes		sequential	themselves	1814-4
themselves	along	constraint	the dependencies in	1814-4
themselves	with	constraint	the dependencies in	1814-4
the dependencies in		sequential	the attributes	1814-4
the attributes	as	constraint	they	1814-4
they	in	constraint	different relation schemas	1814-4
they	occur	action	different relation schemas	1814-4
different relation schemas		sequential	that	1814-4
that	carry	action	the bulk	1814-4
the bulk	of	constraint	the semantics	1814-4
the semantics	in	constraint	the schema	1814-4
The notion	that	constraint	the attributes	1814-5
the attributes	can represent	action	a substantial portion	1814-5
a substantial portion	of	constraint	the semantics	1814-5
the semantics	of	constraint	an application	1814-5
an application	to	constraint	schema design	1814-5
an application	is	attribute	central	1814-5
schema design	on	constraint	the pure URA	1814-5
schema design	based	action	the pure URA	1814-5
decomposition	and	conjunctive	synthesis	1815-1
synthesis	When were first introduced	action	the underlying implications	1815-1
the underlying implications	of	constraint	this notion	1815-1
this notion	were not well understood	action	<B>	1815-1
Several intuitive assumptions	were articulated	action	that	1815-2
that	to	constraint	these implications	1815-2
that	attempted	action	these implications	1815-2
that	capture	action	these implications	1815-2
We	describe here	action	two	1815-3
two	of	constraint	the most important assumptions	1815-3
Any approach	to	constraint	relational schema design	1815-4
relational schema design	on	constraint	the pure URA	1815-4
relational schema design	based	action	the pure URA	1815-4
the pure URA	by	constraint	these two assumptions	1815-4
the pure URA	should also abide	action	these two assumptions	1815-4
Universal Relation Scheme Assumption		sequential	Universal Relation Scheme Assumption	1816-1
<B>	For	constraint	example	1817-1
example		sequential	an attribute name Number	1817-1
an attribute name Number	for	constraint	serial numbers	1817-1
an attribute name Number	both	conjunctive	serial numbers	1817-1
an attribute name Number	should not be used	action	serial numbers	1817-1
serial numbers	and	conjunctive	employee numbers	1817-1
employee numbers		sequential	rather two distinct attribute names	1817-1
rather two distinct attribute names	and	conjunctive	Employee	1817-1
rather two distinct attribute names	#	sequential	Employee	1817-1
Employee	Serial #	sequential	<B>	1817-1
Employee	should be used	action	<B>	1817-1
Unique Role Assumption		sequential	Unique Role Assumption	1818-1
<B>	to	constraint	there	1818-2
<B>	that	constraint	there	1818-2
<B>	is sometimes weakened	action	there	1818-2
<B>	say	action	there	1818-2
there	may be	action	several relationships	1818-2
several relationships	but	conjunctive	one	1818-2
one	is deemed	attribute	primary	1818-2
<B>	in	constraint	the following example	1818-3
<B>	is illustrated	action	the following example	1818-3
Example		sequential	11.3.1	1819-1
BL		sequential	which	1820-1
which	holds	action	data	1820-1
data	about	constraint	branches	1820-1
branches	and	conjunctive	loans	1820-1
loans		sequential	they	1820-1
they	have given	action	BA	1820-1
BA		sequential	which	1820-1
which	holds	action	data	1820-1
data	about	constraint	branches	1820-1
branches	and	conjunctive	checking accounts	1820-1
checking accounts		sequential	they	1820-1
they	provide	action	CL	1820-1
CL		sequential	which	1820-1
which	holds	action	data	1820-1
data	about	constraint	customers	1820-1
customers	and	conjunctive	loans	1820-1
loans		sequential	they	1820-1
they	have	action	CA	1820-1
CA		sequential	which	1820-1
which	holds	action	data	1820-1
data	about	constraint	customers	1820-1
customers	and	conjunctive	checking accounts	1820-1
checking accounts		sequential	they	1820-1
they	have	action	<B>	1820-1
This design	does not satisfy	action	the unique role assumption	1821-1
the unique role assumption	because of	constraint	mainly the cycle	1821-1
mainly the cycle	in	constraint	the schema	1821-1
<B>	For	constraint	example	1821-2
example	consider	action	the relationship	1821-2
the relationship	between	constraint	branches	1821-2
branches	and	conjunctive	customers	1821-2
<B>	In	constraint	fact	1821-3
fact		sequential	there	1821-3
there	are	attribute	two relationships	1821-3
two relationships	via	constraint	loans	1821-3
loans	via	constraint	accounts	1821-3
loans	and	conjunctive	accounts	1821-3
a request	for	constraint	data	1821-4
data	in	constraint	the relationship	1821-4
the relationship	between	constraint	banks	1821-4
banks	and	conjunctive	customers	1821-4
customers	because	constraint	it	1821-4
customers	is	attribute	Thus somewhat ambiguous	1821-4
it	could mean	action	tuples	1821-4
tuples	from	constraint	the two relationships	1821-4
tuples	of	constraint	the two relationships	1821-4
tuples	stemming	attribute	either	1821-4
the two relationships	from	constraint	the intersection	1821-4
the two relationships	or	conjunctive	the intersection	1821-4
the intersection	or	conjunctive	union	1821-4
union	of	constraint	them	1821-4
union	of	constraint	them	1821-4
One solution	to	constraint	this ambiguity	1822-1
this ambiguity	to	constraint	the cycle	1822-1
this ambiguity	is	attribute	the cycle	1822-1
this ambiguity	break	action	the cycle	1822-1
<B>	For	constraint	example	1822-2
example		sequential	we	1822-2
we	could replace	action	the Customer attribute	1822-2
the Customer attribute	by	constraint	the two attributes	1822-2
the two attributes		sequential	L- C	1822-2
L- C		sequential	ustomer	1822-2
ustomer	and	conjunctive	A	1822-2
A		sequential	C	1822-2
C		sequential	ustomer	1822-2
the user	Now can specify	action	the desired relationship	1822-3
the desired relationship	by	constraint	the appropriate attribute	1822-3
the desired relationship	using	action	the appropriate attribute	1822-3
The Weak Universal Relation Assumption	that	constraint	schema	1823-1
The Weak Universal Relation Assumption	Suppose	action	schema	1823-1
schema		sequential	U	1823-1
U	has	action	decomposition	1823-1
decomposition		sequential	R	1823-1
R		sequential	Ŵ	1823-1
Ŵ	with	constraint	R	1823-1
R	=	sequential	R1	1823-1
R	{	sequential	R1	1823-1
<B>	.	sequential	<B>	1823-2
<B>	.	sequential	<B>	1823-3
Rn }		sequential	Rn }	1823-4
<B>	When studying	action	decomposition	1823-5
decomposition		sequential	we	1823-5
we	on	constraint	primarily instances	1823-5
we	focused	action	primarily instances	1823-5
primarily instances		sequential	I	1823-5
I	of	constraint	R	1823-5
R		sequential	that	1823-5
that	were	attribute	the image	1823-5
the image	of	constraint	some instance	1823-5
some instance		sequential	I	1823-5
I	of	constraint	U	1823-5
U	under	constraint	decomposition mapping	1823-5
decomposition mapping		sequential	the πR	1823-5
<B>	In	constraint	such instances	1823-6
such instances		sequential	I	1823-6
I	are	attribute	globally consistent	1823-6
<B>	from	constraint	Chapter 6	1823-7
<B>	Recall	action	Chapter 6	1823-7
Chapter 6		sequential	that instance	1823-7
that instance		sequential	I	1823-7
I	if	constraint	each j ∈	1823-7
I	for	constraint	each j ∈	1823-7
I	is	attribute	globally consistent	1823-7
each j ∈		sequential	1	1823-7
1		sequential	n	1823-7
n		sequential	πR	1823-7
πR		sequential	⊲⊳	1823-7
⊲⊳		sequential	I	1823-7
I	=	sequential	I	1823-7
I		sequential	R j j	1823-7
R j j		sequential	no tuple	1823-7
no tuple	of	constraint	I	1823-7
I		sequential	Rj	1823-7
Rj	to	constraint	the full join	1823-7
Rj	is dangling	action	the full join	1823-7
<B>	in	constraint	many practical situations	1823-8
many practical situations		sequential	it	1823-8
it	to	constraint	the decomposed schema R	1823-8
it	be	attribute	However might useful	1823-8
it	use	action	the decomposed schema R	1823-8
the decomposed schema R	to	constraint	instances	1823-8
the decomposed schema R	store	action	instances	1823-8
instances		sequential	I	1823-8
I		sequential	that	1823-8
that	are	attribute	not globally consistent	1823-8
Example		sequential	11.3.2	1824-1
<B>	that	constraint	some movie	1824-2
<B>	for	constraint	some movie	1824-2
<B>	Suppose	action	some movie	1824-2
some movie		sequential	the director	1824-2
the director	but	conjunctive	no actors	1824-2
the director	is known	action	no actors	1824-2
no actors	are known	action	<B>	1824-2
<B>	As	constraint	this information	1824-3
<B>	mentioned previously	action	this information	1824-3
this information	in	constraint	the decomposed database	1824-3
this information	is easily stored	action	the decomposed database	1824-3
the decomposed database	in	constraint	not the original	1824-3
the decomposed database	but	conjunctive	not the original	1824-3
The impossibility	of	constraint	this information	1824-4
The impossibility	representing	action	this information	1824-4
this information	in	constraint	the original schema	1824-4
the original schema	was	attribute	one	1824-4
one	of	constraint	the anomalies	1824-4
the anomalies		sequential	that	1824-4
that	motivated	action	the decomposition	1824-4
the decomposition	in	constraint	the first place	1824-4
<B>	that	constraint	fd schema	1825-1
<B>	Suppose	action	fd schema	1825-1
fd schema		sequential	U	1825-1
U	has	action	decomposition	1825-1
decomposition		sequential	R	1825-1
R		sequential	Ŵ	1825-1
Ŵ	=	sequential	R1	1825-1
R1		sequential	Ŵ1	1825-1
<B>	.	sequential	<B>	1825-2
<B>	.	sequential	<B>	1825-3
Rn		sequential	Ŵn	1825-4
Ŵn		sequential	}	1825-4
<B>	that	constraint	I	1826-1
<B>	Suppose also	action	I	1826-1
I	is	attribute	an instance	1826-1
an instance	of	constraint	R such	1826-1
R such	that	constraint	I	1826-1
I		sequential	Rj	1826-1
Rj		sequential	Ŵj	1826-1
Ŵj	for	constraint	each j	1826-1
each j	but	conjunctive	I	1826-1
I	is	attribute	Design	1826-1
Design	and	conjunctive	Dependencies	1826-1
Dependencies		sequential	B	1826-1
B		sequential	2 B B b b b b	1826-1
2 B B b b b b		sequential	BC B C BC B C BC	1826-1
BC B C BC B C BC		sequential	B C b c b c b c C D	1826-1
B C b c b c b c C D		sequential	C D c	1826-1
C D c		sequential	C D d	1826-1
C D d		sequential	c	1826-1
c		sequential	d	1826-1
d		sequential	c	1826-1
c		sequential	c	1826-1
c		sequential	d′ c d′ I1 I2	1826-1
d′ c d′ I1 I2		sequential	I3 Figure	1826-1
I3 Figure		sequential	11.4	1826-1
11.4		sequential	Instances	1826-1
Instances	illustrating	action	weak URA	1826-1
weak URA		sequential	<B>	1826-1
I	Should be considered	attribute	valid	1826-2
a instance	of	constraint	schema	1826-2
schema		sequential	R	1826-2
R		sequential	Ŵ	1826-2
<B>	given	action	a schema	1826-3
a schema		sequential	U	1826-3
U		sequential	decomposition	1826-3
decomposition		sequential	a R	1826-3
a R	of	constraint	U	1826-3
U	and	conjunctive	a instance I	1826-3
a instance I	over	constraint	R	1826-3
R		sequential	we	1826-3
we	More generally how should define	action	the notion	1826-3
the notion	of	constraint	<B>	1826-3
The weak universal relation assumption		sequential	weak URA	1827-1
weak URA	provides	action	one approach	1827-1
one approach	for	constraint	this question	1827-1
one approach	answering	action	this question	1827-1
<B>	Under	constraint	the weak URA	1827-2
the weak URA		sequential	we	1827-2
we	that	constraint	I	1827-2
we	say	action	I	1827-2
I	if	constraint	there	1827-2
I	satisfies	action	there	1827-2
there	is	attribute	some instance	1827-2
some instance		sequential	J	1827-2
J		sequential	∈	1827-2
∈	sat	action	U	1827-2
U		sequential	I	1827-2
I		sequential	Rj	1827-2
Rj		sequential	such that ⊆	1827-2
such that ⊆		sequential	πR ∈	1827-2
πR ∈		sequential	J	1827-2
J	for	constraint	each j	1827-2
each j		sequential	1	1827-2
1		sequential	n	1827-2
<B>	In	constraint	this case	1827-3
this case		sequential	J	1827-3
J	is j called	action	a weak instance	1827-3
a weak instance	for	constraint	I	1827-3
Example Let		sequential	11.3.3	1828-1
11.3.3		sequential	U	1828-1
U	=	sequential	ABCD	1828-1
U	{	sequential	ABCD	1828-1
ABCD		sequential	}	1828-1
}	=	sequential	A	1828-1
}	{	sequential	A	1828-1
A	→	sequential	B	1828-1
B		sequential	BC	1828-1
BC	→	sequential	D }	1828-1
D }	and	conjunctive	R	1828-1
R	=	sequential	AB BC ACD	1828-1
R	{	sequential	AB BC ACD	1828-1
AB BC ACD		sequential	}	1828-1
<B>	Consider	action	the three instances	1829-1
the three instances	of	constraint	R	1829-1
R	in	constraint	Fig	1829-1
R	shown	action	Fig	1829-1
11.4		sequential	11.4	1829-2
The instance		sequential	I1	1829-3
I1	under	constraint	the weak URA	1829-3
I1	satisfies	action	the weak URA	1829-3
the weak URA	because	constraint	J1	1829-3
J1	=	sequential	b	1829-3
b		sequential	c	1829-3
c		sequential	d	1829-3
d	is	attribute	a weak instance	1829-3
<B>	On	constraint	the other hand	1830-1
the other hand		sequential	I2	1830-1
I2		sequential	which	1830-1
which	contains	action	I1	1830-1
I1	under	constraint	the weak URA	1830-1
I1	does not satisfy	action	the weak URA	1830-1
<B>	To	constraint	J2	1830-2
<B>	that	constraint	J2	1830-2
<B>	see	attribute	this	1830-2
<B>	suppose	action	J2	1830-2
J2	is	attribute	a weak instance	1830-2
a weak instance	for	constraint	I2	1830-2
J2	Then must contain	attribute	not necessarily distinct	1830-3
the following tuples		sequential	t1	1830-3
t1	=	sequential	a	1830-3
a		sequential	b	1830-3
b		sequential	c1	1830-3
c1		sequential	d1 t2	1830-3
d1 t2	=	sequential	a′	1830-3
a′		sequential	b	1830-3
b		sequential	c2	1830-3
c2		sequential	d2 t3	1830-3
d2 t3	=	sequential	a3	1830-3
a3		sequential	b	1830-3
b		sequential	c	1830-3
c		sequential	d3 t4	1830-3
d3 t4	=	sequential	a	1830-3
a		sequential	b4	1830-3
b4		sequential	c	1830-3
c		sequential	d t5	1830-3
d t5	=	sequential	a′	1830-3
a′		sequential	b5	1830-3
b5		sequential	c	1830-3
c		sequential	d′	1830-3
d′		sequential	the subscripted constants	1830-3
the subscripted constants	be	attribute	where may new	1830-3
<B>	Because	constraint	J2	1830-4
J2	→	sequential	B	1830-4
B	by	constraint	the pairs	1830-4
B	considering	action	the pairs	1830-4
the pairs		sequential	t1	1830-4
t1		sequential	t4	1830-4
t4	and	conjunctive	t2	1830-4
t2		sequential	t5	1830-4
t5		sequential	we	1830-4
we	that	constraint	b4	1830-4
we	see	action	b4	1830-4
b4	=	sequential	b5	1830-4
b5	=	sequential	b	1830-4
<B>	because	constraint	J2	1830-5
J2	|= BC	sequential	D	1830-5
J2	→	sequential	D	1830-5
D	by	constraint	the pair	1830-5
D	and	conjunctive	the pair	1830-5
D	considering	action	the pair	1830-5
the pair		sequential	t4	1830-5
t4		sequential	t5	1830-5
t5		sequential	we	1830-5
we	Next have	action	that d	1830-5
that d		sequential	d′	1830-5
d′		sequential	a contradiction	1830-5
I3	under	constraint	the weak URA	1831-1
I3	Finally does satisfy	action	the weak URA	1831-1
<B>	yields	attribute	the	1832-1
<B>	following	action	Exercise 11.27	1832-1
<B>	see	action	Exercise 11.27	1832-1
Exercise 11.27		sequential	Theorem 11.3.4	1832-1
<B>	whether	constraint	I	1832-2
<B>	Testing	action	I	1832-2
I	over	constraint	R	1832-2
R	under	constraint	the weak URA	1832-2
R	satisfies	action	the weak URA	1832-2
the weak URA	in	constraint	polynomial time	1832-2
the weak URA	can be performed	action	polynomial time	1832-2
the chasing technique	to	constraint	arbitrary egd	1833-1
the chasing technique	Of course can be extended	action	arbitrary egd	1833-1
arbitrary egd		sequential	s	1833-1
s	although	constraint	the complexity	1833-1
the complexity	to	constraint	exptime	1833-1
the complexity	jumps	action	exptime	1833-1
exptime		sequential	<B>	1833-1
What	about	constraint	full tgd	1834-1
full tgd		sequential	<B>	1834-1
<B>	that	constraint	full tgd	1834-2
<B>	Recall	action	full tgd	1834-2
full tgd		sequential	s	1834-2
s	by	constraint	new tuples	1834-2
s	be	attribute	can always satisfied	1834-2
s	adding	action	new tuples	1834-2
new tuples	to	constraint	an instance	1834-2
<B>	be	attribute	a set	1834-3
<B>	Let	action	a set	1834-3
a set	of	constraint	full dependencies	1834-3
It	to	constraint	I	1834-4
It	that	constraint	I	1834-4
It	is	attribute	easy	1834-4
It	see	action	I	1834-4
I	under	constraint	the weak URA iff	1834-4
I	satisfies	action	the weak URA iff	1834-4
the weak URA iff		sequential	I	1834-4
I	satisfies	action	∩	1834-4
∩		sequential	σ	1834-4
σ		sequential	σ	1834-4
σ	is	attribute	an egd	1834-4
an egd		sequential	}	1834-4
}	under	constraint	the weak URA	1834-4
<B>	under	constraint	the Weak URA	1835-1
<B>	Querying	action	the Weak URA	1835-1
the Weak URA	Let	action	U	1835-1
U	be	attribute	a schema	1835-1
a schema	is	attribute	where a set	1835-1
where a set	of	constraint	full dependencies	1835-1
full dependencies	and	conjunctive	R	1835-1
full dependencies	let	action	R	1835-1
R	be	attribute	a decomposition	1835-1
a decomposition	of	constraint	U	1835-1
<B>	Let	action	us	1835-2
us	assume	action	the weak URA	1835-2
the weak URA	and	conjunctive	that database instance	1835-2
the weak URA	suppose	action	that database instance	1835-2
that database instance		sequential	I	1835-2
I	over	constraint	R	1835-2
R	satisfies	action	<B>	1835-2
queries	against	constraint	I	1836-1
I	How should be answered	action	<B>	1836-1
One approach	to	constraint	the query	1836-2
One approach	is	attribute	the query	1836-2
One approach	consider	action	the query	1836-2
the query	against	constraint	all weak instances	1836-2
all weak instances	for	constraint	I	1836-2
I	and	conjunctive	the intersection	1836-2
I	take	action	the intersection	1836-2
the intersection	of	constraint	the answers	1836-2
<B>	is	attribute	q	1836-3
q		sequential	I	1836-3
I	=	sequential	∩	1836-3
∩		sequential	q	1836-3
q		sequential	I	1836-3
I		sequential	I	1836-3
I	is	attribute	a weak instance	1836-3
a weak instance	of	constraint	I	1836-3
I	}	action	<B>	1836-3
We	develop now	action	a constructive method	1837-1
a constructive method	for	constraint	computing q	1837-1
computing q		sequential	<B>	1837-1
<B>	Given	action	instance	1838-1
instance		sequential	I	1838-1
I	of	constraint	R	1838-1
R		sequential	the representative instance	1838-1
the representative instance	of	constraint	I	1838-1
I	as	constraint	<B>	1838-1
I	is defined	action	<B>	1838-1
I	follows	action	<B>	1838-1
<B>	Set	action	I	1838-2
I		sequential	′	1838-2
′	=	sequential	∪	1838-2
∪		sequential	I	1838-2
I	′	action	j	1838-2
j		sequential	∈	1838-2
∈		sequential	1	1838-2
1	n	conjunctive	<B>	1838-2
<B>	Now apply	action	the chase j	1838-3
the chase j	to	constraint	the representative instance	1838-3
the chase j	using	action	the representative instance	1838-3
the chase j	obtain	action	the representative instance	1838-3
the representative instance		sequential	rep	1838-3
rep		sequential	I	1838-3
I	or	conjunctive	the empty instance	1838-3
the empty instance	if	constraint	two distinct constants	1838-3
two distinct constants	to	constraint	<B>	1838-3
two distinct constants	are be identified	action	<B>	1838-3
<B>	that	constraint	some elements	1838-4
<B>	Note	action	some elements	1838-4
some elements	of	constraint	rep	1838-4
rep		sequential	I	1838-4
I	may have	action	variables	1838-4
variables	in	constraint	them	1838-4
variables	occurring	action	them	1838-4
<B>	For	constraint	X ⊆	1839-1
X ⊆		sequential	U	1839-1
U	let	action	π ↓X	1839-1
π ↓X		sequential	rep	1839-1
rep		sequential	I	1839-1
I	denote	action	the set	1839-1
the set	of	constraint	tuples	1839-1
tuples	with	constraint	no variables present	1839-1
no variables present	in	constraint	πX	1839-1
πX		sequential	rep	1839-1
rep		sequential	I	1839-1
<B>	can now be verified	action	Exercise 11.28	1839-2
<B>	see	action	Exercise 11.28	1839-2
Proposition		sequential	11.3.5	1840-1
11.3.5	Let	action	U	1840-1
U		sequential	R	1840-1
R	and	conjunctive	I	1840-1
I	as	constraint	X ⊆ U	1840-1
I	and	conjunctive	X ⊆ U	1840-1
I	be	attribute	X ⊆ U	1840-1
I	let	action	X ⊆ U	1840-1
<B>		sequential	<B>	1840-2
Design	and	conjunctive	Dependencies	1841-1
<B>	if	constraint	a set	1841-2
<B>	is	attribute	a set	1841-2
a set	of	constraint	fd s	1841-2
fd s	evaluating	action	q	1841-2
q	Furthermore will take	action	time	1841-2
time	at	constraint	most polynomial	1841-2
most polynomial	in	constraint	the size	1841-2
the size	of	constraint	the input instance	1841-2
This approach	to	constraint	the case	1841-3
This approach	can be generalized	action	the case	1841-3
the case	is	attribute	where a set	1841-3
where a set	of	constraint	full dependencies	1841-3
full dependencies	but	conjunctive	the projection	1841-3
full dependencies	computing	action	the projection	1841-3
the projection	is	attribute	exptime complete	1841-3
Bibliographic Notes		sequential	Bibliographic Notes	1842-1
Extensive treatments	of	constraint	the topic	1842-2
the topic	in	constraint	Dat86	1842-2
the topic	are also found	action	Dat86	1842-2
Dat86		sequential	Fv89	1842-2
Fv89		sequential	Ull88	1842-2
Ull88		sequential	Vos91	1842-2
References		sequential	Ken78	1843-1
Ken78		sequential	Ken79	1843-1
Ken79		sequential	Ken89	1843-1
Ken89	illustrate	action	the many difficulties	1843-1
the many difficulties		sequential	that	1843-1
that	in	constraint	schema design	1843-1
that	arise	action	schema design	1843-1
schema design	with	constraint	primarily a host	1843-1
primarily a host	of	constraint	intriguing examples	1843-1
intriguing examples		sequential	that	1843-1
that	show	attribute	how skilled	1843-1
the human mind	at	constraint	diverse information	1843-1
the human mind	is	attribute	diverse information	1843-1
the human mind	organizing	action	diverse information	1843-1
diverse information	and	conjunctive	how woefully limiting data models	1843-1
how woefully limiting data models	are	attribute	<B>	1843-1
Surveys	of	constraint	semantic data models	1844-1
semantic data models	include	action	Bor85	1844-1
Bor85		sequential	HK87	1844-1
HK87		sequential	PM88	1844-1
PM88	and	conjunctive	the book	1844-1
the book		sequential	TL82	1844-1
Reference		sequential	Che76	1845-1
Che76	describes	action	a translation	1845-1
a translation	of	constraint	the ER model	1845-1
the ER model	into	constraint	the relational model	1845-1
the relational model	so that	constraint	the resulting schema	1845-1
the resulting schema	in	constraint	BCNF	1845-1
the resulting schema	is	attribute	BCNF	1845-1
<B>	From	constraint	a practical perspective	1845-2
a practical perspective	as	constraint	the method	1845-2
a practical perspective	has become	action	the method	1845-2
a practical perspective	widely accepted	action	the method	1845-2
the method	of	constraint	choice	1845-2
choice	for	constraint	relational schemas	1845-2
choice	designing	action	relational schemas	1845-2
relational schemas		sequential	TYF86	1845-2
TYF86	provides	action	a subsequent perspective	1845-2
a subsequent perspective	on	constraint	this approach	1845-2
There	has also been	action	considerable work	1845-3
considerable work	on	constraint	the properties	1845-3
considerable work	understanding	action	the properties	1845-3
the properties	of	constraint	relational schemas	1845-3
relational schemas	from	constraint	ER schemas	1845-3
relational schemas	resulting	action	ER schemas	1845-3
ER schemas	and	conjunctive	relational schemas	1845-3
ER schemas	mapping	action	relational schemas	1845-3
relational schemas	into	constraint	ER ones	1845-3
Reference		sequential	MR92	1845-4
MR92	in	constraint	depth	1845-4
MR92	provides	action	depth	1845-4
depth		sequential	an discussion	1845-4
an discussion	of	constraint	this area	1845-4
Reference		sequential	LV87	1846-1
LV87	presents	action	a translation	1846-1
a translation	from	constraint	the relational model	1846-1
a translation	to	constraint	the relational model	1846-1
the relational model	and	conjunctive	the constraints	1846-1
the relational model	studies	action	the constraints	1846-1
the constraints	for	constraint	the relational schema	1846-1
the constraints	implied	action	the relational schema	1846-1
the relational schema	including	action	cardinality constraints	1846-1
The logical implication	of	constraint	constraints	1846-2
constraints	within	constraint	a semantic model schema	1846-2
a semantic model schema	in	constraint	CL94	1846-2
a semantic model schema	is studied	action	CL94	1846-2
References		sequential	Lie80	1846-3
Lie80		sequential	Lie82	1846-3
Lie82	study	action	the relationship	1846-3
the relationship	of	constraint	schemas	1846-3
schemas	from	constraint	network	1846-3
network	and	conjunctive	the models	1846-3
Bibliographic		sequential	Bibliographic	1847-1
Formal notions	of	constraint	relative information capacity	1847-2
relative information capacity	in	constraint	the context	1847-2
relative information capacity	have also been applied	action	the context	1847-2
the context	of	constraint	schema integration	1847-2
schema integration	and	conjunctive	translation	1847-2
The area	of	constraint	normal forms	1848-1
normal forms	and	conjunctive	relational database design	1848-1
relational database design	in	constraint	the 1970s	1848-1
relational database design	was studied intensively	action	the 1970s	1848-1
the 1970s	and	conjunctive	early 1980s	1848-1
Much more complete coverage	of	constraint	this topic	1848-2
this topic	than	constraint	Dat86	1848-2
this topic	in	constraint	Dat86	1848-2
this topic	presented here	action	Dat86	1848-2
this topic	may be found	action	Dat86	1848-2
Dat86		sequential	Mai83	1848-2
Mai83		sequential	Ull88	1848-2
Ull88		sequential	Vos91	1848-2
We	of	constraint	the most important papers	1848-3
We	mention	attribute	some	1848-3
the most important papers	in	constraint	this area	1848-3
normal form		sequential	Cod70	1848-4
Cod70	to	constraint	the relational model	1848-4
Cod70	is	attribute	First actually fundamental	1848-4
<B>	In	constraint	Chapter 20	1848-5
Chapter 20		sequential	this restriction	1848-5
this restriction	to	constraint	relations	1848-5
this restriction	be	attribute	shall relaxed	1848-5
this restriction	permit	action	relations	1848-5
relations	of	constraint	whose columns themselves	1848-5
whose columns themselves	hold	action	relations	1848-5
relations		sequential	which	1848-5
which	in	constraint	again may not first normal form	1848-5
which	be	attribute	again may not first normal form	1848-5
References		sequential	Cod71	1848-6
Cod71		sequential	Cod72a	1848-6
Cod72a	raised	action	the issue	1848-6
the issue	of	constraint	update anomalies	1848-6
update anomalies	and	conjunctive	the search	1848-6
update anomalies	initiated	action	the search	1848-6
the search	for	constraint	normal forms	1848-6
normal forms		sequential	that	1848-6
that	prevent	action	them	1848-6
them	by	constraint	normal forms	1848-6
them	and	conjunctive	normal forms	1848-6
them	introducing	attribute	second	1848-6
The definition	of	constraint	3NF	1848-7
3NF	from	constraint	Zan82	1848-7
3NF	is	attribute	Zan82	1848-7
3NF	used here	action	Zan82	1848-7
Second normal form	than	constraint	third normal form	1848-8
Second normal form	is	attribute	less restrictive	1848-8
Boyce		sequential	Codd normal form	1848-9
Codd normal form		sequential	BCNF	1848-9
BCNF	in	constraint	Cod74	1848-9
BCNF	was introduced	action	Cod74	1848-9
Cod74	to	constraint	a normal form	1848-9
Cod74	provide	action	a normal form	1848-9
a normal form	than	constraint	3NF	1848-9
Another improvement	of	constraint	3NF	1848-10
3NF	in	constraint	LTK81	1848-10
3NF	is proposed	action	LTK81	1848-10
Fourth normal form	in	constraint	Fag77 b	1848-11
Fourth normal form	was introduced	action	Fag77 b	1848-11
Fag77 b		sequential	Example 11.2.15	1848-11
Example 11.2.15	from	constraint	that reference	1848-11
Example 11.2.15	is inspired	action	that reference	1848-11
Even richer normal forms	include	action	project	1848-12
project	join	action	normal form	1848-12
normal form		sequential	PJ/NF	1848-12
PJ/NF		sequential	Fag79	1848-12
Fag79	and	conjunctive	domain	1848-12
domain		sequential	normal form	1848-12
normal form		sequential	Fag81	1848-12
<B>	In	constraint	addition	1849-1
addition	to	constraint	normal form	1849-1
addition	and	conjunctive	normal form	1849-1
addition	introducing	attribute	second	1849-1
normal form		sequential	Cod72a	1849-1
Cod72a	initiated	action	the search	1849-1
the search	for	constraint	normalization algorithms	1849-1
normalization algorithms	by	constraint	the first decomposition algorithms	1849-1
normalization algorithms	proposing	action	the first decomposition algorithms	1849-1
<B>	spawned	action	other research	1849-2
other research	on	constraint	decomposition	1849-2
decomposition		sequential	DC72	1849-2
DC72		sequential	RD75	1849-2
RD75		sequential	PJ81	1849-2
PJ81	and	conjunctive	synthesis	1849-2
synthesis		sequential	BST75	1849-2
BST75		sequential	Ber76	1849-2
Ber76		sequential	b	1849-2
b		sequential	WW75	1849-2
The fact	that	constraint	these two criteria	1849-3
these two criteria	in	constraint	Ris77	1849-3
these two criteria	are	attribute	not equivalent	1849-3
these two criteria	was stressed	action	Ris77	1849-3
Ris77		sequential	it	1849-3
it	that	constraint	<B>	1849-3
it	where is proposed	attribute	both	1849-3
it	be attempted	action	<B>	1849-3
Early surveys	on	constraint	these approaches	1849-4
these approaches	to	constraint	relational design	1849-4
relational design	include	action	BBG78	1849-4
BBG78		sequential	Fag77a	1849-4
Fag77a		sequential	Ris78	1849-4
Algorithms	for	constraint	synthesis	1849-5
synthesis	into	constraint	3NF	1849-5
3NF	include	action	<B>	1849-5
The more formal study	of	constraint	decompositions	1850-1
decompositions	and	conjunctive	their properties	1850-1
their properties	in	constraint	Ris77	1850-1
their properties	was initiated	action	Ris77	1850-1
Ris77		sequential	which	1850-1
which	considered	action	decompositions	1850-1
decompositions	into	constraint	two element	1850-1
two element		sequential	sets	1850-1
sets	and	conjunctive	the notion	1850-1
sets	proposed	action	the notion	1850-1
the notion	of	constraint	independent components	1850-1
independent components	and	conjunctive	AC78	1850-1
AC78		sequential	which	1850-1
which	studied	action	decompositions	1850-1
decompositions	with	constraint	lossless joins	1850-1
lossless joins	and	conjunctive	dependency preservation	1850-1
<B>	to	constraint	arbitrary decompositions	1850-2
<B>	was extended independently	action	arbitrary decompositions	1850-2
arbitrary decompositions	over	constraint	fd	1850-2
fd	by	constraint	BR80	1850-2
BR80	and	conjunctive	MMSU80	1850-2
Lossless join	in	constraint	Var82	1850-3
Lossless join	was further investigated	action	Var82	1850-3
Var82		sequential	b	1850-3
The notion	that	constraint	not all integrity constraints	1851-1
not all integrity constraints	in	constraint	a schema	1851-1
not all integrity constraints	specified	action	a schema	1851-1
a schema	for	constraint	the design process	1851-1
a schema	should be considered	action	the design process	1851-1
the design process	in	constraint	various works	1851-1
the design process	was	attribute	implicit	1851-1
various works	on	constraint	semantic data modeling	1851-1
semantic data modeling		sequential	<B>	1851-1
Design	and	conjunctive	Dependencies	1852-1
The URA	in	constraint	the early work	1852-2
The URA	of	constraint	the early work	1852-2
The URA	was	attribute	implicit	1852-2
the early work	on	constraint	normal forms	1852-2
normal forms	and	conjunctive	decompositions	1852-2
decompositions	in	constraint	FMU82	1852-2
decompositions	was articulated more formally	action	FMU82	1852-2
FMU82		sequential	MUV84	1852-2
The weak URA	in	constraint	connection	1852-3
The weak URA	was studied	action	connection	1852-3
connection	with	constraint	query processing	1852-3
query processing	in	constraint	Sag81	1852-3
Sag81		sequential	Sag83	1852-3
Sag83	in	constraint	connection	1852-3
Sag83	and	conjunctive	connection	1852-3
connection	with	constraint	fd satisfaction	1852-3
fd satisfaction	in	constraint	Hon82	1852-3
Proposition		sequential	11.3.5	1852-4
11.3.5	to	constraint	MUV84	1852-4
11.3.5	is	attribute	a due	1852-4
MUV84	and	conjunctive	part	1852-4
part	due to	constraint	b Hon82	1852-4
part	is	attribute	b Hon82	1852-4
b Hon82		sequential	the extension	1852-4
the extension	to	constraint	full dependencies	1852-4
full dependencies	to	constraint	GMV86	1852-4
full dependencies	is	attribute	due	1852-4
Reference		sequential	Sci86	1852-5
Sci86	presents	action	an interesting comparison	1852-5
an interesting comparison	of	constraint	the relational model	1852-5
the relational model	with	constraint	inclusion dependencies	1852-5
inclusion dependencies	to	constraint	a variant	1852-5
a variant	of	constraint	the universal relation model	1852-5
the universal relation model	and	conjunctive	an equivalence	1852-5
the universal relation model	shows	action	an equivalence	1852-5
an equivalence		sequential	certain natural restrictions	1852-5
certain natural restrictions	when are imposed	action	<B>	1852-5
Exercises Exercise		sequential	11.1	1853-1
Exercise		sequential	11.2	1854-1
What dependencies	are	attribute	satisfied	1855-1
Exercise		sequential	11.3	1856-1
Exercise		sequential	11.5	1857-1
Exercises Exercise 11.6		sequential	Exercises Exercise 11.6	1858-1
<B>	Exercise	action	11.7 Let	1859-1
11.7 Let		sequential	U	1859-1
U	be	attribute	a schema	1859-1
a schema	where contains	action	possibly fd	1859-1
possibly fd		sequential	s	1859-1
s		sequential	mvd	1859-1
mvd		sequential	s	1859-1
s	and	conjunctive	jd	1859-1
jd		sequential	<B>	1859-1
<B>	that	constraint	U	1859-2
<B>	Show	action	U	1859-2
U	in	constraint	BCNF	1859-2
U	is	attribute	BCNF	1859-2
BCNF	a implies	action	U	1859-2
U	in	constraint	3NF	1859-2
U	is	attribute	3NF	1859-2
3NF		sequential	U	1859-2
U	in	constraint	4NF	1859-2
U	is	attribute	4NF	1859-2
4NF	b implies	action	U	1859-2
U	in	constraint	BCNF	1859-2
U	is	attribute	BCNF	1859-2
BCNF		sequential	c	1859-2
c		sequential	U	1859-2
U	in	constraint	PJ	1859-2
U	is	attribute	PJ	1859-2
PJ	/	sequential	NF	1859-2
NF	implies	action	U	1859-2
U	in	constraint	4NF	1859-2
U	is	attribute	4NF	1859-2
Exercise		sequential	11.8	1860-1
<B>	Exercise	action	11.9	1861-1
11.9	Recall	action	the schema	1861-1
the schema		sequential	Movies	1861-1
Movies		sequential	TDA	1861-1
TDA		sequential	T }	1861-1
T }	→	sequential	D	1861-1
<B>	Consider	action	the decomposition	1861-2
the decomposition		sequential	R1	1861-2
R1	=	sequential	<B>	1861-2
R1 Exercise		sequential	11.10 Verify	1862-1
11.10 Verify		sequential	Theorem 11.2.8	1862-1
Hint		sequential	Hint	1862-2
Exercise		sequential	11.11	1863-1
Exercise		sequential	11.12	1864-1
<B>	Exercise	action	11.14	1865-1
11.14	Recall	action	the schema Showings	1865-1
the schema Showings		sequential	Th	1865-1
Th		sequential	eater	1865-1
eater		sequential	Sc	1865-1
Sc		sequential	reen	1865-1
reen		sequential	Ti	1865-1
Ti		sequential	tle	1865-1
tle		sequential	Sn	1865-1
Sn		sequential	ack	1865-1
ack	of	constraint	Section	1865-1
Section		sequential	8.1	1865-1
8.1		sequential	which	1865-1
which	satisfies	action	the fd Th	1865-1
the fd Th		sequential	Sc	1865-1
Sc	→	sequential	Ti	1865-1
Ti	and	conjunctive	the mvd Th	1865-1
the mvd Th		sequential	decompositions	1865-1
decompositions		sequential	R1	1865-1
R1	=	sequential	Th	1865-1
Th		sequential	Sc	1865-1
Sc		sequential	Ti }	1865-1
Ti }		sequential	Th	1865-1
Th		sequential	Sn	1865-1
Sn		sequential	}	1865-1
}		sequential	}	1865-1
}		sequential	R2	1865-1
R2	=	sequential	Th	1865-1
R2	{	sequential	Th	1865-1
Th		sequential	Sc	1865-1
Sc		sequential	Ti }	1865-1
Ti }		sequential	Th	1865-1
Th		sequential	Sc	1865-1
Sc		sequential	Sn	1865-1
Sn		sequential	}	1865-1
Exercise		sequential	11.15	1866-1
Design	and	conjunctive	Dependencies	1867-1
Dependencies		sequential	Exercise 11.16	1867-1
Exercise Prove Theorem 11.2.14		sequential	11.17	1868-1
Exercise		sequential	11.18	1869-1
Exercise		sequential	11.19	1870-1
<B>	Consider	action	the schema R	1871-1
the schema R		sequential	ABCD	1871-1
<B>	Given	action	t ∈	1871-2
t ∈		sequential	I	1871-2
I	∈	action	inst	1871-2
inst		sequential	R	1871-2
R		sequential	t	1871-2
t		sequential	A	1871-2
A	is	attribute	a key element	1871-2
a key element	for	constraint	AB	1871-2
AB	in	constraint	I	1871-2
I	if	constraint	there	1871-2
there	is	attribute	no	1871-2
∈		sequential	I	1871-2
I	with	constraint	t	1871-2
t		sequential	A	1871-2
A	=	sequential	A	1871-2
A	and	conjunctive	t	1871-2
t		sequential	B	1871-2
B	=	sequential	B	1871-2
The notion	of	constraint	t	1871-3
t		sequential	C	1871-3
C	being	action	a key element	1871-3
a key element	for	constraint	CD	1871-3
CD	is defined analogously	action	<B>	1871-3
<B>	of	constraint	the constraints	1871-4
<B>	Let	action	the constraints	1871-4
<B>	consist	action	the constraints	1871-4
the constraints	∈	action	I	1871-4
I	that	constraint	t	1871-4
t		sequential	A	1871-4
A	and	conjunctive	t	1871-4
t		sequential	C	1871-4
C	are	attribute	key elements	1871-4
<B>		sequential	AB	1872-1
AB	and	conjunctive	u	1872-1
u		sequential	CD	1872-1
CD	=	sequential	t	1872-1
t		sequential	CD	1872-1
<B>	Let	action	R	1873-1
R	=	sequential	R1	1873-1
R1		sequential	AB	1873-1
AB		sequential	R2	1873-1
R2		sequential	CD	1873-1
CD	be	attribute	a decomposition	1873-1
a decomposition	of	constraint	R	1873-1
<B>	and	conjunctive	the following exercise	1874-1
the following exercise	provide	action	one kind	1874-1
one kind	of	constraint	characterization	1874-1
characterization	of	constraint	the relative information capacity	1874-1
the relative information capacity	of	constraint	decompositions	1874-1
decompositions	of	constraint	relation schemas	1874-1
<B>	Let	action	U	1874-2
U	be	attribute	a set	1874-2
a set	of	constraint	attributes	1874-2
attributes	let	action	α	1874-2
α		sequential	X1	1874-2
<B>	.	sequential	<B>	1874-3
<B>	.	sequential	<B>	1874-4
Xn		sequential	}	1874-5
}	be	attribute	a nonempty family	1874-5
a nonempty family	of	constraint	subsets	1874-5
subsets	of	constraint	U	1874-5
U	and	conjunctive	X	1874-5
U	let	action	X	1874-5
X		sequential	∪n X i=1 i	1874-5
project	join	action	The mapping	1874-6
The mapping	by	constraint	α	1874-6
The mapping	determined	action	α	1874-6
α		sequential	denoted PJ α	1874-6
denoted PJ α	is	attribute	a mapping	1874-6
a mapping	from	constraint	instances	1874-6
instances	over	constraint	U	1874-6
U	to	constraint	instances	1874-6
instances	over	constraint	X i=1	1874-6
instances	∪n	constraint	X i=1	1874-6
X i=1		sequential	i	1874-6
i	by	constraint	PJ α	1874-6
i	defined	action	PJ α	1874-6
PJ α		sequential	I	1874-6
I	=	sequential	project	1874-6
project	⊲⊳n i=1 Xi i=1 join	action	full mapping	1874-6
<B>	for	constraint	instances	1875-1
<B>	Prove	attribute	the	1875-1
<B>	following	action	instances	1875-1
instances		sequential	I	1875-1
I	and	conjunctive	J	1875-1
J	over	constraint	U	1875-1
U		sequential	Exercises	1875-1
<B>	of	constraint	subsets	1876-1
subsets	of	constraint	U	1876-1
U	that	constraint	<B>	1876-1
U	are	attribute	equivalent	1876-1
Exercise		sequential	11.23	1877-1
<B>	Let	action	schema	1877-2
schema		sequential	R	1877-2
R	=	sequential	ABC	1877-2
ABC	{	sequential	A	1877-2
A	→	sequential	B }	1877-2
B }	and	conjunctive	the decomposition	1877-2
the decomposition		sequential	R	1877-2
R	=	sequential	AB	1877-2
AB		sequential	A	1877-2
A	→	sequential	B }	1877-2
B }		sequential	AC	1877-2
AC		sequential	∅	1877-2
a Verify	that	constraint	R	1877-3
R		sequential	calc R.	1877-3
calc R.		sequential	<B>	1877-3
<B>	that	constraint	S	1877-4
<B>	Show	action	S	1877-4
S		sequential	calc	1877-4
<B>	that	constraint	R	1877-5
<B>	Then show	action	R	1877-5
R		sequential	abs R	1877-5
Hint		sequential	Hint	1878-1
<B>	to	constraint	acyclic decompositions	1878-2
<B>	Then generalize	action	acyclic decompositions	1878-2
acyclic decompositions	using	action	an induction	1878-2
an induction	on	constraint	the GYO algorithm	1878-2
an induction	based	action	the GYO algorithm	1878-2
Exercise		sequential	11.26	1879-1
j		sequential	I	1880-1
I	if	constraint	I	1880-1
I	|=2	action	I	1880-1
I	if	constraint	I	1881-1
I	|=3	action	I	1881-1
I		sequential	πR	1881-1
πR		sequential	I	1881-1
I	for	constraint	I	1881-1
I	over	constraint	U	1881-1
U	that	constraint	I	1881-1
Exercise		sequential	11.28	1882-1
P		sequential	A R T D DatalogandRecursion InPartB weconsideredquerylanguagesrangingfromconjunctivequeriestofirst-order queries	1883-1
A R T D DatalogandRecursion InPartB weconsideredquerylanguagesrangingfromconjunctivequeriestofirst-order queries	in	constraint	the three paradigms	1883-1
the three paradigms		sequential	logic	1883-1
logic	and	conjunctive	<B>	1883-1
We	by	constraint	the conjunctive queries	1883-2
We	did	attribute	this	1883-2
We	enriching first	action	the conjunctive queries	1883-2
the conjunctive queries	with	constraint	union	1883-2
union		sequential	disjunction	1883-2
disjunction	with	constraint	difference	1883-2
disjunction	and	conjunctive	difference	1883-2
difference		sequential	negation	1883-2
<B>	In	constraint	this part	1884-1
this part		sequential	we	1884-1
we	further enrich	action	these languages	1884-1
these languages	by	constraint	recursion	1884-1
these languages	adding	action	recursion	1884-1
we	First add	action	recursion	1884-2
recursion	to	constraint	the conjunctive queries	1884-2
the conjunctive queries		sequential	which	1884-2
which	yields	action	datalog	1884-2
We	study	action	this language	1884-3
this language	in	constraint	Chapter 12	1884-3
Datalog	owes	action	a great debt	1885-1
a great debt	to	constraint	Prolog	1885-1
Prolog	and	conjunctive	logic	1885-1
logic		sequential	programming	1885-1
programming		sequential	the area	1885-1
the area	in	constraint	<B>	1885-1
A fundamental contribution	of	constraint	logic programming	1885-2
logic programming		sequential	the paradigm	1885-2
the paradigm	to	constraint	relational query languages	1885-2
relational query languages	is	attribute	its elegant notation	1885-2
its elegant notation	for	constraint	recursion	1885-2
its elegant notation	expressing	action	recursion	1885-2
The perspective	of	constraint	databases	1885-3
databases	from	constraint	logic programming	1885-3
databases	of	constraint	logic programming	1885-3
databases	is	attribute	however significantly different	1885-3
<B>	For	constraint	example	1885-4
example	in	constraint	databases	1885-4
databases		sequential	datalog programs	1885-4
datalog programs	define	action	mappings	1885-4
mappings	from	constraint	instances	1885-4
instances	to	constraint	instances	1885-4
instances	whereas	constraint	logic programs	1885-4
logic programs	generally carry	action	their data	1885-4
their data	with	constraint	them	1885-4
them	as	constraint	entities	1885-4
them	and	conjunctive	entities	1885-4
them	are studied	attribute	stand alone	1885-4
We	adapt	action	logic programming	1885-5
logic programming		sequential	the approach	1885-5
the approach	to	constraint	the framework	1885-5
the framework	of	constraint	databases	1885-5
We	study	action	evaluation techniques	1886-1
evaluation techniques	for	constraint	datalog programs	1886-1
datalog programs	in	constraint	Chapter 13	1886-1
Chapter 13		sequential	which	1886-1
which	covers	action	the main optimization techniques	1886-1
the main optimization techniques	for	constraint	recursion	1886-1
the main optimization techniques	developed	action	recursion	1886-1
recursion	in	constraint	query languages	1886-1
query languages	including	action	seminaive evaluation	1886-1
seminaive evaluation	and	conjunctive	magic sets	1886-1
Chapter 15	considers	action	approaches	1887-1
approaches	to	constraint	negation	1887-1
approaches	incorporating	action	negation	1887-1
negation	in	constraint	datalog	1887-1
datalog		sequential	that	1887-1
that	in	constraint	spirit	1887-1
that	are	attribute	closer	1887-1
spirit	to	constraint	logic programming	1887-1
Several important semantics	for	constraint	negation	1887-2
negation	are presented	action	stratification	1887-2
negation	including	action	stratification	1887-2
stratification	and	conjunctive	semantics	1887-2
stratification	well founded	action	semantics	1887-2
What		sequential	we	1888-1
we	do see next	action	<B>	1888-1
Riccardo		sequential	Riccardo	1889-1
Sergio		sequential	Sergio	1890-1
Vittorio		sequential	Kind	1891-1
Kind	of	constraint	queries	1891-1
queries	to	constraint	paths	1891-1
paths	in	constraint	a graph call	1891-1
a graph call	for	constraint	recursion	1891-1
recursion	for	constraint	many applications	1891-1
recursion	and	conjunctive	many applications	1891-1
recursion	are	attribute	crucial	1891-1
Foralongtime	relationalcalculusandalgebrawereconsidered	action	the databaselanguages	1892-1
Codd	as	constraint	a language	1893-1
Codd	even defined	attribute	complete	1893-1
a language		sequential	that	1893-1
that	would yield	action	precisely relational calculus	1893-1
there	Nonetheless are	action	simple operations	1893-2
simple operations	on	constraint	data	1893-2
data		sequential	that	1893-2
that	in	constraint	the calculus	1893-2
that	can not be realized	action	the calculus	1893-2
The most conspicuous example	is	attribute	graph transitive closure	1893-3
<B>	In	constraint	this chapter	1893-4
this chapter		sequential	we	1893-4
we	study	action	a language	1893-4
a language		sequential	that	1893-4
that	captures	action	such queries	1893-4
such queries	than	constraint	relational calculus	1893-4
such queries	and	conjunctive	relational calculus	1893-4
such queries	is	attribute	thus more complete	1893-4
We	with	constraint	an example	1894-1
We	start	action	an example	1894-1
an example		sequential	that	1894-1
that	motivates	action	the need	1894-1
the need	for	constraint	recursion	1894-1
<B>	Consider	action	a database	1894-2
a database	for	constraint	the Parisian Metro	1894-2
<B>	that	constraint	this database	1894-3
<B>	Note	action	this database	1894-3
this database	essentially describes	action	a graph	1894-3
Database applications	in	constraint	which	1894-4
which		sequential	part	1894-4
part	of	constraint	the data	1894-4
the data	is	attribute	a graph	1894-4
a graph	are	attribute	common	1894-4
<B>	To	constraint	the Metro database	1894-5
<B>	avoid	action	the Metro database	1894-5
<B>	making	action	the Metro database	1894-5
the Metro database		sequential	we	1894-5
we	that	constraint	the database	1894-5
we	assume	action	the database	1894-5
the database	is describing	action	the available metro connections	1894-5
the available metro connections	on	constraint	a day	1894-5
a day	of	constraint	strike	1894-5
strike		sequential	not an unusual occurrence	1894-5
some connections	and	conjunctive	the graph	1894-6
some connections	be	attribute	So may missing	1894-6
the graph	may be partitioned	action	<B>	1894-6
An instance	of	constraint	this database	1894-7
this database	in	constraint	Fig	1894-7
this database	is shown	action	Fig	1894-7
12.1		sequential	12.1	1894-8
Natural queries	to	constraint	<B>	1895-1
Natural queries	as	constraint	<B>	1895-1
Natural queries	are	attribute	<B>	1895-1
Natural queries	ask	action	<B>	1895-1
Natural queries	follows	action	<B>	1895-1
What lines	from	constraint	Odeon	1896-1
What lines	can be reached	action	Odeon	1896-1
we	from	constraint	Odeon	1897-1
we	Can go	action	Odeon	1897-1
Odeon	to	constraint	Chatelet	1897-1
<B>	Is	action	there	1898-1
there		sequential	a cycle	1898-1
a cycle	in	constraint	the graph	1898-1
the graph		sequential	a station	1898-1
a station	in	constraint	one stops	1898-1
a station	or	conjunctive	one stops	1898-1
a station	reachable	attribute	more	1898-1
one stops	from	constraint	itself	1898-1
such queries	in	constraint	the calculus	1899-1
such queries	Unfortunately can not be answered	action	the calculus	1899-1
the calculus	without	constraint	some a 1	1899-1
the calculus	using	action	some a 1	1899-1
What	is	attribute	a reasonable definition	1900-1
a reasonable definition	of	constraint	completeness	1900-1
completeness	for	constraint	database languages	1900-1
database languages		sequential	Datalog Links Line Station Next Station Iena Iena F. D. Roosevelt F. D. Roosevelt Republique	1900-1
Datalog Links Line Station Next Station Iena Iena F. D. Roosevelt F. D. Roosevelt Republique		sequential	St.- Germain Odeon Odeon St. St. Chatelet Chatelet Louvre	1900-1
St.- Germain Odeon Odeon St. St. Chatelet Chatelet Louvre		sequential	Michel	1900-1
Michel		sequential	Michel	1900-1
Michel		sequential	Louvre	1900-1
Louvre		sequential	Palais	1900-1
Palais		sequential	Palais	1900-1
Palais		sequential	Royal Royal Tuileries	1900-1
Royal Royal Tuileries		sequential	Tuileries	1900-1
Tuileries		sequential	Concorde	1900-1
Concorde		sequential	Pont de Sevres	1900-1
Pont de Sevres		sequential	Billancourt	1900-1
Billancourt		sequential	Billancourt	1900-1
Billancourt		sequential	Michel	1900-1
Michel		sequential	Ange	1900-1
Ange		sequential	Michel	1900-1
Michel		sequential	Ange	1900-1
Ange		sequential	Republique	1900-1
Republique		sequential	Voltaire	1900-1
Voltaire		sequential	Figure	1900-1
Figure		sequential	12.1	1900-1
12.1		sequential	priori knowledge	1900-1
priori knowledge	on	constraint	the Metro graph	1900-1
the Metro graph		sequential	the graph diameter	1900-1
<B>	given	action	a graph G	1900-2
a graph G		sequential	a particular vertex a	1900-2
a particular vertex a	and	conjunctive	an integer n	1900-2
an integer n		sequential	it	1900-2
it	to	constraint	a calculus query	1900-2
it	is	attribute	easy	1900-2
it	write	action	a calculus query	1900-2
a calculus query	finding	action	the vertexes	1900-2
the vertexes	at	constraint	distance	1900-2
distance	than	constraint	it	1900-2
distance	from	constraint	it	1900-2
distance	n	conjunctive	it	1900-2
distance	but	conjunctive	it	1900-2
it	to	constraint	a query	1900-2
it	seems	attribute	difficult	1900-2
it	find	action	a query	1900-2
a query	for	constraint	all vertexes	1900-2
all vertexes	from	constraint	the distance	1900-2
all vertexes	of	constraint	the distance	1900-2
We	in	constraint	Chapter 17	1900-3
We	will prove formally	action	Chapter 17	1900-3
Chapter 17	that	constraint	such a query	1900-3
such a query	in	constraint	the calculus	1900-3
such a query	is	attribute	not expressible	1900-3
the reason	is	attribute	Intuitively the lack	1900-4
Intuitively the lack	of	constraint	recursion	1900-4
recursion	in	constraint	the calculus	1900-4
The objective	of	constraint	this chapter	1901-1
this chapter	to	constraint	the database languages	1901-1
this chapter	of	constraint	the database languages	1901-1
this chapter	is	attribute	some	1901-1
this chapter	extend	attribute	some	1901-1
the database languages	with	constraint	recursion	1901-1
the database languages	considered	action	recursion	1901-1
<B>	Although	constraint	there	1901-2
there	are	attribute	many ways	1901-2
many ways	to	constraint	also Chapter 14	1901-2
many ways	do	attribute	this	1901-2
many ways	see	action	also Chapter 14	1901-2
also Chapter 14		sequential	we	1901-2
we	in	constraint	this chapter	1901-2
we	focus	action	this chapter	1901-2
this chapter	on	constraint	an approach	1901-2
an approach	by	constraint	logic programming	1901-2
an approach	inspired	action	logic programming	1901-2
<B>	to	constraint	a field	1901-3
<B>	leads	action	a field	1901-3
a field	called	action	deductive databases	1901-3
deductive databases	or	conjunctive	database logic programming	1901-3
database logic programming		sequential	which	1901-3
which	shares	action	motivation	1901-3
motivation	and	conjunctive	techniques	1901-3
techniques	with	constraint	logic programming	1901-3
logic programming		sequential	the area	1901-3
<B>	of	constraint	the activity	1902-1
the activity	in	constraint	deductive databases	1902-1
deductive databases	on	constraint	a toy language	1902-1
deductive databases	has focused	action	a toy language	1902-1
a toy language	called	action	datalog	1902-1
datalog		sequential	which	1902-1
which	extends	action	the conjunctive queries	1902-1
the conjunctive queries	with	constraint	recursion	1902-1
The interaction	between	constraint	negation	1902-2
negation	and	conjunctive	recursion	1902-2
recursion	in	constraint	Chapters 14	1902-2
recursion	and	conjunctive	Chapters 14	1902-2
recursion	is	attribute	more tricky	1902-2
recursion	is considered	action	Chapters 14	1902-2
Chapters 14	and	conjunctive	15	1902-2
The importance	of	constraint	datalog	1902-3
datalog	for	constraint	deductive databases	1902-3
deductive databases	to	constraint	the conjunctive queries	1902-3
deductive databases	of	constraint	the conjunctive queries	1902-3
deductive databases	is	attribute	analogous	1902-3
the conjunctive queries	for	constraint	the relational model	1902-3
Most optimization techniques	for	constraint	relational algebra	1902-4
relational algebra	for	constraint	conjunctive queries	1902-4
relational algebra	were developed	action	conjunctive queries	1902-4
<B>	in	constraint	this chapter	1902-5
this chapter	of	constraint	the optimization techniques	1902-5
the optimization techniques	in	constraint	deductive databases	1902-5
deductive databases	around	constraint	datalog	1902-5
deductive databases	Similarly have been developed	action	datalog	1902-5
datalog	see	action	Chapter 13	1902-5
<B>	Before	constraint	the language datalog	1903-1
<B>	formally presenting	action	the language datalog	1903-1
the language datalog		sequential	we	1903-1
we	present informally	action	the syntax	1903-1
the syntax	and	conjunctive	various semantics	1903-1
various semantics		sequential	that	1903-1
that	for	constraint	that language	1903-1
that	are considered	action	that language	1903-1
<B>	Following is	action	a datalog program PT C	1903-2
a datalog program PT C		sequential	that	1903-2
that	computes	action	the transitive closure	1903-2
the transitive closure	of	constraint	a graph	1903-2
The graph	in	constraint	relation	1903-3
The graph	is represented	action	relation	1903-3
relation		sequential	G T	1903-3
G T		sequential	x	1903-3
x		sequential	y	1903-3
y		sequential	G	1903-3
G		sequential	x	1903-3
x		sequential	y	1903-3
y		sequential	T	1903-3
T		sequential	x	1903-3
x		sequential	y	1903-3
y		sequential	G	1903-3
G		sequential	x	1903-3
x		sequential	z	1903-3
z		sequential	T	1903-3
T		sequential	z	1903-3
z		sequential	y	1903-3
Datalog Observe	that	constraint	the fact	1904-1
Datalog Observe	except	constraint	the fact	1904-1
Datalog Observe	for	constraint	the fact	1904-1
the fact	that	constraint	relation T	1904-1
relation T	in	constraint	the head	1904-1
relation T	both	conjunctive	the head	1904-1
relation T	occurs	action	the head	1904-1
the head	and	conjunctive	body	1904-1
body	of	constraint	the second rule	1904-1
the second rule	like	constraint	the nonrecursive datalog rules	1904-1
the second rule	look	action	the nonrecursive datalog rules	1904-1
the nonrecursive datalog rules	of	constraint	Chapter 4	1904-1
a datalog program	as	constraint	a mapping	1905-1
a datalog program	Thus is interpreted	action	a mapping	1905-1
a mapping	from	constraint	instances	1905-1
instances	over	constraint	the relations	1905-1
the relations	in	constraint	the bodies only	1905-1
the relations	occurring	action	the bodies only	1905-1
the bodies only	to	constraint	instances	1905-1
instances	over	constraint	the relations	1905-1
the relations	in	constraint	the heads	1905-1
the relations	occurring	action	the heads	1905-1
<B>	For	constraint	instance	1905-2
instance		sequential	the preceding program	1905-2
the preceding program	maps	action	a relation	1905-2
a relation	over	constraint	G	1905-2
G		sequential	a graph	1905-2
a graph	to	constraint	a relation	1905-2
a relation	over	constraint	T	1905-2
T		sequential	its transitive closure	1905-2
The result		sequential	T	1906-1
T	must satisfy	action	the foregoing sentences	1906-1
<B>	to	constraint	the result	1906-2
<B>	is	attribute	However not sufficient	1906-2
<B>	determine uniquely	action	the result	1906-2
the result	because	constraint	it	1906-2
it	to	constraint	there	1906-2
it	that	constraint	there	1906-2
it	is	attribute	easy	1906-2
it	see	action	there	1906-2
there	are	attribute	many T	1906-2
many T		sequential	that	1906-2
that	satisfy	action	the sentences	1906-2
it	that	constraint	the result	1906-3
it	However turns out	action	the result	1906-3
the result	if	constraint	one	1906-3
the result	becomes	attribute	unique	1906-3
one	adds	action	the following natural minimality requirement	1906-3
<B>	As	constraint	it	1906-4
it	for	constraint	each datalog program	1906-4
it	turns out	action	each datalog program	1906-4
each datalog program	and	conjunctive	input	1906-4
input		sequential	there	1906-4
there	is	attribute	a unique minimal model	1906-4
<B>	defines	action	the semantics	1906-5
the semantics	of	constraint	a datalog program	1906-5
<B>	For	constraint	example	1906-6
example	that	constraint	the instance	1906-6
example	suppose	action	the instance	1906-6
the instance	contains	action	G	1906-6
G		sequential	a b	1906-6
a b		sequential	G	1906-6
G		sequential	b	1906-6
b		sequential	c	1906-6
c		sequential	G	1906-6
G		sequential	c	1906-6
c		sequential	d	1906-6
It	that	constraint	T	1907-1
It	turns out	action	T	1907-1
T		sequential	a d	1907-1
a d	in	constraint	each instance	1907-1
a d	holds	action	each instance	1907-1
each instance		sequential	that	1907-1
that	obeys	action	1	1907-1
1	and	conjunctive	these three facts	1907-1
1	and	conjunctive	these three facts	1907-1
these three facts	2 where hold	action	<B>	1907-1
<B>	In	constraint	it	1907-2
it	to	constraint	the minimum model	1907-2
it	belongs	action	the minimum model	1907-2
the minimum model	of	constraint	1	1907-2
1	and	conjunctive	2	1907-2
proof		sequential	The second approach	1908-1
The second approach	on	constraint	proofs	1908-1
The second approach	is based	action	proofs	1908-1
The second approach	obtaining	action	proofs	1908-1
proofs	of	constraint	facts	1908-1
A proof	of	constraint	the fact	1908-2
the fact		sequential	T	1908-2
T		sequential	a d	1908-2
a d	as	constraint	<B>	1908-2
a d	is	attribute	<B>	1908-2
a d	follows	action	<B>	1908-2
<B>	In	constraint	proof	1909-1
proof		sequential	the perspective	1909-1
the perspective		sequential	there	1909-1
there	are	attribute	two ways	1909-1
two ways	to	constraint	facts	1909-1
two ways	derive	action	facts	1909-1
<B>	to	constraint	programs	1909-2
<B>	is	attribute	programs	1909-2
<B>	view	action	programs	1909-2
programs	as	constraint	factories	1909-2
factories	producing	action	all facts	1909-2
all facts		sequential	that	1909-2
that	from	constraint	known facts	1909-2
that	can be proven	action	known facts	1909-2
The rules	from	constraint	the known facts	1910-1
The rules	are used bottom up	action	the known facts	1910-1
The rules	starting	action	the known facts	1910-1
the known facts	and	conjunctive	all possible new facts	1910-1
the known facts	deriving	action	all possible new facts	1910-1
<B>		sequential	An alternative evaluation	1910-2
An alternative evaluation	from	constraint	a fact	1910-2
An alternative evaluation	starts	action	a fact	1910-2
a fact	to	constraint	it	1910-2
a fact	to	constraint	it	1910-2
a fact	and	conjunctive	it	1910-2
a fact	be proven	action	it	1910-2
a fact	attempts	action	it	1910-2
a fact	demonstrate	action	it	1910-2
it	by	constraint	lemmas	1910-2
it	deriving	action	lemmas	1910-2
lemmas		sequential	that	1910-2
that	for	constraint	the proof	1910-2
that	are needed	action	the proof	1910-2
<B>	is	attribute	the underlying Datalog intuition	1910-3
the underlying Datalog intuition	of	constraint	a particular technique	1910-3
a particular technique	called	action	resolution	1910-3
resolution		sequential	that	1910-3
that	in	constraint	the field	1910-3
that	originated	action	the field	1910-3
that	theorem proving	action	the field	1910-3
the field	and	conjunctive	lies	1910-3
lies	at	constraint	the core	1910-3
the core	of	constraint	logic programming	1910-3
logic programming		sequential	the area	1910-3
The last approach	is	attribute	the fixpoint approach	1911-1
We	that	constraint	the semantics	1911-2
We	will see	action	the semantics	1911-2
the semantics	of	constraint	the program	1911-2
the program	as	constraint	a particular solution	1911-2
the program	can be defined	action	a particular solution	1911-2
a particular solution	of	constraint	a fixpoint equation	1911-2
This approach	to	constraint	a query	1911-3
This approach	leads	action	a query	1911-3
This approach	iterating	action	a query	1911-3
a query	until	constraint	a fixpoint	1911-3
a fixpoint	in	constraint	nature	1911-3
a fixpoint	and	conjunctive	nature	1911-3
a fixpoint	is reached	attribute	thus procedural	1911-3
a fixpoint	is	attribute	thus procedural	1911-3
<B>	computes again	action	the facts	1911-4
the facts		sequential	that	1911-4
that	by	constraint	applications	1911-4
that	can be deduced	action	applications	1911-4
applications	of	constraint	the rules	1911-4
the rules	in	constraint	that respect	1911-4
the rules	and	conjunctive	that respect	1911-4
that respect		sequential	it	1911-4
it	to	constraint	bottom up	1911-4
it	is tightly connected	action	bottom up	1911-4
bottom up		sequential	the approach	1911-4
It	to	constraint	a natural strategy	1911-5
It	corresponds	action	a natural strategy	1911-5
a natural strategy	for	constraint	proofs	1911-5
a natural strategy	generating	action	proofs	1911-5
proofs		sequential	shorter proofs	1911-5
shorter proofs	before	constraint	longer proofs	1911-5
shorter proofs	where are produced	action	longer proofs	1911-5
longer proofs		sequential	facts	1911-5
facts	as	constraint	<B>	1911-5
facts	so are proven	attribute	possible	1911-5
<B>	As	constraint	a rule	1911-6
a rule		sequential	we	1911-6
we	introduce	action	only the minimum amount	1911-6
only the minimum amount	of	constraint	terminology	1911-6
terminology	from	constraint	logic programming	1911-6
logic programming	in	constraint	the special database case	1911-6
logic programming	needed	action	the special database case	1911-6
we	However make	action	brief excursions	1911-7
brief excursions	into	constraint	the wider framework	1911-7
the wider framework	in	constraint	the text	1911-7
the text	and	conjunctive	exercises	1911-7
The last section	with	constraint	static analysis	1911-8
The last section	deals	action	static analysis	1911-8
static analysis	of	constraint	datalog programs	1911-8
It	provides	action	decidability	1911-9
decidability	and	conjunctive	undecidability	1911-9
undecidability		sequential	results	1911-9
results	for	constraint	several fundamental properties	1911-9
several fundamental properties	of	constraint	programs	1911-9
Techniques	for	constraint	the evaluation	1911-10
the evaluation	of	constraint	datalog programs	1911-10
datalog programs	in	constraint	Chapter 13	1911-10
datalog programs	are discussed separately	action	Chapter 13	1911-10
Syntax	of	constraint	Datalog	1912-1
We	provide	action	next a detailed definition	1913-1
next a detailed definition	of	constraint	its syntax	1913-1
We	of	constraint	the fundamental differences	1913-2
We	also briefly introduce	attribute	some	1913-2
the fundamental differences	between	constraint	datalog	1913-2
datalog	and	conjunctive	logic	1913-2
logic		sequential	programming	1913-2
Definition		sequential	12.1.1 R1	1914-1
12.1.1 R1		sequential	u1	1914-1
u1		sequential	R2	1914-1
R2		sequential	u2	1914-1
<B>	.	sequential	<B>	1914-2
<B>	.	sequential	<B>	1914-3
Rn		sequential	un	1914-4
un		sequential	n	1914-4
n		sequential	where ≥ 1	1914-4
where ≥ 1		sequential	R1	1914-4
<B>	.	sequential	<B>	1914-5
<B>	.	sequential	<B>	1914-6
Rn	are	attribute	relation names	1914-7
relation names	and	conjunctive	u1	1914-7
<B>	.	sequential	<B>	1914-8
<B>	.	sequential	<B>	1914-9
un	are	attribute	free tuples	1914-10
free tuples	of	constraint	appropriate arities	1914-10
Each variable	in	constraint	u1	1914-11
Each variable	occurring	action	u1	1914-11
u1	in	constraint	one	1914-11
u1	at	constraint	one	1914-11
u1	must occur	attribute	least	1914-11
one	of	constraint	u2	1914-11
<B>	.	sequential	<B>	1914-12
<B>	.	sequential	<B>	1914-13
<B>		sequential	<B>	1914-14
A datalog program	is	attribute	a finite set	1914-15
a finite set	of	constraint	datalog rules	1914-15
The head	of	constraint	the rule	1915-1
the rule	is	attribute	the expression	1915-1
the expression		sequential	R1	1915-1
R1		sequential	u1	1915-1
u1	and	conjunctive	R2	1915-1
R2		sequential	u2	1915-1
<B>	.	sequential	<B>	1915-2
<B>	.	sequential	<B>	1915-3
Rn		sequential	un	1915-4
un	forms	action	the body	1915-4
The set	of	constraint	constants	1916-1
constants	in	constraint	a datalog program P	1916-1
constants	occurring	action	a datalog program P	1916-1
a datalog program P	is denoted	action	adom	1916-1
adom		sequential	P	1916-1
P	for	constraint	an instance	1916-1
P	and	conjunctive	an instance	1916-1
an instance		sequential	I	1916-1
I		sequential	we	1916-1
we	use	action	adom	1916-1
adom		sequential	P	1916-1
P		sequential	I	1916-1
I	as	constraint	an abbreviation	1916-1
an abbreviation	for	constraint	adom	1916-1
adom		sequential	P	1916-1
P		sequential	∪ adom	1916-1
∪ adom		sequential	I	1916-1
We	next recall	action	a definition	1917-1
a definition	from	constraint	Chapter 4	1917-1
Chapter 4		sequential	that	1917-1
that	to	constraint	this chapter	1917-1
that	is	attribute	central	1917-1
Definition		sequential	12.1.2	1918-1
<B>	.	sequential	<B>	1918-2
<B>	.	sequential	<B>	1918-3
Rn		sequential	ν	1918-4
ν		sequential	un	1918-4
un	of	constraint	a rule R1	1918-4
a rule R1		sequential	u1	1918-4
u1		sequential	R2	1918-4
R2		sequential	u2	1918-4
<B>	.	sequential	<B>	1918-5
<B>	.	sequential	<B>	1918-6
Rn		sequential	un	1918-7
un	with	constraint	ν	1918-7
ν	by	constraint	each variable x	1918-7
ν	is obtained	action	each variable x	1918-7
ν	replacing	action	each variable x	1918-7
each variable x	by	constraint	ν	1918-7
ν		sequential	x	1918-7
<B>	Let	action	P	1919-1
P	be	attribute	a datalog program	1919-1
An extensional relation	is	attribute	a relation	1919-2
a relation	in	constraint	only the body	1919-2
a relation	occurring	action	only the body	1919-2
only the body	of	constraint	the rules	1919-2
An intensional relation	is	attribute	a relation	1919-3
a relation	in	constraint	the head	1919-3
a relation	occurring	action	the head	1919-3
the head	of	constraint	some rule	1919-3
some rule	of	constraint	P	1919-3
database		sequential	The extensional schema	1919-4
The extensional schema	denoted	action	edb	1919-4
edb		sequential	P	1919-4
P	of	constraint	the set	1919-4
P	consists	action	the set	1919-4
the set	of	constraint	all extensional relation names	1919-4
all extensional relation names	whereas	constraint	the intensional schema idb	1919-4
the intensional schema idb		sequential	P	1919-4
P	of	constraint	all the intensional ones	1919-4
P	consists	action	all the intensional ones	1919-4
The schema	of	constraint	P	1919-5
P		sequential	denoted sch	1919-5
denoted sch		sequential	P	1919-5
P	is	attribute	the union	1919-5
the union	of	constraint	edb	1919-5
edb		sequential	P	1919-5
P	and	conjunctive	idb	1919-5
idb		sequential	P	1919-5
The semantics	of	constraint	a datalog program	1919-6
a datalog program	is	attribute	a mapping	1919-6
a mapping	from	constraint	database instances	1919-6
database instances	over	constraint	edb	1919-6
edb		sequential	P	1919-6
P	to	constraint	database instances	1919-6
database instances	over	constraint	idb	1919-6
idb		sequential	P	1919-6
<B>	In	constraint	some contexts	1919-7
some contexts		sequential	we	1919-7
we	call	action	the input data	1919-7
the input data		sequential	the extensional database	1919-7
the extensional database	and	conjunctive	the program	1919-7
the program		sequential	the intensional database	1919-7
<B>	that	constraint	the context	1919-8
<B>	in	constraint	the context	1919-8
<B>	Note also	action	the context	1919-8
the context	of	constraint	languages	1919-8
the context	logic based	action	languages	1919-8
languages		sequential	the term predicate	1919-8
the term predicate	in	constraint	place	1919-8
the term predicate	is often used	action	place	1919-8
place	of	constraint	the term relation name	1919-8
<B>	Let	action	us	1920-1
us	consider	action	an example	1920-1
Example		sequential	12.1.3	1921-1
<B>		sequential	edb	1921-2
edb		sequential	P metro	1921-2
P metro	=	sequential	Links }	1921-2
Links }		sequential	idb	1921-2
idb		sequential	P metro	1921-2
P metro	=	sequential	St	1921-2
St		sequential	Reachable	1921-2
Reachable		sequential	Li	1921-2
Li		sequential	Ans	1921-2
Ans	_	sequential	1	1921-2
1		sequential	Ans	1921-2
Ans	_	sequential	2	1921-2
2		sequential	Ans }	1921-2
Ans }	_	sequential	3	1921-2
3	For	constraint	example	1921-2
example		sequential	an instantiation	1921-2
an instantiation	of	constraint	the second rule	1921-2
the second rule	of	constraint	P metro	1921-2
P metro	as	constraint	St Reachable	1921-2
P metro	is	attribute	St Reachable	1921-2
P metro	follows	action	St Reachable	1921-2
St Reachable		sequential	Odeon	1921-2
Odeon		sequential	Louvre	1921-2
The major difference	that	constraint	logic programming	1921-3
The major difference	is	attribute	logic programming	1921-3
logic programming	permits	action	function symbols	1921-3
function symbols	but	conjunctive	datalog	1921-3
datalog	does not	action	<B>	1921-3
Example		sequential	12.1.4	1922-1
<B>	as	constraint	the successor function	1922-2
<B>	might be viewed	action	the successor function	1922-2
the successor function	as	constraint	addition	1922-2
the successor function	+	sequential	addition	1922-2
addition	as	constraint	the relation	1922-2
addition	than	constraint	the relation	1922-2
addition	and	conjunctive	the relation	1922-2
addition	or	conjunctive	the relation	1922-2
addition	capturing	attribute	equal	1922-2
<B>	in	constraint	logic programming	1922-3
logic programming		sequential	the function symbols	1922-3
the function symbols	However are given	attribute	free	1922-3
the interpretation		sequential	two terms	1922-3
two terms	are considered	attribute	nonequal	1922-3
they	are	attribute	whenever syntactically different	1922-3
<B>	For	constraint	example	1922-4
example		sequential	the terms	1922-4
the terms		sequential	0	1922-4
0		sequential	s	1922-4
s		sequential	0	1922-4
0	+	sequential	s	1922-4
s		sequential	0	1922-4
0		sequential	0	1922-4
0	and	conjunctive	s	1922-4
s		sequential	0	1922-4
0	are	attribute	all nonequal	1922-4
functional terms	in	constraint	logic programming	1922-5
functional terms	Importantly can be used	action	logic programming	1922-5
logic programming	to	constraint	intricate data structures	1922-5
logic programming	represent	action	intricate data structures	1922-5
intricate data structures		sequential	lists	1922-5
lists	and	conjunctive	trees	1922-5
<B>	that	constraint	the preceding program	1923-1
<B>	in	constraint	the preceding program	1923-1
<B>	Observe also	action	the preceding program	1923-1
the preceding program		sequential	the variable x	1923-1
the variable x	in	constraint	the head	1923-1
the variable x	occurs	action	the head	1923-1
the head	of	constraint	the first rule	1923-1
the first rule	in	constraint	not the body	1923-1
the first rule	and	conjunctive	not the body	1923-1
not the body	for	constraint	analogously the third rule	1923-1
not the body	and	conjunctive	analogously the third rule	1923-1
<B>	in	constraint	this chapter	1924-1
this chapter		sequential	we	1924-1
we	Later present	action	further comparisons	1924-1
further comparisons	of	constraint	the two frameworks	1924-1
Model		sequential	Semantics	1925-1
the database instance	constituting	action	the result	1925-2
the result	Thus satisfies	action	the sentences	1925-2
Such an instance	is also called	action	a model	1925-3
a model	of	constraint	the sentences	1925-3
there	However can be	attribute	indeed infinitely many	1925-4
many instances	satisfying	action	the sentences	1925-4
the sentences	of	constraint	a program	1925-4
the sentences themselves	Thus do not uniquely identify	action	the answer	1925-5
the answer		sequential	it	1925-5
it	to	constraint	which	1925-5
it	is	attribute	necessary	1925-5
it	specify	action	which	1925-5
which	of	constraint	the models	1925-5
the models	is	attribute	the intended answer	1925-5
<B>	on	constraint	assumptions	1925-6
<B>	is usually done	action	assumptions	1925-6
<B>	based	action	assumptions	1925-6
assumptions		sequential	that	1925-6
that	to	constraint	the sentences themselves	1925-6
that	are	attribute	external	1925-6
<B>	In	constraint	this section	1925-7
this section		sequential	we	1925-7
we	formalize	action	1 the relationship	1925-7
1 the relationship	between	constraint	rules	1925-7
rules	and	conjunctive	logical sentences	1925-7
logical sentences		sequential	the notion	1925-7
the notion	of	constraint	model	1925-7
model	and	conjunctive	3 the concept	1925-7
3 the concept	of	constraint	intended model	1925-7
We	by	constraint	logical sentences	1926-1
We	begin	action	logical sentences	1926-1
We	associating	action	logical sentences	1926-1
logical sentences	with	constraint	rules	1926-1
rules	as	constraint	we	1926-1
we	in	constraint	the beginning	1926-1
we	did	action	the beginning	1926-1
the beginning	of	constraint	this chapter	1926-1
<B>	To	constraint	a datalog rule	1926-2
a datalog rule		sequential	we	1926-2
we	associate	action	the logical sentence	1926-2
the logical sentence		sequential	where x1	1926-2
<B>	.	sequential	<B>	1926-3
<B>	.	sequential	<B>	1926-4
xm	are	attribute	the variables	1926-5
the variables	in	constraint	the rule	1926-5
the variables	occurring	action	the rule	1926-5
the rule	and	conjunctive	the standard logical implication	1926-5
the rule	←	sequential	the standard logical implication	1926-5
the rule	is	attribute	the standard logical implication	1926-5
<B>	that	constraint	an instance	1926-6
<B>	Observe	action	an instance	1926-6
an instance		sequential	I	1926-6
I	satisfies	action	ρ	1926-6
ρ	denoted	action	I	1926-6
I		sequential	ρ	1926-6
ρ	if	constraint	each instantiation R1	1926-6
ρ	for	constraint	each instantiation R1	1926-6
each instantiation R1		sequential	ν	1926-6
ν		sequential	u1	1926-6
u1		sequential	R2	1926-6
R2		sequential	ν	1926-6
ν		sequential	u2	1926-6
<B>	.	sequential	<B>	1926-7
<B>	.	sequential	<B>	1926-8
Rn		sequential	ν	1926-9
ν		sequential	un	1926-9
un	that	constraint	R2	1926-9
R2		sequential	ν	1926-9
ν		sequential	u2	1926-9
<B>	.	sequential	<B>	1926-10
<B>	.	sequential	<B>	1926-11
Rn		sequential	ν	1926-12
ν		sequential	un	1926-12
un	to	constraint	I	1926-12
un	belong	action	I	1926-12
I	so does	action	R1	1926-12
R1		sequential	ν	1926-12
ν		sequential	u1	1926-12
<B>	In	constraint	we	1926-13
<B>	following	action	we	1926-13
we	between	constraint	a rule ρ	1926-13
we	do not distinguish	action	a rule ρ	1926-13
a rule ρ	and	conjunctive	the associated sentence	1926-13
<B>	For	constraint	a program P	1926-14
a program P		sequential	the conjunction	1926-14
the conjunction	of	constraint	the sentences	1926-14
the sentences	with	constraint	the rules	1926-14
the sentences	associated	action	the rules	1926-14
the rules	of	constraint	P	1926-14
P	by	constraint	P	1926-14
P	is denoted	action	P	1926-14
It	to	constraint	there	1927-1
It	that	constraint	there	1927-1
It	is	attribute	useful	1927-1
It	note	action	there	1927-1
there	are	attribute	alternative ways	1927-1
alternative ways	to	constraint	the sentences	1927-1
alternative ways	write	action	the sentences	1927-1
the sentences	with	constraint	rules	1927-1
the sentences	associated	action	rules	1927-1
rules	of	constraint	programs	1927-1
<B>	In	constraint	the formula	1927-2
the formula	is	attribute	equivalent	1927-2
This last form	is	attribute	particularly interesting	1928-1
Formulas	of	constraint	a disjunction	1928-2
Formulas	consisting	action	a disjunction	1928-2
a disjunction	of	constraint	literals	1928-2
literals	of	constraint	which	1928-2
which	at	constraint	most one	1928-2
most one	in	constraint	logic Horn clauses	1928-2
most one	is	attribute	positive	1928-2
most one	are called	action	logic Horn clauses	1928-2
A datalog program	as	constraint	a set	1928-3
A datalog program	can thus be viewed	action	a set	1928-3
a set	of	constraint	<B>	1928-3
We	next discuss	action	the issue	1929-1
the issue	of	constraint	the models	1929-1
the issue	among	constraint	the models	1929-1
the issue	choosing	action	the models	1929-1
the models	of	constraint	P	1929-1
P		sequential	the particular model	1929-1
the particular model		sequential	that	1929-1
that	as	constraint	the answer	1929-1
that	is intended	action	the answer	1929-1
<B>	is	attribute	not a hard problem	1929-2
not a hard problem	for	constraint	datalog	1929-2
datalog	although	constraint	we	1929-2
datalog	as	constraint	we	1929-2
we	in	constraint	Chapter 15	1929-2
we	shall see	action	Chapter 15	1929-2
Chapter 15		sequential	it	1929-2
it	if	constraint	datalog	1929-2
it	becomes	attribute	much more involved	1929-2
datalog	with	constraint	negation	1929-2
datalog	is extended	action	negation	1929-2
<B>	For	constraint	datalog	1930-1
datalog		sequential	the idea	1930-1
the idea	for	constraint	the intended model	1930-1
the idea	choosing	action	the intended model	1930-1
the intended model	that	constraint	the model	1930-1
the intended model	is	attribute	the model	1930-1
the model	simply should not contain	action	more facts	1930-1
more facts	than	constraint	P	1930-1
more facts	for	constraint	P	1930-1
more facts	satisfying	action	P	1930-1
the intended model	in	constraint	some natural sense	1930-2
the intended model	is	attribute	So minimal	1930-2
<B>	is formalized next	action	<B>	1930-3
Definition		sequential	12.2.1	1931-1
A model	of	constraint	P	1931-2
P	is	attribute	an instance	1931-2
an instance	over	constraint	sch	1931-2
sch		sequential	P	1931-2
P	satisfying	action	P	1931-2
The semantics	of	constraint	P	1931-3
P	on	constraint	input	1931-3
input		sequential	I	1931-3
I	denoted	action	P	1931-3
P		sequential	I	1931-3
I	is	attribute	the minimum model	1931-3
the minimum model	of	constraint	P	1931-3
P	containing	action	I	1931-3
I	if	constraint	it	1931-3
it	exists	action	<B>	1931-3
Datalog Station Line		sequential	Odeon St. Chatelet Louvres	1932-1
Odeon St. Chatelet Louvres		sequential	Michel	1932-1
Michel		sequential	Palais	1932-1
Palais		sequential	Royal Tuileries Concorde	1932-1
Royal Tuileries Concorde		sequential	Figure	1932-1
Figure		sequential	12.2	1932-1
12.2		sequential	Relations	1932-1
Relations	of	constraint	P metro	1932-1
P metro		sequential	I	1932-1
I	For	constraint	P metro	1932-1
P metro	as	constraint	Example 12.1.3	1932-1
P metro	in	constraint	Example 12.1.3	1932-1
Example 12.1.3	and	conjunctive	I	1932-1
I	in	constraint	Fig	1932-1
I	as	action	Fig	1932-1
the values	of	constraint	Ans _1	1932-2
Ans _1		sequential	Ans _2	1932-2
Ans _2	and	conjunctive	Ans _3	1932-2
Ans _3	in	constraint	P	1932-2
P		sequential	I	1932-2
I	in	constraint	Fig	1932-2
I	12.1 are shown	action	Fig	1932-2
12.2		sequential	12.2	1932-3
We	briefly discuss	action	the choice	1933-1
the choice	of	constraint	the minimal model	1933-1
the minimal model	at	constraint	the end	1933-1
the end	of	constraint	this section	1933-1
We	next provide	action	simple answers	1934-1
simple answers	to	constraint	these problems	1934-1
simple answers	of	constraint	these problems	1934-1
<B>	that	constraint	definition	1935-1
<B>	by	constraint	definition	1935-1
<B>	Observe	action	definition	1935-1
definition		sequential	P	1935-1
P		sequential	I	1935-1
I	is	attribute	an instance	1935-1
an instance	over	constraint	sch	1935-1
sch		sequential	P	1935-1
A priori		sequential	we	1935-2
we	must consider	action	all instances	1935-2
all instances	over	constraint	sch	1935-2
sch		sequential	P	1935-2
P		sequential	an infinite set	1935-2
It	that	constraint	it	1935-3
It	turns out	action	it	1935-3
it	to	constraint	only those instances	1935-3
it	suffices	action	only those instances	1935-3
it	consider	action	only those instances	1935-3
only those instances	with	constraint	active domain	1935-3
active domain	in	constraint	adom	1935-3
adom		sequential	P	1935-3
P		sequential	I	1935-3
I		sequential	a finite set	1935-3
a finite set	of	constraint	instances	1935-3
<B>	For	constraint	P	1935-4
<B>	given	action	P	1935-4
P	and	conjunctive	I	1935-4
I	let	action	B	1935-4
B		sequential	P	1935-4
P		sequential	I	1935-4
I	be	attribute	the instance	1935-4
the instance	over	constraint	sch	1935-4
sch		sequential	P	1935-4
P	by	constraint	1	1935-4
P	defined	action	1	1935-4
<B>	For	constraint	each R	1935-5
each R	in	constraint	edb	1935-5
edb		sequential	P	1935-5
P		sequential	a fact	1935-5
a fact		sequential	R	1935-5
R		sequential	u	1935-5
u	in	constraint	B	1935-5
u	is	attribute	B	1935-5
B		sequential	P	1935-5
P		sequential	I	1935-5
I	iff	action	it	1935-5
it	in	constraint	I	1935-5
it	is	attribute	I	1935-5
I	and	conjunctive	2	1935-5
<B>	For	constraint	each R	1935-6
each R	in	constraint	idb	1935-6
idb		sequential	P	1935-6
P		sequential	each fact	1935-6
each fact		sequential	R	1935-6
R		sequential	u	1935-6
u	with	constraint	constants	1935-6
constants	in	constraint	adom	1935-6
adom		sequential	P	1935-6
P		sequential	I	1935-6
I	in	constraint	B	1935-6
I	is	attribute	B	1935-6
B		sequential	P	1935-6
P		sequential	I	1935-6
We	that	constraint	B	1936-1
We	now verify	action	B	1936-1
B		sequential	P	1936-1
P		sequential	I	1936-1
I	is	attribute	a model	1936-1
a model	of	constraint	P	1936-1
P	containing	action	I	1936-1
Lemma		sequential	12.2.2	1937-1
B		sequential	P	1937-2
P		sequential	I	1937-2
I	is	attribute	Then a model	1937-2
Then a model	of	constraint	P	1937-2
P	containing	action	I	1937-2
Proof	Let	action	A1	1938-1
A1	←	sequential	A2	1938-1
<B>	.	sequential	<B>	1938-2
<B>	.	sequential	<B>	1938-3
<B>	be	attribute	an instantiation	1938-4
an instantiation	of	constraint	some rule	1938-4
some rule		sequential	r	1938-4
r	in	constraint	P	1938-4
P	that	constraint	A2	1938-4
<B>	.	sequential	<B>	1938-5
<B>	.	sequential	<B>	1938-6
An hold	in	constraint	B	1938-7
B		sequential	P	1938-7
P		sequential	I	1938-7
<B>	Then consider	action	A1	1938-8
<B>	Because	constraint	each variable	1938-9
each variable	in	constraint	the head	1938-9
each variable	occurring	action	the head	1938-9
the head	of	constraint	r	1938-9
r	in	constraint	the body	1938-9
r	also occurs	action	the body	1938-9
the body	in	constraint	A1	1938-9
the body	occurring	action	A1	1938-9
A1	to	constraint	adom	1938-9
A1	belongs	action	adom	1938-9
adom		sequential	P	1938-9
P		sequential	I	1938-9
<B>	by	constraint	definition 2	1938-10
definition 2	just given	action	A1	1938-10
A1	in	constraint	Thus B	1938-10
A1	is	attribute	Thus B	1938-10
Thus B		sequential	P	1938-10
P		sequential	I	1938-10
B		sequential	P	1938-11
P		sequential	I	1938-11
I	Hence satisfies	action	the sentence	1938-11
the sentence	with	constraint	that particular rule	1938-11
the sentence	associated	action	that particular rule	1938-11
that particular rule		sequential	B	1938-11
B		sequential	P	1938-11
P		sequential	I	1938-11
I	so satisfies	action	P	1938-11
B		sequential	P	1938-12
P		sequential	I	1938-12
I	Clearly contains	action	I	1938-12
I	by	constraint	definition 1	1938-12
the semantics	of	constraint	P	1939-1
P	on	constraint	input	1939-1
input		sequential	I	1939-1
I	if	constraint	Thus a subset	1939-1
I	is	attribute	Thus a subset	1939-1
I	defined	action	Thus a subset	1939-1
Thus a subset	of	constraint	B	1939-1
B		sequential	P	1939-1
P		sequential	I	1939-1
<B>	that	constraint	there	1939-2
<B>	means	action	there	1939-2
there	is	attribute	no need	1939-2
no need	to	constraint	instances	1939-2
no need	consider	action	instances	1939-2
instances	with	constraint	constants	1939-2
constants	outside	constraint	adom	1939-2
adom		sequential	P	1939-2
P		sequential	I	1939-2
We	that	constraint	P	1940-1
We	next demonstrate	action	P	1940-1
P		sequential	I	1940-1
I	is always defined	action	<B>	1940-1
Theorem		sequential	12.2.3	1941-1
<B>		sequential	<B>	1941-2
Proof		sequential	Proof	1942-1
<B>	Let	action	r	1942-2
r		sequential	A1	1942-2
A1	←	sequential	A2	1942-2
<B>	.	sequential	<B>	1942-3
<B>	.	sequential	<B>	1942-4
<B>	be	attribute	a rule	1942-5
a rule	in	constraint	P	1942-5
P	ν	constraint	a valuation	1942-5
P	and	conjunctive	a valuation	1942-5
a valuation	of	constraint	the variables	1942-5
the variables	in	constraint	the rule	1942-5
the variables	occurring	action	the rule	1942-5
<B>	To	constraint	we	1942-6
<B>	prove	action	we	1942-6
we	that	constraint	ν	1942-6
we	if	constraint	ν	1942-6
we	1 show	action	ν	1942-6
ν		sequential	A2	1942-6
<B>	.	sequential	<B>	1942-7
<B>	.	sequential	<B>	1942-8
ν	in	constraint	∩X ν	1942-9
ν	are	attribute	∩X ν	1942-9
∩X ν		sequential	A1	1942-9
A1	in	constraint	An also ∩X	1942-9
A1	is	attribute	An also ∩X	1942-9
<B>	For	constraint	<B>	1943-1
<B>	that	constraint	<B>	1943-1
<B>	suppose	action	<B>	1943-1
<B>	holds	action	<B>	1943-1
Then ∩X	|=	sequential	r	1943-2
r		sequential	∩X	1943-2
∩X	so satisfies	action	P	1943-2
<B>	Because	constraint	each instance	1943-3
each instance	in	constraint	X	1943-3
X	contains	action	I	1943-3
I		sequential	∩X	1943-3
∩X	contains	action	I	1943-3
<B>	∩	sequential	X	1943-4
X	is	attribute	Hence a model	1943-4
Hence a model	of	constraint	P	1943-4
P	containing	action	I	1943-4
<B>	By	constraint	construction	1943-5
construction		sequential	∩ X	1943-5
∩ X	is	attribute	minimal	1943-5
∩ X	so 1 holds	action	<B>	1943-5
<B>	To	constraint	ν	1944-1
<B>	that	constraint	ν	1944-1
<B>	show	action	ν	1944-1
<B>	suppose	action	ν	1944-1
ν		sequential	A2	1944-1
<B>	.	sequential	<B>	1944-2
<B>	.	sequential	<B>	1944-3
ν	in	constraint	An ∩X	1944-4
ν	are	attribute	An ∩X	1944-4
An ∩X	and	conjunctive	K	1944-4
An ∩X	let	action	K	1944-4
K	in	constraint	X	1944-4
K	be	attribute	X	1944-4
<B>	Because	constraint	<B>	1944-5
<B>	By	constraint	Lemma 12.2.2	1945-1
Lemma 12.2.2		sequential	B	1945-1
B		sequential	P	1945-1
P		sequential	I	1945-1
I	is	attribute	a model	1945-1
a model	of	constraint	P	1945-1
P	containing	action	I	1945-1
Therefore P		sequential	I	1945-2
I		sequential	⊆ B	1945-2
⊆ B		sequential	P	1945-2
P		sequential	I	1945-2
<B>		sequential	<B>	1946-1
B		sequential	P	1947-1
P		sequential	I	1947-1
I		sequential	R	1947-1
R	=	sequential	I	1947-1
I		sequential	R	1947-1
R		sequential	which	1947-1
which	shows	action	3	1947-1
The previous development	also provides	action	an algorithm	1948-1
an algorithm	for	constraint	the semantics	1948-1
an algorithm	computing	action	the semantics	1948-1
the semantics	of	constraint	datalog programs	1948-1
<B>	Given	action	P	1948-2
P	and	conjunctive	I	1948-2
I		sequential	it	1948-2
it	to	constraint	all instances	1948-2
it	suffices	action	all instances	1948-2
it	consider	action	all instances	1948-2
all instances		sequential	that	1948-2
that	are	attribute	subsets	1948-2
subsets	of	constraint	B	1948-2
B		sequential	P	1948-2
P		sequential	I	1948-2
I	find	attribute	those	1948-2
that	are	attribute	models	1948-2
models	of	constraint	P	1948-2
P	and	conjunctive	I	1948-2
P	contain	action	I	1948-2
I	and	conjunctive	their intersection	1948-2
I	compute	action	their intersection	1948-2
<B>	is	attribute	However clearly an inefficient procedure	1948-3
The next section	provides	action	a more reasonable algorithm	1948-4
We	conclude	action	this section	1949-1
this section	with	constraint	two remarks	1949-1
two remarks	on	constraint	the definition	1949-1
the definition	of	constraint	semantics	1949-1
semantics	of	constraint	datalog programs	1949-1
<B>	explains	action	the choice	1949-2
the choice	of	constraint	a minimal model	1949-2
<B>	rephrases	action	our definition	1949-3
our definition	in	constraint	logic programming	1949-3
logic programming		sequential	more standard terminology	1949-3
<B>	Why Choose	action	the Minimal Model	1950-1
This choice	is	attribute	the natural consequence	1951-1
the natural consequence	of	constraint	an implicit hypothesis	1951-1
an implicit hypothesis	of	constraint	a philosophical nature	1951-1
a philosophical nature		sequential	the closed world assumption	1951-1
the closed world assumption		sequential	CWA	1951-1
CWA	see	action	Chapter 2	1951-1
The CWA	concerns	action	the connection	1952-1
the connection	between	constraint	the database	1952-1
the database	and	conjunctive	the world	1952-1
the world		sequential	it	1952-1
it	models	action	<B>	1952-1
Datalog		sequential	databases	1953-1
databases	are	attribute	Clearly often incomplete	1953-1
facts		sequential	that	1953-1
that	in	constraint	the world	1953-1
that	be	attribute	may true	1953-1
the world	in	constraint	the database	1953-1
the world	are not necessarily recorded	action	the database	1953-1
<B>	although	constraint	we	1953-2
we	that	constraint	a fact	1953-2
we	can reasonably assume	action	a fact	1953-2
a fact	in	constraint	the database	1953-2
a fact	recorded	action	the database	1953-2
the database	in	constraint	the world	1953-2
the database	is	attribute	true	1953-2
the world		sequential	it	1953-2
it	is	attribute	Thus not clear	1953-2
what		sequential	we	1953-2
we	about	constraint	facts	1953-2
we	can say	action	facts	1953-2
facts	not explicitly recorded	action	<B>	1953-2
they	or	conjunctive	<B>	1953-3
they	Should be considered	attribute	false	1953-3
The CWA	provides	action	the simplest solution	1953-4
the simplest solution	to	constraint	this problem	1953-4
<B>	to	constraint	only the facts	1953-5
<B>	is	attribute	equivalent	1953-5
<B>	taking as true	action	only the facts	1953-5
only the facts		sequential	that	1953-5
that	in	constraint	all worlds	1953-5
that	be	attribute	must true	1953-5
all worlds	by	constraint	the database	1953-5
all worlds	modeled	action	the database	1953-5
<B>	By	constraint	extension	1953-6
extension	justifies	action	the choice	1953-6
the choice	of	constraint	minimal model	1953-6
minimal model	as	constraint	the semantics	1953-6
the semantics	of	constraint	a datalog program	1953-6
the minimal model	of	constraint	the facts	1953-7
the minimal model	Indeed consists	action	the facts	1953-7
the facts		sequential	we	1953-7
we	in	constraint	all worlds	1953-7
we	know	attribute	must true	1953-7
we	be	attribute	must true	1953-7
all worlds	satisfying	action	the sentences	1953-7
the sentences	and	conjunctive	the input instance	1953-7
the sentences	including	action	the input instance	1953-7
<B>	As	constraint	we	1953-8
we	shall see	attribute	this	1953-8
we	has	action	proof	1953-8
proof		sequential	an equivalent counterpart	1953-8
an equivalent counterpart		sequential	which	1953-8
which	will justify	action	proof	1953-8
proof		sequential	the semantics	1953-8
the semantics	of	constraint	datalog programs	1953-8
Facts		sequential	that	1953-9
that	can not be proven	attribute	false	1953-9
that	are therefore considered	attribute	false	1953-9
the CWA	to	constraint	the presence	1954-1
the CWA	in	constraint	the presence	1954-1
the CWA	is	attribute	Importantly not so simple	1954-1
the CWA	use	action	the presence	1954-1
the presence	of	constraint	negation	1954-1
negation	or	conjunctive	disjunction	1954-1
<B>	For	constraint	example	1955-1
example	that	constraint	a database	1955-1
example	suppose	action	a database	1955-1
a database	holds	action	p	1955-1
p		sequential	q }	1955-1
<B>	Under	constraint	the CWA	1955-2
the CWA		sequential	both ¬p	1955-2
both ¬p	and	conjunctive	<B>	1955-2
Herbrand Interpretation		sequential	Herbrand Interpretation	1956-1
<B>	In	constraint	logic programming	1957-1
logic programming		sequential	the facts	1957-1
the facts	of	constraint	an input instance	1957-1
an input instance		sequential	I	1957-1
I	from	constraint	the sentences	1957-1
I	are not separated	action	the sentences	1957-1
the sentences	of	constraint	a datalog program P	1957-1
<B>		sequential	sentences	1957-2
sentences	that	constraint	all facts	1957-2
sentences	stating	action	all facts	1957-2
all facts	in	constraint	I	1957-2
I	in	constraint	P	1957-2
I	are	attribute	true	1957-2
I	are included	action	P	1957-2
<B>	gives	action	rise	1957-3
rise	to	constraint	a logical theory P	1957-3
a logical theory P		sequential	I	1957-3
I	of	constraint	the sentences	1957-3
I	consisting	action	the sentences	1957-3
the sentences	in	constraint	P	1957-3
The semantics	as	constraint	a particular model	1958-1
The semantics	is defined	action	a particular model	1958-1
a particular model	of	constraint	this set	1958-1
this set	of	constraint	sentences	1958-1
A problem	that	constraint	standard interpretations	1958-2
A problem	is	attribute	standard interpretations	1958-2
standard interpretations	in	constraint	first order	1958-2
first order		sequential	logic permit interpretation	1958-2
logic permit interpretation	of	constraint	constants	1958-2
constants	of	constraint	the theory	1958-2
the theory	with	constraint	arbitrary elements	1958-2
arbitrary elements	of	constraint	the domain	1958-2
<B>	For	constraint	instance	1958-3
instance		sequential	the constants	1958-3
the constants		sequential	Odeon	1958-3
Odeon	and	conjunctive	St.	1958-3
St.		sequential	Michel	1958-3
Michel	by	constraint	the same element	1958-3
Michel	may be interpreted	action	the same element	1958-3
the same element		sequential	e.g. John	1958-3
<B>	is	attribute	clearly not what	1958-4
clearly not what		sequential	we	1958-4
we	in	constraint	the database context	1958-4
we	mean	action	the database context	1958-4
We	to	constraint	Odeon	1958-5
We	wish	action	Odeon	1958-5
We	interpret	action	Odeon	1958-5
Odeon	by	constraint	Odeon	1958-5
Odeon	for	constraint	similarly all other constants	1958-5
Odeon	and	conjunctive	similarly all other constants	1958-5
Interpretations		sequential	that	1958-6
that	use	action	the identity function	1958-6
the identity function	to	constraint	the constant symbols	1958-6
the identity function	interpret	action	the constant symbols	1958-6
the constant symbols	are called	action	Herbrand interpretations	1958-6
Herbrand interpretations	see	action	Chapter 2	1958-6
<B>	If	constraint	function symbols	1958-7
function symbols	are	attribute	present	1958-7
restrictions	on	constraint	how terms	1958-7
restrictions	are also placed	action	how terms	1958-7
how terms	involving	action	functions	1958-7
functions	are interpreted	action	<B>	1958-7
<B>	Given	action	a set	1958-8
a set	of	constraint	formulas	1958-8
formulas		sequential	a Herbrand model of	1958-8
a Herbrand model of	is	attribute	a Herbrand interpretation satisfying	1958-8
<B>	in	constraint	Thus logic programming terms	1959-1
Thus logic programming terms		sequential	the semantics	1959-1
the semantics	of	constraint	a program P	1959-1
a program P	given	action	an instance	1959-1
an instance		sequential	I	1959-1
I	as	constraint	the minimum Herbrand model	1959-1
I	can be viewed	action	the minimum Herbrand model	1959-1
the minimum Herbrand model	of	constraint	P	1959-1
P		sequential	I	1959-1
Fixpoint Semantics		sequential	Fixpoint Semantics	1960-1
We	use	action	an operator	1960-2
an operator	called	action	the immediate consequence operator	1960-2
The operator	produces	action	new facts	1960-3
new facts	from	constraint	known facts	1960-3
new facts	starting	action	known facts	1960-3
We	that	constraint	se-	1960-4
We	show	attribute	theoretic	1960-4
se-		sequential	the model mantics	1960-4
the model mantics		sequential	P	1960-4
P		sequential	I	1960-4
I	as	constraint	the smallest solution	1960-4
I	can also be defined	action	the smallest solution	1960-4
the smallest solution	of	constraint	a fixpoint equation	1960-4
a fixpoint equation	involving	action	that operator	1960-4
It	that	constraint	this solution	1960-5
It	turns out	action	this solution	1960-5
this solution	can be obtained constructively	action	<B>	1960-5
This approach	therefore provides	action	an alternative constructive definition	1960-6
an alternative constructive definition	of	constraint	the semantics	1960-6
the semantics	of	constraint	datalog programs	1960-6
It	as	constraint	an implementation	1960-7
It	can be viewed	action	an implementation	1960-7
an implementation	of	constraint	model	1960-7
model		sequential	the semantics	1960-7
<B>	Let	action	P	1961-1
P	be	attribute	a datalog program	1961-1
a datalog program	and	conjunctive	K	1961-1
K		sequential	an instance	1961-1
an instance	over	constraint	sch	1961-1
sch		sequential	P	1961-1
A fact		sequential	A	1961-2
A	is	attribute	an immediate consequence	1961-2
an immediate consequence	for	constraint	K	1961-2
K	and	conjunctive	P	1961-2
P	if	constraint	A ∈ K	1961-2
P	either	conjunctive	A ∈ K	1961-2
A ∈ K		sequential	R	1961-2
R	for	constraint	some edb relation R	1961-2
some edb relation R	or	conjunctive	A	1961-2
A	←	sequential	A1	1961-2
<B>	.	sequential	<B>	1961-3
<B>	.	sequential	<B>	1961-4
<B>	is	attribute	an instantiation	1961-5
an instantiation	of	constraint	a rule	1961-5
a rule	in	constraint	P	1961-5
P	and	conjunctive	each Ai	1961-5
each Ai	in	constraint	K	1961-5
each Ai	is	attribute	K	1961-5
<B>	For	constraint	each K	1962-1
each K		sequential	TP K	1962-1
TP K	of	constraint	all facts	1962-1
TP K	consists	action	all facts	1962-1
all facts		sequential	A	1962-1
A		sequential	that	1962-1
that	are	attribute	immediate consequences	1962-1
immediate consequences	for	constraint	K	1962-1
K	and	conjunctive	P	1962-1
We	next note	action	some simple mathematical properties	1963-1
some simple mathematical properties	of	constraint	the operator TP	1963-1
the operator TP	over	constraint	sets	1963-1
sets	of	constraint	instances	1963-1
We	first define	action	two useful properties	1963-2
<B>	For	constraint	an operator	1963-3
an operator		sequential	T	1963-3
The proof	of	constraint	the next lemma	1964-1
the next lemma	and	conjunctive	Exercise 12.9	1964-1
the next lemma	is	attribute	straightforward	1964-1
the next lemma	is omitted	action	Exercise 12.9	1964-1
the next lemma	see	action	Exercise 12.9	1964-1
Lemma		sequential	12.3.1	1965-1
It	that	constraint	P	1966-1
It	turns out	action	P	1966-1
P		sequential	I	1966-1
I	as	constraint	model	1966-1
I	by	constraint	model	1966-1
I	defined	action	model	1966-1
model		sequential	the semantics	1966-1
the semantics	is	attribute	a fixpoint	1966-1
a fixpoint	of	constraint	TP	1966-1
<B>	In	constraint	it	1967-1
it	is	attribute	the minimum fixpoint	1967-1
the minimum fixpoint	containing	action	I	1967-1
<B>	is shown next	action	<B>	1967-2
Theorem		sequential	12.3.2	1968-1
Proof	that	constraint	P	1969-1
Proof	Observe first	action	P	1969-1
P		sequential	I	1969-1
I	is	attribute	a fixpoint	1969-1
a fixpoint	of	constraint	TP	1969-1
P		sequential	I	1969-2
I	is	attribute	Thus the minimum fixpoint	1969-2
Thus the minimum fixpoint	of	constraint	P	1969-2
P	containing	action	I	1969-2
The fixpoint definition	of	constraint	the semantics	1970-1
the semantics	of	constraint	P	1970-1
P	presents	action	the advantage	1970-1
the advantage	of	constraint	a constructive definition	1970-1
the advantage	to	constraint	a constructive definition	1970-1
the advantage	leading	action	a constructive definition	1970-1
a constructive definition	of	constraint	P	1970-1
P		sequential	I	1970-1
<B>	In	constraint	logic programming	1970-2
logic programming	is shown	action	fixpoint theory	1970-2
logic programming	using	action	fixpoint theory	1970-2
fixpoint theory	using	action	Knaster	1970-2
Knaster		sequential	Tarski	1970-2
Tarski	and	conjunctive	Kleene	1970-2
Kleene		sequential	theorems	1970-2
the database framework	than	constraint	logic programming	1970-3
the database framework	is	attribute	However much simpler	1970-3
logic programming		sequential	the general one	1970-3
the general one	due to	constraint	primarily the lack	1970-3
primarily the lack	of	constraint	function symbols	1970-3
We	to	constraint	the construction	1970-4
We	therefore choose	action	the construction	1970-4
We	show directly	action	the construction	1970-4
the construction	without	constraint	the formidable machinery	1970-4
the formidable machinery	of	constraint	the theory	1970-4
the theory	of	constraint	fixpoints	1970-4
fixpoints	in	constraint	complete lattices	1970-4
<B>	In	constraint	Remark	1970-5
Remark		sequential	12.3.5 Datalog	1970-5
12.3.5 Datalog		sequential	we	1970-5
we	sketch	action	the more standard proof	1970-5
the more standard proof		sequential	that	1970-5
that	has	action	the advantage	1970-5
the advantage	of	constraint	the larger context	1970-5
the advantage	to	constraint	the larger context	1970-5
the advantage	being	attribute	applicable	1970-5
the larger context	of	constraint	logic programming	1970-5
<B>	Given	action	an instance	1971-1
an instance		sequential	I	1971-1
I		sequential	edb	1971-1
edb		sequential	P	1971-1
P		sequential	one	1971-1
one	can compute	action	TP	1971-1
TP		sequential	I	1971-1
I		sequential	T	1971-1
T		sequential	2	1971-1
2		sequential	I	1971-1
I		sequential	T 3	1971-1
T 3		sequential	I	1971-1
I		sequential	<B>	1971-1
Clearly P P		sequential	I	1971-2
I		sequential	⊆ TP	1971-2
⊆ TP		sequential	I	1971-2
I		sequential	⊆ T 2 P	1971-2
⊆ T 2 P		sequential	I ⊆ T 3	1971-2
I ⊆ T 3		sequential	I	1971-2
<B>	.	sequential	<B>	1971-3
<B>	.	sequential	<B>	1971-4
⊆ B		sequential	P	1971-5
P		sequential	I	1971-5
P	from	constraint	the fact	1972-1
P	follows immediately	action	the fact	1972-1
the fact	that	constraint	I	1972-1
I	⊆	action	TP	1972-1
TP		sequential	I	1972-1
I	and	conjunctive	the monotonicity	1972-1
the monotonicity	of	constraint	TP	1972-1
<B>	Let	action	N	1972-2
N	be	attribute	the number	1972-2
the number	of	constraint	facts	1972-2
facts	in	constraint	B	1972-2
B		sequential	P	1972-2
P		sequential	I	1972-2
<B>	that	constraint	N	1972-3
<B>	Observe	action	N	1972-3
N	on	constraint	I	1972-3
N	depends	action	I	1972-3
The sequence		sequential	T	1972-4
T		sequential	i	1972-4
i		sequential	I	1972-4
I		sequential	P	1972-4
P		sequential	i	1972-4
i	reaches	action	a fixpoint	1972-4
a fixpoint	after	constraint	most N steps	1972-4
a fixpoint	at	constraint	most N steps	1972-4
<B>	for	constraint	i	1972-5
<B>	is	attribute	each	1972-5
i		sequential	≥	1972-5
≥		sequential	N	1972-5
N		sequential	T i	1972-5
T i		sequential	I	1972-5
I	=	sequential	T N	1972-5
T N		sequential	I	1972-5
<B>	In	constraint	TP	1972-6
TP		sequential	T N	1972-6
T N		sequential	I	1972-6
I	=	sequential	T N	1972-6
T N		sequential	I	1972-6
I		sequential	T N	1972-6
T N		sequential	I	1972-6
I	is	attribute	so a fixpoint P P P	1972-6
so a fixpoint P P P	of	constraint	T P	1972-6
We	denote	action	this fixpoint	1972-7
this fixpoint	by	constraint	T ω	1972-7
T ω		sequential	I	1972-7
P Example 12.3.3		sequential	P Example 12.3.3	1973-1
<B>	Consider	action	the input instance	1974-1
the input instance		sequential	I	1974-1
I	=	sequential	G	1974-1
I	{	sequential	G	1974-1
G		sequential	1	1974-1
1		sequential	2	1974-1
2		sequential	G	1974-1
G		sequential	2	1974-1
2		sequential	3	1974-1
3		sequential	G	1974-1
G		sequential	3	1974-1
3		sequential	4	1974-1
4		sequential	G	1974-1
G		sequential	4	1974-1
4		sequential	5	1974-1
5		sequential	}	1974-1
we	Then have	action	TP	1975-1
TP		sequential	I	1975-1
I	=	sequential	I	1975-1
I	{	sequential	T	1975-1
I	∪	action	T	1975-1
T		sequential	1	1975-1
1		sequential	2	1975-1
2		sequential	T	1975-1
T		sequential	2	1975-1
2		sequential	3	1975-1
3		sequential	T	1975-1
T		sequential	3	1975-1
3		sequential	4	1975-1
4		sequential	T	1975-1
T		sequential	4	1975-1
4		sequential	5	1975-1
5		sequential	}	1975-1
}		sequential	T C T	1975-1
T C T		sequential	2 P T C T C T	1975-1
2 P T C T C T		sequential	3	1975-1
3		sequential	I	1975-1
I	=	sequential	T 2	1975-1
T 2		sequential	I	1975-1
I		sequential	∪	1975-1
∪	{	sequential	T	1975-1
T		sequential	1	1975-1
1		sequential	4	1975-1
4		sequential	T	1975-1
T		sequential	2	1975-1
2		sequential	5	1975-1
5		sequential	} PT	1975-1
} PT		sequential	C PT C T	1975-1
C PT C T		sequential	4 P T C PT C T 5	1975-1
4 P T C PT C T 5		sequential	I	1975-1
I	=	sequential	T	1975-1
T		sequential	4	1975-1
4		sequential	I	1975-1
PT C		sequential	PT	1976-1
PT		sequential	C	1976-1
C		sequential	Thus T ω	1976-1
Thus T ω		sequential	I	1976-1
I	=	sequential	T 4	1976-1
T 4		sequential	I	1976-1
PT C PT C		sequential	PT C PT C	1977-1
P Theorem 12.3.4		sequential	P Theorem 12.3.4	1978-1
T ω		sequential	I	1978-2
I	Then =	sequential	P	1978-2
P		sequential	I	1978-2
P Proof	By	constraint	Theorem	1979-1
Theorem		sequential	12.3.2	1979-1
12.3.2		sequential	it	1979-1
it	to	constraint	T ω I	1979-1
it	that	constraint	T ω I	1979-1
it	suffices	action	T ω I	1979-1
it	show	action	T ω I	1979-1
T ω I	is	attribute	the minimum fixpoint	1979-1
the minimum fixpoint	of	constraint	T P P	1979-1
T P P	containing	action	I	1979-1
<B>	As	constraint	TP T	1979-2
<B>	noted earlier	action	TP T	1979-2
TP T		sequential	T ω	1979-2
T ω		sequential	I	1979-2
P P		sequential	T N P P P	1980-1
T N P P P		sequential	N	1980-1
N	is	attribute	where the number	1980-1
where the number	of	constraint	facts	1980-1
facts	in	constraint	B	1980-1
B		sequential	P	1980-1
P		sequential	I	1980-1
T ω		sequential	I	1980-2
I	is	attribute	Therefore a fixpoint	1980-2
Therefore a fixpoint	of	constraint	T P P	1980-2
T P P		sequential	that	1980-2
that		sequential	con-	1980-2
con-	tains	action	I	1980-2
<B>	To	constraint	it	1981-1
<B>	that	constraint	it	1981-1
<B>	show	action	it	1981-1
it	is	attribute	minimal	1981-1
it	consider	action	an arbitrary fixpoint J	1981-1
an arbitrary fixpoint J	of	constraint	TP	1981-1
TP	containing	action	I	1981-1
Then J ⊇ T		sequential	0	1981-2
0		sequential	I	1981-2
I	=	sequential	I	1981-2
<B>	By	constraint	induction	1981-3
induction	on	constraint	i	1981-3
i		sequential	J ⊇ T	1981-3
J ⊇ T		sequential	i	1981-3
i		sequential	I	1981-3
I	for	constraint	i	1981-3
i		sequential	so J ⊇ T ω	1981-3
so J ⊇ T ω		sequential	I	1981-3
T ω		sequential	I	1981-4
I	is	attribute	Thus the P P P P minimum fixpoint	1981-4
Thus the P P P P minimum fixpoint	of	constraint	TP	1981-4
TP	containing	action	I	1981-4
The smallest integer		sequential	i	1982-1
i	that	constraint	T i	1982-1
T i		sequential	I	1982-1
I	=	sequential	T ω	1982-1
T ω		sequential	I	1982-1
I	is called	action	the stage	1982-1
the stage	for	constraint	P	1982-1
P	and	conjunctive	I	1982-1
I	and	conjunctive	P	1982-1
I	is	attribute	P	1982-1
P	denoted	action	P stage	1982-1
P stage		sequential	P	1982-1
P		sequential	I	1982-1
<B>	As	constraint	stage	1982-2
<B>	already noted	action	stage	1982-2
stage		sequential	P	1982-2
P		sequential	I	1982-2
I		sequential	≤	1982-2
≤		sequential	N	1982-2
N	=	sequential	|B	1982-2
|B		sequential	P	1982-2
P		sequential	I	1982-2
Evaluation		sequential	Evaluation	1983-1
We	explain	action	the algorithm	1984-1
the algorithm	in	constraint	an example	1984-1
We	extend	action	relational algebra	1984-2
relational algebra	with	constraint	a while operator	1984-2
a while operator		sequential	that	1984-2
that	allows	action	us	1984-2
us	to	constraint	an algebraic expression	1984-2
us	iterate	action	an algebraic expression	1984-2
an algebraic expression	while	constraint	some condition	1984-2
some condition	holds	action	<B>	1984-2
The resulting language	in	constraint	Chapter 17	1984-3
The resulting language	is studied extensively	action	Chapter 17	1984-3
<B>	Consider again	action	the transitive closure query	1985-1
We	to	constraint	the transitive closure	1985-2
We	wish	action	the transitive closure	1985-2
We	compute	action	the transitive closure	1985-2
the transitive closure	of	constraint	relation G	1985-2
relation G	in	constraint	relation T	1985-2
Both relations	over	constraint	AB	1985-3
Both relations	are	attribute	AB	1985-3
This computation	by	constraint	the following program	1985-4
This computation	is performed	action	the following program	1985-4
the following program		sequential	T	1985-4
T	=	sequential	G	1985-4
G	while	constraint	q	1985-4
q		sequential	T	1985-4
T	=	sequential	T	1985-4
T	do	action	T	1985-4
T	=	sequential	q	1985-4
q		sequential	T	1985-4
T		sequential	q	1985-4
q		sequential	T	1985-4
T	where =	sequential	G ∪ πAB	1985-4
G ∪ πAB		sequential	δ	1985-4
δ		sequential	B→C	1985-4
B→C		sequential	G	1985-4
G		sequential	δ	1985-4
δ		sequential	A→C	1985-4
A→C		sequential	T	1985-4
The while construct	for	constraint	only recursion	1986-1
The while construct	is needed	action	only recursion	1986-1
<B>	Let	action	us	1986-2
us	consider again	action	the nonrecursive datalog	1986-2
the nonrecursive datalog	of	constraint	Chapter 4	1986-2
<B>	Let	action	P	1986-3
P	be	attribute	a datalog program	1986-3
<B>	Consider	action	the graph	1986-4
the graph		sequential	sch	1986-4
sch		sequential	P	1986-4
P		sequential	EP	1986-4
EP		sequential	S	1986-4
S		sequential	S	1986-4
S	is	attribute	where an edge	1986-4
where an edge	in	constraint	EP	1986-4
EP	if	constraint	S′	1986-4
S′	in	constraint	the head	1986-4
S′	occurs	action	the head	1986-4
the head	of	constraint	some rule	1986-4
some rule		sequential	r	1986-4
r	in	constraint	P	1986-4
P	and	conjunctive	S	1986-4
S	in	constraint	the body	1986-4
S	occurs	action	the body	1986-4
the body	of	constraint	r	1986-4
We	that	constraint	nr-datalog programs	1986-5
We	mentioned already	action	nr-datalog programs	1986-5
nr-datalog programs	to	constraint	SPJRU queries	1986-5
nr-datalog programs	are	attribute	equivalent	1986-5
SPJRU queries	see	action	Section 4.5	1986-5
It	to	constraint	each nr-datalog program P	1986-6
It	that	constraint	each nr-datalog program P	1986-6
It	for	constraint	each nr-datalog program P	1986-6
It	is	attribute	also easy	1986-6
It	see	action	each nr-datalog program P	1986-6
each nr-datalog program P		sequential	there	1986-6
there	exists	action	a constant d	1986-6
a constant d	that	constraint	I	1986-6
a constant d	for	constraint	I	1986-6
I	over	constraint	edb	1986-6
edb		sequential	P	1986-6
P		sequential	stage	1986-6
stage		sequential	P	1986-6
P		sequential	I	1986-6
I	≤	action	d	1986-6
<B>	See	action	Exercise 12.29	1986-7
Programs	for	constraint	which	1986-8
which	happens	action	<B>	1986-8
which	are called	action	<B>	1986-8
which	bounded	action	<B>	1986-8
We	examine	action	this property	1986-9
this property	in	constraint	more detail	1986-9
more detail	in	constraint	Section 12.5	1986-9
Datalog Remark 12.3.5		sequential	Datalog Remark 12.3.5	1987-1
This machinery	is needed	action	the analog	1987-2
This machinery	when proving	action	the analog	1987-2
the analog	of	constraint	that theorem	1987-2
that theorem	in	constraint	the more general context	1987-2
the more general context	of	constraint	logic programming	1987-2
A partially ordered set		sequential	U	1987-3
U		sequential	≤	1987-3
≤	is	attribute	a complete lattice	1987-3
a complete lattice	if	constraint	each subset	1987-3
each subset	has	action	a least upper bound	1987-3
a least upper bound	and	conjunctive	a greatest lower bound	1987-3
a greatest lower bound		sequential	denoted sup	1987-3
denoted sup	and	conjunctive	<B>	1987-3
<B>	In	constraint	inf	1987-4
inf		sequential	U	1987-4
U	and	conjunctive	sup	1987-4
U	is denoted	action	sup	1987-4
sup		sequential	U	1987-4
U	is denoted	action	<B>	1987-4
<B>	To	constraint	each datalog program	1988-1
each datalog program		sequential	P	1988-1
P	and	conjunctive	instance	1988-1
instance		sequential	I	1988-1
I		sequential	we	1988-1
we	associate	action	the program PI	1988-1
the program PI	of	constraint	the rules	1988-1
the program PI	consisting	action	the rules	1988-1
the rules	of	constraint	P	1988-1
P	and	conjunctive	one rule	1988-1
one rule		sequential	R	1988-1
R		sequential	u	1988-1
u	for	constraint	each fact	1988-1
each fact		sequential	R	1988-1
R		sequential	u	1988-1
u	in	constraint	I	1988-1
We	consider	action	the complete lattice	1988-2
the complete lattice	with	constraint	inst	1988-2
the complete lattice	formed	action	inst	1988-2
inst		sequential	sch	1988-2
sch		sequential	P	1988-2
P		sequential	⊆	1988-2
⊆	and	conjunctive	the operator TP	1988-2
the operator TP	by	constraint	<B>	1988-2
the operator TP	defined	attribute	the following	1988-2
The operator TP	on	constraint	inst	1988-3
inst		sequential	sch	1988-3
sch		sequential	P	1988-3
P		sequential	⊆	1988-3
⊆	is	attribute	continuous	1988-3
I		sequential	Knaster	1989-1
Knaster		sequential	Tarski	1989-1
Tarski		sequential	The theorem	1989-1
The theorem	that	constraint	a monotone operator	1989-1
The theorem	states	action	a monotone operator	1989-1
a monotone operator	in	constraint	a complete lattice	1989-1
a complete lattice	has	action	a least fixpoint	1989-1
a least fixpoint		sequential	that	1989-1
that	inf	constraint	x	1989-1
that	equals	action	x	1989-1
x	x	sequential	∈	1989-1
∈		sequential	U	1989-1
U		sequential	T	1989-1
T		sequential	x	1989-1
x		sequential	≤	1989-1
≤		sequential	x }	1989-1
the least fixpoint	of	constraint	TPI	1989-2
TPI	Thus exists	action	<B>	1989-2
Fixpoint theory	also provides	action	the constructive definition	1989-3
the constructive definition	of	constraint	the least fixpoint	1989-3
the least fixpoint	for	constraint	continuous operators	1989-3
Kleene		sequential	theorem	1989-4
theorem	that	constraint	T	1989-4
theorem	if	constraint	T	1989-4
theorem	Indeed states	action	T	1989-4
T	is	attribute	a continuous operator	1989-4
a continuous operator	on	constraint	a complete lattice	1989-4
a complete lattice		sequential	its least fixpoint	1989-4
its least fixpoint	is	attribute	sup	1989-4
sup		sequential	Ki	1989-4
Ki	i ≥	sequential	0 }	1989-4
0 }		sequential	K0	1989-4
K0	for	constraint	each i	1989-4
K0	and	conjunctive	each i	1989-4
K0	where =	sequential	each i	1989-4
K0	⊥	sequential	each i	1989-4
<B>	in	constraint	our case	1989-5
our case		sequential	⊥	1989-5
⊥	and	conjunctive	I	1989-5
⊥	Now =	sequential	I	1989-5
I		sequential	PI	1989-5
PI	with	constraint	P	1989-5
PI	coincides	action	P	1989-5
P		sequential	I	1989-5
<B>	In	constraint	logic programming	1990-1
logic programming		sequential	function symbols	1990-1
function symbols	are also considered	action	Example 12.1.4	1990-1
function symbols	see	action	Example 12.1.4	1990-1
<B>	In	constraint	this context	1990-2
this context		sequential	the sequence	1990-2
the sequence	of	constraint	T i	1990-2
T i		sequential	I	1990-2
I		sequential	P i 0	1990-2
P i 0	in	constraint	a finite number	1990-2
P i 0	does not generally converge	action	a finite number	1990-2
a finite number		sequential	I	1990-2
I	of	constraint	steps	1990-2
steps		sequential	the fixpoint evaluation	1990-2
the fixpoint evaluation	is	attribute	so no longer constructive	1990-2
it	in	constraint	countably many steps	1990-3
it	However does converge	action	countably many steps	1990-3
countably many steps	to	constraint	the least fixpoint	1990-3
the least fixpoint		sequential	T i	1990-3
T i		sequential	∅	1990-3
∅		sequential	i	1990-3
i	≥	action	0 }	1990-3
fixpoint theory	is	attribute	Thus useful PI	1990-4
Thus useful PI	with	constraint	logic programs	1990-4
Thus useful PI	primarily when dealing	action	logic programs	1990-4
logic programs	with	constraint	function symbols	1990-4
It	is	attribute	an overkill	1990-5
an overkill	in	constraint	the simpler context	1990-5
the simpler context	of	constraint	datalog	1990-5
Proof Theoretic Approach		sequential	Proof Theoretic Approach	1991-1
The first step	to	constraint	what	1992-1
The first step	is	attribute	what	1992-1
The first step	define	action	what	1992-1
what	by	constraint	proof	1992-1
what	is meant	action	proof	1992-1
A proof tree	of	constraint	a fact A	1992-2
a fact A	from	constraint	I	1992-2
I	and	conjunctive	P	1992-2
P	is	attribute	a labeled tree where	1992-2
Such a tree	provides	action	a proof fact	1993-1
a proof fact	of	constraint	the A	1993-1
rule		sequential	1 S	1994-1
1 S		sequential	1,6	1994-1
1,6		sequential	S rule	1994-1
S rule		sequential	2 T	1994-1
2 T		sequential	1,5	1994-1
1,5		sequential	R	1994-1
R		sequential	5	1994-1
5		sequential	a,6	1994-1
a,6		sequential	T rule	1994-1
T rule		sequential	3 R	1994-1
3 R		sequential	1	1994-1
1		sequential	a	1994-1
a	,	sequential	2	1994-1
2		sequential	R	1994-1
R		sequential	2	1994-1
2		sequential	b,3	1994-1
b,3		sequential	T	1994-1
T		sequential	3,5 b	1994-1
3,5 b		sequential	T	1994-1
T		sequential	R	1994-1
R		sequential	3	1994-1
3		sequential	a	1994-1
a		sequential	4	1994-1
4		sequential	R	1994-1
R		sequential	4	1994-1
4		sequential	a	1994-1
a		sequential	5	1994-1
5		sequential	Figure	1994-1
Figure		sequential	12.3	1994-1
12.3		sequential	Proof tree Example 12.4.1	1994-1
Proof tree Example 12.4.1	Consider	action	the following program	1994-1
the following program		sequential	S	1994-1
S		sequential	x1	1994-1
x1		sequential	x3	1994-1
x3		sequential	T	1994-1
T		sequential	x1	1994-1
x1		sequential	x2	1994-1
x2		sequential	R	1994-1
R		sequential	x2	1994-1
x2		sequential	a	1994-1
a		sequential	x3	1994-1
x3		sequential	T	1994-1
T		sequential	x1	1994-1
x1		sequential	x4	1994-1
x4		sequential	R	1994-1
R		sequential	x1	1994-1
x1		sequential	a	1994-1
a		sequential	x2	1994-1
x2		sequential	R	1994-1
R		sequential	x2	1994-1
x2		sequential	b	1994-1
b		sequential	x3	1994-1
x3		sequential	T	1994-1
T		sequential	x3	1994-1
x3		sequential	x4	1994-1
x4		sequential	T	1994-1
T		sequential	x1	1994-1
x1		sequential	x3	1994-1
x3		sequential	R	1994-1
R		sequential	x1	1994-1
x1		sequential	a	1994-1
a		sequential	x2	1994-1
x2		sequential	R	1994-1
R		sequential	x2	1994-1
x2		sequential	a	1994-1
a		sequential	x3	1994-1
The reader	with	constraint	context	1995-1
context		sequential	languages	1995-1
languages	will notice	action	the similarity	1995-1
the similarity	between	constraint	proof trees	1995-1
proof trees	and	conjunctive	derivation trees	1995-1
derivation trees	in	constraint	context	1995-1
context		sequential	languages	1995-1
This connection	in	constraint	the case	1995-2
This connection	is	attribute	especially strong	1995-2
the case	of	constraint	datalog programs	1995-2
datalog programs		sequential	that	1995-2
that	have	action	the form	1995-2
the form	of	constraint	the one	1995-2
the one	in	constraint	Example 12.4.1	1995-2
<B>	in	constraint	the last section	1996-1
<B>	will be exploited	action	the last section	1996-1
the last section	of	constraint	this chapter	1996-1
Proof trees	provide	action	proofs	1997-1
proofs	of	constraint	facts	1997-1
It	to	constraint	a fact	1997-2
It	that	constraint	a fact	1997-2
It	is	attribute	straightforward	1997-2
It	show	action	a fact	1997-2
a fact		sequential	A	1997-2
A	in	constraint	P	1997-2
A	is	attribute	P	1997-2
P		sequential	I	1997-2
I		sequential	iff	1997-2
iff		sequential	there	1997-2
there	exists	action	a proof tree	1997-2
a proof tree	for	constraint	A	1997-2
A	from	constraint	I	1997-2
I	and	conjunctive	P	1997-2
<B>	given	action	a fact A	1997-3
a fact A	to	constraint	one	1997-3
a fact A	prove	action	one	1997-3
one	for	constraint	a proof	1997-3
one	Now can look	action	a proof	1997-3
a proof	either	conjunctive	bottom	1997-3
bottom	or	conjunctive	<B>	1997-3
bottom	top down	action	<B>	1997-3
bottom up		sequential	The approach	1998-1
The approach	is	attribute	an alternative way	1998-1
an alternative way	of	constraint	the constructive fixpoint technique	1998-1
an alternative way	at	constraint	the constructive fixpoint technique	1998-1
an alternative way	looking	action	the constructive fixpoint technique	1998-1
One	with	constraint	the facts	1998-2
One	begins	action	the facts	1998-2
the facts	from	constraint	I	1998-2
I	and	conjunctive	the rules	1998-2
I	uses	action	the rules	1998-2
the rules	to	constraint	new facts	1998-2
the rules	infer	action	new facts	1998-2
new facts	like	constraint	much the immediate consequence operator	1998-2
<B>	until	constraint	no new facts	1998-3
<B>	is done repeatedly	action	no new facts	1998-3
no new facts	can be inferred	action	<B>	1998-3
The rules	as	constraint	factories	1998-4
The rules	are used	action	factories	1998-4
factories	producing	action	new facts	1998-4
new facts	from	constraint	already proven ones	1998-4
<B>	eventually yields	action	all facts	1999-1
all facts		sequential	that	1999-1
that	as	constraint	the fixpoint approach	1999-1
that	and	conjunctive	the fixpoint approach	1999-1
that	can be proven	attribute	essentially the same	1999-1
that	is	attribute	essentially the same	1999-1
<B>	In	constraint	contrast	2000-1
contrast	to	constraint	the bottom up	2000-1
the bottom up	and	conjunctive	fixpoint	2000-1
fixpoint	approaches	attribute	top down	2000-1
the approach	allows	action	one	2000-1
one	to	constraint	the search	2000-1
one	direct	action	the search	2000-1
the search	for	constraint	a proof	2000-1
a proof		sequential	one	2000-1
one	in	constraint	particular facts	2000-1
one	is	attribute	when only interested	2000-1
one	proving	action	particular facts	2000-1
Datalog		sequential	Datalog	2001-1
12.1		sequential	12.1	2001-2
<B>		sequential	the approach	2001-3
the approach	Then will never consider	action	atoms	2001-3
atoms	involving intuitively	action	stations	2001-3
stations	on	constraint	Line 9	2001-3
Line 9	because	constraint	they	2001-3
they	from	constraint	Odeon	2001-3
they	are	attribute	are not reachable	2001-3
Odeon	or	conjunctive	Louvre	2001-3
<B>		sequential	the approach	2001-4
the approach	inhibits	action	the indiscriminate inference	2001-4
the indiscriminate inference	of	constraint	facts	2001-4
facts		sequential	that	2001-4
that	to	constraint	the facts	2001-4
that	are	attribute	irrelevant	2001-4
the facts	of	constraint	interest	2001-4
<B>		sequential	The approach	2002-1
The approach	is described next	action	<B>	2002-1
<B>	takes	action	us	2002-2
us	to	constraint	the field	2002-2
the field	of	constraint	logic programming	2002-2
<B>	But	conjunctive	we	2002-3
we	first need	action	some notation	2002-3
some notation		sequential	which	2002-3
which	will remind once again	action	us	2002-3
us	that	constraint	an easy access	2002-3
us	To	constraint	an easy access	2002-3
us	bar	action	an easy access	2002-3
an easy access	to	constraint	newcomers	2002-3
newcomers		sequential	every scientific domain	2002-3
every scientific domain	has introduced	action	its own terminology	2002-3
its own terminology	and	conjunctive	notation	2002-3
notation		sequential	Apt91	2002-3
Notation		sequential	Notation	2003-1
the Ai Bj	are	attribute	where positive literals	2004-1
where positive literals	is called	action	a clause	2004-1
Such a clause	in	constraint	clausal form	2004-2
Such a clause	is written as	action	clausal form	2004-2
definite T		sequential	x	2005-1
x		sequential	y	2005-1
y		sequential	R	2005-1
R		sequential	x	2005-1
x		sequential	z	2005-1
z		sequential	T	2005-1
T		sequential	z	2005-1
z		sequential	y	2005-1
y		sequential	T	2005-1
T		sequential	x	2005-1
x		sequential	y ∨ ¬R	2005-1
y ∨ ¬R		sequential	x	2005-1
x		sequential	z	2005-1
z		sequential	¬T	2005-1
¬T		sequential	z	2005-1
z		sequential	y	2005-1
y		sequential	unit T	2005-1
unit T		sequential	x	2005-1
x		sequential	y	2005-1
y		sequential	T	2005-1
T		sequential	x	2005-1
x		sequential	y	2005-1
y		sequential	goal	2005-1
goal		sequential	<B>	2005-1
<B>	because	constraint	it	2005-2
<B>	is	attribute	it	2005-2
it	to	constraint	the disjunction	2005-2
it	corresponds	action	the disjunction	2005-2
the disjunction	of	constraint	an empty set	2005-2
an empty set	of	constraint	formulas	2005-2
<B>		sequential	The proof technique	2006-1
The proof technique	introduced here	action	SLD resolution	2006-1
The proof technique	is called	action	SLD resolution	2006-1
Goals	as	constraint	the basic focus	2006-2
Goals	serve	action	the basic focus	2006-2
the basic focus	of	constraint	activity	2006-2
activity	in	constraint	SLD resolution	2006-2
<B>	As	constraint	we	2006-3
we	shall see	action	the procedure	2006-3
the procedure	with	constraint	a goal	2006-3
the procedure	begins	action	a goal	2006-3
a goal		sequential	<B>	2006-3
A correct answer	of	constraint	this goal	2006-4
this goal	on	constraint	input	2006-4
input		sequential	I	2006-4
I	is	attribute	any value	2006-4
any value		sequential	that	2006-4
that		sequential	St Reachable	2006-4
St Reachable		sequential	a	2006-4
a		sequential	Concorde	2006-4
Concorde	and	conjunctive	Li	2006-4
Li		sequential	Reachable	2006-4
Reachable		sequential	a 9	2006-4
a 9	by	constraint	P metro	2006-4
a 9	are implied	action	P metro	2006-4
P metro	top	attribute	down	2006-4
I approach	of	constraint	a new goal	2006-4
I approach	consists	action	a new goal	2006-4
I approach	obtaining	action	a new goal	2006-4
a new goal	from	constraint	a previous goal	2006-4
the procedure	if	constraint	the final goal	2006-5
the procedure	Finally is deemed	attribute	successful	2006-5
the final goal	reached	attribute	empty	2006-5
the final goal	is	attribute	empty	2006-5
The standard exposition	of	constraint	SLD resolution	2007-1
SLD resolution	on	constraint	definite clauses	2007-1
SLD resolution	is based	action	definite clauses	2007-1
There	is	attribute	a subtle distinction	2007-2
a subtle distinction	between	constraint	datalog rules	2007-2
datalog rules	and	conjunctive	definite clauses	2007-2
<B>	In	constraint	a datalog unit clause	2007-3
a datalog unit clause	be	attribute	must ground	2007-3
We	will briefly mention	action	some minor consequences	2007-4
some minor consequences	of	constraint	this distinction	2007-4
<B>	ignores	action	the distinction	2008-1
the distinction	between	constraint	edb	2008-1
edb	and	conjunctive	idb	2008-1
idb		sequential	relations	2008-1
relations		sequential	which	2008-1
which	for	constraint	PI	2008-1
which	no longer exists	action	PI	2008-1
Example		sequential	12.4.2	2009-1
The rules	of	constraint	PI	2009-2
PI	Up	constraint	SLD resolution	2009-2
PI	Before	constraint	SLD resolution	2009-2
PI	are	attribute	Warm	2009-2
PI	discussing	action	SLD resolution	2009-2
SLD resolution	as	constraint	a warm up	2009-2
a warm up		sequential	we	2009-2
we	at	constraint	a simplified version	2009-2
we	look	action	a simplified version	2009-2
a simplified version	of	constraint	the technique	2009-2
the technique	by	constraint	only ground rules	2009-2
the technique	considering	action	only ground rules	2009-2
<B>	To	constraint	this end	2009-3
this end	consider	action	a datalog program PI	2009-3
a datalog program PI	integrating	action	the facts	2009-3
the facts	of	constraint	fully instantiated rules	2009-3
the facts	consisting only	action	fully instantiated rules	2009-3
fully instantiated rules	with	constraint	no occurrences	2009-3
no occurrences	of	constraint	variables	2009-3
<B>	Consider	action	a ground goal g	2009-4
<B>	as	constraint	logical sentences	2010-1
<B>	Viewed	action	logical sentences	2010-1
logical sentences		sequential	the resolvent	2010-1
the resolvent	of	constraint	g	2010-1
g	with	constraint	r	2010-1
r	by	constraint	g	2010-1
r	is actually implied	action	g	2010-1
g	and	conjunctive	r	2010-1
<B>	by	constraint	clauses	2011-1
<B>	as	constraint	clauses	2011-1
<B>	is best seen	attribute	these	2011-1
<B>	writing explicitly	attribute	these	2011-1
clauses		sequential	Datalog S	2011-1
Datalog S		sequential	1,6	2011-1
1,6		sequential	T	2011-1
T		sequential	1,5	2011-1
1,5		sequential	R	2011-1
R		sequential	5	2011-1
5	a	sequential	,6	2011-1
,6		sequential	R	2011-1
R		sequential	5	2011-1
5	a	sequential	,6	2011-1
,6		sequential	T	2011-1
T		sequential	1,5	2011-1
1,5		sequential	R	2011-1
R		sequential	1	2011-1
1		sequential	a	2011-1
a		sequential	2	2011-1
2		sequential	R	2011-1
R		sequential	2	2011-1
2		sequential	b,3	2011-1
b,3		sequential	T	2011-1
T		sequential	3,5	2011-1
3,5		sequential	R	2011-1
R		sequential	5	2011-1
5	a	sequential	,6	2011-1
,6		sequential	T	2011-1
T		sequential	3,5	2011-1
3,5		sequential	R	2011-1
R		sequential	3	2011-1
3		sequential	a	2011-1
a		sequential	4	2011-1
4		sequential	R	2011-1
R		sequential	4	2011-1
4		sequential	a	2011-1
a		sequential	5	2011-1
5		sequential	R	2011-1
R		sequential	4	2011-1
4		sequential	a	2011-1
a		sequential	5	2011-1
5	←	sequential	R	2011-1
R		sequential	5	2011-1
5		sequential	a ,6	2011-1
a ,6		sequential	Figure SLD ground refutation	2011-1
Figure SLD ground refutation		sequential	12.4	2011-1
<B>	In	constraint	the converse	2012-1
the converse	does not hold	action	<B>	2012-1
<B>		sequential	<B>	2013-1
<B>	.	sequential	<B>	2013-2
<B>	.	sequential	<B>	2013-3
<B>		sequential	<B>	2013-4
<B>	.	sequential	<B>	2013-5
<B>	.	sequential	<B>	2013-6
gq ≡		sequential	gq ≡	2013-7
Example		sequential	12.4.3	2014-1
12.4.3	Consider	action	Example 12.4.1	2014-1
Example 12.4.1	and	conjunctive	the program	2014-1
the program	by	constraint	all possible instantiations	2014-1
the program	obtained	action	all possible instantiations	2014-1
all possible instantiations	of	constraint	the rules	2014-1
the rules	of	constraint	PI	2014-1
PI	in	constraint	Example 12.4.2	2014-1
An SLD ground refutation	in	constraint	Fig	2014-2
An SLD ground refutation	is shown	action	Fig	2014-2
12.4		sequential	12.4	2014-3
It	is	attribute	a refutation	2014-4
a refutation	of	constraint	S	2014-4
a refutation	←	sequential	S	2014-4
S		sequential	1	2014-4
1		sequential	6	2014-4
6		sequential	i.e	2014-4
a proof	of	constraint	S	2014-5
S		sequential	1	2014-5
1		sequential	6	2014-5
<B>	Let	action	us	2015-1
us	now explain	action	refutations	2015-1
refutations	why provide	action	proofs	2015-1
proofs	of	constraint	facts	2015-1
<B>	that	constraint	we	2015-2
<B>	Suppose	action	we	2015-2
we	to	constraint	A1	2015-2
we	wish	action	A1	2015-2
we	prove	action	A1	2015-2
A1		sequential	∧	2015-2
<B>	To	constraint	we	2015-3
<B>	do	attribute	this	2015-3
we	that	constraint	its negation	2015-3
we	may equivalently prove	action	its negation	2015-3
its negation		sequential	<B>	2015-3
A1		sequential	A1	2015-4
Example		sequential	12.4.4	2016-1
<B>	leads	action	us	2016-2
us	to	constraint	turn	2016-2
us	in	constraint	turn	2016-2
us	considering	action	turn	2016-2
turn		sequential	the formulas	2016-2
the formulas		sequential	Goal Rule	2016-2
Goal Rule	used	action	<B>	2016-2
refutations	Thus provide	action	proofs	2017-1
<B>	As	constraint	a consequence	2017-2
a consequence		sequential	a goal	2017-2
a goal	of	constraint	a query	2017-2
a goal	as	constraint	a query	2017-2
a goal	can be thought	action	a query	2017-2
the arrow	with	constraint	a question mark	2018-1
the arrow	Indeed is sometimes denoted	action	a question mark	2018-1
a question mark	in	constraint	goals	2018-1
<B>	For	constraint	instance	2018-2
instance		sequential	we	2018-2
we	sometimes write	action	<B>	2018-2
<B>	that	constraint	the process	2019-1
<B>	Observe	action	the process	2019-1
the process	of	constraint	a proof	2019-1
the process	finding	action	a proof	2019-1
a proof	for	constraint	two reasons	2019-1
a proof	is	attribute	nondeterministic	2019-1
two reasons		sequential	the choice	2019-1
the choice	of	constraint	the literal A	2019-1
the literal A	to	constraint	the rule	2019-1
the literal A	and	conjunctive	the rule	2019-1
the literal A	replace	action	the rule	2019-1
the rule		sequential	that	2019-1
that	to	constraint	it	2019-1
that	is used	action	it	2019-1
that	replace	action	it	2019-1
We	now have	action	a technique	2020-1
a technique	for	constraint	facts	2020-1
a technique	proving	action	facts	2020-1
The benefit	of	constraint	this technique	2020-2
this technique	that	constraint	it	2020-2
this technique	is	attribute	it	2020-2
it	in	constraint	the sense	2020-2
it	and	conjunctive	the sense	2020-2
it	is	attribute	sound	2020-2
the sense	that	constraint	the set	2020-2
the set	of	constraint	facts	2020-2
facts	in	constraint	P	2020-2
P		sequential	I	2020-2
I	with	constraint	the facts	2020-2
I	coincides	action	the facts	2020-2
the facts		sequential	that	2020-2
that	from	constraint	PI	2020-2
that	can be proven	action	PI	2020-2
Theorem		sequential	12.4.5	2021-1
<B>	for	constraint	each ground goal g	2021-2
each ground goal g		sequential	PI	2021-2
PI		sequential	∅	2021-2
∅		sequential	¬g iff	2021-2
¬g iff		sequential	there	2021-2
there	Then exists	action	a refutation	2021-2
a refutation	of	constraint	g	2021-2
g	with	constraint	ground	2021-2
ground		sequential	PI	2021-2
Crux		sequential	Crux	2022-1
The base case	is	attribute	obvious	2023-1
<B>	that	constraint	i	2023-2
<B>	for	constraint	i	2023-2
<B>	Now suppose	attribute	some	2023-2
<B>	holds	attribute	some	2023-2
i	≥	action	0	2023-2
0	and	conjunctive	A1	2023-2
0	let	action	A1	2023-2
<B>	.	sequential	<B>	2023-3
<B>	.	sequential	<B>	2023-4
<B>	be	attribute	ground atoms	2023-5
<B>	Am	action	ground atoms	2023-5
ground atoms		sequential	T i+1	2023-5
T i+1		sequential	∅ A P I	2023-5
∅ A P I	in	constraint	T i+1	2023-5
T i+1		sequential	∅	2023-5
<B>	Consider	action	some j	2023-6
<B>	If	constraint	A P j	2023-7
A P j	is	attribute	an edb fact	2023-7
an edb fact		sequential	we	2023-7
we	to	constraint	back the base case	2023-7
we	are	attribute	back the base case	2023-7
I		sequential	Otherwise Datalog	2023-8
Otherwise Datalog		sequential	S	2023-8
S	x	sequential	1	2023-8
1	x	sequential	3	2023-8
3		sequential	T	2023-8
T	x	sequential	1	2023-8
1	x	sequential	2	2023-8
2		sequential	R	2023-8
R	x	sequential	2	2023-8
2		sequential	a	2023-8
a	x	sequential	3	2023-8
3		sequential	R	2023-8
R	x	sequential	T	2023-8
T	x	sequential	1	2023-8
1	x	sequential	4	2023-8
4		sequential	R	2023-8
R	x	sequential	1	2023-8
1		sequential	a	2023-8
a	x	sequential	2	2023-8
2		sequential	R	2023-8
R	x	sequential	2	2023-8
2		sequential	b	2023-8
b	x	sequential	3	2023-8
3		sequential	T	2023-8
T	x	sequential	3	2023-8
3	x	sequential	4	2023-8
4		sequential	R	2023-8
R		sequential	y T	2023-8
y T	x	sequential	R	2023-8
R		sequential	2	2023-8
2		sequential	b,3	2023-8
b,3		sequential	R	2023-8
R	x	sequential	T	2023-8
T	x	sequential	1	2023-8
1	x	sequential	3	2023-8
3		sequential	R	2023-8
R	x	sequential	1	2023-8
1		sequential	a	2023-8
a	x	sequential	2	2023-8
2		sequential	R	2023-8
R	x	sequential	2	2023-8
2		sequential	a	2023-8
a	x	sequential	3	2023-8
3		sequential	R	2023-8
R		sequential	z R	2023-8
z R	x	sequential	R	2023-8
R		sequential	4	2023-8
4		sequential	a	2023-8
a		sequential	5	2023-8
5		sequential	R	2023-8
R		sequential	5	2023-8
5	a	sequential	,6	2023-8
,6		sequential	Figure	2023-8
Figure		sequential	12.5	2023-8
12.5		sequential	SLD refutation	2023-8
SLD refutation		sequential	there	2023-8
there	exists	action	an instantiation	2023-8
an instantiation		sequential	Aj	2023-8
Aj		sequential	B1	2023-8
<B>	.	sequential	<B>	2023-9
<B>	.	sequential	<B>	2023-10
Bp	of	constraint	some rule	2023-11
some rule	in	constraint	PI	2023-11
PI	that	constraint	B1	2023-11
<B>	.	sequential	<B>	2023-12
<B>	.	sequential	<B>	2023-13
Bp	in	constraint	T i	2023-14
Bp	are	attribute	T i	2023-14
T i		sequential	∅	2023-14
The refutation	of	constraint	A P j	2023-15
A P j	with	constraint	ground	2023-15
ground		sequential	PI	2023-15
PI	as	constraint	<B>	2023-15
PI	is	attribute	<B>	2023-15
PI	follows	action	<B>	2023-15
It	with	constraint	I	2023-16
It	starts	action	I	2023-16
<B>	by	constraint	induction	2024-1
induction		sequential	there	2024-1
there	Now exist	action	refutations of	2024-1
refutations of	←	sequential	<B>	2024-1
<B>	Using	action	these refutations	2024-2
these refutations		sequential	one	2024-2
one	can extend	action	the preceding derivation	2024-2
the preceding derivation	to	constraint	a derivation	2024-2
a derivation	to	constraint	the empty clause	2024-2
a derivation	leading	action	the empty clause	2024-2
the refutations	for	constraint	the Aj	2024-3
the refutations	of	constraint	the Aj	2024-3
the Aj	to	constraint	a refutation	2024-3
the Aj	Furthermore can be combined	action	a refutation	2024-3
the Aj	obtain	action	a refutation	2024-3
a refutation	of	constraint	A1	2024-3
<B>	.	sequential	<B>	2024-4
<B>	.	sequential	<B>	2024-5
<B>	as	constraint	<B>	2024-6
<B>	Am	action	<B>	2024-6
<B>	desired	action	<B>	2024-6
<B>	for	constraint	i	2024-7
<B>	Therefore holds	action	i	2024-7
i	+	sequential	1	2024-7
<B>	By	constraint	induction	2024-8
induction	holds	action	<B>	2024-8
SLD Resolution		sequential	SLD Resolution	2025-1
<B>	In	constraint	addition	2025-2
addition	to	constraint	the goal	2025-2
addition	obtaining	action	the goal	2025-2
the goal		sequential	the process	2025-2
the process	determines	action	an instantiation θ	2025-2
an instantiation θ	for	constraint	the free variables	2025-2
the free variables	of	constraint	the goal g	2025-2
the goal g		sequential	PI	2025-2
PI		sequential	∅	2025-2
∅	|=	sequential	¬θg	2025-2
We	with	constraint	an example	2025-3
We	start	action	an example	2025-3
12.5		sequential	12.5	2025-4
<B>	In	constraint	we	2026-1
we	with	constraint	a goal	2026-1
we	start	action	a goal	2026-1
a goal		sequential	which	2026-1
which	to	constraint	ground	2026-1
which	be	attribute	ground	2026-1
which	does not have	action	ground	2026-1
<B>	that	constraint	we	2027-1
<B>	Suppose	action	we	2027-1
we	to	constraint	Ai	2027-1
we	selected	attribute	a literal	2027-1
we	be replaced	action	Ai	2027-1
Ai	=	sequential	Q	2027-1
Q		sequential	1	2027-1
1		sequential	x2	2027-1
x2		sequential	x5	2027-1
Any rule	for	constraint	the replacement	2027-2
Any rule	used	action	the replacement	2027-2
the replacement	must have	action	Q	2027-2
Q	for	constraint	predicate	2027-2
predicate	in	constraint	the head	2027-2
the head	as	constraint	just the ground case	2027-2
the head	in	constraint	just the ground case	2027-2
<B>	For	constraint	instance	2027-3
instance		sequential	we	2027-3
we	might try	action	some rule	2027-3
some rule		sequential	Q	2027-3
Q		sequential	x1	2027-3
x1		sequential	x4	2027-3
x4		sequential	x3	2027-3
x3		sequential	P	2027-3
P		sequential	x1	2027-3
x1		sequential	x2	2027-3
x2		sequential	P	2027-3
P		sequential	x2	2027-3
x2		sequential	x3	2027-3
x3		sequential	Q	2027-3
Q		sequential	x3	2027-3
x3		sequential	x4	2027-3
x4		sequential	x5	2027-3
We	now have	action	two difficulties	2028-1
<B>	of	constraint	these two difficulties	2029-1
these two difficulties	by	constraint	the variables	2029-1
these two difficulties	is handled easily	action	the variables	2029-1
these two difficulties	renaming	action	the variables	2029-1
the variables	of	constraint	the rules	2029-1
We	shall use	action	the following renaming discipline	2030-1
we	Thus might use instead	action	the rule	2030-2
the rule		sequential	Q	2030-2
Q		sequential	x11	2030-2
x11		sequential	x14	2030-2
x14		sequential	x13	2030-2
x13		sequential	P	2030-2
P		sequential	x11	2030-2
x11		sequential	x12	2030-2
x12		sequential	P	2030-2
P		sequential	x12	2030-2
x12		sequential	x13	2030-2
x13		sequential	Q	2030-2
Q		sequential	x13	2030-2
x13		sequential	x14	2030-2
x14		sequential	x15	2030-2
The second difficulty	requires	action	a more careful approach	2031-1
It	is tackled	action	unification	2031-2
It	using	action	unification	2031-2
unification		sequential	which	2031-2
which	matches	action	the pattern	2031-2
the pattern	of	constraint	the head	2031-2
the pattern	to	constraint	the head	2031-2
the pattern	of	constraint	the head	2031-2
the head	of	constraint	the rule	2031-2
the rule	if	constraint	<B>	2031-2
<B>	In	constraint	the example	2032-1
the example		sequential	unification	2032-1
unification	of	constraint	a substitution θ	2032-1
unification	consists	action	a substitution θ	2032-1
unification	finding	action	a substitution θ	2032-1
a substitution θ		sequential	that θ	2032-1
that θ		sequential	Q	2032-1
Q		sequential	1	2032-1
1		sequential	x2	2032-1
x2		sequential	x5	2032-1
Definition 12.4.6 Let		sequential	Definition 12.4.6 Let	2033-1
A unifier	for	constraint	A	2033-2
A	and	conjunctive	B	2033-2
B	is	attribute	a substitution θ such	2033-2
that		sequential	θ	2033-2
A substitution		sequential	θ	2033-3
θ	than	constraint	a substitution ν	2033-3
θ	is	attribute	more general	2033-3
a substitution ν	denoted	action	θ	2033-3
θ		sequential	ν	2033-3
ν	if	constraint	some substitution	2033-3
ν	for	constraint	some substitution	2033-3
some substitution		sequential	ν′	2033-3
ν′		sequential	ν	2033-3
ν	=	sequential	θ ν′	2033-3
A most general unifier		sequential	mgu	2033-4
mgu	for	constraint	A	2033-4
A	and	conjunctive	B	2033-4
B	is	attribute	a unifier θ	2033-4
a unifier θ	for	constraint	A	2033-4
A		sequential	B	2033-4
B	that	constraint	each unifier	2033-4
B	for	constraint	each unifier	2033-4
each unifier		sequential	ν	2033-4
ν	of	constraint	A	2033-4
A		sequential	B	2033-4
B		sequential	we	2033-4
we	have	action	θ	2033-4
θ		sequential	֒→ ν	2033-4
the relation ֒→	between	constraint	unifiers	2034-1
unifiers	and	conjunctive	<B>	2034-1
unifiers	but	conjunctive	<B>	2034-1
unifiers	is	attribute	Clearly reflexive	2034-1
<B>	Let	action	≈	2034-2
≈	be	attribute	the equivalence relation	2034-2
the equivalence relation	on	constraint	substitutions	2034-2
substitutions	by	constraint	θ	2034-2
substitutions	defined	action	θ	2034-2
θ		sequential	ν iff	2034-2
ν iff		sequential	֒→	2034-2
֒→		sequential	ν	2034-2
ν	and	conjunctive	ν ֒→	2034-2
ν ֒→		sequential	θ	2034-2
<B>	If	constraint	θ	2034-3
θ		sequential	ν	2034-3
ν	for	constraint	each atom A	2034-3
each atom A		sequential	θ	2034-3
θ	and	conjunctive	ν	2034-3
ν	are	attribute	A A the same modulo renaming	2034-3
A A the same modulo renaming	of	constraint	variables	2034-3
Datalog Computing the mgu		sequential	Datalog Computing the mgu	2035-1
<B>	Let	action	R	2035-2
R	be	attribute	a relation	2035-2
a relation	of	constraint	arity p	2035-2
arity p	and	conjunctive	R	2035-2
R		sequential	x1	2035-2
<B>	.	sequential	<B>	2035-3
<B>	.	sequential	<B>	2035-4
xp		sequential	R	2035-5
R		sequential	y1	2035-5
<B>	.	sequential	<B>	2035-6
<B>	.	sequential	<B>	2035-7
yp		sequential	two literals	2035-8
two literals	with	constraint	disjoint sets	2035-8
disjoint sets	of	constraint	variables	2035-8
Compute ≡		sequential	the equivalence relation	2036-1
the equivalence relation	on	constraint	var ∪ dom	2036-1
var ∪ dom	as	constraint	the reflexive transitive closure	2036-1
var ∪ dom	defined	action	the reflexive transitive closure	2036-1
the reflexive transitive closure	of	constraint	xi ≡ yi	2036-1
xi ≡ yi	for	constraint	i	2036-1
i		sequential	1	2036-1
1		sequential	p	2036-1
The mgu	of	constraint	R	2036-2
R		sequential	x1	2036-2
<B>	.	sequential	<B>	2036-3
<B>	.	sequential	<B>	2036-4
xp	and	conjunctive	R	2036-5
R		sequential	y1	2036-5
<B>	.	sequential	<B>	2036-6
<B>	.	sequential	<B>	2036-7
yp	if	constraint	two distinct constants	2036-8
yp	does not exist	action	two distinct constants	2036-8
two distinct constants	in	constraint	the same equivalence class	2036-8
two distinct constants	are	attribute	the same equivalence class	2036-8
their mgu	is	attribute	Otherwise the substitution	2036-9
Otherwise the substitution		sequential	θ	2036-9
θ		sequential	<B>	2036-9
We	that	constraint	the foregoing	2037-1
We	show	action	the foregoing	2037-1
the foregoing	computes	action	an mgu	2037-1
Lemma		sequential	12.4.7	2038-1
<B>	.	sequential	<B>	2038-2
<B>	.	sequential	<B>	2038-3
xp	and	conjunctive	R	2038-4
R		sequential	y1	2038-4
<B>	.	sequential	<B>	2038-5
<B>	.	sequential	<B>	2038-6
yp		sequential	yp	2038-7
Proof Clearly		sequential	θ	2039-1
θ	is	attribute	a unifier	2039-1
a unifier	for	constraint	R	2039-1
R		sequential	x1	2039-1
<B>	.	sequential	<B>	2039-2
<B>	.	sequential	<B>	2039-3
xp	and	conjunctive	R	2039-4
R		sequential	y1	2039-4
<B>	.	sequential	<B>	2039-5
<B>	.	sequential	<B>	2039-6
yp		sequential	yp	2039-7
<B>	Suppose	action	ν	2039-8
ν	is	attribute	another unifier	2039-8
another unifier	for	constraint	the same atoms	2039-8
<B>	Let	action	≡ν	2039-9
≡ν	be	attribute	the equivalence relation	2039-9
the equivalence relation	on	constraint	var ∪ dom	2039-9
var ∪ dom	by	constraint	≡ν y iff	2039-9
var ∪ dom	defined	action	≡ν y iff	2039-9
≡ν y iff		sequential	ν	2039-9
ν		sequential	x	2039-9
x	=	sequential	ν	2039-9
ν		sequential	y	2039-9
<B>	Because	constraint	ν	2039-10
ν	is	attribute	a unifier	2039-10
a unifier		sequential	ν	2039-10
ν		sequential	xi	2039-10
xi	=	sequential	ν	2039-10
ν		sequential	yi	2039-10
It	that	constraint	xi ≡ν yi	2039-11
It	follows	action	xi ≡ν yi	2039-11
xi ≡ν yi		sequential	<B>	2039-11
The following facts	about	constraint	mgu	2040-1
mgu	to	constraint	<B>	2040-1
mgu	are	attribute	important	2040-1
mgu	note	action	<B>	2040-1
Their proof	to	constraint	the reader	2040-2
Their proof	is left	action	the reader	2040-2
the reader		sequential	Exercise	2040-2
Exercise		sequential	12.19	2040-2
<B>	In	constraint	part ii	2040-3
part ii	of	constraint	the lemma	2040-3
the lemma	that	constraint	the mgu	2040-3
the lemma	says	action	the mgu	2040-3
the mgu	of	constraint	two atoms	2040-3
two atoms	if	constraint	it	2040-3
it	exists	attribute	essentially unique	2040-3
it	is	attribute	essentially unique	2040-3
modulo renaming	of	constraint	variables	2040-3
Lemma		sequential	12.4.8	2041-1
We	to	constraint	the notion	2042-1
We	are	attribute	now ready	2042-1
We	rephrase	action	the notion	2042-1
the notion	of	constraint	resolvent	2042-1
resolvent	to	constraint	variables	2042-1
resolvent	incorporate	action	variables	2042-1
<B>	Let	action	g	2042-2
g	≡←	constraint	A1	2042-2
<B>	.	sequential	<B>	2042-3
<B>	.	sequential	<B>	2042-4
Ai		sequential	Ai	2042-5
<B>	.	sequential	<B>	2042-6
<B>	.	sequential	<B>	2042-7
<B>		sequential	r	2042-8
r	≡	sequential	B1	2042-8
B1	←	sequential	B2	2042-8
<B>	.	sequential	<B>	2042-9
<B>	.	sequential	<B>	2042-10
<B>	be	attribute	a goal	2042-11
a goal	and	conjunctive	a rule such	2042-11
the resolvent	of	constraint	g	2043-1
g	with	constraint	θ	2043-1
g	r using	action	θ	2043-1
θ	is	attribute	Then the goal	2043-1
I	is	attribute	an SLD derivation	2044-1
an SLD derivation		sequential	g0	2044-1
g0	=	sequential	g	2044-1
<B>	.	sequential	<B>	2044-2
<B>	.	sequential	<B>	2044-3
gq	with	constraint	PI	2044-4
gq	=	sequential	PI	2044-4
We	now explain	action	the meaning	2045-1
the meaning	of	constraint	such a refutation	2045-1
<B>	As	constraint	the case	2045-2
<B>	in	constraint	the case	2045-2
the case		sequential	the existence	2045-2
the existence	of	constraint	a refutation	2045-2
a refutation	of	constraint	a goal	2045-2
a goal	←	sequential	A1	2045-2
<B>	.	sequential	<B>	2045-3
<B>	.	sequential	<B>	2045-4
<B>	with	constraint	PI	2045-5
PI	as	constraint	a proof	2045-5
PI	can be viewed	action	a proof	2045-5
a proof	of	constraint	the negation	2045-5
the negation	of	constraint	the goal	2045-5
The goal	is	attribute	where x1	2045-6
<B>	.	sequential	<B>	2045-7
<B>	.	sequential	<B>	2045-8
xm	are	attribute	the variables	2045-9
the variables	in	constraint	the goal	2045-9
Its negation	is	attribute	therefore equivalent	2045-10
<B>	is	attribute	not the case	2046-1
not the case		sequential	one	2046-1
one	when allows	action	arbitrary definite clauses	2046-1
arbitrary definite clauses		sequential	datalog rules	2046-1
datalog rules	as	constraint	the following example	2046-1
datalog rules	in	constraint	the following example	2046-1
datalog rules	illustrated	action	the following example	2046-1
Example		sequential	12.4.9	2047-1
12.4.9	Consider	action	the program	2047-1
the program		sequential	S	2047-1
S		sequential	x	2047-1
x		sequential	z	2047-1
z		sequential	G	2047-1
G		sequential	x	2047-1
x		sequential	z	2047-1
z		sequential	S	2047-1
S		sequential	x	2047-1
x		sequential	z	2047-1
z		sequential	G	2047-1
G		sequential	x	2047-1
x		sequential	y	2047-1
y		sequential	S	2047-1
S		sequential	y	2047-1
y		sequential	z	2047-1
z		sequential	S	2047-1
S		sequential	x	2047-1
x		sequential	x	2047-1
x		sequential	that	2047-1
that	in	constraint	S	2047-1
that	computes	action	S	2047-1
S		sequential	the reflexive transitive closure	2047-1
the reflexive transitive closure	of	constraint	graph G	2047-1
resolution	to	constraint	definite clauses	2047-2
resolution	in	constraint	definite clauses	2047-2
resolution	for	constraint	definite clauses	2047-2
resolution	and	conjunctive	definite clauses	2047-2
resolution	However can be extended	attribute	indeed general	2047-2
resolution	is	attribute	indeed general	2047-2
resolution	presented	action	definite clauses	2047-2
<B>	for	constraint	instance	2047-3
<B>	Observe	action	instance	2047-3
instance	that	constraint	the goal	2047-3
SLD resolution	is	attribute	a technique	2048-1
a technique		sequential	that	2048-1
that	provides	action	proofs	2048-1
proofs	of	constraint	facts	2048-1
One	that	constraint	it	2048-2
One	be	attribute	must sure	2048-2
it	produces	action	only correct proofs	2048-2
only correct proofs		sequential	soundness	2048-2
soundness	that	constraint	it	2048-2
soundness	and	conjunctive	it	2048-2
it	to	constraint	all Datalog true facts	2048-2
it	is	attribute	powerful enough	2048-2
it	prove	action	all Datalog true facts	2048-2
all Datalog true facts		sequential	completeness	2048-2
<B>	To	constraint	this section	2048-3
<B>	conclude	action	this section	2048-3
this section		sequential	we	2048-3
we	demonstrate	action	the soundness	2048-3
the soundness	and	conjunctive	completeness	2048-3
completeness	of	constraint	SLD resolution	2048-3
SLD resolution	for	constraint	datalog programs	2048-3
We	use	action	the following lemma	2049-1
the following lemma		sequential	Lemma 12.4.10	2049-1
<B>	.	sequential	<B>	2049-2
<B>	.	sequential	<B>	2049-3
Ai		sequential	Ai	2049-4
<B>	.	sequential	<B>	2049-5
<B>	.	sequential	<B>	2049-6
<B>	and	conjunctive	r	2049-7
r		sequential	B1	2049-7
B1	←	sequential	B2	2049-7
<B>	.	sequential	<B>	2049-8
<B>	.	sequential	<B>	2049-9
<B>	be	attribute	a goal	2049-10
a goal	and	conjunctive	a rule	2049-10
a rule	with	constraint	no variables	2049-10
no variables	in	constraint	g′	2049-10
no variables	and	conjunctive	g′	2049-10
no variables	let	action	g′	2049-10
g′	≡←	constraint	A1	2049-10
<B>	.	sequential	<B>	2049-11
<B>	.	sequential	<B>	2049-12
Ai−1		sequential	B2	2049-13
<B>	.	sequential	<B>	2049-14
<B>	.	sequential	<B>	2049-15
Bm		sequential	Ai+1	2049-16
<B>	.	sequential	<B>	2049-17
<B>	.	sequential	<B>	2049-18
<B>		sequential	<B>	2049-19
<B>	If	constraint	θg′	2050-1
θg′	is	attribute	a resolvent	2050-1
a resolvent	of	constraint	g	2050-1
g	with	constraint	θ	2050-1
g	r using	action	θ	2050-1
θ		sequential	the formula	2050-1
the formula	r implies	action	r′	2050-1
r′		sequential	¬θg′	2050-1
¬θg′	→	sequential	¬θg	2050-1
Proof	Let	action	J	2051-1
J	be	attribute	an instance	2051-1
an instance	over	constraint	sch	2051-1
sch		sequential	P	2051-1
P		sequential	satisfying r	2051-1
satisfying r	and	conjunctive	valuation ν	2051-1
satisfying r	let	action	valuation ν	2051-1
valuation ν	that	constraint	J ν	2051-1
valuation ν	be	attribute	such	2051-1
J ν		sequential	θ	2051-1
θ		sequential	A1	2051-1
A1		sequential	∧	2051-1
∧		sequential	∧	2051-1
∧		sequential	θ	2051-1
θ		sequential	Ai−1	2051-1
Ai−1		sequential	∧	2051-1
∧		sequential	θ	2051-1
θ		sequential	B2	2051-1
B2		sequential	∧	2051-1
∧		sequential	∧	2051-1
∧		sequential	θ	2051-1
θ		sequential	Bm	2051-1
Bm		sequential	∧	2051-1
∧		sequential	θ	2051-1
θ		sequential	Ai+1	2051-1
Ai+1		sequential	∧	2051-1
∧		sequential	∧ θ	2051-1
∧ θ		sequential	An	2051-1
<B>	Because	constraint	J	2052-1
J		sequential	ν	2052-1
ν		sequential	θ	2052-1
θ		sequential	B2	2052-1
B2		sequential	∧	2052-1
∧		sequential	θ	2052-1
θ		sequential	Bm	2052-1
<B>	for	constraint	each ν J	2053-1
each ν J	|=	sequential	νr′	2053-1
Therefore J	|=	sequential	r′	2053-2
each instance	over	constraint	sch	2053-3
sch		sequential	P	2053-3
P		sequential	satisfying r	2053-3
satisfying r	Thus also satisfies	action	r′	2053-3
r′		sequential	r	2053-3
r	so implies	action	r′	2053-3
<B>	Using	action	this lemma	2054-1
this lemma		sequential	we	2054-1
we	have	action	the following Theorem 12.4.11	2054-1
Proof	Let	action	J	2055-1
J	be	attribute	some instance	2055-1
some instance	over	constraint	sch	2055-1
sch		sequential	P	2055-1
P		sequential	satisfying PI	2055-1
<B>	Let	action	g0	2055-2
g0	=	sequential	g	2055-2
<B>	.	sequential	<B>	2055-3
<B>	.	sequential	<B>	2055-4
gq	=	sequential	an SLD refutation	2055-5
gq	be	attribute	an SLD refutation	2055-5
an SLD refutation	of	constraint	g	2055-5
g	with	constraint	PI	2055-5
PI	for	constraint	each j	2055-5
PI	and	conjunctive	each j	2055-5
each j	let	action	gj	2055-5
gj	be	attribute	a resolvent	2055-5
a resolvent	of	constraint	gj−1	2055-5
gj−1	with	constraint	some rule	2055-5
some rule	in	constraint	PI	2055-5
PI	using	action	some mgu θj	2055-5
<B>	for	constraint	each j	2055-6
each j		sequential	the rule	2055-6
the rule		sequential	that	2055-6
that	is used	action	¬gj	2055-6
that	Then implies	action	¬gj	2055-6
¬gj	→	sequential	θj	2055-6
θj		sequential	¬gj −1	2055-6
¬gj −1	by	constraint	Lemma 12.4.10	2055-6
<B>	Because	constraint	J	2055-7
J	satisfies	action	PI	2055-7
PI	for	constraint	each j	2055-7
each j		sequential	J	2055-7
J		sequential	¬gj	2055-7
¬gj	→	sequential	θj	2055-7
θj		sequential	¬gj	2055-7
¬gj	−	sequential	1	2055-7
<B>	that	constraint	each j	2056-1
<B>	for	constraint	each j	2056-1
<B>	Clearly implies	action	each j	2056-1
each j		sequential	J	2056-1
J		sequential	θj+1	2056-1
θj+1		sequential	θq	2056-1
θq		sequential	¬gj	2056-1
¬gj		sequential	θj	2056-1
θj		sequential	θq	2056-1
θq		sequential	¬gj	2056-1
¬gj		sequential	−1	2056-1
<B>	By	constraint	transitivity	2057-1
transitivity	that	constraint	J	2057-1
transitivity	shows	action	J	2057-1
J	|=	sequential	¬gq	2057-1
¬gq	→	sequential	θ	2057-1
θ		sequential	1 ◦	2057-1
1 ◦		sequential	θq	2057-1
θq	¬	sequential	g0	2057-1
g0		sequential	J	2057-1
J	→	sequential	θ	2057-1
θ		sequential	1 ◦	2057-1
1 ◦		sequential	θq	2057-1
θq		sequential	¬g	2057-1
Thus J		sequential	θ	2058-1
θ		sequential	1	2058-1
1		sequential	θq	2058-1
θq		sequential	A1	2058-1
A1		sequential	∧	2058-1
∧		sequential	∧	2058-1
∧		sequential	An	2058-1
We	next prove	action	the converse	2059-1
the converse	of	constraint	the previous result	2059-1
the previous result		sequential	the completeness	2059-1
the completeness	of	constraint	SLD resolution	2059-1
Theorem		sequential	12.4.12	2060-1
Proof	that	constraint	PI	2061-1
Proof	Suppose	action	PI	2061-1
PI	implies	action	¬g	2061-1
<B>	Consider	action	the set ground	2061-2
the set ground		sequential	PI	2061-2
PI	of	constraint	instantiations	2061-2
instantiations	of	constraint	rules	2061-2
rules	in	constraint	PI	2061-2
PI	with	constraint	constants	2061-2
constants	in	constraint	adom	2061-2
adom		sequential	P	2061-2
P		sequential	I	2061-2
ground		sequential	PI	2061-3
PI		sequential	∅	2061-3
∅	is	attribute	Clearly a model	2061-3
Clearly a model	of	constraint	PI	2061-3
PI		sequential	it	2061-3
it	so satisfies	action	<B>	2061-3
<B>	Let	action	g0	2062-1
g0	=	sequential	θg	2062-1
<B>	.	sequential	<B>	2062-2
<B>	.	sequential	<B>	2062-3
gp	be	attribute	that refutation	2062-4
We	by	constraint	induction	2062-5
We	show	action	induction	2062-5
induction	on	constraint	k	2062-5
k	for	constraint	each k	2062-5
each k	in	constraint	0	2062-5
0		sequential	p	2062-5
p		sequential	g	2062-5
<B>	.	sequential	<B>	2062-6
<B>	.	sequential	<B>	2062-7
<B>	with	constraint	some k PI	2062-8
<B>	for	constraint	some k PI	2062-8
some k PI		sequential	gk	2062-8
gk	=	sequential	θkg′k	2062-8
<B>	For	constraint	each k	2063-1
<B>	that	constraint	each k	2063-1
<B>	for	constraint	each k	2063-1
<B>	suppose	action	each k	2063-1
<B>	† holds	action	each k	2063-1
<B>	.	sequential	<B>	2063-2
<B>	.	sequential	<B>	2063-3
<B>	with	constraint	some p PI	2063-4
<B>	for	constraint	some p PI	2063-4
some p PI		sequential	<B>	2063-4
The basis	of	constraint	the induction	2064-1
the induction	because	constraint	g0	2064-1
the induction	holds	action	g0	2064-1
g0	=	sequential	θg	2064-1
θg	=	sequential	θg′	2064-1
<B>	that	constraint	0	2064-2
<B>	Now suppose	action	0	2064-2
<B>	† holds	action	0	2064-2
0	for	constraint	some k	2064-2
<B>	In	constraint	g′	2064-3
g′	select	action	the atom B′	2064-3
the atom B′	with	constraint	location	2064-3
location	in	constraint	g′	2064-3
g′		sequential	corresponding k	2064-3
corresponding k	to	constraint	the location	2064-3
the location	of	constraint	B	2064-3
B	in	constraint	gk	2064-3
<B>	that	constraint	B	2064-4
<B>	Note	action	B	2064-4
B	=	sequential	θkB′	2064-4
<B>	In	constraint	addition	2064-5
addition		sequential	we	2064-5
we	that	constraint	there	2064-5
we	know	action	there	2064-5
there	is	attribute	rule	2064-5
rule		sequential	r′′	2064-5
r′′	=	sequential	<B>	2064-5
<B>	.	sequential	<B>	2064-6
<B>	.	sequential	<B>	2064-7
<B>	in	constraint	P	2064-8
P	n	conjunctive	I	2064-8
I	has	action	r	2064-8
r	for	constraint	instantiation	2064-8
instantiation	via	constraint	some substitution θ ′′	2064-8
some substitution θ ′′		sequential	such a pair B′	2064-8
such a pair B′		sequential	r′′	2064-8
r′′	although	constraint	it	2064-8
r′′	exists	action	it	2064-8
it	be	attribute	may not unique	2064-8
<B>	As	constraint	we	2064-9
we	that	constraint	the variables	2064-9
we	can assume	action	the variables	2064-9
the variables	in	constraint	g′	2064-9
g′	from	constraint	r′′	2064-9
g′	in	constraint	r′′	2064-9
g′	are	attribute	disjoint	2064-9
<B>	Let	action	θ	2064-10
θ	k	action	k	2064-10
k	θ	constraint	′′	2064-10
′′	be	attribute	the substitution	2064-10
the substitution	by	constraint	k k	2064-10
the substitution	defined	action	k k	2064-10
k k		sequential	⊕	2064-10
⊕		sequential	θ	2064-10
θ		sequential	′′	2064-10
′′		sequential	x	2064-10
x	=	sequential	θ	2064-10
θ	if	constraint	x	2064-10
x	is	attribute	x a variable	2064-10
x a variable	in	constraint	r ′′	2064-10
<B>		sequential	⊕	2065-1
⊕		sequential	B′	2065-1
B′	=	sequential	θk ⊕ θ′′	2065-1
θk ⊕ θ′′		sequential	B′′	2065-1
B′′	= so	sequential	B	2065-1
B	by	constraint	Lemma 12.4.8	2065-1
Lemma 12.4.8		sequential	i	2065-1
i		sequential	B′	2065-1
B′	and	conjunctive	B′′	2065-1
B′′	have	action	some mgu θ	2065-1
<B>	Let	action	g′	2065-2
g′	be	attribute	the resolvent	2065-2
the resolvent	of	constraint	g′	2065-2
g′	with	constraint	r′′	2065-2
r′′		sequential	B′	2065-2
B′	using	action	mgu θ	2065-2
<B>	By	constraint	the definition	2065-3
the definition	of	constraint	mgu	2065-3
mgu		sequential	there	2065-3
there	k+1 k exists	action	a substitution θk	2065-3
a substitution θk	+1	sequential	that	2065-3
that		sequential	θk	2065-3
θk		sequential	θ′′	2065-3
θ′′	=	sequential	θ	2065-3
θ		sequential	θk+1	2065-3
Clearly θk+1		sequential	g′ k+1	2065-4
g′ k+1		sequential	k+1	2065-4
Datalog Infinite no possible derivation subtree		sequential	Figure 12.6	2066-1
Figure 12.6		sequential	SLD tree SLD Trees	2066-1
it	Thus provides	attribute	top down	2066-2
an adequate technique	for	constraint	the facts	2066-2
an adequate technique	obtaining	action	the facts	2066-2
the facts	in	constraint	the answer	2066-2
the answer	to	constraint	a datalog program	2066-2
<B>	To	constraint	a fact	2066-3
<B>	that	constraint	a fact	2066-3
<B>	prove	action	a fact	2066-3
a fact	in	constraint	the answer	2066-3
a fact	is	attribute	the answer	2066-3
the answer		sequential	one	2066-3
one	for	constraint	a refutation	2066-3
one	must search	action	a refutation	2066-3
a refutation	of	constraint	the corresponding goal	2066-3
there	Clearly are	action	many refutations possible	2066-4
There	are	attribute	two sources	2066-5
two sources	of	constraint	nondeterminism	2066-5
nondeterminism	in	constraint	a refutation	2066-5
nondeterminism	for	constraint	a refutation	2066-5
nondeterminism	searching	action	a refutation	2066-5
a refutation		sequential	1 the choice	2066-5
1 the choice	of	constraint	the selected atom	2066-5
the selected atom	and	conjunctive	2 the choice	2066-5
2 the choice	of	constraint	the clause	2066-5
the clause	to	constraint	the atom	2066-5
the clause	with	constraint	the atom	2066-5
the clause	unify	action	the atom	2066-5
<B>	Now let	action	us	2066-6
us	that	constraint	we	2066-6
us	assume	action	we	2066-6
we	have fixed	action	some golden rule	2066-6
some golden rule	called	action	a selection rule	2066-6
a selection rule	for	constraint	which atom	2066-6
a selection rule	choosing	action	which atom	2066-6
which atom	to	constraint	each step	2066-6
which atom	at	constraint	each step	2066-6
which atom	select	action	each step	2066-6
each step	in	constraint	a refutation	2066-6
A priori		sequential	such a rule	2066-7
such a rule	as	constraint	Prolog	2066-7
such a rule	in	constraint	Prolog	2066-7
such a rule	be	attribute	may very simple	2066-7
Prolog	always take	action	the leftmost atom	2066-7
the leftmost atom	in	constraint	contrast very involved	2066-7
the leftmost atom	or	conjunctive	contrast very involved	2066-7
contrast very involved	into	constraint	account	2066-7
contrast very involved	taking	action	account	2066-7
account		sequential	the entire history	2066-7
the entire history	of	constraint	the refutation	2066-7
<B>	Once	constraint	an atom	2066-8
an atom	has been selected	action	we	2066-8
we	for	constraint	all possible unifying rules	2066-8
we	can systematically search	action	all possible unifying rules	2066-8
Such a search	in	constraint	an SLD tree	2066-9
Such a search	can be represented	action	an SLD tree	2066-9
<B>	For	constraint	instance	2066-10
instance	consider	action	the tree	2066-10
the tree	of	constraint	Fig	2066-10
12.6	for	constraint	the program	2066-11
the program	in	constraint	Example 12.4.2	2066-11
The selected atoms	with	constraint	boxes	2066-12
The selected atoms	are represented	action	boxes	2066-12
Edges	denote	action	unifications	2066-13
unifications	used	action	<B>	2066-13
<B>	Given	action	S	2066-14
S		sequential	1	2066-14
1		sequential	x	2066-14
x		sequential	only one rule	2066-14
only one rule	can be used	action	<B>	2066-14
<B>	Given	action	T	2066-15
T		sequential	1	2066-15
1		sequential	x2	2066-15
x2		sequential	two rules	2066-15
two rules	are	attribute	applicable	2066-15
that	for	constraint	the two descendants	2066-15
that	account	action	the two descendants	2066-15
the two descendants	of	constraint	vertex T	2066-15
vertex T		sequential	1	2066-15
1		sequential	x2	2066-15
<B>	in	constraint	edge	2066-16
edge		sequential	The first number labels	2066-16
The first number labels	denotes	action	the rule	2066-16
the rule		sequential	that	2066-16
that	and	conjunctive	the remaining part	2066-16
that	is used	action	the remaining part	2066-16
the remaining part	denotes	action	the substitution	2066-16
An SLD tree	is	attribute	a representation	2066-17
a representation	of	constraint	all the derivations	2066-17
all the derivations	with	constraint	a fixed selection rule	2066-17
all the derivations	obtained	action	a fixed selection rule	2066-17
a fixed selection rule	for	constraint	atoms	2066-17
There	are	attribute	several important observations	2067-1
several important observations	to	constraint	this particular SLD tree	2067-1
several important observations	about	constraint	this particular SLD tree	2067-1
several important observations	be made	action	this particular SLD tree	2067-1
this particular SLD tree		sequential	i	2067-1
We	to	constraint	a certain extent	2068-1
We	can now explain	action	a certain extent	2068-1
a certain extent		sequential	the acronym SLD	2068-1
SLD	for	constraint	selection linear resolution	2068-2
SLD	stands	action	selection linear resolution	2068-2
SLD	rule driven	action	selection linear resolution	2068-2
selection linear resolution	for	constraint	definite clauses	2068-2
Rule	to	constraint	the rule	2068-3
Rule	driven	action	the rule	2068-3
Rule	refers	action	the rule	2068-3
the rule	for	constraint	the atom	2068-3
the rule	used	action	the atom	2068-3
the rule	selecting	action	the atom	2068-3
An important fact	that	constraint	the success	2068-4
An important fact	is	attribute	the success	2068-4
the success	or	conjunctive	failure	2068-4
failure	of	constraint	an SLD tree	2068-4
an SLD tree	on	constraint	the rule	2068-4
an SLD tree	does not depend	action	the rule	2068-4
the rule	for	constraint	atoms	2068-4
the rule	selecting	action	atoms	2068-4
<B>	explains	action	the definition	2068-5
the definition	of	constraint	an SLD tree	2068-5
an SLD tree	why does not specify	action	the selection rule	2068-5
Datalog	versus	constraint	Logic Programming	2069-1
Logic Programming	Revisited	action	the three semantics	2069-1
Logic Programming	Having established	action	the three semantics	2069-1
the three semantics	for	constraint	datalog	2069-1
datalog		sequential	we	2069-1
we	summarize briefly	action	the main differences	2069-1
the main differences	between	constraint	datalog	2069-1
datalog	and	conjunctive	logic programming	2069-1
logic programming		sequential	lp	2069-1
lp		sequential	the more general framework	2069-1
Syntax		sequential	Datalog	2070-1
Datalog	has	action	only relation symbols	2070-1
only relation symbols	whereas	constraint	lp	2070-1
lp	uses also	action	function symbols	2070-1
Datalog	requires	action	variables	2070-2
variables	in	constraint	rule heads	2070-2
rule heads	to	constraint	bodies	2070-2
rule heads	in	constraint	bodies	2070-2
rule heads	appear	action	bodies	2070-2
bodies	in	constraint	all unit clauses	2070-2
all unit clauses	are	attribute	ground	2070-2
Model		sequential	semantics	2071-1
Datalog programs	always have	action	finite models	2071-2
<B>	from	constraint	this distinction	2071-3
this distinction		sequential	lp	2071-3
lp	and	conjunctive	datalog	2071-3
datalog	with	constraint	respect	2071-3
datalog	are	attribute	identical	2071-3
respect	to	constraint	model	2071-3
model		sequential	semantics	2071-3
Fixpoint semantics		sequential	the minimum fixpoint	2072-1
the minimum fixpoint	of	constraint	the immediate consequence operator	2072-1
the immediate consequence operator	in	constraint	the lp case	2072-1
the immediate consequence operator	be	attribute	Again may infinite	2072-1
the lp case	whereas	constraint	it	2072-1
it	for	constraint	datalog	2072-1
it	is	attribute	always finite	2072-1
the fixpoint approach	Thus does not necessarily provide	action	a constructive semantics	2072-2
a constructive semantics	for	constraint	lp	2072-2
Proof		sequential	semantics	2073-1
<B>	For	constraint	datalog	2073-2
datalog		sequential	the significance	2073-2
the significance	of	constraint	SLD resolution	2073-2
SLD resolution	concerns	action	primarily optimization methods	2073-2
primarily optimization methods	by	constraint	resolution	2073-2
primarily optimization methods	inspired	action	resolution	2073-2
resolution		sequential	resolution	2073-2
SLD resolution	as	constraint	the practical alternative	2073-3
SLD resolution	Thus emerges	action	the practical alternative	2073-3
Expressive power		sequential	Expressive power	2074-1
<B>	predicates	action	<B>	2074-2
<B>	as	constraint	Part E	2074-3
<B>	in	constraint	Part E	2074-3
<B>	will be discussed	action	Part E	2074-3
Part E		sequential	the expressive power	2074-3
the expressive power	of	constraint	datalog	2074-3
datalog	within	constraint	ptime	2074-3
datalog	However lies	action	ptime	2074-3
<B>	Why is	action	there	2074-4
there		sequential	such a disparity	2074-4
A fundamental reason	that	constraint	function symbols	2074-5
A fundamental reason	is	attribute	function symbols	2074-5
function symbols	in	constraint	lp	2074-5
function symbols	are used	action	lp	2074-5
lp	and	conjunctive	an infinite domain	2074-5
an infinite domain	of	constraint	objects	2074-5
objects	from	constraint	a finite set	2074-5
objects	so can be constructed	action	a finite set	2074-5
a finite set	of	constraint	symbols	2074-5
<B>	Speaking technically	action	the result	2074-6
the result	for	constraint	lp	2074-6
lp	states	action	that	2074-6
that	if	constraint	S	2074-6
S	is	attribute	possibly infinite	2074-6
<B>	over	constraint	terms	2074-7
<B>	predicate	action	terms	2074-7
terms	constructed	action	a finite language	2074-7
terms	using	action	a finite language	2074-7
a finite language		sequential	there	2074-7
there	is	attribute	an lp program	2074-7
an lp program		sequential	that	2074-7
that	for	constraint	some predicate symbol	2074-7
that	produces	action	some predicate symbol	2074-7
some predicate symbol		sequential	exactly the tuples	2074-7
exactly the tuples	in	constraint	the facts	2074-7
exactly the tuples	from	constraint	the facts	2074-7
exactly the tuples	S. Speaking intuitively	attribute	this	2074-7
exactly the tuples	follows	action	the facts	2074-7
the facts		sequential	that	2074-7
that	in	constraint	bottom	2074-7
that	viewed	action	bottom	2074-7
bottom	up	constraint	a sense	2074-7
a sense		sequential	lp	2074-7
lp	provides	action	composition	2074-7
composition	and	conjunctive	looping	2074-7
looping	and	conjunctive	terms	2074-7
terms	of	constraint	arbitrary length	2074-7
arbitrary length	as	constraint	scratch paper	2074-7
arbitrary length	can be used	action	scratch paper	2074-7
scratch paper		sequential	Datalog	2074-7
Static Program Analysis		sequential	Static Program Analysis	2075-1
<B>	In	constraint	tableau homomorphism	2075-2
<B>	although	constraint	tableau homomorphism	2075-2
tableau homomorphism	allowed	action	us	2075-2
us	to	constraint	the equivalence	2075-2
us	test	action	the equivalence	2075-2
the equivalence	of	constraint	conjunctive queries	2075-2
conjunctive queries		sequential	equivalence	2075-2
equivalence	of	constraint	datalog programs	2075-2
datalog programs	in	constraint	<B>	2075-2
datalog programs	is	attribute	undecidable	2075-2
<B>	complicates	action	a systematic search	2075-3
a systematic search	for	constraint	alternative execution plans	2075-3
alternative execution plans	for	constraint	datalog queries	2075-3
datalog queries	and	conjunctive	severe limitations	2075-3
datalog queries	yields	action	severe limitations	2075-3
severe limitations	to	constraint	query optimization	2075-3
It	also entails	action	the undecidability	2075-4
the undecidability	of	constraint	many other problems	2075-4
many other problems	to	constraint	optimization	2075-4
optimization	deciding	action	selection propagation	2075-4
selection propagation	in	constraint	the style	2075-4
the style	of	constraint	selections	2075-4
the style	pushing	action	selections	2075-4
selections	in	constraint	relational algebra	2075-4
relational algebra	or	conjunctive	parallel evaluation	2075-4
relational algebra	when can be performed	action	parallel evaluation	2075-4
parallel evaluation	is	attribute	when possible	2075-4
We	consider	action	three fundamental static properties	2076-1
three fundamental static properties		sequential	satisfiability	2076-1
satisfiability		sequential	containment	2076-1
containment	and	conjunctive	a new one	2076-1
a new one		sequential	boundedness	2076-1
We	exhibit	action	a decision procedure	2076-2
a decision procedure	for	constraint	satisfiability	2076-2
<B>	that	constraint	we	2076-3
<B>	Recall	action	we	2076-3
we	in	constraint	Chapter 5	2076-3
we	showed	action	Chapter 5	2076-3
Chapter 5	that	constraint	an analogous property	2076-3
an analogous property	for	constraint	CALC	2076-3
an analogous property	is	attribute	undecidable	2076-3
The decidability	of	constraint	satisfiability	2076-4
satisfiability	for	constraint	datalog	2076-4
datalog	be	attribute	may therefore surprising	2076-4
one	that	constraint	datalog	2076-5
one	although	constraint	datalog	2076-5
one	However must remember	action	datalog	2076-5
datalog	than	constraint	CALC	2076-5
datalog	is	attribute	more powerful	2076-5
CALC	in	constraint	some respects	2076-5
some respects		sequential	it	2076-5
it	has	action	recursion	2076-5
recursion		sequential	it	2076-5
it	in	constraint	others	2076-5
it	is	attribute	less powerful	2076-5
others		sequential	there	2076-5
there	is	attribute	no negation	2076-5
It	is	attribute	the lack	2076-6
the lack	of	constraint	negation	2076-6
negation		sequential	that	2076-6
that	makes	action	satisfiability	2076-6
satisfiability	for	constraint	datalog	2076-6
We	prove	action	the undecidability	2077-1
the undecidability	of	constraint	containment	2077-1
containment	and	conjunctive	boundedness	2077-1
boundedness	for	constraint	datalog programs	2077-1
datalog programs	and	conjunctive	variations	2077-1
datalog programs	consider	action	variations	2077-1
variations	or	conjunctive	restrictions	2077-1
restrictions		sequential	that	2077-1
that	are	attribute	decidable	2077-1
Satisfiability	Let	action	P	2078-1
P	be	attribute	a datalog program	2078-1
An intensional relation T	by	constraint	P	2078-2
An intensional relation T	is	attribute	satisfiable	2078-2
P	if	constraint	there	2078-2
there	exists	action	an instance	2078-2
an instance		sequential	I	2078-2
I	over	constraint	edb	2078-2
edb		sequential	P	2078-2
P	that	constraint	P I	2078-2
P I		sequential	T	2078-2
T	is	attribute	nonempty	2078-2
We	give	action	a simple proof	2078-3
a simple proof	of	constraint	the decidability	2078-3
the decidability	of	constraint	satisfiability	2078-3
satisfiability	for	constraint	datalog programs	2078-3
We	will soon see	action	an alternative proof	2078-4
an alternative proof	on	constraint	context	2078-4
an alternative proof	based	action	context	2078-4
context		sequential	languages	2078-4
We	first consider	attribute	constant	2079-1
We	to	constraint	the general case	2079-2
We	describe	action	the general case	2079-2
We	how reduce	action	the general case	2079-2
the general case	to	constraint	the one	2079-2
<B>	To	constraint	the result	2080-1
<B>	prove	action	the result	2080-1
the result		sequential	we	2080-1
we	use	action	an auxiliary result	2080-1
an auxiliary result	about	constraint	instance homomorphisms	2080-1
instance homomorphisms		sequential	that	2080-1
that	of	constraint	some interest	2080-1
that	is	attribute	some interest	2080-1
some interest	in	constraint	its own right	2080-1
<B>	that	constraint	any mapping θ	2080-2
<B>	Note	action	any mapping θ	2080-2
any mapping θ	from	constraint	dom	2080-2
dom	to	constraint	dom	2080-2
dom	to	constraint	a homomorphism	2080-2
dom	can be extended	action	a homomorphism	2080-2
a homomorphism	over	constraint	the set	2080-2
the set	of	constraint	instances	2080-2
instances		sequential	which	2080-2
which		sequential	we	2080-2
we	by	constraint	θ	2080-2
we	also denote	action	θ	2080-2
Lemma		sequential	12.5.1	2081-1
<B>	If	constraint	θ I ⊆ J	2081-2
θ I ⊆ J		sequential	i θ	2081-2
i θ		sequential	q	2081-2
q		sequential	I	2081-2
I		sequential	⊆ q	2081-2
⊆ q		sequential	J	2081-2
J	and	conjunctive	ii θ	2081-2
ii θ		sequential	P	2081-2
P		sequential	I	2081-2
I		sequential	⊆	2081-2
⊆		sequential	P	2081-2
P		sequential	J	2081-2
Proof	For	constraint	q	2082-1
Proof	that	constraint	q	2082-1
Proof	i observe	action	q	2082-1
q	and	conjunctive	that q ⊆ θ	2082-1
q	is	attribute	monotone	2082-1
that q ⊆ θ		sequential	θ	2082-1
θ		sequential	q	2082-1
q		sequential	which	2082-1
which	if	constraint	q	2082-1
which	is	attribute	not necessary	2082-1
q	has	action	constants	2082-1
<B>	Because	constraint	TP	2082-2
TP	as	constraint	a query	2082-2
TP	can be viewed	attribute	positive existential	2082-2
a query		sequential	a straightforward induction	2082-2
a straightforward induction	proves	action	ii	2082-2
This result	for	constraint	datalog programs	2083-1
This result	does not hold	action	datalog programs	2083-1
datalog programs	with	constraint	constants	2083-1
constants	see	action	Exercise 12.21	2083-1
Theorem		sequential	12.5.2	2084-1
Proof	that	constraint	T	2085-1
Proof	Suppose	action	T	2085-1
T	by	constraint	datalog program	2085-1
T	is	attribute	satisfiable	2085-1
datalog program		sequential	a P	2085-1
We	that	constraint	P	2085-2
We	prove	action	P	2085-2
P		sequential	Ia	2085-2
Ia		sequential	T	2085-2
T	for	constraint	some particular instance Ia	2085-2
T	is	attribute	nonempty	2085-2
<B>	in	constraint	dom	2085-3
<B>	Let	attribute	a	2085-3
<B>	be	attribute	dom	2085-3
<B>	Let	action	Ia	2085-4
Ia	be	attribute	the instance	2085-4
the instance	over	constraint	edb	2085-4
edb		sequential	P	2085-4
P	that	constraint	each R	2085-4
P	for	constraint	each R	2085-4
each R	in	constraint	edb	2085-4
edb		sequential	P	2085-4
P		sequential	Ia	2085-4
Ia		sequential	R	2085-4
R	contains	action	a single tuple	2085-4
a single tuple	with	constraint	a each entry	2085-4
a single tuple	in	constraint	a each entry	2085-4
<B>	Because	constraint	T	2085-5
T	by	constraint	P	2085-5
T	is	attribute	satisfiable	2085-5
P		sequential	there	2085-5
there	exists	action	I	2085-5
I	that	constraint	P I	2085-5
P I		sequential	T	2085-5
T	=	sequential	<B>	2085-5
<B>	Consider	action	the function θ	2085-6
the function θ		sequential	that	2085-6
that	in	constraint	dom	2085-6
that	maps	attribute	every constant	2085-6
dom	to	constraint	<B>	2085-6
Then θ		sequential	I	2085-7
I		sequential	⊆	2085-7
<B>	By	constraint	the previous lemma	2085-8
the previous lemma		sequential	θ	2085-8
θ		sequential	P	2085-8
P		sequential	I	2085-8
I		sequential	⊆ P	2085-8
⊆ P		sequential	Ia	2085-8
P		sequential	Ia	2085-9
Ia		sequential	T	2085-9
T	is	attribute	Therefore nonempty	2085-9
T	by	constraint	P iff	2085-10
T	is	attribute	Hence satisfiable	2085-10
P iff		sequential	P	2085-10
P		sequential	Ia	2085-10
Ia		sequential	T	2085-10
T	=	sequential	<B>	2085-10
T	∅	sequential	<B>	2085-10
<B>	Let	action	us	2086-1
us	now consider	action	the case	2086-1
the case	of	constraint	datalog programs	2086-1
datalog programs	with	constraint	constants	2086-1
<B>	Let	action	P	2086-2
P	be	attribute	a datalog program	2086-2
a datalog program	with	constraint	constants	2086-2
<B>	For	constraint	example	2086-3
example	that	constraint	b	2086-3
example	suppose	action	b	2086-3
b		sequential	c	2086-3
c	are	attribute	the only two constants	2086-3
the only two constants	in	constraint	the program	2086-3
the only two constants	occurring	action	the program	2086-3
the program	that	constraint	R	2086-3
the program	and	conjunctive	R	2086-3
R	is	attribute	a binary relation	2086-3
a binary relation	in	constraint	P	2086-3
a binary relation	occurring	action	P	2086-3
We	transform	action	the problem	2086-4
the problem	into	constraint	a problem	2086-4
a problem	without	constraint	constants	2086-4
we	Specifically replace	action	R	2086-5
R	with	constraint	nine new relations	2086-5
nine new relations		sequential	R⋆⋆	2086-5
R⋆⋆		sequential	Rb⋆	2086-5
Rb⋆		sequential	Rc⋆	2086-5
Rc⋆		sequential	R⋆b	2086-5
R⋆b		sequential	R⋆c	2086-5
R⋆c		sequential	Rbc	2086-5
Rbc		sequential	Rcb	2086-5
Rcb		sequential	Rbb	2086-5
Rbb		sequential	Rcc	2086-5
The first one	is	attribute	binary	2087-1
the next four	and	conjunctive	the last four	2087-1
the next four	are	attribute	unary	2087-1
the last four	are	attribute	0 ary	2087-1
0 ary	are	attribute	proposi-tions	2087-1
<B>		sequential	a fact	2087-2
a fact		sequential	R	2087-2
R		sequential	x	2087-2
x		sequential	y	2087-2
y	by	constraint	the fact	2087-2
y	is represented	action	the fact	2087-2
the fact		sequential	R⋆⋆	2087-2
R⋆⋆		sequential	x	2087-2
x		sequential	y	2087-2
y	if	constraint	x	2087-2
x		sequential	y	2087-2
y	in	constraint	not b	2087-2
y	are	attribute	not b	2087-2
not b		sequential	c	2087-2
c	}	sequential	R	2087-2
R		sequential	b	2087-2
b		sequential	x	2087-2
x	with	constraint	not b	2087-2
x	in	constraint	not b	2087-2
not b		sequential	c	2087-2
c	by	constraint	Rb⋆	2087-2
c	is represented	action	Rb⋆	2087-2
Rb⋆		sequential	x	2087-2
x	for	constraint	similarly Rc⋆	2087-2
x	and	conjunctive	similarly Rc⋆	2087-2
similarly Rc⋆		sequential	R⋆b	2087-2
R⋆b		sequential	R⋆c	2087-2
The fact		sequential	R	2087-3
R		sequential	b	2087-3
b		sequential	c	2087-3
c	by	constraint	proposition Rbc	2087-3
c	is represented	action	proposition Rbc	2087-3
proposition Rbc		sequential	<B>	2087-3
<B>	Using	action	this kind	2087-4
this kind	of	constraint	transformation	2087-4
transformation	for	constraint	each relation	2087-4
each relation		sequential	one	2087-4
one	translates	action	program P	2087-4
program P	into	constraint	program	2087-4
program		sequential	a P	2087-4
a P	that	constraint	T	2087-4
T	by	constraint	P iff	2087-4
T	is	attribute	satisfiable	2087-4
P iff		sequential	Tw	2087-4
Tw	by	constraint	P ′	2087-4
Tw	is	attribute	satisfiable	2087-4
P ′	for	constraint	some string	2087-4
some string	w	constraint	constants	2087-4
some string	of	constraint	constants	2087-4
some string	or	conjunctive	constants	2087-4
constants	in	constraint	P	2087-4
constants	occurring	action	P	2087-4
Containment	Consider	action	two datalog programs	2088-1
two datalog programs		sequential	P	2088-1
P		sequential	P	2088-1
P	with	constraint	the same extensional relations edb	2088-1
the same extensional relations edb		sequential	P	2088-1
P	and	conjunctive	a target relation T	2088-1
a target relation T	in	constraint	both programs	2088-1
a target relation T	occurring	action	both programs	2088-1
We	that	constraint	P	2088-2
We	say	action	P	2088-2
P	in	constraint	P ′	2088-2
P	is included	action	P ′	2088-2
P ′	with	constraint	respect	2088-2
respect	to	constraint	T P	2088-2
T P	denoted	action	⊆T P	2088-2
⊆T P	if	constraint	each instance	2088-2
⊆T P	for	constraint	each instance	2088-2
each instance		sequential	I	2088-2
I	over	constraint	edb	2088-2
edb		sequential	P	2088-2
P		sequential	P	2088-2
P		sequential	I	2088-2
I		sequential	T	2088-2
T		sequential	⊆ P	2088-2
⊆ P		sequential	I	2088-2
I		sequential	T	2088-2
The containment problem	is	attribute	undecidable	2089-1
We	by	constraint	reduction	2089-2
We	prove	attribute	this	2089-2
reduction	of	constraint	the containment problem	2089-2
the containment problem	for	constraint	context	2089-2
context		sequential	languages	2089-2
The technique	because	constraint	it	2089-3
The technique	is	attribute	interesting	2089-3
it	exhibits	action	a correspondence	2089-3
a correspondence	between	constraint	proof trees	2089-3
proof trees	of	constraint	certain datalog programs	2089-3
certain datalog programs	and	conjunctive	derivation trees	2089-3
derivation trees	of	constraint	context	2089-3
context		sequential	languages	2089-3
Datalog		sequential	Datalog	2090-1
Example		sequential	12.5.3	2091-1
The corresponding datalog program		sequential	PG	2092-1
PG	is	attribute	the program	2092-1
the program	of	constraint	Example 12.4.1	2092-1
A proof tree	and	conjunctive	its corresponding derivation tree	2092-2
its corresponding derivation tree	in	constraint	Fig	2092-2
its corresponding derivation tree	are shown	action	Fig	2092-2
12.3		sequential	12.3	2092-3
We	next formalize	action	the correspondence	2093-1
the correspondence	between	constraint	proof trees	2093-1
proof trees	and	conjunctive	derivation trees	2093-1
<B>	denotes	action	the empty string	2094-1
the empty string	and	conjunctive	<B>	2094-1
We	use	attribute	the	2095-1
<B>	For	constraint	each ⋆ grammar G	2096-1
each ⋆ grammar G	let	action	PG	2096-1
PG		sequential	the corresponding datalog program	2096-1
the corresponding datalog program	to	constraint	Example 12.5.3	2096-1
the corresponding datalog program	be constructed	attribute	similar	2096-1
Example 12.5.3	as	constraint	G	2096-1
Example 12.5.3	follows	action	G	2096-1
Example 12.5.3	Let	action	G	2096-1
G	=	sequential	V	2096-1
V		sequential	S	2096-1
We	without	constraint	loss	2096-2
We	may assume	action	loss	2096-2
loss	of	constraint	generality	2096-2
generality		sequential	that	2096-2
that		sequential	V	2096-2
V	is	attribute	a set	2096-2
a set	of	constraint	relation names	2096-2
relation names	of	constraint	arity 2	2096-2
arity 2	and	conjunctive	a set	2096-2
a set	of	constraint	elements	2096-2
elements	from	constraint	dom	2096-2
idb		sequential	PG	2096-3
PG	Then =	sequential	V	2096-3
V	and	conjunctive	edb	2096-3
edb		sequential	PG	2096-3
PG	=	sequential	R	2096-3
PG	{	sequential	R	2096-3
R		sequential	R	2096-3
R	is	attribute	where a ternary relation	2096-3
<B>	Let	action	x1	2096-4
x1		sequential	x2	2096-4
<B>	.	sequential	<B>	2096-5
<B>	.	sequential	<B>	2096-6
<B>	be	attribute	an infinite sequence	2097-1
an infinite sequence	of	constraint	distinct variables	2097-1
<B>	To	constraint	each production in T → C1	2097-2
<B>	.	sequential	<B>	2097-3
<B>	.	sequential	<B>	2097-4
Cn		sequential	we	2097-5
we	associate	action	a datalog rule	2097-5
a datalog rule		sequential	T	2097-5
T		sequential	x1	2097-5
x1		sequential	xn+1	2097-5
xn+1	←	sequential	A1	2097-5
<B>	.	sequential	<B>	2097-6
<B>	.	sequential	<B>	2097-7
<B>	for	constraint	each i	2097-8
<B>	that	constraint	any proof tree	2098-1
<B>	for	constraint	any proof tree	2098-1
<B>	Note	action	any proof tree	2098-1
any proof tree	of	constraint	a fact	2098-1
a fact		sequential	S	2098-1
S		sequential	a 1	2098-1
a 1	using	action	PG	2098-1
PG		sequential	the sequence	2098-1
the sequence	of	constraint	its leaves	2098-1
its leaves	in	constraint	this order	2098-1
its leaves	is	attribute	this order	2098-1
this order		sequential	R	2098-1
R		sequential	a 1	2098-1
a 1		sequential	b1	2098-1
b1	a	sequential	2	2098-1
<B>	.	sequential	<B>	2098-2
<B>	.	sequential	<B>	2098-3
R	an −	sequential	1	2098-4
1		sequential	bn−1	2098-4
bn−1	for	constraint	some a2	2098-4
<B>	.	sequential	<B>	2098-5
<B>	.	sequential	<B>	2098-6
an−1	and	conjunctive	b1	2098-7
<B>	.	sequential	<B>	2098-8
<B>	.	sequential	<B>	2098-9
bn−1		sequential	bn−1	2098-10
The connection	between	constraint	derivation trees	2098-11
derivation trees	of	constraint	G	2098-11
G	and	conjunctive	trees	2098-11
trees	of	constraint	PG	2098-11
PG	in	constraint	<B>	2098-11
PG	is shown	attribute	the	2098-11
PG	following	action	<B>	2098-11
Proposition		sequential	12.5.4	2099-1
<B>	For	constraint	each a 1	2099-2
<B>	.	sequential	<B>	2099-3
<B>	.	sequential	<B>	2099-4
<B>		sequential	b1	2099-5
<B>	.	sequential	<B>	2099-6
<B>	.	sequential	<B>	2099-7
there	bn−1 is	action	a proof tree	2099-8
a proof tree	of	constraint	S	2099-8
S		sequential	a 1	2099-8
a 1	from	constraint	PG	2099-8
PG	with	constraint	leaves R	2099-8
leaves R		sequential	a 1	2099-8
a 1		sequential	b1	2099-8
b1	a	sequential	2	2099-8
<B>	.	sequential	<B>	2099-9
<B>	.	sequential	<B>	2099-10
R		sequential	an 1	2099-11
an 1		sequential	bn−1	2099-11
bn−1	in	constraint	this order	2099-11
this order		sequential	iff b1	2099-11
<B>	.	sequential	<B>	2099-12
<B>	.	sequential	<B>	2099-13
bn−1	in	constraint	L	2099-14
bn−1	is	attribute	L	2099-14
L		sequential	G	2099-14
The proof	of	constraint	the proposition	2100-1
the proposition	as	constraint	Exercise 12.25	2100-1
the proposition	is left	action	Exercise 12.25	2100-1
we	Now can show	action	the following Theorem 12.5.5	2100-2
Proof		sequential	Proof	2101-1
S PG2 Suppose		sequential	‡	2102-1
‡	and	conjunctive	T containment	2102-1
‡	holds	action	T containment	2102-1
T containment	is	attribute	decidable	2102-1
we	Then obtain	action	an algorithm	2102-2
an algorithm	to	constraint	containment	2102-2
an algorithm	decide	action	containment	2102-2
containment	of	constraint	⋆	2102-2
⋆		sequential	grammars	2102-2
grammars		sequential	which	2102-2
which	contradicts	action	the aforementioned fact	2102-2
<B>	Let	action	G2	2103-1
G2		sequential	G2	2103-1
G2	be	attribute	⋆	2103-1
⋆		sequential	two grammars	2103-1
We	that	constraint	L	2103-2
We	show here	action	L	2103-2
L		sequential	G1	2103-2
G1		sequential	⊆ L	2103-2
⊆ L		sequential	G2	2103-2
G2		sequential	PG	2103-2
S		sequential	PG2	2104-1
PG2		sequential	S	2104-1
S		sequential	a 1	2104-1
a 1	in	constraint	PG	2104-1
a 1	be	attribute	PG	2104-1
PG		sequential	I	2104-1
there	Then exists	action	a proof tree	2104-2
a proof tree	of	constraint	S	2104-2
S	and	conjunctive	I	2104-2
I	with	constraint	leaves	2104-2
leaves	by	constraint	facts R	2104-2
leaves	labeled	action	facts R	2104-2
facts R		sequential	a 1	2104-2
a 1		sequential	b1	2104-2
b1	a	sequential	2	2104-2
<B>	.	sequential	<B>	2104-3
<B>	.	sequential	<B>	2104-4
R	an −	sequential	1	2104-5
1		sequential	bn−1	2104-5
bn−1	in	constraint	this order	2104-5
<B>	By	constraint	Proposition 12.5.4 b1	2104-6
<B>	.	sequential	<B>	2104-7
<B>	.	sequential	<B>	2104-8
bn−1	in	constraint	L	2104-9
bn−1	is	attribute	L	2104-9
L		sequential	G1	2104-9
<B>	Because	constraint	L	2104-10
L		sequential	G1	2104-10
G1		sequential	⊆ L	2104-10
⊆ L		sequential	G2	2104-10
G2		sequential	b1	2104-10
<B>	.	sequential	<B>	2104-11
<B>	.	sequential	<B>	2104-12
bn−1	in	constraint	L	2104-13
bn−1	is	attribute	L	2104-13
L		sequential	G2	2104-13
<B>	By	constraint	the proposition again	2104-14
the proposition again		sequential	there	2104-14
there	is	attribute	a proof tree	2104-14
a proof tree	of	constraint	S	2104-14
S		sequential	a 1	2104-14
a 1	from	constraint	PG2	2104-14
PG2	with	constraint	leaves R	2104-14
leaves R		sequential	a 1	2104-14
a 1		sequential	b1	2104-14
b1	a	sequential	2	2104-14
<B>	.	sequential	<B>	2104-15
<B>	.	sequential	<B>	2104-16
R	an −	sequential	1	2104-17
1		sequential	bn−1	2104-17
bn−1	of	constraint	which	2104-17
which	are	attribute	facts	2104-17
facts	in	constraint	I	2104-17
S		sequential	a 1	2104-18
a 1	in	constraint	Thus PG	2104-18
a 1	is	attribute	Thus PG	2104-18
Thus PG		sequential	I	2104-18
I		sequential	so P	2104-18
G1 S PG2 Note		sequential	that	2105-1
that		sequential	the datalog programs	2105-1
the datalog programs	in	constraint	the preceding construction	2105-1
the datalog programs	used	action	the preceding construction	2105-1
the preceding construction	are	attribute	very particular	2105-1
<B>	in	constraint	a chain program	2105-2
a chain program		sequential	the variables	2105-2
the variables	in	constraint	a rule body	2105-2
a rule body	Intuitively form	action	a chain	2105-2
<B>		sequential	rules	2105-3
rules	in	constraint	chain programs	2105-3
chain programs	of	constraint	the form	2105-3
chain programs	are	attribute	the form	2105-3
the form		sequential	A0	2105-3
A0		sequential	x0	2105-3
x0		sequential	xn	2105-3
xn		sequential	A1	2105-3
A1		sequential	x0	2105-3
x0		sequential	x1	2105-3
x1		sequential	A2	2105-3
A2		sequential	x1	2105-3
x1		sequential	x2	2105-3
<B>	.	sequential	<B>	2105-4
<B>	.	sequential	<B>	2105-5
<B>		sequential	xn−1	2105-6
xn−1		sequential	xn	2105-6
The preceding proof	to	constraint	containment	2106-1
The preceding proof	that	constraint	containment	2106-1
The preceding proof	can be tightened	action	containment	2106-1
The preceding proof	show	action	containment	2106-1
containment	for	constraint	even chain programs	2106-1
containment	is	attribute	undecidable	2106-1
even chain programs	see	action	Exercise 12.26	2106-1
The connection	with	constraint	grammars	2107-1
grammars	to	constraint	an alternate proof	2107-1
grammars	can also be used	action	an alternate proof	2107-1
grammars	provide	action	an alternate proof	2107-1
an alternate proof	of	constraint	the decidability	2107-1
the decidability	of	constraint	satisfiability	2107-1
satisfiability		sequential	satisfiability	2107-1
satisfiability	to	constraint	the emptiness problem	2107-1
satisfiability	can be reduced	action	the emptiness problem	2107-1
the emptiness problem	for	constraint	context	2107-1
context		sequential	languages	2107-1
languages	see	action	Exercise 12.22 c	2107-1
Datalog set	of	constraint	relations	2108-1
Datalog set	and	conjunctive	relations	2108-1
relations		sequential	we	2108-1
we	that	constraint	P	2108-1
we	say	action	P	2108-1
P	in	constraint	P ′	2108-1
P	is uniformly contained	action	P ′	2108-1
P ′	denoted	action	P ⊆	2108-1
P ⊆		sequential	P ′	2108-1
P ′		sequential	iff	2108-1
iff	for	constraint	each I	2108-1
each I	over	constraint	sch	2108-1
sch		sequential	P	2108-1
P		sequential	P	2108-1
P		sequential	I	2108-1
I		sequential	⊆ P ′	2108-1
⊆ P ′		sequential	I	2108-1
Uniform containment	is	attribute	a sufficient condition	2108-2
a sufficient condition	for	constraint	containment	2108-2
one	Interestingly can decide	action	uniform containment	2108-3
The test	for	constraint	uniform containment	2109-1
uniform containment	uses	action	dependencies	2109-1
dependencies	in	constraint	Part D	2109-1
dependencies	studied	action	Part D	2109-1
Part D	and	conjunctive	the fundamental chase technique	2109-1
the fundamental chase technique	see	action	Exercises 12.27	2109-1
Exercises 12.27	and	conjunctive	12.28	2109-1
Boundedness		sequential	Boundedness	2110-1
Example		sequential	12.5.6	2111-1
<B>	On	constraint	the other hand	2111-2
the other hand		sequential	the program Buys	2111-2
the program Buys		sequential	x	2111-2
x		sequential	y	2111-2
y	Knows	action	x	2111-2
x		sequential	z	2111-2
z		sequential	Buys	2111-2
Buys		sequential	z	2111-2
z		sequential	y	2111-2
y		sequential	Buys	2111-2
Buys		sequential	x	2111-2
x		sequential	y	2111-2
y		sequential	Likes	2111-2
Likes		sequential	x	2111-2
x		sequential	y	2111-2
y	to	constraint	recursion	2111-2
y	is	attribute	inherently recursive	2111-2
y	is	attribute	not equivalent	2111-2
recursion		sequential	any program	2111-2
It	to	constraint	truly recursive programs	2112-1
It	is	attribute	important	2112-1
It	distinguish	action	truly recursive programs	2112-1
truly recursive programs	from	constraint	falsely recursive programs	2112-1
truly recursive programs	bounded	action	falsely recursive programs	2112-1
boundedness	Unfortunately can not be tested	action	<B>	2112-2
Theorem		sequential	12.5.7	2113-1
The proof	by	constraint	reduction	2114-1
The proof	is	attribute	reduction	2114-1
reduction	of	constraint	the PCP	2114-1
the PCP	see	action	Chapter 2	2114-1
One	that	constraint	boundedness	2114-2
One	can even show	action	boundedness	2114-2
boundedness	under	constraint	strong restrictions	2114-2
boundedness	remains	attribute	undecidable	2114-2
strong restrictions	that	constraint	the programs	2114-2
the programs		sequential	that	2114-2
that	are considered	attribute	1 constant free	2114-2
that	are	attribute	1 constant free	2114-2
that	2 contain	action	a unique recursive rule	2114-2
a unique recursive rule	or	conjunctive	a unique intensional relation	2114-2
a unique recursive rule	3 contain	action	a unique intensional relation	2114-2
Decidability results	for	constraint	linear programs	2114-3
Decidability results	have been obtained	action	linear programs	2114-3
linear programs	or	conjunctive	chain rule	2114-3
chain rule		sequential	programs	2114-3
programs	see	action	Exercise 12.31	2114-3
Bibliographic Notes		sequential	Bibliographic Notes	2115-1
The name datalog	to	constraint	our knowledge	2115-2
The name datalog	was coined	action	our knowledge	2115-2
our knowledge	by	constraint	David Maier	2115-2
Bibliographic Notes		sequential	Many particular classes	2116-1
Many particular classes	of	constraint	datalog programs	2116-1
datalog programs	have been investigated	action	<B>	2116-1
Examples	are	attribute	the class	2116-2
the class	of	constraint	monadic programs	2116-2
monadic programs		sequential	all intensional relations	2116-2
all intensional relations	have	action	arity one	2116-2
arity one		sequential	the class	2116-2
the class	of	constraint	linear programs	2116-2
linear programs	in	constraint	the body	2116-2
the body	of	constraint	each rule	2116-2
each rule	of	constraint	these programs	2116-2
these programs		sequential	there	2116-2
there	at	constraint	most one relation	2116-2
there	can be	action	most one relation	2116-2
most one relation		sequential	that	2116-2
that	with	constraint	the head relation	2116-2
that	is	attribute	mutually recursive	2116-2
the head relation	see	action	Chapter 13	2116-2
Chapter 13		sequential	the class	2116-2
the class	of	constraint	chain programs	2116-2
The fixpoint semantics		sequential	that	2117-1
that		sequential	we	2117-1
we	in	constraint	this chapter	2117-1
we	considered	action	this chapter	2117-1
this chapter	to	constraint	CH85	2117-1
this chapter	is	attribute	due	2117-1
it	in	constraint	the context	2117-2
it	However has been considered much earlier	action	the context	2117-2
the context	of	constraint	logic programming	2117-2
logic programming		sequential	vEK76	2117-2
vEK76		sequential	AvE82	2117-2
<B>	For	constraint	logic programming	2118-1
logic programming		sequential	the existence	2118-1
the existence	of	constraint	a least fixpoint	2118-1
a least fixpoint	is proved	action	Tar55	2118-1
a least fixpoint	using	action	Tar55	2118-1
The study	of	constraint	stage functions stage	2119-1
stage functions stage		sequential	d	2119-1
d		sequential	H	2119-1
H	is	attribute	a major topic	2119-1
a major topic	in	constraint	Mos74	2119-1
Mos74		sequential	they	2119-1
they	for	constraint	finite structures	2119-1
they	where are defined	action	finite structures	2119-1
finite structures		sequential	instances	2119-1
instances	for	constraint	infinite structures	2119-1
Resolution	in	constraint	the context	2120-1
Resolution	was originally proposed	action	the context	2120-1
the context	of	constraint	automatic theorem	2120-1
automatic theorem	proving	action	<B>	2120-1
Its foundations	due to	constraint	Robinson	2120-2
Its foundations	are	attribute	Robinson	2120-2
Robinson		sequential	Rob65	2120-2
SLD resolution	in	constraint	vEK76	2120-3
SLD resolution	was developed	action	vEK76	2120-3
<B>	form	action	the basis	2121-1
the basis	of	constraint	logic programming	2121-1
logic programming	by	constraint	Kowalski	2121-1
logic programming	introduced	action	Kowalski	2121-1
Kowalski		sequential	Kow74	2121-1
Kow74	and	conjunctive	<B>	2121-1
The programming language		sequential	Prolog	2122-1
Prolog	by	constraint	Colmerauer	2122-1
Prolog	proposed	action	Colmerauer	2122-1
Colmerauer		sequential	CKRP73	2122-1
CKRP73	on	constraint	SLD resolution	2122-1
CKRP73	is based	action	SLD resolution	2122-1
It	uses	action	a particular strategy	2122-2
a particular strategy	for	constraint	SLD refutations	2122-2
a particular strategy	for	constraint	SLD refutations	2122-2
a particular strategy	searching	action	SLD refutations	2122-2
Various ways	to	constraint	Prolog	2122-3
Various ways	couple	action	Prolog	2122-3
Prolog	with	constraint	a relational database system	2122-3
a relational database system	have been considered	action	<B>	2122-3
a relational database system	see	action	<B>	2122-3
The undecidability	of	constraint	containment	2123-1
containment	in	constraint	CGKV88	2123-1
containment	is studied	action	CGKV88	2123-1
CGKV88		sequential	Shm87	2123-1
The decidability	of	constraint	uniform containment	2123-2
uniform containment	in	constraint	CK86	2123-2
uniform containment	is shown	action	CK86	2123-2
CK86		sequential	Sag88	2123-2
The decidability	of	constraint	containment	2123-3
containment	for	constraint	monadic programs	2123-3
monadic programs	in	constraint	CGKV88	2123-3
monadic programs	is studied	action	CGKV88	2123-3
The equivalence	of	constraint	datalog programs	2123-4
The equivalence	and	conjunctive	datalog programs	2123-4
datalog programs	to	constraint	CV92	2123-4
datalog programs	in	constraint	CV92	2123-4
datalog programs	is shown	attribute	decidable	2123-4
datalog programs	be	attribute	decidable	2123-4
The complexity	of	constraint	this problem	2123-5
this problem	in	constraint	CV94	2123-5
this problem	is considered	action	CV94	2123-5
<B>		sequential	bounded recursion	2124-1
bounded recursion	in	constraint	the context	2124-1
bounded recursion	and	conjunctive	the context	2124-1
bounded recursion	is defined early	action	the context	2124-1
bounded recursion	used	action	the context	2124-1
the context	of	constraint	universal relations	2124-1
universal relations		sequential	MUV84	2124-1
Example		sequential	12.5.6	2124-2
12.5.6	from	constraint	Nau86	2124-2
12.5.6	is	attribute	Nau86	2124-2
Undecidability results	for	constraint	boundedness	2124-3
boundedness	of	constraint	various datalog classes	2124-3
various datalog classes	in	constraint	GMSV87	2124-3
various datalog classes	are shown	action	GMSV87	2124-3
GMSV87		sequential	GMSV93	2124-3
GMSV93		sequential	Var88	2124-3
Var88		sequential	Abi89	2124-3
Decidability results	for	constraint	particular subclasses	2124-4
particular subclasses	in	constraint	Ioa85	2124-4
particular subclasses	are demonstrated	action	Ioa85	2124-4
Ioa85		sequential	Nau86	2124-4
Nau86		sequential	CGKV88	2124-4
CGKV88		sequential	NS87	2124-4
NS87		sequential	Var88	2124-4
Boundedness	that	constraint	the query	2125-1
Boundedness	implies	action	the query	2125-1
the query	by	constraint	the program	2125-1
the query	expressed	action	the program	2125-1
the program	is	attribute	a positive existential query	2125-1
a positive existential query	in	constraint	CALC	2125-1
a positive existential query	and	conjunctive	CALC	2125-1
a positive existential query	is	attribute	therefore expressible	2125-1
CALC	over	constraint	finite inputs	2125-1
What	about	constraint	the converse	2125-2
<B>	If	constraint	infinite inputs	2126-1
infinite inputs	by	constraint	a compactness argument	2126-1
infinite inputs	are allowed	action	a compactness argument	2126-1
a compactness argument		sequential	unboundedness	2126-1
unboundedness	implies	action	nonexpressibility	2126-1
nonexpressibility	by	constraint	CALC	2126-1
<B>	in	constraint	database	2126-2
<B>	But	conjunctive	database	2126-2
database		sequential	the finite case	2126-2
the finite case		sequential	compactness	2126-2
compactness	and	conjunctive	the question	2126-2
compactness	does not hold	action	the question	2126-2
the question	for	constraint	some time	2126-2
the question	remained	attribute	open	2126-2
Kolaitis	that	constraint	unboundedness	2126-3
Kolaitis	observed	action	unboundedness	2126-3
unboundedness	does not imply	action	nonexpressibility	2126-3
nonexpressibility	by	constraint	CALC	2126-3
CALC	over	constraint	finite structures	2126-3
finite structures	for	constraint	datalog	2126-3
datalog	with	constraint	inequalities	2126-3
inequalities		sequential	x	2126-3
x	=	sequential	y	2126-3
We	did not consider	action	comparators	2126-4
comparators	=	sequential	<B>	2126-4
<B>	in	constraint	this chapter	2126-5
The question	by	constraint	Ajtai	2126-6
The question	was settled	action	Ajtai	2126-6
Ajtai	and	conjunctive	Gurevich	2126-6
Gurevich		sequential	AG89	2126-6
AG89		sequential	who	2126-6
who	by	constraint	an elegant argument	2126-6
who	showed	action	an elegant argument	2126-6
an elegant argument	that	constraint	no unbounded datalog program	2126-6
no unbounded datalog program	in	constraint	CALC	2126-6
no unbounded datalog program	is	attribute	expressible	2126-6
CALC	on	constraint	even finite structures	2126-6
Datalog set	of	constraint	fd	2127-1
fd		sequential	s	2127-1
s	on	constraint	edb	2127-1
edb		sequential	P	2127-1
P	of	constraint	fd	2127-1
P	and	conjunctive	fd	2127-1
P	set	action	fd	2127-1
fd	on	constraint	idb	2127-1
idb		sequential	P	2127-1
P	whether	constraint	P	2127-1
P		sequential	I	2127-1
I		sequential	I	2127-1
The expressive power	of	constraint	datalog	2128-1
datalog	in	constraint	AC89	2128-1
datalog	has been investigated	action	AC89	2128-1
AC89		sequential	ACY91	2128-1
ACY91		sequential	CH85	2128-1
CH85		sequential	Shm87	2128-1
Shm87		sequential	LM89	2128-1
LM89		sequential	KV90c	2128-1
<B>		sequential	datalog	2128-2
datalog	expresses	action	only monotonic queries	2128-2
only monotonic queries		sequential	commutes	2128-2
commutes	with	constraint	homomorphisms	2128-2
homomorphisms	of	constraint	the database	2128-2
the database	if	constraint	there	2128-2
there	are	attribute	no constants	2128-2
no constants	in	constraint	the program	2128-2
the program	in	constraint	polynomial time	2128-2
the program	and	conjunctive	polynomial time	2128-2
the program	can be evaluated	action	polynomial time	2128-2
polynomial time	see	action	also Exercise 12.11	2128-2
It	to	constraint	datalog	2128-3
It	if	constraint	datalog	2128-3
It	is	attribute	natural	2128-3
It	wonder	action	datalog	2128-3
datalog	expresses precisely	action	those queries	2128-3
The answer	is	attribute	negative	2128-4
<B>		sequential	ACY91	2128-5
ACY91	that	constraint	the existence	2128-5
ACY91	shows	action	the existence	2128-5
the existence	of	constraint	a path	2128-5
a path		sequential	whose length	2128-5
whose length	is	attribute	a perfect square	2128-5
a perfect square	between	constraint	two nodes	2128-5
two nodes	in	constraint	datalog=	2128-5
two nodes	is	attribute	not expressible	2128-5
datalog=		sequential	datalog	2128-5
datalog	with	constraint	inequalities	2128-5
datalog	augmented	action	inequalities	2128-5
inequalities		sequential	x	2128-5
x	=	sequential	y	2128-5
y	in	constraint	so not datalog	2128-5
y	and	conjunctive	so not datalog	2128-5
<B>	is	attribute	polynomial	2128-6
time		sequential	a monotonic query	2128-6
a monotonic query	with	constraint	homomorphisms	2128-6
a monotonic query	commuting	action	homomorphisms	2128-6
The parallel complexity	of	constraint	datalog	2128-7
datalog	in	constraint	Kan88	2128-7
datalog	is surveyed	action	Kan88	2128-7
The function symbols	in	constraint	logic programming	2129-1
The function symbols	used	action	logic programming	2129-1
logic programming	over	constraint	a Herbrand domain	2129-1
logic programming	are interpreted	action	a Herbrand domain	2129-1
a Herbrand domain	in	constraint	datalog	2129-1
a Herbrand domain	and	conjunctive	datalog	2129-1
a Herbrand domain	are prohibited	action	datalog	2129-1
it	to	constraint	arithmetic functions	2129-2
it	is	attribute	However interesting	2129-2
it	incorporate	action	arithmetic functions	2129-2
arithmetic functions		sequential	addition	2129-2
addition	and	conjunctive	multiplication	2129-2
multiplication	into	constraint	datalog	2129-2
Such functions	as	constraint	infinite base relations	2129-3
Such functions	can also be viewed	action	infinite base relations	2129-3
<B>	If	constraint	it	2129-4
<B>	are	attribute	present	2129-4
it	that	constraint	bottom	2129-4
it	is	attribute	possible	2129-4
bottom	up	constraint	the evaluation	2129-4
the evaluation	of	constraint	a datalog program	2129-4
a datalog program	will not terminate	action	<B>	2129-4
This issue	in	constraint	RBS87	2129-5
This issue	was first studied	action	RBS87	2129-5
RBS87		sequential	finiteness dependencies	2129-5
finiteness dependencies	where were introduced	action	<B>	2129-5
These dependencies	to	constraint	the finiteness	2129-6
These dependencies	can be used	action	the finiteness	2129-6
These dependencies	describe	action	the finiteness	2129-6
the finiteness	of	constraint	the range	2129-6
the range	of	constraint	a set	2129-6
a set	of	constraint	variables	2129-6
variables	how can imply	action	the finiteness	2129-6
the finiteness	of	constraint	the range	2129-6
the range	of	constraint	another variable	2129-6
<B>	For	constraint	example	2129-7
example		sequential	the relation	2129-7
the relation		sequential	x	2129-7
x		sequential	y	2129-7
y		sequential	z	2129-7
z	satisfies	action	the finiteness dependencies	2129-7
the finiteness dependencies		sequential	x	2129-7
x		sequential	y	2129-7
y		sequential	}	2129-7
}		sequential	❀	2129-7
❀		sequential	z }	2129-7
z }		sequential	x	2129-7
x		sequential	z	2129-7
z		sequential	}	2129-7
}		sequential	❀	2129-7
❀		sequential	y }	2129-7
y }	and	conjunctive	y	2129-7
y		sequential	z	2129-7
z	}	sequential	}	2129-7
z	❀	sequential	}	2129-7
z	x	sequential	}	2129-7
Safety	of	constraint	datalog programs	2129-8
datalog programs	with	constraint	infinite relations	2129-8
infinite relations	by	constraint	finiteness dependencies	2129-8
infinite relations	constrained	action	finiteness dependencies	2129-8
finiteness dependencies	is	attribute	undecidable	2129-8
Various syntactic conditions	on	constraint	datalog programs	2129-9
datalog programs		sequential	that	2129-9
that	ensure	action	safety	2129-9
safety	in	constraint	RBS87	2129-9
safety	are developed	action	RBS87	2129-9
RBS87		sequential	KRS88a	2129-9
KRS88a		sequential	KRS88	2129-9
KRS88		sequential	b	2129-9
b		sequential	SV89	2129-9
Finiteness dependencies	to	constraint	a safety condition	2129-10
Finiteness dependencies	were used	action	a safety condition	2129-10
Finiteness dependencies	develop	action	a safety condition	2129-10
a safety condition	for	constraint	the relational calculus	2129-10
the relational calculus	with	constraint	infinite base relations	2129-10
infinite base relations	in	constraint	EHJ93	2129-10
Safety	in	constraint	the context	2129-11
Safety	was also considered	action	the context	2129-11
the context	of	constraint	data functions	2129-11
data functions		sequential	functions	2129-11
functions		sequential	whose extent	2129-11
whose extent	is predefined	action	<B>	2129-11
Exercises Exercise 12.1	to	constraint	the Parisian Metro database	2130-1
Exercises Exercise 12.1	Refer	action	the Parisian Metro database	2130-1
<B>	Give	action	a datalog program	2130-2
a datalog program		sequential	that	2130-2
that	for	constraint	each pair	2130-2
that	yields	action	each pair	2130-2
each pair	of	constraint	stations	2130-2
stations		sequential	b the stations c	2130-2
b the stations c		sequential	c	2130-2
c	is	attribute	such that reachable	2130-2
1	from	constraint	b	2130-2
1	both	conjunctive	b	2130-2
1	and	conjunctive	b	2130-2
b	and	conjunctive	2	2130-2
2	from	constraint	b	2130-2
2	or	conjunctive	b	2130-2
<B>	Exercise	action	12.2	2131-1
12.2	Consider	action	a database	2131-1
a database	of	constraint	Metro	2131-1
a database	consisting	action	Metro	2131-1
Metro	and	conjunctive	Cinema	2131-1
Cinema		sequential	the databases	2131-1
the databases	plus	conjunctive	a relation Theater Station	2131-1
a relation Theater Station	for	constraint	each theater the closest metro station	2131-1
a relation Theater Station	giving	action	each theater the closest metro station	2131-1
<B>	that	constraint	you	2131-2
<B>	Suppose	action	you	2131-2
you	near	constraint	the Odeon metro station	2131-2
you	live	action	the Odeon metro station	2131-2
<B>	Write	action	a program	2131-3
a program		sequential	that	2131-3
that	answers	action	the query	2131-3
the query	Near	constraint	which metro station	2131-3
which metro station		sequential	I	2131-3
I	can see	action	a Bergman movie	2131-3
a Bergman movie	Having spent	action	many years	2131-3
many years	in	constraint	Los Angeles	2131-3
Los Angeles		sequential	you	2131-3
you	do not like	action	your only option	2131-3
you	walking	action	your only option	2131-3
your only option	to	constraint	the metro	2131-3
your only option	is	attribute	the metro	2131-3
your only option	so take	action	the metro	2131-3
the metro	at	constraint	Odeon	2131-3
Odeon	at	constraint	the station	2131-3
Odeon	and	conjunctive	the station	2131-3
Odeon	get off	action	the station	2131-3
the station	to	constraint	the theater	2131-3
Exercise		sequential	12.3	2131-4
Exercise		sequential	12.4	2132-1
<B>	Write	action	a datalog program P	2132-2
a datalog program P		sequential	that	2132-2
that	computes	action	the set	2132-2
the set	of	constraint	pairs	2132-2
pairs		sequential	a b	2132-2
a b	of	constraint	vertexes	2132-2
vertexes		sequential	there	2132-2
there	exists	action	a path	2132-2
a path	from	constraint	a b	2132-2
a path	to	constraint	a b	2132-2
a b	and	conjunctive	edges	2132-2
edges	with	constraint	a white edge	2132-2
edges	where alternate	action	a white edge	2132-2
edges	starting	action	a white edge	2132-2
Exercises Exercise		sequential	12.5	2133-1
<B>	Although	constraint	Edge	2133-2
Edge	provides	action	directed edges	2133-2
directed edges		sequential	we	2133-2
we	ignore	action	the direction	2133-2
the direction		sequential	we	2133-2
we	so treat	action	the graph	2133-2
the graph	as	constraint	<B>	2133-2
<B>	that	constraint	a vertex	2133-3
<B>	Say	action	a vertex	2133-3
a vertex	if	constraint	it	2133-3
a vertex	is	attribute	good	2133-3
it	to	constraint	a blue vertex	2133-3
it	is connected	action	a blue vertex	2133-3
a blue vertex		sequential	blue	2133-3
blue	is	attribute	a constant	2133-3
a constant	if	constraint	it	2133-3
a constant	or	conjunctive	it	2133-3
it	to	constraint	an excellent vertex	2133-3
it	is connected	action	an excellent vertex	2133-3
An excellent vertex	is	attribute	a vertex	2133-4
a vertex		sequential	that	2133-4
that	to	constraint	an outstanding vertex	2133-4
that	is connected	action	an outstanding vertex	2133-4
an outstanding vertex	to	constraint	a red vertex	2133-4
an outstanding vertex	and	conjunctive	a red vertex	2133-4
An outstanding vertex	is	attribute	a vertex	2133-5
a vertex		sequential	that	2133-5
that	to	constraint	a good vertex	2133-5
that	is connected	action	a good vertex	2133-5
a good vertex		sequential	an excellent one	2133-5
an excellent one	and	conjunctive	a yellow one	2133-5
<B>	Write	action	a datalog program	2133-6
a datalog program		sequential	that	2133-6
that	computes	action	the excellent vertexes	2133-6
Exercise		sequential	12.6	2134-1
12.6	Consider	action	a directed graph G	2134-1
a directed graph G	as	constraint	a binary relation	2134-1
a directed graph G	represented	action	a binary relation	2134-1
<B>	Show	action	a datalog program	2134-2
a datalog program		sequential	that	2134-2
that	computes	action	a binary relation T	2134-2
a binary relation T	containing	action	the pairs	2134-2
the pairs	for	constraint	which	2134-2
which		sequential	there	2134-2
there	b is	action	a path	2134-2
a path	of	constraint	odd length	2134-2
odd length	from	constraint	a b	2134-2
odd length	to	constraint	a b	2134-2
a b	in	constraint	G	2134-2
Exercise		sequential	12.7	2135-1
Exercise		sequential	12.8	2136-1
<B>	Describe	action	the output	2136-2
the output	of	constraint	the program	2136-2
<B>	Now suppose	action	the first rule	2136-3
the first rule	by	constraint	R	2136-3
the first rule	is replaced	action	R	2136-3
R		sequential	x	2136-3
x		sequential	y	2136-3
y		sequential	Q	2136-3
Q		sequential	y	2136-3
y		sequential	x	2136-3
<B>	Describe	action	the output	2136-4
the output	of	constraint	the new program	2136-4
Exercise 12.9 Prove Lemma 12.3.1		sequential	Exercise 12.9 Prove Lemma 12.3.1	2137-1
Exercise		sequential	12.10	2138-1
Exercise 12.11 Suppose		sequential	Exercise 12.11 Suppose	2139-1
<B>	that	constraint	P	2139-2
<B>	Show	action	P	2139-2
P	under	constraint	extensions	2139-2
P	is preserved	action	extensions	2139-2
extensions	and	conjunctive	homomorphisms	2139-2
<B>	if	constraint	G	2139-3
<B>	is	attribute	G	2139-3
G	is	attribute	a graph	2139-3
a graph	satisfying	action	P	2139-3
P		sequential	every supergraph	2139-3
every supergraph	of	constraint	G	2139-3
G	1 satisfies	action	P	2139-3
P	if	constraint	h	2139-3
P	and	conjunctive	h	2139-3
h	is	attribute	a graph homomorphism	2139-3
a graph homomorphism		sequential	h	2139-3
h		sequential	G	2139-3
G	2 satisfies	action	P	2139-3
Exercise		sequential	12.12	2140-1
<B>	that	constraint	nontrivial cycles	2141-1
<B>	Show	action	nontrivial cycles	2141-1
nontrivial cycles	if	constraint	inequalities	2141-1
nontrivial cycles	can be detected	action	inequalities	2141-1
inequalities	of	constraint	the form	2141-1
the form		sequential	x	2141-1
x	=	sequential	y	2141-1
y	in	constraint	rule bodies	2141-1
y	are allowed	action	rule bodies	2141-1
Hint	For	constraint	words	2142-1
Hint	ii consider	action	words	2142-1
words	of	constraint	simple paths	2142-1
words	consisting	action	simple paths	2142-1
simple paths	from	constraint	a b	2142-1
simple paths	to	constraint	a b	2142-1
a b	and	conjunctive	a pumping lemma	2142-1
a b	prove	action	a pumping lemma	2142-1
a pumping lemma	for	constraint	words	2142-1
words	by	constraint	datalog programs	2142-1
words	accepted	action	datalog programs	2142-1
Datalog Exercise 12.14		sequential	Datalog Exercise 12.14	2143-1
<B>	that	constraint	your algorithm	2143-2
<B>	Make	attribute	sure	2143-2
your algorithm	terminates	action	<B>	2143-2
Exercise		sequential	12.15	2144-1
<B>	Let	action	u	2144-2
u	be	attribute	a vector	2144-2
a vector	of	constraint	distinct variables	2144-2
distinct variables	of	constraint	the arity	2144-2
the arity	of	constraint	R.	2144-2
R.	that	constraint	P	2144-2
R.	Demonstrate	action	P	2144-2
P		sequential	I	2144-2
I		sequential	R	2144-2
R	=	sequential	θ	2144-2
θ		sequential	R	2144-2
R		sequential	u	2144-2
u		sequential	there	2144-2
there	is	attribute	a refutation	2144-2
a refutation	of	constraint	R	2144-2
a refutation	←	sequential	R	2144-2
R		sequential	u	2144-2
u	using	action	PI	2144-2
PI	and	conjunctive	substitutions	2144-2
substitutions		sequential	1	2144-2
<B>	.	sequential	<B>	2144-3
<B>	.	sequential	<B>	2144-4
<B>	θn	attribute	such	2144-5
that θ		sequential	θ	2144-5
θ		sequential	1	2144-5
1		sequential	θn	2144-5
Exercise		sequential	12.16	2145-1
Exercise 12.17 Reprove Theorem 12.3.4	using	action	Tarski	2146-1
Tarski	and	conjunctive	Kleene	2146-1
Kleene		sequential	theorems	2146-1
theorems	in	constraint	Remark 12.3.5	2146-1
theorems	stated	action	Remark 12.3.5	2146-1
Exercise		sequential	12.18	2147-1
Exercise Prove Lemma 12.4.8		sequential	12.19	2148-1
<B>	For	constraint	example	2149-1
example		sequential	f	2149-1
f		sequential	g	2149-1
g		sequential	x	2149-1
x		sequential	5	2149-1
5		sequential	y	2149-1
y		sequential	f	2149-1
f		sequential	y	2149-1
y		sequential	x	2149-1
x		sequential	x	2149-1
x	is	attribute	a term	2149-1
<B>	In	constraint	this context	2149-2
this context		sequential	a substitution θ	2149-2
a substitution θ	is	attribute	a mapping	2149-2
a mapping	from	constraint	a subset	2149-2
a subset	of	constraint	var	2149-2
var	into	constraint	the set	2149-2
the set	of	constraint	terms	2149-2
<B>	Given	action	a substitution θ	2149-3
a substitution θ		sequential	it	2149-3
it	in	constraint	the natural manner	2149-3
it	is extended	action	the natural manner	2149-3
the natural manner	to	constraint	all terms	2149-3
the natural manner	include	action	all terms	2149-3
all terms	over	constraint	the domain	2149-3
all terms	constructed	action	the domain	2149-3
the domain	of	constraint	θ	2149-3
<B>	Extend	action	the definitions	2149-4
the definitions	of	constraint	unifier	2149-4
unifier	and	conjunctive	mgu	2149-4
mgu	to	constraint	terms	2149-4
terms	to	constraint	atoms	2149-4
terms	and	conjunctive	atoms	2149-4
atoms	permitting	action	terms	2149-4
<B>	Give	action	an algorithm	2149-5
an algorithm	to	constraint	the mgu	2149-5
an algorithm	obtain	action	the mgu	2149-5
the mgu	of	constraint	two atoms	2149-5
Exercise		sequential	12.21	2150-1
12.21	Prove	action	that	2150-1
that		sequential	Lemma 12.5.1	2150-1
Lemma 12.5.1	to	constraint	datalog programs	2150-1
Lemma 12.5.1	does not generalize	action	datalog programs	2150-1
datalog programs	with	constraint	constants	2150-1
Exercise		sequential	12.22	2151-1
<B>	Prove	action	the generalization	2151-2
the generalization	by	constraint	the technique	2151-2
the generalization	a using	action	the technique	2151-2
the technique	after	constraint	just the statement	2151-2
the technique	outlined	action	just the statement	2151-2
just the statement	of	constraint	the theorem	2151-2
the theorem	b making	action	a direct proof	2151-2
a direct proof	as	constraint	input	2151-2
a direct proof	using	action	input	2151-2
input		sequential	an instance	2151-2
an instance		sequential	IC ∪	2151-2
IC ∪		sequential	a }	2151-2
a }		sequential	C	2151-2
C	is	attribute	where the set	2151-2
where the set	of	constraint	all constants	2151-2
all constants	in	constraint	the program	2151-2
all constants	occurring	action	the program	2151-2
the program	and	conjunctive	each relation	2151-2
the program	and	conjunctive	each relation	2151-2
the program	is	attribute	a new	2151-2
each relation	in	constraint	I	2151-2
I	where contains	action	all tuples	2151-2
all tuples	constructed	action	C ∪	2151-2
all tuples	using	action	C ∪	2151-2
C ∪		sequential	<B>	2151-2
Exercise Prove Proposition 12.5.4		sequential	12.25	2152-1
Exercises Exercise 12.26		sequential	Exercises Exercise 12.26	2153-1
Hint	Modify	action	the proof	2153-2
the proof	of	constraint	Theorem 12.5.5	2153-2
Theorem 12.5.5	by	constraint	each b ∈	2153-2
Theorem 12.5.5	for	constraint	each b ∈	2153-2
Theorem 12.5.5	using	action	each b ∈	2153-2
each b ∈		sequential	a relation Rb such	2153-2
a relation Rb such		sequential	that	2153-2
that		sequential	Rb	2153-2
Rb		sequential	x	2153-2
x		sequential	y	2153-2
y		sequential	iff	2153-2
iff		sequential	R	2153-2
R		sequential	x	2153-2
x		sequential	b	2153-2
b		sequential	y	2153-2
Exercise		sequential	12.27	2154-1
Exercise		sequential	12.29	2155-1
Exercise		sequential	12.31	2156-1
R		sequential	x	2157-1
x		sequential	R	2157-1
R		sequential	y	2157-1
y		sequential	R	2157-1
R		sequential	z	2157-1
z		sequential	S	2157-1
S		sequential	x	2157-1
x		sequential	y	2157-1
y		sequential	z	2157-1
z	in	constraint	ptime	2157-1
z	is	attribute	complete	2157-1
<B>	has been called	action	variously the graph accessibility problem	2157-2
variously the graph accessibility problem	and	conjunctive	the water buffalo problem	2157-2
variously the graph accessibility problem	blooded	action	the water buffalo problem	2157-2
the water buffalo problem		sequential	a water buffalo	2157-2
a water buffalo	if	constraint	its parents	2157-2
a water buffalo	of	constraint	its parents	2157-2
a water buffalo	is blue blooded	attribute	both	2157-2
its parents	only are	action	<B>	2157-2
R		sequential	x	2158-1
x		sequential	R	2158-1
R		sequential	y	2158-1
y		sequential	R	2158-1
R		sequential	z	2158-1
z		sequential	T	2158-1
T		sequential	y	2158-1
y		sequential	x	2158-1
x		sequential	T	2158-1
T		sequential	x	2158-1
x		sequential	z	2158-1
z	in	constraint	ptime	2158-1
z	is	attribute	complete	2158-1
Datalog		sequential	Datalog	2159-1
I	to	constraint	it	2160-1
I	but	conjunctive	it	2160-1
I	don mean	attribute	naive	2160-1
I	sound	attribute	naive	2160-1
I	isn	action	it	2160-1
it	to	constraint	datalog queries	2160-1
it	answer	action	datalog queries	2160-1
Riccardo		sequential	Riccardo	2161-1
<B>	.	sequential	<B>	2161-2
<B>	.	sequential	<B>	2161-3
Vittorio		sequential	Vittorio	2162-1
Sergio		sequential	Sergio	2163-1
We	that	constraint	the evaluation	2163-2
We	will see	action	the evaluation	2163-2
the evaluation	if	constraint	the algorithm	2163-2
the evaluation	is	attribute	much easier	2163-2
the algorithm	knows	action	it	2163-2
it	and	conjunctive	advantage	2163-2
it	where is going	action	advantage	2163-2
it	takes	action	advantage	2163-2
advantage	of	constraint	this knowledge	2163-2
The introduction	of	constraint	datalog	2164-1
datalog	to	constraint	a flurry	2164-1
datalog	led	action	a flurry	2164-1
a flurry	of	constraint	research	2164-1
research	in	constraint	optimization	2164-1
optimization	during	constraint	the late 1980s	2164-1
the late 1980s	and	conjunctive	early 1990s	2164-1
A variety	of	constraint	techniques	2164-2
techniques	emerged	action	a range	2164-2
techniques	covering	action	a range	2164-2
a range	of	constraint	different approaches	2164-2
These techniques	into	constraint	two classes	2164-3
These techniques	are usually separated	action	two classes	2164-3
two classes	whether	constraint	they	2164-3
two classes	depending on	action	they	2164-3
they	on	constraint	bottom	2164-3
they	or	conjunctive	bottom	2164-3
they	focus	action	bottom	2164-3
bottom	up	constraint	evaluation	2164-3
Another key dimension	of	constraint	the techniques	2164-4
the techniques	whether	constraint	they	2164-4
the techniques	concerns	action	they	2164-4
they	on	constraint	direct evaluation	2164-4
they	are based	action	direct evaluation	2164-4
direct evaluation	or	conjunctive	some compilation	2164-4
direct evaluation	propose	action	some compilation	2164-4
some compilation	of	constraint	the query	2164-4
the query	into	constraint	a related query	2164-4
a related query		sequential	which	2164-4
which	is subsequently evaluated	action	a direct technique	2164-4
which	using	action	a direct technique	2164-4
This chapter	provides	action	a brief introduction	2165-1
a brief introduction	to	constraint	this broad family	2165-1
this broad family	of	constraint	heuristic techniques	2165-1
The advantage	of	constraint	techniques	2166-1
techniques	that	constraint	selections	2166-1
techniques	is	attribute	selections	2166-1
selections		sequential	that	2166-1
that	form	action	part	2166-1
part	of	constraint	the initial query	2166-1
the initial query	into	constraint	the rules	2166-1
the initial query	can be propagated	action	the rules	2166-1
the rules	as	constraint	they	2166-1
they	are expanded	action	<B>	2166-1
There	is	attribute	no direct way	2166-2
no direct way	to	constraint	advantage	2166-2
no direct way	take	action	advantage	2166-2
advantage	of	constraint	this information	2166-2
this information	in	constraint	bottom	2166-2
bottom	up	constraint	evaluation	2166-2
evaluation		sequential	it	2166-2
it	that	constraint	bottom up	2166-2
it	so would seem	action	bottom up	2166-2
bottom up		sequential	the technique	2166-2
the technique	at	constraint	a disadvantage	2166-2
the technique	is	attribute	a disadvantage	2166-2
a disadvantage	with	constraint	respect	2166-2
respect	to	constraint	optimization	2166-2
A rather elegant conclusion		sequential	that	2166-3
that	from	constraint	the research	2166-3
that	has emerged	action	the research	2166-3
the research	on	constraint	datalog evaluation	2166-3
datalog evaluation	that	constraint	there	2166-3
datalog evaluation	is	attribute	there	2166-3
there	are	attribute	bottom	2166-3
bottom	up	constraint	techniques	2166-3
techniques		sequential	that	2166-3
that	have essentially	action	the same running time	2166-3
the same running time	as	constraint	techniques	2166-3
the same running time	down	constraint	techniques	2166-3
Exposition	of	constraint	this result	2167-1
this result	is	attribute	a main focus	2167-1
a main focus	of	constraint	this chapter	2167-1
<B>	of	constraint	the evaluation techniques	2168-1
the evaluation techniques	and	conjunctive	our main emphasis	2168-1
the evaluation techniques	presented here	attribute	intricate	2168-1
the evaluation techniques	are	attribute	intricate	2168-1
our main emphasis	on	constraint	the essential ideas	2168-1
our main emphasis	is	attribute	the essential ideas	2168-1
our main emphasis	conveying	action	the essential ideas	2168-1
the essential ideas		sequential	they	2168-1
they	use	action	<B>	2168-1
The discussion	around	constraint	the presentation	2168-2
The discussion	is centered	action	the presentation	2168-2
the presentation	of	constraint	the techniques	2168-2
the techniques	in	constraint	connection	2168-2
connection	with	constraint	a concrete running example	2168-2
<B>	In	constraint	the cases	2168-3
the cases	of	constraint	Query Subquery	2168-3
Query Subquery	and	conjunctive	magic sets	2168-3
magic sets	rewriting	action	we	2168-3
we	also informally describe	action	they	2168-3
they	in	constraint	the general case	2168-3
they	can be applied	action	the general case	2168-3
<B>	to	constraint	a precise understanding	2168-4
<B>	is	attribute	sufficient	2168-4
<B>	give	action	a precise understanding	2168-4
a precise understanding	of	constraint	the techniques	2168-4
the techniques	without	constraint	notation	2168-4
the techniques	by	constraint	notation	2168-4
the techniques	becoming	action	notation	2168-4
the techniques	overwhelmed	action	notation	2168-4
Proofs	of	constraint	the correctness	2168-5
the correctness	of	constraint	these techniques	2168-5
these techniques	as	constraint	exercises	2168-5
these techniques	but	conjunctive	exercises	2168-5
these techniques	and	conjunctive	exercises	2168-5
these techniques	are	attribute	typically lengthy	2168-5
these techniques	are left	action	exercises	2168-5
Evaluation p f m m f d d u u	of	constraint	Datalog f up flat down f f e g f l f l m n o n	2169-1
Datalog f up flat down f f e g f l f l m n o n		sequential	u	2169-1
u		sequential	u	2169-1
u		sequential	u	2169-1
u		sequential	d f m m o g b p	2169-1
d f m m o g b p		sequential	g n m h c e f g h i j k f h	2169-1
g n m h c e f g h i j k f h		sequential	d	2169-1
d		sequential	n i i o p	2169-1
n i i o p		sequential	k u	2169-1
k u		sequential	u d d d	2169-1
u d d d		sequential	j	2169-1
j		sequential	o	2169-1
o		sequential	b d	2169-1
b d		sequential	c	2169-1
c		sequential	Figure	2169-1
Figure		sequential	13.1	2169-1
13.1		sequential	Instance	2169-1
Instance		sequential	I0	2169-1
I0	for	constraint	RSG example	2169-1
RSG example		sequential	Seminaive Evaluation	2169-1
<B>	To	constraint	the other techniques	2169-2
<B>	and	conjunctive	the other techniques	2169-2
<B>	illustrate	attribute	this	2169-2
the other techniques		sequential	we	2169-2
we	as	constraint	a running example	2169-2
we	use	action	a running example	2169-2
a running example		sequential	the program	2169-2
the program		sequential	Reverse	2169-2
Reverse		sequential	Generation	2169-2
Generation		sequential	RSG	2169-2
RSG	by	constraint	rsg x	2169-2
RSG	given	action	rsg x	2169-2
rsg x		sequential	y	2169-2
y		sequential	x	2169-2
x		sequential	y	2169-2
y		sequential	flat rsg	2169-2
flat rsg		sequential	x	2169-2
x		sequential	y	2169-2
y		sequential	up	2169-2
up		sequential	x	2169-2
x		sequential	x1	2169-2
x1		sequential	rsg	2169-2
rsg		sequential	y1	2169-2
y1		sequential	x1	2169-2
x1		sequential	y1	2169-2
y1		sequential	y	2169-2
y	and	conjunctive	the sample instance I0	2169-2
the sample instance I0	in	constraint	Fig	2169-2
the sample instance I0	illustrated	action	Fig	2169-2
13.1		sequential	13.1	2169-3
<B>	is	attribute	a fairly simple program	2169-4
a fairly simple program	but	conjunctive	it	2169-4
it	will allow	action	us	2169-4
us	to	constraint	the main features	2169-4
us	present	action	the main features	2169-4
the main features	of	constraint	the various techniques	2169-4
the various techniques	throughout	constraint	this chapter	2169-4
the various techniques	presented	action	this chapter	2169-4
<B>	If	constraint	bottom up	2170-1
bottom up		sequential	the algorithm	2170-1
the algorithm	of	constraint	Chapter 12	2170-1
Chapter 12	to	constraint	the value	2170-1
Chapter 12	is used	action	the value	2170-1
Chapter 12	compute	action	the value	2170-1
the value	of	constraint	rsg	2170-1
rsg	on	constraint	input I0	2170-1
input I0		sequential	the following values	2170-1
the following values	are obtained	action	level 0	2170-1
level 0		sequential	level 1	2170-1
level 1		sequential	level 2	2170-1
level 2		sequential	level 3	2170-1
level 3		sequential	level 4	2170-1
This algorithm	has been termed	action	the naive algorithm	2171-1
the naive algorithm	for	constraint	datalog evaluation	2171-1
The central idea	of	constraint	the seminaive algorithm	2171-2
the seminaive algorithm	to	constraint	the extent possible	2171-2
the seminaive algorithm	to	constraint	the extent possible	2171-2
the seminaive algorithm	is	attribute	the extent possible	2171-2
the seminaive algorithm	focus	action	the extent possible	2171-2
the extent possible	on	constraint	the new facts	2171-2
the new facts	at	constraint	each level	2171-2
the new facts	generated	action	each level	2171-2
each level	and	conjunctive	the same facts	2171-2
each level	thereby avoid	action	the same facts	2171-2
each level	recomputing	action	the same facts	2171-2
<B>	Consider	action	the facts	2172-1
the facts	inferred	action	the second rule	2172-1
the facts	using	action	the second rule	2172-1
the second rule	of	constraint	RSG	2172-1
RSG	in	constraint	the consecutive stages	2172-1
the consecutive stages	of	constraint	the naive evaluation	2172-1
<B>	At	constraint	each stage	2172-2
each stage		sequential	some new facts	2172-2
some new facts	until	constraint	a fixpoint	2172-2
some new facts	are inferred	action	a fixpoint	2172-2
a fixpoint	is reached	action	<B>	2172-2
<B>	To	constraint	a new fact	2173-1
<B>	infer	action	a new fact	2173-1
a new fact	at	constraint	stage	2173-1
stage		sequential	i	2173-1
i	+	sequential	1	2173-1
1		sequential	one	2173-1
one	at	constraint	one fact	2173-1
one	must use	attribute	least	2173-1
one fact	at	constraint	stage	2173-1
one fact	newly derived	action	stage	2173-1
stage		sequential	i	2173-1
<B>	is	attribute	the main idea	2174-1
the main idea	of	constraint	seminaive evaluation	2174-1
It	by	constraint	the following version	2174-2
It	is captured	action	the following version	2174-2
the following version	of	constraint	RSG	2174-2
RSG	called	action	RSG	2174-2
RSG		sequential	rsg	2174-2
rsg		sequential	x	2174-2
x		sequential	y	2174-2
y		sequential	up	2174-2
up		sequential	x	2174-2
x		sequential	x1	2174-2
x1		sequential	.i rsg	2174-2
.i rsg		sequential	y1	2174-2
y1		sequential	x1	2174-2
x1		sequential	y1	2174-2
y1		sequential	y	2174-2
y		sequential	an instance	2174-2
an instance	of	constraint	the second rule	2174-2
the second rule	for	constraint	<B>	2174-2
the second rule	i ≥ 1	sequential	<B>	2174-2
the second rule	where is included	attribute	each	2174-2
<B>	Strictly speaking	attribute	this	2174-3
<B>	is	attribute	not a datalog program	2174-3
not a datalog program	because	constraint	it	2174-3
it	has	action	an infinite number	2174-3
an infinite number	of	constraint	rules	2174-3
<B>	On	constraint	the other hand	2174-4
the other hand		sequential	it	2174-4
it	is	attribute	not recursive	2174-4
.i	Intuitively contains	action	the facts	2175-1
the facts	in	constraint	rsg rsg	2175-1
rsg rsg	at	constraint	the ith stage	2175-1
rsg rsg	newly inferred	action	the ith stage	2175-1
the ith stage	of	constraint	the naive evaluation	2175-1
<B>	To	constraint	we	2175-2
<B>	see	attribute	this	2175-2
we	note	action	a close relationship	2175-2
a close relationship	between	constraint	the repeated applications	2175-2
the repeated applications	of	constraint	T RSG	2175-2
T RSG	and	conjunctive	the values	2175-2
the values	by	constraint	the .i	2175-2
the values	taken	action	the .i	2175-2
<B>	Let	action	I	2175-3
I	be	attribute	a fixed input instance	2175-3
Then rsg		sequential	RSG RSG	2175-4
RSG RSG	on	constraint	I	2175-4
I	and	conjunctive	when rsg RSG	2175-4
when rsg RSG		sequential	I	2175-4
I	.i	sequential	rsg	2175-4
rsg		sequential	the value	2175-4
the value	of	constraint	rsg T RSG	2175-4
the value	.i	sequential	rsg T RSG	2175-4
rsg T RSG	reaches	action	a fixpoint	2175-4
a fixpoint	on	constraint	I	2175-4
It	for	constraint	i	2176-1
It	is easily verified	action	i	2176-1
i	each ≥	sequential	1	2176-1
1		sequential	that	2176-1
that		sequential	T i−1 RSG ′	2176-1
T i−1 RSG ′		sequential	I	2176-1
I	.i	sequential	rsg	2176-1
rsg	=	sequential	∅	2176-1
∅	and	conjunctive	T	2176-1
T		sequential	i RSG	2176-1
i RSG		sequential	′	2176-1
′		sequential	I	2176-1
I	.i	sequential	rsg	2176-1
rsg	=	sequential	δi	2176-1
δi		sequential	rsg thermore	2176-1
rsg thermore	for	constraint	i	2176-1
i	≥	action	0	2176-1
0		sequential	we	2176-1
we	have	action	rsg i+1	2176-1
rsg i+1		sequential	rsg	2176-1
rsg		sequential	i	2176-1
i		sequential	⊆	2176-1
⊆		sequential	δi+1 ⊆ rsg rsg	2176-1
δi+1 ⊆ rsg rsg		sequential	i+1	2176-1
Therefore RSG j rsg		sequential	Therefore RSG j rsg	2177-1
<B>	if	constraint	j	2177-2
j	satisfies	action	δ rsg ⊆	2177-2
δ rsg ⊆		sequential	∪i	2177-2
∪i		sequential	j δi rsg RSG	2177-2
j δi rsg RSG		sequential	I	2177-2
I		sequential	rsg	2177-2
rsg	=	sequential	∪i	2177-2
∪i		sequential	j	2177-2
j		sequential	δi	2177-2
δi	is	attribute	only rsg j levels	2177-2
only rsg j levels	of	constraint	RSG	2177-2
RSG	to	constraint	RSG	2177-2
RSG	Furthermore need be computed	action	RSG	2177-2
RSG	find	action	RSG	2177-2
RSG		sequential	I	2177-2
I		sequential	rsg	2177-2
<B>		sequential	bottom up	2177-3
bottom up		sequential	evaluation ′	2177-3
evaluation ′	of	constraint	RSG	2177-3
RSG	typically involves	action	much less redundant computation	2177-3
much less redundant computation	than	constraint	bottom	2177-3
bottom	up	constraint	direct evaluation	2177-3
direct evaluation	of	constraint	RSG	2177-3
<B>	with	constraint	the informal development	2178-1
<B>	Continuing	action	the informal development	2178-1
the informal development		sequential	we	2178-1
we	introduce now	action	two refinements	2178-1
two refinements		sequential	that	2178-1
that	further reduce	action	the amount	2178-1
the amount	of	constraint	redundant computation	2178-1
<B>	on	constraint	the observation	2178-2
<B>	is	attribute	the observation	2178-2
<B>	based	action	the observation	2178-2
the observation	that	constraint	RSG′	2178-2
the observation	when executing	action	RSG′	2178-2
RSG′		sequential	we	2178-2
we	do not always have	action	δi+1	2178-2
δi+1		sequential	rsg rsg i+1	2178-2
rsg rsg i+1		sequential	rsg	2178-2
rsg		sequential	i	2178-2
<B>	Using	action	I0	2178-3
I0		sequential	we	2178-3
we	have	action	g	2178-3
g		sequential	f	2178-3
f		sequential	∈ δ 2	2178-3
∈ δ 2	in	constraint	not rsg rsg 2	2178-3
∈ δ 2	but	conjunctive	not rsg rsg 2	2178-3
not rsg rsg 2	−	sequential	rsg 1	2178-3
<B>	that	constraint	the efficiency	2178-4
<B>	suggests	action	the efficiency	2178-4
the efficiency	by	constraint	rsg	2178-4
the efficiency	can be further improved	action	rsg	2178-4
the efficiency	using	action	rsg	2178-4
rsg		sequential	rsg	2178-4
rsg		sequential	i i−1	2178-4
i i−1	in	constraint	place	2178-4
place	of	constraint	.i	2178-4
.i	in	constraint	the body	2178-4
the body	of	constraint	the second rule	2178-4
the second rule	of	constraint	RSG ′	2178-4
rsg	Using	action	a pidgin language	2179-1
a pidgin language		sequential	that	2179-1
that	both	conjunctive	datalog	2179-1
that	combines	action	datalog	2179-1
datalog	and	conjunctive	commands	2179-1
commands		sequential	the new version RSG′′	2179-1
the new version RSG′′	by	constraint	<B>	2179-1
the new version RSG′′	is given	action	<B>	2179-1
rsg		sequential	x	2180-1
x		sequential	y	2180-1
y		sequential	x	2180-1
x		sequential	y	2180-1
y		sequential	rsg	2180-1
rsg		sequential	1 rsg	2180-1
1 rsg		sequential	x	2180-1
x		sequential	y	2180-1
y		sequential	x	2180-1
x		sequential	x1	2180-1
x1		sequential	.i	2180-1
.i		sequential	rsg	2180-1
rsg		sequential	y1	2180-1
y1		sequential	x1	2180-1
x1		sequential	down	2180-1
down		sequential	y1 rsg temp i+1 rsg rsg i rsg i ∪ rsg	2180-1
y1 rsg temp i+1 rsg rsg i rsg i ∪ rsg		sequential	y	2180-1
y		sequential		2180-1
		sequential	.i+1	2180-1
Evaluation	of	constraint	Datalog	2181-1
<B>	To	constraint	the nonlinear version	2181-2
<B>	illustrate	action	the nonlinear version	2181-2
<B>	consider	action	the nonlinear version	2181-2
the nonlinear version	of	constraint	the ancestor program	2181-2
par		sequential	x y	2182-1
x y		sequential	temp	2182-1
temp		sequential	i+1	2182-1
i+1	−	sequential	anc i	2182-1
<B>	Consider now	action	an input instance	2183-1
an input instance	of	constraint	par	2183-1
an input instance	consisting	action	par	2183-1
par		sequential	1	2183-1
1		sequential	2	2183-1
2		sequential	par	2183-1
par		sequential	2	2183-1
2		sequential	3	2183-1
we	of	constraint	the rules	2183-2
we	Then have Furthermore	attribute	both	2183-2
the rules	for	constraint	temp 2	2183-2
temp 2	will compute	action	the join	2183-2
the join	of	constraint	tuples	2183-2
tuples		sequential	1	2183-2
temp i+1		sequential	x	2184-1
x		sequential	y	2184-1
y	←	sequential	anc	2184-1
y	.i	sequential	anc	2184-1
anc		sequential	x	2184-1
x		sequential	z	2184-1
z		sequential	anc	2184-1
anc		sequential	i−1	2184-1
i−1		sequential	z	2184-1
z		sequential	y	2184-1
y		sequential	temp i+1	2184-1
temp i+1		sequential	x	2184-1
x		sequential	y	2184-1
y		sequential	anc i	2184-1
anc i		sequential	x	2184-1
x		sequential	z	2184-1
z	.i	sequential	anc	2184-1
anc		sequential	z	2184-1
z		sequential	y	2184-1
We	now present	action	the seminaive algorithm	2185-1
the seminaive algorithm	for	constraint	the general case	2185-1
<B>	Let	action	P	2185-2
P	be	attribute	a datalog program	2185-2
a datalog program	over	constraint	edb	2185-2
edb		sequential	R	2185-2
R	and	conjunctive	idb T.	2185-2
idb T.	Consider	action	a rule S	2185-2
a rule S		sequential	u	2185-2
u	←	sequential	R1	2185-2
R1		sequential	v1	2185-2
<B>	.	sequential	<B>	2185-3
<B>	.	sequential	<B>	2185-4
Rn		sequential	vn	2185-5
vn		sequential	T1	2185-5
T1		sequential	w1	2185-5
<B>	.	sequential	<B>	2185-6
<B>	.	sequential	<B>	2185-7
Tm		sequential	wm	2185-8
wm	in	constraint	P	2185-8
P		sequential	the Rk	2185-8
the Rk	are	attribute	where edb predicates	2185-8
where edb predicates	and	conjunctive	the Tj	2185-8
the Tj		sequential	s	2185-8
s	are	attribute	idb predicates	2185-8
<B>	for	constraint	each j ∈	2185-9
<B>	Construct	action	each j ∈	2185-9
each j ∈		sequential	1	2185-9
1		sequential	m	2185-9
m	and	conjunctive	i	2185-9
i		sequential	≥	2185-9
≥		sequential	1	2185-9
1		sequential	the rule temp	2185-9
the rule temp		sequential	i+1	2185-9
i+1		sequential	u	2185-9
u		sequential	R S T i1	2185-9
R S T i1		sequential	w1	2185-9
<B>	.	sequential	<B>	2185-10
<B>	.	sequential	<B>	2185-11
T i j −		sequential	1	2185-12
1		sequential	wj	2185-12
wj	−	sequential	1	2185-12
1		sequential	.iT j	2185-12
.iT j		sequential	T i−1	2185-12
T i−1		sequential	j +1	2185-12
<B>	.	sequential	<B>	2185-13
<B>	.	sequential	<B>	2185-14
T i−1		sequential	j	2185-15
j		sequential	j	2185-15
j		sequential	+1 m	2185-15
<B>	Let	action	P	2186-1
P		sequential	i	2186-1
i	represent	action	the set	2186-1
the set	of	constraint	all i-level rules	2186-1
all i-level rules	of	constraint	this form	2186-1
this form	for	constraint	the idb predicate S S	2186-1
this form	constructed	action	the idb predicate S S	2186-1
<B>	that	constraint	T1	2187-1
<B>	S Suppose now	action	T1	2187-1
<B>	.	sequential	<B>	2187-2
<B>	.	sequential	<B>	2187-3
Tl	is	attribute	a listing	2187-4
a listing	of	constraint	the idb predicates	2187-4
the idb predicates	of	constraint	P	2187-4
P		sequential	that	2187-4
that	in	constraint	the body	2187-4
that	occur	action	the body	2187-4
the body	of	constraint	a rule	2187-4
a rule	defining	action	S	2187-4
S		sequential	We	2187-4
We	write	action	P	2187-4
P		sequential	i	2187-4
i		sequential	I	2187-4
I		sequential	T i−1	2187-4
<B>	.	sequential	<B>	2187-5
<B>	.	sequential	<B>	2187-6
T i−1 T i S l l T1 Tl	to	constraint	the set	2187-7
T i−1 T i S l l T1 Tl	denote	action	the set	2187-7
the set	of	constraint	tuples	2187-7
tuples		sequential	that	2187-7
that	from	constraint	the rules	2187-7
that	result	action	the rules	2187-7
that	applying	action	the rules	2187-7
the rules	in	constraint	P	2187-7
P		sequential	i	2187-7
i	to	constraint	values	2187-7
i	given	action	values	2187-7
values	for	constraint	input S instance	2187-7
input S instance		sequential	I	2187-7
I	for	constraint	the T i−1	2187-7
I	and	conjunctive	the T i−1	2187-7
the T i−1		sequential	T i	2187-7
T i	and	conjunctive	.i	2187-7
j j Tj		sequential	j j Tj	2188-1
<B>	.	sequential	<B>	2188-2
<B>	.	sequential	<B>	2188-3
Tl	begin	action	Si	2188-4
Si	=	sequential	Si−1	2188-4
Si−1		sequential	∪	2188-4
∪		sequential	.i	2188-4
.i		sequential	S S	2188-4
S S		sequential	l l T1 Tl end	2188-4
l l T1 Tl end		sequential	i	2188-4
i	=	sequential	i	2188-4
i	+	sequential	1 end	2188-4
1 end	until	constraint	each idb predicate S	2188-4
1 end	for	constraint	each idb predicate S	2188-4
1 end	.i	sequential	each idb predicate S	2188-4
1 end	=	sequential	each idb predicate S	2188-4
1 end	∅	sequential	each idb predicate S	2188-4
S		sequential	S	2189-1
The correctness	of	constraint	this algorithm	2190-1
this algorithm	in	constraint	Exercise 13.3	2190-1
this algorithm	is demonstrated	action	Exercise 13.3	2190-1
it	However is still doing	action	a lot	2190-2
a lot	of	constraint	unnecessary work	2190-2
unnecessary work	on	constraint	some programs	2190-2
We	now analyze	action	the structure	2190-3
the structure	of	constraint	datalog programs	2190-3
datalog programs	to	constraint	an improved version	2190-3
datalog programs	develop	action	an improved version	2190-3
an improved version	of	constraint	the seminaive algorithm	2190-3
It	that	constraint	this analysis	2190-4
It	turns out	action	this analysis	2190-4
this analysis	with	constraint	simple control	2190-4
simple control	of	constraint	the computation	2190-4
the computation	allows	action	us	2190-4
us	to	constraint	advance	2190-4
us	in	constraint	advance	2190-4
us	know	action	advance	2190-4
advance		sequential	which	2190-4
which	to	constraint	each iteration	2190-4
which	at	constraint	each iteration	2190-4
which	predicates	attribute	likely	2190-4
which	are	attribute	likely	2190-4
which	grow	action	each iteration	2190-4
each iteration	and	conjunctive	which	2190-4
which	because	constraint	they	2190-4
which	either	conjunctive	they	2190-4
which	are not	action	they	2190-4
they	because	constraint	they	2190-4
they	or	conjunctive	they	2190-4
they	are already saturated	action	they	2190-4
they	by	constraint	the computation	2190-4
they	are not yet affected	action	the computation	2190-4
<B>	Let	action	P	2191-1
P	be	attribute	a datalog program	2191-1
<B>	Form	action	the precedence graph GP	2191-2
the precedence graph GP	for	constraint	P	2191-2
P	as	constraint	<B>	2191-2
P	follows	action	<B>	2191-2
P	if	constraint	GP	2191-3
P	is	attribute	recursive	2191-3
GP	has	action	a directed cycle	2191-3
Two predicates		sequential	R	2191-4
R	and	conjunctive	R′	2191-4
R′	if	constraint	R	2191-4
R′	are	attribute	mutually recursive	2191-4
R	=	sequential	R′	2191-4
R′	or	conjunctive	R	2191-4
R	and	conjunctive	R′	2191-4
R′	in	constraint	the same Evaluation	2191-4
R′	participate	action	the same Evaluation	2191-4
the same Evaluation	of	constraint	Datalog cycle	2191-4
Datalog cycle	of	constraint	GP	2191-4
Mutual recursion	is	attribute	an equivalence relation	2191-5
an equivalence relation	on	constraint	the idb predicates	2191-5
the idb predicates	of	constraint	P	2191-5
P		sequential	each equivalence class	2191-5
each equivalence class	to	constraint	a strongly connected component	2191-5
each equivalence class	where corresponds	action	a strongly connected component	2191-5
a strongly connected component	of	constraint	GP	2191-5
A rule	of	constraint	P	2191-6
P	if	constraint	the body	2191-6
P	is	attribute	recursive	2191-6
the body	involves	action	a predicate	2191-6
a predicate		sequential	that	2191-6
that	with	constraint	the head	2191-6
that	is	attribute	mutually recursive	2191-6
We	now have	action	the following Input Datalog program	2192-1
the following Input Datalog program	and	conjunctive	P edb instance	2192-1
P edb instance		sequential	I	2192-1
I	Output	action	P I	2192-1
The correctness	of	constraint	this algorithm	2193-1
this algorithm	as	constraint	Exercise 13.4	2193-1
this algorithm	is left	action	Exercise 13.4	2193-1
Linear Datalog		sequential	Linear Datalog	2194-1
<B>	Let	action	P	2195-1
P	be	attribute	a program	2195-1
A rule	in	constraint	P	2195-2
P	with	constraint	head relation R	2195-2
head relation R	if	constraint	there	2195-2
head relation R	is	attribute	linear	2195-2
there	at	constraint	most one atom	2195-2
there	is	attribute	most one atom	2195-2
most one atom	in	constraint	the body	2195-2
the body	of	constraint	the rule	2195-2
the rule		sequential	whose predicate	2195-2
whose predicate	with	constraint	R.	2195-2
whose predicate	is	attribute	mutually recursive	2195-2
R.		sequential	P	2195-2
P	if	constraint	each rule	2195-2
P	is	attribute	linear	2195-2
each rule	in	constraint	P	2195-2
P	is	attribute	linear	2195-2
We	now show	action	the Improved Seminaive Algorithm	2195-3
the Improved Seminaive Algorithm	for	constraint	such programs	2195-3
the Improved Seminaive Algorithm	can be simplified	action	such programs	2195-3
<B>	that	constraint	P	2196-1
<B>	Suppose	action	P	2196-1
P	is	attribute	a linear program	2196-1
a linear program	and	conjunctive	a rule	2196-1
a linear program	is	attribute	a rule	2196-1
a rule	in	constraint	P	2196-1
P		sequential	Tj	2196-1
Tj	with	constraint	R. Associate	2196-1
Tj	is	attribute	where mutually recursive	2196-1
R. Associate	with	constraint	the rule R j	2196-1
<B>	.	sequential	<B>	2196-2
<B>	.	sequential	<B>	2196-3
Tn		sequential	vn	2196-4
j	that	constraint	the only rule	2197-1
j	Note	attribute	this	2197-1
j	is	attribute	the only rule	2197-1
the only rule		sequential	that	2197-1
that	by	constraint	the Improved Seminaive Algorithm	2197-1
that	will be associated	action	the Improved Seminaive Algorithm	2197-1
the Improved Seminaive Algorithm	with	constraint	ρ	2197-1
<B>	given	action	an equivalence class	2197-2
an equivalence class		sequential	Tk	2197-2
Tk	of	constraint	mutually recursive predicates	2197-2
mutually recursive predicates	of	constraint	P	2197-2
P		sequential	the rules	2197-2
the rules	for	constraint	predicates S	2197-2
predicates S	in	constraint	Tk	2197-2
Tk	Thus use	action	only the .i	2197-2
only the .i	but	conjunctive	not the Si	2197-2
<B>	In	constraint	contrast	2197-3
contrast	as	constraint	S	2197-3
contrast	seen earlier	action	S	2197-3
S	both	conjunctive	the .i	2197-3
the .i	and	conjunctive	Si	2197-3
Si	in	constraint	nonlinear programs	2197-3
Si	must be used	action	nonlinear programs	2197-3
S Top -Down Techniques	Consider	action	the RSG program	2198-1
the RSG program	from	constraint	the previous section	2198-1
the previous section	with	constraint	a query	2198-1
the previous section	augmented	action	a query	2198-1
the previous section	selection based	action	a query	2198-1
a query		sequential	rsg	2198-1
rsg		sequential	x	2198-1
x		sequential	y	2198-1
y		sequential	x y	2198-1
x y		sequential	rsg	2198-1
rsg		sequential	x	2198-1
x		sequential	y	2198-1
y		sequential	up	2198-1
up		sequential	x	2198-1
x		sequential	x1	2198-1
x1		sequential	rsg	2198-1
rsg		sequential	y1	2198-1
y1		sequential	x1	2198-1
x1		sequential	y1	2198-1
y1		sequential	y	2198-1
y		sequential	query	2198-1
query		sequential	y	2198-1
y	←	sequential	rsg	2198-1
rsg		sequential	a	2198-1
a		sequential	y	2198-1
y	is	attribute	where a constant	2198-1
This program	will be called	action	the RSG query	2198-2
<B>	that	constraint	seminaive evaluation	2198-3
<B>	Suppose	action	seminaive evaluation	2198-3
seminaive evaluation	is used	action	<B>	2198-3
each pair	of	constraint	rsg	2198-4
rsg	Then will be produced	attribute	those	2198-4
rsg	including	attribute	those	2198-4
that	to	constraint	any element	2198-4
that	are not used	action	any element	2198-4
that	derive	action	any element	2198-4
any element	of	constraint	query	2198-4
<B>	For	constraint	example	2198-5
example	using	action	I0	2198-5
I0	of	constraint	Fig	2198-5
13.1	as	constraint	input	2198-6
input		sequential	fact rsg	2198-6
fact rsg		sequential	f	2198-6
f		sequential	k	2198-6
k	but	conjunctive	<B>	2198-6
k	will be produced	action	<B>	2198-6
k	not used	action	<B>	2198-6
A primary motivation	for	constraint	the approaches	2198-7
the approaches	to	constraint	datalog query evaluation	2198-7
datalog query evaluation	to	constraint	the extent possible	2198-7
datalog query evaluation	to	constraint	the extent possible	2198-7
datalog query evaluation	is	attribute	the extent possible	2198-7
datalog query evaluation	avoid	action	the extent possible	2198-7
the extent possible		sequential	the production	2198-7
the production	of	constraint	tuples	2198-7
tuples		sequential	that	2198-7
that	to	constraint	any answer tuples	2198-7
that	are not needed	action	any answer tuples	2198-7
that	derive	action	any answer tuples	2198-7
<B>	For	constraint	this discussion	2199-1
this discussion		sequential	we	2199-1
we	define	action	a datalog query	2199-1
a datalog query	to	constraint	a pair	2199-1
a datalog query	be	attribute	a pair	2199-1
a pair		sequential	P	2199-1
P		sequential	q	2199-1
q		sequential	P	2199-1
P	is	attribute	where a datalog program	2199-1
where a datalog program	and	conjunctive	q	2199-1
q	is	attribute	a datalog rule	2199-1
a datalog rule	using	action	relations	2199-1
relations	of	constraint	P	2199-1
P	in	constraint	its body	2199-1
its body	and	conjunctive	the new relation query	2199-1
the new relation query	in	constraint	its head	2199-1
We	that	constraint	there	2199-2
We	generally assume	action	there	2199-2
there	is	attribute	only one rule	2199-2
only one rule	defining	action	the predicate query	2199-2
the predicate query	and	conjunctive	it	2199-2
it	has	action	the form query	2199-2
the form query		sequential	u	2199-2
u		sequential	R	2199-2
R		sequential	v	2199-2
v	for	constraint	some idb predicate R	2199-2
<B>		sequential	The approaches	2200-1
The approaches	use	action	natural heuristics	2200-1
natural heuristics	to	constraint	attention	2200-1
natural heuristics	focus	action	attention	2200-1
attention	on	constraint	relevant facts	2200-1
<B>	In	constraint	they	2200-2
they	use	action	the framework	2200-2
the framework	by	constraint	SLD resolution	2200-2
the framework	provided	action	SLD resolution	2200-2
The starting point	for	constraint	these algorithms	2200-3
these algorithms		sequential	the query	2200-3
the query	to	constraint	constants	2200-3
the query	be answered	action	constants	2200-3
the query	often includes	action	constants	2200-3
constants	have	action	the effect	2200-3
the effect	of	constraint	the search	2200-3
the effect	restricting	action	the search	2200-3
the search	for	constraint	derivation trees	2200-3
derivation trees	and	conjunctive	thus the set	2200-3
thus the set	of	constraint	facts	2200-3
facts	produced	action	<B>	2200-3
<B>	In	constraint	the context	2200-4
the context	of	constraint	databases	2200-4
databases	without	constraint	function symbols	2200-4
function symbols		sequential	top down	2200-4
top down		sequential	the datalog evaluation algorithms	2200-4
the datalog evaluation algorithms	to	constraint	all inputs	2200-4
the datalog evaluation algorithms	on	constraint	all inputs	2200-4
the datalog evaluation algorithms	can generally be forced	action	all inputs	2200-4
the datalog evaluation algorithms	terminate	action	all inputs	2200-4
all inputs		sequential	SLD	2200-4
SLD		sequential	resolution	2200-4
resolution		sequential	the corresponding algorithm	2200-4
the corresponding algorithm	when does not	action	<B>	2200-4
<B>	In	constraint	this section	2200-5
this section		sequential	we	2200-5
we	on	constraint	query subquery	2200-5
we	focus	action	query subquery	2200-5
query subquery		sequential	QSQ	2200-5
QSQ		sequential	primarily the framework	2200-5
There	are	attribute	four basic elements	2201-1
four basic elements	of	constraint	this framework	2201-1
<B>	Recall	action	the RSG query	2202-1
the RSG query	given earlier	action	<B>	2202-1
<B>	Consider	action	an SLD tree	2202-2
an SLD tree	for	constraint	it	2202-2
The child	of	constraint	the root	2202-3
the root	be	attribute	would rsg	2202-3
<B>	Speaking intuitively	action	not all values	2202-4
not all values	for	constraint	rsg	2202-4
rsg	but	conjunctive	rather only those Evaluation	2202-4
rsg	are requested	action	rather only those Evaluation	2202-4
rather only those Evaluation	of	constraint	Datalog	2202-4
Datalog	with	constraint	<B>	2202-4
Datalog	first coordinate	attribute	a	2202-4
we	in	constraint	derivations	2202-5
we	are	attribute	More generally interested	2202-5
we	finding	action	derivations	2202-5
derivations	for	constraint	rsg	2202-5
rsg		sequential	the first coordinate	2202-5
the first coordinate	and	conjunctive	the second coordinate	2202-5
the first coordinate	where is bound	action	the second coordinate	2202-5
the second coordinate	is	attribute	free	2202-5
<B>	by	constraint	the expression	2202-6
<B>	is denoted	action	the expression	2202-6
the expression		sequential	rsg bf	2202-6
rsg bf		sequential	the superscript	2202-6
the superscript		sequential	bf	2202-6
bf	where is called	action	an adornment	2202-6
The next layer	of	constraint	the SLD tree	2203-1
the SLD tree	will have	action	a node	2203-1
a node	holding	attribute	flat	2203-1
a y	and	conjunctive	a node	2203-1
a node	holding up	action	a x1	2203-1
a x1		sequential	rsg	2203-1
rsg		sequential	y1	2203-1
y1		sequential	x1	2203-1
x1		sequential	y1	2203-1
y1		sequential	y	2203-1
Answers	for	constraint	these nodes	2203-2
Answers	of	constraint	these nodes	2203-2
Answers	generated	attribute	the first	2203-2
these nodes	by	constraint	π	2203-2
these nodes	are given	action	π	2203-2
π		sequential	2	2203-2
2		sequential	σ 1	2203-2
σ 1	=	sequential	a	2203-2
a		sequential	<B>	2203-2
Answers	for	constraint	the other node	2203-3
the other node	by	constraint	a evaluation	2203-3
the other node	to	constraint	a evaluation	2203-3
the other node	can be generated	attribute	left	2203-3
the set	of	constraint	possible values	2203-4
possible values	for	constraint	x1	2203-4
x1	is	attribute	J	2203-4
J	First =	sequential	π 2	2203-4
π 2		sequential	σ 1	2203-4
σ 1	=	sequential	a	2203-4
a		sequential	up	2203-4
the possible values	for	constraint	y1	2203-5
y1	by	constraint	y1	2203-5
y1	Next are given	action	y1	2203-5
y1	|	sequential	y1	2203-5
y1		sequential	x1 ∈ rsg	2203-5
x1 ∈ rsg	and	conjunctive	x1 ∈ J }	2203-5
x1 ∈ J }		sequential	the first coordinate values	2203-5
the first coordinate values	of	constraint	rsg	2203-5
rsg	from	constraint	second coordinate values	2203-5
rsg	stemming	action	second coordinate values	2203-5
second coordinate values	in	constraint	J	2203-5
<B>	for	constraint	an evaluation	2203-6
<B>	calls	action	an evaluation	2203-6
an evaluation	of	constraint	rsg f b	2203-6
rsg f b		sequential	the second coordinate values	2203-6
the second coordinate values	by	constraint	J	2203-6
the second coordinate values	where are bound	action	J	2203-6
<B>	given	action	y1 values	2204-1
y1 values	with	constraint	y values	2204-1
y1 values	to	constraint	y values	2204-1
y1 values	can be used	action	y values	2204-1
y1 values	obtain	action	y values	2204-1
y values		sequential	answers	2204-1
answers	to	constraint	the query	2204-1
query	to	constraint	the instance	2205-1
query	were applied	action	the instance	2205-1
the instance	of	constraint	Fig	2205-1
the first subquery	be	attribute	13.1 would rsg f b	2205-2
the first subquery	generated	action	13.1 would rsg f b	2205-2
13.1 would rsg f b		sequential	e	2205-2
e		sequential	f	2205-2
f		sequential	}	2205-2
<B>	As	constraint	we	2205-3
we	shall see	action	the QSQ framework	2205-3
the QSQ framework	on	constraint	a systematic evaluation	2205-3
the QSQ framework	is based	action	a systematic evaluation	2205-3
a systematic evaluation	of	constraint	subqueries	2205-3
<B>	Let	action	P	2206-1
P	be	attribute	a datalog program	2206-1
a datalog program	and	conjunctive	I	2206-1
I		sequential	an input instance	2206-1
<B>	that	constraint	R	2206-2
<B>	Suppose	action	R	2206-2
R	is	attribute	an idb predicate	2206-2
an idb predicate	and	conjunctive	γ	2206-2
γ	is	attribute	an adornment	2206-2
an adornment	for	constraint	R	2206-2
R		sequential	a string	2206-2
a string	of	constraint	b	2206-2
b		sequential	s	2206-2
s	and	conjunctive	f	2206-2
f	having	action	length	2206-2
length		sequential	the arity	2206-2
the arity	of	constraint	R	2206-2
<B>	bound	action	R	2206-3
R		sequential	γ	2206-3
γ	Then denotes	action	the coordinates	2206-3
the coordinates	of	constraint	R	2206-3
R	in	constraint	γ	2206-3
R	bound	action	γ	2206-3
<B>	Let	action	t	2206-4
t	be	attribute	a tuple	2206-4
a tuple	over	constraint	R	2206-4
R		sequential	γ	2206-4
a completion	for	constraint	t	2207-1
t	in	constraint	Rγ	2207-1
Rγ	is	attribute	a tuple	2207-1
a tuple		sequential	that	2207-1
that	s	action	R	2207-1
that	bound	action	R	2207-1
R		sequential	γ	2207-1
γ	=	sequential	t	2207-1
t	and	conjunctive	∈	2207-1
∈		sequential	P	2207-1
P		sequential	I	2207-1
I		sequential	R	2207-1
The answer	to	constraint	a subquery	2208-1
a subquery		sequential	Rγ	2208-1
Rγ		sequential	J	2208-1
J	over	constraint	I	2208-1
I	is	attribute	the set	2208-1
the set	of	constraint	all completions	2208-1
all completions	of	constraint	all tuples	2208-1
all tuples	in	constraint	J	2208-1
The use	of	constraint	adornments	2209-1
adornments	within	constraint	a rule body	2209-1
a rule body	is	attribute	a generalization	2209-1
a generalization	of	constraint	the technique	2209-1
the technique	of	constraint	sideways information passing	2209-1
sideways information passing	in	constraint	Chapter 6	2209-1
sideways information passing	discussed	action	Chapter 6	2209-1
<B>	Consider	action	the rule	2209-2
the rule		sequential	R	2209-2
R		sequential	x	2209-2
x		sequential	y	2209-2
y		sequential	z	2209-2
z		sequential	R1	2209-2
R1		sequential	x	2209-2
x		sequential	u	2209-2
u		sequential	v	2209-2
v		sequential	R2	2209-2
R2		sequential	u	2209-2
u		sequential	w	2209-2
w		sequential	w	2209-2
w		sequential	z	2209-2
z		sequential	R3	2209-2
R3		sequential	v	2209-2
v		sequential	w	2209-2
w		sequential	y	2209-2
y		sequential	<B>	2209-2
<B>	that	constraint	a subquery	2210-1
<B>	Suppose	action	a subquery	2210-1
a subquery	involving	action	R bfb	2210-1
R bfb	is invoked	action	<B>	2210-1
<B>	to	constraint	a evaluation	2210-2
<B>	Assuming	attribute	left	2210-2
a evaluation	to	constraint	subqueries	2210-2
a evaluation	will lead	action	subqueries	2210-2
subqueries	involving	action	bff bffb bbfb R bff bffb bbfb R	2210-2
bff bffb bbfb R bff bffb bbfb R		sequential	bfb	2210-2
bfb		sequential	x	2210-2
x		sequential	y	2210-2
y		sequential	z	2210-2
z	←	sequential	R	2210-2
R	to	constraint	the adornments	2210-2
R	emphasize	action	the adornments	2210-2
<B>	is	attribute	an example	2210-3
an example	of	constraint	an adorned rule	2210-3
<B>	As	constraint	we	2210-4
we	shall see	action	the adornments	2210-4
the adornments	of	constraint	idb	2210-4
idb	in	constraint	rule bodies	2210-4
idb	predicates	action	rule bodies	2210-4
rule bodies	to	constraint	evaluations	2210-4
rule bodies	shall be used	action	evaluations	2210-4
rule bodies	guide	action	evaluations	2210-4
evaluations	of	constraint	queries	2210-4
queries	and	conjunctive	subqueries	2210-4
It	to	constraint	the adornments	2210-5
It	is	attribute	common	2210-5
It	omit	action	the adornments	2210-5
the adornments	of	constraint	edb predicates	2210-5
The general algorithm	for	constraint	a rule	2211-1
The general algorithm	adorning	action	a rule	2211-1
a rule	given	action	an adornment	2211-1
an adornment	for	constraint	the head	2211-1
the head	and	conjunctive	an ordering	2211-1
an ordering	of	constraint	the rule body	2211-1
the rule body	as	constraint	All occurrences	2211-1
the rule body	is	attribute	All occurrences	2211-1
the rule body	follows	action	All occurrences	2211-1
All occurrences	of	constraint	each bound variable	2211-1
each bound variable	in	constraint	the rule head	2211-1
the rule head	1 are bound	action	all occurrences	2211-1
all occurrences	of	constraint	constants	2211-1
constants	if	constraint	a variable x	2211-1
constants	and	conjunctive	a variable x	2211-1
constants	2 are bound	action	a variable x	2211-1
a variable x	in	constraint	the rule body	2211-1
a variable x	occurs	action	the rule body	2211-1
the rule body		sequential	all occurrences	2211-1
all occurrences	of	constraint	x	2211-1
x	in	constraint	subsequent literals	2211-1
subsequent literals	3 are bound	action	<B>	2211-1
The definition	of	constraint	adorned rule	2212-1
adorned rule	to	constraint	situations	2212-1
adorned rule	also applies	action	situations	2212-1
situations	in	constraint	which	2212-1
which		sequential	there	2212-1
there	are	attribute	repeated variables	2212-1
repeated variables	or	conjunctive	constants	2212-1
constants	in	constraint	the rule head	2212-1
the rule head	see	action	Exercise 13.9	2212-1
adornments	of	constraint	the relevant information	2212-2
adornments	However do not capture	attribute	all	2212-2
the relevant information		sequential	that	2212-2
that	as	constraint	the result	2212-2
that	can arise	action	the result	2212-2
the result	of	constraint	repeated variables	2212-2
repeated variables	or	conjunctive	constants	2212-2
constants		sequential	that	2212-2
that	in	constraint	idb	2212-2
that	occur	action	idb	2212-2
idb	in	constraint	rule bodies	2212-2
idb	predicates	action	rule bodies	2212-2
Mechanisms	for	constraint	Section 13.4	2212-3
Mechanisms	in	constraint	Section 13.4	2212-3
Mechanisms	doing	attribute	this	2212-3
Mechanisms	are discussed	action	Section 13.4	2212-3
Supplementary Relations	and	conjunctive	QSQ	2213-1
<B>	To	constraint	QSQ templates	2214-1
<B>	do	attribute	this	2214-1
QSQ templates	on	constraint	supplementary relations	2214-1
QSQ templates	rely	action	supplementary relations	2214-1
A total	of	constraint	1	2214-2
A total	+	sequential	1	2214-2
1		sequential	n supplementary relations	2214-2
n supplementary relations	to	constraint	a rule body	2214-2
n supplementary relations	are associated	action	a rule body	2214-2
a rule body	with	constraint	atoms	2214-2
a rule body	n	conjunctive	atoms	2214-2
<B>	For	constraint	example	2214-3
example		sequential	the supplementary relations sup	2214-3
the supplementary relations sup		sequential	0	2214-3
<B>	.	sequential	<B>	2214-4
<B>	.	sequential	<B>	2214-5
sup 3	for	constraint	the rule	2214-6
the rule	with	constraint	head	2214-6
head	by	constraint	R bfb	2214-6
head	adorned	action	R bfb	2214-6
R bfb	are	attribute	bff bffb bbfb	2214-6
bff bffb bbfb		sequential	R bfb	2214-6
R bfb		sequential	x	2214-6
x		sequential	y	2214-6
y		sequential	z	2214-6
z	←	sequential	R sup	2214-6
R sup		sequential	0	2214-6
0	x	sequential	z	2214-6
z	sup	sequential	1	2214-6
1		sequential	x	2214-6
x		sequential	z	2214-6
z		sequential	u	2214-6
u		sequential	v	2214-6
v	sup	sequential	2	2214-6
2	x	sequential	z	2214-6
z		sequential	v	2214-6
v		sequential	w	2214-6
w	sup	sequential	3	2214-6
3	x	sequential	y	2214-6
y		sequential	z	2214-6
<B>	Speaking intuitively	action	the body	2214-7
the body	of	constraint	a rule	2214-7
a rule	as	constraint	a process	2214-7
a rule	may be viewed	action	a process	2214-7
a process		sequential	that	2214-7
that	as	constraint	input tuples	2214-7
that	takes	action	input tuples	2214-7
input tuples	over	constraint	the bound attributes	2214-7
the bound attributes	of	constraint	the head	2214-7
the head	as	constraint	output tuples	2214-7
the head	and	conjunctive	output tuples	2214-7
the head	produces	action	output tuples	2214-7
output tuples	over	constraint	the variables	2214-7
the variables	of	constraint	the head	2214-7
the variables	and	conjunctive	the head	2214-7
the variables	bound	attribute	free	2214-7
<B>	determines	action	the attributes	2214-8
the attributes	of	constraint	the supplementary relations	2214-8
the attributes	and	conjunctive	the supplementary relations	2214-8
<B>	In	constraint	addition	2215-1
addition		sequential	an attribute name	2215-1
an attribute name	in	constraint	some supplementary relation	2215-1
an attribute name	is	attribute	some supplementary relation	2215-1
some supplementary relation	if	constraint	it	2215-1
it	by	constraint	it	2215-1
it	if	constraint	it	2215-1
it	and	conjunctive	it	2215-1
it	is has been bound	attribute	some previous literal	2215-1
it	in	constraint	the future	2215-1
it	is needed	action	the future	2215-1
the future	by	constraint	the result	2215-1
the future	in	constraint	the result	2215-1
the future	or	conjunctive	the result	2215-1
<B>	for	constraint	a rule body	2216-1
a rule body	with	constraint	atoms A1	2216-1
<B>	.	sequential	<B>	2216-2
<B>	.	sequential	<B>	2216-3
<B>		sequential	the set	2216-4
the set	of	constraint	variables	2216-4
variables	as	constraint	attribute names	2216-4
variables	used	action	attribute names	2216-4
attribute names	for	constraint	the ith supplementary relation	2216-4
the ith supplementary relation	as	constraint	<B>	2216-4
the ith supplementary relation	is determined	action	<B>	2216-4
the ith supplementary relation	follows	action	<B>	2216-4
The QSQ template	for	constraint	an adorned rule	2217-1
an adorned rule	is	attribute	the sequence	2217-1
the sequence		sequential	sup	2217-1
sup		sequential	0	2217-1
<B>	.	sequential	<B>	2217-2
<B>	.	sequential	<B>	2217-3
sup		sequential	n	2217-4
n	of	constraint	relation schemas	2217-4
relation schemas	for	constraint	the supplementary relations	2217-4
the supplementary relations	of	constraint	the rule	2217-4
<B>	During	constraint	the process	2217-5
the process	of	constraint	QSQ query evaluation	2217-5
QSQ query evaluation		sequential	relation instances	2217-5
relation instances	to	constraint	these schemas	2217-5
relation instances	are assigned	action	these schemas	2217-5
these schemas		sequential	these instances	2217-5
these instances	typically repeatedly acquire	action	new tuples	2217-5
new tuples	as	constraint	the algorithm	2217-5
the algorithm	runs	action	<B>	2217-5
Figure		sequential	13.2	2217-6
13.2	shows	action	the use	2217-6
the use	of	constraint	QSQ templates	2217-6
QSQ templates	in	constraint	connection	2217-6
connection	with	constraint	the RSG query	2217-6
Evaluation	of	constraint	Datalog rsgbf	2218-1
Datalog rsgbf		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	rsgbf	2218-1
rsgbf		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	flat up	2218-1
flat up		sequential	x	2218-1
x		sequential	x	2218-1
x		sequential	rsgfb	2218-1
rsgfb		sequential	y	2218-1
y		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	y	2218-1
y		sequential	1 sup	2218-1
1 sup		sequential	1	2218-1
1	x	sequential	sup	2218-1
sup		sequential	1	2218-1
1	x	sequential	y	2218-1
y	sup	sequential	3	2218-1
3	x	sequential	sup	2218-1
sup		sequential	3	2218-1
3		sequential	x	2218-1
x	x	sequential	sup	2218-1
sup		sequential	3	2218-1
3	x	sequential	y	2218-1
y	sup	sequential	3 fb	2218-1
3 fb		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	rsg	2218-1
rsg		sequential	x fb	2218-1
x fb		sequential	y	2218-1
y		sequential	rsg	2218-1
rsg		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	x	2218-1
x		sequential	y	2218-1
y		sequential	y	2218-1
y		sequential	y	2218-1
y		sequential	rsgbf	2218-1
rsgbf		sequential	y	2218-1
y		sequential	x	2218-1
x		sequential	x	2218-1
x	x	sequential	1 sup	2218-1
1 sup		sequential	2	2218-1
2		sequential	y	2218-1
y		sequential	sup	2218-1
sup		sequential	2	2218-1
2	x	sequential	y	2218-1
y		sequential	sup	2218-1
sup		sequential	4	2218-1
4		sequential	y	2218-1
y		sequential	sup	2218-1
sup		sequential	4	2218-1
4		sequential	y	2218-1
y		sequential	y	2218-1
y		sequential	sup	2218-1
sup		sequential	4	2218-1
4		sequential	y	2218-1
y	x	sequential	sup	2218-1
sup		sequential	4	2218-1
4		sequential	x e g f e f l f f f m input_rsgbf	2218-1
x e g f e f l f f f m input_rsgbf		sequential	y	2218-1
y		sequential	input_rsg fb e g	2218-1
input_rsg fb e g		sequential	f	2218-1
f		sequential	f	2218-1
f		sequential	Figure	2218-1
Figure		sequential	13.2	2218-1
13.2		sequential	Illustration	2218-1
Illustration	of	constraint	QSQ framework	2218-1
QSQ framework		sequential	The Kernel	2218-1
The Kernel	of	constraint	QSQ Evaluation	2218-1
<B>	Let	action	P q	2218-2
P q	be	attribute	a datalog query	2218-2
a datalog query	and	conjunctive	I	2218-2
a datalog query	let	action	I	2218-2
I	be	attribute	an edb instance	2218-2
<B>	Speaking conceptually	action	QSQ evaluation	2218-3
QSQ evaluation	by	constraint	an adorned rule	2218-3
QSQ evaluation	begins	action	an adorned rule	2218-3
QSQ evaluation	constructing	action	an adorned rule	2218-3
an adorned rule	for	constraint	each adornment	2218-3
each adornment	of	constraint	each idb predicate	2218-3
each idb predicate	in	constraint	P	2218-3
P	for	constraint	the query q	2218-3
P	and	conjunctive	the query q	2218-3
<B>	In	constraint	practice	2218-4
practice		sequential	the construction	2218-4
the construction	of	constraint	these adorned rules	2218-4
these adorned rules	be	attribute	can lazy	2218-4
they	if	constraint	execution	2218-4
they	during	constraint	execution	2218-4
they	can be constructed	action	execution	2218-4
they	only needed	action	execution	2218-4
execution	of	constraint	the algorithm	2218-4
<B>	Let	action	P ad	2218-5
P ad		sequential	qad	2218-5
qad	denote	action	the result	2218-5
the result	of	constraint	this transformation	2218-5
The relevant adorned rules	for	constraint	the RSG query	2219-1
the RSG query	as	constraint	<B>	2219-1
the RSG query	are	attribute	<B>	2219-1
the RSG query	follows	action	<B>	2219-1
<B>	that	constraint	the fourth rule	2220-1
<B>	in	constraint	the fourth rule	2220-1
<B>	Note	action	the fourth rule	2220-1
the fourth rule		sequential	the literals	2220-1
the literals	of	constraint	the body	2220-1
the body	so that	constraint	the binding	2220-1
the body	are ordered	action	the binding	2220-1
the binding	of	constraint	y	2220-1
y	in	constraint	y1	2220-1
y	via	constraint	y1	2220-1
y	can be passed	action	y1	2220-1
y1	to	constraint	rsg	2220-1
rsg	via	constraint	x1	2220-1
rsg	and	conjunctive	x1	2220-1
x1	to	constraint	<B>	2220-1
following relations	as	constraint	variables	2221-1
following relations	and	conjunctive	variables	2221-1
following relations	are needed	action	variables	2221-1
following relations	will serve	action	variables	2221-1
variables	in	constraint	the QSQ evaluation algorithm	2221-1
the QSQ evaluation algorithm	for	constraint	R	2221-1
R	and	conjunctive	relevant adornment	2221-1
relevant adornment		sequential	a each idb predicate γ the variable ans _Rγ	2221-1
a each idb predicate γ the variable ans _Rγ	with	constraint	same arity	2221-1
same arity	as	constraint	R	2221-1
j j		sequential	Intuitively input	2222-1
Intuitively input		sequential	Rγ	2222-1
Rγ	to	constraint	subqueries	2222-1
Rγ	will be used	action	subqueries	2222-1
Rγ	form	action	subqueries	2222-1
subqueries		sequential	Rγ	2222-1
Rγ		sequential	input	2222-1
input		sequential	_Rγ	2222-1
The completion	of	constraint	tuples	2222-2
tuples	in	constraint	input	2222-2
input		sequential	Rγ	2222-2
Rγ	to	constraint	ans _Rγ	2222-2
Rγ	will go	action	ans _Rγ	2222-2
<B>	ans	conjunctive	_Rγ	2222-3
_Rγ	Thus will hold	action	tuples	2222-3
tuples		sequential	that	2222-3
that	in	constraint	P	2222-3
that	are	attribute	P	2222-3
P		sequential	I	2222-3
I		sequential	R	2222-3
R	from	constraint	subqueries	2222-3
R	and	conjunctive	subqueries	2222-3
R	were generated	action	subqueries	2222-3
subqueries	on	constraint	Rγ	2222-3
subqueries	based	action	Rγ	2222-3
The query	to	constraint	the process	2223-1
The query	is used	action	the process	2223-1
The query	initialize	action	the process	2223-1
<B>	For	constraint	example	2223-2
example		sequential	the rule query	2223-2
the rule query		sequential	y	2223-2
y		sequential	rsg	2223-2
rsg		sequential	a y	2223-2
a y	gives	action	the initial value	2223-2
the initial value	of	constraint	a }	2223-2
a }	to	constraint	input	2223-2
input		sequential	rsg bf	2223-2
<B>	In	constraint	rise	2223-3
<B>	gives	action	rise	2223-3
rise	to	constraint	the subquery	2223-3
the subquery		sequential	Rγ	2223-3
Rγ		sequential	t }	2223-3
t }		sequential	t	2223-3
t	where is constructed	action	the set	2223-3
t	using	action	the set	2223-3
the set	of	constraint	constants	2223-3
constants	in	constraint	the initial query	2223-3
There	are essentially	action	four kinds	2224-1
four kinds	of	constraint	steps	2224-1
steps	in	constraint	the execution	2224-1
Different possible orderings	for	constraint	these steps	2224-2
these steps	will be considered	action	<B>	2224-2
<B>	of	constraint	rules	2224-3
<B>	to	constraint	rules	2224-3
<B>	is used	action	rules	2224-3
<B>	initialize	action	rules	2224-3
New tuples	in	constraint	supplementary relations	2225-1
New tuples	are generated	action	supplementary relations	2225-1
supplementary relations	sup	action	i	2225-1
i	in	constraint	two ways	2225-1
j		sequential	−1	2226-1
−1		sequential	j j − 1	2226-1
j j − 1	yet	conjunctive	sup	2226-1
j j − 1	and	conjunctive	sup	2226-1
j j − 1	been processed	action	sup	2226-1
sup		sequential	i	2226-1
i	is	attribute	not the last supplementary relation	2226-1
not the last supplementary relation	of	constraint	j 1	2226-1
j 1		sequential	the corresponding rule	2226-1
<B>	that	constraint	Aj	2226-2
<B>	Suppose	action	Aj	2226-2
Aj	is	attribute	the atom	2226-2
the atom	in	constraint	the rule	2226-2
the rule	immediately following	action	sup i	2226-2
j −1 Evaluation	of	constraint	Datalog	2227-1
j		sequential	j	2228-1
j −1		sequential	j −1	2229-1
j		sequential	j	2230-1
<B>	in	constraint	some rule	2231-1
<B>	occurs	action	some rule	2231-1
some rule	with	constraint	supplementary variables	2231-1
some rule	surrounding	action	supplementary variables	2231-1
supplementary variables	sup	action	i	2231-1
i	and	conjunctive	i	2231-1
i	sup	action	i	2231-1
<B>	In	constraint	1 j	2231-2
<B>	−	sequential	1 j	2231-2
1 j		sequential	this j case	2231-2
this j case	and	conjunctive	projection	2231-2
this j case	use	action	projection	2231-2
this j case	join	action	projection	2231-2
projection	on	constraint	all tuples	2231-2
all tuples	in	constraint	sup	2231-2
sup		sequential	i	2231-2
i		sequential	j 1	2231-2
j 1	−	sequential	new tuples	2231-2
j 1	create	action	new tuples	2231-2
new tuples	to	constraint	i	2231-2
new tuples	to	constraint	i	2231-2
new tuples	be added	action	i	2231-2
new tuples	sup	action	i	2231-2
j tuples	in	constraint	the final supplementary variable sup i	2232-1
the final supplementary variable sup i	of	constraint	a rule	2232-1
<B>	that	constraint	the rule predicate	2232-2
<B>	Suppose	action	the rule predicate	2232-2
the rule predicate	n	conjunctive	Rγ	2232-2
the rule predicate	is	attribute	Rγ	2232-2
<B>	Add	action	the new tuples	2232-3
the new tuples	in	constraint	sup	2232-3
sup		sequential	i	2232-3
i	to	constraint	<B>	2232-3
i	n	conjunctive	<B>	2232-3
Example		sequential	13.2.1 Figure 13.2	2233-1
13.2.1 Figure 13.2	illustrates	action	the data structures	2233-1
the data structures	and	conjunctive	scratch paper	2233-1
scratch paper		sequential	relations	2233-1
relations	in	constraint	the QSQ algorithm	2233-1
relations	used	action	the QSQ algorithm	2233-1
the QSQ algorithm	in	constraint	connection	2233-1
connection	with	constraint	the RSG query	2233-1
the RSG query	as	constraint	the instance	2233-1
the RSG query	to	constraint	the instance	2233-1
the RSG query	applied	action	the instance	2233-1
the instance	of	constraint	Fig	2233-1
13.1		sequential	13.1	2233-2
<B>	Recall	action	the adorned version	2233-3
the adorned version	of	constraint	the RSG query	2233-3
the RSG query	on	constraint	page 321	2233-3
the RSG query	presented	action	page 321	2233-3
The QSQ templates	for	constraint	Fig	2233-4
The QSQ templates	in	constraint	Fig	2233-4
The QSQ templates	are shown	action	Fig	2233-4
13.2		sequential	13.2	2233-5
<B>		sequential	the scratch paper relations	2233-6
the scratch paper relations	for	constraint	the input	2233-6
Figure 13.2	shows	action	the contents	2234-1
the contents	of	constraint	the relation variables	2234-1
the relation variables	after	constraint	several steps	2234-1
several steps	of	constraint	the QSQ approach	2234-1
the QSQ approach	have been applied	action	<B>	2234-1
The procedure	with	constraint	the insertion	2234-2
The procedure	begins	action	the insertion	2234-2
the insertion	of	constraint	a input	2234-2
the insertion	into	constraint	a input	2234-2
a input		sequential	rsg bf	2234-2
rsg bf	to	constraint	the rule query	2234-2
rsg bf	corresponds	action	the rule query	2234-2
the rule query		sequential	y	2234-2
y		sequential	rsg	2234-2
rsg		sequential	y	2234-2
y		sequential	a step	2234-2
a step		sequential	B.ii.a	2234-2
B.ii.a	does not yield	action	any tuples	2234-2
any tuples	for	constraint	sup 3	2234-2
step		sequential	B.ii.b	2234-3
B.ii.b	to	constraint	e 2	2234-3
B.ii.b	However is used	action	e 2	2234-3
B.ii.b	insert	action	e 2	2234-3
Global Control Strategies		sequential	Global Control Strategies	2235-1
A variety	of	constraint	global control strategies	2235-2
global control strategies	for	constraint	the QSQ approach	2235-2
global control strategies	can be used	action	the QSQ approach	2235-2
The most basic strategy	is stated simply	action	steps	2235-3
The most basic strategy	Apply A	action	steps	2235-3
steps	through	constraint	D	2235-3
D	until	constraint	a fixpoint	2235-3
a fixpoint	is reached	action	<B>	2235-3
<B>	following	action	Exercise 13.12	2235-4
<B>	can be shown	action	Exercise 13.12	2235-4
<B>	see	action	Exercise 13.12	2235-4
Exercise 13.12		sequential	Theorem 13.2.2	2235-4
Theorem 13.2.2	Let	action	P	2235-4
P		sequential	q	2235-4
q	be	attribute	a datalog query	2235-4
<B>	For	constraint	each input	2235-5
each input		sequential	I	2235-5
I		sequential	any evaluation	2235-5
any evaluation	of	constraint	QSQ	2235-5
QSQ	on	constraint	P ad	2235-5
P ad		sequential	qad	2235-5
qad	yields	action	the answer	2235-5
the answer	of	constraint	P	2235-5
P		sequential	q	2235-5
q	on	constraint	I	2235-5
We	now present	action	a more specific algorithm	2236-1
a more specific algorithm	on	constraint	the QSQ framework	2236-1
a more specific algorithm	based	action	the QSQ framework	2236-1
This algorithm	called	action	QSQ Recursive	2236-2
QSQ Recursive		sequential	QSQR	2236-2
QSQR	on	constraint	a recursive strategy	2236-2
QSQR	is based	action	a recursive strategy	2236-2
<B>	To	constraint	the central intuition	2236-3
<B>	understand	action	the central intuition	2236-3
the central intuition	behind	constraint	QSQR	2236-3
QSQR	that	constraint	step	2236-3
QSQR	suppose	action	step	2236-3
step		sequential	B	2236-3
B	to	constraint	supplementary relation sup	2236-3
B	from	constraint	supplementary relation sup	2236-3
B	described earlier	action	supplementary relation sup	2236-3
B	is be performed	action	supplementary relation sup	2236-3
B	passing	action	supplementary relation sup	2236-3
supplementary relation sup		sequential	i	2236-3
i		sequential	j 1 relation	2236-3
j 1 relation	sup	action	i	2236-3
<B>	to	constraint	the introduction	2236-4
<B>	may lead	action	the introduction	2236-4
the introduction	of	constraint	new tuples	2236-4
new tuples	into	constraint	sup	2236-4
sup		sequential	i	2236-4
i	by	constraint	step	2236-4
step		sequential	B.ii.a	2236-4
B.ii.a	and	conjunctive	j j	2236-4
j j	to	constraint	the introduction	2236-4
the introduction	of	constraint	new tuples	2236-4
new tuples	into	constraint	input	2236-4
input		sequential	Rγ	2236-4
Rγ	by	constraint	step	2236-4
step		sequential	B.ii.b	2236-4
The essence	of	constraint	QSQR	2236-5
QSQR	that	constraint	it	2236-5
QSQR	is	attribute	it	2236-5
it	now performs	action	a recursive call	2236-5
a recursive call	to	constraint	the Rγ values	2236-5
a recursive call	determine	action	the Rγ values	2236-5
the Rγ values	to	constraint	the new tuples	2236-5
the Rγ values	corresponding	action	the new tuples	2236-5
the new tuples	to	constraint	input _Rγ	2236-5
the new tuples	added	action	input _Rγ	2236-5
input _Rγ	before	constraint	step	2236-5
input _Rγ	applying	action	step	2236-5
step		sequential	B	2236-5
B	or	conjunctive	D	2236-5
D	to	constraint	the new tuples	2236-5
the new tuples	into	constraint	sup i	2236-5
the new tuples	placed	action	sup i	2236-5
j		sequential	We	2237-1
We	present	action	QSQR	2237-1
QSQR	in	constraint	two steps	2237-1
two steps		sequential	first a subroutine	2237-1
first a subroutine	and	conjunctive	the recursive algorithm itself	2237-1
<B>	During	constraint	processing	2237-2
processing	in	constraint	QSQR	2237-2
QSQR		sequential	the global state	2237-2
the global state	includes	action	values	2237-2
values	for	constraint	ans _R γ	2237-2
ans _R γ	and	conjunctive	input	2237-2
input		sequential	_Rγ	2237-2
_Rγ	for	constraint	each idb	2237-2
each idb	predicate	action	R	2237-2
R	and	conjunctive	relevant adornment	2237-2
relevant adornment		sequential	γ	2237-2
the supplementary relations	are	attribute	However not global	2237-3
local copies	of	constraint	the supplementary relations	2237-3
the supplementary relations	by	constraint	each call	2237-3
the supplementary relations	are maintained	action	each call	2237-3
each call	of	constraint	the subroutine	2237-3
Subroutine Process subquery Input	on	constraint	one rule	2238-1
the tuples	in	constraint	T	2238-2
T	with	constraint	this rule	2238-2
T	Intuitively have not been considered yet	action	this rule	2238-2
<B>	For	constraint	each atom Aj	2239-1
Evaluation	of	constraint	Datalog	2240-1
Datalog	for	constraint	the tuples	2240-1
the tuples	in	constraint	S.	2240-1
S.	to	constraint	sup j	2240-1
S.	populate	action	sup j	2240-1
<B>	includes	action	steps	2240-2
steps		sequential	B.ii.a	2240-2
B.ii.a	and	conjunctive	C	2240-2
The main algorithm	by	constraint	following Input	2240-3
The main algorithm	is given	attribute	the	2240-3
following Input		sequential	A query	2240-3
A query	of	constraint	the form	2240-3
the form		sequential	Rγ	2240-3
Rγ		sequential	T	2240-3
T		sequential	input instance I	2240-3
input instance I	and	conjunctive	a QSQR	2240-3
a QSQR		sequential	state	2240-3
state		sequential	set	2240-3
set	of	constraint	values	2240-3
values	for	constraint	the input	2240-3
the input	and	conjunctive	ans-variables	2240-3
Procedure	Call	action	the subroutine	2241-1
the subroutine	to	constraint	subquery	2241-1
the subroutine	process	action	subquery	2241-1
subquery		sequential	Rγ	2241-1
Rγ		sequential	T	2241-1
T	on	constraint	each rule	2241-1
each rule	defining	action	R	2241-1
<B>	that	constraint	we	2242-1
<B>	Suppose	action	we	2242-1
we	are given	action	the query query	2242-1
the query query		sequential	u	2242-1
u		sequential	R	2242-1
R		sequential	v	2242-1
It	to	constraint	QSQR	2243-1
It	that	constraint	QSQR	2243-1
It	is	attribute	straightforward	2243-1
It	show	action	QSQR	2243-1
QSQR	is	attribute	correct	2243-1
Exercise		sequential	13.12	2243-1
Magic		sequential	rsg bf rsg f	2244-1
rsg bf rsg f		sequential	x	2244-1
x		sequential	y	2244-1
y		sequential	b	2244-1
b		sequential	x	2244-1
x		sequential	y	2244-1
y		sequential	sup 31	2244-1
sup 31	x	sequential	x1	2244-1
x1		sequential	sup	2244-1
sup		sequential	32	2244-1
32	x	sequential	y1	2244-1
y1		sequential	rsg bf	2244-1
rsg bf	x	sequential	y	2244-1
y		sequential	sup	2244-1
sup		sequential	41	2244-1
41		sequential	y	2244-1
y		sequential	y1	2244-1
y1		sequential	sup	2244-1
sup		sequential	42 y	2244-1
42 y		sequential	x1	2244-1
x1		sequential	rsg f b	2244-1
rsg f b	x	sequential	y	2244-1
y		sequential	input	2244-1
input	_	sequential	rsg bf	2244-1
rsg bf		sequential	x1	2244-1
x1		sequential	sup	2244-1
sup		sequential	31	2244-1
31	x	sequential	x1	2244-1
x1		sequential	input	2244-1
input	_	sequential	rsg f	2244-1
rsg f		sequential	b	2244-1
b		sequential	y1	2244-1
y1		sequential	sup	2244-1
sup		sequential	41	2244-1
41		sequential	y	2244-1
y		sequential	y1	2244-1
y1		sequential	input rsg bf	2244-1
input rsg bf	_	sequential	query	2244-1
query		sequential	Figure	2244-1
Figure		sequential	13.3	2244-1
13.3		sequential	Transformation	2244-1
Transformation	of	constraint	RSG query	2244-1
RSG query	using	action	magic sets	2244-1
magic sets		sequential	QSQ	2244-1
<B>	In	constraint	P m	2244-2
P m		sequential	qm	2244-2
qm	incorporates	action	the effect	2244-2
the effect	of	constraint	selections	2244-2
the effect	pushing	action	selections	2244-2
selections	from	constraint	the query	2244-2
the query	into	constraint	bottom	2244-2
bottom	up	constraint	computations	2244-2
computations	as if	constraint	magic	2244-2
computations	by	constraint	magic	2244-2
We	on	constraint	a technique	2245-1
We	focus	action	a technique	2245-1
a technique	originally called	action	generalized supplementary magic	2245-1
generalized supplementary magic		sequential	it	2245-1
it	is	attribute	perhaps the most general magic set technique	2245-1
perhaps the most general magic set technique	for	constraint	datalog	2245-1
datalog	in	constraint	the literature	2245-1
An earlier form	of	constraint	magic	2245-2
magic	in	constraint	Exercise 13.18	2245-2
magic	is considered	action	Exercise 13.18	2245-2
The discussion	by	constraint	the technique	2245-3
The discussion	begins	action	the technique	2245-3
The discussion	explaining	action	the technique	2245-3
the technique	in	constraint	connection	2245-3
the technique	how works	action	connection	2245-3
connection	with	constraint	the RSG query	2245-3
the RSG query	of	constraint	the previous section	2245-3
the previous section	and	conjunctive	the general algorithm	2245-3
the previous section	presents	action	the general algorithm	2245-3
We	first present	action	a primitive family	2246-1
a primitive family	of	constraint	rules	2246-1
rules	to	constraint	that rule	2246-1
rules	corrresponding	action	that rule	2246-1
that rule	and	conjunctive	some optimizations	2246-1
that rule	apply	action	some optimizations	2246-1
Evaluation	of	constraint	Datalog sup 30	2247-1
Datalog sup 30		sequential	x	2247-1
x		sequential	sup	2247-1
sup		sequential	31	2247-1
31	x	sequential	x1	2247-1
x1	←	sequential	sup	2247-1
sup		sequential	30	2247-1
30		sequential	x	2247-1
x		sequential	up	2247-1
up		sequential	x x1	2247-1
x x1		sequential	sup	2247-1
sup		sequential	32	2247-1
32		sequential	x	2247-1
x		sequential	y1	2247-1
y1		sequential	sup 31	2247-1
sup 31		sequential	x	2247-1
x		sequential	x1	2247-1
x1		sequential	rsg f b	2247-1
rsg f b		sequential	y1	2247-1
y1		sequential	x1	2247-1
x1		sequential	s3.3 ’	2247-1
s3.3 ’		sequential	sup	2247-1
sup		sequential	33	2247-1
33		sequential	x	2247-1
x		sequential	y	2247-1
y		sequential	sup 32	2247-1
sup 32		sequential	x	2247-1
x		sequential	y1	2247-1
y1		sequential	y1	2247-1
y1		sequential	y	2247-1
y		sequential	rsg bf	2247-1
rsg bf		sequential	x	2247-1
x		sequential	y	2247-1
y		sequential	sup 33	2247-1
sup 33		sequential	x y	2247-1
x y		sequential	Rule	2247-1
Rule		sequential	s3.0	2247-1
s3.0	to	constraint	step	2247-1
s3.0	corresponds	action	step	2247-1
step	of	constraint	the QSQ algorithm	2247-1
the QSQ algorithm		sequential	rules	2247-1
rules		sequential	s3.1	2247-1
s3.1	and	conjunctive	s3.3	2247-1
s3.3	to	constraint	step	2247-1
s3.3	correspond	action	step	2247-1
step		sequential	B.i	2247-1
B.i		sequential	rule	2247-1
rule		sequential	s3.2	2247-1
s3.2	to	constraint	steps	2247-1
s3.2	corresponds	action	steps	2247-1
steps		sequential	B.ii.a	2247-1
B.ii.a	and	conjunctive	C	2247-1
C	and	conjunctive	rule	2247-1
rule		sequential	s3.4	2247-1
s3.4	to	constraint	step	2247-1
s3.4	corresponds	action	step	2247-1
step		sequential	D	2247-1
<B>	In	constraint	the literature	2247-2
the literature		sequential	the predicate input rsg f b	2247-2
the predicate input rsg f b	as	constraint	magic	2247-2
the predicate input rsg f b	has usually been denoted	action	magic	2247-2
magic		sequential	rsg f b	2247-2
rsg f b	and	conjunctive	sup	2247-2
sup		sequential	i	2247-2
i	as	constraint	i	2247-2
We	use	action	the current notation	2247-3
the current notation	to	constraint	the j j connection	2247-3
the current notation	stress	action	the j j connection	2247-3
the j j connection	with	constraint	the QSQ framework	2247-3
<B>	that	constraint	the predicate rsg bf here	2247-4
<B>	Note	action	the predicate rsg bf here	2247-4
the predicate rsg bf here	plays	action	the role	2247-4
the role	of	constraint	ans	2247-4
ans		sequential	rsg bf	2247-4
<B>		sequential	<B>	2248-1
<B>	In	constraint	the ith rule	2248-2
<B>	if	constraint	the ith rule	2248-2
the ith rule	defines	action	Rγ	2248-2
Rγ		sequential	the predicate sup	2248-2
the predicate sup		sequential	i	2248-2
i	with	constraint	0 input _Rγ	2248-2
i	is eliminated	action	0 input _Rγ	2248-2
0 input _Rγ	in	constraint	its place	2248-2
0 input _Rγ	used	action	its place	2248-2
its place	to	constraint	rule	2248-2
its place	eliminate	action	rule	2248-2
rule		sequential	3.0	2248-2
3.0	to	constraint	form	2248-2
3.0	and	conjunctive	form	2248-2
form		sequential	s3.1	2248-2
s3.1		sequential	sup	2248-2
sup		sequential	31	2248-2
31	x	sequential	x1	2248-2
x1		sequential	input	2248-2
input	_	sequential	rsg bf	2248-2
rsg bf		sequential	x	2248-2
x		sequential	x	2248-2
x		sequential	x1	2248-2
the predicate	of	constraint	the last supplementary relation	2249-1
the last supplementary relation	to	constraint	rule	2249-1
the last supplementary relation	Similarly can be eliminated	action	rule	2249-1
the last supplementary relation	delete	action	rule	2249-1
rule		sequential	s 3.4	2249-1
s 3.4	to	constraint	rsg bf	2249-1
s 3.4	and	conjunctive	rsg bf	2249-1
s 3.4	form	action	rsg bf	2249-1
rsg bf		sequential	x	2249-1
x		sequential	y	2249-1
y		sequential	sup	2249-1
sup		sequential	32	2249-1
32		sequential	x	2249-1
x		sequential	y1	2249-1
y1		sequential	y1	2249-1
y1		sequential	y	2249-1
the set	of	constraint	rules	2250-1
rules		sequential	s3.0	2250-1
s3.0	through	constraint	s 3.4	2250-1
s 3.4	by	constraint	s3.1	2250-1
s 3.4	Therefore may be replaced	action	s3.1	2250-1
s3.1		sequential	s3.2	2250-1
s3.2	and	conjunctive	s3.3	2250-1
Rules		sequential	s4.1	2250-2
s4.1		sequential	s4.2	2250-2
s4.2	and	conjunctive	s4.3	2250-2
s4.3	of	constraint	Fig	2250-2
13.3	from	constraint	rule	2250-3
13.3	are generated	action	rule	2250-3
rule		sequential	4	2250-3
4	of	constraint	the adorned program	2250-3
the adorned program	for	constraint	the RSG query	2250-3
the RSG query	see	action	p. 321	2250-3
<B>	Recall	action	the order	2250-4
the order	of	constraint	the body literals	2250-4
the body literals	in	constraint	that rule	2250-4
that rule	to	constraint	bounding information	2250-4
that rule	how are reversed	action	bounding information	2250-4
that rule	pass	action	bounding information	2250-4
<B>		sequential	rules	2250-5
rules		sequential	s1.1	2250-5
s1.1	and	conjunctive	s2.1 stem	2250-5
s2.1 stem	from	constraint	rules	2250-5
rules		sequential	1	2250-5
1	of	constraint	the adorned program	2250-5
1	and	conjunctive	the adorned program	2250-5
The second class	of	constraint	rules	2251-1
rules	to	constraint	values	2251-1
rules	is used	action	values	2251-1
rules	provide	action	values	2251-1
values	for	constraint	the input	2251-1
the input	predicates	action	step	2251-1
the input	simulating	action	step	2251-1
step		sequential	B.ii.b	2251-1
B.ii.b	of	constraint	the QSQ algorithm	2251-1
<B>	In	constraint	the RSG query	2251-2
the RSG query		sequential	one rule	2251-2
one rule	for	constraint	input	2251-2
one rule	of	constraint	input	2251-2
input		sequential	rsg bf	2251-2
rsg bf	and	conjunctive	input	2251-2
input	_	sequential	rsg f b	2251-2
rsg f b	is needed	action	i3.2 input	2251-2
i3.2 input	_	sequential	rsg bf	2251-2
rsg bf		sequential	x1	2251-2
x1		sequential	sup	2251-2
sup		sequential	31	2251-2
31		sequential	x	2251-2
x		sequential	x1	2251-2
x1		sequential	input	2251-2
input	_	sequential	rsg f	2251-2
rsg f		sequential	b	2251-2
b		sequential	y1	2251-2
y1	sup	sequential	41	2251-2
41		sequential	y	2251-2
y		sequential	y1	2251-2
the first rule	from	constraint	rule	2252-1
the first rule	Intuitively comes	action	rule	2252-1
rule		sequential	s3.2	2252-1
<B>	In	constraint	other words	2252-2
other words		sequential	it	2252-2
it	from	constraint	the second atom	2252-2
it	follows	action	the second atom	2252-2
the second atom	of	constraint	the body	2252-2
the body	of	constraint	rule	2252-2
rule		sequential	3	2252-2
3	of	constraint	the original adorned program	2252-2
the original adorned program	see	action	p. 321	2252-2
<B>	In	constraint	an adorned rule	2252-3
an adorned rule	with	constraint	k idb atoms	2252-3
k idb atoms	in	constraint	the body	2252-3
the body	will generate	action	k input rules	2252-3
k input rules	of	constraint	this form	2252-3
<B>	and	conjunctive	The classes	2253-1
The classes	of	constraint	rules	2253-1
rules	include	action	one rule each	2253-1
one rule each	and	conjunctive	the simulation	2253-1
one rule each	initialize	action	the simulation	2253-1
one rule each	conclude	action	the simulation	2253-1
the simulation	of	constraint	QSQ	2253-1
QSQ		sequential	<B>	2253-1
<B>	of	constraint	a seed	2253-2
<B>	as	constraint	a seed	2253-2
<B>	acts	action	a seed	2253-2
a seed	from	constraint	the initial query	2253-2
a seed	and	conjunctive	the initial query	2253-2
a seed	is derived	action	the initial query	2253-2
<B>	In	constraint	the running example	2253-3
the running example		sequential	the seed	2253-3
the seed	is	attribute	input _rsgbf a	2253-3
input _rsgbf a	←	sequential	<B>	2253-3
<B>	constructs	action	the answer	2254-1
the answer	to	constraint	the query	2254-1
the query	in	constraint	the example	2254-1
the example		sequential	it	2254-1
it	is	attribute	query	2254-1
query		sequential	y	2254-1
y		sequential	rsg bf	2254-1
rsg bf		sequential	a	2254-1
a		sequential	y	2254-1
<B>	From	constraint	this example	2255-1
this example		sequential	it	2255-1
it	to	constraint	the magic set rewriting	2255-1
it	be	attribute	should straightforward	2255-1
it	specify	action	the magic set rewriting	2255-1
the magic set rewriting	of	constraint	an adorned query	2255-1
an adorned query		sequential	P ad	2255-1
P ad		sequential	qad	2255-1
qad	see	action	Exercise 13.16a	2255-1
The example	and	conjunctive	supplementary	2256-1
The example	showed	attribute	the first	2256-1
supplementary	how predicates	action	sup	2256-1
sup	and	conjunctive	0	2256-1
0		sequential	3 sup 3	2256-1
3 sup 3	with	constraint	input	2256-1
3 sup 3	were	attribute	redundant	2256-1
input	_	sequential	rsg bf	2256-1
rsg bf	and	conjunctive	rsg bf	2256-1
rsg bf	and	conjunctive	<B>	2256-1
rsg bf	could be eliminated	action	<B>	2256-1
Rγ		sequential	u	2257-1
u	←	sequential	R	2257-1
R		sequential	1	2257-1
1		sequential	u	2257-1
u		sequential	n	2257-1
n		sequential	un	2257-1
un		sequential	i.k′′	2257-1
<B>	.	sequential	<B>	2257-2
<B>	.	sequential	<B>	2257-3
Rγn n		sequential	un	2257-4
<B>	For	constraint	example	2258-1
example		sequential	rules	2258-1
rules		sequential	s3.2	2258-1
s3.2	and	conjunctive	s3.3	2258-1
s3.3	of	constraint	Fig	2258-1
13.3	by	constraint	s3.2′ ′	2258-2
13.3	can be replaced	action	s3.2′ ′	2258-2
s3.2′ ′		sequential	rsg bf	2258-2
rsg bf		sequential	x	2258-2
x		sequential	y	2258-2
y		sequential	sup	2258-2
sup		sequential	31	2258-2
31		sequential	x	2258-2
x		sequential	x1	2258-2
x1		sequential	rsg f b	2258-2
rsg f b		sequential	y1	2258-2
y1		sequential	x1	2258-2
x1		sequential	y1	2258-2
y1		sequential	y	2258-2
This simplification	within	constraint	rules	2259-1
This simplification	can also be used	action	rules	2259-1
<B>	that	constraint	Rk	2259-2
<B>	Suppose	action	Rk	2259-2
Rk	and	conjunctive	Rl	2259-2
Rl	are	attribute	idb relations	2259-2
idb relations	with	constraint	only edb relations	2259-2
only edb relations	in	constraint	<B>	2259-2
only edb relations	between	constraint	<B>	2259-2
only edb relations	occurring	action	<B>	2259-2
Then rules		sequential	i.k	2259-3
<B>	.	sequential	<B>	2259-4
<B>	.	sequential	<B>	2259-5
i.l	with	constraint	i.k′′	2259-6
i.l	1 can be replaced	action	i.k′′	2259-6
i.k′′		sequential	sup	2259-6
sup		sequential	i	2259-6
i		sequential	k	2259-6
k		sequential	u	2259-6
u		sequential	k+1	2259-6
k+1		sequential	u	2259-6
u		sequential	l−1	2259-6
l−1		sequential	u l−1	2259-6
u l−1		sequential	vl−	2259-6
vl−		sequential	1	2259-6
1		sequential	sup ik −1	2259-6
sup ik −1		sequential	vk−1	2259-6
vk−1		sequential	Rk	2259-6
Rk		sequential	k	2259-6
k		sequential	Rk+1	2259-6
Rk+1		sequential	k+1	2259-6
<B>	.	sequential	<B>	2259-7
<B>	.	sequential	<B>	2259-8
Rl −1 l−1		sequential	Rl −1 l−1	2259-9
<B>	To	constraint	the development	2260-1
<B>	summarize	action	the development	2260-1
the development		sequential	we	2260-1
we	state	attribute	the following	2260-1
we	see	action	Exercise 13.16	2260-1
Exercise 13.16		sequential	Theorem 13.3.1	2260-1
Theorem 13.3.1	Let	action	P	2260-1
P		sequential	q	2260-1
q	be	attribute	a query	2260-1
a query	and	conjunctive	P m	2260-1
a query	let	action	P m	2260-1
P m		sequential	qm	2260-1
qm	be	attribute	the query	2260-1
the query	from	constraint	the magic rewriting	2260-1
the query	resulting	action	the magic rewriting	2260-1
the magic rewriting	of	constraint	P	2260-1
P		sequential	q	2260-1
<B>		sequential	<B>	2260-2
Two Improvements		sequential	Two Improvements	2261-1
<B>	on	constraint	another kind	2261-2
<B>	focuses	action	another kind	2261-2
another kind	of	constraint	information passing	2261-2
information passing	from	constraint	repeated variables	2261-2
information passing	resulting	action	repeated variables	2261-2
repeated variables	and	conjunctive	constants	2261-2
constants	in	constraint	idb	2261-2
constants	occurring	action	idb	2261-2
idb	in	constraint	rule bodies	2261-2
idb	predicates	action	rule bodies	2261-2
<B>	called	action	counting	2261-3
counting	to	constraint	sets	2261-3
counting	is	attribute	applicable	2261-3
sets	of	constraint	data	2261-3
data	and	conjunctive	rules	2261-3
rules	having	action	certain acyclicity properties	2261-3
Evaluation	of	constraint	Datalog Repeated Variables	2262-1
Datalog Repeated Variables	and	conjunctive	Constants	2262-1
Constants	in	constraint	Rule Bodies	2262-1
Rule Bodies	by	constraint	Example	2262-1
Example	Consider	action	the program Pr	2262-1
the program Pr		sequential	T	2262-1
T		sequential	x	2262-1
x		sequential	y	2262-1
y		sequential	z	2262-1
z		sequential	R	2262-1
R		sequential	x	2262-1
x		sequential	y	2262-1
y		sequential	z	2262-1
z		sequential	T	2262-1
T		sequential	x	2262-1
x		sequential	y	2262-1
y		sequential	z	2262-1
z		sequential	S	2262-1
S		sequential	x	2262-1
x		sequential	y	2262-1
y		sequential	w	2262-1
w		sequential	T	2262-1
T		sequential	w	2262-1
w		sequential	z	2262-1
z		sequential	z	2262-1
z		sequential	query	2262-1
query		sequential	y	2262-1
y		sequential	z	2262-1
z		sequential	T	2262-1
T		sequential	1	2262-1
1		sequential	y	2262-1
y		sequential	z	2262-1
z	as	constraint	input	2262-1
z	Consider	action	input	2262-1
input		sequential	the instance	2262-1
the instance		sequential	I1	2262-1
I1	in	constraint	Fig	2262-1
I1	shown	action	Fig	2262-1
13.4		sequential	<B>	2262-2
The data structures	for	constraint	a QSQ evaluation	2262-3
a QSQ evaluation	of	constraint	this program	2262-3
this program	in	constraint	Fig	2262-3
this program	are shown	action	Fig	2262-3
13.4		sequential	b	2262-4
The annotations $ 2	=	sequential	<B>	2262-5
The annotations $ 2	$ 3	sequential	<B>	2262-5
The annotations $ 2	$ 2	sequential	<B>	2262-5
The annotations $ 2	=	sequential	<B>	2262-5
The annotations $ 2	$ 3	sequential	<B>	2262-5
T bff		sequential	x	2263-1
x		sequential	y	2263-1
y		sequential	z	2263-1
z		sequential	sup	2263-1
sup		sequential	21	2263-1
21		sequential	x	2263-1
x		sequential	y	2263-1
y		sequential	w	2263-1
w	←	sequential	input	2263-1
input	_T	sequential	bff	2263-1
bff		sequential	x	2263-1
x		sequential	S	2263-1
S		sequential	x	2263-1
x		sequential	y	2263-1
y		sequential	w	2263-1
w		sequential	T	2263-1
T		sequential	bff	2263-1
bff		sequential	x	2263-1
x		sequential	y	2263-1
y		sequential	z	2263-1
z		sequential	input	2263-1
input		sequential	_T bff	2263-1
_T bff		sequential	w	2263-1
w	←	sequential	sup	2263-1
sup		sequential	21	2263-1
21		sequential	x	2263-1
x		sequential	y	2263-1
y		sequential	w	2263-1
w		sequential	input	2263-1
input	_T	sequential	bff	2263-1
bff		sequential	1	2263-1
1		sequential	query	2263-1
query		sequential	y	2263-1
y		sequential	z	2263-1
<B>	On	constraint	input I1	2264-1
input I1		sequential	the query	2264-1
the query	returns	action	the empty instance	2264-1
<B>		sequential	the SLD tree	2264-2
the SLD tree	for	constraint	this query	2264-2
this query	on	constraint	I1	2264-2
I1	in	constraint	Fig	2264-2
I1	shown	action	Fig	2264-2
<B>	13.5 has	action	only 9 goals	2264-3
only 9 goals	and	conjunctive	a total	2264-3
a total	of	constraint	13 atoms	2264-3
13 atoms	of	constraint	the value	2264-3
the value	of	constraint	n	2264-3
QSQ	and	conjunctive	magic	2265-1
magic		sequential	both sets	2265-1
both sets	on	constraint	this program	2265-1
both sets	Why do perform so poorly	action	this program	2265-1
this program	and	conjunctive	query	2265-1
The answer	that	constraint	neither QSQ	2265-2
The answer	as	constraint	neither QSQ	2265-2
The answer	is	attribute	neither QSQ	2265-2
The answer	presented	action	neither QSQ	2265-2
neither QSQ	nor	conjunctive	magic sets	2265-2
magic sets	take	action	advantage	2265-2
advantage	of	constraint	restrictions	2265-2
restrictions	on	constraint	derivations	2265-2
derivations	from	constraint	the repeated z variable	2265-2
derivations	resulting	action	the repeated z variable	2265-2
the repeated z variable	in	constraint	the body	2265-2
the body	of	constraint	rule	2265-2
rule		sequential	2	2265-2
Analogous examples	for	constraint	cases	2265-3
Analogous examples	can be developed	action	cases	2265-3
cases		sequential	constants	2265-3
constants	in	constraint	idb atoms	2265-3
constants	where appear	action	idb atoms	2265-3
idb atoms	in	constraint	rule bodies	2265-3
<B>	Both	conjunctive	QSQ	2266-1
QSQ	and	conjunctive	magic	2266-1
magic		sequential	sets	2266-1
sets	to	constraint	such information	2266-1
sets	can be enhanced	action	such information	2266-1
sets	use	action	such information	2266-1
<B>	In	constraint	the case	2266-2
the case	of	constraint	QSQ	2266-2
QSQ		sequential	the tuples	2266-2
the tuples	to	constraint	supplementary relations	2266-2
the tuples	added	action	supplementary relations	2266-2
supplementary relations	to	constraint	information	2266-2
supplementary relations	can be annotated	action	information	2266-2
supplementary relations	carry	action	information	2266-2
information	about	constraint	restrictions	2266-2
restrictions	by	constraint	the atom	2266-2
restrictions	imposed	action	the atom	2266-2
the atom		sequential	that	2266-2
that	caused	action	the tuple	2266-2
the tuple	to	constraint	the leftmost supplementary relation	2266-2
the tuple	into	constraint	the leftmost supplementary relation	2266-2
the tuple	be placed	action	the leftmost supplementary relation	2266-2
<B>	by	constraint	the annotations	2266-3
<B>	is illustrated	action	the annotations	2266-3
the annotations	in	constraint	Fig	2266-3
13.4		sequential	b	2266-4
<B>	First consider	action	the annotation $ 2	2266-5
the annotation $ 2	on	constraint	the tuple 3	2266-5
the annotation $ 2	=	sequential	the tuple 3	2266-5
the annotation $ 2	$ 3	sequential	the tuple 3	2266-5
the tuple 3	in	constraint	input	2266-5
input		sequential	_T bff	2266-5
This tuple	into	constraint	input	2266-6
This tuple	is included	action	input	2266-6
<B>	In	constraint	any valid tuple	2266-7
any valid tuple		sequential	x	2266-7
x		sequential	y	2266-7
y		sequential	z	2266-7
z	from	constraint	3	2266-7
z	resulting	action	3	2266-7
3	and	conjunctive	coordinates	2266-7
3	1 must have	attribute	second	2266-7
coordinates		sequential	<B>	2266-7
The annotation $ 2	with	constraint	3	2266-8
The annotation $ 2	=	sequential	3	2266-8
The annotation $ 2	$ 3	sequential	3	2266-8
The annotation $ 2	is passed	action	3	2266-8
3	into	constraint	sup 1	2266-8
sup 1	and	conjunctive	sup 2	2266-8
<B>	Because	constraint	variable y	2267-1
variable y	to	constraint	4	2267-1
variable y	is bound	action	4	2267-1
4	in	constraint	the tuple	2267-1
the tuple		sequential	3	2267-1
3		sequential	4	2267-1
4		sequential	5	2267-1
5	in	constraint	sup 2	2267-1
sup 2		sequential	the annotation	2267-1
the annotation	$ 2	sequential	<B>	2267-1
the annotation	=	sequential	<B>	2267-1
<B>	Now consider	action	the tuple 5	2268-1
the tuple 5	in	constraint	sup	2268-1
sup		sequential	1	2268-1
1	with	constraint	annotation	2268-1
annotation	$ 2	sequential	4	2268-1
annotation	=	sequential	4	2268-1
annotation	$ 3	sequential	4	2268-1
annotation	=	sequential	4	2268-1
<B>	can generate	action	a 0 tuple	2268-2
a 0 tuple	in	constraint	sup 1	2268-2
sup 1	if	constraint	only 5	2268-2
only 5		sequential	4	2268-2
4		sequential	4	2268-2
4	in	constraint	R	2268-2
4	is	attribute	R	2268-2
<B>	n	conjunctive	I1	2269-1
I1		sequential	R	2269-1
R		sequential	I1	2269-1
I1		sequential	S	2269-1
S		sequential	Tbff	2269-1
Tbff		sequential	x	2269-1
x		sequential	y	2269-1
y		sequential	z	2269-1
z		sequential	R	2269-1
R		sequential	x	2269-1
x		sequential	y	2269-1
y		sequential	z	2269-1
z		sequential	input_Tbff	2269-1
input_Tbff		sequential	sup	2269-1
sup		sequential	1	2269-1
1		sequential	x	2269-1
x		sequential	sup	2269-1
sup		sequential	1	2269-1
1	x	sequential	y	2269-1
y		sequential	z	2269-1
<B>	n	conjunctive	Tbff S	2270-1
Tbff S		sequential	x	2270-1
x		sequential	y	2270-1
y		sequential	z	2270-1
z		sequential	x	2270-1
x		sequential	y	2270-1
y		sequential	w	2270-1
w		sequential	Tbff	2270-1
Tbff		sequential	w z	2270-1
w z		sequential	z	2270-1
sup		sequential	2	2271-1
2		sequential	x	2271-1
x		sequential	sup	2271-1
sup		sequential	2	2271-1
2		sequential	x	2271-1
x		sequential	y	2271-1
y		sequential	w	2271-1
w	sup	sequential	2	2271-1
2	x	sequential	y	2271-1
y		sequential	z	2271-1
z	n	conjunctive	Figure 13.4	2271-1
Figure 13.4		sequential	Behavior	2271-1
Behavior	of	constraint	QSQ	2271-1
QSQ	on	constraint	program	2271-1
program	with	constraint	repeated variables Evaluation	2271-1
repeated variables Evaluation	of	constraint	Datalog	2271-1
Datalog		sequential	Figure	2271-1
Figure		sequential	13.5	2271-1
13.5		sequential	Behavior	2271-1
Behavior	of	constraint	SLD	2271-1
SLD	on	constraint	program	2271-1
program	with	constraint	repeated variables	2271-1
repeated variables		sequential	tuple 5	2271-1
tuple 5	in	constraint	sup 1	2271-1
sup 1	generates	action	nothing	2271-1
nothing	though	constraint	even the original QSQ framework	2271-1
nothing	in	constraint	even the original QSQ framework	2271-1
even the original QSQ framework		sequential	many 0 tuples	2271-1
many 0 tuples	are generated	action	<B>	2271-1
<B>	because	constraint	there	2271-2
there	is	attribute	no tuple 5	2271-2
no tuple 5		sequential	4	2271-2
4	w	constraint	S	2271-2
4	in	constraint	S	2271-2
S		sequential	the annotated tuple 5	2271-2
the annotated tuple 5	of	constraint	sup 2	2271-2
sup 2	Analogously does not generate	action	anything	2271-2
anything	in	constraint	sup 2	2271-2
<B>	illustrates	action	annotations	2271-3
annotations	to	constraint	the facts	2271-3
annotations	how can 0 be used	action	the facts	2271-3
annotations	restrict	action	the facts	2271-3
the facts	during	constraint	execution	2271-3
the facts	generated	action	execution	2271-3
execution	of	constraint	QSQ	2271-3
annotations	on	constraint	tuples	2272-1
tuples	are	attribute	More generally conjunctions	2272-1
More generally conjunctions	of	constraint	equality terms	2272-1
equality terms	of	constraint	the form	2272-1
The magic set technique	to	constraint	the information	2273-1
The magic set technique	can also be enhanced	action	the information	2273-1
The magic set technique	incorporate	action	the information	2273-1
the information	by	constraint	the annotations	2273-1
the information	captured	action	the annotations	2273-1
the annotations	just described	action	<B>	2273-1
<B>	by	constraint	an initial preprocessing	2273-2
<B>	is accomplished	action	an initial preprocessing	2273-2
an initial preprocessing	of	constraint	the program	2273-2
the program	and	conjunctive	query	2273-2
query	called	action	subgoal rectification	2273-2
Rectified subgoals	from	constraint	nonrectified ones	2274-1
Rectified subgoals	may be formed	action	nonrectified ones	2274-1
nonrectified ones	by	constraint	new idb predicates	2274-1
nonrectified ones	creating	action	new idb predicates	2274-1
new idb predicates		sequential	that	2274-1
that	to	constraint	versions	2274-1
that	correspond	action	versions	2274-1
versions	of	constraint	idb	2274-1
idb	with	constraint	repeated variables	2274-1
idb	predicates	action	repeated variables	2274-1
repeated variables	and	conjunctive	constants	2274-1
<B>	For	constraint	example	2274-2
example	is	attribute	the result	2274-2
the result	of	constraint	the subgoals	2274-2
the result	rectifying	action	the subgoals	2274-2
the subgoals	of	constraint	the program Pr	2274-2
the program Pr		sequential	T	2274-2
T		sequential	x	2274-2
x		sequential	y	2274-2
y		sequential	z	2274-2
z		sequential	T	2274-2
T		sequential	x	2274-2
x		sequential	y	2274-2
y		sequential	z	2274-2
z		sequential	T	2274-2
T	$ 2	sequential	z	2274-2
T	=	sequential	z	2274-2
T	$ 3	sequential	z	2274-2
T	x	sequential	z	2274-2
z		sequential	R	2274-2
R		sequential	x	2274-2
x		sequential	z	2274-2
z		sequential	z	2274-2
z		sequential	T	2274-2
T	$ 2	sequential	z	2274-2
T	=	sequential	z	2274-2
T	$ 3	sequential	z	2274-2
T	x	sequential	z	2274-2
z		sequential	S	2274-2
S		sequential	x	2274-2
x		sequential	z	2274-2
z		sequential	w	2274-2
w		sequential	T $ 2	2274-2
T $ 2	=	sequential	w	2274-2
T $ 2	$ 3	sequential	w	2274-2
w		sequential	z	2274-2
z		sequential	query	2274-2
query		sequential	y	2274-2
y		sequential	z	2274-2
z		sequential	T	2274-2
T		sequential	1	2274-2
1		sequential	y	2274-2
y		sequential	z	2274-2
z		sequential	query	2274-2
query		sequential	z	2274-2
z		sequential	z	2274-2
z		sequential	T $ 2	2274-2
T $ 2	=	sequential	1	2274-2
T $ 2	$ 3	sequential	1	2274-2
1		sequential	z	2274-2
It	to	constraint	an iterative algorithm	2275-1
It	is	attribute	straightforward	2275-1
It	develop	action	an iterative algorithm	2275-1
an iterative algorithm		sequential	that	2275-1
that	replaces	action	an arbitrary datalog program	2275-1
an arbitrary datalog program	and	conjunctive	query	2275-1
query	with	constraint	an equivalent one	2275-1
an equivalent one	of	constraint	whose idb subgoals	2275-1
whose idb subgoals	are rectified	action	Exercise 13.20	2275-1
whose idb subgoals	see	action	Exercise 13.20	2275-1
<B>	that	constraint	there	2275-2
<B>	Note	action	there	2275-2
there	may be	action	more than one rule	2275-2
more than one rule	defining	action	the query	2275-2
the query	after	constraint	rectification	2275-2
The magic set transformation	to	constraint	the rectified program	2276-1
The magic set transformation	is applied	action	the rectified program	2276-1
the rectified program	to	constraint	the final result	2276-1
the rectified program	obtain	action	the final result	2276-1
<B>	In	constraint	the preceding example	2276-2
the preceding example		sequential	there	2276-2
there	are	attribute	two relevant adornments	2276-2
two relevant adornments	for	constraint	the predicate T $ 2	2276-2
the predicate T $ 2	=	sequential	<B>	2276-2
the predicate T $ 2	$ 3	sequential	<B>	2276-2
<B>	can be verified	action	Exercise 13.21	2277-1
<B>	see	action	Exercise 13.21	2277-1
Exercise 13.21		sequential	Theorem 13.4.1	2277-1
Theorem 13.4.1		sequential	<B>	2277-1
the set	of	constraint	idb predicate facts	2277-2
idb predicate facts	by	constraint	a datalog query	2277-2
idb predicate facts	generated	action	a datalog query	2277-2
idb predicate facts	evaluating	action	a datalog query	2277-2
a datalog query	with	constraint	these techniques	2277-2
a datalog query	of	constraint	these techniques	2277-2
these techniques	to	constraint	the set	2277-2
these techniques	is	attribute	Furthermore identical	2277-2
the set	of	constraint	facts	2277-2
facts	in	constraint	the corresponding SLD tree	2277-2
facts	occurring	action	the corresponding SLD tree	2277-2
<B>	by	constraint	Example	2278-1
<B>	Counting	action	Example	2278-1
It	from	constraint	the previous one	2278-2
It	is	attribute	different	2278-2
the previous one	in that	constraint	it	2278-2
it	works	action	the underlying data set	2278-2
the underlying data set	to	constraint	certain acyclicity properties	2278-2
the underlying data set	only when is known	action	certain acyclicity properties	2278-2
the underlying data set	have	action	certain acyclicity properties	2278-2
<B>	Consider	action	the following SG query	2279-1
<B>	evaluating	action	the following SG query	2279-1
the following SG query	on	constraint	Same Generation	2279-1
the following SG query	based	action	Same Generation	2279-1
Same Generation		sequential	the program	2279-1
the program		sequential	sg	2279-1
sg		sequential	x	2279-1
x		sequential	y	2279-1
y		sequential	x y	2279-1
x y		sequential	sg	2279-1
sg		sequential	x	2279-1
x		sequential	y	2279-1
y		sequential	up	2279-1
up		sequential	x	2279-1
x		sequential	x1	2279-1
x1		sequential	sg	2279-1
sg		sequential	x1	2279-1
x1		sequential	y1	2279-1
y1		sequential	y1	2279-1
y1		sequential	y	2279-1
y		sequential	query	2279-1
query		sequential	y	2279-1
y		sequential	sg	2279-1
sg		sequential	a	2279-1
a		sequential	y	2279-1
y	on	constraint	input	2279-1
input		sequential	the Jn	2279-1
the Jn	by	constraint	Jn	2279-1
the Jn	given	action	Jn	2279-1
Jn		sequential	Jn	2279-1
Jn		sequential	Jn	2279-1
Jn	=	sequential	di	2279-1
Jn	{	sequential	di	2279-1
di		sequential	ej	2279-1
ej		sequential	i	2279-1
i		sequential	j ∈	2279-1
j ∈		sequential	1	2279-1
1		sequential	n	2279-1
n		sequential	} ∪	2279-1
} ∪		sequential	ei	2279-1
ei		sequential	f	2279-1
f		sequential	i	2279-1
i		sequential	∈	2279-1
∈		sequential	1	2279-1
1	n	conjunctive	<B>	2279-1
Instance		sequential	J2	2280-1
J2	in	constraint	Fig	2280-1
J2	is shown	action	Fig	2280-1
13.6		sequential	13.6	2280-2
The completed QSQ template	on	constraint	input J2	2281-1
input J2	for	constraint	the second rule	2281-1
the second rule	of	constraint	the SG query	2281-1
the SG query	in	constraint	Fig	2281-1
the SG query	is shown	action	Fig	2281-1
13.7		sequential	<B>	2281-2
The tuples	in	constraint	the order	2281-3
The tuples	are listed	action	the order	2281-3
the order	in	constraint	which	2281-3
which		sequential	QSQR	2281-3
QSQR	would discover	action	them	2281-3
<B>	that	constraint	input	2281-4
<B>	on	constraint	input	2281-4
<B>	Note	action	input	2281-4
input		sequential	Jn	2281-4
Jn		sequential	both sup 2	2281-4
both sup 2	and	conjunctive	sup 2	2281-4
sup 2	n	conjunctive	1	2281-4
sup 2	+	sequential	1	2281-4
sup 2	would contain	action	1	2281-4
1		sequential	n tuples	2281-4
<B>	Consider now	action	the proof tree	2282-1
the proof tree	of	constraint	SG	2282-1
SG	having	action	root sg	2282-1
root sg		sequential	a f	2282-1
a f	in	constraint	Fig	2282-1
a f	shown	action	Fig	2282-1
13.8	see	action	Chapter 12	2282-2
There	is	attribute	a natural correspondence	2282-3
a natural correspondence	of	constraint	the children	2282-3
the children	at	constraint	depth	2282-3
depth		sequential	1	2282-3
1	in	constraint	this tree	2282-3
this tree	with	constraint	the supplementary relation atoms	2282-3
the supplementary relation atoms		sequential	sup	2282-3
sup		sequential	2	2282-3
2		sequential	sup	2282-3
sup		sequential	2	2282-3
2		sequential	a	2282-3
a		sequential	b Evaluation	2282-3
b Evaluation	of	constraint	Datalog flat c c d d up down b b e e	2282-3
Datalog flat c c d d up down b b e e	down	constraint	up f Figure 13.6	2282-3
up f Figure 13.6		sequential	Instance J2	2282-3
Instance J2	for	constraint	QSQ	2282-3
Instance J2	by	constraint	QSQ	2282-3
Instance J2	counting	action	QSQ	2282-3
QSQ	between	constraint	the children	2282-3
QSQ	and	conjunctive	the children	2282-3
the children	at	constraint	depth 2	2282-3
depth 2	with	constraint	sup 2	2282-3
sup 2		sequential	b	2282-3
b		sequential	sup 2	2282-3
sup 2		sequential	b	2282-3
sup		sequential	2	2283-1
2		sequential	1	2283-1
1		sequential	e	2283-1
e		sequential	sup	2283-1
sup		sequential	2	2283-1
2		sequential	a	2283-1
a		sequential	b sponds	2283-1
b sponds	to	constraint	both sup 2	2283-1
both sup 2		sequential	b	2283-1
the modified supplementary relation atoms	More generally hold	action	an index	2284-1
an index		sequential	that	2284-1
that	indicates	action	a level	2284-1
a level	in	constraint	a proof tree	2284-1
a proof tree	to	constraint	the atom	2284-1
a proof tree	corresponding	action	the atom	2284-1
the atom	to	constraint	<B>	2284-1
the atom	came	action	<B>	2284-1
the atom	be created	action	<B>	2284-1
<B>	Because of	constraint	the structure	2284-2
the structure	of	constraint	SG	2284-2
SG	that	constraint	the up relation	2284-2
SG	and	conjunctive	the up relation	2284-2
SG	assuming	action	the up relation	2284-2
the up relation	is	attribute	acyclic	2284-2
these modified supplementary relations	to	constraint	query answers	2284-2
these modified supplementary relations	can be used	action	query answers	2284-2
these modified supplementary relations	find	action	query answers	2284-2
<B>	that	constraint	input Jn	2284-3
<B>	on	constraint	input Jn	2284-3
<B>	Note	action	input Jn	2284-3
input Jn		sequential	the relations countsup	2284-3
the relations countsup		sequential	2 ′	2284-3
2 ′	and	conjunctive	count	2284-3
count		sequential	sup	2284-3
sup		sequential	2 ′	2284-3
2 ′	hold	action	2n tuples	2284-3
2n tuples		sequential	each n	2284-3
each n		sequential	n	2284-3
n	+	sequential	1	2284-3
1	as	constraint	the original QSQ	2284-3
1	in	constraint	the original QSQ	2284-3
We	now describe	action	the magic set program	2285-1
the magic set program	with	constraint	the SG query	2285-1
the magic set program	associated	action	the SG query	2285-1
the SG query	into	constraint	an equivalent program	2285-1
the SG query	how can be transformed	action	an equivalent program	2285-1
an equivalent program	on	constraint	acyclic input	2285-1
acyclic input		sequential	that	2285-1
that	uses	action	the indexes	2285-1
the indexes	by	constraint	Fig	2285-1
the indexes	suggested	action	Fig	2285-1
13.7		sequential	b	2285-2
The magic set rewriting	of	constraint	the SG query	2285-3
the SG query	by	constraint	s1.1 sg bf	2285-3
the SG query	is given	action	s1.1 sg bf	2285-3
s1.1 sg bf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	input	2285-3
input	_	sequential	sg bf	2285-3
sg bf		sequential	x	2285-3
x		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	s2.1	2285-3
s2.1		sequential	sup	2285-3
sup		sequential	21	2285-3
21	x	sequential	x1	2285-3
x1		sequential	input	2285-3
input	_	sequential	sg bf	2285-3
sg bf		sequential	x	2285-3
x		sequential	x	2285-3
x		sequential	x1	2285-3
x1		sequential	s2.2	2285-3
s2.2		sequential	sup	2285-3
sup		sequential	22	2285-3
22		sequential	x	2285-3
x		sequential	y1	2285-3
y1		sequential	sup 21	2285-3
sup 21		sequential	x	2285-3
x		sequential	x1	2285-3
x1		sequential	sg bf	2285-3
sg bf		sequential	x1	2285-3
x1		sequential	y1	2285-3
y1		sequential	s2.3	2285-3
s2.3		sequential	sg bf	2285-3
sg bf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	sup 22	2285-3
sup 22		sequential	x	2285-3
x		sequential	y1	2285-3
y1		sequential	y1	2285-3
y1		sequential	y	2285-3
y		sequential	sgbf	2285-3
sgbf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	up	2285-3
up		sequential	x	2285-3
x		sequential	x	2285-3
x		sequential	sgbf	2285-3
sgbf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	y	2285-3
y		sequential	y	2285-3
y		sequential	1	2285-3
1		sequential	sup	2285-3
sup		sequential	2	2285-3
2		sequential	x	2285-3
x		sequential	sup	2285-3
sup		sequential	2	2285-3
2		sequential	x	2285-3
x	x	sequential	sup	2285-3
sup		sequential	2	2285-3
2		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	sup	2285-3
sup		sequential	2	2285-3
2		sequential	x b e b b d b	2285-3
x b e b b d b		sequential	y	2285-3
y		sequential	b d e b b c b d b e b c b	2285-3
b d e b b c b d b e b c b		sequential	b d e b c b	2285-3
b d e b c b		sequential	c	2285-3
c		sequential	sgbf	2285-3
sgbf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	up	2285-3
up		sequential	x	2285-3
x		sequential	x	2285-3
x		sequential	sgbf	2285-3
sgbf		sequential	x	2285-3
x		sequential	y	2285-3
y		sequential	y	2285-3
y		sequential	y	2285-3
y		sequential	1	2285-3
1		sequential	count_sup	2285-3
count_sup		sequential	2	2285-3
2		sequential	d	2285-3
d	x	sequential	count_sup	2285-3
count_sup		sequential	2	2285-3
2		sequential	d	2285-3
d	x	sequential	count_sup	2285-3
count_sup		sequential	2	2285-3
2		sequential	d	2285-3
d		sequential	y	2285-3
y		sequential	count_sup	2285-3
count_sup		sequential	2	2285-3
2		sequential	d	2285-3
d		sequential	y	2285-3
y		sequential	Figure	2285-3
Figure		sequential	13.7	2285-3
13.7		sequential	Illustration	2285-3
Illustration	of	constraint	intuition	2285-3
intuition	behind	constraint	counting input	2285-3
counting input	_	sequential	sg bf	2285-3
sg bf		sequential	x1	2285-3
x1		sequential	sup 21	2285-3
sup 21		sequential	x x1	2285-3
x x1		sequential	input	2285-3
input	_	sequential	sg	2285-3
sg		sequential	bf	2285-3
bf	←	sequential	query	2285-3
query		sequential	y	2285-3
The counting version	of	constraint	<B>	2286-1
The counting version	is now given	action	<B>	2286-1
<B>	In	constraint	other literature	2286-2
other literature	on	constraint	counting	2286-2
counting		sequential	the seed	2286-2
the seed	with	constraint	0	2286-2
the seed	is initialized	action	0	2286-2
0		sequential	1	2286-2
Evaluation	of	constraint	Datalog sg	2287-1
Datalog sg		sequential	a	2287-1
a		sequential	f	2287-1
f		sequential	a b	2287-1
a b		sequential	up sg down	2287-1
up sg down		sequential	b	2287-1
b		sequential	e	2287-1
e		sequential	e	2287-1
e		sequential	f	2287-1
f		sequential	up	2287-1
up		sequential	b	2287-1
b		sequential	c	2287-1
c		sequential	sg	2287-1
sg		sequential	c	2287-1
c		sequential	d	2287-1
d		sequential	down d	2287-1
down d		sequential	e	2287-1
e		sequential	c	2287-1
c		sequential	d	2287-1
d		sequential	Figure	2287-1
Figure		sequential	13.8	2287-1
13.8		sequential	count	2287-1
count	_	sequential	sg bf	2287-1
sg bf		sequential	I	2287-1
I		sequential	y	2287-1
y		sequential	count	2287-1
count	_	sequential	sup	2287-1
sup		sequential	21	2287-1
21		sequential	I	2287-1
I		sequential	x1	2287-1
x1		sequential	count	2287-1
count	_	sequential	sup	2287-1
sup		sequential	22	2287-1
22		sequential	I	2287-1
I		sequential	y1	2287-1
y1		sequential	count	2287-1
count	_	sequential	sg bf	2287-1
sg bf		sequential	I	2287-1
I		sequential	y	2287-1
y		sequential	count	2287-1
count	_	sequential	input	2287-1
input	_	sequential	sg bf	2287-1
sg bf		sequential	I	2287-1
I	+	sequential	1	2287-1
1		sequential	x1	2287-1
x1		sequential	count	2287-1
count	_	sequential	sup	2287-1
sup		sequential	21	2287-1
21		sequential	I	2287-1
I		sequential	x1	2287-1
x1		sequential	c-seed	2287-1
c-seed		sequential	count	2287-1
count	_	sequential	input	2287-1
input	_	sequential	sg	2287-1
sg		sequential	bf	2287-1
bf		sequential	1	2287-1
1		sequential	a	2287-1
<B>	In	constraint	the counting version	2288-1
the counting version		sequential	the first coordinate	2288-1
the first coordinate	of	constraint	each supplementary relation	2288-1
each supplementary relation	keeps	action	track	2288-1
track	of	constraint	a level	2288-1
a level	in	constraint	a proof tree	2288-1
a proof tree		sequential	a specific value	2288-1
<B>	constructing	action	sg bf	2288-2
sg bf		sequential	I	2288-2
I	+	sequential	1	2288-2
1		sequential	y1	2288-2
y1	in	constraint	rule	2288-2
y1	Intuitively when is used	action	rule	2288-2
rule		sequential	c	2288-2
c		sequential	s2.2	2288-2
rule		sequential	c	2288-3
c		sequential	i2.2	2288-3
i2.2	Furthermore initiates	action	the construction	2288-3
the construction	to	constraint	a new layer	2288-3
the construction	corresponding	action	a new layer	2288-3
a new layer	of	constraint	the proof tree	2288-3
The counting program	of	constraint	the preceding example	2289-1
the preceding example	in	constraint	the sense	2289-1
the preceding example	is	attribute	not safe	2289-1
the sense	that	constraint	some inputs	2289-1
the sense	on	constraint	some inputs	2289-1
some inputs		sequential	the program	2289-1
the program	may produce	action	an infinite set	2289-1
an infinite set	of	constraint	tuples	2289-1
tuples	in	constraint	some predicates	2289-1
some predicates		sequential	count	2289-1
count	_	sequential	sup	2289-1
sup		sequential	2	2289-1
<B>	For	constraint	example	2289-2
example	if	constraint	there	2289-2
example	will happen	action	there	2289-2
there	is	attribute	a cycle	2289-2
a cycle	in	constraint	the up relation	2289-2
the up relation	reachable	action	1	2289-2
1	from	constraint	<B>	2289-2
<B>	As	constraint	a result	2289-3
a result		sequential	the counting technique	2289-3
the counting technique	can only be used	action	the underlying data set	2289-3
the underlying data set	to	constraint	certain restrictions	2289-3
the underlying data set	where is known	action	certain restrictions	2289-3
the underlying data set	satisfy	action	certain restrictions	2289-3
Bibliographic Notes		sequential	Bibliographic Notes	2290-1
Bibliographic Notes		sequential	Bibliographic Notes	2291-1
An excellent survey	of	constraint	this work	2291-2
this work	is	attribute	BR88a	2291-2
BR88a		sequential	which	2291-2
which	presents	action	a taxonomy	2291-2
a taxonomy	of	constraint	different techniques	2291-2
different techniques	and	conjunctive	surveys	2291-2
surveys		sequential	a broad number	2291-2
a broad number	of	constraint	them	2291-2
Several books	provide	action	substantial coverage	2291-3
substantial coverage	of	constraint	this area	2291-3
this area	including	action	Bid91a	2291-3
Bid91a		sequential	CGT90	2291-3
CGT90		sequential	Ull89	2291-3
Ull89		sequential	b	2291-3
Experimental results	of	constraint	the techniques	2291-4
Experimental results	comparing	attribute	several	2291-4
the techniques	in	constraint	the context	2291-4
the context	of	constraint	datalog	2291-4
datalog	in	constraint	BR88 b	2291-4
datalog	are described	action	BR88 b	2291-4
An excellent survey	on	constraint	deductive database systems	2291-5
deductive database systems		sequential	which	2291-5
which	includes	action	an overview	2291-5
an overview	of	constraint	several prototype systems	2291-5
several prototype systems		sequential	that	2291-5
that	support	action	datalog	2291-5
datalog	in	constraint	RU94	2291-5
datalog	is presented	action	RU94	2291-5
<B>	and	conjunctive	The strategies	2292-1
The strategies	for	constraint	datalog evaluation	2292-1
datalog evaluation	underlie	action	several early investigations	2292-1
several early investigations	and	conjunctive	implementations	2292-1
implementations		sequential	Cha81 b	2292-1
Cha81 b		sequential	MS81	2292-1
MS81		sequential	the seminaive strategy	2292-1
the seminaive strategy	for	constraint	evaluation	2292-1
evaluation	in	constraint	Ban85	2292-1
evaluation	is described	action	Ban85	2292-1
Ban85		sequential	Ban86	2292-1
Ban86		sequential	which	2292-1
which	also propose	action	various refinements	2292-1
The use	of	constraint	T i−1	2292-2
T i−1	and	conjunctive	T i	2292-2
T i	in	constraint	Algorithm 13.1.1	2292-2
Algorithm 13.1.1	from	constraint	BR87 b	2292-2
Algorithm 13.1.1	is	attribute	BR87 b	2292-2
Reference		sequential	CGT90	2292-3
CGT90	highlights	action	the close relationship	2292-3
the close relationship	of	constraint	these approaches	2292-3
these approaches	to	constraint	Jacobi	2292-3
Jacobi	and	conjunctive	Gauss	2292-3
Gauss		sequential	Seidel	2292-3
Seidel		sequential	the classical algorithms	2292-3
the classical algorithms	of	constraint	numerical analysis	2292-3
Query Subquery		sequential	QSQ	2293-1
QSQ		sequential	The approach	2293-1
The approach	in	constraint	Vie86	2293-1
The approach	was initially presented	action	Vie86	2293-1
Vie86		sequential	the independently developed method	2293-1
the independently developed method	of	constraint	extension tables	2293-1
extension tables		sequential	DW87	2293-1
DW87	to	constraint	<B>	2293-1
DW87	is	attribute	essentially equivalent	2293-1
The QSQ approach	in	constraint	Vie88	2294-1
The QSQ approach	is extended	action	Vie88	2294-1
Vie88		sequential	Vie89	2294-1
Vie89	to	constraint	certain global optimizations	2294-1
Vie89	incorporate	action	certain global optimizations	2294-1
An extension	of	constraint	the technique	2294-2
the technique	to	constraint	general logic programming	2294-2
general logic programming	called	action	SLD	2294-2
SLD		sequential	AL	2294-2
AL	in	constraint	Vie87a	2294-2
AL	is developed	action	Vie87a	2294-2
Vie87a		sequential	Vie89	2294-2
Related approaches	include	action	APEX	2294-3
APEX		sequential	Loz85	2294-3
Loz85		sequential	Earley Deduction	2294-3
Earley Deduction		sequential	PW80	2294-3
PW80		sequential	Por86	2294-3
Por86	of	constraint	Nej87	2294-3
Por86	and	conjunctive	Nej87	2294-3
Nej87		sequential	Roe87	2294-3
The connection	between	constraint	parsing	2294-4
parsing	and	conjunctive	datalog	2294-4
datalog		sequential	evaluation	2294-4
evaluation	in	constraint	Lan88	2294-4
evaluation	is highlighted	action	Lan88	2294-4
The algorithms	of	constraint	the QSQ family	2295-1
the QSQ family	are sometimes called	action	memo-ing	2295-1
memo-ing		sequential	approaches	2295-1
approaches	because	constraint	they	2295-1
they	use	action	various data structures	2295-1
various data structures	to	constraint	salient inferred facts	2295-1
various data structures	remember	action	salient inferred facts	2295-1
salient inferred facts	to	constraint	the work	2295-1
salient inferred facts	filter	action	the work	2295-1
the work	of	constraint	traditional SLD resolution	2295-1
the most general	of	constraint	the approaches	2296-1
the approaches	Perhaps uses	action	rule	2296-1
rule	/	sequential	goal	2296-1
goal		sequential	graphs	2296-1
graphs		sequential	Ull85	2296-1
Ull85		sequential	these potentially infinite trees	2296-1
these potentially infinite trees	to	constraint	a breadth time execution	2296-1
these potentially infinite trees	at	constraint	a breadth time execution	2296-1
these potentially infinite trees	a-	sequential	a breadth time execution	2296-1
these potentially infinite trees	intuitively correspond	action	a breadth time execution	2296-1
these potentially infinite trees	set	action	a breadth time execution	2296-1
a breadth time execution	of	constraint	SLD resolution	2296-1
<B>	/	sequential	goal	2296-2
goal		sequential	Rule graphs	2296-2
Rule graphs	in	constraint	Van86	2296-2
Rule graphs	are applied	action	Van86	2296-2
Van86	to	constraint	datalog queries	2296-2
Van86	evaluate	action	datalog queries	2296-2
datalog queries	in	constraint	distributed systems	2296-2
Similar graph structures	in	constraint	connection	2296-3
Similar graph structures	have also been used	action	connection	2296-3
connection	with	constraint	general logic programs	2296-3
general logic programs		sequential	Kow75	2296-3
Kow75		sequential	Sic76	2296-3
A survey	of	constraint	several approaches	2296-4
A survey	graph based	action	several approaches	2296-4
several approaches	is	attribute	<B>	2296-4
<B>	to	constraint	bottom	2297-1
<B>	Turning	action	bottom	2297-1
bottom	up	constraint	approaches	2297-1
approaches		sequential	the essentially equivalent approaches	2297-1
the essentially equivalent approaches	of	constraint	HN84	2297-1
HN84	and	conjunctive	Evaluation	2297-1
Evaluation	of	constraint	Datalog	2297-1
magic set	and	conjunctive	counting	2298-1
counting		sequential	The techniques	2298-1
The techniques	for	constraint	linear datalog	2298-1
The techniques	originally appeared	action	linear datalog	2298-1
linear datalog	in	constraint	<B>	2298-1
The counting method	with	constraint	magic sets	2299-1
The counting method	and	conjunctive	magic sets	2299-1
The counting method	is generalized	action	magic sets	2299-1
The counting method	combined	action	magic sets	2299-1
magic sets	in	constraint	SZ86	2299-1
SZ86		sequential	SZ88	2299-1
Supplementary magic	in	constraint	BR91	2300-1
Supplementary magic	is incorporated	action	BR91	2300-1
Analytic comparisons	of	constraint	magic	2300-2
magic	and	conjunctive	counting	2300-2
counting	for	constraint	selected programs	2300-2
selected programs	in	constraint	MSPS87	2300-2
selected programs	are presented	action	MSPS87	2300-2
<B>	of	constraint	the investigations	2301-1
the investigations	just mentioned	action	BR87a	2301-1
the investigations	including	action	BR87a	2301-1
BR87a		sequential	KL86a	2301-1
KL86a		sequential	KL86	2301-1
KL86		sequential	b	2301-1
b		sequential	Ull85	2301-1
Ull85		sequential	Vie86	2301-1
Vie86	emphasize	action	the idea	2301-1
the idea	that	constraint	sideways information passing	2301-1
sideways information passing	and	conjunctive	control	2301-1
control	are	attribute	largely independent	2301-1
<B>		sequential	SZ88	2301-2
SZ88	and	conjunctive	BR91	2301-2
BR91	describe	action	fairly general mechanisms	2301-2
fairly general mechanisms	for	constraint	passing	2301-2
fairly general mechanisms	and	conjunctive	passing	2301-2
fairly general mechanisms	specifying	action	passing	2301-2
fairly general mechanisms	using	action	passing	2301-2
passing	and	conjunctive	alternative sideways information message passing	2301-2
A more general form	of	constraint	sideways information passing	2301-3
sideways information passing		sequential	which	2301-3
which	passes	action	bounding inequalities	2301-3
bounding inequalities	between	constraint	subgoals	2301-3
subgoals	in	constraint	APP+86	2301-3
subgoals	is studied	action	APP+86	2301-3
A formal framework	for	constraint	the success	2301-4
A formal framework	studying	action	the success	2301-4
the success	of	constraint	selections	2301-4
the success	pushing	action	selections	2301-4
selections	into	constraint	datalog programs	2301-4
datalog programs	in	constraint	BKBR87	2301-4
datalog programs	is developed	action	BKBR87	2301-4
Several papers	have studied	action	the connection	2302-1
the connection	between	constraint	top down	2302-1
top down	and	conjunctive	bottom	2302-1
bottom	up	constraint	evaluation techniques	2302-1
One body	of	constraint	the research	2302-2
the research	in	constraint	this direction	2302-2
this direction	on	constraint	the sets	2302-2
this direction	focuses	action	the sets	2302-2
the sets	of	constraint	facts	2302-2
facts	by	constraint	top down	2302-2
facts	generated	action	top down	2302-2
top down	and	conjunctive	bottom	2302-2
bottom	up	constraint	the techniques	2302-2
One	of	constraint	the first results	2302-3
the first results	and	conjunctive	bottom	2302-3
the first results	relating	action	bottom	2302-3
bottom		sequential	up	2302-3
up	from	constraint	BR87a	2302-3
up	is	attribute	BR87a	2302-3
BR87a		sequential	BR91	2302-3
BR91		sequential	it	2302-3
it	that	constraint	a technique	2302-3
it	if	constraint	a technique	2302-3
it	where is shown	attribute	top down	2302-3
a technique	and	conjunctive	the generalized supplementary magic set technique	2302-3
the generalized supplementary magic set technique	use	action	a given family	2302-3
a given family	of	constraint	sideways information passing techniques	2302-3
sideways information passing techniques		sequential	the sets	2302-3
the sets	of	constraint	intermediate facts	2302-3
intermediate facts	by	constraint	both techniques	2302-3
intermediate facts	produced	action	both techniques	2302-3
both techniques	correspond	action	<B>	2302-3
That research	in	constraint	the context	2302-4
That research	is conducted	action	the context	2302-4
the context	of	constraint	general logic programs	2302-4
general logic programs		sequential	that	2302-4
that		sequential	range	2302-4
range	are restricted	action	<B>	2302-4
These results	to	constraint	possibly logic programs	2302-5
These results	are generalized	action	possibly logic programs	2302-5
These results	non-range restricted	action	possibly logic programs	2302-5
possibly logic programs	in	constraint	the independent research	2302-5
the independent research		sequential	Ram91	2302-5
Ram91	and	conjunctive	Sek89	2302-5
<B>	In	constraint	that research	2302-6
that research		sequential	bottom	2302-6
bottom		sequential	up	2302-6
up		sequential	evaluations	2302-6
evaluations	may use	action	terms	2302-6
terms	and	conjunctive	tuples	2302-6
tuples		sequential	that	2302-6
that	include	action	variables	2302-6
variables	and	conjunctive	bottom	2302-6
bottom	up	constraint	evaluation	2302-6
evaluation	of	constraint	rewritten programs	2302-6
rewritten programs	uses	action	unification	2302-6
unification		sequential	simple relational join	2302-6
A close correspondence	between	constraint	top down	2302-7
top down	and	conjunctive	bottom	2302-7
bottom	up	constraint	evaluation	2302-7
evaluation	for	constraint	datalog	2302-7
datalog	in	constraint	Ull89a	2302-7
datalog	was established	action	Ull89a	2302-7
Ull89a		sequential	subgoal rectification	2302-7
subgoal rectification	where is used	action	<B>	2302-7
The treatment	of	constraint	Program	2302-8
Program		sequential	Pr	2302-8
Pr	and	conjunctive	Theorem 13.4.1	2302-8
Theorem 13.4.1	by	constraint	that development	2302-8
Theorem 13.4.1	are inspired	action	that development	2302-8
This close correspondence	to	constraint	arbitrary logic programs	2302-9
This close correspondence	is extended	action	arbitrary logic programs	2302-9
arbitrary logic programs	in	constraint	Ull89 b	2302-9
<B>	Using	action	a more detailed cost model	2302-10
a more detailed cost model		sequential	SR93	2302-10
SR93	that	constraint	bottom	2302-10
SR93	shows	action	bottom	2302-10
bottom	up	constraint	evaluation	2302-10
evaluation	down	constraint	evaluation	2302-10
evaluation	asymptotically dominates	attribute	top	2302-10
evaluation	for	constraint	logic programs	2302-10
logic programs	if	constraint	they	2302-10
they	even produce	action	nonground terms	2302-10
nonground terms	in	constraint	their output	2302-10
<B>	Exercises	action	the QSQ	2303-1
the QSQ	until	constraint	a fixpoint	2303-1
a fixpoint	is reached	action	<B>	2303-1
<B>	that	constraint	the fixpoint operator	2303-2
<B>	Note	action	the fixpoint operator	2303-2
the fixpoint operator	in	constraint	this chapter	2303-2
the fixpoint operator	used	action	this chapter	2303-2
this chapter	from	constraint	bottom	2303-2
this chapter	is	attribute	different	2303-2
bottom	up	constraint	the conventional application	2303-2
the conventional application	of	constraint	TP	2303-2
TP	by	constraint	the naive algorithm	2303-2
TP	used	action	the naive algorithm	2303-2
the naive algorithm	for	constraint	datalog evaluation	2303-2
The framework	in	constraint	Bry89	2303-3
The framework	presented	action	Bry89	2303-3
Bry89	on	constraint	meta- interpreters	2303-3
Bry89	is based	action	meta- interpreters	2303-3
meta- interpreters		sequential	interpreters	2303-3
interpreters		sequential	that	2303-3
that	on	constraint	datalog rules	2303-3
that	operate	action	datalog rules	2303-3
datalog rules	in	constraint	addition	2303-3
addition	to	constraint	data	2303-3
data	to	constraint	QSQ	2303-3
data	can be used	action	QSQ	2303-3
data	specify	action	QSQ	2303-3
QSQ	and	conjunctive	algorithms	2303-3
algorithms	as	constraint	bottom up	2303-3
bottom up		sequential	fixpoint evaluations	2303-3
meta		sequential	Such programming	2303-4
Such programming	in	constraint	programming	2303-4
Such programming	and	conjunctive	programming	2303-4
Such programming	is	attribute	common	2303-4
programming	but	conjunctive	novel results	2303-4
programming	yields	action	novel results	2303-4
novel results	in	constraint	the context	2303-4
the context	of	constraint	datalog	2303-4
Reference		sequential	Bry	2303-5
Bry		sequential	89	2303-5
89	to	constraint	bottom	2303-5
89	and	conjunctive	bottom	2303-5
89	goes on	action	bottom	2303-5
89	describe	action	bottom	2303-5
bottom	up	constraint	several datalog evaluation techniques	2303-5
several datalog evaluation techniques	within	constraint	the framework	2303-5
the framework	proving	action	their correctness	2303-5
their correctness	and	conjunctive	a basis	2303-5
their correctness	providing	action	a basis	2303-5
a basis	for	constraint	comparison	2303-5
Extensions	of	constraint	the datalog evaluation techniques	2304-1
the datalog evaluation techniques	to	constraint	stratified datalog¬ programs	2304-1
stratified datalog¬ programs	see	action	Chapter 15	2304-1
Chapter 15	include	action	BPR87	2304-1
BPR87		sequential	Ros91	2304-1
Ros91		sequential	SI88	2304-1
SI88		sequential	KT88	2304-1
Exercises Exercise 13.1	Recall	action	the program RSG ′	2305-1
the program RSG ′	from	constraint	Section 13.1	2305-1
Exhibit		sequential	an instance	2305-2
an instance		sequential	I	2305-2
I	on	constraint	this input	2305-2
this input		sequential	δi	2305-2
δi	for	constraint	each i 0	2305-2
δi	=	sequential	each i 0	2305-2
δi	∅	sequential	each i 0	2305-2
rsg Exercise		sequential	13.2	2306-1
<B>	Let	action	P1	2306-2
P1	of	constraint	P2 the second	2306-2
P1	and	conjunctive	P2 the second	2306-2
P1	denote	attribute	the first	2306-2
<B>	Show	attribute	the following	2307-1
<B>	Exercise	action	13.3	2308-1
13.3	Consider	action	the basic seminaive algorithm	2308-1
the basic seminaive algorithm		sequential	13.1.1	2308-1
Evaluation	of	constraint	Datalog	2309-1
S	to	constraint	T i+1	2310-1
T i+1		sequential	I	2310-1
I		sequential	S	2310-1
S		sequential	T i	2310-1
T i		sequential	I	2310-1
I		sequential	S	2310-1
P P		sequential	P P	2311-1
Exercise		sequential	13.4	2312-1
Exercise		sequential	13.5	2313-1
<B>	that	constraint	the naive algorithm	2313-2
<B>	Suppose	action	the naive algorithm	2313-2
the naive algorithm	is performed	action	P	2313-2
the naive algorithm	using	action	P	2313-2
P		sequential	′	2313-2
′	on	constraint	some input I	2313-2
<B>	Does yield	action	P	2313-3
P		sequential	I	2313-3
<B>	or	conjunctive	<B>	2313-4
What	if	constraint	the basic seminaive algorithm	2313-5
the basic seminaive algorithm	is used	action	<B>	2313-5
Exercise		sequential	13.6	2314-1
Exercise		sequential	13.7	2315-1
13.7		sequential	S3	2315-1
S3		sequential	S4	2315-1
S4	are	attribute	where edb relations	2315-1
<B>	that	constraint	the atoms	2315-2
<B>	Observe	action	the atoms	2315-2
the atoms		sequential	S3	2315-2
S3		sequential	u	2315-2
u		sequential	v	2315-2
v	and	conjunctive	S4	2315-2
S4		sequential	v	2315-2
v		sequential	w	2315-2
w	to	constraint	the other atoms	2315-2
w	are not connected	action	the other atoms	2315-2
the other atoms	of	constraint	the rule body	2315-2
the rule body	to	constraint	the rule head	2315-2
the rule body	or	conjunctive	the rule head	2315-2
<B>	in	constraint	an evaluation	2315-3
an evaluation	of	constraint	P	2315-3
P	on	constraint	input	2315-3
input		sequential	I	2315-3
I		sequential	this rule	2315-3
this rule	may contribute	action	some tuple	2315-3
some tuple	to	constraint	S	2315-3
S	if	constraint	there	2315-3
there	only is	action	an assignment	2315-3
an assignment	for	constraint	u	2315-3
u	w	constraint	S3	2315-3
u	that	constraint	S3	2315-3
S3		sequential	u	2315-3
u		sequential	v	2315-3
v		sequential	S4	2315-3
S4		sequential	v	2315-3
v		sequential	w	2315-3
w		sequential	α	2315-3
α		sequential	I	2315-3
<B>	Explain	action	it	2315-4
it	to	constraint	ρ	2315-4
it	is	attribute	typically more efficient	2315-4
it	replace	action	ρ	2315-4
ρ	with	constraint	ρ′	2315-4
ρ′		sequential	S	2315-4
S		sequential	x	2315-4
x		sequential	y	2315-4
y		sequential	S1	2315-4
S1		sequential	x	2315-4
x		sequential	z	2315-4
z		sequential	S2	2315-4
S2		sequential	z	2315-4
z		sequential	y	2315-4
y	if	constraint	there	2315-4
there	is	attribute	such an assignment	2315-4
such an assignment	to	constraint	ρ	2315-4
such an assignment	and	conjunctive	ρ	2315-4
such an assignment	delete otherwise	action	ρ	2315-4
ρ	from	constraint	P	2315-4
<B>	to	constraint	the case	2315-5
<B>	Extend	attribute	this	2315-5
the case		sequential	S3 S4	2315-5
S3 S4	are	attribute	when idb relations	2315-5
State		sequential	a general version	2315-6
a general version	of	constraint	this heuristic improvement	2315-6
Exercise		sequential	13.8	2316-1
<B>	Explain	action	it	2317-1
it	why makes	action	sense	2317-1
sense	to	constraint	the second occurrence	2317-1
sense	view	action	the second occurrence	2317-1
the second occurrence	of	constraint	v	2317-1
v	as	constraint	<B>	2317-1
v	bound	action	<B>	2317-1
<B>	Exercise	action	13.9	2318-1
13.9	Consider	action	the rule R	2318-1
the rule R		sequential	x	2318-1
x		sequential	y	2318-1
y		sequential	y	2318-1
y	←	sequential	S	2318-1
S		sequential	y	2318-1
y		sequential	z	2318-1
z		sequential	T	2318-1
T		sequential	z	2318-1
z		sequential	x	2318-1
Exercises		sequential	Exercises	2319-1
Exercise		sequential	13.10	2320-1
Exercise		sequential	13.14	2321-1
Exercise		sequential	13.15	2322-1
Exercise		sequential	13.17	2323-1
Evaluation	of	constraint	Datalog sgv bf	2324-1
Datalog sgv bf		sequential	x	2324-1
x		sequential	y	2324-1
y		sequential	sgv bf	2324-1
sgv bf		sequential	x	2324-1
x		sequential	y	2324-1
y		sequential	input	2324-1
input	_	sequential	sgv bf	2324-1
sgv bf	z	sequential	1	2324-1
1		sequential	input	2324-1
input	_	sequential	sgv bf	2324-1
sgv bf		sequential	x	2324-1
x		sequential	x	2324-1
x		sequential	z1	2324-1
z1		sequential	o	2324-1
o		sequential	i2.4	2324-1
i2.4		sequential	input	2324-1
input	_	sequential	sgv bf	2324-1
sgv bf		sequential	z3	2324-1
z3	←	sequential	input	2324-1
input		sequential	sgv bf	2324-1
sgv bf		sequential	x	2324-1
x		sequential	x z1	2324-1
x z1		sequential	sgv bf	2324-1
sgv bf		sequential	z1	2324-1
z1		sequential	z2	2324-1
z2		sequential	z2	2324-1
z2		sequential	z3	2324-1
z3		sequential	flat input	2324-1
flat input	_	sequential	sgv a query	2324-1
sgv a query		sequential	y	2324-1
bf bf bf bf bbf Rbbf		sequential	x	2325-1
x		sequential	y	2325-1
y		sequential	z	2325-1
z	←	sequential	<B>	2325-1
Exercise		sequential	13.22	2326-1
Exercises	count	action	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	y	2327-1
y		sequential	count	2327-1
count	_	sequential	sup	2327-1
sup		sequential	21	2327-1
21		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	z1	2327-1
z1		sequential	count	2327-1
count	_	sequential	sup	2327-1
sup		sequential	22	2327-1
22		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	z2	2327-1
z2		sequential	count	2327-1
count	_	sequential	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I	+	sequential	1	2327-1
1		sequential	2 K	2327-1
2 K	+	sequential	2	2327-1
2		sequential	5L	2327-1
5L	+	sequential	2 z2	2327-1
2 z2		sequential	count	2327-1
count	_	sequential	sup	2327-1
sup		sequential	23	2327-1
23		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	z3	2327-1
z3		sequential	count	2327-1
count	_	sequential	sup	2327-1
sup		sequential	24	2327-1
24		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	z4	2327-1
z4		sequential	count	2327-1
count		sequential	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I	+	sequential	1	2327-1
1		sequential	2 K	2327-1
2 K	+	sequential	2	2327-1
2		sequential	5L	2327-1
5L	+	sequential	4	2327-1
4		sequential	z4	2327-1
z4		sequential	count	2327-1
count	_	sequential	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I		sequential	K	2327-1
K		sequential	L	2327-1
L		sequential	y	2327-1
y		sequential	count	2327-1
count	_	sequential	input	2327-1
input	_	sequential	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I	+	sequential	1	2327-1
1		sequential	2 K	2327-1
2 K	+	sequential	2	2327-1
2		sequential	5L	2327-1
5L	+	sequential	2	2327-1
2		sequential	z1	2327-1
z1		sequential	count	2327-1
count	_	sequential	input	2327-1
input	_	sequential	sgv bf	2327-1
sgv bf		sequential	I	2327-1
I	+	sequential	1	2327-1
1		sequential	2 K	2327-1
2 K	+	sequential	2	2327-1
2		sequential	5L	2327-1
5L	+	sequential	4	2327-1
4		sequential	z3	2327-1
z3		sequential	count	2327-1
count	_	sequential	input	2327-1
input	_	sequential	sgv bf	2327-1
sgv bf		sequential	1	2327-1
1		sequential	0	2327-1
0		sequential	0	2327-1
0		sequential	query	2327-1
query		sequential	Figure	2327-1
Figure		sequential	13.9	2327-1
13.9		sequential	Generalized counting transformation	2327-1
Generalized counting transformation	on	constraint	SGV query	2327-1
Vittorio	Let	action	’ s	2328-1
’ s	combine	action	recursion	2328-1
recursion	and	conjunctive	negation	2328-1
Riccardo		sequential	Riccardo	2329-1
Sergio		sequential	Sergio	2330-1
Riccardo		sequential	Riccardo	2331-1
Vittorio	about	constraint	how datalog	2332-1
how datalog	with	constraint	negation	2332-1
Riccardo		sequential	Riccardo	2333-1
Riccardo		sequential	you	2334-1
you	are	attribute	recursively negative	2334-1
The query languages	by	constraint	the conjunctive queries	2335-1
The query languages	considered so far	action	the conjunctive queries	2335-1
The query languages	were obtained	action	the conjunctive queries	2335-1
The query languages	augmenting successively	action	the conjunctive queries	2335-1
the conjunctive queries	with	constraint	disjunction	2335-1
disjunction		sequential	negation	2335-1
negation	and	conjunctive	recursion	2335-1
<B>	In	constraint	this chapter	2335-2
this chapter		sequential	we	2335-2
we	consider	action	languages	2335-2
languages		sequential	that	2335-2
that	both	conjunctive	negation	2335-2
that	provide	action	negation	2335-2
negation	and	conjunctive	recursion	2335-2
They	allow	action	us	2335-3
us	to	constraint	queries	2335-3
us	ask	action	queries	2335-3
queries		sequential	Which	2335-3
Which	are	attribute	the pairs	2335-3
the pairs	of	constraint	metro stops	2335-3
metro stops		sequential	which	2335-3
which	are not connected	action	<B>	2335-3
This query	in	constraint	relational calculus	2335-4
This query	is	attribute	not expressible	2335-4
relational calculus	and	conjunctive	algebra	2335-4
algebra	in	constraint	datalog	2335-4
algebra	or	conjunctive	datalog	2335-4
The integration	of	constraint	recursion	2336-1
recursion	and	conjunctive	negation	2336-1
negation	and	conjunctive	highly expressive languages	2336-1
negation	is	attribute	natural	2336-1
negation	yields	action	highly expressive languages	2336-1
We	will see	action	it	2336-2
it	in	constraint	the three paradigms	2336-2
it	how can be achieved	action	the three paradigms	2336-2
the three paradigms	considered so far	attribute	algebraic	2336-2
logic	and	conjunctive	<B>	2336-2
The algebraic language	is	attribute	an extension	2336-3
an extension	of	constraint	the algebra	2336-3
the algebra	with	constraint	a looping construct	2336-3
a looping construct	and	conjunctive	an assignment	2336-3
an assignment	in	constraint	the style	2336-3
the style	of	constraint	traditional imperative programming languages	2336-3
The logic language	is	attribute	an extension	2336-4
an extension	of	constraint	the calculus	2336-4
the calculus	in	constraint	which	2336-4
which		sequential	recursion	2336-4
recursion	by	constraint	a fixpoint operator	2336-4
recursion	is provided	action	a fixpoint operator	2336-4
The deductive language	extends	action	datalog	2336-5
datalog	with	constraint	negation	2336-5
<B>	In	constraint	this chapter	2337-1
this chapter		sequential	the semantics	2337-1
the semantics	of	constraint	datalog	2337-1
datalog	with	constraint	negation	2337-1
negation	from	constraint	a purely computational perspective	2337-1
negation	is defined	action	a purely computational perspective	2337-1
a purely computational perspective		sequential	that	2337-1
that	in	constraint	the spirit	2337-1
that	is	attribute	the spirit	2337-1
the spirit	of	constraint	the algebraic approach	2337-1
<B>	and	conjunctive	model	2337-2
<B>	accepted	action	model	2337-2
model		sequential	More natural semantics	2337-2
More natural semantics	and	conjunctive	semantics	2337-2
More natural semantics	stratified	action	semantics	2337-2
More natural semantics	well founded	action	semantics	2337-2
semantics	in	constraint	Chapter 15	2337-2
semantics	are presented	action	Chapter 15	2337-2
Recursion	and	conjunctive	Negation	2338-1
Negation	of	constraint	such queries	2338-1
such queries	that	constraint	there	2338-1
such queries	imply	action	there	2338-1
there	are	attribute	queries	2338-1
queries		sequential	that	2338-1
that	are	attribute	not fixpoint	2338-1
not fixpoint	while	constraint	queries	2338-1
not fixpoint	or	conjunctive	queries	2338-1
More powerful languages	in	constraint	Chapter 18	2338-2
More powerful languages	are considered	action	Chapter 18	2338-2
<B>	Before	constraint	specific languages	2339-1
<B>	describing	action	specific languages	2339-1
specific languages		sequential	we	2339-1
we	present	action	an example	2339-1
an example		sequential	that	2339-1
that	illustrates	action	the principles	2339-1
the principles	underlying	action	the two flavors	2339-1
the two flavors	of	constraint	the languages	2339-1
Example		sequential	Example	2340-1
The game	with	constraint	a set	2340-2
The game	starts	action	a set	2340-2
a set	of	constraint	cells	2340-2
cells	of	constraint	which	2340-2
which	and	conjunctive	the alive ones	2340-2
which	are	attribute	alive	2340-2
the alive ones	in	constraint	<B>	2340-2
the alive ones	or	conjunctive	<B>	2340-2
the alive ones	are colored	attribute	blue	2340-2
One cell	may have	action	two colors	2340-3
Each cell	has	action	other cells	2340-4
other cells	as	constraint	neighbors	2340-4
<B>	that	constraint	a binary relation Neighbor	2340-5
<B>	Suppose	action	a binary relation Neighbor	2340-5
a binary relation Neighbor	holds	action	the neighbor relation	2340-5
the neighbor relation	as	constraint	a symmetric relation	2340-5
the neighbor relation	considered	action	a symmetric relation	2340-5
a symmetric relation	that	constraint	the information	2340-5
a symmetric relation	and	conjunctive	the information	2340-5
the information	about	constraint	living cells	2340-5
living cells	and	conjunctive	their color	2340-5
their color	in	constraint	a binary relation Alive	2340-5
their color	is held	action	a binary relation Alive	2340-5
a binary relation Alive	see	action	Fig	2340-5
14.1		sequential	14.1	2340-6
<B>	that	constraint	a cell	2340-7
<B>	Suppose first	action	a cell	2340-7
a cell	can change	action	status	2340-7
status	from	constraint	this rule	2340-7
status	to	constraint	this rule	2340-7
status	following	action	this rule	2340-7
this rule		sequential	α	2340-7
14.1	in	constraint	Fig	2340-8
14.1	a is given	action	Fig	2340-8
14.1		sequential	<B>	2340-9
<B>	that	constraint	the sets	2340-10
<B>	Observe	action	the sets	2340-10
the sets	of	constraint	tuples	2340-10
tuples	that	constraint	we	2340-10
tuples	and	conjunctive	we	2340-10
tuples	keep	action	we	2340-10
tuples	increasing	action	we	2340-10
we	reach	action	a stable state	2340-10
<B>	is	attribute	an example	2341-1
an example	of	constraint	inflationary iteration	2341-1
<B>	that	constraint	the evolution	2342-1
<B>	Now suppose	action	the evolution	2342-1
the evolution	also obeys	action	the second rule	2342-1
The evolution	of	constraint	the population	2343-1
the population	with	constraint	the two rules	2343-1
the two rules	in	constraint	Fig	2343-1
the two rules	is given	action	Fig	2343-1
14.1		sequential	c	2343-2
<B>	that	constraint	the number	2343-3
<B>	Observe	action	the number	2343-3
the number	of	constraint	tuples	2343-3
tuples	that	constraint	the computation	2343-3
tuples	and	conjunctive	the computation	2343-3
tuples	sometimes decreases	action	the computation	2343-3
the computation	diverges	action	<B>	2343-3
<B>	is	attribute	an example	2343-4
an example	of	constraint	noninflationary iteration	2343-4
i=1		sequential	n	2344-1
n	+	sequential	c	2344-1
c		sequential	ri	2344-1
ri		sequential	which	2344-1
which	is	attribute	a polynomial	2344-1
a polynomial	in	constraint	n	2344-1
<B>	As	constraint	the formal definitions	2344-2
<B>	will be seen	action	the formal definitions	2344-2
the formal definitions	in	constraint	when place	2344-2
the formal definitions	are	attribute	when place	2344-2
when place	that	constraint	each noninflationary iteration	2344-2
when place	implies	action	each noninflationary iteration	2344-2
each noninflationary iteration	and	conjunctive	hence each noninflationary query	2344-2
hence each noninflationary query	in	constraint	polynomial space	2344-2
hence each noninflationary query	can be evaluated	action	polynomial space	2344-2
polynomial space	whether or not	constraint	it	2344-2
it	terminates	action	<B>	2344-2
<B>	In	constraint	contrast	2344-3
contrast		sequential	the inflationary semantics	2344-3
the inflationary semantics	ensures	action	termination	2344-3
termination	by	constraint	a tuple	2344-3
termination	that	constraint	a tuple	2344-3
termination	requiring	action	a tuple	2344-3
a tuple	once	constraint	it	2344-3
a tuple	can never be deleted	action	it	2344-3
it	has been inserted	action	<B>	2344-3
<B>	Because	constraint	there	2345-1
there	are	attribute	only polynomially many tuples	2345-1
only polynomially many tuples		sequential	each such program	2345-1
each such program	in	constraint	polynomial time	2345-1
each such program	terminates	action	polynomial time	2345-1
<B>	To	constraint	the inflationary languages	2346-1
<B>	summarize	action	the inflationary languages	2346-1
the inflationary languages	use	action	iteration	2346-1
iteration	on	constraint	an inflation	2346-1
iteration	based	action	an inflation	2346-1
an inflation	of	constraint	tuples	2346-1
The noninflationary languages	or	conjunctive	assignment	2346-2
The noninflationary languages	use inside	attribute	noninflationary	2346-2
assignment	of	constraint	iterations	2346-2
<B>	In	constraint	all three paradigms	2346-3
all three paradigms		sequential	noninflationary queries	2346-3
noninflationary queries	in	constraint	polynomial space	2346-3
noninflationary queries	can be evaluated	action	polynomial space	2346-3
polynomial space	and	conjunctive	the same expressive power	2346-3
the same expressive power	is	attribute	Recursion	2346-3
Recursion	and	conjunctive	Negation	2346-3
Negation		sequential	again Neighbor e b e c e d e	2346-3
again Neighbor e b e c e d e		sequential	blue blue blue b red b red b red c	2346-3
blue blue blue b red b red b red c		sequential	blue c blue c blue	2346-3
d red d red d red e blue e blue e red e red blue blue blue blue blue b red b red b red b red b red		sequential	d red d red d red e blue e blue e red e red blue blue blue blue blue b red b red b red b red b red	2347-1
c blue c blue c blue c blue c blue d red d red d red d red d red e blue e blue e red		sequential	e red Figure 14.1	2348-1
e red Figure 14.1		sequential	Game	2348-1
Game	of	constraint	life	2348-1
life	obtained	action	<B>	2348-1
We	that	constraint	it	2348-2
We	note however	action	it	2348-2
it	whether	constraint	the inflationary	2348-2
it	remains	attribute	open	2348-2
the inflationary	and	conjunctive	the noninflationary languages	2348-2
the noninflationary languages	have	action	equivalent expressive power	2348-2
equivalent expressive power		sequential	we	2348-2
we	discuss later	action	this issue	2348-2
14.1 Relational algebra	is	attribute	essentially a procedural language	2348-3
<B>	Of	constraint	the query languages	2348-4
the query languages		sequential	it	2348-4
it	to	constraint	traditional imperative programming languages	2348-4
it	is	attribute	the closest	2348-4
Chapters		sequential	4	2348-5
4	and	conjunctive	5	2348-5
5	described	action	it	2348-5
it	can be extended syntactically	action	assignment	2348-5
it	using	action	assignment	2348-5
assignment	and	conjunctive	composition	2348-5
assignment	=	sequential	composition	2348-5
composition	without	constraint	its expressive power	2348-5
composition	increasing	action	its expressive power	2348-5
The extensions	of	constraint	the algebra	2348-6
the algebra	with	constraint	recursion	2348-6
recursion	with	constraint	the imperative paradigm	2348-6
recursion	are	attribute	also consistent	2348-6
the imperative paradigm	and	conjunctive	a while construct	2348-6
the imperative paradigm	incorporate	action	a while construct	2348-6
a while construct		sequential	which	2348-6
which	for	constraint	the iteration	2348-6
which	calls	action	the iteration	2348-6
the iteration	of	constraint	a program segment	2348-6
The resulting language	in	constraint	two flavors	2348-7
The resulting language	comes	action	two flavors	2348-7
two flavors	and	conjunctive	<B>	2348-7
The two versions	of	constraint	the language	2348-8
the language	in	constraint	the semantics	2348-8
the language	differ	action	the semantics	2348-8
the semantics	of	constraint	the assignment statement	2348-8
The noninflationary version	was	attribute	the one	2348-9
the one	and	conjunctive	we	2348-9
the one	first defined historically	action	we	2348-9
we	discuss next	action	it	2348-9
The resulting language	is called	action	the while language	2348-10
Noninflationary Semantics Recall	from	constraint	Chapter 4	2349-1
Chapter 4	that	constraint	assignment statements	2349-1
assignment statements	into	constraint	the algebra	2349-1
assignment statements	can be incorporated	action	the algebra	2349-1
the algebra	using	action	expressions	2349-1
expressions	of	constraint	the form R	2349-1
the form R	=	sequential	E	2349-1
E		sequential	E	2349-1
E	is	attribute	where an algebra expression	2349-1
where an algebra expression	and	conjunctive	R	2349-1
R		sequential	a relational variable	2349-1
a relational variable	of	constraint	the same sort	2349-1
the same sort	as	constraint	the result	2349-1
the result	of	constraint	E.	2349-1
E.		sequential	The difference	2349-1
The difference	from	constraint	Chapter 4	2349-1
Chapter 4	that	constraint	it	2349-1
Chapter 4	is	attribute	it	2349-1
it	that	constraint	each successive assignment statement	2349-1
it	is no longer required	action	each successive assignment statement	2349-1
each successive assignment statement	use	attribute	distinct	2349-1
<B>	In	constraint	the while language	2349-2
the while language		sequential	the semantics	2349-2
the semantics	of	constraint	an assignment statement	2349-2
an assignment statement	as	constraint	<B>	2349-2
an assignment statement	is	attribute	<B>	2349-2
an assignment statement	follows	action	<B>	2349-2
<B>	is	attribute	the usual destructive assignment	2349-3
the usual destructive assignment	in	constraint	imperative programming languages	2349-3
imperative programming languages		sequential	the old value	2349-3
the old value	of	constraint	a variable	2349-3
a variable	where is overwritten	action	<B>	2349-3
<B>	While	constraint	statements	2350-1
statements	have	action	the form	2350-1
the form	while	constraint	change	2350-1
change	do begin	action	loop body end	2350-1
loop body end		sequential	There	2350-1
There	is	attribute	no explicit termination condition	2350-1
a loop	as	constraint	the execution	2350-2
a loop	Instead runs	action	the execution	2350-2
the execution	of	constraint	the body	2350-2
the body	causes	action	some change	2350-2
some change	to	constraint	some relation	2350-2
some relation	until	constraint	a stable state	2350-2
a stable state	is reached	action	<B>	2350-2
<B>	At	constraint	the end	2350-3
the end	of	constraint	this section	2350-3
this section		sequential	we	2350-3
we	consider	action	the introduction	2350-3
the introduction	of	constraint	explicit terminating conditions	2350-3
explicit terminating conditions	that	constraint	the language	2350-3
explicit terminating conditions	and	conjunctive	the language	2350-3
explicit terminating conditions	see	attribute	this	2350-3
explicit terminating conditions	does not affect	action	the language	2350-3
the language	in	constraint	an essential manner	2350-3
<B>	of	constraint	loops	2351-1
<B>	Nesting	action	loops	2351-1
loops	is permitted	action	<B>	2351-1
A while program	is	attribute	a finite sequence	2351-2
a finite sequence	of	constraint	assignment	2351-2
assignment	while	constraint	statements	2351-2
assignment	or	conjunctive	statements	2351-2
The program	uses	action	a finite set	2351-3
a finite set	of	constraint	relational variables	2351-3
relational variables	of	constraint	specified sorts	2351-3
specified sorts	including	action	the names	2351-3
the names	of	constraint	relations	2351-3
relations	in	constraint	the input database	2351-3
Relational variables		sequential	that	2351-4
that	in	constraint	not the input database	2351-4
that	are	attribute	not the input database	2351-4
not the input database	to	constraint	the empty relation	2351-4
not the input database	are initialized	action	the empty relation	2351-4
A designated relational variable	holds	action	the output	2351-5
the output	to	constraint	the program	2351-5
the program	at	constraint	the end	2351-5
the end	of	constraint	the computation	2351-5
The image	or	conjunctive	value	2351-6
value	of	constraint	program P	2351-6
program P	on	constraint	I	2351-6
I	denoted	action	P	2351-6
P		sequential	I	2351-6
I		sequential	the value	2351-6
the value	to	constraint	the designated variable	2351-6
the value	is finally assigned	action	the designated variable	2351-6
the designated variable	if	constraint	P	2351-6
P	on	constraint	I	2351-6
P	terminates	action	I	2351-6
I		sequential	P	2351-6
P		sequential	I	2351-6
I	is	attribute	otherwise undefined	2351-6
Example		sequential	14.1.1	2352-1
14.1.1		sequential	Transitive Closure	2352-1
<B>	while	constraint	program	2352-2
<B>	The following	action	program	2352-2
program	in	constraint	T	2352-2
program	computes	action	T	2352-2
T		sequential	AB	2352-2
AB		sequential	the transitive closure	2352-2
the transitive closure	of	constraint	G	2352-2
T	=	sequential	G	2353-1
G	while	constraint	change	2353-1
change	do begin	action	T	2353-1
T	=	sequential	T ∪ πAB	2353-1
T ∪ πAB		sequential	δ B→C	2353-1
δ B→C		sequential	T	2353-1
T		sequential	δ A→C	2353-1
δ A→C		sequential	G	2353-1
G		sequential	end	2353-1
Recursion	and	conjunctive	Negation Example 14.1.2	2354-1
Negation Example 14.1.2		sequential	Add Remove	2354-1
Each loop	of	constraint	the following program	2354-2
<B>	while	constraint	some change	2355-1
<B>	is iterated	action	some change	2355-1
some change	occurs	action	<B>	2355-1
The result	into	constraint	the binary relation T	2355-2
The result	is placed	action	the binary relation T	2355-2
<B>	In	constraint	addition	2356-1
addition		sequential	the binary relation variables	2356-1
the binary relation variables		sequential	ToAdd	2356-1
ToAdd	and	conjunctive	ToRemove	2356-1
ToRemove	as	constraint	scratch paper	2356-1
ToRemove	are used	action	scratch paper	2356-1
scratch paper	For	constraint	the sake	2356-1
the sake	of	constraint	readability	2356-1
readability		sequential	we	2356-1
we	use	action	the calculus	2356-1
the calculus	with	constraint	active domain semantics	2356-1
active domain semantics	to	constraint	the corresponding algebra expression	2356-1
active domain semantics	than	constraint	the corresponding algebra expression	2356-1
active domain semantics	is	attribute	whenever easier	2356-1
active domain semantics	understand	action	the corresponding algebra expression	2356-1
T	=	sequential	G	2357-1
G	while	constraint	change	2357-1
change	do begin	action	ToRemove	2357-1
ToRemove	=	sequential	x	2357-1
x		sequential	y	2357-1
y		sequential	∃z	2357-1
∃z		sequential	T	2357-1
T		sequential	x	2357-1
x		sequential	z	2357-1
z		sequential	∧ T	2357-1
∧ T		sequential	z	2357-1
z		sequential	y	2357-1
y		sequential	}	2357-1
}		sequential	ToAdd	2357-1
ToAdd	=	sequential	x	2357-1
x		sequential	y	2357-1
y		sequential	∃z	2357-1
∃z		sequential	¬T	2357-1
¬T		sequential	x	2357-1
x		sequential	z	2357-1
z		sequential	¬T	2357-1
¬T		sequential	z	2357-1
z	x	sequential	∧	2357-1
∧		sequential	¬T	2357-1
¬T		sequential	y	2357-1
y		sequential	z	2357-1
z		sequential	¬T	2357-1
¬T		sequential	z	2357-1
z		sequential	y	2357-1
y		sequential	}	2357-1
}		sequential	T	2357-1
T	=	sequential	T ∪ ToAdd	2357-1
T ∪ ToAdd		sequential	ToRemove	2357-1
ToRemove		sequential	end	2357-1
<B>	is	attribute	not the case	2357-2
not the case	for	constraint	Add Remove	2357-2
Add Remove		sequential	the query	2357-2
<B>	Try	action	the graph	2357-3
the graph		sequential	b	2357-3
b		sequential	b	2357-3
b		sequential	a	2357-3
a		sequential	b	2357-3
b		sequential	b	2357-3
b		sequential	}	2357-3
The halting problem	for	constraint	programs	2357-4
The halting problem	while	constraint	programs	2357-4
programs	is	attribute	undecidable	2357-4
there	is	attribute	no algorithm	2357-4
no algorithm		sequential	that	2357-4
that	given	action	a while program	2357-4
a while program		sequential	P	2357-4
P	whether	constraint	P	2357-4
P	decides	action	P	2357-4
P	on	constraint	each input	2357-4
P	halts	action	each input	2357-4
each input	see	action	Exercise 14.2	2357-4
<B>	that	constraint	a pair	2357-5
<B>	for	constraint	a pair	2357-5
<B>	Observe	action	a pair	2357-5
a pair		sequential	P	2357-5
P		sequential	I	2357-5
I		sequential	one	2357-5
one	whether	constraint	P	2357-5
one	can decide	action	P	2357-5
P	on	constraint	input	2357-5
P	halts	action	input	2357-5
input		sequential	I	2357-5
I	because	constraint	computations	2357-5
I	as	constraint	computations	2357-5
I	while	constraint	computations	2357-5
I	argued earlier	action	computations	2357-5
computations	in	constraint	pspace	2357-5
computations	are	attribute	pspace	2357-5
Inflationary Semantics		sequential	Inflationary Semantics	2358-1
The while	+	sequential	language	2358-2
language	with	constraint	the semantics	2358-2
language	while	constraint	the semantics	2358-2
language	in	constraint	the semantics	2358-2
language	differs	action	the semantics	2358-2
the semantics	of	constraint	the assignment statement	2358-2
<B>	In	constraint	assignment	2358-3
<B>	in	constraint	assignment	2358-3
<B>	while	constraint	assignment	2358-3
<B>	+	sequential	assignment	2358-3
assignment	is	attribute	cumulative	2358-3
Execution	of	constraint	the statement	2358-3
the statement	assigning	action	E	2358-3
E	to	constraint	R	2358-3
R	in	constraint	the result	2358-3
R	results	action	the result	2358-3
R	adding	action	the result	2358-3
the result	of	constraint	E	2358-3
E	to	constraint	the old value	2358-3
the old value	of	constraint	R	2358-3
<B>	To	constraint	the cumulative semantics	2358-4
<B>	distinguish	action	the cumulative semantics	2358-4
the cumulative semantics	from	constraint	the destructive one	2358-4
the destructive one		sequential	we	2358-4
we	use	action	the notation P	2358-4
the notation P	+=	sequential	e	2358-4
e	for	constraint	the cumulative semantics	2358-4
Example		sequential	14.1.3	2359-1
14.1.3		sequential	Transitive Closure Revisited	2359-1
The result	in	constraint	the variable T	2359-2
The result	is obtained	action	the variable T	2359-2
the variable T		sequential	AB	2359-2
T	+=	sequential	G	2360-1
G	while	constraint	change	2360-1
change	do begin	action	T	2360-1
T	+=	sequential	πAB	2360-1
πAB		sequential	δ	2360-1
δ		sequential	B→C	2360-1
B→C		sequential	T	2360-1
T		sequential	δ A→C	2360-1
δ A→C		sequential	G	2360-1
G		sequential	end	2360-1
The only difference	that	constraint	assignment	2360-2
The only difference	because	constraint	assignment	2360-2
The only difference	is	attribute	assignment	2360-2
assignment	is	attribute	cumulative	2360-2
it	to	constraint	the content	2360-2
it	is	attribute	not necessary	2360-2
it	add	action	the content	2360-2
the content	of	constraint	T	2360-2
T	to	constraint	the result	2360-2
the result	of	constraint	the projection	2360-2
<B>	To	constraint	this section	2361-1
<B>	conclude	action	this section	2361-1
this section		sequential	we	2361-1
we	consider	action	alternatives	2361-1
alternatives	for	constraint	the control condition	2361-1
the control condition	of	constraint	loops	2361-1
<B>	Until	constraint	we	2362-1
we	based	action	termination	2362-1
termination	on	constraint	a stable state	2362-1
termination	reaching	action	a stable state	2362-1
It	to	constraint	explicit terminating conditions	2362-2
It	is	attribute	also common	2362-2
It	use	action	explicit terminating conditions	2362-2
explicit terminating conditions		sequential	tests	2362-2
tests	for	constraint	emptiness	2362-2
emptiness	of	constraint	the form E	2362-2
the form E	=	sequential	∅	2362-2
∅		sequential	E	2362-2
E	=	sequential	∅	2362-2
∅	or	conjunctive	E	2362-2
E	=	sequential	E′	2362-2
E′		sequential	E	2362-2
E		sequential	E′	2362-2
E′	are	attribute	relational algebra expressions	2362-2
The body	of	constraint	the loop	2362-3
the loop	as	constraint	the condition	2362-3
the loop	is executed	action	the condition	2362-3
the condition	is	attribute	satisfied	2362-3
The following example	shows	action	transitive closure	2362-4
transitive closure	how is computed	action	explicit looping conditions	2362-4
transitive closure	using	action	explicit looping conditions	2362-4
Example		sequential	14.1.4	2363-1
T	+=	sequential	G	2364-1
G	while	constraint	T	2364-1
T		sequential	old T	2364-1
old T	=	sequential	old T += T	2364-1
old T	do begin	action	old T += T	2364-1
old T += T		sequential	T	2364-1
T	+=	sequential	πAB	2364-1
πAB		sequential	δ B→C	2364-1
δ B→C		sequential	T	2364-1
T		sequential	δ A→C	2364-1
δ A→C		sequential	G	2364-1
G		sequential	end	2364-1
The computation	ends	action	old T	2364-2
old T	and	conjunctive	T	2364-2
T	when coincide	action	which	2364-2
which	that	constraint	no new edges	2364-2
which	means	action	no new edges	2364-2
no new edges	in	constraint	the current iteration	2364-2
no new edges	were added	action	the current iteration	2364-2
the current iteration		sequential	T	2364-2
T	so now holds	action	the transitive closure	2364-2
the transitive closure	of	constraint	G	2364-2
It	that	constraint	the use	2365-1
It	is easily shown	action	the use	2365-1
the use	of	constraint	such termination conditions	2365-1
such termination conditions	does not modify	action	the expressive power	2365-1
the expressive power	of	constraint	while	2365-1
while	and	conjunctive	the use	2365-1
the use	of	constraint	conditions	2365-1
conditions		sequential	E E′	2365-1
E E′	does not modify	action	the expressive power	2365-1
the expressive power	of	constraint	Exercise 14.5	2365-1
the expressive power	while	constraint	Exercise 14.5	2365-1
the expressive power	+	sequential	Exercise 14.5	2365-1
the expressive power	see	action	Exercise 14.5	2365-1
<B>	In	constraint	Section 14.4	2366-1
Section 14.4		sequential	we	2366-1
we	that	constraint	nesting in	2366-1
we	shall see	action	nesting in	2366-1
nesting in	of	constraint	loops	2366-1
loops	while	constraint	queries	2366-1
queries	does not increase	action	expressive power	2366-1
Calculus		sequential	Calculus	2367-1
<B>	could be done	action	assignment statements	2367-2
<B>	using	action	assignment statements	2367-2
assignment statements	while	constraint	loops	2367-2
assignment statements	and	conjunctive	loops	2367-2
loops	as	constraint	the algebra	2367-2
loops	for	constraint	the algebra	2367-2
we	Indeed used	action	calculus notation	2367-3
calculus notation	in	constraint	Example 14.1.2	2367-3
Example 14.1.2		sequential	Add- Remove	2367-3
we	but	conjunctive	an construct	2367-4
we	Instead use	attribute	equivalent	2367-4
we	more logic oriented	action	an construct	2367-4
an construct	to	constraint	the calculus	2367-4
an construct	augment	action	the calculus	2367-4
The construct	called	action	a fixpoint operator	2367-5
a fixpoint operator	allows	action	the iteration	2367-5
the iteration	of	constraint	calculus formulas	2367-5
calculus formulas	up to	constraint	a fixpoint	2367-5
<B>	In	constraint	effect	2367-6
effect	allows	action	relations	2367-6
effect	defining	action	relations	2367-6
relations	inductively using	action	calculus formulas	2367-6
<B>	For	constraint	the remainder	2368-1
the remainder	of	constraint	this chapter	2368-1
this chapter	as	constraint	a notational convenience	2368-1
a notational convenience		sequential	we	2368-1
we	use	action	active domain semantics	2368-1
active domain semantics	for	constraint	calculus queries	2368-1
<B>	In	constraint	addition	2368-2
addition		sequential	we	2368-2
we	often use	action	a formula	2368-2
a formula		sequential	x1	2368-2
<B>	.	sequential	<B>	2368-3
<B>	.	sequential	<B>	2368-4
xn	as	constraint	an abbreviation	2368-5
an abbreviation	for	constraint	the query	2368-5
the query		sequential	x1	2368-5
<B>	.	sequential	<B>	2368-6
<B>	.	sequential	<B>	2368-7
xn		sequential	x1	2368-8
<B>	.	sequential	<B>	2368-9
<B>	.	sequential	<B>	2368-10
xn		sequential	}	2368-11
These two simplifications	do not affect	action	the results	2368-12
the results	developed	action	<B>	2368-12
Recursion	and	conjunctive	Negation	2369-1
Negation		sequential	Partial Fixpoints	2369-1
It	in	constraint	the following example	2369-2
It	is illustrated	action	the following example	2369-2
Example		sequential	14.2.1	2370-1
14.2.1		sequential	Transitive Closure Revisited	2370-1
<B>	ϕ	sequential	Jn−1	2371-1
Jn−1	Here denotes	action	the result	2371-1
the result	of	constraint	T	2371-1
the result	evaluating	action	T	2371-1
T		sequential	the value	2371-1
the value	of	constraint	T	2371-1
T	is	attribute	when Jn−1	2371-1
<B>	that	constraint	each input G	2371-2
<B>	for	constraint	each input G	2371-2
<B>	Note	action	each input G	2371-2
each input G		sequential	the sequence	2371-2
<B>	is	attribute	there	2371-3
there	exists	action	some k	2371-3
some k	for	constraint	which	2371-3
which		sequential	Jk	2371-3
Jk	=	sequential	<B>	2371-3
Jk	Clearly holds	action	the transitive closure	2371-4
the transitive closure	of	constraint	the graph	2371-4
the transitive closure	of	constraint	G	2371-5
G	as	constraint	the limit	2371-5
G	Thus can be defined	action	the limit	2371-5
the limit	of	constraint	the foregoing sequence	2371-5
<B>	that	constraint	Jk	2371-6
<B>	Note	action	Jk	2371-6
Jk	=	sequential	ϕ	2371-6
ϕ		sequential	Jk	2371-6
Jk		sequential	Jk	2371-6
Jk	is	attribute	so also a fixpoint	2371-6
so also a fixpoint	of	constraint	ϕ	2371-6
ϕ		sequential	T	2371-6
The relation		sequential	Jk	2371-7
Jk	by	constraint	µT	2371-7
Jk	thereby obtained	action	µT	2371-7
Jk	is denoted	action	µT	2371-7
µT		sequential	ϕ	2371-7
ϕ		sequential	T	2371-7
the transitive closure	of	constraint	G	2371-8
G	by	constraint	<B>	2371-8
G	Then is defined	action	<B>	2371-8
<B>	By	constraint	definition	2372-1
definition		sequential	µ T	2372-1
µ T	is	attribute	an operator	2372-1
an operator		sequential	that	2372-1
that	produces	action	a new relation	2372-1
a new relation		sequential	the fixpoint Jk	2372-1
the fixpoint Jk	to	constraint	T	2372-1
the fixpoint Jk	when applied	action	T	2372-1
<B>	that	constraint	T	2372-2
<B>	although	constraint	T	2372-2
<B>	Note	action	T	2372-2
T	in	constraint	T	2372-2
T	is used	action	T	2372-2
T		sequential	T	2372-2
T	is	attribute	not a database relation	2372-2
not a database relation	but	conjunctive	rather a relation	2372-2
rather a relation	to	constraint	inductively µT	2372-2
rather a relation	used	action	inductively µT	2372-2
rather a relation	define	action	inductively µT	2372-2
inductively µT		sequential	ϕ	2372-2
ϕ		sequential	T	2372-2
T	from	constraint	the database	2372-2
the database	with	constraint	T	2372-2
the database	starting	action	T	2372-2
T	=	sequential	<B>	2372-2
T	∅	sequential	<B>	2372-2
T	to	constraint	µT	2372-3
T	to	constraint	µT	2372-3
T	is said	action	µT	2372-3
T	be bound	action	µT	2372-3
µT	to	constraint	a quantifier	2372-4
µT	is	attribute	Indeed somewhat similar	2372-4
a quantifier	over	constraint	relations	2372-4
<B>	that	constraint	the scope	2372-5
<B>	Note	action	the scope	2372-5
the scope	of	constraint	the free variables	2372-5
the free variables	of	constraint	T	2372-5
T	to	constraint	T	2372-5
T	is restricted	action	T	2372-5
T	by	constraint	the operator µT	2372-5
<B>	In	constraint	the preceding example	2373-1
the preceding example		sequential	the limit	2373-1
the limit	of	constraint	the sequence	2373-1
<B>	is	attribute	not always the case	2373-2
not always the case		sequential	the possibility	2373-2
the possibility	of	constraint	nontermination	2373-2
nontermination	and	conjunctive	Exercise 14.4	2373-2
nontermination	is illustrated next	action	Exercise 14.4	2373-2
Exercise 14.4	considers	action	cases	2373-2
cases	in	constraint	which	2373-2
which		sequential	a nonminimal fixpoint	2373-2
a nonminimal fixpoint	is reached	action	<B>	2373-2
Example 14.2.2 Consider		sequential	Example 14.2.2 Consider	2374-1
<B>	In	constraint	this case	2375-1
this case		sequential	the sequence	2375-1
the sequence		sequential	Jn	2375-1
Jn		sequential	n≥0	2375-1
n≥0	{	sequential	0	2375-1
n≥0	is	attribute	0	2375-1
0	{	sequential	1	2375-1
1		sequential	}	2375-1
}	{	sequential	0	2375-1
0		sequential	}	2375-1
<B>	.	sequential	<B>	2375-2
<B>	.	sequential	<B>	2375-3
<B>		sequential	T	2375-4
T		sequential	flip flops	2375-4
flip flops	between	constraint	zero	2375-4
zero	and	conjunctive	one	2375-4
the sequence	and	conjunctive	µT	2375-5
the sequence	Thus does not converge	action	µT	2375-5
µT		sequential	ϕ	2375-5
ϕ		sequential	T	2375-5
T	is not defined	action	<B>	2375-5
Situations	in	constraint	which	2375-6
which		sequential	µ	2375-6
µ	to	constraint	nonterminating computations	2375-6
µ	is	attribute	undefined	2375-6
µ	correspond	action	nonterminating computations	2375-6
nonterminating computations	in	constraint	the while language	2375-6
The following nonterminating	while	constraint	program	2376-1
program	to	constraint	µT	2376-1
program	corresponds	action	µT	2376-1
µT		sequential	ϕ	2376-1
ϕ		sequential	T	2376-1
T	=	sequential	0 }	2377-1
T	{	sequential	0 }	2377-1
0 }	while	constraint	change	2377-1
change	do begin	action	T	2377-1
T	=	sequential	0	2377-1
T	{	sequential	0	2377-1
0		sequential	1	2377-1
1	}	sequential	− T	2377-1
− T		sequential	end	2377-1
end	Because	constraint	µ	2377-1
µ	is only partially defined	action	it	2377-1
it	is called	action	the partial fixpoint operator	2377-1
We	now define	action	its syntax	2377-2
its syntax	and	conjunctive	semantics	2377-2
semantics	in	constraint	more detail	2377-2
Partial Fixpoint Operator		sequential	Partial Fixpoint Operator	2378-1
<B>	Let	action	ϕ	2378-2
ϕ		sequential	T	2378-2
T	be	attribute	a formula	2378-2
a formula	using	action	T	2378-2
T	and	conjunctive	relations	2378-2
relations	in	constraint	R	2378-2
R	with	constraint	m free variables	2378-2
<B>	Given	action	an instance	2378-3
an instance		sequential	I	2378-3
I	over	constraint	R	2378-3
R		sequential	µT	2378-3
µT		sequential	ϕ	2378-3
ϕ		sequential	T	2378-3
T	denotes	action	the relation	2378-3
the relation		sequential	that	2378-3
that	is	attribute	the limit	2378-3
the limit	if	constraint	it	2378-3
it	of	constraint	the sequence	2378-3
it	exists	action	the sequence	2378-3
The expression		sequential	µT	2379-1
µT		sequential	ϕ	2379-1
ϕ		sequential	T	2379-1
T	denotes	action	a new relation	2379-1
a new relation	if	constraint	it	2379-1
it	is defined	action	<B>	2379-1
<B>	In	constraint	turn	2379-2
turn		sequential	it	2379-2
it	in	constraint	more complex formulas	2379-2
it	can be used	action	more complex formulas	2379-2
more complex formulas	like	constraint	any other relation	2379-2
<B>	For	constraint	example	2379-3
example		sequential	µT	2379-3
µT		sequential	ϕ	2379-3
ϕ		sequential	T	2379-3
T		sequential	y	2379-3
y		sequential	z	2379-3
z	that	constraint	y	2379-3
z	states	action	y	2379-3
y		sequential	z	2379-3
z	in	constraint	µT	2379-3
z	is	attribute	µT	2379-3
µT		sequential	ϕ	2379-3
ϕ		sequential	T	2379-3
<B>	If	constraint	µT	2379-4
µT		sequential	ϕ T	2379-4
ϕ T	defines	action	the transitive closure	2379-4
the transitive closure	of	constraint	G	2379-4
G		sequential	the complement	2379-4
the complement	of	constraint	the transitive closure	2379-4
the transitive closure	by	constraint	<B>	2379-4
the transitive closure	is defined	action	<B>	2379-4
The extension	of	constraint	the calculus	2380-1
the calculus	with	constraint	µ	2380-1
µ	is called	action	partial fixpoint logic	2380-1
partial fixpoint logic	denoted	action	CALC +µ	2380-1
Partial Fixpoint Logic CALC	+	sequential	µ formulas	2381-1
µ formulas	by	constraint	repeated applications	2381-1
µ formulas	are obtained	action	repeated applications	2381-1
repeated applications	of	constraint	CALC operators	2381-1
CALC operators		sequential	∃	2381-1
∃		sequential	∀	2381-1
∀		sequential	∨	2381-1
∨		sequential	∧	2381-1
∧		sequential	¬	2381-1
¬	and	conjunctive	the partial fixpoint operator	2381-1
the partial fixpoint operator	from	constraint	atoms	2381-1
the partial fixpoint operator	starting	action	atoms	2381-1
<B>	In	constraint	µT	2381-2
µT		sequential	ϕ	2381-2
ϕ		sequential	T	2381-2
T		sequential	e1	2381-2
<B>	.	sequential	<B>	2381-3
<B>	.	sequential	<B>	2381-4
en		sequential	T	2381-5
T	where has	action	arity	2381-5
arity	n	conjunctive	T	2381-5
T	n	conjunctive	variables	2381-5
T	has	attribute	free	2381-5
variables	and	conjunctive	the ei	2381-5
the ei	are	attribute	variables	2381-5
variables	or	conjunctive	constants	2381-5
constants	is	attribute	a formula	2381-5
Its free variables	are	attribute	the variables	2381-6
the variables	in	constraint	the set	2381-6
the set		sequential	ξ	2381-6
ξ	is	attribute	CALC	2381-6
CALC	+	sequential	µ	2381-6
µ		sequential	where a formula	2381-6
where a formula		sequential	whose free variables	2381-6
whose free variables	in	constraint	e1	2381-6
whose free variables	are	attribute	those	2381-6
whose free variables	occurring	action	e1	2381-6
<B>	.	sequential	<B>	2381-7
<B>	.	sequential	<B>	2381-8
en		sequential	en	2381-9
The formula		sequential	ξ	2381-10
ξ	may use	action	relation names	2381-10
relation names	in	constraint	addition	2381-10
addition	to	constraint	R	2381-10
addition	in	constraint	R	2381-10
R		sequential	each occurrence P	2381-10
each occurrence P	of	constraint	such relation name	2381-10
such relation name	to	constraint	some partial fixpoint operator µ P	2381-10
such relation name	must be bound	action	some partial fixpoint operator µ P	2381-10
The semantics	of	constraint	CALC +µ queries	2381-11
CALC +µ queries	as	constraint	<B>	2381-11
CALC +µ queries	is defined	action	<B>	2381-11
CALC +µ queries	follows	action	<B>	2381-11
<B>	that	constraint	an instance	2381-12
<B>	First note	action	an instance	2381-12
<B>	given	action	an instance	2381-12
an instance		sequential	I	2381-12
I	over	constraint	R	2381-12
R	and	conjunctive	a sentence σ	2381-12
a sentence σ	in	constraint	CALC +µ	2381-12
CALC +µ		sequential	there	2381-12
there	are	attribute	three possibilities	2381-12
three possibilities		sequential	σ	2381-12
σ	on	constraint	I	2381-12
σ	is	attribute	undefined	2381-12
I		sequential	σ	2381-12
σ	on	constraint	I Recursion	2381-12
σ	is defined	action	I Recursion	2381-12
I Recursion	and	conjunctive	Negation	2381-12
Negation		sequential	q	2381-12
q	=	sequential	e1	2381-12
q	{	sequential	e1	2381-12
<B>	.	sequential	<B>	2381-13
<B>	.	sequential	<B>	2381-14
en		sequential	}	2381-15
}	if	constraint	the application	2381-15
}	is	attribute	undefined	2381-15
the application	of	constraint	some µ	2381-15
some µ	in	constraint	a subformula	2381-15
a subformula	is	attribute	undefined	2381-15
the answer	to	constraint	q	2381-16
q	is	attribute	Otherwise the n-ary relation	2381-16
Otherwise the n-ary relation	of	constraint	all valuations	2381-16
Otherwise the n-ary relation	consisting	action	all valuations	2381-16
all valuations		sequential	ν	2381-16
ν	of	constraint	e1	2381-16
<B>	.	sequential	<B>	2381-17
<B>	.	sequential	<B>	2381-18
en	for	constraint	which	2381-19
which		sequential	ξ	2381-19
ξ		sequential	ν	2381-19
ν		sequential	e1	2381-19
<B>	.	sequential	<B>	2381-20
<B>	.	sequential	<B>	2381-21
ν		sequential	en	2381-22
en	and	conjunctive	<B>	2381-22
en	is defined	attribute	true	2381-22
The queries	in	constraint	partial fixpoint logic	2381-23
partial fixpoint logic	are called	action	the partial fixpoint queries	2381-23
Example		sequential	14.2.3	2382-1
14.2.3		sequential	Add	2382-1
Add		sequential	Remove Revisited	2382-1
<B>	To	constraint	the initialization step	2383-1
<B>	distinguish	action	the initialization step	2383-1
the initialization step	from	constraint	the subsequent ones	2383-1
the subsequent ones		sequential	we	2383-1
we	use where	action	a ternary relation Q	2383-1
this query	than	constraint	its counterpart	2384-1
this query	is	attribute	Clearly more awkward	2384-1
its counterpart	in	constraint	while	2384-1
The simulation	highlights	action	some peculiarities	2384-2
some peculiarities	of	constraint	computing	2384-2
computing	with	constraint	CALC +µ	2384-2
<B>	In	constraint	Section 14.4	2385-1
Section 14.4		sequential	it	2385-1
it	that	constraint	the family	2385-1
it	is shown	action	the family	2385-1
the family	of	constraint	partial fixpoint queries	2385-1
partial fixpoint queries	to	constraint	the while queries	2385-1
partial fixpoint queries	is	attribute	equivalent	2385-1
<B>	In	constraint	the preceding definition	2385-2
the preceding definition	of	constraint	µT	2385-2
µT		sequential	ϕ	2385-2
ϕ		sequential	T	2385-2
T		sequential	the scope	2385-2
the scope	of	constraint	all free variables in	2385-2
all free variables in	by	constraint	µT	2385-2
all free variables in	is defined	action	µT	2385-2
<B>	For	constraint	example	2385-3
example	if	constraint	T	2385-3
T	in	constraint	T	2385-3
T	is	attribute	binary	2385-3
T	following	action	T	2385-3
T		sequential	x	2385-3
x		sequential	y	2385-3
y	the has	action	free variables	2385-3
free variables		sequential	x	2385-3
x		sequential	y	2385-3
<B>	According to	action	the definition	2385-4
the definition		sequential	y	2385-4
y	in	constraint	µT	2385-4
y	is	attribute	not free	2385-4
µT		sequential	ϕ	2385-4
ϕ		sequential	T	2385-4
T		sequential	x	2385-4
x		sequential	y	2385-4
y		sequential	z	2385-4
z		sequential	the free variables	2385-4
the free variables	are	attribute	z	2385-4
z		sequential	w	2385-4
the quantifier		sequential	∃y	2385-5
∃y	to	constraint	the y	2385-5
∃y	Hence applies alone	action	the y	2385-5
the y	in	constraint	P	2385-5
P		sequential	y	2385-5
y	and	conjunctive	no relation	2385-5
y	has	action	no relation	2385-5
no relation	to	constraint	the y	2385-5
the y	in	constraint	µT	2385-5
µT		sequential	ϕ	2385-5
ϕ		sequential	T	2385-5
T		sequential	x	2385-5
x		sequential	y	2385-5
y		sequential	z	2385-5
z		sequential	w	2385-5
<B>	To	constraint	confusion	2385-6
<B>	avoid	action	confusion	2385-6
confusion		sequential	it	2385-6
it	to	constraint	distinct variable names	2385-6
it	is	attribute	preferable	2385-6
it	use	action	distinct variable names	2385-6
distinct variable names	in	constraint	such cases	2385-6
<B>	For	constraint	instance	2385-7
instance		sequential	the preceding sentence	2385-7
the preceding sentence	can be rewritten as	action	<B>	2385-7
Simultaneous Induction	Consider	action	the following use	2386-1
the following use	of	constraint	nested partial fixpoint operators	2386-1
nested partial fixpoint operators		sequential	G	2386-1
G		sequential	P	2386-1
P	and	conjunctive	Q	2386-1
Q	are	attribute	where binary	2386-1
P		sequential	Q	2387-1
Q	both	conjunctive	P	2387-1
Q	Here involves	action	P	2387-1
P	and	conjunctive	Q	2387-1
<B>	to	constraint	a nested iteration	2387-2
<B>	corresponds	action	a nested iteration	2387-2
<B>	In	constraint	each iteration	2387-3
each iteration		sequential	i	2387-3
i	in	constraint	the computation	2387-3
the computation	of	constraint	Jn } n≥0	2387-3
Jn } n≥0	over	constraint	P	2387-3
P		sequential	the fixpoint µQ	2387-3
the fixpoint µQ		sequential	ϕ	2387-3
ϕ		sequential	P	2387-3
P		sequential	Q	2387-3
Q	for	constraint	the successive values	2387-3
Q	is recomputed	action	the successive values	2387-3
the successive values		sequential	Ji	2387-3
Ji	of	constraint	P	2387-3
<B>	In	constraint	contrast	2388-1
contrast		sequential	we	2388-1
we	now consider	action	a generalization	2388-1
a generalization	of	constraint	the partial fixpoint	2388-1
the partial fixpoint		sequential	that	2388-1
that	permits	action	simultaneous iteration	2388-1
simultaneous iteration	over	constraint	two relations	2388-1
simultaneous iteration	or	conjunctive	two relations	2388-1
<B>	For	constraint	example	2388-2
example	let	action	R	2388-2
R	be	attribute	a database schema	2388-2
a database schema	and	conjunctive	P	2388-2
P		sequential	Q	2388-2
Q	and	conjunctive	ψ	2388-2
ψ		sequential	P	2388-2
P		sequential	Q	2388-2
Q	be	attribute	calculus formulas	2388-2
calculus formulas	using	action	P	2388-2
P	and	conjunctive	Q	2388-2
Q	in	constraint	not R	2388-2
not R		sequential	the arity	2388-2
the arity	of	constraint	P	2388-2
P		sequential	respectively Q	2388-2
respectively Q	is	attribute	the number	2388-2
the number	of	constraint	free variables	2388-2
free variables	in	constraint	ψ	2388-2
free variables	ϕ	sequential	ψ	2388-2
<B>	On	constraint	input	2388-3
input		sequential	I	2388-3
I	over	constraint	R	2388-3
R		sequential	one	2388-3
one	can define inductively	action	the sequence	2388-3
Such a mutually recursive definition	of	constraint	Jn	2389-1
Jn		sequential	P	2389-1
P	and	conjunctive	Jn	2389-1
Jn		sequential	Q	2389-1
Q	to	constraint	simultaneous induction	2389-1
Q	as	constraint	simultaneous induction	2389-1
Q	is referred	action	simultaneous induction	2389-1
<B>	If	constraint	the sequence	2389-2
the sequence		sequential	Jn	2389-2
Jn		sequential	P	2389-2
P		sequential	Jn	2389-2
Jn		sequential	Q	2389-2
Q		sequential	n≥0	2389-2
n≥0	converges	action	the limit	2389-2
the limit	is	attribute	a fixpoint	2389-2
a fixpoint	of	constraint	the mapping	2389-2
the mapping	on	constraint	pairs	2389-2
pairs	of	constraint	relations	2389-2
relations	by	constraint	P	2389-2
relations	defined	action	P	2389-2
P		sequential	Q	2389-2
Q	and	conjunctive	ψ	2389-2
ψ		sequential	P	2389-2
P		sequential	Q	2389-2
This pair	of	constraint	values	2389-3
values	for	constraint	P	2389-3
P	and	conjunctive	Q	2389-3
Q	by	constraint	µP	2389-3
Q	is denoted	action	µP	2389-3
µP		sequential	Q	2389-3
Q		sequential	ϕ	2389-3
ϕ		sequential	P	2389-3
P		sequential	Q	2389-3
Q		sequential	ψ	2389-3
ψ		sequential	P	2389-3
P		sequential	Q	2389-3
Q	and	conjunctive	µP Q	2389-3
µP Q	is	attribute	a simultaneous induction partial fixpoint operator	2389-3
The value	for	constraint	P	2389-4
P	in	constraint	µP	2389-4
µP		sequential	Q	2389-4
Q	by	constraint	µP	2389-4
Q	is denoted	action	µP	2389-4
µP		sequential	Q	2389-4
Q		sequential	ϕ	2389-4
ϕ		sequential	P	2389-4
P		sequential	Q	2389-4
Q		sequential	ψ	2389-4
ψ		sequential	P	2389-4
P		sequential	Q	2389-4
Q		sequential	P	2389-4
P	and	conjunctive	the value	2389-4
the value	for	constraint	Q	2389-4
Q	by	constraint	µ P	2389-4
µ P		sequential	Q	2389-4
Q		sequential	ϕ	2389-4
ϕ		sequential	P	2389-4
P		sequential	Q	2389-4
Q		sequential	ψ	2389-4
ψ		sequential	P	2389-4
P		sequential	Q	2389-4
Q		sequential	Q	2389-4
simultaneous induction definitions	like	constraint	the foregoing	2389-5
the foregoing	for	constraint	any number	2389-5
the foregoing	Clearly can be extended	action	any number	2389-5
any number	of	constraint	relations	2389-5
Simultaneous induction	can simplify	action	certain queries	2389-6
certain queries	as	constraint	<B>	2389-6
certain queries	shown next	action	<B>	2389-6
Example		sequential	14.2.4	2390-1
14.2.4		sequential	Add Remove	2390-1
Add Remove	by	constraint	Simultaneous Induction	2390-1
Simultaneous Induction	Consider again	action	the query	2390-1
the query		sequential	Add Remove	2390-1
Add Remove	in	constraint	Example 14.2.3	2390-1
One	can simplify	action	the query	2390-2
the query	by	constraint	an auxiliary unary relation Off	2390-2
the query	introducing	action	an auxiliary unary relation Off	2390-2
an auxiliary unary relation Off		sequential	which	2390-2
which	inhibits	action	the transfer	2390-2
the transfer	of	constraint	G	2390-2
G	into	constraint	T	2390-2
T	after	constraint	the first step	2390-2
the first step	in	constraint	a direct fashion	2390-2
T	in	constraint	a mutually recursive fashion by	2390-3
T	and	conjunctive	a mutually recursive fashion by	2390-3
T	are defined	action	a mutually recursive fashion by	2390-3
The Add -Remove query	can now be written as	action	<B>	2391-1
It	that	constraint	simultaneous induction	2392-1
It	turns out	action	simultaneous induction	2392-1
It	using	action	simultaneous induction	2392-1
simultaneous induction		sequential	regular fixpoint operators	2392-1
regular fixpoint operators	does not provide	action	additional power	2392-1
<B>	For	constraint	example	2392-2
example		sequential	a CALC +µ formula	2392-2
a CALC +µ formula	to	constraint	the query	2392-2
the query	in	constraint	Example 14.2.4	2392-2
Example 14.2.4	is	attribute	the one	2392-2
the one	in	constraint	Example 14.2.3	2392-2
the one	shown	action	Example 14.2.3	2392-2
we	More generally have	action	the following Lemma 14.2.5	2392-3
<B>	.	sequential	<B>	2392-4
<B>	.	sequential	<B>	2392-5
Rn	be	attribute	CALC formulas	2392-6
CALC formulas		sequential	i	2392-6
i		sequential	1	2392-6
1		sequential	n	2392-6
n	that	constraint	µR	2392-6
<B>		sequential	i	2393-1
i		sequential	i	2393-1
i	of	constraint	variables	2393-1
variables	or	conjunctive	constants	2393-1
constants	for	constraint	i	2393-1
ei		sequential	ei	2394-1
Crux		sequential	Crux	2395-1
<B>	using	action	two relations	2395-2
two relations	Off	constraint	T	2395-2
two relations	and	conjunctive	T	2395-2
T		sequential	we	2395-2
we	use	action	a ternary relation Q	2395-2
a ternary relation Q		sequential	that	2395-2
that	Off	constraint	T	2395-2
that	both	conjunctive	T	2395-2
that	and	conjunctive	T	2395-2
that	encodes	action	T	2395-2
The extra coordinate	to	constraint	tuples	2395-3
The extra coordinate	between	constraint	tuples	2395-3
The extra coordinate	is used	action	tuples	2395-3
The extra coordinate	distinguish	action	tuples	2395-3
tuples	in	constraint	T	2395-3
T	and	conjunctive	tuples	2395-3
tuples	in	constraint	<B>	2395-3
<B>	that	constraint	the use	2396-1
<B>	Note	action	the use	2396-1
the use	of	constraint	the tuples	2396-1
ei	allows	action	one	2397-1
one	to	constraint	appropriate selections	2397-1
one	perform	action	appropriate selections	2397-1
appropriate selections	and	conjunctive	projections	2397-1
projections	on	constraint	µQ	2397-1
µQ		sequential	ϕ′	2397-1
ϕ′		sequential	Q	2397-1
Q	for	constraint	<B>	2397-1
Q	decoding	action	<B>	2397-1
These selections	and	conjunctive	projections	2397-2
projections	are	attribute	i	2397-2
i	and	conjunctive	Exercise 14.17 c	2397-2
i	can not be avoided	action	Exercise 14.17 c	2397-2
i	see	action	Exercise 14.17 c	2397-2
Inflationary Fixpoint		sequential	Inflationary Fixpoint	2398-1
The semantics	of	constraint	the partial fixpoint operator µ	2398-2
the partial fixpoint operator µ	because	constraint	the inductive definition	2398-2
the partial fixpoint operator µ	in	constraint	the inductive definition	2398-2
the partial fixpoint operator µ	is	attribute	essentially noninflationary	2398-2
the inductive definition	of	constraint	Jn	2398-2
Jn		sequential	each step	2398-2
each step	is	attribute	a destructive assignment	2398-2
<B>	As with	constraint	while	2398-3
while		sequential	we	2398-3
we	can make	action	the semantics	2398-3
the semantics	by	constraint	the assignment	2398-3
the semantics	having	action	the assignment	2398-3
the assignment	at	constraint	each step	2398-3
each step	of	constraint	the induction	2398-3
the induction	be	attribute	cumulative	2398-3
<B>	yields	action	an inflationary version	2398-4
an inflationary version	of	constraint	µ	2398-4
µ	by	constraint	µ+	2398-4
µ	denoted	action	µ+	2398-4
µ+	and	conjunctive	the inflationary fixpoint operator	2398-4
µ+	called	action	the inflationary fixpoint operator	2398-4
the inflationary fixpoint operator		sequential	which	2398-4
which	for	constraint	all formulas	2398-4
which	is defined	action	all formulas	2398-4
all formulas	and	conjunctive	databases	2398-4
databases	to	constraint	which	2398-4
which		sequential	it	2398-4
it	is applied	action	<B>	2398-4
Inflationary Fixpoint Operators	and	conjunctive	Logic	2399-1
This definition	that	constraint	the sequence	2400-1
This definition	ensures	action	the sequence	2400-1
<B>	Because	constraint	each instance	2401-1
<B>	for	constraint	each instance	2401-1
each instance		sequential	there	2401-1
there	are	attribute	finitely many tuples	2401-1
finitely many tuples		sequential	that	2401-1
that	can be added	action	the sequence	2401-1
the sequence	in	constraint	all cases	2401-1
the sequence	converges	action	all cases	2401-1
The set	of	constraint	queries	2402-1
queries	by	constraint	inflationary fixpoint logic	2402-1
queries	expressible	action	inflationary fixpoint logic	2402-1
inflationary fixpoint logic	is called	action	the fixpoint queries	2402-1
The fixpoint queries	among	constraint	the inflationary languages	2402-2
The fixpoint queries	were historically defined first	action	the inflationary languages	2402-2
the inflationary languages	in	constraint	logic	2402-2
logic	and	conjunctive	the paradigms	2402-2
the class	of	constraint	queries	2402-3
queries	in	constraint	inflationary languages	2402-3
inflationary languages	in	constraint	the three paradigms	2402-3
the three paradigms	to	constraint	the fixpoint queries	2402-3
the three paradigms	to	constraint	the fixpoint queries	2402-3
the three paradigms	as	constraint	the fixpoint queries	2402-3
the three paradigms	Therefore has come	action	the fixpoint queries	2402-3
the three paradigms	be referred	action	the fixpoint queries	2402-3
T	that	constraint	datalog	2403-1
T	Recall	action	datalog	2403-1
datalog	as	constraint	Chapter 12	2403-1
datalog	in	constraint	Chapter 12	2403-1
datalog	presented	action	Chapter 12	2403-1
Chapter 12	uses	action	an inflationary operator	2403-1
an inflationary operator	and	conjunctive	the minimal fixpoint	2403-1
an inflationary operator	yields	action	the minimal fixpoint	2403-1
the minimal fixpoint	of	constraint	a set	2403-1
a set	of	constraint	rules	2403-1
One	to	constraint	an inflationary simultaneous induction	2403-2
One	that	constraint	an inflationary simultaneous induction	2403-2
One	may also be tempted	action	an inflationary simultaneous induction	2403-2
One	assume	action	an inflationary simultaneous induction	2403-2
an inflationary simultaneous induction	of	constraint	the form µ+	2403-2
the form µ+		sequential	ϕ	2403-2
ϕ		sequential	P	2403-2
P		sequential	Q	2403-2
Q		sequential	ψ	2403-2
ψ		sequential	P	2403-2
P		sequential	Q	2403-2
Q	to	constraint	a system P	2403-2
Q	is	attribute	equivalent	2403-2
a system P		sequential	Q	2403-2
Q	of	constraint	equational definitions	2403-2
equational definitions	of	constraint	the form	2403-2
the form		sequential	P	2403-2
P	=	sequential	ϕ	2403-2
ϕ		sequential	P	2403-2
P		sequential	Q	2403-2
Q		sequential	Q	2403-2
Q	=	sequential	ψ	2403-2
ψ		sequential	P	2403-2
P		sequential	Q	2403-2
Example		sequential	14.2.6	2404-1
One	to	constraint	the fixpoint	2405-1
One	that	constraint	the fixpoint	2405-1
One	is tempted	action	the fixpoint	2405-1
One	believe	action	the fixpoint	2405-1
the fixpoint	of	constraint	these two equations	2405-1
these two equations	yields	action	the complement	2405-1
the complement	of	constraint	transitive closure	2405-1
<B>	with	constraint	the inflationary semantics	2405-2
the inflationary semantics		sequential	Recursion	2405-2
Recursion	and	conjunctive	Negation	2405-2
Negation		sequential	J0	2405-2
J0		sequential	T	2405-2
T	=	sequential	J0	2405-2
J0		sequential	CT	2405-2
CT	=	sequential	Jn	2405-2
CT	∅	sequential	Jn	2405-2
Jn		sequential	T	2405-2
T	=	sequential	Jn−1	2405-2
Jn−1		sequential	T	2405-2
T		sequential	∪	2405-2
∪		sequential	x	2405-2
x		sequential	y	2405-2
y	|	sequential	G	2405-2
G		sequential	x	2405-2
x		sequential	y ∨	2405-2
y ∨		sequential	Jn−1	2405-2
Jn−1		sequential	T	2405-2
T		sequential	x	2405-2
x		sequential	y	2405-2
y		sequential	Jn	2405-2
Jn		sequential	CT	2405-2
CT	=	sequential	Jn−1	2405-2
Jn−1		sequential	CT	2405-2
CT	{	sequential	x	2405-2
x		sequential	y	2405-2
y	¬	sequential	Jn−1	2405-2
Jn−1		sequential	T	2405-2
T		sequential	x	2405-2
x		sequential	y	2405-2
y	to	constraint	CT	2405-2
y	leads	action	CT	2405-2
y	saturating	action	CT	2405-2
CT	at	constraint	the first iteration	2405-2
<B>	and	conjunctive	Formulas	2406-1
An alternative approach	to	constraint	the formulas	2406-2
An alternative approach	is	attribute	the formulas	2406-2
An alternative approach	restrict	action	the formulas	2406-2
the formulas		sequential	T	2406-2
T		sequential	so that convergence	2406-2
so that convergence	of	constraint	the sequence	2406-2
One such restriction	is	attribute	monotonicity	2406-3
<B>	that	constraint	a query q	2406-4
<B>	Recall	action	a query q	2406-4
a query q	if	constraint	each I	2406-4
a query q	for	constraint	each I	2406-4
a query q	is	attribute	monotone	2406-4
each I		sequential	J	2406-4
J		sequential	I	2406-4
I	⊆	action	J q	2406-4
J q		sequential	I ⊆ q	2406-4
I ⊆ q		sequential	J	2406-4
One	that	constraint	such formulas	2406-5
One	for	constraint	such formulas	2406-5
One	can again show	action	such formulas	2406-5
such formulas		sequential	a least fixpoint	2406-5
a least fixpoint	that	constraint	it	2406-5
a least fixpoint	and	conjunctive	it	2406-5
a least fixpoint	always exists	action	it	2406-5
it	after	constraint	a number	2406-5
it	but	conjunctive	a number	2406-5
it	is obtained	attribute	finite	2406-5
a number	of	constraint	stages	2406-5
stages	of	constraint	inductive applications	2406-5
inductive applications	of	constraint	the formula	2406-5
monotonicity	is	attribute	Unfortunately an undecidable property	2407-1
Unfortunately an undecidable property	for	constraint	CALC	2407-1
One	can also restrict	action	the application	2407-2
the application	of	constraint	fixpoint	2407-2
fixpoint	to	constraint	positive formulas	2407-2
<B>	was	attribute	historically the first track	2407-3
historically the first track		sequential	that	2407-3
that	and	conjunctive	the advantage	2407-3
that	was followed	action	the advantage	2407-3
that	presents	action	the advantage	2407-3
the advantage		sequential	that positiveness	2407-3
that positiveness	is	attribute	syntactic	2407-3
It	by	constraint	T	2407-4
It	that	constraint	T	2407-4
It	is done	action	T	2407-4
It	requiring	action	T	2407-4
T	in	constraint	T	2407-4
T	occur only positively	action	T	2407-4
T	under	constraint	an even number	2407-4
an even number	of	constraint	negations	2407-4
negations	in	constraint	the syntax tree	2407-4
the syntax tree	of	constraint	the formula	2407-4
All formulas	and	conjunctive	µT	2407-5
All formulas	thereby obtained	attribute	monotone	2407-5
All formulas	are	attribute	monotone	2407-5
µT		sequential	ϕ	2407-5
ϕ		sequential	T	2407-5
T	so is always defined	action	Exercise 14.10	2407-5
T	see	action	Exercise 14.10	2407-5
It	that	constraint	the approach	2408-1
It	can be shown	action	the approach	2408-1
the approach	of	constraint	inflationary fixpoint	2408-1
inflationary fixpoint	and	conjunctive	the two approaches	2408-1
the two approaches	on	constraint	fixpoint	2408-1
the two approaches	based	action	fixpoint	2408-1
fixpoint	of	constraint	formulas	2408-1
fixpoint	or	conjunctive	formulas	2408-1
formulas	are	attribute	equivalent	2408-1
the sets	of	constraint	queries	2408-1
queries	expressed	attribute	identical	2408-1
queries	are	attribute	identical	2408-1
queries	see	action	Exercise 14.10	2408-1
Fixpoint Operators	and	conjunctive	Circumscription	2409-1
<B>	to	constraint	the technique	2409-2
<B>	is	attribute	somewhat similar	2409-2
<B>	well known	action	the technique	2409-2
the technique	of	constraint	circumscription	2409-2
circumscription	in	constraint	artificial intelligence	2409-2
circumscription	studied	action	artificial intelligence	2409-2
<B>	Suppose	action	ψ	2409-3
ψ		sequential	T	2409-3
T	is	attribute	a calculus sentence	2409-3
a calculus sentence		sequential	no free variables	2409-3
no free variables		sequential	that	2409-3
that	uses	action	T	2409-3
T	in	constraint	addition	2409-3
addition	to	constraint	relations	2409-3
relations	from	constraint	a database schema R.	2409-3
a database schema R.		sequential	The circumscription	2409-3
The circumscription	of	constraint	ψ	2409-3
ψ		sequential	T	2409-3
T	with	constraint	respect	2409-3
respect	to	constraint	T	2409-3
T	by	constraint	circ T	2409-3
T	denoted here	action	circ T	2409-3
circ T		sequential	ψ	2409-3
ψ		sequential	T	2409-3
T	of	constraint	an operator	2409-3
T	as	constraint	an operator	2409-3
T	can be thought	action	an operator	2409-3
an operator	defining	action	a new relation	2409-3
a new relation	from	constraint	the database	2409-3
a new relation	starting	action	the database	2409-3
<B>	let	action	I	2409-4
I	be	attribute	an instance	2409-4
an instance	over	constraint	R	2409-4
R		sequential	circ	2409-4
circ		sequential	T	2409-4
T		sequential	ψ	2409-4
ψ		sequential	T	2409-4
T	Then denotes	action	the relation	2409-4
the relation	containing	action	all tuples	2409-4
all tuples	to	constraint	every relation T	2409-4
all tuples	belonging	action	every relation T	2409-4
every relation T	that	constraint	ψ	2409-4
ψ		sequential	T	2409-4
T	for	constraint	I	2409-4
T	1 holds	action	I	2409-4
I	and	conjunctive	T	2409-4
T	under	constraint	set inclusion2	2409-4
T	is	attribute	2 minimal	2409-4
set inclusion2	with	constraint	this property	2409-4
<B>	Consider now	action	a fixpoint query	2409-5
<B>	As	constraint	fixpoint queries	2409-6
<B>	stated earlier	action	fixpoint queries	2409-6
fixpoint queries	can be expressed	action	just fixpoint operators	2409-6
fixpoint queries	using	action	just fixpoint operators	2409-6
just fixpoint operators	µ	constraint	T	2409-6
T	to	constraint	formulas	2409-6
T	applied	action	formulas	2409-6
formulas	in	constraint	T	2409-6
T		sequential	T	2409-6
T	in	constraint	an even number	2409-6
T	under	constraint	an even number	2409-6
T	ϕ	sequential	an even number	2409-6
T	always appears	action	an even number	2409-6
an even number	of	constraint	negations	2409-6
We	that	constraint	µT	2409-7
We	claim	action	µT	2409-7
µT		sequential	ϕ	2409-7
ϕ		sequential	T	2409-7
T	=	sequential	circ T	2409-7
circ T		sequential	ϕ′	2409-7
ϕ′		sequential	T	2409-7
T		sequential	ϕ′	2409-7
ϕ′		sequential	T	2409-7
T	is	attribute	where a sentence 2	2409-7
<B>	from	constraint	T	2410-1
<B>	obtained	action	T	2410-1
T	as	constraint	<B>	2410-1
T	follows	action	<B>	2410-1
Datalog	with	constraint	Negation Datalog	2411-1
Negation Datalog	provides	action	recursion	2411-1
recursion	but	conjunctive	no negation	2411-1
It	defines	action	only monotonic queries	2411-2
<B>	from	constraint	the standpoint	2411-3
<B>	Viewed	action	the standpoint	2411-3
the standpoint	of	constraint	the deductive paradigm	2411-3
the deductive paradigm		sequential	datalog	2411-3
datalog	provides	action	a form	2411-3
a form	of	constraint	monotonic reasoning	2411-3
<B>	Adding	action	negation	2411-4
negation	to	constraint	datalog rules	2411-4
datalog rules	permits	action	the specification	2411-4
the specification	of	constraint	nonmonotonic queries	2411-4
nonmonotonic queries	of	constraint	hence nonmonotonic reasoning	2411-4
nonmonotonic queries	and	conjunctive	hence nonmonotonic reasoning	2411-4
<B>	For	constraint	instance	2412-1
instance		sequential	the basic assumptions	2412-1
the basic assumptions	in	constraint	the reasoning process	2412-1
the reasoning process	that	constraint	a fact	2412-1
the reasoning process	once	constraint	a fact	2412-1
the reasoning process	may require	action	a fact	2412-1
a fact	at	constraint	some point	2412-1
a fact	is assumed	attribute	false	2412-1
some point	in	constraint	the inferencing process	2412-1
the inferencing process		sequential	it	2412-1
it	at	constraint	a later point	2412-1
it	should not be proven	attribute	true	2412-1
This idea	at	constraint	the core	2412-2
This idea	lies	action	the core	2412-2
the core	of	constraint	semantics	2412-2
the core	and	conjunctive	semantics	2412-2
the core	stratified	action	semantics	2412-2
the core	well founded	action	semantics	2412-2
semantics		sequential	two	2412-2
two	of	constraint	the deductive framework	2412-2
two	in	constraint	the deductive framework	2412-2
two	the most widely accepted	action	the deductive framework	2412-2
The deductive point	of	constraint	view	2412-3
view	in	constraint	depth	2412-3
view	is considered	action	depth	2412-3
depth	in	constraint	Chapter 15	2412-3
The semantics	for	constraint	datalog	2413-1
The semantics	given here	action	datalog	2413-1
datalog	with	constraint	negation	2413-1
negation	follows	action	the semantics	2413-1
the semantics	in	constraint	Chapter 12	2413-1
the semantics	given	action	Chapter 12	2413-1
Chapter 12	for	constraint	datalog	2413-1
datalog	to	constraint	the semantics	2413-1
datalog	but	conjunctive	the semantics	2413-1
datalog	does not correspond directly	action	the semantics	2413-1
the semantics	for	constraint	nonrecursive datalog¬	2413-1
nonrecursive datalog¬	in	constraint	Chapter 5	2413-1
nonrecursive datalog¬	given	action	Chapter 5	2413-1
The semantics	in	constraint	Chapter 5	2413-2
Chapter 5	by	constraint	the stratified semantics	2413-2
Chapter 5	is inspired	action	the stratified semantics	2413-2
the stratified semantics	by	constraint	the semantics	2413-2
the stratified semantics	of	constraint	the semantics	2413-2
the stratified semantics	but	conjunctive	the semantics	2413-2
the stratified semantics	either	conjunctive	the semantics	2413-2
the stratified semantics	can be simulated	action	the semantics	2413-2
the semantics	in	constraint	this chapter	2413-2
the semantics	presented	action	this chapter	2413-2
Inflationary Semantics		sequential	Inflationary Semantics	2414-1
Like datalog		sequential	its rules	2415-1
its rules	to	constraint	a set	2415-1
its rules	are used	action	a set	2415-1
its rules	infer	action	a set	2415-1
a set	of	constraint	facts	2415-1
<B>	Once	constraint	a fact	2415-2
a fact	is inferred	action	it	2415-2
it	from	constraint	the set	2415-2
it	is never removed	action	the set	2415-2
the set	of	constraint	true facts	2415-2
<B>	yields	action	the inflationary character	2415-3
the inflationary character	of	constraint	the language	2415-3
Example		sequential	14.3.1	2416-1
T		sequential	x	2417-1
x		sequential	y	2417-1
y		sequential	T	2417-1
T		sequential	x	2417-1
x		sequential	y	2417-1
y		sequential	x	2417-1
x		sequential	y	2417-1
y		sequential	x′	2417-1
x′		sequential	y′	2417-1
y′		sequential	T	2417-1
T		sequential	x	2417-1
x		sequential	y	2417-1
y		sequential	¬T	2417-1
¬T		sequential	x′	2417-1
x′		sequential	y′	2417-1
The rules	with	constraint	all applicable valuations	2417-2
The rules	are fired simultaneously	action	all applicable valuations	2417-2
<B>	At	constraint	each such firing	2417-3
each such firing		sequential	some facts	2417-3
some facts	are inferred	action	<B>	2417-3
<B>	until	constraint	no new facts	2417-4
<B>	is repeated	action	no new facts	2417-4
no new facts	can be inferred	action	<B>	2417-4
A negative fact		sequential	¬T	2417-5
¬T		sequential	x′	2417-5
x′		sequential	y′	2417-5
y′	if	constraint	T	2417-5
y′	is	attribute	true	2417-5
T		sequential	x′	2417-5
x′		sequential	y′	2417-5
y′	has not been inferred so far	action	<B>	2417-5
<B>	does not preclude	action	T	2417-6
T		sequential	x′	2417-6
x′		sequential	y′	2417-6
y′	from	constraint	a later firing	2417-6
y′	at	constraint	a later firing	2417-6
y′	being inferred	action	a later firing	2417-6
a later firing	of	constraint	the rules	2417-6
One firing	of	constraint	the rules	2418-1
the rules	is called	action	a stage	2418-1
a stage	in	constraint	the evaluation	2418-1
the evaluation	of	constraint	the program	2418-1
<B>	In	constraint	the preceding program	2418-2
the preceding program		sequential	the transitive closure	2418-2
the transitive closure	of	constraint	G	2418-2
G	in	constraint	T	2418-2
G	is computed	action	T	2418-2
<B>	Consider	action	the consecutive stages	2418-3
the consecutive stages	in	constraint	the evaluation	2418-3
the evaluation	of	constraint	the program	2418-3
<B>	that	constraint	the fact	2418-4
<B>	if	constraint	the fact	2418-4
<B>	Note	action	the fact	2418-4
the fact		sequential	T	2418-4
T		sequential	x	2418-4
x		sequential	y	2418-4
y	at	constraint	stage	2418-4
y	is inferred	action	stage	2418-4
stage	n	conjunctive	d	2418-4
d		sequential	x	2418-4
x		sequential	y	2418-4
y	= n	sequential	<B>	2418-4
<B>	if	constraint	T	2418-5
T		sequential	x	2418-5
x		sequential	y	2418-5
y	and	conjunctive	¬T	2418-5
¬T		sequential	x′	2418-5
x′		sequential	y′	2418-5
y′	at	constraint	some stage	2418-5
y′	Thus hold	action	some stage	2418-5
some stage	n	conjunctive	d	2418-5
d		sequential	x	2418-5
x		sequential	y	2418-5
y	≤	conjunctive	d	2418-5
y	n	conjunctive	d	2418-5
y	and	conjunctive	d	2418-5
d		sequential	x′	2418-5
x′		sequential	y′	2418-5
y′	n	conjunctive	x	2418-5
y′	and	conjunctive	x	2418-5
x		sequential	y′	2418-5
y′	is inferred	action	<B>	2418-5
The formal syntax	and	conjunctive	semantics	2419-1
semantics	of	constraint	datalog¬	2419-1
datalog¬	are	attribute	straightforward extensions	2419-1
straightforward extensions	of	constraint	datalog	2419-1
straightforward extensions	for	constraint	datalog	2419-1
A datalog¬ rule	is	attribute	an expression	2419-2
an expression	of	constraint	the form	2419-2
the form		sequential	A	2419-2
A	is	attribute	where an atom	2419-2
where an atom	and	conjunctive	each Li	2419-2
each Li	either	conjunctive	an atom Bi	2419-2
each Li	is	attribute	an atom Bi	2419-2
an atom Bi	in	constraint	which	2419-2
which		sequential	case	2419-2
case		sequential	it	2419-2
it	or	conjunctive	a negated atom ¬ Bi	2419-2
it	is called	attribute	positive	2419-2
a negated atom ¬ Bi	in	constraint	which	2419-2
which		sequential	case	2419-2
case		sequential	it	2419-2
it	is called	attribute	negative	2419-2
<B>	In	constraint	this chapter	2419-3
this chapter		sequential	we	2419-3
we	use	action	an active domain semantics	2419-3
an active domain semantics	for	constraint	datalog¬	2419-3
an active domain semantics	evaluating	action	datalog¬	2419-3
datalog¬	that	constraint	the rules	2419-3
datalog¬	and	conjunctive	the rules	2419-3
datalog¬	so do not require	action	the rules	2419-3
the rules		sequential	range	2419-3
range	be restricted	action	Exercise 14.13	2419-3
range	see	action	Exercise 14.13	2419-3
The semantics	of	constraint	datalog¬	2420-1
datalog¬		sequential	that	2420-1
that		sequential	we	2420-1
we	in	constraint	this chapter	2420-1
we	present	action	this chapter	2420-1
this chapter	is	attribute	an extension	2420-1
an extension	of	constraint	the fixpoint semantics	2420-1
the fixpoint semantics	of	constraint	datalog	2420-1
<B>	Let	action	K	2420-2
K	be	attribute	an instance	2420-2
an instance	over	constraint	sch	2420-2
sch		sequential	P	2420-2
<B>	that	constraint	active domain	2420-3
<B>	Recall	action	active domain	2420-3
active domain		sequential	an instantiation	2420-3
an instantiation	of	constraint	a rule	2420-3
a rule		sequential	A	2420-3
A	←	sequential	L1	2420-3
<B>	.	sequential	<B>	2420-4
<B>	.	sequential	<B>	2420-5
Ln	is	attribute	a rule	2420-6
a rule		sequential	ν	2420-6
ν		sequential	A	2420-6
A		sequential	ν	2420-6
ν		sequential	L1	2420-6
<B>	.	sequential	<B>	2420-7
<B>	.	sequential	<B>	2420-8
ν		sequential	Ln	2420-9
Ln		sequential	ν	2420-9
ν	is	attribute	where a valuation	2420-9
where a valuation		sequential	that	2420-9
that	into	constraint	adom	2420-9
that	maps	attribute	each variable	2420-9
adom		sequential	P	2420-9
P		sequential	K	2420-9
A fact		sequential	A′	2420-10
A′	is	attribute	an immediate consequence	2420-10
an immediate consequence	for	constraint	K	2420-10
K	and	conjunctive	P	2420-10
P	if	constraint	A′ ∈ K	2420-10
A′ ∈ K		sequential	R	2420-10
R	for	constraint	some edb relation R	2420-10
some edb relation R	or	conjunctive	A′	2420-10
A′	←	sequential	L′	2420-10
<B>	.	sequential	<B>	2420-11
<B>	.	sequential	<B>	2420-12
L′	is	attribute	an instantiation	2420-13
an instantiation		sequential	1 n	2420-13
1 n	of	constraint	a rule	2420-13
a rule	in	constraint	P	2420-13
P	and	conjunctive	each positive L′	2420-13
each positive L′	is	attribute	a fact	2420-13
a fact	in	constraint	K	2420-13
K	for	constraint	L′	2420-13
K	and	conjunctive	L′	2420-13
L′	=	sequential	A′	2420-13
A′		sequential	A′	2420-13
A′		sequential	∈	2420-13
∈		sequential	i	2420-13
i		sequential	i	2420-13
i		sequential	i	2420-13
i		sequential	i K	2420-13
<B>	For	constraint	each K	2420-14
each K	over	constraint	sch	2420-14
sch		sequential	P	2420-14
<B>	Given	action	an instance	2421-1
an instance		sequential	I	2421-1
I		sequential	edb	2421-1
edb		sequential	P	2421-1
P		sequential	one	2421-1
one	can compute	action	ŴP	2421-1
ŴP		sequential	I	2421-1
I		sequential	Ŵ2	2421-1
Ŵ2		sequential	I	2421-1
I		sequential	Ŵ3	2421-1
Ŵ3		sequential	I	2421-1
I		sequential	<B>	2421-1
<B>	As	constraint	P P	2421-2
<B>	suggested	action	P P	2421-2
P P	in	constraint	Example 14.3.1	2421-2
Example 14.3.1		sequential	each application	2421-2
each application	of	constraint	ŴP	2421-2
ŴP	is called	action	a stage	2421-2
a stage	in	constraint	the evaluation	2421-2
<B>	From	constraint	the definition	2421-3
the definition	of	constraint	ŴP	2421-3
ŴP		sequential	it	2421-3
it	follows	attribute	that	2421-3
P steps		sequential	P steps	2422-1
The restriction	of	constraint	the idb relations	2422-2
The restriction	to	constraint	the idb relations	2422-2
the idb relations	or	conjunctive	some subset thereof	2422-2
some subset thereof	is called	action	the image	2422-2
the image	or	conjunctive	answer	2422-2
answer	of	constraint	P	2422-2
P	on	constraint	I	2422-2
minimal model	of	constraint	P	2423-1
P	containing	action	I	2423-1
I	as	constraint	<B>	2423-1
I	illustrated next	action	<B>	2423-1
Example		sequential	14.3.2	2424-1
<B>	Let	action	I	2425-1
I		sequential	Q	2425-1
Q		sequential	0	2425-1
0		sequential	}	2425-1
P		sequential	I	2425-2
I	Then =	sequential	Q	2425-2
I	{	sequential	Q	2425-2
Q		sequential	0	2425-2
0		sequential	R	2425-2
R		sequential	0	2425-2
0		sequential	R }	2425-2
R }		sequential	1	2425-2
<B>	Although	constraint	P I	2425-3
P I	is	attribute	a model	2425-3
a model	of	constraint	P	2425-3
P		sequential	it	2425-3
it	is	attribute	not minimal	2425-3
The minimal models	containing	action	I	2425-4
I	are	attribute	Q	2425-4
Q		sequential	0	2425-4
0		sequential	R	2425-4
R		sequential	0	2425-4
0		sequential	}	2425-4
}	and	conjunctive	Q	2425-4
Q		sequential	0	2425-4
0		sequential	R	2425-4
R		sequential	1	2425-4
1		sequential	}	2425-4
Noninflationary Semantics		sequential	Noninflationary Semantics	2426-1
<B>	To	constraint	a noninflationary variant	2426-2
<B>	obtain	action	a noninflationary variant	2426-2
a noninflationary variant		sequential	there	2426-2
there	are	attribute	several possibilities	2426-2
One	could keep	action	the syntax	2426-3
the syntax	of	constraint	datalog¬	2426-3
datalog¬	but	conjunctive	the semantics	2426-3
datalog¬	make	action	the semantics	2426-3
the semantics	by	constraint	each stage	2426-3
the semantics	at	constraint	each stage	2426-3
the semantics	retaining	action	each stage	2426-3
each stage		sequential	only the newly inferred facts	2426-3
only the newly inferred facts	see	action	Exercise 14.16	2426-3
Another possibility	to	constraint	explicit retraction	2426-4
Another possibility	is	attribute	explicit retraction	2426-4
Another possibility	allow	action	explicit retraction	2426-4
explicit retraction	of	constraint	a previously inferred fact	2426-4
<B>	Syntactically can be done	action	negations	2427-1
<B>	using	action	negations	2427-1
negations	in	constraint	heads	2427-1
heads	of	constraint	rules	2427-1
rules	as	constraint	deletions	2427-1
rules	interpreted	action	deletions	2427-1
deletions	of	constraint	facts	2427-1
We	adopt here	action	this solution	2427-2
this solution	in	constraint	part	2427-2
part	because	constraint	it	2427-2
it	brings	action	our language	2427-2
our language	to	constraint	some practical languages	2427-2
some practical languages		sequential	that	2427-2
that	use	action	production	2427-2
that	so called	action	production	2427-2
production		sequential	rules	2427-2
rules	in	constraint	the sense	2427-2
the sense	of	constraint	expert	2427-2
expert	and	conjunctive	active database	2427-2
active database		sequential	systems	2427-2
The resulting language	by	constraint	datalog¬¬	2427-3
The resulting language	is denoted	action	datalog¬¬	2427-3
datalog¬¬	to	constraint	negations	2427-3
datalog¬¬	that	constraint	negations	2427-3
datalog¬¬	indicate	action	negations	2427-3
negations	in	constraint	heads	2427-3
negations	both	conjunctive	heads	2427-3
negations	are allowed	action	heads	2427-3
heads	and	conjunctive	bodies	2427-3
bodies	of	constraint	rules	2427-3
Example		sequential	14.3.3	2428-1
14.3.3		sequential	Add Remove	2428-1
Add Remove	Visited Again	action	<B>	2428-1
Recursion	and	conjunctive	Negation T	2429-1
Negation T		sequential	x	2429-1
x		sequential	y	2429-1
y		sequential	T	2429-1
T		sequential	Relation off	2429-1
Relation off	to	constraint	the first rule	2429-1
Relation off	off 1 x y is used	action	the first rule	2429-1
Relation off	inhibit	action	the first rule	2429-1
the first rule	initializing	action	T	2429-1
T	to	constraint	G	2429-1
G	after	constraint	the first step	2429-1
The immediate consequence operator		sequential	ŴP	2430-1
ŴP	and	conjunctive	semantics	2430-1
semantics	of	constraint	a datalog¬¬ program	2430-1
a datalog¬¬ program	to	constraint	datalog¬	2430-1
a datalog¬¬ program	for	constraint	datalog¬	2430-1
a datalog¬¬ program	are	attribute	analogous	2430-1
datalog¬	with	constraint	the following important proviso	2430-1
<B>	If	constraint	<B>	2430-2
<B>	With	constraint	the semantics	2431-1
the semantics	chosen previously	action	termination	2431-1
termination	is no longer guaranteed	action	<B>	2431-1
<B>	For	constraint	instance	2431-2
instance		sequential	the program	2431-2
the program		sequential	T 0	2431-2
T 0		sequential	T	2431-2
T		sequential	1	2431-2
1	on	constraint	input	2431-2
1	never terminates	action	input	2431-2
input		sequential	T	2431-2
T		sequential	0	2431-2
The value	of	constraint	T flip flops	2431-3
T flip flops	between	constraint	0 }	2431-3
0 }	and	conjunctive	no fixpoint	2431-3
0 }	{ 1 }	sequential	no fixpoint	2431-3
no fixpoint	so is reached	action	<B>	2431-3
Datalog¬¬	and	conjunctive	Datalog¬	2432-1
Datalog¬	as	constraint	Fragments	2432-1
Fragments	of	constraint	CALC +µ	2432-1
CALC +µ	and	conjunctive	CALC	2432-1
CALC		sequential	+µ+	2432-1
It	as	constraint	a subset	2432-2
It	can be viewed	action	a subset	2432-2
a subset	of	constraint	CALC +µ	2432-2
CALC +µ	in	constraint	the following manner	2432-2
<B>	that	constraint	P	2433-1
<B>	Suppose	action	P	2433-1
P	is	attribute	a datalog¬¬ program	2433-1
The idb relations	by	constraint	rules	2433-2
The idb relations	defined	action	rules	2433-2
rules	by	constraint	simultaneous induction	2433-2
rules	can alternately be defined	action	simultaneous induction	2433-2
simultaneous induction	using	action	formulas	2433-2
formulas		sequential	that	2433-2
that	to	constraint	the rules	2433-2
that	correspond	action	the rules	2433-2
Each firing	of	constraint	the rules	2433-3
the rules	to	constraint	one step	2433-3
the rules	corresponds	action	one step	2433-3
one step	in	constraint	the simultaneous inductive definition	2433-3
<B>	For	constraint	instance	2433-4
instance		sequential	the simultaneous induction definition	2433-4
the simultaneous induction definition	to	constraint	the program	2433-4
the simultaneous induction definition	corresponding	action	the program	2433-4
the program	in	constraint	Example 14.3.3	2433-4
Example 14.3.3	is	attribute	the one	2433-4
the one	in	constraint	Example 14.2.4	2433-4
<B>	Because	constraint	simultaneous induction	2433-5
simultaneous induction	in	constraint	CALC	2433-5
simultaneous induction	can be simulated	action	CALC	2433-5
CALC	+	sequential	µ	2433-5
quantifiers		sequential	quantifiers	2434-1
<B>	in	constraint	the noninflationary case	2434-2
<B>	can be shown	action	the noninflationary case	2434-2
the noninflationary case	although	constraint	the proof	2434-2
the proof	is	attribute	more subtle	2434-2
<B>	In	constraint	summary	2434-3
summary	see	action	Exercise 14.18	2434-3
Exercise 14.18	applies	action	Lemma 14.3.4	2434-3
µ	+	sequential	T	2435-1
T		sequential	t	2435-1
t		sequential	T where	2435-1
x	is	attribute	the tuple	2436-1
the tuple	of	constraint	distinct free variables	2436-1
distinct free variables	in	constraint	t	2436-1
The Rule Algebra		sequential	The Rule Algebra	2437-1
There	is	attribute	a simple mechanism	2437-2
a simple mechanism		sequential	that	2437-2
that	facilitates	action	the specification	2437-2
the specification	by	constraint	the user	2437-2
the user	of	constraint	various customized semantics	2437-2
<B>	by	constraint	means	2437-3
<B>	is done	action	means	2437-3
means	of	constraint	the rule algebra	2437-3
the rule algebra		sequential	which	2437-3
which	allows	action	specification	2437-3
specification	of	constraint	an order	2437-3
an order	of	constraint	firing	2437-3
firing	of	constraint	the rules	2437-3
the rules	to	constraint	a fixpoint	2437-3
the rules	firing up	action	a fixpoint	2437-3
a fixpoint	in	constraint	an manner	2437-3
a fixpoint	or	conjunctive	an manner	2437-3
<B>	For	constraint	the inflationary version	2437-4
the inflationary version		sequential	RA	2437-4
RA	of	constraint	the rule algebra	2437-4
the rule algebra		sequential	the base expressions	2437-4
the base expressions	are	attribute	individual datalog¬ rules	2437-4
individual datalog¬ rules		sequential	the semantics	2437-4
the semantics	with	constraint	a rule	2437-4
the semantics	associated	action	a rule	2437-4
a rule	to	constraint	its immediate consequence operator	2437-4
a rule	is	attribute	its immediate consequence operator	2437-4
a rule	apply once	action	its immediate consequence operator	2437-4
its immediate consequence operator	in	constraint	a cumulative fashion	2437-4
Union		sequential	∪	2437-5
∪	to	constraint	simultaneous application	2437-5
∪	can be used	action	simultaneous application	2437-5
∪	specify	action	simultaneous application	2437-5
simultaneous application	of	constraint	a pair	2437-5
a pair	of	constraint	rules	2437-5
rules	or	conjunctive	more complex programs	2437-5
The expression P		sequential	Q	2437-6
Q	specifies	action	the composition	2437-6
the composition	of	constraint	P	2437-6
P	and	conjunctive	Q	2437-6
Q		sequential	its semantics	2437-6
its semantics	to	constraint	P	2437-6
its semantics	is	attribute	P	2437-6
its semantics	execute once	action	P	2437-6
P	and	conjunctive	Q	2437-6
Inflationary iteration program	of	constraint	P	2437-7
P	for	constraint	P	2437-7
P	by	constraint	P	2437-7
P	is called	action	P	2437-7
The noninflationary version	of	constraint	the rule algebra	2437-8
the rule algebra		sequential	denoted RA	2437-8
denoted RA	with	constraint	datalog¬ rules	2437-8
denoted RA	starts	action	datalog¬ rules	2437-8
datalog¬ rules	with	constraint	now a noninflationary destructive semantics	2437-8
datalog¬ rules	but	conjunctive	now a noninflationary destructive semantics	2437-8
now a noninflationary destructive semantics	as	constraint	Exercise 14.16	2437-8
now a noninflationary destructive semantics	in	constraint	Exercise 14.16	2437-8
now a noninflationary destructive semantics	defined	action	Exercise 14.16	2437-8
Union	and	conjunctive	composition	2437-9
composition	in	constraint	the natural fashion	2437-9
composition	are generalized	action	the natural fashion	2437-9
the natural fashion	and	conjunctive	the noninflationary iterator	2437-9
the noninflationary iterator	denoted	action	∗	2437-9
∗	is used	action	<B>	2437-9
Example		sequential	14.3.5	2438-1
<B>	+	sequential	The RA program	2439-1
The RA program		sequential	P	2439-1
P	+	sequential	Q	2439-1
Q	in	constraint	CT	2439-1
Q	computes	action	CT	2439-1
CT		sequential	the complement	2439-1
the complement	of	constraint	the transitive closure	2439-1
the transitive closure	of	constraint	G	2439-1
It	from	constraint	the results	2440-1
It	follows easily	action	the results	2440-1
the results	of	constraint	Section 14.4	2440-1
Section 14.4		sequential	that	2440-1
that		sequential	RA	2440-1
RA	to	constraint	datalog¬	2440-1
RA	is	attribute	equivalent	2440-1
datalog¬	and	conjunctive	RA	2440-1
RA	to	constraint	noninflationary datalog¬	2440-1
RA	is	attribute	equivalent	2440-1
noninflationary datalog¬	to	constraint	hence datalog¬ ¬	2440-1
noninflationary datalog¬	and	conjunctive	hence datalog¬ ¬	2440-1
hence datalog¬ ¬		sequential	Exercise	2440-1
Exercise		sequential	14.23	2440-1
an RA	+	sequential	program	2441-1
program	into	constraint	Recursion	2441-1
program	Thus can be compiled	attribute	possibly much more complicated	2441-1
Recursion	and	conjunctive	Negation	2441-1
Negation		sequential	a datalog¬ program	2441-1
<B>	For	constraint	instance	2441-2
instance		sequential	RA	2441-2
RA	+	sequential	the program	2441-2
the program	in	constraint	Example 14.3.5	2441-2
Example 14.3.5	to	constraint	the datalog¬ program	2441-2
Example 14.3.5	is	attribute	equivalent	2441-2
the datalog¬ program	in	constraint	Example 14.4.2	2441-2
The advantage	of	constraint	the rule algebra	2441-3
the rule algebra	is	attribute	the ease	2441-3
the ease	of	constraint	various semantics	2441-3
the ease	expressing	action	various semantics	2441-3
<B>	In	constraint	RA	2441-4
RA	to	constraint	the semantics	2441-4
RA	and	conjunctive	the semantics	2441-4
RA	+	sequential	the semantics	2441-4
RA	can be used easily	action	the semantics	2441-4
RA	specify	action	the semantics	2441-4
RA	stratified	action	the semantics	2441-4
RA	well founded	action	the semantics	2441-4
the semantics	for	constraint	datalog¬	2441-4
datalog¬	in	constraint	Chapter 15	2441-4
datalog¬	introduced	action	Chapter 15	2441-4
Equivalence		sequential	Equivalence	2442-1
This section	that	constraint	the inflationary languages	2442-2
This section	shows	action	the inflationary languages	2442-2
the inflationary languages	in	constraint	the three paradigms	2442-2
the three paradigms	while	constraint	CALC +µ+	2442-2
the three paradigms	+	sequential	CALC +µ+	2442-2
CALC +µ+	and	conjunctive	datalog¬	2442-2
datalog¬	that	constraint	the noninflationary languages	2442-2
datalog¬	for	constraint	the noninflationary languages	2442-2
datalog¬	and	conjunctive	the noninflationary languages	2442-2
datalog¬	are	attribute	equivalent	2442-2
datalog¬	holds	action	the noninflationary languages	2442-2
the noninflationary languages	while	constraint	CALC +µ	2442-2
CALC +µ	and	conjunctive	datalog¬¬	2442-2
<B>	yields	action	two classes	2443-1
two classes	of	constraint	queries	2443-1
queries		sequential	that	2443-1
that	in	constraint	the theory	2443-1
that	are	attribute	central	2443-1
the theory	of	constraint	query languages	2443-1
query languages		sequential	the fixpoint queries	2443-1
the fixpoint queries	by	constraint	the inflationary languages	2443-1
the fixpoint queries	expressed	action	the inflationary languages	2443-1
the inflationary languages	while	constraint	the queries	2443-1
the inflationary languages	and	conjunctive	the queries	2443-1
the queries	by	constraint	the noninflationary languages	2443-1
the queries	expressed	action	the noninflationary languages	2443-1
<B>	in	constraint	Fig	2443-2
<B>	is summarized	action	Fig	2443-2
14.2	at	constraint	the end	2443-3
the end	of	constraint	the chapter	2443-3
We	with	constraint	the equivalence	2444-1
We	begin	action	the equivalence	2444-1
the equivalence	of	constraint	the inflationary languages	2444-1
the inflationary languages	because	constraint	it	2444-1
it	to	constraint	<B>	2444-1
it	is	attribute	the more difficult	2444-1
it	show	action	<B>	2444-1
The equivalence	of	constraint	CALC +µ+	2444-2
CALC +µ+	while	constraint	the languages	2444-2
CALC +µ+	because	constraint	the languages	2444-2
CALC +µ+	and	conjunctive	the languages	2444-2
CALC +µ+	+	sequential	the languages	2444-2
CALC +µ+	is	attribute	easy	2444-2
the languages	have	action	similar capabilities	2444-2
similar capabilities		sequential	Program composition	2444-2
Program composition	in	constraint	formula composition	2444-2
Program composition	while	constraint	formula composition	2444-2
Program composition	to	constraint	formula composition	2444-2
Program composition	+	sequential	formula composition	2444-2
Program composition	corresponds closely	action	formula composition	2444-2
formula composition	in	constraint	CALC +µ+	2444-2
CALC +µ+	and	conjunctive	the while change loop	2444-2
the while change loop	of	constraint	while	2444-2
while	to	constraint	the inflationary fixpoint operator	2444-2
while	+	sequential	the inflationary fixpoint operator	2444-2
while	is	attribute	close	2444-2
the inflationary fixpoint operator	of	constraint	CALC +µ+	2444-2
<B>	and	conjunctive	the equivalence	2444-3
<B>	is	attribute	the equivalence	2444-3
the equivalence	of	constraint	these languages	2444-3
these languages	with	constraint	datalog¬	2444-3
datalog¬	because	constraint	this much simpler language	2444-3
this much simpler language	has	action	no explicit constructs	2444-3
no explicit constructs	for	constraint	program composition	2444-3
program composition	or	conjunctive	nested recursion	2444-3
Lemma		sequential	14.4.1 CALC	2445-1
14.4.1 CALC		sequential	+µ+	2445-1
+µ+	while	constraint	<B>	2445-1
+µ+	and	conjunctive	<B>	2445-1
+µ+	are	attribute	+ equivalent	2445-1
Proof		sequential	Proof	2446-1
<B>	Let	action	x1	2446-2
<B>	.	sequential	<B>	2446-3
<B>	.	sequential	<B>	2446-4
xm Rξ	+=	sequential	<B>	2446-5
<B>	Now suppose	action	the statement	2446-6
the statement	for	constraint	formulas	2446-6
the statement	is	attribute	true	2446-6
formulas	with	constraint	depth	2446-6
depth	of	constraint	nesting	2446-6
nesting	of	constraint	the fixpoint operator	2446-6
the fixpoint operator	than	constraint	d	2446-6
d		sequential	d	2446-6
d		sequential	0	2446-6
<B>	Let	action	ξ	2447-1
ξ	be	attribute	a formula	2447-1
a formula	with	constraint	d	2447-1
d		sequential	ξ	2447-1
ξ	=	sequential	d	2447-1
<B>	If	constraint	ξ	2448-1
ξ	=	sequential	µQ	2448-1
µQ		sequential	ϕ	2448-1
ϕ		sequential	Q	2448-1
Q		sequential	f1	2448-1
<B>	.	sequential	<B>	2448-2
<B>	.	sequential	<B>	2448-3
fk		sequential	Pξ	2448-4
Pξ	is	attribute	Q	2448-4
Q	+=	sequential	∅	2448-4
∅	while	constraint	change	2448-4
change	do begin	action	Eϕ	2448-4
Eϕ		sequential	Q	2448-4
Q	+=	sequential	Rϕ end	2448-4
Rϕ end		sequential	Rξ	2448-4
Rξ	+=	sequential	π	2448-4
π		sequential	σ	2448-4
σ		sequential	Q	2448-4
Q		sequential	π	2448-4
π		sequential	σ	2448-4
σ		sequential	Q	2448-4
Q	where denotes	action	the selection	2448-4
the selection	and	conjunctive	projection	2448-4
projection	to	constraint	f1	2448-4
projection	corresponding	action	f1	2448-4
<B>	.	sequential	<B>	2448-5
<B>	.	sequential	<B>	2448-6
fk		sequential	fk	2448-7
<B>	that	constraint	first order	2449-1
<B>	by	constraint	first order	2449-1
<B>	ξ	sequential	first order	2449-1
<B>	Suppose now	action	first order	2449-1
<B>	is obtained	action	first order	2449-1
first order		sequential	operations	2449-1
operations	from	constraint	k formulas	2449-1
k formulas		sequential	1	2449-1
<B>	.	sequential	<B>	2449-2
<B>	.	sequential	<B>	2449-3
<B>	having	action	µ+	2449-4
µ+	as	constraint	root	2449-4
<B>	Let	action	Eξ	2449-5
Eξ		sequential	Rξ	2449-5
<B>	.	sequential	<B>	2449-6
<B>	.	sequential	<B>	2449-7
R	be	attribute	the relational algebra expression corre	2449-8
the relational algebra expression corre		sequential	1	2449-8
1	to	constraint	ξ	2449-8
1	sponding	action	ξ	2449-8
ξ		sequential	each subformula ξi	2449-8
each subformula ξi	where =	sequential	µQ	2449-8
µQ		sequential	ϕ	2449-8
ϕ		sequential	Q	2449-8
Q		sequential	ei	2449-8
<B>	.	sequential	<B>	2449-9
<B>	.	sequential	<B>	2449-10
ei	by	constraint	R	2449-11
ei	is replaced	action	R	2449-11
<B>	For	constraint	1 n	2449-12
1 n		sequential	i	2449-12
i		sequential	i	2449-12
i		sequential	i	2449-12
i	let	action	Pξ	2449-12
Pξ	be	attribute	a program	2449-12
a program		sequential	that	2449-12
that	produces	action	the value	2449-12
the value	of	constraint	µ i Q	2449-12
µ i Q		sequential	ϕ	2449-12
ϕ		sequential	Q	2449-12
Q		sequential	ei1	2449-12
ei1		sequential	ni	2449-12
ni		sequential	it	2449-12
it	into	constraint	Rξ	2449-12
Then P		sequential	i	2449-13
i		sequential	Pξ	2449-13
<B>	.	sequential	<B>	2449-14
<B>	.	sequential	<B>	2449-15
P		sequential	Rξ	2449-16
Rξ	+=	sequential	Eξ	2449-16
Eξ		sequential	Rξ	2449-16
<B>	.	sequential	<B>	2449-17
<B>	.	sequential	<B>	2449-18
R		sequential	R	2449-19
<B>	completes	action	the induction	2450-1
the induction	and	conjunctive	the proof	2450-1
the proof	that	constraint	CALC +µ+	2450-1
CALC +µ+	by	constraint	while +	2450-1
CALC +µ+	can be simulated	action	while +	2450-1
The converse simulation	is	attribute	similar	2451-1
Exercise		sequential	14.20	2451-1
We	to	constraint	the equivalence	2452-1
We	now turn	action	the equivalence	2452-1
the equivalence	of	constraint	CALC +µ+	2452-1
CALC +µ+	and	conjunctive	datalog¬	2452-1
Lemma 14.3.4	yields	action	the subsumption	2452-2
the subsumption	of	constraint	datalog¬	2452-2
datalog¬	by	constraint	CALC +µ+	2452-2
<B>	For	constraint	the other direction	2452-3
the other direction		sequential	we	2452-3
we	simulate	action	CALC +µ+ queries	2452-3
CALC +µ+ queries	using	action	datalog¬	2452-3
This simulation	presents	action	two main difficulties	2452-4
<B>	involves	action	the firing	2453-1
<B>	delaying	action	the firing	2453-1
the firing	of	constraint	a rule	2453-1
a rule	until	constraint	the completion	2453-1
a rule	after	constraint	the completion	2453-1
the completion	of	constraint	a fixpoint	2453-1
a fixpoint	by	constraint	another set	2453-1
another set	of	constraint	rules	2453-1
<B>	because	constraint	the fixpoint	2453-2
<B>	that	constraint	the fixpoint	2453-2
<B>	is	attribute	Intuitively hard	2453-2
<B>	checking	action	the fixpoint	2453-2
the fixpoint	has been reached	action	the nonexistence	2453-2
the fixpoint	involves	action	the nonexistence	2453-2
the fixpoint	checking	action	the nonexistence	2453-2
the nonexistence		sequential	the existence	2453-2
the existence	of	constraint	some valuation	2453-2
some valuation	and	conjunctive	datalog¬	2453-2
datalog¬	toward	constraint	the existence	2453-2
datalog¬	is more naturally geared	action	the existence	2453-2
datalog¬	checking	action	the existence	2453-2
the existence	of	constraint	valuations	2453-2
The solution	to	constraint	this difficulty	2453-3
this difficulty	in	constraint	the following example	2453-3
this difficulty	is illustrated	action	the following example	2453-3
Example		sequential	14.4.2	2454-1
<B>	To	constraint	the relations old	2454-2
<B>	monitor	attribute	this	2454-2
the relations old		sequential	T	2454-2
T		sequential	T	2454-2
T	except	constraint	<B>	2454-2
T	are used	action	<B>	2454-2
<B>		sequential	T	2454-3
T	follows	action	the computation	2454-3
the computation	of	constraint	T	2454-3
T	but	conjunctive	one step	2454-3
T	is	attribute	one step	2454-3
one step	behind	constraint	it	2454-3
The relation old		sequential	T	2454-4
T	except	constraint	final	2454-4
final	to	constraint	old T	2454-4
final	is	attribute	identical	2454-4
old T	but	conjunctive	the rule	2454-4
the rule	defining	action	it	2454-4
it	includes	action	a clause	2454-4
a clause		sequential	that	2454-4
that	prevents	action	it	2454-4
it	from	constraint	T	2454-4
it	firing	action	T	2454-4
T	when has reached	action	its last iteration	2454-4
<B>		sequential	T	2454-5
T	and	conjunctive	T	2454-5
T	except	constraint	only the iteration	2454-5
T	in	constraint	only the iteration	2454-5
T	differ	action	only the iteration	2454-5
only the iteration	after	constraint	the transitive closure T	2454-5
the transitive closure T	reaches	action	its final value	2454-5
<B>	In	constraint	the subsequent iteration	2454-6
the subsequent iteration		sequential	the program	2454-6
the program	that	constraint	the fixpoint	2454-6
the program	recognizes	action	the fixpoint	2454-6
the fixpoint	and	conjunctive	the rule	2454-6
the fixpoint	has been reached	action	the rule	2454-6
the fixpoint	fires	action	the rule	2454-6
the rule	computing	action	the complement	2454-6
the complement	in	constraint	relation CT	2454-6
The program	is	attribute	T	2454-7
T		sequential	x	2454-7
x		sequential	y	2454-7
y		sequential	T	2454-7
T		sequential	x	2454-7
x		sequential	y	2454-7
y		sequential	T	2454-7
T		sequential	x	2454-7
x		sequential	y	2454-7
y		sequential	T	2454-7
T	except	constraint	x	2454-7
x		sequential	y	2454-7
y		sequential	T	2454-7
T		sequential	x	2454-7
x		sequential	y	2454-7
y		sequential	T	2454-7
T		sequential	x′	2454-7
x′		sequential	z′	2454-7
z′		sequential	T	2454-7
T		sequential	z′	2454-7
z′		sequential	y′	2454-7
y′		sequential	¬T	2454-7
¬T		sequential	x′	2454-7
x′		sequential	y′	2454-7
y′		sequential	CT	2454-7
CT		sequential	x	2454-7
x		sequential	y	2454-7
Recursion	and	conjunctive	Negation	2455-1
<B>	Given	action	a formula	2455-2
a formula		sequential	µ+	2455-2
µ+		sequential	ϕ	2455-2
ϕ		sequential	T	2455-2
T		sequential	the simulation	2455-2
the simulation	of	constraint	itself	2455-2
itself	may involve	action	numerous re-T lations	2455-2
numerous re-T lations	than	constraint	T	2455-2
T		sequential	whose behavior	2455-2
whose behavior	by	constraint	an overly zealous application	2455-2
whose behavior	may be sabotaged	action	an overly zealous application	2455-2
an overly zealous application	of	constraint	iteration	2455-2
iteration	of	constraint	the immediate consequence operator	2455-2
<B>	To	constraint	we	2455-3
<B>	overcome	attribute	this	2455-3
we	separate	action	the internal computation	2455-3
the internal computation	of	constraint	the external iteration	2455-3
the internal computation	from	constraint	the external iteration	2455-3
the external iteration	over	constraint	T	2455-3
T	as	constraint	the following example	2455-3
T	in	constraint	the following example	2455-3
T	illustrated	action	the following example	2455-3
Example		sequential	14.4.3	2456-1
<B>	Consider	action	the CALC +µ+ query	2456-2
the CALC +µ+ query		sequential	<B>	2456-2
<B>	that	constraint	the query	2457-1
<B>	Note	action	the query	2457-1
the query	computes	action	the set	2457-1
the set	of	constraint	nodes	2457-1
nodes	in	constraint	G	2457-1
G		sequential	that	2457-1
that	from	constraint	a cycle	2457-1
that	are	attribute	not reachable	2457-1
a cycle	in	constraint	other words	2457-1
other words		sequential	the nodes	2457-1
the nodes		sequential	the length	2457-1
the length	of	constraint	paths	2457-1
paths	to	constraint	them	2457-1
paths	leading	action	them	2457-1
them	is bounded	action	<B>	2457-1
One application	of	constraint	good	2457-2
good	by	constraint	the datalog¬ program	2457-2
good	is achieved	action	the datalog¬ program	2457-2
the datalog¬ program		sequential	P	2457-2
P		sequential	x	2457-2
x	←	sequential	G	2457-2
G		sequential	y	2457-2
y		sequential	x	2457-2
x	y delay	attribute	good	2457-2
x		sequential	delay	2457-2
delay	¬	sequential	x	2457-2
the relations	and	conjunctive	which	2457-3
the relations	Intuitively delay	attribute	bad	2457-3
which	as	constraint	scratch paper	2457-3
which	are used	action	scratch paper	2457-3
scratch paper	in	constraint	the computation	2457-3
the computation	of	constraint	a single iteration	2457-3
a single iteration	of	constraint	µ+	2457-3
µ+	to	constraint	the computation	2457-3
µ+	and	conjunctive	the computation	2457-3
µ+	can not be reinitialized	action	the computation	2457-3
µ+	so can not be reused	action	the computation	2457-3
µ+	perform	action	the computation	2457-3
the computation	of	constraint	subsequent iterations	2457-3
<B>	To	constraint	this problem	2458-1
<B>	surmount	action	this problem	2458-1
this problem		sequential	we	2458-1
we	essentially create	action	a version	2458-1
a version	of	constraint	P	2458-1
P	for	constraint	each iteration	2458-1
each iteration	of	constraint	<B>	2458-1
The versions	by	constraint	timestamps	2458-2
The versions	are distinguished	action	timestamps	2458-2
The versions	using	action	timestamps	2458-2
timestamps		sequential	The nodes themselves	2458-2
The nodes themselves	as	constraint	timestamps	2458-2
The nodes themselves	serve	action	timestamps	2458-2
The timestamps	marking	action	iteration	2458-3
iteration		sequential	i	2458-3
i	are	attribute	the values	2458-3
the values	in	constraint	relation good	2458-3
the values	newly introduced	action	relation good	2458-3
relation good	at	constraint	iteration	2458-3
iteration		sequential	i	2458-3
i	− 1	sequential	<B>	2458-3
Relations delay	to	constraint	the derivation	2458-4
Relations delay	and	conjunctive	the derivation	2458-4
Relations delay	delay stamped	action	the derivation	2458-4
Relations delay	are used	action	the derivation	2458-4
Relations delay	delay	action	the derivation	2458-4
the derivation	of	constraint	new tuples	2458-4
new tuples	in	constraint	good	2458-4
good	until	constraint	the current iteration	2458-4
good	in	constraint	the current iteration	2458-4
good	and	conjunctive	the current iteration	2458-4
good	bad stamped	action	the current iteration	2458-4
good	have been computed	action	the current iteration	2458-4
The process	until	constraint	no new values	2458-5
The process	continues	action	no new values	2458-5
no new values	in	constraint	an iteration	2458-5
no new values	are introduced	action	an iteration	2458-5
The full program	is	attribute	the union	2458-6
the union	of	constraint	the three rules	2458-6
the three rules	given earlier	action	which	2458-6
which	perform	action	the first iteration	2458-6
the first iteration	and	conjunctive	the following rules	2458-6
the following rules		sequential	which	2458-6
which	perform	action	the iteration	2458-6
the iteration	with	constraint	timestamp t	2458-6
timestamp t	stamped	action	x	2458-6
x		sequential	t	2458-6
t		sequential	G	2458-6
G		sequential	y	2458-6
y		sequential	x	2458-6
x		sequential	y	2458-6
y		sequential	t	2458-6
t	good delay stamped	action	t	2458-6
t		sequential	t	2458-6
t		sequential	x	2458-6
We	on	constraint	the formal demonstration	2459-1
We	now embark	action	the formal demonstration	2459-1
the formal demonstration	that	constraint	datalog¬	2459-1
datalog¬	can simulate	action	CALC +µ+	2459-1
We	first introduce	action	some notation	2460-1
some notation	to	constraint	the timestamping	2460-1
some notation	relating	action	the timestamping	2460-1
the timestamping	of	constraint	a program	2460-1
a program	in	constraint	the simulation	2460-1
<B>	Let	action	m	2460-2
m		sequential	≥ 1	2460-2
<B>	For	constraint	each relation schema Q	2460-3
each relation schema Q	let	action	Q	2460-3
Q	be	attribute	a new relational schema	2460-3
a new relational schema	with	constraint	arity	2460-3
arity		sequential	Q	2460-3
Q	=	sequential	arity	2460-3
arity		sequential	Q	2460-3
Q	+	sequential	m.	2460-3
<B>	.	sequential	<B>	2460-4
<B>	.	sequential	<B>	2460-5
en	and	conjunctive	<B>	2460-6
en	is	attribute	a literal	2460-6
<B>	.	sequential	<B>	2460-7
<B>	.	sequential	<B>	2460-8
en		sequential	en	2460-9
<B>	.	sequential	<B>	2460-10
<B>	.	sequential	<B>	2460-11
en		sequential	z1	2460-12
<B>	.	sequential	<B>	2460-13
<B>	.	sequential	<B>	2460-14
zm		sequential	zm	2460-15
<B>	For	constraint	each program P	2460-16
each program P	and	conjunctive	tuple	2460-16
<B>	To	constraint	the previous notation	2461-1
<B>	illustrate	action	the previous notation	2461-1
the previous notation	consider	action	the program P	2461-1
the program P	of	constraint	the following two rules	2461-1
the program P	consisting	action	the following two rules	2461-1
the following two rules		sequential	S	2461-1
S		sequential	x	2461-1
x		sequential	y	2461-1
y		sequential	R	2461-1
R		sequential	x	2461-1
x		sequential	y	2461-1
y		sequential	S	2461-1
S		sequential	x	2461-1
x		sequential	y	2461-1
y		sequential	R	2461-1
R		sequential	x	2461-1
x		sequential	z	2461-1
z		sequential	S	2461-1
S		sequential	z	2461-1
z		sequential	y	2461-1
P		sequential	z	2462-1
z	//	sequential	¬T	2462-1
¬T		sequential	x	2462-1
x	w	constraint	y	2462-1
y	is	attribute	Then S	2462-1
Then S		sequential	x	2462-1
x		sequential	y	2462-1
y		sequential	z	2462-1
z		sequential	R	2462-1
R		sequential	x	2462-1
x		sequential	y	2462-1
y		sequential	z	2462-1
z		sequential	¬T	2462-1
¬T		sequential	x	2462-1
x	w	constraint	y	2462-1
y		sequential	S	2462-1
S		sequential	x	2462-1
x		sequential	y	2462-1
y		sequential	z	2462-1
z		sequential	R	2462-1
R		sequential	x	2462-1
x		sequential	z	2462-1
z		sequential	z	2462-1
z		sequential	S	2462-1
S		sequential	z	2462-1
z		sequential	y	2462-1
y		sequential	z	2462-1
z		sequential	¬T	2462-1
¬T		sequential	x	2462-1
x		sequential	w	2462-1
w		sequential	y	2462-1
Lemma		sequential	14.4.4	2463-1
14.4.4		sequential	CALC	2463-1
CALC		sequential	+µ+	2463-1
+µ+	and	conjunctive	datalog¬	2463-1
datalog¬	are	attribute	equivalent	2463-1
Proof program	to	constraint	a predicate	2464-1
Proof program	produce concomitantly	action	a predicate	2464-1
a predicate		sequential	that	2464-1
that	only becomes	attribute	true	2464-1
the simulation	when has been completed	action	<B>	2464-1
we	by	constraint	induction	2464-2
we	More precisely will prove	action	induction	2464-2
induction	For	constraint	each CALC +µ+ formula	2464-2
induction	following	action	each CALC +µ+ formula	2464-2
each CALC +µ+ formula	over	constraint	a database schema R	2464-2
a database schema R		sequential	there	2464-2
there	exists	action	a datalog¬ program prog	2464-2
a datalog¬ program prog		sequential	whose edb relations	2464-2
whose edb relations	are	attribute	ϕ the relations	2464-2
ϕ the relations	in	constraint	R	2464-2
R		sequential	whose idb relations	2464-2
whose idb relations	include	action	result	2464-2
result	with	constraint	arity	2464-2
arity	to	constraint	the number	2464-2
the number	of	constraint	free variables	2464-2
free variables	in	constraint	0 ary	2464-2
free variables	and	conjunctive	0 ary	2464-2
free variables	ϕ	sequential	0 ary	2464-2
0 ary		sequential	a relation	2464-2
a relation	that	constraint	every instance	2464-2
a relation	for	constraint	every instance	2464-2
a relation	done	attribute	such	2464-2
every instance		sequential	I	2464-2
I	over	constraint	R	2464-2
We	without	constraint	loss	2465-1
We	will assume	action	loss	2465-1
loss	of	constraint	generality	2465-1
generality	that	constraint	no variable	2465-1
no variable	of	constraint	more than one quantifier	2465-1
no variable	to	constraint	more than one quantifier	2465-1
no variable	and	conjunctive	more than one quantifier	2465-1
no variable	or	conjunctive	more than one quantifier	2465-1
no variable	occurs	attribute	free	2465-1
no variable	bound	action	more than one quantifier	2465-1
more than one quantifier	that	constraint	ϕ	2465-1
ϕ	or	conjunctive	∨	2465-1
ϕ	contains	attribute	no	2465-1
∨	that	constraint	the initial query	2465-1
∨	and	conjunctive	the initial query	2465-1
the initial query	has	action	the form	2465-1
the form		sequential	x1	2465-1
<B>	.	sequential	<B>	2465-2
<B>	.	sequential	<B>	2465-3
xn		sequential	}	2465-4
}		sequential	where x1	2465-4
<B>	.	sequential	<B>	2465-5
<B>	.	sequential	<B>	2465-6
xn	are	attribute	distinct variables	2465-7
<B>	that	constraint	the last assumption	2465-8
<B>	Note	action	the last assumption	2465-8
the last assumption	that	constraint	the desired result	2465-8
the last assumption	implies	action	the desired result	2465-8
the last assumption	i establishes	action	the desired result	2465-8
<B>	that	constraint	an atom R	2466-1
<B>	is	attribute	an atom R	2466-1
<B>	Suppose now	action	an atom R	2466-1
an atom R		sequential	e	2466-1
<B>	Let	action	<B>	2466-2
<B>	be	attribute	the tuple	2467-1
the tuple	of	constraint	distinct variables	2467-1
distinct variables	in	constraint	e	2467-1
distinct variables	occurring	action	e	2467-1
prog	of	constraint	the rules	2467-2
prog	Then ϕ consists	action	the rules	2467-2
the rules	done	action	result	2467-2
<B>	←	sequential	x R	2468-1
e		sequential	e	2469-1
There	are	attribute	four cases	2470-1
four cases	to	constraint	the induction step	2470-1
four cases	for	constraint	the induction step	2470-1
four cases	consider	action	the induction step	2470-1
<B>	and	conjunctive	<B>	2471-1
<B>	x	sequential	<B>	2471-1
<B>	be	attribute	the tuples	2472-1
the tuples	of	constraint	distinct free variables	2472-1
distinct free variables	of	constraint	α	2472-1
α	and	conjunctive	β	2472-1
β	and	conjunctive	<B>	2472-1
β	let	action	<B>	2472-1
<B>	or	conjunctive	<B>	2473-1
<B>	x	sequential	<B>	2473-1
y		sequential	y	2474-1
Recursion	and	conjunctive	Negation	2475-1
x result β		sequential	x result β	2476-1
<B>		sequential	<B>	2477-1
<B>	be	attribute	the tuple	2478-1
the tuple	of	constraint	distinct free variables	2478-1
distinct free variables	of	constraint	ψ	2478-1
ψ	and	conjunctive	<B>	2478-1
ψ	let	action	<B>	2478-1
<B>	from	constraint	<B>	2479-1
<B>	obtained	action	<B>	2479-1
y	by	constraint	the variable x	2480-1
y	removing	action	the variable x	2480-1
prog	of	constraint	prog	2480-2
prog	Then ϕ consists	action	prog	2480-2
prog		sequential	ψ	2480-2
ψ		sequential	the rules result ψ	2480-2
the rules result ψ		sequential	z	2480-2
z	done	action	ψ	2480-2
ψ		sequential	result	2480-2
<B>		sequential	<B>	2481-1
<B>	be	attribute	the tuple	2482-1
the tuple	of	constraint	distinct free variables	2482-1
distinct free variables	in	constraint	ψ	2482-1
distinct free variables	occurring	action	ψ	2482-1
prog	of	constraint	prog	2482-2
prog	Then ϕ consists	action	prog	2482-2
prog		sequential	ψ	2482-2
ψ		sequential	result	2482-2
<B>	x done	action	ψ	2483-1
ψ		sequential	result	2483-1
<B>	x done	action	<B>	2484-1
Relation fixpoint	contains	action	µS	2485-1
µS		sequential	ψ	2485-1
ψ		sequential	S	2485-1
S	at	constraint	the end	2485-1
the end	of	constraint	the computation	2485-1
the computation	and	conjunctive	result	2485-1
result	contains	action	µS	2485-1
µS		sequential	ψ	2485-1
ψ		sequential	S	2485-1
S		sequential	e	2485-1
Relation	run	action	the timestamps	2486-1
Relation	contains	action	the timestamps	2486-1
Relation	used	action	the timestamps	2487-1
Relation	contains	action	the timestamps	2487-1
the timestamps	in	constraint	the previous stages	2487-1
the timestamps	introduced	action	the previous stages	2487-1
the previous stages	of	constraint	the iteration	2487-1
The active timestamps	in	constraint	run	2487-2
The active timestamps	are	attribute	run	2487-2
run	used	action	<B>	2487-2
Relation	to	constraint	the final iteration	2488-1
Relation	is used	action	the final iteration	2488-1
Relation	detect	action	the final iteration	2488-1
the final iteration		sequential	the iteration	2488-1
the iteration		sequential	that	2488-1
that	adds	action	no new tuples	2488-1
no new tuples	to	constraint	fixpoint	2488-1
The presence	of	constraint	a timestamp	2488-2
a timestamp	in	constraint	the final iteration	2488-2
a timestamp	that	constraint	the final iteration	2488-2
a timestamp	used	attribute	not final	2488-2
a timestamp	indicates	action	the final iteration	2488-2
the final iteration	has been completed	action	<B>	2488-2
Relations	for	constraint	timing	2489-1
Relations	and	conjunctive	timing	2489-1
Relations	ϕ	sequential	timing	2489-1
Relations	delay	attribute	not- empty	2489-1
Relations	are used	action	timing	2489-1
timing	to	constraint	an empty result	2489-1
timing	and	conjunctive	an empty result	2489-1
timing	detect	action	an empty result	2489-1
<B>	In	constraint	<B>	2490-1
<B>	the following	action	<B>	2490-1
<B>	and	conjunctive	<B>	2491-1
<B>		sequential	<B>	2492-1
The remainder	of	constraint	the program	2493-1
the program	contains	action	the following rules	2493-1
<B>	of	constraint	distinct variables	2494-1
distinct variables	with	constraint	same arity	2494-1
same arity	as	constraint	R	2494-1
R		sequential	R	2494-1
t	←	sequential	x R	2495-1
x fixpoint		sequential	t	2496-1
t	run	action	t	2496-1
t		sequential	fixpoint	2496-1
fixpoint		sequential	t	2496-1
t		sequential	S	2496-1
<B>		sequential	t	2497-1
t		sequential	fixpoint	2497-1
fixpoint		sequential	ϕ	2497-1
ϕ		sequential	y	2497-1
y		sequential	fixpoint	2497-1
fixpoint		sequential	t	2497-1
prog		sequential	ψ	2498-1
ψ		sequential	t	2498-1
t	run where	action	t	2498-1
t	used	action	t	2498-1
t		sequential	result	2498-1
result		sequential	z	2498-1
z		sequential	fixpoint ϕ	2498-1
fixpoint ϕ		sequential	e	2498-1
It	by	constraint	inspection	2499-1
It	is easily verified	action	inspection	2499-1
inspection		sequential	that	2499-1
that		sequential	prog	2499-1
prog	under	constraint	ii the induction hypothesis	2499-1
prog	and	conjunctive	ii the induction hypothesis	2499-1
prog	ϕ satisfies i	action	ii the induction hypothesis	2499-1
ii the induction hypothesis	for	constraint	cases	2499-1
cases		sequential	1	2499-1
1	through	constraint	3	2499-1
<B>	To	constraint	case	2499-2
<B>	that	constraint	case	2499-2
<B>	and	conjunctive	case	2499-2
<B>	see	action	case	2499-2
<B>	i ii hold in	action	case	2499-2
case		sequential	we	2499-2
we	4 carefully consider	action	the stages	2499-2
the stages	in	constraint	the evaluation	2499-2
the evaluation	of	constraint	prog	2499-2
<B>	Let	action	I	2499-3
I	be	attribute	an instance	2499-3
an instance	over	constraint	the relations	2499-3
the relations	in	constraint	ψ	2499-3
ψ	than	constraint	S	2499-3
S	let	action	J0	2499-3
J0	over	constraint	S	2499-3
J0	be	attribute	S	2499-3
S	and	conjunctive	Ji	2499-3
S	let	action	Ji	2499-3
Ji		sequential	Ji−1 ∪	2499-3
Ji−1 ∪		sequential	ψ	2499-3
ψ		sequential	Ji−1	2499-3
Ji−1	for	constraint	each i 0	2499-3
Then µS		sequential	ψ	2500-1
ψ		sequential	S	2500-1
S		sequential	I	2500-1
The program prog	simulates	action	the consecutive iterations	2500-2
the consecutive iterations	of	constraint	this process	2500-2
The first iteration	is simulated	action	prog ψ	2500-3
The first iteration	using directly	action	prog ψ	2500-3
prog ψ	whereas	constraint	the subsequent iterations	2500-3
the subsequent iterations	by	constraint	prog ψ	2500-3
the subsequent iterations	are simulated	action	prog ψ	2500-3
prog ψ	with	constraint	the tuples	2500-3
prog ψ	timestamped	action	the tuples	2500-3
the tuples	at	constraint	the previous iteration	2500-3
the tuples	added	action	the previous iteration	2500-3
We	omit	action	consideration	2500-4
consideration	of	constraint	the case	2500-4
the case	in	constraint	which	2500-4
which		sequential	the fixpoint	2500-4
the fixpoint	∅	sequential	care	2500-4
the fixpoint	is	attribute	this	2500-4
the fixpoint	is taken	action	care	2500-4
care	of	constraint	the rules	2500-4
care	by	constraint	the rules	2500-4
the rules	involving	action	delay	2500-4
delay	and	conjunctive	<B>	2500-4
Recursion	and	conjunctive	Negation	2501-1
The stage	in	constraint	which	2501-2
which		sequential	the simulation	2501-2
the simulation	of	constraint	the first iteration	2501-2
the first iteration	is completed immediately	action	the stage	2501-2
the first iteration	follows	action	the stage	2501-2
the stage	in	constraint	which	2501-2
which	done	action	ψ	2501-2
ψ	becomes	attribute	true	2501-2
The subsequent iterations	are completed immediately	action	the stages	2501-3
The subsequent iterations	following	action	the stages	2501-3
the stages	in	constraint	which	2501-3
which	becomes	attribute	true	2501-3
<B>	Thus let	action	k1	2501-4
k1	be	attribute	the stage	2501-4
the stage	in	constraint	which	2501-4
which	done	action	ψ	2501-4
ψ	and	conjunctive	ki	2501-4
ψ	becomes	attribute	true	2501-4
ψ	let	action	ki	2501-4
ki		sequential	2	2501-4
2		sequential	i	2501-4
i		sequential	≤	2501-4
≤		sequential	n	2501-4
n	be	attribute	the successive stages	2501-4
the successive stages	in	constraint	which	2501-4
which	is	attribute	true	2501-4
First note		sequential	First note	2501-5
y		sequential	result	2502-1
result		sequential	ψ	2502-1
}	y =	sequential	ψ	2503-1
ψ		sequential	J0	2503-1
J0		sequential	fixpoint	2503-1
fixpoint	=	sequential	J1	2503-1
<B>	For	constraint	i 1	2504-1
i 1		sequential	it	2504-1
it	by	constraint	induction	2504-1
it	can be shown	action	induction	2504-1
induction	on	constraint	i	2504-1
y	done	action	ψ	2505-1
ψ		sequential	t	2505-1
t		sequential	∧	2505-1
∧	result	action	ψ	2505-1
y		sequential	t	2506-1
t		sequential	∧	2506-1
∧		sequential	¬	2506-1
¬	used	action	t	2506-1
t		sequential	}	2506-1
}	=	sequential	ψ	2506-1
ψ		sequential	Ji−1	2506-1
Ji−1		sequential	fixpoint	2506-1
fixpoint	=	sequential	Ji−1 ∪	2506-1
Ji−1 ∪		sequential	ψ	2506-1
ψ		sequential	Ji−1	2506-1
Ji−1	=	sequential	Ji	2506-1
Ji	ϕ	sequential	ψ	2506-1
Ji	=	sequential	ψ	2506-1
Ji	=	sequential	ψ	2506-1
Ji	used	attribute	not last	2506-1
Ji	done	action	ψ	2506-1
ψ	=	sequential	Ji−1	2506-1
x		sequential	R	2507-1
t	x run	action	t	2508-1
t		sequential	∧ ¬	2508-1
∧ ¬	used	action	t	2508-1
t		sequential	}	2508-1
}	=	sequential	I	2508-1
I		sequential	R	2508-1
x		sequential	S	2509-1
t	x run	action	t	2510-1
t		sequential	∧	2510-1
∧	used	action	t	2510-1
t		sequential	}	2510-1
}	=	sequential	Ji	2510-1
<B>	at	constraint	stage	2511-1
stage		sequential	kn 1	2511-1
kn 1	+	sequential	ϕ	2511-1
kn 1	used	action	ϕ	2511-1
ϕ	=	sequential	Jn−1	2511-1
Jn−1		sequential	not -last	2511-1
not -last		sequential	ϕ	2511-1
ϕ	=	sequential	Jn−2	2511-1
Jn−2		sequential	fixpoint	2511-1
fixpoint	=	sequential	Jn	2511-1
Jn	=	sequential	µS	2511-1
µS		sequential	ψ	2511-1
ψ		sequential	S	2511-1
S		sequential	I	2511-1
I		sequential	result	2511-1
result		sequential	ϕ	2511-1
ϕ	=	sequential	µS	2511-1
µS		sequential	ψ	2511-1
ψ		sequential	S	2511-1
S		sequential	z	2511-1
z		sequential	I	2511-1
I	=	sequential	<B>	2511-1
I	done	attribute	true	2511-1
<B>	for	constraint	prog	2512-1
<B>	and	conjunctive	prog	2512-1
<B>	Thus i ii hold	action	prog	2512-1
prog	in	constraint	case	2512-1
case		sequential	4	2512-1
4		sequential	which	2512-1
which	concludes	action	the induction	2512-1
Lemmas		sequential	14.4.1	2513-1
14.4.1	and	conjunctive	14.4.4	2513-1
14.4.4	now yield	action	the following Theorem	2513-1
the following Theorem		sequential	14.4.5	2513-1
14.4.5	while	constraint	CALC +µ+	2513-1
14.4.5	+	sequential	CALC +µ+	2513-1
CALC +µ+	and	conjunctive	datalog¬	2513-1
datalog¬	are	attribute	equivalent	2513-1
The set	of	constraint	queries	2514-1
queries	in	constraint	CALC +µ+	2514-1
queries	while	constraint	CALC +µ+	2514-1
queries	+	sequential	CALC +µ+	2514-1
CALC +µ+	and	conjunctive	datalog¬	2514-1
datalog¬	is called	action	the fixpoint queries	2514-1
An analogous equivalence result	for	constraint	the noninflationary languages	2514-2
An analogous equivalence result	can be proven	action	the noninflationary languages	2514-2
the noninflationary languages	while	constraint	CALC +µ	2514-2
CALC +µ	and	conjunctive	datalog¬¬	2514-2
The proof	of	constraint	the equivalence	2514-3
the equivalence	of	constraint	CALC +µ	2514-3
CALC +µ	and	conjunctive	datalog¬¬	2514-3
datalog¬¬	than	constraint	the inflationary case	2514-3
datalog¬¬	in	constraint	the inflationary case	2514-3
datalog¬¬	is	attribute	easier	2514-3
the inflationary case	because	constraint	the ability	2514-3
the ability	to	constraint	deletions	2514-3
the ability	perform	action	deletions	2514-3
deletions	in	constraint	datalog¬¬	2514-3
datalog¬¬	facilitates	action	the task	2514-3
the task	of	constraint	explicit control	2514-3
the task	simulating	action	explicit control	2514-3
explicit control	see	action	Exercise 14.21	2514-3
we	Thus can prove	attribute	the	2514-4
we	following	action	Theorem 14.4.6	2514-4
Theorem 14.4.6	while	constraint	CALC +µ	2514-4
CALC +µ	and	conjunctive	datalog¬¬	2514-4
datalog¬¬	are	attribute	equivalent	2514-4
The set	of	constraint	queries	2515-1
queries	in	constraint	CALC	2515-1
queries	while	constraint	CALC	2515-1
CALC		sequential	+µ	2515-1
+µ	and	conjunctive	datalog¬¬	2515-1
datalog¬¬	is called	action	the while queries	2515-1
We	at	constraint	the fixpoint queries	2515-2
We	will look	action	the fixpoint queries	2515-2
the fixpoint queries	and	conjunctive	the while queries	2515-2
the while queries	from	constraint	complexity	2515-2
complexity	and	conjunctive	expressiveness	2515-2
expressiveness		sequential	a standpoint	2515-2
a standpoint	in	constraint	Chapter 17	2515-2
<B>	Although	constraint	the spirit	2515-3
the spirit	of	constraint	our discussion	2515-3
our discussion	in	constraint	this chapter	2515-3
this chapter	that	constraint	fixpoint	2515-3
this chapter	suggested	action	fixpoint	2515-3
fixpoint	while	constraint	distinct classes	2515-3
fixpoint	and	conjunctive	distinct classes	2515-3
fixpoint	are	attribute	distinct classes	2515-3
distinct classes	of	constraint	queries	2515-3
queries	from	constraint	<B>	2515-3
queries	is	attribute	obvious	2515-3
<B>	In	constraint	fact	2515-4
fact		sequential	the question	2515-4
the question	remains	attribute	open	2515-4
The equivalences	among	constraint	languages	2516-1
languages	in	constraint	this chapter	2516-1
languages	discussed	action	this chapter	2516-1
this chapter	in	constraint	Fig	2516-1
this chapter	are summarized	action	Fig	2516-1
14.2		sequential	14.2	2516-2
Normal Forms		sequential	Normal Forms	2517-1
they	that	constraint	these languages	2517-2
they	First show	action	these languages	2517-2
these languages	under	constraint	composition	2517-2
these languages	are closed	action	composition	2517-2
composition	and	conjunctive	complementation	2517-2
<B>	For	constraint	instance	2517-3
instance	if	constraint	two mappings	2517-3
two mappings	f	constraint	g	2517-3
g	from	constraint	a schema S	2517-3
a schema S	to	constraint	a schema S′	2517-3
a schema S′	from	constraint	S′	2517-3
a schema S′	and	conjunctive	S′	2517-3
S′	to	constraint	a schema	2517-3
Analogous results	for	constraint	CALC +µ	2517-4
Analogous results	are	attribute	true	2517-4
CALC +µ	+	sequential	<B>	2517-4
<B>	yields	action	a normal form	2518-1
a normal form	for	constraint	CALC +µ+ queries	2518-1
CALC +µ+ queries	that	constraint	a single application	2518-1
CALC +µ+ queries	and	conjunctive	a single application	2518-1
CALC +µ+ queries	implies	action	a single application	2518-1
a single application	of	constraint	Recursion	2518-1
Recursion	and	conjunctive	Negation	2518-1
Negation		sequential	Languages Class	2518-1
Languages Class	of	constraint	queries	2518-1
queries	while	constraint	inflationary CALC +µ+ fixpoint datalog¬	2518-1
queries	+	sequential	inflationary CALC +µ+ fixpoint datalog¬	2518-1
inflationary CALC +µ+ fixpoint datalog¬	while	constraint	noninflationary CALC +µ	2518-1
noninflationary CALC +µ	while	sequential	datalog¬	2518-1
Similar remarks	to	constraint	CALC +µ queries	2518-2
Similar remarks	apply	action	CALC +µ queries	2518-2
<B>	In	constraint	summary	2518-3
summary	applies	action	Theorem 14.4.7	2518-3
Theorem 14.4.7		sequential	Each CALC +µ	2518-3
Each CALC +µ	+	sequential	query	2518-3
query	to	constraint	CALC +µ	2518-3
query	is	attribute	equivalent	2518-3
CALC +µ	+	sequential	a query	2518-3
a query	of	constraint	the form	2518-3
µ	+	sequential	T	2519-1
T		sequential	t	2519-1
t		sequential	T	2519-1
T	is	attribute	where an existential CALC formula	2519-1
Recursion	in	constraint	Practical Languages	2520-1
<B>	of	constraint	these languages	2520-2
these languages	provide	action	semantics	2520-2
semantics	for	constraint	recursion	2520-2
recursion	in	constraint	the spirit	2520-2
the spirit	of	constraint	the procedural semantics	2520-2
the procedural semantics	in	constraint	this chapter	2520-2
the procedural semantics	described	action	this chapter	2520-2
Prototypes	implementing	action	the deductive paradigm	2520-3
the deductive paradigm	in	constraint	Chapter 15	2520-3
the deductive paradigm	are discussed	action	Chapter 15	2520-3
SQL		sequential	2	2521-1
2	-	sequential	3	2521-1
3		sequential	a norm	2521-1
a norm	by	constraint	ISO	2521-1
a norm	provided	action	ISO	2521-1
ISO	/	sequential	ANSII	2521-1
ANSII	allows	action	select statements	2521-1
select statements		sequential	that	2521-1
that	define	action	a table	2521-1
a table	in	constraint	the clauses	2521-1
a table	from	constraint	the clauses	2521-1
a table	and	conjunctive	the clauses	2521-1
a table	used recursively	action	the clauses	2521-1
Such recursion	in	constraint	Starburst	2521-2
Such recursion	is also allowed	action	Starburst	2521-2
The semantics	of	constraint	the recursion	2522-1
the recursion	although	constraint	noninflationary semantics	2522-1
the recursion	is	attribute	inflationary	2522-1
noninflationary semantics	can be achieved	action	deletion	2522-1
noninflationary semantics	using	action	deletion	2522-1
An extension	of	constraint	SQL 2	2522-2
SQL 2	-	sequential	3	2522-2
3	is	attribute	ESQL	2522-2
ESQL		sequential	Extended SQL	2522-2
<B>	To	constraint	the flavor	2522-3
<B>	illustrate	action	the flavor	2522-3
the flavor	of	constraint	the syntax	2522-3
the syntax		sequential	which	2522-3
which	for	constraint	this category	2522-3
which	is	attribute	typical	2522-3
this category	of	constraint	languages	2522-3
languages	is	attribute	an ESQL program	2522-3
an ESQL program	defining	action	a table SPARTS	2522-3
a table SPARTS		sequential	subparts	2522-3
subparts		sequential	the transitive closure	2522-3
the transitive closure	of	constraint	the table PARTS	2522-3
<B>	is done	action	a view creation mechanism	2522-4
<B>	using	action	a view creation mechanism	2522-4
<B>	create	action	view SPARTS	2523-1
view SPARTS	as	constraint	PARTS union Bibliographic Notes	2523-1
view SPARTS	from	constraint	PARTS union Bibliographic Notes	2523-1
PARTS union Bibliographic Notes	select	action	P1.	2523-1
<B>	With	constraint	deletion	2523-2
deletion		sequential	one	2523-2
one	can simulate	action	CALC +µ	2523-2
The system Postgres	also provides	action	similar iteration	2523-3
similar iteration	up to	constraint	a fixpoint	2523-3
a fixpoint	in	constraint	its query language POSTQUEL	2523-3
programs		sequential	programs	2524-1
The recursion	by	constraint	loops	2524-2
The recursion	while	constraint	loops	2524-2
The recursion	is provided	action	loops	2524-2
loops	in	constraint	the host language	2524-2
The recursion	by	constraint	datalog¬	2525-1
The recursion	provided	action	datalog¬	2525-1
datalog¬	and	conjunctive	datalog¬¬	2525-1
datalog¬¬	in	constraint	spirit	2525-1
datalog¬¬	is	attribute	close	2525-1
spirit	to	constraint	production rule	2525-1
production rule		sequential	systems	2525-1
<B>	Speaking loosely	action	a production rule	2525-2
a production rule	has	action	the form	2525-2
the form	if	constraint	condition action	2525-2
Production rules	permit	action	the specification	2526-1
the specification	of	constraint	database updates	2526-1
database updates	whereas	constraint	deductive rules	2526-1
deductive rules	usually support	action	only database queries	2526-1
only database queries	with	constraint	some notable exceptions	2526-1
<B>	that	constraint	the deletion	2526-2
<B>	Note	action	the deletion	2526-2
the deletion	in	constraint	datalog¬¬	2526-2
datalog¬¬	as	constraint	an update capability	2526-2
datalog¬¬	can be viewed	action	an update capability	2526-2
datalog¬¬	providing	action	an update capability	2526-2
production rule		sequential	The approach	2526-3
The approach	in	constraint	connection	2526-3
The approach	has been studied widely	action	connection	2526-3
connection	with	constraint	expert systems	2526-3
expert systems	in	constraint	artificial intelligence	2526-3
artificial intelligence		sequential	OPS5	2526-3
OPS5	is	attribute	a system	2526-3
OPS5	well known	action	a system	2526-3
a system		sequential	that	2526-3
that	uses	action	this approach	2526-3
<B>	In	constraint	active databases	2527-1
active databases		sequential	the rule condition	2527-1
the rule condition	into	constraint	two pieces	2527-1
the rule condition	is often broken	action	two pieces	2527-1
two pieces		sequential	one piece	2527-1
one piece	called	action	the trigger	2527-1
the trigger	to	constraint	the database	2527-1
the trigger	is usually closely tied	action	the database	2527-1
the database	on	constraint	insertions to	2527-1
the database	based	action	insertions to	2527-1
insertions to	or	conjunctive	deletions	2527-1
deletions	from	constraint	relations	2527-1
relations	in	constraint	the system	2527-1
relations	and	conjunctive	the system	2527-1
relations	can be implemented deep	action	the system	2527-1
<B>	In	constraint	active database systems	2528-1
active database systems		sequential	rules	2528-1
rules	are recursively fired	action	conditions	2528-1
conditions	in	constraint	the database	2528-1
conditions	when become	attribute	true	2528-1
<B>	in	constraint	broad terms	2528-2
<B>	Speaking	action	broad terms	2528-2
broad terms		sequential	the noninflationary languages	2528-2
the noninflationary languages	in	constraint	this chapter	2528-2
the noninflationary languages	studied	action	this chapter	2528-2
this chapter	as	constraint	an abstraction	2528-2
this chapter	can be viewed	action	an abstraction	2528-2
an abstraction	of	constraint	this behavior	2528-2
<B>	For	constraint	example	2528-3
example		sequential	the database language RDL1	2528-3
the database language RDL1	in	constraint	spirit	2528-3
the database language RDL1	is	attribute	close	2528-3
spirit	to	constraint	the language datalog¬¬	2528-3
<B>	See also	action	Chapter 22	2528-4
Chapter 22	for	constraint	a discussion	2528-4
a discussion	of	constraint	active databases	2528-4
The language Graphlog		sequential	a visual language	2529-1
a visual language	for	constraint	queries	2529-1
queries	on	constraint	graphs	2529-1
graphs	at	constraint	the University	2529-1
graphs	developed	action	the University	2529-1
the University	of	constraint	Toronto	2529-1
Toronto	emphasizes	action	queries	2529-1
queries	involving	action	paths	2529-1
paths	and	conjunctive	recursion	2529-1
paths	provides	action	recursion	2529-1
recursion	specified	action	regular expressions	2529-1
recursion	using	action	regular expressions	2529-1
regular expressions		sequential	that	2529-1
that	describe	action	the shape	2529-1
the shape	of	constraint	desired paths	2529-1
Bibliographic Notes		sequential	Bibliographic Notes	2530-1
The other noninflationary languages		sequential	CALC +µ	2530-2
CALC +µ	and	conjunctive	datalog¬¬	2530-2
datalog¬¬	in	constraint	AV91a	2530-2
datalog¬¬	were defined	action	AV91a	2530-2
The equivalence	of	constraint	the noninflationary languages	2530-3
the noninflationary languages	was also shown	action	<B>	2530-3
The fixpoint languages	have	action	a long history	2531-1
Logics	with	constraint	fixpoints	2531-2
fixpoints	by	constraint	logicians	2531-2
fixpoints	have been considered	action	logicians	2531-2
logicians	in	constraint	the general case	2531-2
the general case		sequential	infinite structures	2531-2
infinite structures	to	constraint	infinite database instances	2531-2
infinite structures	corresponding	action	infinite database instances	2531-2
infinite database instances	where are allowed	action	Mos74	2531-2
<B>	In	constraint	the finite case	2531-3
the finite case		sequential	which	2531-3
which	in	constraint	this book	2531-3
which	is	attribute	relevant	2531-3
this book		sequential	the fixpoint queries	2531-3
the fixpoint queries	were first defined	action	the partial fixpoint operator µ T	2531-3
the fixpoint queries	using	action	the partial fixpoint operator µ T	2531-3
the partial fixpoint operator µ T	to	constraint	only formulas	2531-3
the partial fixpoint operator µ T	applied	action	only formulas	2531-3
only formulas	in	constraint	T	2531-3
T		sequential	CH82	2531-3
The language	allowing	action	applications	2531-4
applications	of	constraint	µT	2531-4
µT	to	constraint	formulas	2531-4
formulas	in	constraint	T	2531-4
formulas	but	conjunctive	T	2531-4
T	in	constraint	Gur84	2531-4
T	was further studied	action	Gur84	2531-4
An interesting difference	between	constraint	models	2531-5
An interesting difference	and	conjunctive	models	2531-5
models	arises here	action	Every CALC formula monotone	2531-5
Every CALC formula monotone	in	constraint	some predicate R	2531-5
some predicate R	for	constraint	unrestricted structures	2531-5
some predicate R	is	attribute	equivalent	2531-5
unrestricted structures	to	constraint	some CALC formula	2531-5
some CALC formula	in	constraint	R	2531-5
R		sequential	Lyndon	2531-5
Lyndon		sequential	lemma	2531-5
lemma	whereas	constraint	not the case	2531-5
lemma	is	attribute	not the case	2531-5
not the case	for	constraint	finite structures	2531-5
finite structures		sequential	AG87	2531-5
Monotonicity	for	constraint	both cases	2532-1
Monotonicity	is	attribute	undecidable	2532-1
both cases		sequential	Gur84	2532-1
Recursion	and	conjunctive	Negation	2533-1
<B>	As	constraint	side	2533-2
side		sequential	a effect	2533-2
a effect		sequential	it	2533-2
it	in	constraint	GS86	2533-2
it	was shown	action	GS86	2533-2
GS86	that	constraint	the nesting	2533-2
the nesting	of	constraint	µ	2533-2
µ	or	conjunctive	µ+	2533-2
µ+	provides	action	no additional power	2533-2
This fact	for	constraint	the first language	2533-3
This fact	had been proven earlier	action	the first language	2533-3
the first language	in	constraint	Imm86	2533-3
a new alternative proof	of	constraint	the sufficiency	2533-4
the sufficiency	of	constraint	a single application	2533-4
a single application	of	constraint	the fixpoint	2533-4
the fixpoint	in	constraint	CALC +µ+	2533-4
CALC +µ+	in	constraint	Lei90	2533-4
CALC +µ+	Moreover is provided	action	Lei90	2533-4
The simultaneous induction lemma		sequential	Lemma	2533-5
Lemma		sequential	14.2.5	2533-5
14.2.5	in	constraint	GS86	2533-5
14.2.5	was also proven	action	GS86	2533-5
GS86	extending	action	an analogous result	2533-5
an analogous result	of	constraint	Mos74	2533-5
Mos74	for	constraint	infinite structures	2533-5
<B>	Of	constraint	the other inflationary languages	2533-6
the other inflationary languages	while	constraint	AV90	2533-6
the other inflationary languages	in	constraint	AV90	2533-6
the other inflationary languages	+	sequential	AV90	2533-6
the other inflationary languages	was defined	action	AV90	2533-6
AV90	and	conjunctive	datalog¬	2533-6
datalog¬	with	constraint	fixpoint semantics	2533-6
fixpoint semantics	in	constraint	AV88 c	2533-6
fixpoint semantics	was first defined	action	AV88 c	2533-6
AV88 c		sequential	KP88	2533-6
The equivalence	of	constraint	datalog¬	2534-1
datalog¬	with	constraint	CALC +µ+	2534-1
CALC +µ+	while	constraint	AV91a	2534-1
CALC +µ+	in	constraint	AV91a	2534-1
CALC +µ+	and	conjunctive	AV91a	2534-1
CALC +µ+	+ was shown	action	AV91a	2534-1
The relationship	between	constraint	the while	2534-2
the while	and	conjunctive	fixpoint queries	2534-2
fixpoint queries	in	constraint	AV91 b	2534-2
fixpoint queries	was investigated	action	AV91 b	2534-2
AV91 b		sequential	it	2534-2
it	that	constraint	they	2534-2
it	where was shown	action	they	2534-2
they	are	attribute	equivalent	2534-2
The issues	of	constraint	complexity	2534-3
complexity	and	conjunctive	expressivity	2534-3
expressivity	of	constraint	fixpoint	2534-3
fixpoint	while	constraint	queries	2534-3
fixpoint	and	conjunctive	queries	2534-3
queries	in	constraint	detail	2534-3
queries	will be considered	action	detail	2534-3
detail	in	constraint	Chapter 17	2534-3
The rule algebra	for	constraint	logic programs	2535-1
logic programs	in	constraint	IN88	2535-1
logic programs	was introduced	action	IN88	2535-1
The game	of	constraint	life	2536-1
life	in	constraint	detail	2536-1
life	is described	action	detail	2536-1
detail	in	constraint	Gar70	2536-1
The normal forms	in	constraint	this chapter	2536-2
The normal forms	discussed	action	this chapter	2536-2
this chapter	as	constraint	variations	2536-2
this chapter	can be viewed	action	variations	2536-2
variations	of	constraint	folk theorems	2536-2
variations	well known	action	folk theorems	2536-2
folk theorems	in	constraint	Har80	2536-2
folk theorems	described	action	Har80	2536-2
SQL		sequential	2	2537-1
2	-	sequential	3	2537-1
3	in	constraint	ISO	2537-1
3	is described	action	ISO	2537-1
ISO		sequential	ANSII	2537-1
ANSII		sequential	an norm	2537-1
an norm		sequential	57391	2537-1
57391		sequential	69392	2537-1
Starburst	in	constraint	<B>	2537-2
Starburst	is presented	action	<B>	2537-2
The area	of	constraint	active databases	2538-1
active databases	is	attribute	the subject	2538-1
the subject	of	constraint	numerous works	2538-1
numerous works	including	action	Mor83	2538-1
Mor83		sequential	Coh89	2538-1
Coh89		sequential	KDM88	2538-1
KDM88		sequential	SJGP90	2538-1
SJGP90		sequential	MD89	2538-1
MD89		sequential	WF90	2538-1
WF90		sequential	HJ91a	2538-1
Early work	on	constraint	database triggers	2538-2
database triggers	includes	action	<B>	2538-2
The visual graph language Graphlog	at	constraint	the University	2539-1
The visual graph language Graphlog	developed	action	the University	2539-1
the University	of	constraint	Toronto	2539-1
Toronto	in	constraint	CM90	2539-1
Toronto	is described	action	CM90	2539-1
CM90		sequential	CM93a	2539-1
CM93a		sequential	CM93	2539-1
CM93		sequential	b	2539-1
Exercises Exercise 14.1		sequential	Exercises Exercise 14.1	2540-1
Exercise		sequential	14.2	2541-1
Hint		sequential	Hint	2541-2
<B>	Exercise	action	14.3	2542-1
14.3	Recall	action	the datalog¬¬ program	2542-1
the datalog¬¬ program	of	constraint	Example 14.4.2	2542-1
Exercise		sequential	14.4	2543-1
Exercises		sequential	Exercises	2544-1
Exercise		sequential	14.5	2545-1
Exercise		sequential	14.6	2546-1
Exhibit		sequential	a while program	2546-2
a while program	and	conjunctive	a fixpoint query	2546-2
a fixpoint query		sequential	that	2546-2
that	compute	action	this set	2546-2
<B>	Exercise	action	14.7	2547-1
14.7	Recall	action	the CALC +µ+ query	2547-1
the CALC +µ+ query	of	constraint	Example 14.4.3	2547-1
Exercise		sequential	14.9	2548-1
<B>	that	constraint	I	2549-1
I		sequential	R	2549-1
R	=	sequential	J	2549-1
J		sequential	R	2549-1
R	and	conjunctive	I	2549-1
I		sequential	T	2549-1
T		sequential	⊆ J	2549-1
⊆ J		sequential	T	2549-1
T		sequential	I	2549-1
I		sequential	⊆	2549-1
⊆		sequential	J	2549-1
Recursion	and	conjunctive	Negation	2550-1
Negation	be	attribute	a formula	2550-1
a formula		sequential	T	2550-1
T	where has	action	arity	2550-1
arity	n	conjunctive	the xi	2550-1
arity	and	conjunctive	the xi	2550-1
the xi	and	conjunctive	yj	2550-1
yj	in	constraint	ϕ	2550-1
yj	are	attribute	free	2550-1
µT		sequential	x	2550-2
x	is	attribute	Then a correct formula	2550-2
Then a correct formula		sequential	whose free variables	2550-2
whose free variables	are	attribute	the yj	2550-2
the yj	among	constraint	the ei	2550-2
the yj	and	conjunctive	the ei	2550-2
the yj	occurring	action	the ei	2550-2
The fixpoint	with	constraint	respect	2550-3
The fixpoint	is defined	action	respect	2550-3
respect	to	constraint	a given valuation	2550-3
a given valuation	of	constraint	the yj	2550-3
<B>	For	constraint	instance	2550-4
instance	is	attribute	a formula	2550-4
instance	well formed	action	a formula	2550-4
<B>	Give	action	a precise definition	2550-5
a precise definition	of	constraint	the semantics	2550-5
the semantics	for	constraint	queries	2550-5
queries	using	action	this operator	2550-5
<B>	that	constraint	this extension	2550-6
<B>	Show	action	this extension	2550-6
this extension	does not yield	action	increased expressive power	2550-6
increased expressive power	over	constraint	CALC +µ+	2550-6
<B>	for	constraint	CALC +µ	2551-1
Exercise		sequential	14.12	2552-1
<B>	Give	action	a fixpoint query	2552-2
a fixpoint query	in	constraint	the three paradigms	2552-2
a fixpoint query	of	constraint	the three paradigms	2552-2
the three paradigms		sequential	that	2552-2
that	computes	action	the pairs	2552-2
the pairs	of	constraint	vertexes	2552-2
vertexes		sequential	the shortest path	2552-2
the shortest path	between	constraint	them	2552-2
them	of	constraint	even length	2552-2
them	is	attribute	even length	2552-2
Exercise		sequential	14.13	2553-1
rr rr Exercise 14.14		sequential	rr rr Exercise 14.14	2554-1
Hint	Maintain	action	the complement	2554-2
the complement	of	constraint	each relation R	2554-2
each relation R	in	constraint	a new relation R′	2554-2
a new relation R′	using	action	deletions	2554-2
<B>	For	constraint	a datalog¬¬ program	2555-1
a datalog¬¬ program		sequential	P	2555-1
P	let	action	Pξ	2555-1
Pξ	denote	action	program	2555-1
program		sequential	the P	2555-1
the P	with	constraint	semantics	2555-1
semantics		sequential	∈	2555-1
∈		sequential	α	2555-1
α		sequential	β	2555-1
β		sequential	γ	2555-1
γ		sequential	δ	2555-1
δ		sequential	}	2555-1
log¬¬		sequential	datalog¬¬	2556-1
datalog¬¬	≡	sequential	datalog¬¬	2556-1
Exercises Exercise 14.16		sequential	Exercises Exercise 14.16	2557-1
σ	where denotes	action	a selection	2558-1
a selection	and	conjunctive	π	2558-1
π		sequential	a projection	2558-1
Exercise		sequential	14.19	2559-1
<B>	Exercise	attribute	14.20 Complete	2560-1
the proof	of	constraint	Lemma	2560-1
Lemma		sequential	14.4.1	2560-1
14.4.1	that	constraint	each while	2560-1
14.4.1	prove	action	each while	2560-1
each while	+	sequential	program	2560-1
program	by	constraint	a CALC +µ+ program	2560-1
program	can be simulated	action	a CALC +µ+ program	2560-1
<B>	Exercise	action	14.22 Formulate	2561-1
14.22 Formulate	and	conjunctive	a normal form	2561-1
14.22 Formulate	prove	action	a normal form	2561-1
a normal form	for	constraint	while +	2561-1
while +	while	constraint	the normal forms	2561-1
while +	to	constraint	the normal forms	2561-1
while +	and	conjunctive	the normal forms	2561-1
the normal forms	for	constraint	CALC +µ+	2561-1
the normal forms	stated	action	CALC +µ+	2561-1
CALC +µ+	and	conjunctive	CALC	2561-1
CALC		sequential	+µ	2561-1
Exercise		sequential	14.23	2562-1
Hint	Use	action	Theorems 14.4.5	2562-2
Theorems 14.4.5	and	conjunctive	14.4.6	2562-2
14.4.6	and	conjunctive	Exercise 14.16	2562-2
Exercise		sequential	14.24	2563-1
<B>	that	constraint	each RA program	2563-2
<B>	Show	action	each RA program	2563-2
each RA program	to	constraint	an RA program	2563-2
each RA program	is	attribute	equivalent	2563-2
an RA program	of	constraint	star height one	2563-2
I	thought	action	we	2564-1
we	about	constraint	negation	2564-1
we	already talked	action	negation	2564-1
Sergio		sequential	Sergio	2565-1
Humbug		sequential	I	2566-1
I	to	constraint	it	2566-1
I	just got used	action	it	2566-1
Riccardo		sequential	Riccardo	2567-1
Vittorio		sequential	Vittorio	2568-1
This chapter	with	constraint	illustrations how	2569-1
This chapter	begins	action	illustrations how	2569-1
illustrations how	of	constraint	the various semantics	2569-1
the various semantics	for	constraint	datalog	2569-1
datalog	to	constraint	datalog¬	2569-1
datalog	do not naturally extend	action	datalog¬	2569-1
Two semantics	for	constraint	datalog¬	2569-2
datalog¬	are considered	action	<B>	2569-2
<B>	called	action	a syntactic restriction	2569-3
<B>	stratified	action	a syntactic restriction	2569-3
<B>	involves	action	a syntactic restriction	2569-3
a syntactic restriction	on	constraint	programs	2569-3
programs	but	conjunctive	a semantics	2569-3
programs	provides	action	a semantics	2569-3
a semantics		sequential	that	2569-3
that	to	constraint	<B>	2569-3
that	and	conjunctive	<B>	2569-3
that	is	attribute	natural	2569-3
that	understand	action	<B>	2569-3
<B>	called	action	no syntactic restriction	2569-4
<B>	well founded	action	no syntactic restriction	2569-4
<B>	requires	action	no syntactic restriction	2569-4
no syntactic restriction	on	constraint	programs	2569-4
programs	but	conjunctive	the meaning	2569-4
the meaning	with	constraint	some programs	2569-4
the meaning	associated	action	some programs	2569-4
some programs	is expressed	action	a logic	2569-4
some programs	using	action	a logic	2569-4
some programs	3 valued	action	a logic	2569-4
<B>	In	constraint	this logic	2569-5
this logic		sequential	facts	2569-5
facts	or	conjunctive	<B>	2569-5
facts	are	attribute	true	2569-5
<B>	With	constraint	respect	2569-6
respect	to	constraint	expressive power	2569-6
expressive power	founded	action	semantics	2569-6
semantics	to	constraint	the fixpoint queries	2569-6
semantics	is	attribute	equivalent	2569-6
the fixpoint queries	whereas	constraint	the stratified semantics	2569-6
the stratified semantics	is	attribute	strictly weaker	2569-6
proof		sequential	A semantics	2569-7
A semantics	for	constraint	datalog¬	2569-7
datalog¬	on	constraint	negation	2569-7
datalog¬	based	action	negation	2569-7
negation	as	constraint	failure	2569-7
failure	at	constraint	the end	2569-7
failure	is discussed briefly	action	the end	2569-7
the end	of	constraint	this chapter	2569-7
The Basic Problem	that	constraint	we	2570-1
The Basic Problem	Suppose	action	we	2570-1
we	to	constraint	the pairs	2570-1
we	want	action	the pairs	2570-1
we	compute	action	the pairs	2570-1
the pairs	of	constraint	disconnected nodes	2570-1
disconnected nodes	in	constraint	a graph G	2570-1
a graph G		sequential	we	2570-1
we	in	constraint	the complement	2570-1
we	are	attribute	interested	2570-1
the complement	of	constraint	the transitive closure	2570-1
the transitive closure	of	constraint	a graph	2570-1
a graph		sequential	whose edges	2570-1
whose edges	by	constraint	a binary relation G	2570-1
whose edges	are given	action	a binary relation G	2570-1
We	to	constraint	the transitive closure	2570-2
We	already know	action	the transitive closure	2570-2
We	define	action	the transitive closure	2570-2
the transitive closure	of	constraint	G	2570-2
G	in	constraint	a relation T	2570-2
a relation T	using	action	the datalog program	2570-2
the datalog program		sequential	PT C	2570-2
PT C	of	constraint	Chapter 12	2570-2
Chapter 12		sequential	T	2570-2
T		sequential	x	2570-2
x		sequential	y	2570-2
y		sequential	G	2570-2
G		sequential	x	2570-2
x		sequential	y	2570-2
y		sequential	T	2570-2
T		sequential	x	2570-2
x		sequential	y	2570-2
y		sequential	G	2570-2
G		sequential	x	2570-2
x		sequential	z	2570-2
z		sequential	T	2570-2
T		sequential	z	2570-2
z		sequential	y	2570-2
<B>	To	constraint	the complement	2571-1
<B>	define	action	the complement	2571-1
the complement		sequential	CT	2571-1
CT	of	constraint	T	2571-1
T		sequential	we	2571-1
we	to	constraint	negation	2571-1
we	are naturally tempted	action	negation	2571-1
we	use	action	negation	2571-1
negation	as	constraint	we	2571-1
we		sequential	374	2571-1
374	in	constraint	Chapter 5	2571-1
374	did	action	Chapter 5	2571-1
<B>	Let	action	PT	2571-2
<B>	To	constraint	the discussion	2572-1
<B>	simplify	action	the discussion	2572-1
the discussion		sequential	we	2572-1
we	generally assume	action	an active domain interpretation	2572-1
an active domain interpretation	of	constraint	datalog¬ rules	2572-1
<B>	In	constraint	this example	2573-1
this example		sequential	negation	2573-1
negation	to	constraint	an appealing addition	2573-1
negation	be	attribute	an appealing addition	2573-1
negation	appears	action	an appealing addition	2573-1
an appealing addition	to	constraint	the datalog syntax	2573-1
The language datalog¬	by	constraint	bodies	2574-1
The language datalog¬	in	constraint	bodies	2574-1
The language datalog¬	is defined	action	bodies	2574-1
The language datalog¬	allowing	action	bodies	2574-1
bodies	of	constraint	rules	2574-1
rules		sequential	literals	2574-1
literals	of	constraint	the form	2574-1
One	to	constraint	fixpoint	2575-1
One	might hope	attribute	the model theoretic	2575-1
One	extend	attribute	the model theoretic	2575-1
fixpoint	and	conjunctive	semantics	2575-1
semantics	of	constraint	datalog	2575-1
datalog	as	constraint	the syntax	2575-1
things	are	attribute	Unfortunately less straightforward	2575-2
negation	is	attribute	when present	2575-2
We	illustrate informally	action	the problems	2575-3
the problems		sequential	that	2575-3
that	if	constraint	one	2575-3
that	arise	action	one	2575-3
one	to	constraint	the least fixpoint	2575-3
one	tries	action	the least fixpoint	2575-3
one	extend	action	the least fixpoint	2575-3
the least fixpoint	and	conjunctive	minimal model	2575-3
minimal model		sequential	semantics	2575-3
semantics	of	constraint	datalog	2575-3
We	shall discuss later	attribute	proof theoretic	2575-4
Fixpoint Semantics Problems		sequential	Fixpoint Semantics Problems	2576-1
The immediate consequence operator	to	constraint	a datalog¬ program P	2576-2
The immediate consequence operator	can be naturally extended	action	a datalog¬ program P	2576-2
<B>	For	constraint	a program	2576-3
a program		sequential	P	2576-3
P		sequential	TP	2576-3
TP	as	constraint	follows1	2576-3
TP	is defined	action	follows1	2576-3
<B>	.	sequential	<B>	2576-4
<B>	.	sequential	<B>	2576-5
<B>	of	constraint	a rule	2576-6
a rule	in	constraint	P	2576-6
P	for	constraint	which	2576-6
which	if	constraint	Ai	2576-6
Ai	is	attribute	1 a positive literal	2576-6
Ai ∈ K	if	constraint	Ai	2576-6
Ai ∈ K	and	conjunctive	Ai	2576-6
Ai	=	sequential	¬ Bi	2576-6
¬ Bi		sequential	Bi	2576-6
Bi	is	attribute	2 where a positive literal Bi ∈ K	2576-6
Example		sequential	15.1.1	2577-1
P		sequential	i	2578-1
i		sequential	0	2578-1
0	for	constraint	a given datalog¬ program P	2578-1
<B>	that	constraint	datalog	2578-2
<B>	for	constraint	datalog	2578-2
<B>	Recall	action	datalog	2578-2
datalog		sequential	the sequence	2578-2
the sequence	to	constraint	the least fixpoint	2578-2
the sequence	and	conjunctive	the least fixpoint	2578-2
the sequence	is increasing	action	the least fixpoint	2578-2
the sequence	converges	action	the least fixpoint	2578-2
the least fixpoint	of	constraint	TP	2578-2
<B>	In	constraint	the case	2579-1
the case	of	constraint	datalog¬	2579-1
datalog¬		sequential	the situation	2579-1
the situation	is	attribute	more intricate	2579-1
Negation	in	constraint	Datalog TP	2580-1
Datalog TP	has	action	a least fixpoint p	2580-1
a least fixpoint p	but	conjunctive	T i	2580-1
T i		sequential	∅	2580-1
∅		sequential	} P i 0	2580-1
} P i 0	between	constraint	<B>	2580-1
} P i 0	and	conjunctive	<B>	2580-1
} P i 0	∅	sequential	<B>	2580-1
} P i 0	alternates	action	<B>	2580-1
P		sequential	i	2581-1
i	>	sequential	0	2581-1
0	converges	action	its limit	2581-1
its limit	is	attribute	not necessarily a minimal fixpoint	2581-1
not necessarily a minimal fixpoint	of	constraint	TP	2581-1
TP	if	constraint	such fixpoints	2581-1
such fixpoints	even exist	action	<B>	2581-1
<B>	To	constraint	P4	2581-2
<B>	see	attribute	this	2581-2
<B>	let	action	P4	2581-2
P4	=	sequential	p	2581-2
p	←	sequential	p	2581-2
p		sequential	q	2581-2
q		sequential	q	2581-2
q		sequential	p	2581-2
p		sequential	¬p	2581-2
¬p		sequential	q	2581-2
q		sequential	¬p	2581-2
¬p		sequential	}	2581-2
<B>		sequential	T i	2581-3
T i		sequential	∅ } P	2581-3
∅ } P		sequential	i	2581-3
i	>	sequential	0	2581-3
0	to	constraint	p	2581-3
0	converges	action	p	2581-3
p		sequential	q	2581-3
q	but	conjunctive	the least fixpoint	2581-3
the least fixpoint	of	constraint	TP	2581-3
TP	equals	action	p	2581-3
Remark		sequential	15.1.2	2582-1
15.1.2		sequential	Inflationary fixpoint semantics	2582-1
However rules	of	constraint	the form R	2583-1
the form R		sequential	x1	2583-1
<B>	.	sequential	<B>	2583-2
<B>	.	sequential	<B>	2583-3
xn		sequential	← R	2583-4
← R		sequential	x1	2583-4
<B>	.	sequential	<B>	2583-5
<B>	.	sequential	<B>	2583-6
xn	have	action	a nontrivial impact	2583-7
a nontrivial impact	on	constraint	the immediate consequence operator TP	2583-7
<B>	If	constraint	such rules	2583-8
such rules	for	constraint	each idb relation R	2583-8
such rules	are added	action	each idb relation R	2583-8
each idb relation R	in	constraint	TP inflationary	2583-8
each idb relation R	results	action	TP inflationary	2583-8
each idb relation R	making	action	TP inflationary	2583-8
TP inflationary		sequential	K ⊆ TP	2583-8
K ⊆ TP		sequential	K	2583-8
K	for	constraint	each K	2583-8
each K	because	constraint	each fact	2583-8
each fact	is	attribute	an immediate consequence	2583-8
an immediate consequence	of	constraint	itself	2583-8
It	that	constraint	this case	2583-9
It	in	constraint	this case	2583-9
It	is	attribute	worth	2583-9
It	noting	action	this case	2583-9
this case		sequential	T i	2583-9
T i		sequential	I	2583-9
I		sequential	P i	2583-9
<B>	To	constraint	the difference	2584-1
<B>	see	action	the difference	2584-1
the difference	between	constraint	the two semantics	2584-1
the two semantics	consider again	action	program PT C comp	2584-1
The sequence		sequential	T	2585-1
T		sequential	i	2585-1
i		sequential	P	2585-1
P		sequential	i 0	2585-1
i 0	on	constraint	input	2585-1
input		sequential	I	2585-1
I	over	constraint	G	2585-1
G	to	constraint	the desired answer	2585-1
G	converges	action	the desired answer	2585-1
the desired answer		sequential	the T C comp complement	2585-1
the T C comp complement	of	constraint	transitive closure	2585-1
<B>	With	constraint	the inflationary fixpoint semantics	2585-2
the inflationary fixpoint semantics		sequential	CT	2585-2
CT	becomes	action	a complete graph	2585-2
a complete graph	at	constraint	the first iteration	2585-2
the first iteration	because	constraint	T	2585-2
T	and	conjunctive	PT C comp	2585-2
T	is	attribute	initially empty	2585-2
PT C comp	does not compute	action	the complement	2585-2
the complement	of	constraint	transitive closure	2585-2
it	in	constraint	Chapter 14	2585-3
it	Nonetheless was shown	action	Chapter 14	2585-3
Chapter 14	that	constraint	there	2585-3
there	is	attribute	more complicated	2585-3
a different datalog¬ program		sequential	that	2585-3
that	computes	action	the complement	2585-3
the complement	of	constraint	transitive closure	2585-3
transitive closure	with	constraint	the inflationary fixpoint semantics	2585-3
Model		sequential	Semantics	2586-1
Semantics		sequential	Problems sentences	2586-1
Problems sentences	to	constraint	the rules	2586-1
Problems sentences	corresponding	action	the rules	2586-1
the rules	of	constraint	P	2586-1
<B>	that	constraint	datalog	2586-2
<B>	as	constraint	datalog	2586-2
<B>	with	constraint	datalog	2586-2
<B>	Note first	action	datalog	2586-2
datalog		sequential	P	2586-2
P	at	constraint	one model	2586-2
P	always has	attribute	least	2586-2
one model	containing	action	any given input I	2586-2
B		sequential	P	2586-3
P		sequential	I	2586-3
I	is	attribute	such a model	2586-3
<B>	that	constraint	B	2586-4
<B>	Recall	action	B	2586-4
B		sequential	P	2586-4
P		sequential	I	2586-4
I	in	constraint	Chapter 12	2586-4
I	introduced	action	Chapter 12	2586-4
Chapter 12	is	attribute	the instance	2586-4
the instance	in	constraint	which	2586-4
which		sequential	the idb relations	2586-4
the idb relations	contain	action	all tuples	2586-4
all tuples	with	constraint	values	2586-4
values	in	constraint	I	2586-4
I	or	conjunctive	P	2586-4
<B>	For	constraint	datalog	2586-5
datalog		sequential	model	2586-5
model		sequential	the semantics	2586-5
the semantics	of	constraint	a program P	2586-5
a program P	by	constraint	the unique minimal model	2586-5
a program P	was given	action	the unique minimal model	2586-5
the unique minimal model	of	constraint	P	2586-5
P	containing	action	the input	2586-5
this simple solution	for	constraint	datalog¬	2586-6
this simple solution	Unfortunately no longer works	action	datalog¬	2586-6
datalog¬	because	constraint	uniqueness	2586-6
uniqueness	of	constraint	a minimal model	2586-6
a minimal model	containing	action	the input	2586-6
the input	is not guaranteed	action	<B>	2586-6
Program P2	in	constraint	Example 15.1.1	2586-7
Example 15.1.1	b provides	action	one example	2586-7
one example	of	constraint	p	2586-7
p	and	conjunctive	q	2586-7
q	}	sequential	J	2586-7
J		sequential	G	2586-7
G	=	sequential	I	2586-7
T C		sequential	comp	2587-1
The converse	is	attribute	false	2587-2
Exercise		sequential	15.3	2587-2
<B>	for	constraint	a program P	2588-1
a program P		sequential	P	2588-1
P	When has	action	several minimal models	2588-1
several minimal models		sequential	one	2588-1
one	must specify	action	which	2588-1
<B>	In	constraint	summary	2589-1
summary		sequential	the approach	2589-1
the approach		sequential	we	2589-1
we	for	constraint	datalog	2589-1
we	used	action	datalog	2589-1
datalog	on	constraint	equivalent least fixpoint	2589-1
datalog	based	action	equivalent least fixpoint	2589-1
equivalent least fixpoint	or	conjunctive	minimum	2589-1
minimum		sequential	model	2589-1
model		sequential	semantics	2589-1
semantics	breaks down	action	negation	2589-1
negation	is	attribute	when present	2589-1
We	shall describe	action	several solutions	2589-2
several solutions	to	constraint	the problem	2589-2
the problem	of	constraint	semantics	2589-2
the problem	giving	action	semantics	2589-2
semantics	to	constraint	datalog¬ programs	2589-2
We	with	constraint	the simplest case	2589-3
We	begin	action	the simplest case	2589-3
the simplest case	from	constraint	<B>	2589-3
the simplest case	and	conjunctive	<B>	2589-3
the simplest case	build up	action	<B>	2589-3
Stratified Semantics		sequential	Stratified Semantics	2590-1
The semantics	for	constraint	negation	2590-2
negation	in	constraint	this case	2590-2
negation	is	attribute	straightforward	2590-2
We	to	constraint	stratified semantics	2590-3
We	turn	action	stratified semantics	2590-3
stratified semantics		sequential	which	2590-3
which	extends	action	this simple case	2590-3
this simple case	in	constraint	an extremely natural fashion	2590-3
Semipositive Datalog¬		sequential	Semipositive Datalog¬	2591-1
<B>	For	constraint	example	2591-2
example		sequential	the difference	2591-2
the difference	of	constraint	R	2591-2
R	and	conjunctive	R′	2591-2
R′	by	constraint	one rule	2591-2
R′	can be defined	action	one rule	2591-2
one rule		sequential	the program	2591-2
the program		sequential	Diff	2591-2
Diff		sequential	x	2591-2
x		sequential	R	2591-2
R		sequential	x	2591-2
x		sequential	¬ R′	2591-2
¬ R′		sequential	x	2591-2
<B>	To	constraint	semantics	2592-1
<B>	give	action	semantics	2592-1
semantics	to	constraint	¬ R′	2592-1
¬ R′		sequential	x	2592-1
x		sequential	we	2592-1
we	simply use	action	the closed world assumption	2592-1
the closed world assumption	see	action	Chapter 2	2592-1
Definition		sequential	15.2.1	2593-1
Theorem		sequential	15.2.2	2594-1
<B>	For	constraint	every instance	2594-2
every instance		sequential	I	2594-2
I		sequential	edb	2594-2
edb		sequential	P	2594-2
Negation	in	constraint	Datalog P	2595-1
Datalog P		sequential	i	2595-1
i	>	sequential	0	2595-1
Remark		sequential	15.2.3	2596-1
<B>	is	attribute	not the case here	2597-1
not the case here	because	constraint	negation	2597-1
negation	destroys	action	monotonicity	2597-1
<B>	Given	action	a semipositive datalog¬ program	2598-1
a semipositive datalog¬ program		sequential	P	2598-1
P	and	conjunctive	an input	2598-1
an input		sequential	I	2598-1
I		sequential	we	2598-1
we	by	constraint	P semi− pos	2598-1
we	denote	action	P semi− pos	2598-1
P semi− pos		sequential	I	2598-1
I		sequential	the minimum model	2598-1
the minimum model	of	constraint	P	2598-1
P	or	conjunctive	the least fixpoint	2598-1
the least fixpoint	of	constraint	TP	2598-1
TP		sequential	whose restriction	2598-1
whose restriction	to	constraint	P	2598-1
whose restriction	edb	action	P	2598-1
P	equals	action	I	2598-1
T		sequential	x	2599-1
x		sequential	y	2599-1
y		sequential	¬G	2599-1
¬G		sequential	x	2599-1
x		sequential	y	2599-1
y		sequential	T	2599-1
T		sequential	x	2599-1
x		sequential	y	2599-1
y		sequential	¬G	2599-1
¬G		sequential	x	2599-1
x		sequential	z	2599-1
z		sequential	T	2599-1
T		sequential	z	2599-1
z		sequential	y	2599-1
This program	computes	action	the transitive closure	2600-1
the transitive closure	of	constraint	the complement	2600-1
the complement	of	constraint	G	2600-1
it	as	constraint	the composition	2600-2
it	However can naturally be viewed	action	the composition	2600-2
the composition	of	constraint	two semipositive programs	2600-2
two semipositive programs		sequential	the program	2600-2
the program	computing	action	the transitive closure	2600-2
the transitive closure	by	constraint	the program	2600-2
the transitive closure	followed	action	the program	2600-2
the program	computing	action	its complement	2600-2
Stratification		sequential	which	2600-3
which	as	constraint	the closure	2600-3
which	is studied next	action	the closure	2600-3
which	may be viewed	action	the closure	2600-3
the closure	of	constraint	semipositive programs	2600-3
semipositive programs	under	constraint	composition	2600-3
It	will allow	action	us	2600-4
us	to	constraint	instance	2600-4
us	for	constraint	instance	2600-4
us	specify	action	instance	2600-4
instance		sequential	the composition	2600-4
the composition	just described	action	the complement	2600-4
the composition	computing	action	the complement	2600-4
the complement	of	constraint	transitive closure	2600-4
Syntactic Restriction	for	constraint	Stratification	2601-1
<B>	In	constraint	semipositive programs	2601-2
semipositive programs		sequential	the use	2601-2
the use	of	constraint	negation	2601-2
negation	to	constraint	edb relations	2601-2
negation	is restricted	action	edb relations	2601-2
<B>	that	constraint	we	2601-3
<B>	Now suppose	action	we	2601-3
we	use	action	some defined relations	2601-3
some defined relations	like	constraint	much views	2601-3
<B>	Once	constraint	a relation	2601-4
a relation	by	constraint	some program	2601-4
a relation	has been defined	action	some program	2601-4
some program		sequential	other programs	2601-4
other programs	can subsequently treat	action	it	2601-4
it	as	constraint	an edb relation	2601-4
an edb relation	and	conjunctive	negation	2601-4
an edb relation	apply	action	negation	2601-4
negation	to	constraint	it	2601-4
This simple idea	underlies	action	an important extension	2601-5
an important extension	to	constraint	semipositive programs	2601-5
semipositive programs	called	action	stratified programs	2601-5
<B>	Suppose	action	we	2602-1
we	have	action	a datalog¬ program P	2602-1
Each idb relation	by	constraint	one rules	2602-2
Each idb relation	or	conjunctive	one rules	2602-2
Each idb relation	is defined	attribute	more	2602-2
one rules	of	constraint	P	2602-2
<B>	If	constraint	we	2602-3
we	to	constraint	the program	2602-3
we	are	attribute	able	2602-3
we	read	action	the program	2602-3
the program	so that	constraint	each idb relation R′	2602-3
the program	for	constraint	each idb relation R′	2602-3
each idb relation R′		sequential	the portion	2602-3
the portion	of	constraint	R′	2602-3
the portion	P defining	action	R′	2602-3
R′	before	constraint	the negation	2602-3
R′	comes	action	the negation	2602-3
the negation	of	constraint	R′	2602-3
R′	is used	action	we	2602-3
we	can simply compute	action	R′	2602-3
R′	before	constraint	its negation	2602-3
its negation	and	conjunctive	we	2602-3
its negation	is used	action	we	2602-3
we	are	attribute	done	2602-3
<B>	For	constraint	example	2602-4
example	consider	action	program PT C comp	2602-4
program PT C comp	at	constraint	the beginning	2602-4
program PT C comp	introduced	action	the beginning	2602-4
the beginning	of	constraint	this chapter	2602-4
we	for	constraint	T	2602-5
we	Clearly intended	action	T	2602-5
T	to	constraint	the first two rules	2602-5
T	by	constraint	the first two rules	2602-5
T	be defined	action	the first two rules	2602-5
the first two rules	before	constraint	its negation	2602-5
its negation	in	constraint	the rule	2602-5
its negation	is used	action	the rule	2602-5
the rule	defining	action	CT	2602-5
the first two rules	before	constraint	the third	2602-6
the first two rules	Thus are applied	action	the third	2602-6
Such a way	of	constraint	P	2602-7
Such a way	reading	action	P	2602-7
P	is called	action	a stratification	2602-7
a stratification	of	constraint	P	2602-7
P	and	conjunctive	<B>	2602-7
P	is defined next	action	<B>	2602-7
Definition		sequential	15.2.4	2603-1
15.2.4		sequential	programs	2603-1
programs		sequential	P 1	2603-1
<B>	.	sequential	<B>	2603-2
<B>	.	sequential	<B>	2603-3
P	that	constraint	some mapping σ to	2603-4
P	for	constraint	some mapping σ to	2603-4
P	n	conjunctive	some mapping σ to	2603-4
some mapping σ to	from	constraint	idb	2603-4
idb		sequential	P	2603-4
P		sequential	1	2603-4
1		sequential	n	2603-4
n		sequential	i	2603-4
i	{	sequential	P	2603-4
P		sequential	1	2603-4
<B>	.	sequential	<B>	2603-5
<B>	.	sequential	<B>	2603-6
P	n	conjunctive	a partition	2603-7
P	is	attribute	a partition	2603-7
a partition	of	constraint	P	2603-7
<B>	Given	action	a stratification P	2604-1
a stratification P		sequential	1	2604-1
<B>	.	sequential	<B>	2604-2
<B>	.	sequential	<B>	2604-3
P n	of	constraint	P	2604-4
P		sequential	each P	2604-4
each P		sequential	i	2604-4
i	is called	action	a stratum	2604-4
a stratum	of	constraint	the stratification	2604-4
the stratification	and	conjunctive	σ	2604-4
σ	is called	action	the stratification mapping	2604-4
a stratification	of	constraint	a program P	2605-1
a program P	Intuitively provides	action	a way	2605-1
a way	of	constraint	P	2605-1
a way	parsing	action	P	2605-1
P	as	constraint	a sequence	2605-1
a sequence	of	constraint	subprograms P 1	2605-1
<B>	.	sequential	<B>	2605-2
<B>	.	sequential	<B>	2605-3
P n		sequential	each defining one	2605-4
each defining one	or	conjunctive	several idb relations	2605-4
<B>	if	constraint	a relation	2605-5
a relation		sequential	R′	2605-5
R′	in	constraint	the definition	2605-5
R′	is used positively	action	the definition	2605-5
the definition	of	constraint	R	2605-5
R		sequential	R′	2605-5
R′	with	constraint	R	2605-5
R′	or	conjunctive	R	2605-5
R′	By iii must be defined	action	R	2605-5
R	allows	action	recursion	2605-5
<B>	If	constraint	the negation	2605-6
the negation	of	constraint	R′	2605-6
R′	in	constraint	the definition	2605-6
R′	is used	action	the definition	2605-6
the definition	of	constraint	R	2605-6
R	by	constraint	the definition	2605-6
the definition	of	constraint	R′	2605-6
R′	before	constraint	R	2605-6
R′	of	constraint	R	2605-6
R′	iv must come strictly	attribute	that	2605-6
not every datalog¬ program	Unfortunately has	action	a stratification	2606-1
<B>	For	constraint	example	2606-2
example		sequential	there	2606-2
there	is	attribute	no way	2606-2
no way	to	constraint	program	2606-2
no way	read	action	program	2606-2
program		sequential	P2	2606-2
P2	of	constraint	Example 15.1.1	2606-2
Example 15.1.1	so that	constraint	p	2606-2
p	before	constraint	q	2606-2
p	is defined	action	q	2606-2
q	and	conjunctive	q	2606-2
q	before	constraint	p. Programs	2606-2
p. Programs		sequential	that	2606-2
that	have	action	a stratification	2606-2
a stratification	are called	attribute	stratifiable	2606-2
P2	is	attribute	Thus not stratifiable	2606-3
<B>	On	constraint	the other hand	2606-4
the other hand		sequential	PT C comp	2606-4
PT C comp	is	attribute	clearly stratifiable	2606-4
Example		sequential	15.2.5	2607-1
P7	Then has namely	action	5 distinct stratifications	2608-1
<B>	to	constraint	five different ways	2609-1
<B>	lead	action	five different ways	2609-1
five different ways	of	constraint	the program	2609-1
five different ways	reading	action	the program	2609-1
the program		sequential	P7	2609-1
<B>	As	constraint	the same semantics	2609-2
<B>	of	constraint	the same semantics	2609-2
<B>	will be seen	attribute	each	2609-2
<B>	yields	action	the same semantics	2609-2
There	is	attribute	a simple test	2610-1
a simple test	for	constraint	a program	2610-1
a simple test	if	constraint	a program	2610-1
a simple test	checking	action	a program	2610-1
a program	is	attribute	stratifiable	2610-1
<B>		sequential	it	2610-2
it	involves	action	testing	2610-2
testing	for	constraint	an acyclicity condition	2610-2
an acyclicity condition	in	constraint	definitions	2610-2
definitions	of	constraint	relations	2610-2
relations	using	action	negation	2610-2
<B>	Let	action	P	2610-3
P	be	attribute	a datalog¬ program	2610-3
precedence		sequential	The graph GP	2610-4
The graph GP	of	constraint	P	2610-4
P	is	attribute	the labeled graph	2610-4
the labeled graph		sequential	whose nodes	2610-4
whose nodes	are	attribute	the idb relations	2610-4
the idb relations	of	constraint	P	2610-4
Its edges	are	attribute	the following Negation P T	2610-5
the following Negation P T	in	constraint	Datalog V	2610-5
Datalog V		sequential	CT P	2610-5
CT P		sequential	P	2610-5
P		sequential	Q	2610-5
Q		sequential	P	2610-5
P		sequential	S TC	2610-5
S TC		sequential	U comp	2610-5
U comp		sequential	T	2610-5
T		sequential	Figure 15.1	2610-5
Figure 15.1		sequential	Precedence graphs	2610-5
Precedence graphs	for	constraint	PCT	2610-5
PCT		sequential	P2	2610-5
P2	and	conjunctive	P7	2610-5
<B>	For	constraint	example	2611-1
example		sequential	the precedence graphs	2611-1
the precedence graphs	for	constraint	program PT	2611-1
program PT		sequential	C comp	2611-1
C comp		sequential	P2	2611-1
P2	and	conjunctive	P7	2611-1
P7	in	constraint	Fig	2611-1
P7	are represented	action	Fig	2611-1
15.1		sequential	15.1	2611-2
It	to	constraint	proof	2611-3
It	is	attribute	straightforward	2611-3
It	show	attribute	the	2611-3
It	following	action	proof	2611-3
proof	omitted	action	Lemma 15.2.6	2611-3
<B>	If	constraint	there	2611-4
there	is	attribute	a path	2611-4
a path	from	constraint	R′	2611-4
R′	to	constraint	R	2611-4
R	in	constraint	GP	2611-4
GP		sequential	σ	2611-4
σ		sequential	R′	2611-4
R′		sequential	≤ σ	2611-4
≤ σ		sequential	R	2611-4
R	if	constraint	there	2611-4
R	and	conjunctive	there	2611-4
there	is	attribute	a path	2611-4
a path	from	constraint	R′	2611-4
R′	to	constraint	R	2611-4
R	in	constraint	GP	2611-4
GP	containing	action	some negative edge	2611-4
some negative edge		sequential	σ	2611-4
σ		sequential	R′	2611-4
R′		sequential	σ	2611-4
σ		sequential	R	2611-4
We	now show	action	the precedence graph	2612-1
the precedence graph	of	constraint	a program	2612-1
a program	to	constraint	the stratifiability	2612-1
a program	how can be used	action	the stratifiability	2612-1
a program	test	action	the stratifiability	2612-1
the stratifiability	of	constraint	the program	2612-1
Proposition 15.2.7	has	action	no cycle	2613-1
no cycle	containing	action	a negative edge	2613-1
Proof	if	constraint	the only part	2614-1
Proof	Consider	action	the only part	2614-1
<B>	Suppose	action	P	2614-2
P	is	attribute	a datalog¬ program	2614-2
a datalog¬ program		sequential	whose precedence graph	2614-2
whose precedence graph	has	action	a cycle R1	2614-2
<B>	.	sequential	<B>	2614-3
<B>	.	sequential	<B>	2614-4
Rm		sequential	R1	2614-5
R1	containing	action	a negative edge	2614-5
a negative edge	from	constraint	Rm	2614-5
a negative edge	say	action	Rm	2614-5
Rm	to	constraint	R1	2614-5
<B>	toward	constraint	a contradiction	2614-6
<B>	Suppose	action	a contradiction	2614-6
a contradiction	that	constraint	σ	2614-6
σ	is	attribute	a stratification mapping	2614-6
a stratification mapping	for	constraint	P	2614-6
<B>	By	constraint	Lemma 15.2.6	2614-7
Lemma 15.2.6		sequential	σ	2614-7
σ		sequential	R1	2614-7
R1		sequential	σ	2614-7
σ		sequential	R1	2614-7
R1	because	constraint	there	2614-7
there	is	attribute	a path	2614-7
a path	from	constraint	R1	2614-7
R1	to	constraint	R1	2614-7
R1	with	constraint	a negative edge	2614-7
<B>	is	attribute	a contradiction	2614-8
a contradiction		sequential	no stratification mapping σ	2614-8
no stratification mapping σ	for	constraint	P	2614-8
no stratification mapping σ	so exists	action	P	2614-8
<B>	Conversely suppose	action	P	2615-1
P	is	attribute	a program	2615-1
a program		sequential	whose precedence graph GP	2615-1
whose precedence graph GP	has	action	no cycle	2615-1
no cycle	with	constraint	negative edges	2615-1
<B>	Let	action	≺	2615-2
≺	be	attribute	the binary relation	2615-2
the binary relation	among	constraint	the strongly connected components	2615-2
the strongly connected components	of	constraint	GP	2615-2
GP	as	constraint	C	2615-2
GP	defined	action	C	2615-2
GP	follows	action	C	2615-2
C		sequential	C′	2615-2
C′	if	constraint	C	2615-2
C	=	sequential	C′	2615-2
C′	and	conjunctive	there	2615-2
there	or	conjunctive	a edge	2615-2
there	is	attribute	positive	2615-2
a edge	in	constraint	GP	2615-2
GP	from	constraint	some node	2615-2
some node	of	constraint	C	2615-2
C	to	constraint	some node	2615-2
some node	of	constraint	C′	2615-2
We	that	constraint	<B>	2616-1
We	first show	action	<B>	2616-1
<B>	Suppose	action	there	2617-1
there	is	attribute	a cycle	2617-1
a cycle	in	constraint	≺	2617-1
<B>	by	constraint	construction	2617-2
construction	of	constraint	≺	2617-2
≺		sequential	this cycle	2617-2
this cycle	Then must traverse	action	two distinct strongly connected components	2617-2
two distinct strongly connected components	say	action	C	2617-2
C		sequential	C′	2617-2
<B>	Let	action	A	2617-3
A	in	constraint	C	2617-3
A	be	attribute	C	2617-3
<B>	Because	constraint	C′	2618-1
C′	is	attribute	a strongly connected component	2618-1
a strongly connected component	of	constraint	GP	2618-1
GP		sequential	A	2618-1
A	in	constraint	C′	2618-1
A	is	attribute	C′	2618-1
Thus C		sequential	⊆ C′	2618-2
⊆ C′		sequential	C	2618-2
C	so =	sequential	C′	2618-2
C′		sequential	a contradiction	2618-2
<B>	Hence holds	action	<B>	2618-3
<B>	In	constraint	view	2619-1
view	of	constraint	the binary relation	2619-1
the binary relation	induces	action	a partial order	2619-1
a partial order	among	constraint	the strongly connected components	2619-1
the strongly connected components	of	constraint	GP	2619-1
GP		sequential	which	2619-1
which		sequential	we	2619-1
we	by	constraint	abuse	2619-1
we	by	constraint	abuse	2619-1
we	≺	sequential	abuse	2619-1
we	also denote	action	abuse	2619-1
abuse	of	constraint	notation	2619-1
<B>	Let	action	C1	2619-2
<B>	.	sequential	<B>	2619-3
<B>	.	sequential	<B>	2619-4
Cn	be	attribute	a topographic sort	2619-5
a topographic sort	with	constraint	respect	2619-5
respect	to	constraint	the strongly connected components	2619-5
respect	of	constraint	the strongly connected components	2619-5
the strongly connected components	of	constraint	GP	2619-5
GP	is	attribute	C1	2619-5
<B>	.	sequential	<B>	2619-6
<B>	.	sequential	<B>	2619-7
Cn	is	attribute	the set	2619-8
the set	of	constraint	strongly connected components	2619-8
strongly connected components	of	constraint	GP	2619-8
GP	if	constraint	Ci	2619-8
GP	and	conjunctive	Ci	2619-8
Ci		sequential	Cj	2619-8
Cj		sequential	i	2619-8
i	≤	action	j	2619-8
<B>	for	constraint	i	2619-9
i		sequential	1 ≤	2619-9
1 ≤		sequential	i	2619-9
i	n	conjunctive	Qi	2619-9
i	let	action	Qi	2619-9
Qi	of	constraint	all rules	2619-9
Qi	consist	action	all rules	2619-9
all rules	defining	action	some relation	2619-9
some relation	in	constraint	Ci	2619-9
Then Q1		sequential	Then Q1	2619-10
<B>	.	sequential	<B>	2619-11
<B>	.	sequential	<B>	2619-12
Qn	is	attribute	a stratification	2619-13
a stratification	of	constraint	P	2619-13
<B>	in	constraint	the definition	2619-14
<B>	and	conjunctive	the definition	2619-14
the definition	of	constraint	stratification	2619-14
stratification	are	attribute	Indeed i ii clearly satisfied	2619-14
Conditions		sequential	iii	2619-15
iii	from	constraint	the construction	2619-15
iii	and	conjunctive	the construction	2619-15
iii	iv follow immediately	action	the construction	2619-15
the construction	of	constraint	GP	2619-15
GP	from	constraint	the hypothesis	2619-15
GP	and	conjunctive	the hypothesis	2619-15
GP	and	conjunctive	the hypothesis	2619-15
the hypothesis	that	constraint	GP	2619-15
GP	has	action	no cycle	2619-15
no cycle	with	constraint	negative edge	2619-15
the stratifiability test	by	constraint	Proposition 15.2.7	2620-1
the stratifiability test	provided	action	Proposition 15.2.7	2620-1
Proposition 15.2.7	Clearly takes	action	time polynomial	2620-1
time polynomial	in	constraint	the size	2620-1
the size	of	constraint	the program P	2620-1
Verification	of	constraint	the following observation	2621-1
the following observation	to	constraint	the reader	2621-1
the following observation	is left	action	the reader	2621-1
the reader		sequential	Exercise	2621-1
Exercise		sequential	15.4	2621-1
Lemma		sequential	15.2.8	2622-1
15.2.8	Let	action	P 1	2622-1
<B>	.	sequential	<B>	2622-2
<B>	.	sequential	<B>	2622-3
P	be	attribute	n a stratification	2622-4
n a stratification	of	constraint	P	2622-4
P	and	conjunctive	Q1	2622-4
P	let	action	Q1	2622-4
<B>	.	sequential	<B>	2622-5
<B>	.	sequential	<B>	2622-6
Qm	as	constraint	Proposition 15.2.7	2622-7
Qm	in	constraint	Proposition 15.2.7	2622-7
Qm	be obtained	action	Proposition 15.2.7	2622-7
<B>	If	constraint	Qj	2622-8
Qj		sequential	∩	2622-8
∩		sequential	P	2622-8
P		sequential	i	2622-8
i	=	sequential	Qj	2622-8
i	∅	sequential	Qj	2622-8
Qj		sequential	⊆ P	2622-8
⊆ P		sequential	i	2622-8
<B>	In	constraint	the partition Q1	2622-9
<B>	.	sequential	<B>	2622-10
<B>	.	sequential	<B>	2622-11
Qm	of	constraint	P	2622-12
P	refines	action	all other partitions	2622-12
all other partitions	by	constraint	stratifications	2622-12
all other partitions	given	action	stratifications	2622-12
stratifications	of	constraint	P	2622-12
Semantics	of	constraint	Stratified Programs	2623-1
Stratified Programs	Consider	action	a stratifiable program P	2623-1
a stratifiable program P	with	constraint	a stratification	2623-1
a stratification		sequential	σ	2623-1
σ	=	sequential	P 1	2623-1
<B>	.	sequential	<B>	2623-2
<B>	.	sequential	<B>	2623-3
P n		sequential	P n	2623-4
Notice	that	constraint	each program	2623-5
Notice	for	constraint	each program	2623-5
each program		sequential	P	2623-5
P		sequential	i	2623-5
i	in	constraint	the stratification	2623-5
the stratification	if	constraint	P	2623-5
P		sequential	i	2623-5
i	uses	action	the negation	2623-5
the negation	of	constraint	R′	2623-5
R′		sequential	R′ ∈	2623-5
R′ ∈		sequential	edb	2623-5
edb		sequential	P	2623-5
P	that	constraint	edb	2623-5
P	note	action	edb	2623-5
edb		sequential	P i	2623-5
P i	of	constraint	the idb relations	2623-5
P i	may contain	attribute	some	2623-5
the idb relations	of	constraint	P	2623-5
R′	in	constraint	Furthermore edb	2623-6
R′	either	conjunctive	Furthermore edb	2623-6
R′	is	attribute	Furthermore edb	2623-6
Furthermore edb		sequential	P	2623-6
P	by	constraint	some P j preceding P	2623-6
P	or	conjunctive	some P j preceding P	2623-6
P	is defined	action	some P j preceding P	2623-6
some P j preceding P		sequential	i Ii	2623-6
i Ii	=	sequential	Ii−1	2623-6
Ii−1		sequential	∪ P	2623-6
∪ P		sequential	i	2623-6
i		sequential	Ii−1	2623-6
Ii−1		sequential	edb	2623-6
edb		sequential	P	2623-6
P		sequential	i	2623-6
i		sequential	0	2623-6
0		sequential	i ≤	2623-6
i ≤		sequential	n	2623-6
<B>	that	constraint	Ii	2624-1
<B>	Note	action	Ii	2624-1
Ii	extends	action	Ii−1	2624-1
Ii−1	by	constraint	values	2624-1
Ii−1	providing	action	values	2624-1
values	to	constraint	the relations	2624-1
the relations	by	constraint	P	2624-1
the relations	defined	action	P	2624-1
P		sequential	i	2624-1
i	that	constraint	P	2624-1
i	and	conjunctive	P	2624-1
P		sequential	i	2624-1
i		sequential	Ii−1	2624-1
Ii−1		sequential	edb	2624-1
edb		sequential	P i	2624-1
P i	or	conjunctive	P i	2624-1
P i		sequential	Ii−1	2624-1
Ii−1	is	attribute	the semantics	2624-1
the semantics	of	constraint	the semipositive program P	2624-1
the semipositive program P		sequential	i	2624-1
i	to	constraint	the values	2624-1
i	applied	action	the values	2624-1
the values	of	constraint	its edb relations	2624-1
its edb relations	by	constraint	Ii−1	2624-1
its edb relations	provided	action	Ii−1	2624-1
<B>	Let	action	us	2624-2
us	denote	action	the final instance	2624-2
<B>	provides	action	the semantics	2624-3
the semantics	of	constraint	a datalog¬ program	2624-3
a datalog¬ program	under	constraint	a stratification σ	2624-3
Independence	of	constraint	Stratification	2625-1
the different stratifications	Will yield	action	the same semantics	2626-1
<B>		sequential	the answer	2626-2
the answer	is	attribute	<B>	2626-2
Negation	in	constraint	Datalog	2627-1
Lemma		sequential	15.2.9	2628-1
P semi− pos		sequential	I	2629-1
I	Then =	sequential	σ	2629-1
σ		sequential	I	2629-1
I	for	constraint	each instance	2629-1
each instance		sequential	I	2629-1
I		sequential	edb	2629-1
edb		sequential	P	2629-1
Two stratifications	of	constraint	a datalog¬ program	2630-1
a datalog¬ program	if	constraint	they	2630-1
a datalog¬ program	are	attribute	equivalent	2630-1
they	yield	action	the same semantics	2630-1
the same semantics	on	constraint	all inputs	2630-1
Theorem		sequential	15.2.10	2631-1
All stratifications	of	constraint	P	2631-2
P	are	attribute	equivalent	2631-2
Proof	Let	action	GP	2632-1
GP	be	attribute	the precedence graph	2632-1
the precedence graph	of	constraint	P	2632-1
P	and	conjunctive	σ G	2632-1
σ G	=	sequential	Q1	2632-1
<B>	.	sequential	<B>	2632-2
<B>	.	sequential	<B>	2632-3
Qn	be	attribute	stratification	2632-4
stratification		sequential	a P	2632-4
a P	from	constraint	GP	2632-4
a P	constructed	action	GP	2632-4
GP	as	constraint	the proof	2632-4
GP	in	constraint	the proof	2632-4
the proof	of	constraint	Theorem 15.2.7	2632-4
<B>	Let	action	σ	2632-5
σ	=	sequential	P 1	2632-5
<B>	.	sequential	<B>	2632-6
<B>	.	sequential	<B>	2632-7
P k	be	attribute	a stratification	2632-8
a stratification	of	constraint	P	2632-8
It	to	constraint	σ	2632-9
It	that	constraint	σ	2632-9
It	clearly suffices	action	σ	2632-9
It	show	action	σ	2632-9
σ	to	constraint	σ G	2632-9
σ	is	attribute	equivalent	2632-9
The stratification σ P GP	as	constraint	a reference	2632-10
The stratification σ P GP	is used	action	a reference	2632-10
a reference	because	constraint	Lemma 15.2.8	2632-10
a reference	as	constraint	Lemma 15.2.8	2632-10
a reference	in	constraint	Lemma 15.2.8	2632-10
a reference	shown	action	Lemma 15.2.8	2632-10
Lemma 15.2.8		sequential	its strata	2632-10
its strata	among	constraint	all stratifications	2632-10
its strata	are	attribute	the finest possible	2632-10
all stratifications	for	constraint	P	2632-10
We	that	constraint	a sequence Qi1	2633-1
We	say	action	a sequence Qi1	2633-1
<B>	.	sequential	<B>	2633-2
<B>	.	sequential	<B>	2633-3
Qir	of	constraint	the Qi	2633-4
Qir	of	constraint	the Qi	2633-4
the Qi	with	constraint	every l	2633-4
the Qi	if	constraint	every l	2633-4
the Qi	for	constraint	every l	2633-4
the Qi	is	attribute	compatible	2633-4
every l		sequential	m	2633-4
m		sequential	it	2633-4
it	is	attribute	not the case	2633-4
not the case	that	constraint	Qim ≺ Qil	2633-4
We	that	constraint	P	2634-1
We	shall prove	action	P	2634-1
<B>	Before	constraint	we	2635-1
<B>	demonstrating	attribute	these	2635-1
we	that	constraint	the foregoing statements	2635-1
we	argue	action	the foregoing statements	2635-1
the foregoing statements		sequential	1	2635-1
1	through	constraint	3	2635-1
3	to	constraint	σ	2635-1
3	that	constraint	σ	2635-1
3	are	attribute	sufficient	2635-1
3	show	action	σ	2635-1
σ	and	conjunctive	σ	2635-1
σ		sequential	G	2635-1
G	are	attribute	equivalent	2635-1
<B>	By	constraint	statement 2	2635-2
statement 2		sequential	each σ P	2635-2
each σ P		sequential	i	2635-2
i	is	attribute	a stratification i.	2635-2
a stratification i.	of	constraint	P	2635-2
P		sequential	Lemma 15.2.9	2635-2
Lemma 15.2.9	that	constraint	P	2635-2
Lemma 15.2.9	implies	action	P	2635-2
P		sequential	i	2635-2
i	to	constraint	σi	2635-2
i	is	attribute	equivalent	2635-2
It	that	constraint	σ	2635-3
It	follows	action	σ	2635-3
σ	=	sequential	P 1	2635-3
<B>	.	sequential	<B>	2635-4
<B>	.	sequential	<B>	2635-5
P k	to	constraint	<B>	2635-6
P k	σ 1	sequential	<B>	2635-6
P k	is	attribute	equivalent	2635-6
<B>	.	sequential	<B>	2635-7
<B>	.	sequential	<B>	2635-8
σk		sequential	which	2635-9
which	by	constraint	statement 3	2635-9
statement 3	is	attribute	a permutation	2635-9
a permutation	of	constraint	σ G	2635-9
σ G	with	constraint	P	2635-9
P GP	Consider	action	statement 1	2636-1
<B>	that	constraint	one	2636-2
<B>	Note first	action	one	2636-2
one	can obtain	action	σ ′′	2636-2
σ ′′	from	constraint	σ	2636-2
σ	by	constraint	a sequence	2636-2
a sequence	of	constraint	exchanges	2636-2
exchanges	of	constraint	adjacent Qi	2636-2
adjacent Qi		sequential	Qj	2636-2
Qj		sequential	that	2636-2
that		sequential	Qi ≺ Qj	2636-2
Qi ≺ Qj	and	conjunctive	Qj ≺	2636-2
Qj ≺		sequential	Qi	2636-2
Qi		sequential	Exercise	2636-2
Exercise		sequential	15.9	2636-2
it	to	constraint	every such pair	2636-3
it	that	constraint	every such pair	2636-3
it	for	constraint	every such pair	2636-3
it	is	attribute	Thus sufficient	2636-3
it	show	action	every such pair	2636-3
every such pair		sequential	Qi Qj	2636-3
Qi Qj	to	constraint	Qj Qi	2636-3
Qi Qj	is	attribute	equivalent	2636-3
<B>	Because	constraint	Qi ≺	2636-4
Qi ≺		sequential	Qj	2636-4
Qj	and	conjunctive	Qj	2636-4
Qj		sequential	≺ Qi	2636-4
≺ Qi		sequential	it	2636-4
it	that	constraint	no idb relation	2636-4
it	follows	action	no idb relation	2636-4
no idb relation	of	constraint	Qi	2636-4
Qi	in	constraint	Qj	2636-4
Qi	occurs	action	Qj	2636-4
Qj	and	conjunctive	<B>	2636-4
Then Qi		sequential	Then Qi	2637-1
<B>	By	constraint	Lemma 15.2.9	2637-2
Lemma 15.2.9		sequential	Qi Qi	2637-2
Qi Qi		sequential	Qj	2637-2
Qj	and	conjunctive	Qj	2637-2
Qj	to	constraint	Qi ∪ Qj	2637-2
Qj	are	attribute	both equivalent	2637-2
Qi ∪ Qj	as	constraint	a semipositive program	2637-2
a semipositive program		sequential	Qi Qi	2637-2
Qi Qi		sequential	Qj	2637-2
Qj	and	conjunctive	Qj	2637-2
Qj	are	attribute	so equivalent	2637-2
Statement		sequential	2	2638-1
2	from	constraint	Lemma 15.2.8	2638-1
2	follows immediately	action	Lemma 15.2.8	2638-1
<B>	Finally consider	action	statement 3	2639-1
<B>	By	constraint	statement 2	2639-2
statement 2		sequential	each σi	2639-2
each σi	with	constraint	<B>	2639-2
each σi	is	attribute	compatible	2639-2
it	to	constraint	Qm	2639-3
it	that	constraint	Qm	2639-3
it	if	constraint	Qm	2639-3
it	Thus remains	action	Qm	2639-3
it	be shown	action	Qm	2639-3
Qm	in	constraint	σi	2639-3
Qm	occurs	action	σi	2639-3
σi		sequential	Ql	2639-3
Ql	in	constraint	σj	2639-3
Ql	occurs	action	σj	2639-3
σj	and	conjunctive	i	2639-3
i		sequential	j	2639-3
j		sequential	Ql ≺ Qm	2639-3
<B>	that	constraint	Ql	2640-1
<B>	Note	action	Ql	2640-1
Ql	in	constraint	P j	2640-1
Ql	is included	action	P j	2640-1
P j	and	conjunctive	Qm	2640-1
Qm	in	constraint	P	2640-1
Qm	is included	action	P	2640-1
P		sequential	i	2640-1
It	that	constraint	all relations R	2640-2
It	for	constraint	all relations R	2640-2
It	follows	action	all relations R	2640-2
all relations R	by	constraint	Qm	2640-2
all relations R	defined	action	Qm	2640-2
Qm	and	conjunctive	R′	2640-2
R′	by	constraint	Ql	2640-2
R′	defined	action	Ql	2640-2
Ql		sequential	σ	2640-2
σ		sequential	R	2640-2
R		sequential	σ	2640-2
σ		sequential	R′	2640-2
R′		sequential	σ	2640-2
σ	is	attribute	where the stratification function	2640-2
where the stratification function	of	constraint	P 1	2640-2
<B>	.	sequential	<B>	2640-3
<B>	.	sequential	<B>	2640-4
P k. Hence		sequential	R′ ≺ R	2640-5
R′ ≺ R		sequential	so Ql ≺ Qm	2640-5
all stratifications	of	constraint	a given stratifiable program	2641-1
a given stratifiable program	are	attribute	Thus equivalent	2641-1
<B>	that	constraint	we	2641-2
<B>	means	action	we	2641-2
we	about	constraint	the semantics	2641-2
we	can speak	action	the semantics	2641-2
the semantics	of	constraint	such a program	2641-2
such a program	of	constraint	a particular stratification	2641-2
<B>	Given	action	stratifiable datalog¬ program	2641-3
stratifiable datalog¬ program		sequential	a P	2641-3
a P	and	conjunctive	an input	2641-3
an input		sequential	I	2641-3
I		sequential	edb	2641-3
edb		sequential	P	2641-3
P		sequential	we	2641-3
we	as	constraint	the semantics	2641-3
we	shall take	action	the semantics	2641-3
the semantics	of	constraint	P	2641-3
P	on	constraint	I	2641-3
I		sequential	the semantics σ	2641-3
the semantics σ		sequential	I	2641-3
I	of	constraint	any stratification σ	2641-3
any stratification σ	of	constraint	P	2641-3
This semantics	by	constraint	Theorem	2641-4
This semantics	well defined	action	Theorem	2641-4
Theorem		sequential	15.2.10	2641-4
15.2.10	by	constraint	P strat	2641-4
15.2.10	is denoted	action	P strat	2641-4
P strat		sequential	I	2641-4
P strat		sequential	I	2641-5
I	in	constraint	time	2641-5
I	Clearly can be computed	action	time	2641-5
time	with	constraint	respect	2641-5
respect	to	constraint	I	2641-5
<B>	that	constraint	we	2642-1
we	have	action	a semantics	2642-1
we	well defined	action	a semantics	2642-1
a semantics	for	constraint	stratified programs	2642-1
stratified programs		sequential	we	2642-1
we	that	constraint	semipositive programs	2642-1
we	for	constraint	semipositive programs	2642-1
we	can verify	action	semipositive programs	2642-1
semipositive programs		sequential	the semantics	2642-1
the semantics	with	constraint	the semantics	2642-1
the semantics	coincides	action	the semantics	2642-1
the semantics	already introduced	action	<B>	2642-1
<B>	If	constraint	P	2643-1
P	is	attribute	a semipositive datalog¬ program	2643-1
a semipositive datalog¬ program		sequential	P	2643-1
P	is	attribute	also stratifiable	2643-1
<B>	By	constraint	Lemma 15.2.9	2643-2
Lemma 15.2.9		sequential	P semi− pos	2643-2
P semi− pos	and	conjunctive	P strat	2643-2
P strat	are	attribute	equivalent	2643-2
Properties Stratified Semantics	of	constraint	Stratified semantics	2644-1
Stratified semantics	has	action	a procedural flavor	2644-1
a procedural flavor	because	constraint	it	2644-1
it	is	attribute	the result	2644-1
the result	of	constraint	an ordering	2644-1
an ordering	of	constraint	the rules	2644-1
the rules		sequential	<B>	2644-1
What		sequential	we	2644-2
we	about	constraint	P strat	2644-2
we	can say	action	P strat	2644-2
P strat		sequential	I	2644-2
I	from	constraint	model	2644-2
model		sequential	a point	2644-2
a point	of	constraint	view	2644-2
P strat		sequential	I	2644-3
I	is	attribute	Rather pleasantly a minimal model	2644-3
Rather pleasantly a minimal model	of	constraint	P	2644-3
P	containing	action	I	2644-3
no precise characterization	of	constraint	stratified semantics	2644-4
stratified semantics	in	constraint	model	2644-4
model		sequential	terms	2644-4
terms	However has emerged	action	<B>	2644-4
model		sequential	Some properties	2644-5
Some properties	of	constraint	stratified semantics	2644-5
stratified semantics	are established next	action	<B>	2644-5
Proposition		sequential	15.2.11	2645-1
Proof	For	constraint	part	2646-1
part	let	action	σ	2646-1
σ	=	sequential	P 1	2646-1
<B>	.	sequential	<B>	2646-2
<B>	.	sequential	<B>	2646-3
P	be	attribute	n a stratification	2646-4
n a stratification	of	constraint	P	2646-4
P	and	conjunctive	I	2646-4
I		sequential	an instance	2646-4
an instance	over	constraint	edb	2646-4
edb		sequential	P	2646-4
We	to	constraint	P strat	2646-5
We	that	constraint	P strat	2646-5
We	have	action	P strat	2646-5
We	show	action	P strat	2646-5
P strat		sequential	I	2646-5
I	is	attribute	a minimal model	2646-5
a minimal model	of	constraint	P	2646-5
P		sequential	whose restriction	2646-5
whose restriction	to	constraint	edb	2646-5
edb		sequential	P	2646-5
P	equals	action	I	2646-5
P strat		sequential	I	2646-6
I	is	attribute	Clearly a model	2646-6
Clearly a model	of	constraint	P	2646-6
P		sequential	whose restriction	2646-6
whose restriction	to	constraint	edb	2646-6
edb		sequential	P	2646-6
P	equals	action	I	2646-6
<B>	To	constraint	its minimality	2647-1
<B>	prove	action	its minimality	2647-1
its minimality		sequential	it	2647-1
it	to	constraint	each model	2647-1
it	that	constraint	each model	2647-1
it	for	constraint	each model	2647-1
it	is	attribute	sufficient	2647-1
it	show	action	each model	2647-1
each model		sequential	J	2647-1
J	of	constraint	P	2647-1
P	if	constraint	I	2647-1
I	⊆	action	J ⊆ P strat J	2647-1
J ⊆ P strat J		sequential	I	2647-1
I		sequential	P strat	2647-1
P strat		sequential	I	2647-1
<B>	Thus suppose	action	I	2648-1
I	⊆	action	J ⊆ P strat	2648-1
J ⊆ P strat		sequential	I	2648-1
We	by	constraint	induction	2648-2
We	prove	action	induction	2648-2
induction	on	constraint	k	2648-2
k		sequential	† P strat	2648-2
† P strat		sequential	I	2648-2
I		sequential	sch	2648-2
sch		sequential	∪i≤	2648-2
∪i≤		sequential	kP i	2648-2
kP i	=	sequential	<B>	2648-2
<B>	For	constraint	k	2649-1
k	=	sequential	1	2649-1
1		sequential	edb ⊆	2649-1
edb ⊆		sequential	P	2649-1
P		sequential	1	2649-1
1		sequential	edb	2649-1
edb		sequential	P	2649-1
P		sequential	so P strat	2649-1
so P strat		sequential	I	2649-1
I		sequential	edb	2649-1
edb		sequential	P	2649-1
P		sequential	1	2649-1
1	=	sequential	I|	2649-1
I|		sequential	edb	2649-1
edb		sequential	P	2649-1
P		sequential	1	2649-1
1	=	sequential	J| edb	2649-1
J| edb		sequential	P	2649-1
P		sequential	1	2649-1
<B>	By	constraint	the definition	2650-1
the definition	of	constraint	stratified semantics	2650-1
stratified semantics	and	conjunctive	Theorem 15.2.2	2650-1
Theorem 15.2.2		sequential	P strat	2650-1
P strat		sequential	I	2650-1
I		sequential	sch	2650-1
sch		sequential	P	2650-1
P		sequential	1	2650-1
1	is	attribute	Negation	2650-1
Negation	in	constraint	Datalog	2650-1
Datalog		sequential	the minimum model	2650-1
the minimum model	of	constraint	P1	2650-1
P1		sequential	whose restriction	2650-1
whose restriction	to	constraint	edb	2650-1
edb		sequential	P	2650-1
P		sequential	1	2650-1
1	equals	action	P strat	2650-1
P strat		sequential	I	2650-1
I		sequential	edb	2650-1
edb		sequential	P	2650-1
P		sequential	1	2650-1
<B>	On	constraint	the other hand	2650-2
the other hand		sequential	J| sch	2650-2
J| sch		sequential	P	2650-2
P		sequential	1	2650-2
1	is	attribute	also a model	2650-2
also a model	of	constraint	P1	2650-2
P1		sequential	whose restriction	2650-2
whose restriction	to	constraint	edb	2650-2
edb		sequential	P	2650-2
P		sequential	1	2650-2
1	equals	action	P strat	2650-2
P strat		sequential	I	2650-2
I		sequential	edb	2650-2
edb		sequential	P	2650-2
P		sequential	1	2650-2
<B>	From	constraint	the minimality	2650-3
the minimality	of	constraint	P strat	2650-3
P strat		sequential	I	2650-3
I		sequential	sch	2650-3
sch		sequential	P	2650-3
P		sequential	1	2650-3
1		sequential	it	2650-3
it	that	constraint	P strat	2650-3
it	follows	action	P strat	2650-3
P strat		sequential	I	2650-3
I		sequential	sch	2650-3
sch		sequential	P	2650-3
P		sequential	1	2650-3
1		sequential	⊆ J| sch	2650-3
⊆ J| sch		sequential	P	2650-3
P		sequential	1	2650-3
it	that	constraint	P strat	2651-1
it	From follows	action	P strat	2651-1
P strat		sequential	I	2651-1
I		sequential	sch	2651-1
sch		sequential	P	2651-1
P		sequential	1	2651-1
1	=	sequential	J| sch	2651-1
J| sch		sequential	P	2651-1
P		sequential	1	2651-1
1		sequential	which	2651-1
which	establishes	action	†	2651-1
†	for	constraint	k	2651-1
k	=	sequential	1	2651-1
<B>	For	constraint	the induction step	2651-2
the induction step	for	constraint	k	2651-2
the induction step	suppose	attribute	† true	2651-2
the induction step	is	attribute	† true	2651-2
k		sequential	1	2651-2
1	≤	sequential	k	2651-2
k		sequential	n	2651-2
<B>	for	constraint	1 ≤ k ≤	2651-3
<B>	proves †	action	1 ≤ k ≤	2651-3
1 ≤ k ≤	n	conjunctive	<B>	2651-3
The proof	of	constraint	part	2652-1
part	for	constraint	Exercise 15.12	2652-1
part	b is left	action	Exercise 15.12	2652-1
There	is	attribute	another appealing property	2653-1
another appealing property	of	constraint	stratified semantics	2653-1
stratified semantics		sequential	that	2653-1
that	into	constraint	account	2653-1
that	takes	action	account	2653-1
account		sequential	the syntax	2653-1
the syntax	of	constraint	the program	2653-1
the program	in	constraint	addition	2653-1
addition	to	constraint	model	2653-1
model		sequential	purely considerations	2653-1
This property	is illustrated next	action	<B>	2653-2
<B>	Consider	action	the two programs	2654-1
the two programs		sequential	P5	2654-1
P5	=	sequential	p	2654-1
P5	{	sequential	p	2654-1
p	←	sequential	P6	2654-1
p	¬q	sequential	P6	2654-1
p	}	sequential	P6	2654-1
P6	=	sequential	q	2654-1
P6	{	sequential	q	2654-1
q		sequential	¬p	2654-1
¬p		sequential	}	2654-1
}	From	constraint	the perspective	2654-1
the perspective	of	constraint	classical logic	2654-1
classical logic		sequential	P	2654-1
P	and	conjunctive	P6 P6 P5	2654-1
P6 P6 P5	whereas	constraint	TP	2654-1
P6 P6 P5	of	constraint	TP	2654-1
TP	is	attribute	q	2654-1
<B>	by	constraint	the notion	2654-2
<B>	is partially captured	action	the notion	2654-2
the notion	of	constraint	<B>	2654-2
the notion	as	constraint	<B>	2654-2
the notion	supported	action	<B>	2654-2
the notion	follows	action	<B>	2654-2
<B>	Let	action	datalog¬ program P	2655-1
datalog¬ program P	and	conjunctive	input	2655-1
input		sequential	I	2655-1
I	be given	action	<B>	2655-1
<B>	As with	constraint	pure datalog	2655-2
pure datalog		sequential	J	2655-2
J	is	attribute	a model	2655-2
a model	of	constraint	P iff	2655-2
P iff		sequential	J	2655-2
J		sequential	TP	2655-2
TP		sequential	J	2655-2
We	that	constraint	J	2655-3
We	say	action	J	2655-3
J	is	attribute	a supported model	2655-3
a supported model	if	constraint	J ⊆ TP	2655-3
J ⊆ TP		sequential	J	2655-3
J	if	constraint	each fact	2655-3
each fact	in	constraint	J	2655-3
J	is	attribute	<B>	2655-3
The proof following	of	constraint	the reader	2656-1
The proof following	to	constraint	the reader	2656-1
The proof following	is left	action	the reader	2656-1
the reader		sequential	Exercise	2656-1
Exercise		sequential	15.13	2656-1
Proposition		sequential	15.2.12	2657-1
We	that	constraint	stratification	2658-1
We	have seen	action	stratification	2658-1
stratification	and	conjunctive	an approach	2658-1
stratification	provides	attribute	elegant	2658-1
an approach	to	constraint	semantics	2658-1
an approach	defining	action	semantics	2658-1
semantics	of	constraint	datalog¬ programs	2658-1
it	Nonetheless has	action	two major limitations	2658-2
it	First does not provide	action	semantics	2658-3
semantics	to	constraint	all datalog¬ programs	2658-3
<B>		sequential	stratified datalog¬ programs	2658-4
stratified datalog¬ programs	with	constraint	regard	2658-4
stratified datalog¬ programs	are	attribute	not entirely satisfactory	2658-4
regard	to	constraint	expressive power	2658-4
<B>	From	constraint	a computational point	2658-5
a computational point	of	constraint	view	2658-5
view		sequential	they	2658-5
they	provide	action	recursion	2658-5
recursion	and	conjunctive	negation	2658-5
negation	and	conjunctive	<B>	2658-5
negation	are	attribute	inflationary	2658-5
<B>	as	constraint	Chapter 14	2658-6
<B>	in	constraint	Chapter 14	2658-6
<B>	discussed	action	Chapter 14	2658-6
Chapter 14		sequential	one	2658-6
one	that	constraint	they	2658-6
one	Therefore might expect	action	they	2658-6
they	express	action	the fixpoint queries	2658-6
<B>		sequential	stratified datalog¬ programs	2658-7
stratified datalog¬ programs	of	constraint	all such queries	2658-7
stratified datalog¬ programs	fall	attribute	short	2658-7
stratified datalog¬ programs	expressing	action	all such queries	2658-7
all such queries	as	constraint	Section 15.4	2658-7
all such queries	in	constraint	Section 15.4	2658-7
all such queries	will be shown	action	Section 15.4	2658-7
<B>	because	constraint	the stratification condition	2658-8
<B>	is	attribute	the stratification condition	2658-8
the stratification condition	prohibits	attribute	recursive	2658-8
<B>	For	constraint	these reasons	2659-1
these reasons		sequential	we	2659-1
we	consider	action	another semantics	2659-1
another semantics	for	constraint	datalog¬ programs	2659-1
datalog¬ programs	called	action	<B>	2659-1
datalog¬ programs	well founded	action	<B>	2659-1
<B>	As	constraint	we	2659-2
we	shall see	attribute	this	2659-2
we	provides	action	semantics	2659-2
semantics	to	constraint	all datalog¬ programs	2659-2
all datalog¬ programs	and	conjunctive	all fixpoint queries	2659-2
all datalog¬ programs	expresses	action	all fixpoint queries	2659-2
<B>	and	conjunctive	semantics	2659-3
<B>	founded	action	semantics	2659-3
<B>	stratified	action	semantics	2659-3
semantics	on	constraint	stratified datalog¬ programs	2659-3
semantics	agree	action	stratified datalog¬ programs	2659-3
<B>	Founded	action	Semantics	2660-1
we	that	constraint	the answer	2660-2
we	So far required	action	the answer	2660-2
the answer	must provide	action	information	2660-2
information	on	constraint	the truth	2660-2
the truth	or	conjunctive	falsehood	2660-2
falsehood	of	constraint	every fact	2660-2
<B>	founded	action	semantics	2660-3
semantics	on	constraint	the idea	2660-3
semantics	is based	action	the idea	2660-3
the idea	that	constraint	a given program	2660-3
a given program	may not necessarily provide	action	such information	2660-3
such information	on	constraint	all facts	2660-3
some facts	to	constraint	it	2660-4
some facts	be	attribute	Instead may simply indifferent	2660-4
it	and	conjunctive	the answer	2660-4
the answer	to	constraint	the truth value	2660-4
the answer	that	constraint	the truth value	2660-4
the answer	should be allowed	action	the truth value	2660-4
the answer	say	action	the truth value	2660-4
the truth value	of	constraint	those facts	2660-4
those facts	is	attribute	unknown	2660-4
<B>	As	constraint	it	2660-5
it	turns out	action	relaxing expectations	2660-5
relaxing expectations	about	constraint	the answer	2660-5
the answer	in	constraint	this fashion	2660-5
this fashion	allows	action	us	2660-5
us	to	constraint	a natural semantics	2660-5
us	provide	action	a natural semantics	2660-5
a natural semantics	for	constraint	all datalog¬ programs	2660-5
The price	that	constraint	the answer	2660-6
The price	is	attribute	the answer	2660-6
the answer	to	constraint	total information	2660-6
the answer	is no longer guaranteed	action	total information	2660-6
the answer	provide	action	total information	2660-6
This section	by	constraint	a largely declarative semantics	2661-1
This section	begins	action	a largely declarative semantics	2661-1
This section	introducing	action	a largely declarative semantics	2661-1
a largely declarative semantics	for	constraint	datalog¬ programs	2661-1
an equivalent fixpoint semantics	Next is developed	action	<B>	2661-2
it	that	constraint	semantics	2661-3
it	and	conjunctive	semantics	2661-3
it	Finally is shown	action	semantics	2661-3
it	stratified	action	semantics	2661-3
it	well founded	action	semantics	2661-3
semantics	on	constraint	the family	2661-3
semantics	agree	action	the family	2661-3
the family	of	constraint	stratified datalog¬ programs	2661-3
The aim	of	constraint	semantics	2662-1
The aim	giving	action	semantics	2662-1
semantics	to	constraint	a datalog¬ program	2662-1
a datalog¬ program		sequential	P	2662-1
P	to	constraint	an appropriate model	2662-1
P	be	attribute	an appropriate model	2662-1
P	will find	action	an appropriate model	2662-1
P	3 valued	action	an appropriate model	2662-1
an appropriate model		sequential	I	2662-1
I	of	constraint	P	2662-1
<B>	In	constraint	it	2662-2
<B>	considering	attribute	what appropriate	2662-2
<B>	might mean	action	it	2662-2
it	to	constraint	the basic motivation	2662-2
it	is	attribute	useful	2662-2
it	recall	action	the basic motivation	2662-2
the basic motivation	underlying	action	logic programming	2662-2
logic programming		sequential	the approach	2662-2
the approach	to	constraint	negation	2662-2
negation	as opposed to	constraint	the purely computational approach	2662-2
An important goal	to	constraint	some form	2662-3
An important goal	is	attribute	some form	2662-3
An important goal	model	action	some form	2662-3
some form	of	constraint	natural reasoning process	2662-3
<B>	In	constraint	consistency	2662-4
consistency	in	constraint	the reasoning process	2662-4
the reasoning process	is required	action	<B>	2662-4
one	Specifically can not use	action	a fact	2663-1
a fact	and	conjunctive	its negation	2663-1
a fact	later infer	action	its negation	2663-1
<B>	in	constraint	the notion	2663-2
<B>	should be captured	action	the notion	2663-2
the notion	of	constraint	appropriateness	2663-2
appropriateness	of	constraint	a model I	2663-2
appropriateness	3 valued	action	a model I	2663-2
a model I	and	conjunctive	it	2663-2
it	has	action	two intuitive aspects	2663-2
Negation	in	constraint	Datalog Example 15.3.1	2664-1
<B>	.	sequential	<B>	2664-2
<B>	.	sequential	<B>	2664-3
<B>	.	sequential	<B>	2664-4
The game	between	constraint	two players	2664-5
The game	is	attribute	two players	2664-5
The possible moves	of	constraint	the games	2664-6
the games	in	constraint	a binary relation moves	2664-6
the games	are held	action	a binary relation moves	2664-6
A tuple		sequential	a	2664-7
a	in	constraint	b moves	2664-7
b moves	that	constraint	state	2664-7
b moves	in	constraint	state	2664-7
b moves	indicates	action	state	2664-7
state		sequential	one	2664-7
one	to	constraint	state b	2664-7
one	to	constraint	state b	2664-7
one	when can choose	action	state b	2664-7
one	move	action	state b	2664-7
A player	if	constraint	he	2664-8
A player	loses	action	he	2664-8
he	or	conjunctive	she	2664-8
she	in	constraint	a state	2664-8
she	is	attribute	a state	2664-8
a state	from	constraint	which	2664-8
which		sequential	there	2664-8
there	are	attribute	no moves	2664-8
The goal	to	constraint	the set	2664-9
The goal	is	attribute	the set	2664-9
The goal	compute	action	the set	2664-9
the set	of	constraint	winning states	2664-9
winning states		sequential	the set	2664-9
the set	of	constraint	states	2664-9
states		sequential	there	2664-9
there	exists	action	a winning strategy	2664-9
a winning strategy	for	constraint	a player	2664-9
a player	in	constraint	this state	2664-9
<B>	in	constraint	a unary predicate win	2664-10
<B>	are obtained	action	a unary predicate win	2664-10
<B>	Consider	action	the input K	2665-1
the input K	with	constraint	the following value	2665-1
the following value	for	constraint	moves	2665-1
moves		sequential	K	2665-1
K		sequential	moves	2665-1
moves	=	sequential	b	2665-1
b		sequential	c	2665-1
c		sequential	c	2665-1
c		sequential	a	2665-1
a		sequential	a	2665-1
a		sequential	b	2665-1
b		sequential	a	2665-1
a		sequential	d	2665-1
d		sequential	d	2665-1
d		sequential	e	2665-1
e		sequential	d	2665-1
d		sequential	f	2665-1
f		sequential	f	2665-1
f		sequential	g	2665-1
g		sequential	the input	2665-1
the input	as	constraint	b c e d f	2665-1
the input	Graphically is represented	action	b c e d f	2665-1
b c e d f		sequential	g	2665-1
<B>	is	attribute	the fact	2665-2
the fact	that	constraint	there	2665-2
there	is	attribute	no winning strategy	2665-2
no winning strategy	from	constraint	states	2665-2
no winning strategy	of	constraint	states	2665-2
states		sequential	b	2665-2
b	or	conjunctive	c	2665-2
<B>	Now consider	action	the following nonstratifiable program	2666-1
the following nonstratifiable program		sequential	P win	2666-1
P win		sequential	win	2666-1
win		sequential	x	2666-1
x		sequential	moves	2666-1
moves		sequential	x	2666-1
x		sequential	y	2666-1
y		sequential	¬ win	2666-1
¬ win		sequential	y	2666-1
We	now exhibit	action	a model	2666-2
We	3 valued	action	a model	2666-2
a model		sequential	J	2666-2
J	of	constraint	P win	2666-2
P win		sequential	that	2666-2
that	with	constraint	K	2666-2
that	agrees	action	K	2666-2
K	on	constraint	moves	2666-2
<B>	As	constraint	fact	2666-3
<B>	in	constraint	fact	2666-3
<B>	will be seen	attribute	this	2666-3
fact	be	attribute	will the semantics	2666-3
fact	well founded	action	will the semantics	2666-3
will the semantics	of	constraint	P win	2666-3
P win	on	constraint	input	2666-3
input		sequential	K.	2666-3
K.		sequential	Instance J	2666-3
Instance J	that	constraint	J	2666-3
Instance J	is	attribute	such	2666-3
J		sequential	moves	2666-3
moves	=	sequential	K	2666-3
K		sequential	moves	2666-3
moves	and	conjunctive	the values	2666-3
the values	of	constraint	win-atoms	2666-3
win-atoms	as	constraint	true win	2666-3
win-atoms	are given	action	true win	2666-3
win-atoms	follows	action	true win	2666-3
true win		sequential	d	2666-3
d	win	action	f	2666-3
f		sequential	false win	2666-3
false win		sequential	e	2666-3
e	win	action	g	2666-3
g		sequential	unknown win	2666-3
unknown win	win	action	c	2666-3
unknown win	win	action	c	2666-3
We	in	constraint	three steps	2666-4
We	do	attribute	this	2666-4
we	First define	action	the notion	2666-5
the notion	of	constraint	instance	2666-5
the notion	3 valued	action	instance	2666-5
instance	and	conjunctive	the notion	2666-5
instance	extend	action	the notion	2666-5
the notion	of	constraint	truth value	2666-5
truth value	and	conjunctive	satisfaction	2666-5
we	Then consider	action	datalog	2666-6
datalog	and	conjunctive	the existence	2666-6
datalog	show	action	the existence	2666-6
the existence	of	constraint	a minimum model	2666-6
the existence	3 valued	action	a minimum model	2666-6
a minimum model	for	constraint	each datalog program	2666-6
we	Finally consider	action	datalog¬	2666-7
datalog¬	and	conjunctive	the notion	2666-7
the notion	of	constraint	model	2666-7
model		sequential	which	2666-7
which	is	attribute	the basis	2666-7
the basis	of	constraint	semantics	2666-7
the basis	founded	action	semantics	2666-7
<B>	with	constraint	three truth values	2667-1
<B>	Dealing	action	three truth values	2667-1
three truth values		sequential	the usual two	2667-1
the usual two	of	constraint	the basic notions	2667-1
the usual two	requires	attribute	some	2667-1
the usual two	extending	attribute	some	2667-1
the basic notions	like	constraint	instance	2667-1
instance	and	conjunctive	model	2667-1
<B>	As	constraint	we	2667-2
we	shall see	attribute	this	2667-2
we	is	attribute	straightforward	2667-2
We	by	constraint	1	2667-3
We	will denote	attribute	true	2667-3
1	by	constraint	0	2667-3
0	by	constraint	1/2	2667-3
0	and	conjunctive	1/2	2667-3
<B>	Consider	action	a datalog¬ program P	2668-1
a datalog¬ program P	and	conjunctive	a classical instance I	2668-1
a datalog¬ program P	2 valued	action	a classical instance I	2668-1
<B>	As	constraint	the discussion	2668-2
<B>	in	constraint	the discussion	2668-2
<B>	was done	action	the discussion	2668-2
the discussion	of	constraint	SLD resolution	2668-2
SLD resolution	in	constraint	Chapter 12	2668-2
Chapter 12		sequential	we	2668-2
we	by	constraint	PI	2668-2
we	shall denote	action	PI	2668-2
PI		sequential	the program	2668-2
the program	from	constraint	P	2668-2
the program	obtained	action	P	2668-2
P	by	constraint	P unit clauses	2668-2
P	to	constraint	P unit clauses	2668-2
P	adding	action	P unit clauses	2668-2
P unit clauses	that	constraint	the facts	2668-2
P unit clauses	stating	action	the facts	2668-2
the facts	in	constraint	I	2668-2
I	are	attribute	true	2668-2
P		sequential	I	2668-3
I	Then =	sequential	PI	2668-3
PI		sequential	∅	2668-3
<B>	For	constraint	the moment	2669-1
the moment		sequential	we	2669-1
we	with	constraint	datalog¬ programs	2669-1
we	shall deal	action	datalog¬ programs	2669-1
datalog¬ programs		sequential	whose input	2669-1
whose input	in	constraint	the program	2669-1
whose input	is included	action	the program	2669-1
<B>	that	constraint	B	2669-2
<B>	Recall	action	B	2669-2
B		sequential	P	2669-2
P	denotes	action	all facts	2669-2
all facts	of	constraint	the form	2669-2
the form		sequential	R	2669-2
R		sequential	a 1	2669-2
<B>	.	sequential	<B>	2669-3
<B>	.	sequential	<B>	2669-4
ak		sequential	R	2669-5
R	is	attribute	where a relation	2669-5
where a relation	and	conjunctive	a 1	2669-5
<B>	.	sequential	<B>	2669-6
<B>	.	sequential	<B>	2669-7
ak constants	in	constraint	P	2669-8
ak constants	occurring	action	P	2669-8
<B>	In	constraint	B	2669-9
B		sequential	PI	2669-9
PI	=	sequential	B	2669-9
B		sequential	P	2669-9
P		sequential	I	2669-9
<B>	Let	action	P	2670-1
P	be	attribute	a datalog¬ program	2670-1
<B>	3 valued	action	A instance	2670-2
A instance		sequential	I	2670-2
I	over	constraint	sch	2670-2
sch		sequential	P	2670-2
P	is	attribute	a total mapping	2670-2
a total mapping	from	constraint	B	2670-2
B		sequential	P	2670-2
P	to	constraint	0	2670-2
P	{	sequential	0	2670-2
0		sequential	1/2	2670-2
1/2		sequential	1 }	2670-2
We	by	constraint	I1	2670-3
We	denote	action	I1	2670-3
I1		sequential	I1/2	2670-3
I1/2	and	conjunctive	I0	2670-3
I0		sequential	the set	2670-3
the set	of	constraint	atoms	2670-3
atoms	in	constraint	B	2670-3
B		sequential	P	2670-3
P		sequential	whose truth value	2670-3
whose truth value	is	attribute	1	2670-3
1		sequential	1/2	2670-3
1/2	and	conjunctive	0 respectively	2670-3
<B>	3 valued	action	A instance	2670-4
A instance		sequential	I	2670-4
I	if	constraint	I1/2	2670-4
I	or	conjunctive	I1/2	2670-4
I	is	attribute	total	2670-4
I	2 valued	action	I1/2	2670-4
I1/2	=	sequential	<B>	2670-4
I1/2	∅	sequential	<B>	2670-4
There	is	attribute	a natural ordering	2671-1
a natural ordering	among	constraint	instances	2671-1
a natural ordering	3 valued	action	instances	2671-1
instances	over	constraint	sch	2671-1
sch		sequential	P	2671-1
P	by	constraint	I	2671-1
P	defined	action	I	2671-1
I	≺	action	J iff	2671-1
J iff	for	constraint	each A ∈ B	2671-1
each A ∈ B		sequential	P	2671-1
P		sequential	I	2671-1
I		sequential	A ≤	2671-1
A ≤		sequential	J	2671-1
J		sequential	A	2671-1
<B>	that	constraint	I1 ⊆ J1	2672-1
<B>	to	constraint	I1 ⊆ J1	2672-1
<B>	Note	attribute	this	2672-1
<B>	is	attribute	equivalent	2672-1
I1 ⊆ J1	and	conjunctive	I0	2672-1
I0		sequential	⊇ J0	2672-1
⊇ J0	that	constraint	it	2672-1
⊇ J0	and	conjunctive	it	2672-1
it	generalizes	action	containment	2672-1
containment	for	constraint	instances	2672-1
containment	2 valued	action	instances	2672-1
we	Occasionally will represent	action	a instance	2673-1
we	3 valued	action	a instance	2673-1
a instance	by	constraint	the facts	2673-1
a instance	and	conjunctive	the facts	2673-1
a instance	listing	attribute	positive	2673-1
the facts	and	conjunctive	the undefined ones	2673-1
the facts	omitting	action	the undefined ones	2673-1
<B>	For	constraint	example	2673-2
example	3 valued	action	the instance I	2673-2
the instance I		sequential	I	2673-2
I		sequential	p	2673-2
<B>	Given	action	a instance	2674-1
<B>	3 valued	action	a instance	2674-1
a instance		sequential	I	2674-1
I		sequential	we	2674-1
we	next define	action	the truth value	2674-1
the truth value	of	constraint	Boolean combinations	2674-1
Boolean combinations	of	constraint	facts	2674-1
facts	using	action	the connectives	2674-1
the connectives		sequential	∨	2674-1
∨		sequential	∧	2674-1
∧	¬	sequential	<B>	2674-1
∧	←	sequential	<B>	2674-1
The truth value	of	constraint	a Boolean combination	2674-2
a Boolean combination		sequential	α	2674-2
α	of	constraint	facts	2674-2
facts	by	constraint	I	2674-2
facts	is denoted	action	I	2674-2
I		sequential	α	2674-2
α	by	constraint	<B>	2674-2
α	defined	action	<B>	2674-2
The reader	be	attribute	should careful	2675-1
Known facts	about	constraint	Boolean operators	2675-1
Boolean operators	in	constraint	the context	2675-1
Boolean operators	2 valued	action	the context	2675-1
the context	in	constraint	this more complex one	2675-1
the context	may not hold	action	this more complex one	2675-1
<B>	For	constraint	instance	2675-2
instance	that	constraint	the truth value	2675-2
instance	note	action	the truth value	2675-2
the truth value	of	constraint	p	2675-2
p	←	sequential	q	2675-2
q	from	constraint	p ¬q	2675-2
q	of	constraint	p ¬q	2675-2
q	be	attribute	may different	2675-2
p ¬q		sequential	∨	2675-2
∨	see	action	Exercise 15.15	2675-2
<B>	To	constraint	the preceding definition	2675-3
<B>	that	constraint	the preceding definition	2675-3
<B>	see	action	the preceding definition	2675-3
the preceding definition	matches	action	the intuition	2675-3
the intuition		sequential	one	2675-3
one	to	constraint	the specific semantics	2675-3
one	that	constraint	the specific semantics	2675-3
one	with	constraint	the specific semantics	2675-3
one	might want	action	the specific semantics	2675-3
one	verify	action	the specific semantics	2675-3
the specific semantics	of	constraint	the instance	2675-3
the specific semantics	← used here	action	the instance	2675-3
the instance		sequential	J	2675-3
J	of	constraint	Example 15.3.1	2675-3
Example 15.3.1	does satisfy	action	the ground instantiation	2675-3
the ground instantiation	of	constraint	P win K	2675-3
Example		sequential	15.3.2	2676-1
Negation	in	constraint	Datalog	2677-1
The second	because ˆJ	constraint	¬ win	2677-2
The second	is	attribute	true	2677-2
¬ win		sequential	b	2677-2
b	=	sequential	1/2	2677-2
1/2		sequential	ˆJ	2677-2
ˆJ		sequential	moves	2677-2
moves		sequential	a	2677-2
a		sequential	b	2677-2
b	=	sequential	1	2677-2
1		sequential	ˆJ	2677-2
ˆJ		sequential	win	2677-2
win		sequential	<B>	2677-2
<B>	that	constraint	the other hand	2678-1
<B>	on	constraint	the other hand	2678-1
<B>	Observe	action	the other hand	2678-1
We	next extend	action	the definition	2679-1
the definition	and	conjunctive	semantics	2679-1
semantics	of	constraint	datalog programs	2679-1
datalog programs	to	constraint	the context	2679-1
the context	of	constraint	instances	2679-1
the context	3 valued	action	instances	2679-1
<B>	Although	constraint	datalog programs	2679-2
datalog programs	do not contain	action	negation	2679-2
negation		sequential	they	2679-2
they	to	constraint	facts	2679-2
they	and	conjunctive	facts	2679-2
they	will now be allowed	attribute	positive	2679-2
they	infer	attribute	positive	2679-2
The syntax	of	constraint	a datalog program	2680-1
The syntax	3 extended	action	a datalog program	2680-1
a datalog program	as	constraint	datalog	2680-1
a datalog program	for	constraint	datalog	2680-1
a datalog program	is	attribute	the same	2680-1
datalog	except	constraint	the truth values	2680-1
datalog	that	constraint	the truth values	2680-1
the truth values		sequential	0	2680-1
0		sequential	1/2	2680-1
1/2	and	conjunctive	1	2680-1
1	as	constraint	literals	2680-1
1	can occur	action	literals	2680-1
literals	in	constraint	bodies	2680-1
bodies	of	constraint	rules	2680-1
<B>	Given	action	a datalog program	2680-2
<B>	3 extended	action	a datalog program	2680-2
a datalog program		sequential	P	2680-2
P	3 valued	action	the immediate consequence operator	2680-2
the immediate consequence operator		sequential	3	2680-2
3		sequential	T P	2680-2
T P	of	constraint	P	2680-2
P	is	attribute	a mapping	2680-2
a mapping	on	constraint	instances	2680-2
a mapping	3 valued	action	instances	2680-2
instances	over	constraint	sch	2680-2
sch		sequential	P	2680-2
P	as	constraint	<B>	2680-2
P	defined	action	<B>	2680-2
P	follows	action	<B>	2680-2
<B>	Given	action	a instance	2680-3
<B>	3 valued	action	a instance	2680-3
a instance	and	conjunctive	I A ∈ B	2680-3
I A ∈ B		sequential	P	2680-3
P		sequential	3	2680-3
3		sequential	T	2680-3
T		sequential	P	2680-3
P		sequential	I	2680-3
I		sequential	A	2680-3
A	is	attribute	<B>	2680-3
Example		sequential	15.3.3	2681-1
<B>		sequential	<B>	2681-2
<B>	In	constraint	the instances	2682-1
<B>	following	action	the instances	2682-1
<B>	3 valued	action	the instances	2682-1
the instances	with	constraint	respect	2682-1
the instances	are compared	action	respect	2682-1
respect	to	constraint	<B>	2682-1
respect	≺	sequential	<B>	2682-1
<B>		sequential	<B>	2682-2
<B>	With	constraint	the preceding definitions	2683-1
the preceding definitions		sequential	extended datalog programs	2683-1
extended datalog programs	on	constraint	instances	2683-1
extended datalog programs	3 valued	action	instances	2683-1
instances	to	constraint	classical programs	2683-1
instances	behave similarly	action	classical programs	2683-1
The next lemma	can be verified easily	action	Exercise 15.16	2683-2
Exercise 15.16		sequential	Lemma 15.3.4	2683-2
P		sequential	i 0	2683-3
i 0	to	constraint	the least fixpoint	2683-3
i 0	and	conjunctive	the least fixpoint	2683-3
i 0	Then is increasing	action	the least fixpoint	2683-3
i 0	converges	action	the least fixpoint	2683-3
the least fixpoint	of	constraint	3	2683-3
3	-	sequential	TP	2683-3
The semantics	of	constraint	an extended datalog program	2684-1
an extended datalog program	is	attribute	the minimum model	2684-1
an extended datalog program	3 valued	action	the minimum model	2684-1
the minimum model	of	constraint	P	2684-1
We	to	constraint	datalog¬ programs	2685-1
We	at	constraint	datalog¬ programs	2685-1
We	are	attribute	now ready	2685-1
We	look	action	datalog¬ programs	2685-1
datalog¬ programs	and	conjunctive	models	2685-1
datalog¬ programs	formally define	attribute	3 stable	2685-1
models	of	constraint	a datalog¬ program P	2685-1
We		sequential	bootstrap	2685-2
bootstrap	to	constraint	the semantics	2685-2
the semantics	of	constraint	programs	2685-2
programs	with	constraint	negation	2685-2
negation	using	action	the semantics	2685-2
the semantics	for	constraint	datalog programs	2685-2
the semantics	3 extended	action	datalog programs	2685-2
datalog programs	described earlier	action	<B>	2685-2
<B>	Let	action	I	2685-3
I	be	attribute	a instance	2685-3
I	3 valued	action	a instance	2685-3
a instance	over	constraint	sch	2685-3
sch		sequential	P	2685-3
We	reduce	action	the problem	2685-4
the problem	to	constraint	a positive datalog program	2685-4
the problem	of	constraint	a positive datalog program	2685-4
the problem	applying	action	a positive datalog program	2685-4
a positive datalog program	as	constraint	<B>	2685-4
a positive datalog program	follows	action	<B>	2685-4
The positivized ground version	of	constraint	P	2685-5
P	given	action	I pg	2685-5
P	denoted	action	I pg	2685-5
I pg		sequential	P	2685-5
P		sequential	I	2685-5
I	is	attribute	the datalog program	2685-5
I	3 extended	action	the datalog program	2685-5
the datalog program	from	constraint	ground	2685-5
the datalog program	obtained	action	ground	2685-5
ground		sequential	P	2685-5
P	by	constraint	each negative premise A	2685-5
P	replacing	action	each negative premise A	2685-5
each negative premise A	by	constraint	Î	2685-5
Î		sequential	¬	2685-5
¬		sequential	A	2685-5
A		sequential	0	2685-5
0		sequential	1	2685-5
1	or	conjunctive	1/2	2685-5
<B>	Because	constraint	all negative literals	2685-6
all negative literals	in	constraint	ground	2685-6
ground		sequential	P	2685-6
P	by	constraint	their truth value	2685-6
P	have been replaced	action	their truth value	2685-6
their truth value	in	constraint	I	2685-6
I		sequential	pg	2685-6
pg		sequential	P	2685-6
P		sequential	I	2685-6
I	is	attribute	now a datalog program	2685-6
I	3 extended	action	now a datalog program	2685-6
now a datalog program		sequential	i.e a program	2685-6
i.e a program	without	constraint	negation	2685-6
Its least fixpoint pg		sequential	P	2685-7
P		sequential	I	2685-7
I	⊥ contains	action	all the facts	2685-7
all the facts		sequential	that	2685-7
that	are	attribute	consequences	2685-7
consequences	of	constraint	P	2685-7
P	by	constraint	the values	2685-7
P	assuming	action	the values	2685-7
the values	for	constraint	the negative premises	2685-7
the negative premises	as	constraint	I	2685-7
the negative premises	by	constraint	I	2685-7
the negative premises	given	action	I	2685-7
We	denote ⊥	action	pg	2685-8
pg		sequential	P	2685-8
P		sequential	I	2685-8
I	by	constraint	conseq P	2685-8
conseq P		sequential	I	2685-8
the intuitive conditions	of	constraint	models	2685-9
the intuitive conditions	required	attribute	3 stable	2685-9
models		sequential	Thus now amount	2685-9
Thus now amount	to	constraint	conseq P	2685-9
conseq P		sequential	I	2685-9
I	=	sequential	I	2685-9
Definition		sequential	15.3.5	2686-1
<B>	3 valued	action	A instance	2686-2
A instance		sequential	I	2686-2
I	over	constraint	sch	2686-2
sch		sequential	P	2686-2
P	is	attribute	3 stable	2686-2
a model	of	constraint	P iff	2686-2
P iff		sequential	conseq P	2686-2
conseq P		sequential	I	2686-2
I	=	sequential	I	2686-2
<B>	Observe	action	an important distinction	2687-1
an important distinction	between	constraint	conseq P	2687-1
conseq P	and	conjunctive	the immediate consequence operator	2687-1
the immediate consequence operator	for	constraint	inflationary datalog¬	2687-1
the immediate consequence operator	used	action	inflationary datalog¬	2687-1
<B>	For	constraint	inflationary datalog¬	2687-2
inflationary datalog¬		sequential	we	2687-2
we	that	constraint	A	2687-2
we	assumed	action	A	2687-2
A	as	constraint	A	2687-2
A	was	attribute	true	2687-2
A	was not inferred	action	<B>	2687-2
we	in	constraint	such a case	2687-3
we	Here just assume	action	such a case	2687-3
such a case	that	constraint	A	2687-3
A	to	constraint	new facts	2687-3
A	and	conjunctive	new facts	2687-3
A	is	attribute	unknown	2687-3
A	try	action	new facts	2687-3
A	prove	action	new facts	2687-3
<B>	doing so	action	the approach	2687-4
<B>	Of course requires	action	the approach	2687-4
<B>	3 valued	action	the approach	2687-4
Example		sequential	15.3.6	2688-1
The program P		sequential	′	2688-2
′	=	sequential	pg	2688-2
pg		sequential	P	2688-2
P		sequential	I3	2688-2
I3	is	attribute	Negation	2688-2
Negation	in	constraint	Datalog p	2688-2
Datalog p		sequential	1 q	2688-2
1 q	←	sequential	1	2688-2
1		sequential	p	2688-2
p		sequential	1/2 t	2688-2
1/2 t		sequential	q	2688-2
q		sequential	1/2 u	2688-2
1/2 u	←	sequential	1/2	2688-2
1/2		sequential	p	2688-2
p		sequential	s	2688-2
we	with	constraint	⊥	2688-3
we	Thus start	action	⊥	2688-3
⊥	=	sequential	¬p	2688-3
¬p		sequential	¬u	2688-3
The first application	of	constraint	3 TP	2688-4
3 TP		sequential	′ yields 3	2688-4
′ yields 3	-	sequential	TP	2688-4
TP		sequential	′	2688-4
′	⊥ =	sequential	p	2688-4
p		sequential	¬u	2688-4
<B>	-	sequential	TP	2688-5
TP		sequential	3 ′	2688-5
3 ′		sequential	2	2688-5
2		sequential	⊥	2688-5
⊥	=	sequential	p	2688-5
⊥	{	sequential	p	2688-5
p		sequential	q	2688-5
q	¬t	constraint	}	2688-5
<B>	-	sequential	TP	2688-6
TP		sequential	3 ′	2688-6
3 ′		sequential	3	2688-6
3		sequential	⊥	2688-6
⊥	Finally =	sequential	TP	2688-6
⊥	-	sequential	TP	2688-6
TP		sequential	3 ′ 4	2688-6
3 ′ 4		sequential	⊥	2688-6
⊥	=	sequential	p	2688-6
⊥	{	sequential	p	2688-6
p		sequential	q	2688-6
q		sequential	¬r	2688-6
¬r		sequential	}	2688-6
conseq P		sequential	I3	2688-7
I3	Thus =	sequential	pg	2688-7
pg		sequential	P	2688-7
P		sequential	I3	2688-7
I3		sequential	⊥	2688-7
⊥	=	sequential	TP	2688-7
⊥	-	sequential	TP	2688-7
TP		sequential	3 ′	2688-7
3 ′		sequential	3	2688-7
3	⊥ =	sequential	I3	2688-7
I3	and	conjunctive	I3	2688-7
I3	is	attribute	3 stable	2688-7
a model	of	constraint	P	2688-7
The reader	to	constraint	Example 15.3.1	2689-1
The reader	that	constraint	Example 15.3.1	2689-1
The reader	in	constraint	Example 15.3.1	2689-1
The reader	is invited	action	Example 15.3.1	2689-1
The reader	verify	action	Example 15.3.1	2689-1
Example 15.3.1		sequential	the instance J	2689-1
the instance J	is	attribute	3 stable	2689-1
a model	of	constraint	the program	2689-1
the program		sequential	P win	2689-1
P win		sequential	K	2689-1
K	for	constraint	the input instance K	2689-1
the input instance K	presented	action	<B>	2689-1
We	that	constraint	each datalog¬ program	2690-1
We	will show later	action	each datalog¬ program	2690-1
each datalog¬ program	at	constraint	one model	2690-1
each datalog¬ program	has	attribute	least	2690-1
it	Therefore makes	action	sense	2690-2
sense	to	constraint	the final answer	2690-2
sense	let	action	the final answer	2690-2
the final answer	of	constraint	the facts	2690-2
the final answer	and	conjunctive	the facts	2690-2
the final answer	consist	attribute	positive	2690-2
the facts	to	constraint	all models	2690-2
the facts	belonging	attribute	3 stable	2690-2
all models	of	constraint	the program	2690-2
<B>	As	constraint	we	2690-3
we	shall see	action	the instance	2690-3
we	3 valued	action	the instance	2690-3
the instance	is	attribute	itself	2690-3
the instance	so obtained	action	itself	2690-3
itself		sequential	a model	2690-3
a model	of	constraint	the program	2690-3
Definition		sequential	15.3.7	2691-1
<B>	well founded	action	The semantics	2691-2
The semantics	of	constraint	P	2691-2
P	is	attribute	the instance	2691-2
P	3 valued	action	the instance	2691-2
the instance	of	constraint	all facts	2691-2
the instance	and	conjunctive	all facts	2691-2
the instance	consisting	attribute	positive	2691-2
all facts	to	constraint	all models	2691-2
all facts	belonging	attribute	3 stable	2691-2
all models	of	constraint	P	2691-2
<B>	by	constraint	P	2691-3
<B>	is denoted	action	P	2691-3
P		sequential	wf	2691-3
wf		sequential	∅	2691-3
∅	or	conjunctive	P wf	2691-3
Given datalog¬ program P	and	conjunctive	input instance	2691-4
input instance		sequential	I	2691-4
I		sequential	wf P	2691-4
I	well founded	action	the semantics	2692-1
the semantics	of	constraint	the program P	2692-1
the program P	in	constraint	Example 15.3.6	2692-1
Example 15.3.6	is	attribute	Thus P wf	2692-1
Thus P wf		sequential	∅	2692-1
∅	=	sequential	wf p	2692-1
wf p		sequential	q	2692-1
q		sequential	¬r	2692-1
¬r	}	sequential	<B>	2692-1
We	in	constraint	Example 15.3.1	2692-2
We	shall see later	attribute	that	2692-2
Example 15.3.1		sequential	P	2692-2
<B>	win	action	<B>	2693-1
The straightforward algorithm	by	constraint	this description	2693-2
The straightforward algorithm	yielded	action	this description	2693-2
this description	involves	action	all possible instances	2693-2
this description	checking	action	all possible instances	2693-2
this description	3 valued	action	all possible instances	2693-2
all possible instances	of	constraint	a program	2693-2
a program	determining	action	which	2693-2
which	are	attribute	3 stable	2693-2
models	and	conjunctive	their intersection	2693-2
models	taking	action	their intersection	2693-2
We	next provide	action	a simpler efficient way	2693-3
a simpler efficient way	of	constraint	the semantics	2693-3
a simpler efficient way	computing	action	the semantics	2693-3
a simpler efficient way	well founded	action	the semantics	2693-3
It	on	constraint	alternating fixpoint	2693-4
It	is based	action	alternating fixpoint	2693-4
alternating fixpoint		sequential	an computation	2693-4
an computation		sequential	that	2693-4
that	to	constraint	the semantics	2693-4
that	converges	action	the semantics	2693-4
that	well founded	action	the semantics	2693-4
<B>	As	constraint	side	2693-5
side		sequential	a effect	2693-5
a effect		sequential	the proof	2693-5
the proof	that	constraint	each datalog¬ program	2693-5
the proof	will show	action	each datalog¬ program	2693-5
each datalog¬ program	at	constraint	one model	2693-5
each datalog¬ program	has	attribute	least	2693-5
one model	and	conjunctive	the semantics	2693-5
one model	well founded	action	the semantics	2693-5
the semantics	therefore is always defined	action	something	2693-5
something		sequential	we	2693-5
we	have not proven	action	<B>	2693-5
It	that	constraint	the model	2693-6
It	will also show	action	the model	2693-6
It	well founded	action	the model	2693-6
the model	is	attribute	itself	2693-6
itself		sequential	a model	2693-6
a model	in	constraint	some sense	2693-6
some sense		sequential	<B>	2693-6
The idea	of	constraint	the computation	2694-1
the computation	as	constraint	<B>	2694-1
the computation	is	attribute	<B>	2694-1
the computation	follows	action	<B>	2694-1
We	define	action	an alternating sequence	2694-2
<B>	that	constraint	⊥	2695-1
<B>	Recall	action	⊥	2695-1
⊥	is	attribute	the instance	2695-1
⊥	least 3 valued	action	the instance	2695-1
the instance	that	constraint	all facts	2695-1
the instance	and	conjunctive	all facts	2695-1
all facts	have	action	value 0	2695-1
value 0	in	constraint	⊥	2695-1
<B>	that	constraint	the Ii	2695-2
<B>	of	constraint	the Ii	2695-2
<B>	Also note	attribute	each	2695-2
the Ii	is	attribute	a total instance	2695-2
the Ii	just defined	action	a total instance	2695-2
<B>	from	constraint	the following facts	2695-3
<B>	follows easily	action	the following facts	2695-3
the following facts		sequential	Exercise	2695-3
Exercise		sequential	15.17	2695-3
The intuition	behind	constraint	the construction	2696-1
the construction	of	constraint	the sequence	2696-1
The sequence	with	constraint	⊥	2696-2
The sequence	starts	action	⊥	2696-2
⊥		sequential	which	2696-2
which	is	attribute	an overestimate	2696-2
an overestimate	of	constraint	the negative facts	2696-2
the negative facts	in	constraint	the answer	2696-2
the answer		sequential	it	2696-2
it	contains	action	all negative facts	2696-2
<B>	From	constraint	this overestimate	2696-3
this overestimate		sequential	we	2696-3
we	compute	action	I1	2696-3
I1	=	sequential	conseq P	2696-3
conseq P		sequential	which	2696-3
which	includes	action	all positive facts	2696-3
all positive facts		sequential	that	2696-3
that	from	constraint	⊥	2696-3
that	can be inferred	action	⊥	2696-3
<B>	is	attribute	clearly an overestimate	2696-4
clearly an overestimate	of	constraint	the positive facts	2696-4
the positive facts	in	constraint	the answer	2696-4
the answer		sequential	the set	2696-4
the set	of	constraint	negative facts	2696-4
negative facts	in	constraint	I1	2696-4
I1	is	attribute	so an underestimate	2696-4
so an underestimate	of	constraint	the negative facts	2696-4
the negative facts	in	constraint	the answer	2696-4
<B>	Using	action	this underestimate	2696-5
this underestimate	of	constraint	the negative facts	2696-5
the negative facts		sequential	we	2696-5
we	compute	action	I2	2696-5
I2	=	sequential	conseq P	2696-5
conseq P		sequential	I1	2696-5
I1		sequential	whose positive facts	2696-5
whose positive facts	be	attribute	will now an underestimate	2696-5
will now an underestimate	of	constraint	the positive facts	2696-5
the positive facts	in	constraint	the answer	2696-5
<B>	By	constraint	the process	2696-6
<B>	continuing	action	the process	2696-6
the process		sequential	we	2696-6
we	that	constraint	the instances	2696-6
we	see	action	the instances	2696-6
we	even indexed	action	the instances	2696-6
the instances	provide	action	underestimates	2696-6
underestimates	of	constraint	the positive facts	2696-6
the positive facts	in	constraint	the answer	2696-6
the answer	and	conjunctive	the ones	2696-6
the answer	indexed	action	the ones	2696-6
the ones	provide	action	underestimates	2696-6
underestimates	of	constraint	the negative facts	2696-6
the negative facts	in	constraint	the answer	2696-6
the limit	of	constraint	the instances	2696-7
the limit	even indexed	action	the instances	2696-7
the instances	Then provides	action	the positive facts	2696-7
the positive facts	in	constraint	the answer	2696-7
the answer	and	conjunctive	the limit	2696-7
the limit	of	constraint	the instances	2696-7
the limit	indexed	action	the instances	2696-7
the instances	provides	action	the negative facts	2696-7
the negative facts	in	constraint	the answer	2696-7
This intuition	in	constraint	this section	2696-8
This intuition	will be made later	attribute	formal	2696-8
It	to	constraint	conseq P	2697-1
It	that	constraint	conseq P	2697-1
It	is	attribute	easy	2697-1
It	see	action	conseq P	2697-1
conseq P		sequential	I	2697-1
I	is	attribute	antimonotonic	2697-1
<B>	if	constraint	I	2697-2
<B>	is	attribute	I	2697-2
I	≺	action	J	2697-2
J		sequential	conseq P	2697-2
conseq P		sequential	J	2697-2
J		sequential	conseq	2697-2
conseq		sequential	P	2697-2
P		sequential	I	2697-2
I		sequential	Exercise	2697-2
Exercise		sequential	15.17	2697-2
<B>	From	constraint	the facts	2697-3
<B>	and	conjunctive	the facts	2697-3
the facts		sequential	that	2697-3
that		sequential	I1	2697-3
I1	and	conjunctive	I2	2697-3
I2		sequential	it	2697-3
it	for	constraint	i	2697-3
it	immediately follows	attribute	that	2697-3
i	>	sequential	0	2697-3
0		sequential	I0 ≺ I2	2697-3
<B>	.	sequential	<B>	2697-4
<B>	.	sequential	<B>	2697-5
<B>		sequential	i	2697-6
i		sequential	I2i+2	2697-6
<B>	.	sequential	<B>	2697-7
<B>	.	sequential	<B>	2697-8
I2i+1		sequential	I2i−1 ≺	2697-9
<B>	.	sequential	<B>	2697-10
<B>	.	sequential	<B>	2697-11
I1		sequential	I1	2697-12
the even subsequence	and	conjunctive	the odd one	2698-1
the even subsequence	Thus is increasing	action	the odd one	2698-1
the odd one	is decreasing	action	<B>	2698-1
<B>	Because	constraint	there	2698-2
there	are finitely	action	many instances	2698-2
there	3 valued	action	many instances	2698-2
many instances	to	constraint	a given program P	2698-2
a given program P	of	constraint	these sequences	2698-2
these sequences	at	constraint	some point	2698-2
these sequences	becomes	attribute	constant	2698-2
<B>	Let	action	<B>	2698-3
I∗∗	Equivalently =	sequential	I∗	2699-1
I∗		sequential	1	2699-1
1		sequential	∪	2699-1
∪		sequential	I∗	2699-1
I∗		sequential	0	2699-1
<B>	As	constraint	I∗∗	2699-2
<B>	will be seen shortly	action	I∗∗	2699-2
I∗∗	=	sequential	P wf	2699-2
P wf		sequential	∅	2699-2
<B>	Before	constraint	we	2699-3
<B>	proving	attribute	this	2699-3
we	illustrate	action	the alternating fixpoint computation	2699-3
the alternating fixpoint computation	with	constraint	several examples	2699-3
Negation	in	constraint	Datalog Example 15.3.8	2700-1
Datalog Example 15.3.8		sequential	I1	2700-1
I1	=	sequential	p	2700-1
I1	{	sequential	p	2700-1
p		sequential	q	2700-1
q		sequential	¬r	2700-1
¬r		sequential	s	2700-1
s		sequential	t	2700-1
t		sequential	u	2700-1
u		sequential	}	2700-1
}		sequential	I2	2700-1
I2	=	sequential	p	2700-1
I2	{	sequential	p	2700-1
p		sequential	q	2700-1
q		sequential	¬s	2700-1
¬s		sequential	¬u	2700-1
¬u	}	sequential	I3	2700-1
I3	=	sequential	p	2700-1
I3	{	sequential	p	2700-1
p		sequential	q	2700-1
q		sequential	s	2700-1
s		sequential	t	2700-1
t		sequential	u	2700-1
u		sequential	}	2700-1
}		sequential	I4	2700-1
I4	=	sequential	p	2700-1
I4	{	sequential	p	2700-1
p		sequential	q	2700-1
q	¬s	action	¬u	2700-1
¬u	}	sequential	<B>	2700-1
I∗	Thus =	sequential	I4	2701-1
I4	{	sequential	p	2701-1
p		sequential	q	2701-1
q		sequential	¬u	2701-1
¬u		sequential	}	2701-1
}	and	conjunctive	I∗	2701-1
I∗	=	sequential	I3	2701-1
I3	=	sequential	p	2701-1
p		sequential	q	2701-1
q		sequential	t	2701-1
t		sequential	u	2701-1
u		sequential	}	2701-1
I∗∗	Finally =	sequential	p	2701-2
I∗∗	{	sequential	p	2701-2
p		sequential	q	2701-2
q		sequential	¬r	2701-2
¬r		sequential	}	2701-2
}		sequential	which	2701-2
which	with	constraint	the semantics	2701-2
which	coincides	action	the semantics	2701-2
which	well founded	action	the semantics	2701-2
the semantics	of	constraint	P	2701-2
P	in	constraint	Example 15.3.6	2701-2
P	computed	action	Example 15.3.6	2701-2
I1	=	sequential	win	2702-1
win	a win	action	c	2702-1
win	win	action	c	2702-1
c	win	action	d	2702-1
d		sequential	¬ win	2702-1
¬ win		sequential	e	2702-1
e	win	action	f	2702-1
f		sequential	¬ win	2702-1
¬ win		sequential	g	2702-1
g		sequential	I2	2702-1
I2	=	sequential	{ ¬ win	2702-1
{ ¬ win		sequential	¬ win	2702-1
¬ win		sequential	¬ win	2702-1
¬ win		sequential	c	2702-1
c		sequential	win	2702-1
win		sequential	d	2702-1
d		sequential	¬ win	2702-1
¬ win		sequential	e	2702-1
e		sequential	win	2702-1
win		sequential	f	2702-1
f		sequential	¬ win	2702-1
¬ win		sequential	g	2702-1
g		sequential	I3	2702-1
I3	=	sequential	I1	2702-1
I1		sequential	I4	2702-1
I4	=	sequential	I2	2702-1
I∗	Thus =	sequential	I2	2703-1
I2	=	sequential	¬ win	2703-1
¬ win		sequential	a win	2703-1
a win		sequential	win	2703-1
win		sequential	c	2703-1
c	win	action	d	2703-1
d		sequential	¬ win	2703-1
¬ win		sequential	e	2703-1
e	win	action	f	2703-1
f		sequential	win	2703-1
win		sequential	g	2703-1
<B>	Consider	action	the instance K	2704-1
the instance K	over	constraint	G	2704-1
G	and	conjunctive	K	2704-1
K		sequential	G	2704-1
G		sequential	K	2704-1
K	where =	sequential	a }	2704-1
K	{	sequential	a }	2704-1
We	that	constraint	the facts	2705-1
We	assume	action	the facts	2705-1
the facts	of	constraint	the database	2705-1
the database	as	constraint	unit clauses	2705-1
the database	are added	action	unit clauses	2705-1
unit clauses	to	constraint	P	2705-1
P	yielding	action	PK	2705-1
we	Again perform	action	the alternating fixpoint computation	2705-2
the alternating fixpoint computation	for	constraint	PK	2705-2
We	with	constraint	I0	2705-3
We	start	action	I0	2705-3
I0		sequential	⊥	2705-3
⊥	containing	action	all negated atoms	2705-3
<B>	Applying	action	conseq P	2705-4
conseq P	yields	action	the following K sequence	2705-4
I∗∗	Thus =	sequential	I∗	2706-1
I∗	=	sequential	I∗	2706-1
I∗	=	sequential	I3	2706-1
I3	=	sequential	I4	2706-1
<B>	that	constraint	P	2706-2
<B>	Note	action	P	2706-2
P	and	conjunctive	its semantics	2706-2
P	is stratified	action	its semantics	2706-2
P	founded	action	its semantics	2706-2
its semantics	with	constraint	its stratified semantics	2706-2
its semantics	coincides	action	its stratified semantics	2706-2
<B>	As	constraint	we	2706-3
we	shall see	attribute	this	2706-3
we	is	attribute	not accidental	2706-3
We	that	constraint	the fixpoint construction	2707-1
We	now show	action	the fixpoint construction	2707-1
the fixpoint construction	yields	action	the semantics	2707-1
the fixpoint construction	well founded	action	the semantics	2707-1
the semantics	for	constraint	datalog¬ programs	2707-1
Theorem		sequential	15.3.9	2708-1
Proof		sequential	Proof	2709-1
We	that	constraint	every fact A	2709-2
We	for	constraint	every fact A	2709-2
We	show	action	every fact A	2709-2
every fact A	if	constraint	I∗∗	2709-2
I∗∗		sequential	A	2709-2
A	=	sequential	∈	2709-2
A	ǫ	sequential	∈	2709-2
∈	{	sequential	0	2709-2
0		sequential	1/2	2709-2
1/2		sequential	1 }	2709-2
1 }		sequential	conseq P	2709-2
conseq P		sequential	I∗∗	2709-2
I∗∗		sequential	A	2709-2
A	=	sequential	ǫ	2709-2
<B>	From	constraint	the antimonotonicity	2709-3
the antimonotonicity	of	constraint	conseq P	2709-3
conseq P		sequential	the fact	2709-3
the fact	that	constraint	I∗	2709-3
I∗		sequential	I∗∗	2709-3
I∗∗		sequential	I∗	2709-3
I∗	and	conjunctive	conseq	2709-3
conseq		sequential	P	2709-3
P		sequential	I∗	2709-3
I∗	=	sequential	I∗	2709-3
I∗		sequential	conseq P	2709-3
conseq P		sequential	I∗	2709-3
<B>	If	constraint	I∗∗	2709-4
I∗∗		sequential	A	2709-4
A	=	sequential	0	2709-4
0		sequential	I∗	2709-4
I∗		sequential	A	2709-4
A	= so	sequential	0	2709-4
0		sequential	conseq P	2709-4
conseq P		sequential	I∗∗	2709-4
I∗∗		sequential	A	2709-4
A	=	sequential	0	2709-4
0	for	constraint	I∗∗	2709-4
I∗∗		sequential	A	2709-4
A	=	sequential	1	2709-4
<B>	that	constraint	I∗∗	2709-5
<B>	Now suppose	action	I∗∗	2709-5
I∗∗		sequential	A	2709-5
A	=	sequential	1/2	2709-5
It	to	constraint	conseq P	2709-6
It	that	constraint	conseq P	2709-6
It	is	attribute	sufficient	2709-6
It	prove	action	conseq P	2709-6
conseq P		sequential	I∗∗	2709-6
I∗∗		sequential	<B>	2709-6
<B>	By	constraint	the definition	2709-7
the definition	of	constraint	I∗∗	2709-7
I∗∗		sequential	I∗	2709-7
I∗		sequential	A	2709-7
A	=	sequential	0	2709-7
0	and	conjunctive	I∗	2709-7
I∗		sequential	A	2709-7
A	=	sequential	1	2709-7
<B>	that	constraint	conseq P	2709-8
<B>	Recall	action	conseq P	2709-8
conseq P		sequential	I∗	2709-8
<B>	In	constraint	addition	2709-9
addition		sequential	conseq P	2709-9
conseq P		sequential	I∗	2709-9
I∗	is	attribute	the limit	2709-9
the limit	of	constraint	the sequence	2709-9
<B>	Let	action	stage	2709-10
stage	be	attribute	A the minimum P	2709-10
A the minimum P		sequential	i	2709-10
i	-	sequential	T	2709-10
T		sequential	3 i pg	2709-10
3 i pg		sequential	P	2709-10
P		sequential	I∗	2709-10
I∗		sequential	I∗	2709-10
I∗	pose	action	that stage	2709-10
that stage		sequential	A	2709-10
A	=	sequential	1	2709-10
there	in	constraint	ground	2709-11
there	Then exists	action	ground	2709-11
ground		sequential	P	2709-11
P		sequential	a rule	2709-11
a rule	of	constraint	the form A ←	2709-11
the form A ←	or	conjunctive	one	2709-11
one	of	constraint	the form	2709-11
the form		sequential	A	2709-11
A		sequential	¬ B1	2709-11
<B>	.	sequential	<B>	2709-12
<B>	.	sequential	<B>	2709-13
Bn		sequential	I∗	2709-14
I∗		sequential	Bj	2709-14
Bj	where =	sequential	0	2709-14
0		sequential	1 ≤	2709-14
1 ≤		sequential	j	2709-14
j	n	conjunctive	<B>	2709-14
<B>	By	constraint	the same argument	2709-15
the same argument		sequential	I∗	2709-15
I∗		sequential	Bj	2709-15
Bj	=	sequential	1	2709-15
1		sequential	I∗∗	2709-15
I∗∗		sequential	Bj	2709-15
Bj	so =	sequential	1/2	2709-15
1/2		sequential	1 ≤ j ≤	2709-15
1 ≤ j ≤		sequential	n.	2709-15
n.	Consider now	action	pg	2709-15
pg		sequential	P	2709-15
P		sequential	I∗∗	2709-15
<B>	Because	constraint	I∗∗	2709-16
I∗∗		sequential	Bj	2709-16
Bj	=	sequential	Negation	2709-16
Negation	in	constraint	Datalog pg	2709-16
Datalog pg		sequential	P	2709-16
P		sequential	I∗	2709-16
I∗		sequential	k	2709-16
k	=	sequential	1	2709-16
1	for	constraint	each j	2709-16
each j	and	conjunctive	k.	2709-16
<B>	In	constraint	addition	2709-17
addition	by	constraint	the induction hypothesis	2709-17
the induction hypothesis		sequential	conseq P ≥ 1/2	2709-17
conseq P ≥ 1/2		sequential	I∗∗	2709-17
I∗∗		sequential	Ak	2709-17
It	that	constraint	conseq P	2709-18
It	follows	action	conseq P	2709-18
conseq P		sequential	I∗∗	2709-18
I∗∗	and	conjunctive	the induction	2709-18
I∗∗	A ≥ 1/2	sequential	the induction	2709-18
the induction	is	attribute	complete	2709-18
conseq P		sequential	I∗∗	2709-19
I∗∗	and	conjunctive	I∗∗	2709-19
I∗∗	Thus =	sequential	I∗∗	2709-19
I∗∗	is	attribute	3 stable	2709-19
a model	of	constraint	P	2709-19
<B>	Consider	action	statement 2	2710-1
We	to	constraint	the facts	2710-2
We	that	constraint	the facts	2710-2
We	and	conjunctive	the facts	2710-2
We	have	attribute	positive	2710-2
We	show	attribute	positive	2710-2
the facts	in	constraint	I∗∗	2710-2
I∗∗	to	constraint	every model M	2710-2
I∗∗	are	attribute	those	2710-2
I∗∗	belonging	attribute	3 stable	2710-2
every model M	of	constraint	P	2710-2
<B>	Because	constraint	I∗∗	2710-3
I∗∗	is	attribute	3 stable	2710-3
itself a model	of	constraint	P	2710-3
P		sequential	it	2710-3
it	and	conjunctive	the facts	2710-3
it	contains	attribute	positive	2710-3
the facts	to	constraint	every model	2710-3
the facts	belonging	attribute	3 stable	2710-3
every model	of	constraint	P	2710-3
It	to	constraint	the converse	2710-4
It	remains	action	the converse	2710-4
It	show	action	the converse	2710-4
the converse	that	constraint	the facts	2710-4
the converse	and	conjunctive	the facts	2710-4
the facts	in	constraint	I∗∗	2710-4
I∗∗	to	constraint	every model	2710-4
I∗∗	belong	attribute	3 stable	2710-4
every model	of	constraint	P	2710-4
<B>	To	constraint	this end	2710-5
this end		sequential	we	2710-5
we	that	constraint	each model M	2710-5
we	for	constraint	each model M	2710-5
we	first show	attribute	3 stable	2710-5
each model M	of	constraint	P	2710-5
P	and	conjunctive	i	2710-5
i		sequential	≥ 0	2710-5
≥ 0		sequential	I2	2710-5
I2		sequential	i	2710-5
i		sequential	M	2710-5
M	≺	sequential	I2i+1	2710-5
The proof	by	constraint	induction	2711-1
The proof	is	attribute	induction	2711-1
induction	on	constraint	i	2711-1
<B>	For	constraint	i	2711-2
i	=	sequential	0	2711-2
0		sequential	we	2711-2
we	have	action	I0	2711-2
I0	=	sequential	M	2711-2
I0	⊥	sequential	M	2711-2
I0	≺	sequential	M	2711-2
<B>	Because	constraint	conseq P	2712-1
conseq P	is	attribute	antimonotonic	2712-1
conseq P		sequential	M	2712-1
M		sequential	conseq P	2712-1
conseq P		sequential	I0	2712-1
conseq P		sequential	I0	2712-2
I0	Now =	sequential	I1	2712-2
The induction step	and	conjunctive	<B>	2713-1
The induction step	is	attribute	similar	2713-1
The induction step	is omitted	action	<B>	2713-1
<B>	By	constraint	‡ M	2714-1
‡ M		sequential	I∗	2714-1
a positive fact	in	constraint	I∗∗	2714-2
I∗∗	in	constraint	Now I∗	2714-2
I∗∗	is	attribute	Now I∗	2714-2
Now I∗	in	constraint	so M	2714-2
Now I∗	and	conjunctive	so M	2714-2
Now I∗	is	attribute	so M	2714-2
so M	because	constraint	I∗	2714-2
I∗		sequential	M	2714-2
a negative fact	in	constraint	I∗∗	2715-1
I∗∗	in	constraint	Similarly I∗	2715-1
I∗∗	is	attribute	Similarly I∗	2715-1
Similarly I∗	in	constraint	so M	2715-1
Similarly I∗	and	conjunctive	so M	2715-1
Similarly I∗	is	attribute	so M	2715-1
so M	because	constraint	M	2715-1
M		sequential	I∗	2715-1
<B>	that	constraint	the proof	2716-1
<B>	Note	action	the proof	2716-1
the proof	of	constraint	statement 2 above	2716-1
statement 2 above	formalizes	action	the intuition	2716-1
the intuition		sequential	that	2716-1
that		sequential	the I2i	2716-1
the I2i	provide	action	underestimates	2716-1
underestimates	of	constraint	the positive facts	2716-1
the positive facts	in	constraint	all acceptable answers	2716-1
all acceptable answers	-	sequential	3 models	2716-1
3 models	and	conjunctive	the I2i+1	2716-1
the I2i+1	provide	action	underestimates	2716-1
underestimates	of	constraint	the negative facts	2716-1
the negative facts	in	constraint	those answers	2716-1
The fact	that	constraint	P wf	2716-2
P wf		sequential	∅	2716-2
∅	is	attribute	a minimal model	2716-2
a minimal model	of	constraint	P	2716-2
P	for	constraint	Exercise 15.19	2716-2
P	is left	action	Exercise 15.19	2716-2
Variations	of	constraint	the alternating fixpoint computation	2717-1
the alternating fixpoint computation	by	constraint	initial instances	2717-1
the alternating fixpoint computation	with	constraint	initial instances	2717-1
the alternating fixpoint computation	can be obtained	action	initial instances	2717-1
the alternating fixpoint computation	starting	action	initial instances	2717-1
initial instances	from	constraint	⊥	2717-1
<B>	For	constraint	example	2717-2
example		sequential	it	2717-2
it	may make	action	sense	2717-2
sense	to	constraint	the content	2717-2
sense	with	constraint	the content	2717-2
sense	start	action	the content	2717-2
the content	of	constraint	the edb relations	2717-2
the edb relations	as	constraint	an initial instance	2717-2
Such variations	for	constraint	technical reasons	2717-3
Such variations	are	attribute	sometimes useful	2717-3
It	that	constraint	the resulting sequences	2717-4
It	turns out	action	the resulting sequences	2717-4
the resulting sequences	still compute	action	the semantics	2717-4
the resulting sequences	well founded	action	the semantics	2717-4
We	show	attribute	the	2718-1
<B>	Let	action	<B>	2718-2
Then I0	≺	sequential	I2	2719-1
<B>	.	sequential	<B>	2719-2
<B>	.	sequential	<B>	2719-3
<B>		sequential	i	2719-4
i		sequential	I2i+2	2719-4
<B>	.	sequential	<B>	2719-5
<B>	.	sequential	<B>	2719-6
I2i+1		sequential	I2i−1 ≺	2719-7
<B>	.	sequential	<B>	2719-8
<B>	.	sequential	<B>	2719-9
I1 I∗	=	sequential	P wf	2719-10
P wf		sequential	∅	2719-10
Proof		sequential	Proof	2720-1
<B>	Because	constraint	I0	2720-2
I0		sequential	P wf	2720-2
P wf		sequential	∅	2720-2
∅	and	conjunctive	I0	2720-2
I0	is	attribute	total	2720-2
it	easily follows	action	that I0	2720-2
that I0		sequential	<B>	2720-2
⊥	Thus =	sequential	I0	2720-3
I0		sequential	I0	2720-3
I0		sequential	I∗	2720-3
<B>	From	constraint	the antimonotonicity	2720-4
the antimonotonicity	of	constraint	the conseq P operator	2720-4
the conseq P operator	and	conjunctive	the fact	2720-4
the fact	that	constraint	conseq 2	2720-4
conseq 2		sequential	I	2720-4
I		sequential	P	2720-4
P		sequential	I	2720-4
I		sequential	conseq P	2720-4
conseq P		sequential	I∗	2720-4
I∗	=	sequential	conseq P	2720-4
conseq P		sequential	I∗	2720-4
the alternating fixpoint computation	of	constraint	the semantics	2721-1
the alternating fixpoint computation	well founded	action	the semantics	2721-1
the semantics	at	constraint	the ground rules	2721-1
the semantics	Finally involves	action	the ground rules	2721-1
the semantics	looking	action	the ground rules	2721-1
the ground rules	of	constraint	the given program	2721-1
one	However can clearly compute	action	the semantics	2721-2
the semantics	without	constraint	the ground rules	2721-2
the semantics	to	constraint	the ground rules	2721-2
the semantics	at	constraint	the ground rules	2721-2
the semantics	having	action	the ground rules	2721-2
the semantics	explicitly look	action	the ground rules	2721-2
We	in	constraint	Section 15.4	2721-3
We	show	action	Section 15.4	2721-3
Section 15.4	well founded	action	the semantics	2721-3
the semantics	by	constraint	a fixpoint query	2721-3
the semantics	how can be computed	action	a fixpoint query	2721-3
<B>	and	conjunctive	Semantics	2722-1
<B>	Founded	action	Semantics	2722-1
<B>	Stratified	action	Semantics	2722-1
Semantics	Because	constraint	the semantics	2722-1
Semantics	Agree	action	the semantics	2722-1
Semantics	well founded	action	the semantics	2722-1
the semantics	provides	action	semantics	2722-1
semantics	to	constraint	all datalog¬ programs	2722-1
all datalog¬ programs		sequential	it	2722-1
it	in	constraint	stratified programs	2722-1
it	for	constraint	stratified programs	2722-1
it	does	attribute	particular	2722-1
Example		sequential	15.3.8	2722-2
15.3.8		sequential	c	2722-2
c	showed	action	one stratified program	2722-2
one stratified program	for	constraint	which	2722-2
which	and	conjunctive	semantics	2722-2
which	stratified	action	semantics	2722-2
which	well founded	action	semantics	2722-2
semantics	coincide	action	<B>	2722-2
<B>	as	constraint	semantics	2722-3
<B>	and	conjunctive	semantics	2722-3
<B>	shown	action	semantics	2722-3
<B>	next stratified	action	semantics	2722-3
<B>	well founded	action	semantics	2722-3
semantics	are	attribute	Fortunately always compatible	2722-3
<B>	if	constraint	a program	2722-4
a program	and	conjunctive	the semantics	2722-4
a program	is stratified	action	the semantics	2722-4
a program	stratified	action	the semantics	2722-4
a program	well founded	action	the semantics	2722-4
the semantics	Thus agree	action	<B>	2722-4
Theorem		sequential	15.3.11	2723-1
Proof	Let	action	P	2724-1
P	and	conjunctive	input	2724-1
P	be stratified	action	input	2724-1
P	let	action	input	2724-1
input		sequential	I0	2724-1
I0	over	constraint	edb	2724-1
edb		sequential	P	2724-1
P	be fixed	action	<B>	2724-1
The idea	of	constraint	the proof	2724-2
the proof	is	attribute	the following	2724-2
<B>	Let	action	J	2724-3
J	be	attribute	3 stable	2724-3
a model	of	constraint	PI	2724-3
We	that	constraint	J	2724-4
We	shall show	action	J	2724-4
J		sequential	P strat	2724-4
P strat		sequential	I	2724-4
I		sequential	0	2724-4
0	that	constraint	P strat	2724-4
0	imply	action	P strat	2724-4
P strat		sequential	I0	2724-4
I0	is	attribute	3 stable	2724-4
the unique model	for	constraint	PI	2724-4
<B>	In	constraint	it	2724-5
it	and	conjunctive	only the facts	2724-5
it	contains	attribute	0 positive	2724-5
only the facts	in	constraint	all models	2724-5
all models	of	constraint	PI	2724-5
PI	and	conjunctive	thus P wf	2724-5
PI	is	attribute	thus P wf	2724-5
thus P wf		sequential	I	2724-5
I		sequential	0	2724-5
<B>	For	constraint	the proof	2725-1
the proof		sequential	we	2725-1
we	to	constraint	some notation	2725-1
we	will need	action	some notation	2725-1
we	develop	action	some notation	2725-1
Notation	for	constraint	the stratification	2726-1
the stratification	Let	action	P	2726-1
P		sequential	1	2726-1
<B>	.	sequential	<B>	2726-2
<B>	.	sequential	<B>	2726-3
P	be	attribute	n a stratification	2726-4
n a stratification	of	constraint	P	2726-4
<B>	Let	action	P	2726-5
P		sequential	0	2726-5
0	=	sequential	I	2726-5
0	∅	sequential	I	2726-5
I		sequential	0	2726-5
0		sequential	the program	2726-5
the program	to	constraint	the facts	2726-5
the program	of	constraint	the facts	2726-5
the program	corresponding	attribute	all	2726-5
the facts	in	constraint	I0	2726-5
<B>	For	constraint	each k	2726-6
each k	in	constraint	0	2726-6
0		sequential	n	2726-6
n	let	action	Sk	2726-6
Sk	=	sequential	idb	2726-6
idb		sequential	P k	2726-6
P k		sequential	S0	2726-6
S0	is	attribute	edb	2726-6
edb		sequential	P	2726-6
P		sequential	S	2726-6
S		sequential	0	2726-6
0		sequential	k	2726-6
k	=	sequential	∪i∈	2726-6
∪i∈		sequential	0	2726-6
0		sequential	k	2726-6
k		sequential	Si	2726-6
Si	and	conjunctive	Negation	2726-6
Negation	in	constraint	Datalog	2726-6
Datalog		sequential	Ik	2726-6
Ik	=	sequential	P	2726-6
P		sequential	1 ∪	2726-6
1 ∪		sequential	∪ P k	2726-6
∪ P k		sequential	strat	2726-6
strat		sequential	I0	2726-6
I0	=	sequential	In|S	2726-6
In|S		sequential	0	2726-6
0		sequential	k	2726-6
k	in	constraint	P strat	2726-6
k	and	conjunctive	P strat	2726-6
P strat		sequential	I0	2726-6
I0	= In	sequential	<B>	2726-6
Notation	for	constraint	the model	2727-1
the model	Let	action	ˆ	2727-1
ˆ		sequential	P	2727-1
P	=	sequential	pg	2727-1
pg		sequential	PI	2727-1
PI		sequential	J	2727-1
<B>	that	constraint	J	2727-2
<B>	because	constraint	J	2727-2
<B>	Recall	action	J	2727-2
J	for	constraint	0 PI	2727-2
J	is	attribute	3 stable	2727-2
0 PI		sequential	J	2727-2
J	=	sequential	conseq	2727-2
conseq	ˆ	sequential	J	2727-2
J	=	sequential	lim 3 i	2727-2
lim 3 i	-	sequential	T	2727-2
T		sequential	∅	2727-2
P P	For	constraint	each k	2728-1
each k	in	constraint	0	2728-1
0		sequential	n	2728-1
n		sequential	P	2728-1
P		sequential	k+1	2728-1
k+1	=	sequential	pg	2728-1
pg		sequential	P k+1	2728-1
P k+1		sequential	J	2728-1
<B>	J k =	sequential	pg	2729-1
pg		sequential	P k+1 k Jk J k	2729-1
P k+1 k Jk J k	=	sequential	pg	2729-1
pg		sequential	P	2729-1
P		sequential	k+1 k	2729-1
k+1 k		sequential	Jk cates	2729-1
Jk cates	in	constraint	S	2729-1
S		sequential	0	2729-1
0		sequential	k	2729-1
<B>	To	constraint	the result	2729-2
<B>	demonstrate	action	the result	2729-2
the result		sequential	we	2729-2
we	by	constraint	induction	2729-2
we	will show	action	induction	2729-2
induction	on	constraint	k ∈	2729-2
k ∈		sequential	0	2729-2
0		sequential	n	2729-2
n	that	constraint	<B>	2729-2
P	for	constraint	k	2730-1
k	n	conjunctive	the result	2730-1
k	=	sequential	the result	2730-1
k	Clearly demonstrates	action	the result	2730-1
The case		sequential	k	2731-1
k	where =	sequential	0	2731-1
0	by	constraint	l0	2731-1
0	is	attribute	satisfied	2731-1
0	setting	action	l0	2731-1
l0	=	sequential	1	2731-1
1	because	constraint	J0	2731-1
J0	=	sequential	3	2731-1
3	-	sequential	T 1+i	2731-1
T 1+i		sequential	∅	2731-1
∅		sequential	|S P	2731-1
|S P	for	constraint	i	2731-1
i	≥ 0	sequential	<B>	2731-1
<B>	that	constraint	some k ∈	2732-1
<B>	for	constraint	some k ∈	2732-1
<B>	Suppose now	attribute	true	2732-1
<B>	is	attribute	true	2732-1
some k ∈		sequential	0	2732-1
0		sequential	n	2732-1
n	−	sequential	1	2732-1
<B>	for	constraint	i	2732-2
i	Then ≥	sequential	0	2732-2
0	by	constraint	the choice	2732-2
the choice	of	constraint	P k+1	2732-2
P k+1		sequential	the form	2732-2
the form	of	constraint	P k+1	2732-2
P k+1	and	conjunctive	T i P k+1	2732-2
T i P k+1		sequential	Ik	2732-2
Ik		sequential	Sk+1	2732-2
Sk+1		sequential	⊆ 3 i+1 k+1 ⊆ T i+1 k	2732-2
⊆ 3 i+1 k+1 ⊆ T i+1 k	-	sequential	T	2732-2
T		sequential	Sk+1	2732-2
P k+1 P		sequential	k+1 P k+1 k	2733-1
k+1 P k+1 k	=	sequential	<B>	2733-1
<B>	On	constraint	the other hand	2733-2
the other hand		sequential	the T i P	2733-2
the T i P		sequential	k+1 P k+1	2733-2
<B>	By	constraint	finiteness	2734-1
<B>	and	conjunctive	finiteness	2734-1
finiteness	of	constraint	the input	2734-1
the input		sequential	there	2734-1
there	1 is	action	some m	2734-1
some m	for	constraint	i	2734-1
some m	≥	sequential	i	2734-1
P k+1	is	attribute	almost what	2735-1
almost what	to	constraint	the induction	2735-1
almost what	is needed	action	the induction	2735-1
almost what	complete	action	the induction	2735-1
the induction	except	constraint	ˆ P k+1	2735-1
the induction	that	constraint	ˆ P k+1	2735-1
ˆ P k+1	ˆ	sequential	P	2735-1
ˆ P k+1	is used	action	P	2735-1
<B>	that	constraint	each i ≥	2735-2
<B>	for	constraint	each i ≥	2735-2
<B>	However observe	action	each i ≥	2735-2
each i ≥		sequential	0	2735-2
0		sequential	P P k+1	2735-2
P P k+1	because	constraint	3	2735-2
3	-	sequential	T	2735-2
T		sequential	i	2735-2
i		sequential	∅	2735-2
∅		sequential	|S	2735-2
|S	for	constraint	each i	2735-2
each i		sequential	≥ 0	2735-2
≥ 0		sequential	P k+1 P	2735-2
P k+1 P	because	constraint	3	2735-2
3		sequential	T lk |S	2735-2
T lk |S		sequential	∅	2735-2
P Then	for	constraint	i	2736-1
i	≥	action	0	2736-1
0		sequential	we	2736-1
we	have	action	k+1 ⊆ 3 m+i+lk k+1	2736-1
k+1 ⊆ 3 m+i+lk k+1	-	sequential	T	2736-1
T	by	constraint	4 P	2736-1
4 P		sequential	k+1 P k+1	2736-1
k+1 P k+1	by	constraint	3 P	2736-1
3 P		sequential	k+1 k+1	2736-1
k+1 k+1	by	constraint	2	2736-1
P k+1		sequential	It	2737-1
It	follows	action	that k+1	2737-1
that k+1	=	sequential	3	2737-1
3		sequential	T	2737-1
T		sequential	m+i+lk k+1	2737-1
P k+1		sequential	P	2738-1
P		sequential	Set l	2738-1
Set l		sequential	k+1	2738-1
k+1	=	sequential	lk	2738-1
lk	+	sequential	m.	2738-1
P Together	with	constraint	the inductive hypothesis	2739-1
the inductive hypothesis		sequential	we	2739-1
we	for	constraint	i	2739-1
we	obtain	attribute	each	2739-1
i	≥	action	0	2739-1
0		sequential	that	2739-1
that		sequential	l J|S P	2739-1
l J|S P		sequential	which	2739-1
which	concludes	action	the proof	2739-1
Expressive Power		sequential	Expressive Power	2740-1
<B>		sequential	we	2740-2
we	on	constraint	semantics	2740-2
we	and	conjunctive	semantics	2740-2
we	focus	attribute	semipositive	2740-2
we	well founded	action	semantics	2740-2
We	at	constraint	the relative power	2740-3
We	first look	action	the relative power	2740-3
the relative power	of	constraint	these semantics	2740-3
these semantics	that	constraint	semipositive programs	2740-3
these semantics	and	conjunctive	semipositive programs	2740-3
these semantics	show	action	semipositive programs	2740-3
semipositive programs	than	constraint	which	2740-3
semipositive programs	are	attribute	weaker	2740-3
semipositive programs	stratified	action	which	2740-3
which	in	constraint	turn	2740-3
turn	than	constraint	<B>	2740-3
turn	are	attribute	weaker	2740-3
turn	well founded	action	<B>	2740-3
we	at	constraint	the connection	2740-4
we	Then look	action	the connection	2740-4
the connection	with	constraint	languages	2740-4
languages	in	constraint	Chapter 14	2740-4
languages	studied	action	Chapter 14	2740-4
Chapter 14		sequential	that	2740-4
that	also use	action	recursion	2740-4
recursion	and	conjunctive	negation	2740-4
We	that	constraint	semantics	2740-5
We	prove	action	semantics	2740-5
We	well founded	action	semantics	2740-5
semantics	can express	action	precisely the fixpoint queries	2740-5
we	at	constraint	the impact	2741-1
we	Finally look	action	the impact	2741-1
the impact	of	constraint	order	2741-1
order	on	constraint	expressive power	2741-1
An ordered database	contains	action	a special binary relation succ	2741-2
a special binary relation succ		sequential	that	2741-2
that	provides	action	a successor relation	2741-2
a successor relation	on	constraint	all constants	2741-2
all constants		sequential	Negation	2741-2
Negation	in	constraint	Datalog	2741-2
Datalog	in	constraint	the active domain	2741-2
the constants	by	constraint	fact	2741-3
the constants	in	constraint	fact	2741-3
the constants	and	conjunctive	fact	2741-3
the constants	Thus are ordered	attribute	succ	2741-3
fact	as	constraint	integers	2741-3
fact	can be viewed	action	integers	2741-3
The impact	of	constraint	a database	2741-4
The impact	that	constraint	a database	2741-4
The impact	assuming	action	a database	2741-4
a database	at	constraint	length	2741-4
a database	is ordered	action	length	2741-4
a database	is examined	action	length	2741-4
length	in	constraint	Chapter 17	2741-4
<B>		sequential	we	2741-5
we	that	constraint	the presence	2741-5
we	in	constraint	the presence	2741-5
we	show	action	the presence	2741-5
the presence	of	constraint	order	2741-5
order		sequential	semipositive programs	2741-5
semipositive programs	as	constraint	programs	2741-5
semipositive programs	are	attribute	as powerful	2741-5
programs	with	constraint	semantics	2741-5
programs	founded	action	semantics	2741-5
<B>	In	constraint	all three semantics	2741-6
all three semantics	and	conjunctive	precisely the fixpoint queries	2741-6
all three semantics	are	attribute	equivalent	2741-6
all three semantics	express	action	precisely the fixpoint queries	2741-6
We	by	constraint	the connection	2742-1
We	begin	action	the connection	2742-1
We	briefly noting	action	the connection	2742-1
the connection	between	constraint	stratified datalog¬	2742-1
stratified datalog¬	and	conjunctive	relational calculus	2742-1
relational calculus	and	conjunctive	algebra	2742-1
<B>	To	constraint	that stratified datalog¬	2742-2
<B>	see	action	that stratified datalog¬	2742-2
that stratified datalog¬	can express	action	all queries	2742-2
all queries	in	constraint	CALC	2742-2
CALC	recall	action	datalog¬	2742-2
datalog¬		sequential	nr-datalog¬	2742-2
nr-datalog¬		sequential	the nonrecursive programs	2742-2
the nonrecursive programs	in	constraint	Chapter 5	2742-2
the nonrecursive programs	introduced	action	Chapter 5	2742-2
<B>	are	attribute	Clearly stratified datalog¬ programs	2742-3
Clearly stratified datalog¬ programs	in	constraint	which	2742-3
which		sequential	recursion	2742-3
recursion	is not allowed	action	<B>	2742-3
Theorem 5.3.10	states	action	that	2742-4
that		sequential	nr-datalog¬	2742-4
nr-datalog¬	with	constraint	one answer relation	2742-4
one answer relation	and	conjunctive	CALC	2742-4
CALC	are	attribute	equivalent	2742-4
It	follows	action	that stratified datalog¬	2742-5
that stratified datalog¬	of	constraint	CALC	2742-5
that stratified datalog¬	can express	attribute	all	2742-5
<B>	Because	constraint	transitive closure	2742-6
transitive closure	of	constraint	a graph	2742-6
a graph	in	constraint	stratified datalog¬	2742-6
a graph	can be expressed	action	stratified datalog¬	2742-6
stratified datalog¬	in	constraint	not CALC	2742-6
stratified datalog¬	but	conjunctive	not CALC	2742-6
not CALC	see	action	Proposition 17.2.3	2742-6
Proposition 17.2.3		sequential	it	2742-6
it	follows	action	that stratified datalog¬	2742-6
that stratified datalog¬	than	constraint	CALC	2742-6
that stratified datalog¬	is	attribute	strictly stronger	2742-6
Stratified Datalog		sequential	Stratified Datalog	2743-1
<B>		sequential	stratified programs	2743-2
stratified programs	provide	action	recursion	2743-2
recursion	and	conjunctive	negation	2743-2
negation	and	conjunctive	<B>	2743-2
negation	are	attribute	inflationary	2743-2
one	that	constraint	they	2743-3
one	Therefore might expect	action	they	2743-3
they	express	action	the fixpoint queries	2743-3
It	to	constraint	all stratified datalog¬	2743-4
It	that	constraint	all stratified datalog¬	2743-4
It	is	attribute	easy	2743-4
It	see	action	all stratified datalog¬	2743-4
all stratified datalog¬	are	attribute	fixpoint queries	2743-4
fixpoint queries		sequential	Exercise	2743-4
Exercise		sequential	15.28	2743-4
<B>	In	constraint	such programs	2743-5
<B>	that	constraint	such programs	2743-5
<B>	shows	action	such programs	2743-5
such programs	in	constraint	polynomial time	2743-5
such programs	can be evaluated	action	polynomial time	2743-5
stratified datalog¬	Can express	action	all fixpoint queries	2743-6
<B>		sequential	<B>	2743-7
The intuitive reason	that	constraint	stratified datalog¬	2744-1
The intuitive reason	in	constraint	stratified datalog¬	2744-1
The intuitive reason	is	attribute	stratified datalog¬	2744-1
stratified datalog¬		sequential	there	2744-1
there	is	attribute	no recursion	2744-1
no recursion	through	constraint	negation	2744-1
negation	so	constraint	the number	2744-1
the number	of	constraint	applications	2744-1
applications	of	constraint	negation	2744-1
negation	is bounded	action	<B>	2744-1
<B>	In	constraint	contrast	2744-2
contrast		sequential	fixpoint queries	2744-2
fixpoint queries	allow	action	recursion	2744-2
recursion	through	constraint	negation	2744-2
negation		sequential	there	2744-2
there	so is	action	no bound	2744-2
no bound	on	constraint	the number	2744-2
the number	of	constraint	applications	2744-2
applications	of	constraint	negation	2744-2
This distinction	to	constraint	<B>	2745-1
This distinction	turns out	attribute	crucial	2745-1
This distinction	be	attribute	crucial	2745-1
We	next outline	action	the main points	2745-2
the main points	of	constraint	the argument	2745-2
the argument	that	constraint	stratified datalog¬	2745-2
the argument	showing	action	stratified datalog¬	2745-2
stratified datalog¬	than	constraint	fixpoint	2745-2
stratified datalog¬	is	attribute	indeed strictly weaker	2745-2
The proof	uses	action	a game	2746-1
a game	on	constraint	game trees	2746-1
a game	played	action	game trees	2746-1
a game	so called	action	game trees	2746-1
The game	on	constraint	a given tree	2746-2
The game	is played	action	a given tree	2746-2
The nodes	of	constraint	the tree	2746-3
the tree	are	attribute	the possible positions	2746-3
the possible positions	in	constraint	the game	2746-3
the game	and	conjunctive	the edges	2746-3
the edges	are	attribute	the possible moves	2746-3
the possible moves	from	constraint	one position	2746-3
one position	to	constraint	<B>	2746-3
some leaves	of	constraint	the tree	2746-4
the tree	Additionally are labeled	attribute	black	2746-4
The game	between	constraint	two players	2746-5
The game	is	attribute	two players	2746-5
A round	of	constraint	the game	2746-6
the game	at	constraint	node	2746-6
the game	starting	action	node	2746-6
node		sequential	x	2746-6
x	with	constraint	Player	2746-6
x	begins	action	Player	2746-6
Player		sequential	I	2746-6
I	making	action	a move	2746-6
a move	from	constraint	x	2746-6
x	to	constraint	one y	2746-6
one y	of	constraint	its children	2746-6
Player II	makes	action	a move	2746-7
a move	from	constraint	y	2746-7
y		sequential	<B>	2746-7
The game	ends	action	a leaf	2746-8
a leaf	when is reached	action	<B>	2746-8
Player		sequential	I	2746-9
I	if	constraint	Player II	2746-9
I	wins	action	Player II	2746-9
Player II	picks	action	a black leaf	2746-9
<B>	For	constraint	a given tree	2746-10
a given tree	with	constraint	labels	2746-10
labels		sequential	Player	2746-10
Player		sequential	I	2746-10
I	has	action	a winning strategy	2746-10
a winning strategy	for	constraint	the game	2746-10
the game	at	constraint	node x	2746-10
the game	starting	action	node x	2746-10
node x	if	constraint	he	2746-10
he	or	conjunctive	she	2746-10
she	at	constraint	x	2746-10
she	can win	action	x	2746-10
she	starting	action	x	2746-10
x		sequential	no matter	2746-10
no matter		sequential	Player II	2746-10
Player II	how plays	action	<B>	2746-10
We	in	constraint	programs	2746-11
We	are	attribute	interested	2746-11
programs	whether	constraint	there	2746-11
programs	determining	action	there	2746-11
there	is	attribute	such a winning strategy	2746-11
The game tree	as	constraint	<B>	2747-1
The game tree	is represented	action	<B>	2747-1
The game tree	follows	action	<B>	2747-1
The set	of	constraint	possible moves	2747-2
possible moves	by	constraint	a binary relation move	2747-2
possible moves	is given	action	a binary relation move	2747-2
a binary relation move	and	conjunctive	the set	2747-2
the set	of	constraint	black nodes	2747-2
black nodes	by	constraint	a unary relation black	2747-2
<B>	Consider	action	the query	2747-3
the query	to	constraint	the predicate win	2747-3
the query	with	constraint	the predicate win	2747-3
the query	winning	action	the predicate win	2747-3
the query	not be confused	action	the predicate win	2747-3
the predicate win	of	constraint	Example 15.3.1	2747-3
Example 15.3.1		sequential	which	2747-3
which	if	constraint	Player	2747-3
which	asks	action	Player	2747-3
Player		sequential	I	2747-3
I	has	action	a winning strategy	2747-3
a winning strategy	at	constraint	the root	2747-3
a winning strategy	starting	action	the root	2747-3
the root	of	constraint	the tree	2747-3
We	will define	action	a set	2747-4
a set	of	constraint	game trees G such that	2747-4
<B>	that	constraint	the winning query	2748-1
<B>	Clearly ii shows	action	the winning query	2748-1
the winning query	on	constraint	game trees	2748-1
game trees	by	constraint	a stratified datalog¬ program	2748-1
game trees	is	attribute	not definable	2748-1
The set G	of	constraint	game trees	2748-2
game trees	is defined next	action	<B>	2748-2
It	of	constraint	Gl k	2748-3
It	consists	action	Gl k	2748-3
Gl k	and	conjunctive	G′l	2748-3
G′l		sequential	the k	2748-3
the k	by	constraint	induction	2748-3
the k	defined	action	induction	2748-3
induction	as	constraint	G′	2748-3
induction	in	constraint	G′	2748-3
induction	follows	action	G′	2748-3
i		sequential	k	2749-1
k		sequential	i	2749-1
i		sequential	k	2749-1
k	and	conjunctive	a new root di+1	2749-1
The moves	are	attribute	the union	2749-2
the union	of	constraint	the moves	2749-2
the moves	in	constraint	the copies	2749-2
the copies	of	constraint	G′ i	2749-2
G′ i		sequential	k i	2749-2
k i	with	constraint	new moves	2749-2
k i	k together	action	new moves	2749-2
new moves	from	constraint	the root di+1	2749-2
the root di+1	to	constraint	the roots	2749-2
the roots	of	constraint	the copies	2749-2
The labels	remain	attribute	unchanged	2749-3
<B>	of	constraint	1	2750-1
<B>	+	sequential	1	2750-1
<B>	consists	action	1	2750-1
1		sequential	k disjoint copies	2750-1
k disjoint copies	of	constraint	G	2750-1
G	from	constraint	which	2750-1
which		sequential	i+1	2750-1
i+1		sequential	k	2750-1
k		sequential	i	2750-1
i		sequential	k	2750-1
k	and	conjunctive	a new root d ′i+1 moves	2750-1
a new root d ′i+1 moves	to	constraint	the roots	2750-1
a new root d ′i+1 moves	are	attribute	possible	2750-1
the roots	of	constraint	the copies	2750-1
the copies	of	constraint	Gi k	2750-1
The game trees		sequential	G4,1	2751-1
G4,1	and	conjunctive	G′	2751-1
G′	in	constraint	Fig	2751-1
G′	are represented	action	Fig	2751-1
15.2		sequential	15.2	2751-2
It	to	constraint	the game trees	2751-3
It	that	constraint	the game trees	2751-3
It	on	constraint	the game trees	2751-3
It	is	attribute	easy	2751-3
It	see	attribute	true	2751-3
It	winning 4,1	attribute	true	2751-3
It	is	attribute	true	2751-3
the game trees		sequential	G2i	2751-3
G2i		sequential	k	2751-3
k	on	constraint	game trees	2751-3
k	and	conjunctive	game trees	2751-3
game trees		sequential	G′	2751-3
We	that	constraint	the query	2752-1
We	first note	action	the query	2752-1
the query	on	constraint	game trees	2752-1
the query	winning	action	game trees	2752-1
game trees	in	constraint	G	2752-1
G	by	constraint	a fixpoint query	2752-1
G	can be defined	action	a fixpoint query	2752-1
<B>	Consider	action	<B>	2752-2
Root G		sequential	4.1 Root	2753-1
4.1 Root		sequential	G′4.1	2753-1
G′4.1		sequential	Figure	2753-1
Figure		sequential	15.2	2753-1
15.2		sequential	Game trees Negation	2753-1
Game trees Negation	in	constraint	Datalog	2753-1
we	that	constraint	the winning query	2753-2
we	Next note	action	the winning query	2753-2
the winning query	by	constraint	any stratified datalog¬ program	2753-2
the winning query	is	attribute	not expressible	2753-2
<B>	To	constraint	this end	2753-3
this end		sequential	we	2753-3
we	use	action	the following result	2753-3
the following result	without	constraint	proof	2753-3
the following result	stated	action	proof	2753-3
Lemma		sequential	15.4.1	2754-1
The proof	of	constraint	Lemma 15.4.1	2755-1
Lemma 15.4.1	uses	action	an extension	2755-1
an extension	of	constraint	Ehrefeucht	2755-1
Ehrefeucht		sequential	Fraissé	2755-1
Fraissé		sequential	games	2755-1
games		sequential	the games	2755-1
the games	in	constraint	Chapter 17	2755-1
the games	are described	action	Chapter 17	2755-1
The intuition	of	constraint	the lemma	2755-2
the lemma	that	constraint	Gi	2755-2
the lemma	to	constraint	Gi	2755-2
the lemma	between	constraint	Gi	2755-2
the lemma	is	attribute	Gi	2755-2
the lemma	distinguish	action	Gi	2755-2
Gi		sequential	k	2755-2
k	and	conjunctive	G′	2755-2
G′	for	constraint	i	2755-2
i	and	conjunctive	one	2755-2
i	k	attribute	sufficiently large	2755-2
one	to	constraint	more negations	2755-2
one	needs	action	more negations	2755-2
one	apply	action	more negations	2755-2
more negations	than	constraint	i	2755-2
i		sequential	the k fixed number	2755-2
the k fixed number	by	constraint	P	2755-2
the k fixed number	allowed	action	P	2755-2
no stratified program	between	constraint	all the Gi	2755-3
no stratified program	Thus can distinguish	action	all the Gi	2755-3
all the Gi		sequential	k	2755-3
k	and	conjunctive	G′	2755-3
<B>	In	constraint	it	2755-4
it	that	constraint	the fixpoint query	2755-4
it	follows	action	the fixpoint query	2755-4
the fixpoint query	to	constraint	i	2755-4
the fixpoint query	winning	attribute	not equivalent	2755-4
the fixpoint query	is	attribute	not equivalent	2755-4
i		sequential	k	2755-4
Theorem		sequential	15.4.2	2756-1
Remark		sequential	15.4.3	2757-1
<B>	Specifically let	action	Strat	2757-2
Strat		sequential	i	2757-2
i	of	constraint	all queries	2757-2
i	consist	action	all queries	2757-2
all queries	by	constraint	stratified datalog¬ programs	2757-2
all queries	expressible	action	stratified datalog¬ programs	2757-2
stratified datalog¬ programs	with	constraint	i strata	2757-2
it	that	constraint	i	2757-3
it	for	constraint	i	2757-3
it	Then can be shown	attribute	all	2757-3
i		sequential	Strat	2757-3
Strat		sequential	i	2757-3
i	⊂	action	Strat i+1	2757-3
<B>	In	constraint	semipositive datalog¬	2757-4
semipositive datalog¬	than	constraint	stratified datalog¬	2757-4
semipositive datalog¬	is	attribute	weaker	2757-4
<B>	Well Founded	action	Datalog¬	2758-1
We	that	constraint	semantics	2759-1
We	prove	action	semantics	2759-1
We	well founded	action	semantics	2759-1
semantics	can express	action	precisely the fixpoint queries	2759-1
We	by	constraint	the semantics	2759-2
We	that	constraint	the semantics	2759-2
We	begin	action	the semantics	2759-2
We	showing	action	the semantics	2759-2
We	well founded	action	the semantics	2759-2
the semantics	by	constraint	a fixpoint query	2759-2
the semantics	can be computed	action	a fixpoint query	2759-2
<B>		sequential	we	2759-3
we	to	constraint	the set	2759-3
we	show	action	the set	2759-3
we	compute	action	the set	2759-3
the set	of	constraint	facts	2759-3
the set	and	conjunctive	facts	2759-3
facts	of	constraint	the answer	2759-3
the answer	using	action	a while	2759-3
a while	+	sequential	program	2759-3
program	see	action	Chapter 14	2759-3
Chapter 14	for	constraint	the definition	2759-3
the definition	of	constraint	while	2759-3
while	+	sequential	programs	2759-3
Theorem		sequential	15.4.4	2760-1
There	exists	action	a while	2760-2
a while	+	sequential	program	2760-2
program	w	constraint	input relations	2760-2
program	with	constraint	input relations	2760-2
input relations		sequential	edb	2760-2
edb		sequential	P	2760-2
P		sequential	<B>	2760-2
Crux	Let	action	P	2761-1
P	be	attribute	a datalog¬ program	2761-1
The while	+	sequential	program	2761-2
program	mimics	action	the alternating fixpoint computation	2761-2
the alternating fixpoint computation	of	constraint	P wf	2761-2
<B>	that	constraint	repeated applications	2761-3
<B>	Recall	attribute	this	2761-3
<B>	involves	action	repeated applications	2761-3
repeated applications	of	constraint	the operator conseq P	2761-3
the operator conseq P	in	constraint	the sequence I0 ≺ I2	2761-3
the operator conseq P	resulting	action	the sequence I0 ≺ I2	2761-3
<B>	.	sequential	<B>	2761-4
<B>	.	sequential	<B>	2761-5
<B>		sequential	i	2761-6
i		sequential	I2i+2	2761-6
<B>	.	sequential	<B>	2761-7
<B>	.	sequential	<B>	2761-8
I2i+1		sequential	I2i−1 ≺	2761-9
<B>	.	sequential	<B>	2761-10
<B>	.	sequential	<B>	2761-11
I1		sequential	I1	2761-12
<B>	that	constraint	the Ii	2762-1
<B>	Recall	action	the Ii	2762-1
the Ii	are	attribute	all total instances	2762-1
<B>	3 valued	action	instances	2762-2
instances	to	constraint	the final answer	2762-2
instances	Thus are only required	action	the final answer	2762-2
instances	produce	action	the final answer	2762-2
the final answer	from	constraint	I∗	2762-2
I∗	and	conjunctive	I∗	2762-2
I∗	at	constraint	the end	2762-2
the end	of	constraint	the computation	2762-2
the computation	by	constraint	first order	2762-2
first order		sequential	one last query	2762-2
It	that	constraint	one application	2763-1
It	while	constraint	one application	2763-1
It	+	sequential	one application	2763-1
It	is easily verified	action	one application	2763-1
It	can simulate	action	one application	2763-1
one application	of	constraint	conseq P	2763-1
conseq P	on	constraint	total instances	2763-1
total instances		sequential	Exercise	2763-1
Exercise		sequential	15.27	2763-1
The only delicate point	to	constraint	the computation	2763-2
The only delicate point	is	attribute	sure	2763-2
The only delicate point	make	attribute	sure	2763-2
the computation	is	attribute	inflationary	2763-2
<B>	To	constraint	this end	2763-3
this end		sequential	the program w	2763-3
the program w	between	constraint	results	2763-3
the program w	will distinguish	action	results	2763-3
results	of	constraint	iterations	2763-3
results	and	conjunctive	iterations	2763-3
iterations	of	constraint	conseq P	2763-3
conseq P	by	constraint	each R	2763-3
conseq P	for	constraint	each R	2763-3
conseq P	having	action	each R	2763-3
each R	and	conjunctive	an version	2763-3
an version		sequential	R0	2763-3
R0	and	conjunctive	R1	2763-3
R0 odd	at	constraint	iteration 2i	2763-4
R0 odd	holds	action	iteration 2i	2763-4
iteration 2i	+	sequential	1	2763-4
1		sequential	the negative facts	2763-4
the negative facts	of	constraint	R	2763-4
R	in	constraint	I2i+1	2763-4
I2i+1	and	conjunctive	R1	2763-4
R1	at	constraint	iteration 2	2763-4
R1	holds	action	iteration 2	2763-4
iteration 2		sequential	i	2763-4
i		sequential	even the positive facts	2763-4
even the positive facts	of	constraint	R	2763-4
R	in	constraint	I2i	2763-4
<B>	that	constraint	R0	2763-5
<B>	both	conjunctive	R0	2763-5
<B>	Note	action	R0	2763-5
R0		sequential	odd even computation	2763-5
We	on	constraint	the simulation the operator	2764-1
We	elaborate	action	the simulation the operator	2764-1
the simulation the operator	of	constraint	conseq P	2764-1
conseq P	on	constraint	a total instance I	2764-1
The program w	to	constraint	facts	2764-2
The program w	between	constraint	facts	2764-2
The program w	will have	action	facts	2764-2
The program w	distinguish	action	facts	2764-2
facts	in	constraint	the input I	2764-2
the input I	to	constraint	the negative premises	2764-2
the input I	used	action	the negative premises	2764-2
the input I	resolve	action	the negative premises	2764-2
the negative premises	of	constraint	rules	2764-2
rules	in	constraint	P	2764-2
P	by	constraint	applications	2764-2
P	and	conjunctive	applications	2764-2
P	inferred	action	applications	2764-2
applications	of	constraint	3 TP	2764-2
<B>	for	constraint	each relation R	2764-3
each relation R		sequential	the while	2764-3
the while	+	sequential	program	2764-3
program	Therefore will also maintain even	action	a copy	2764-3
a copy	¯	constraint	R	2764-3
R	to	constraint	the facts	2764-3
R	and	conjunctive	the facts	2764-3
R	R	attribute	¯ odd	2764-3
R	hold	action	the facts	2764-3
the facts	by	constraint	consecutive applications	2764-3
the facts	produced	action	consecutive applications	2764-3
consecutive applications	of	constraint	3 TP	2764-3
3 TP	in	constraint	the cases	2764-3
3 TP	and	conjunctive	the cases	2764-3
the cases		sequential	<B>	2764-3
<B>		sequential	the ¯ R odd	2764-4
the ¯ R odd	hold	action	the positive facts	2764-4
the positive facts	from	constraint	input I2i	2764-4
the positive facts	inferred	action	input I2i	2764-4
input I2i	in	constraint	R1	2764-4
input I2i	represented	action	R1	2764-4
R1	and	conjunctive	even the ¯ R	2764-4
even the ¯ R	even hold	action	the positive facts	2764-4
the positive facts	from	constraint	input I2i+1	2764-4
the positive facts	inferred	action	input I2i+1	2764-4
input I2i+1	in	constraint	R0	2764-4
input I2i+1	represented	action	R0	2764-4
It	to	constraint	first order	2764-5
It	is	attribute	easy	2764-5
It	write	action	first order	2764-5
first order		sequential	a query	2764-5
a query	defining	action	one application	2764-5
one application	of	constraint	3 TP	2764-5
3 TP	for	constraint	the cases	2764-5
3 TP	or	conjunctive	the cases	2764-5
<B>	Because	constraint	the representations	2765-1
the representations	of	constraint	the input	2765-1
the input	in	constraint	the cases	2765-1
the input	and	conjunctive	the cases	2765-1
the input	are	attribute	different	2765-1
the cases		sequential	different programs	2765-1
different programs	in	constraint	the two cases	2765-1
different programs	must be used	action	the two cases	2765-1
<B>	in	constraint	an inflationary manner	2765-2
<B>	can be iterated	action	an inflationary manner	2765-2
an inflationary manner	because	constraint	the set	2765-2
the set	of	constraint	positive facts	2765-2
positive facts	in	constraint	consecutive applications	2765-2
positive facts	inferred	action	consecutive applications	2765-2
consecutive applications	of	constraint	3 TP	2765-2
3 TP	is always increasing	action	<B>	2765-2
the ¯ R odd	to	constraint	each application	2765-3
the ¯ R odd	to	constraint	each application	2765-3
the ¯ R odd	at	constraint	each application	2765-3
the ¯ R odd	and	conjunctive	each application	2765-3
the ¯ R odd	¯ R	action	each application	2765-3
the ¯ R odd	However even have	action	each application	2765-3
the ¯ R odd	be initialized	action	each application	2765-3
each application	of	constraint	conseq P	2765-3
<B>	Because	constraint	the computation	2765-4
the computation	be	attribute	must inflationary	2765-4
the computation	can not be done directly	action	<B>	2765-4
timestamping	Instead must be used	action	<B>	2766-1
The initialization	of	constraint	the ¯ R odd	2766-2
the ¯ R odd	and	conjunctive	¯ R	2766-2
¯ R	by	constraint	each relation	2766-2
¯ R	even is simulated	action	each relation	2766-2
¯ R	timestamping	action	each relation	2766-2
each relation	with	constraint	the current content even R0 odd	2766-2
the current content even R0 odd	of	constraint	R1	2766-2
R1	in	constraint	a manner	2766-2
R1	is done	action	a manner	2766-2
a manner	to	constraint	the proofs	2766-2
the proofs	of	constraint	Chapter 14	2766-2
We	now exhibit	action	a converse	2767-1
a converse	of	constraint	Theorem	2767-1
Theorem		sequential	15.4.4	2767-1
15.4.4	that	constraint	any fixpoint query	2767-1
15.4.4	showing	action	any fixpoint query	2767-1
any fixpoint query	by	constraint	a datalog¬ program	2767-1
any fixpoint query	can essentially be simulated	action	a datalog¬ program	2767-1
a datalog¬ program	with	constraint	semantics	2767-1
a datalog¬ program	founded	action	semantics	2767-1
the positive portion	of	constraint	the semantics	2767-2
the positive portion	well founded	action	the semantics	2767-2
the semantics	More precisely yields	action	the same facts	2767-2
the same facts	as	constraint	the fixpoint query	2767-2
Example		sequential	15.4.6	2768-1
15.4.6	illustrates	action	the proof	2768-1
the proof	of	constraint	this result	2768-1
Theorem		sequential	15.4.5	2769-1
Crux		sequential	Crux	2770-1
<B>	Let	action	q	2770-2
q	be	attribute	a fixpoint query	2770-2
<B>	As	constraint	Chapter 14	2770-3
<B>	in	constraint	Chapter 14	2770-3
<B>	discussed	action	Chapter 14	2770-3
Chapter 14		sequential	there	2770-3
there	exists	action	a CALC formula	2770-3
a CALC formula		sequential	T	2770-3
T	in	constraint	T	2770-3
T	that	constraint	q	2770-3
q	by	constraint	µT	2770-3
q	is defined	action	µT	2770-3
µT		sequential	ϕ	2770-3
ϕ		sequential	T	2770-3
T		sequential	u	2770-3
u		sequential	u	2770-3
u	is	attribute	where a vector	2770-3
where a vector	of	constraint	variables	2770-3
variables	and	conjunctive	constants	2770-3
<B>	Consider	action	the CALC formula	2770-4
the CALC formula		sequential	T	2770-4
<B>	As	constraint	this section	2770-5
<B>	in	constraint	this section	2770-5
<B>	noted earlier	action	this section	2770-5
this section		sequential	there	2770-5
there	is	attribute	an nr-datalog¬ program	2770-5
<B>	Because	constraint	T	2770-6
T	in	constraint	T	2770-6
T	is	attribute	positive	2770-6
T	along	constraint	any path	2770-6
any path	in	constraint	the syntax tree	2770-6
the syntax tree	of	constraint	ϕ	2770-6
ϕ		sequential	T	2770-6
T	with	constraint	atom T	2770-6
T	ending	action	atom T	2770-6
atom T		sequential	there	2770-6
there	is	attribute	an even number	2770-6
an even number	of	constraint	negations	2770-6
<B>	of	constraint	paths	2770-7
<B>	is	attribute	also true	2770-7
paths	in	constraint	GP	2770-7
<B>	Consider	action	the precedence	2771-1
the precedence		sequential	graph GP	2771-1
graph GP	of	constraint	P	2771-1
P		sequential	each idb relation	2771-1
each idb relation	except	constraint	T	2771-1
T	in	constraint	the definition	2771-1
T	is used	action	the definition	2771-1
the definition	of	constraint	exactly one other idb relation	2771-1
exactly one other idb relation	and	conjunctive	all idb relations	2771-1
all idb relations	in	constraint	the definition	2771-1
all idb relations	are used eventually	action	the definition	2771-1
the definition	of	constraint	the answer R′	2771-1
<B>	In	constraint	other words	2771-2
other words	for	constraint	each idb relation R	2771-2
each idb relation R	than	constraint	T	2771-2
T		sequential	there	2771-2
there	is	attribute	a unique path	2771-2
a unique path	in	constraint	GP	2771-2
GP	from	constraint	R	2771-2
R	to	constraint	R′	2771-2
<B>	Consider	action	the paths	2771-3
the paths	from	constraint	T	2771-3
T	to	constraint	some idb relation	2771-3
some idb relation		sequential	R	2771-3
R	in	constraint	Pϕ	2771-3
<B>	Without	constraint	loss	2771-4
loss	of	constraint	generality	2771-4
generality		sequential	we	2771-4
we	that	constraint	all paths	2771-4
we	can assume	action	all paths	2771-4
all paths	have	action	the same number	2771-4
the same number	of	constraint	negations	2771-4
negations	because	constraint	all paths	2771-4
all paths	to	constraint	T	2771-4
T	have	action	an even number	2771-4
an even number	of	constraint	negations	2771-4
negations		sequential	additional idb relations	2771-4
additional idb relations	to	constraint	the paths	2771-4
additional idb relations	can be introduced	action	the paths	2771-4
additional idb relations	pad	action	the paths	2771-4
the paths	with	constraint	fewer negations	2771-4
fewer negations	using	action	rules	2771-4
rules		sequential	that	2771-4
that	perform	action	redundant double negations	2771-4
<B>	Let	action	the rank	2771-5
the rank	of	constraint	an idb relation R	2771-5
an idb relation R	in	constraint	Pϕ	2771-5
Pϕ	be	attribute	the number	2771-5
the number	of	constraint	negations	2771-5
negations	on	constraint	each path	2771-5
each path	from	constraint	T	2771-5
each path	leading	action	T	2771-5
T	to	constraint	R	2771-5
R	in	constraint	GP	2771-5
<B>	Now let	action	P	2772-1
P	be	attribute	the datalog¬ program	2772-1
the datalog¬ program	from	constraint	Pϕ	2772-1
the datalog¬ program	obtained	action	Pϕ	2772-1
Pϕ	as	constraint	<B>	2772-1
Pϕ	follows	action	<B>	2772-1
The purpose	of	constraint	R′	2773-1
The purpose	replacing	action	R′	2773-1
R′	by	constraint	T	2773-1
T	to	constraint	program	2773-1
T	is	attribute	program	2773-1
T	cause	action	program	2773-1
The last rule	to	constraint	the final selection	2774-1
The last rule	is added	action	the final selection	2774-1
The last rule	perform	action	the final selection	2774-1
the final selection	and	conjunctive	projection	2774-1
projection	to	constraint	the answer µT	2774-1
projection	needed	action	the answer µT	2774-1
projection	obtain	action	the answer µT	2774-1
the answer µT		sequential	ϕ	2774-1
ϕ		sequential	T	2774-1
T		sequential	u	2774-1
<B>	that	constraint	some sense	2774-2
<B>	in	constraint	some sense	2774-2
<B>	Note	action	some sense	2774-2
some sense		sequential	P	2774-2
P	except	constraint	the fact	2774-2
P	for	constraint	the fact	2774-2
P	is almost stratified	action	the fact	2774-2
the fact	that	constraint	the result T	2774-2
the result T	into	constraint	the program	2774-2
the result T	is fed back	action	the program	2774-2
<B>	Consider	action	the alternating fixpoint sequence	2775-1
<B>	Suppose	action	R′	2775-2
R′	has rank	action	q	2775-2
q	in	constraint	Pϕ	2775-2
Pϕ	and	conjunctive	R	2775-2
Pϕ	let	action	R	2775-2
R	be	attribute	an idb relation	2775-2
an idb relation	of	constraint	Pϕ	2775-2
Pϕ		sequential	whose rank	2775-2
whose rank	in	constraint	Pϕ	2775-2
Pϕ	is	attribute	r	2775-2
r		sequential	≤ q	2775-2
there	Intuitively is	action	a close correspondence	2776-1
a close correspondence	between	constraint	the sequence	2776-1
There	is however	action	one minor glitch	2776-2
<B>	in	constraint	a mismatch	2776-3
<B>	results	action	a mismatch	2776-3
<B>	To	constraint	the problem	2776-4
<B>	fix	action	the problem	2776-4
the problem	consider	action	a variation	2776-4
a variation	of	constraint	the alternating fixpoint computation	2776-4
the alternating fixpoint computation	of	constraint	P wf	2776-4
P wf		sequential	I	2776-4
I	as	constraint	I0 Ii+1	2776-4
I	defined	action	I0 Ii+1	2776-4
I	follows	action	I0 Ii+1	2776-4
I0 Ii+1	=	sequential	conseq P Ii	2776-4
Clearly I0		sequential	P wf	2777-1
P wf		sequential	I	2777-1
<B>	by	constraint	Proposition 15.3.10	2777-2
Proposition 15.3.10		sequential	I∗	2777-2
I∗	Then =	sequential	P wf	2777-2
P wf		sequential	I	2777-2
<B>	by	constraint	induction	2778-1
<B>	Now can be verified	action	induction	2778-1
induction	for	constraint	each idb relation	2778-1
each idb relation		sequential	R	2778-1
R	of	constraint	rank r	2778-1
rank r	For	constraint	i	2778-1
i		sequential	Iiq+r 1	2778-1
Iiq+r 1	contains	action	exactly the facts	2778-1
exactly the facts	of	constraint	R true	2778-1
R true	in	constraint	Pϕ	2778-1
Pϕ		sequential	ϕi	2778-1
ϕi		sequential	∅	2778-1
<B>	because	constraint	each application	2779-1
<B>	is	attribute	each application	2779-1
each application	of	constraint	conseq P	2779-1
conseq P	propagates	action	the correct result	2779-1
the correct result	across	constraint	one application	2779-1
one application	of	constraint	negation	2779-1
negation	to	constraint	an idb predicate	2779-1
<B>	Because	constraint	R′	2779-2
R′		sequential	has rank q	2779-2
has rank q		sequential	it	2779-2
it	takes	action	q applications	2779-2
q applications	to	constraint	a complete application	2779-2
q applications	simulate	action	a complete application	2779-2
a complete application	of	constraint	Pϕ	2779-2
<B>	In	constraint	it	2779-3
it	for	constraint	i	2779-3
it	follows	attribute	that	2779-3
i		sequential	Iiq 1	2779-3
Iiq 1	in	constraint	T	2779-3
Iiq 1	contains	action	T	2779-3
T		sequential	the facts	2779-3
the facts	in	constraint	ϕi	2779-3
ϕi		sequential	∅	2779-3
1	in	constraint	T	2780-1
1	Thus I∗ contains	action	T	2780-1
T		sequential	the facts	2780-1
the facts	in	constraint	µT	2780-1
µT		sequential	ϕ	2780-1
ϕ		sequential	T	2780-1
answer	by	constraint	a simple selection	2780-2
answer	Finally is obtained	action	a simple selection	2780-2
a simple selection	and	conjunctive	projection	2780-2
projection	from	constraint	T	2780-2
T	using	action	the last rule	2780-2
the last rule	in	constraint	P	2780-2
P	and	conjunctive	yields	2780-2
yields		sequential	µT	2780-2
µT		sequential	ϕ	2780-2
ϕ		sequential	T	2780-2
T		sequential	u	2780-2
<B>	In	constraint	the preceding theorem	2781-1
the preceding theorem		sequential	the positive portion	2781-1
the positive portion	of	constraint	answer	2781-1
answer	for	constraint	P wf	2781-1
P wf		sequential	I	2781-1
I	with	constraint	q	2781-1
I	coincides	action	q	2781-1
q		sequential	I	2781-1
P wf		sequential	I	2781-2
I	to	constraint	it	2781-2
I	However is not guaranteed	attribute	total	2781-2
I	be	attribute	total	2781-2
it	may contain	action	unknown facts	2781-2
<B>	Using	action	a recent result	2782-1
a recent result	not demonstrated here	action	a program Q	2782-1
a program Q	that	constraint	Qwf	2782-1
a program Q	can be found	attribute	such	2782-1
Qwf	always provides	action	a total answer	2782-1
a total answer	that	constraint	the positive facts	2782-1
a total answer	and	conjunctive	the positive facts	2782-1
the positive facts	of	constraint	P wf	2782-1
P wf	and	conjunctive	Qwf	2782-1
Qwf	on	constraint	all inputs	2782-1
Qwf	coincide	action	all inputs	2782-1
<B>	from	constraint	Chapter 14	2783-1
<B>	Recall	action	Chapter 14	2783-1
Chapter 14	that	constraint	datalog¬	2783-1
datalog¬	with	constraint	inflationary semantics	2783-1
inflationary semantics	also expresses precisely	action	the fixpoint queries	2783-1
we	Thus have converged again	action	this time	2783-2
this time	by	constraint	the deductive database path	2783-2
the deductive database path	to	constraint	the fixpoint queries	2783-2
<B>	bears	action	witness	2783-3
witness	to	constraint	the naturalness	2783-3
the naturalness	of	constraint	this class	2783-3
<B>	In	constraint	the semantics	2783-4
<B>	and	conjunctive	the semantics	2783-4
<B>	well founded	attribute	inflationary	2783-4
the semantics	although	constraint	the same expressive power	2783-4
the semantics	have	action	the same expressive power	2783-4
the same expressive power		sequential	modulo	2783-4
modulo		sequential	the difference	2783-4
the difference	between	constraint	3 models	2783-4
the difference	and	conjunctive	3 models	2783-4
the difference	-	sequential	3 models	2783-4
the difference	valued	action	3 models	2783-4
the difference	2 valued	action	3 models	2783-4
Example		sequential	15.4.6	2784-1
<B>	that	constraint	this query	2785-1
<B>	Recall	action	this query	2785-1
this query	in	constraint	Chapter	2785-1
this query	also encountered	action	Chapter	2785-1
Chapter		sequential	14	2785-1
14	computes	attribute	good	2785-1
the nodes	of	constraint	the graph G	2785-1
the graph G		sequential	that	2785-1
that	from	constraint	a cycle	2785-1
that	can not be reached	action	a cycle	2785-1
The nr-datalog¬ program		sequential	The nr-datalog¬ program	2785-2
The answer		sequential	R′	2785-3
R′	has rank	action	two	2785-3
The program P	as	constraint	x	2785-4
The program P	is	attribute	bad	2785-4
The program P	follows	attribute	bad	2785-4
x		sequential	x	2785-4
The consecutive values	of	constraint	ϕi	2786-1
ϕi	are	attribute	<B>	2786-1
<B>	ϕ	conjunctive	x	2787-1
x	Thus yields	action	the answer	2787-1
the answer		sequential	e	2787-1
e		sequential	}	2787-1
<B>	Consider now	action	the alternating fixpoint sequence	2787-2
the alternating fixpoint sequence	in	constraint	the computation	2787-2
the computation	of	constraint	P wf	2787-2
P wf	on	constraint	the same input	2787-2
the same input		sequential	only the positive facts	2787-2
only the positive facts	of	constraint	G	2787-2
only the positive facts	because	constraint	G	2787-2
only the positive facts	and	conjunctive	G	2787-2
only the positive facts	are listed	action	G	2787-2
G	and	conjunctive	<B>	2787-2
G	=	sequential	<B>	2787-2
G	does not change	attribute	good	2787-2
G	answer	attribute	good	2787-2
Negation bad Thus	in	constraint	Datalog	2788-1
Datalog		sequential	I0 I1 I2	2788-1
I0 I1 I2		sequential	I3 I4	2788-1
I3 I4		sequential	I5 I6	2788-1
The relative expressive power	of	constraint	the various languages	2789-1
the various languages	in	constraint	this chapter	2789-1
the various languages	discussed	action	this chapter	2789-1
this chapter	in	constraint	Fig	2789-1
this chapter	is summarized	action	Fig	2789-1
15.3		sequential	15.3	2789-2
The arrows	indicate	action	strict inclusion	2789-3
<B>	For	constraint	a view	2789-4
a view	of	constraint	these languages	2789-4
these languages	in	constraint	a larger context	2789-4
a larger context	see also	action	Figs	2789-4
18.4	and	conjunctive	18.5	2789-5
18.5	at	constraint	the end	2789-5
the end	of	constraint	Part E	2789-5
The Impact	of	constraint	Order	2790-1
Order		sequential	we	2790-1
we	at	constraint	the impact	2790-1
we	Finally look	action	the impact	2790-1
the impact	of	constraint	order	2790-1
order	on	constraint	the expressive power	2790-1
the expressive power	of	constraint	the various datalog¬ semantics	2790-1
<B>	As	constraint	we	2790-2
we	at	constraint	length	2790-2
we	will discuss	action	length	2790-2
length	in	constraint	Chapter 17	2790-2
Chapter 17		sequential	the assumption	2790-2
the assumption	that	constraint	databases	2790-2
databases	are ordered	action	a dramatic impact	2790-2
databases	can have	action	a dramatic impact	2790-2
a dramatic impact	on	constraint	the expressive power	2790-2
the expressive power	of	constraint	languages	2790-2
languages	like	constraint	fixpoint	2790-2
fixpoint	or	conjunctive	while	2790-2
The datalog¬ languages	are	attribute	no exception	2790-3
The effect	of	constraint	order	2790-4
order	is	attribute	spectacular	2790-4
<B>	With	constraint	this assumption	2791-1
this assumption		sequential	it	2791-1
it	that	constraint	semipositive datalog¬	2791-1
it	turns out	action	semipositive datalog¬	2791-1
semipositive datalog¬	as	constraint	stratified datalog¬	2791-1
semipositive datalog¬	is	attribute	as powerful	2791-1
stratified datalog¬	and	conjunctive	datalog¬	2791-1
datalog¬	with	constraint	semantics	2791-1
datalog¬	founded	action	semantics	2791-1
<B>	from	constraint	a semantics datalog¬	2791-2
<B>	comes	action	a semantics datalog¬	2791-2
<B>	well founded	action	a semantics datalog¬	2791-2
a semantics datalog¬		sequential	fixpoint semantics datalog¬ stratified datalog¬ semipositive datalog¬ datalog	2791-2
fixpoint semantics datalog¬ stratified datalog¬ semipositive datalog¬ datalog		sequential	Figure 15.3	2791-2
Figure 15.3		sequential	Relative expressive power	2791-2
Relative expressive power	of	constraint	datalog	2791-2
datalog		sequential	¬	2791-2
¬		sequential	languages technicality	2791-2
languages technicality	concerning	action	the order	2791-2
these constants		sequential	which	2791-3
which	with	constraint	a first order query	2791-3
which	can be computed	action	a first order query	2791-3
a first order query	if	constraint	succ	2791-3
succ	with	constraint	semipositive programs	2791-3
succ	is given	action	semipositive programs	2791-3
succ	Surprisingly can not be computed	action	semipositive programs	2791-3
semipositive programs	see	action	Exercise 15.29	2791-3
The next lemma	that	constraint	semipositive programs	2792-1
The next lemma	states	action	semipositive programs	2792-1
semipositive programs	express	action	the fixpoint queries	2792-1
the fixpoint queries	on	constraint	ordered databases	2792-1
ordered databases	with	constraint	min	2792-1
min	and	conjunctive	max	2792-1
max		sequential	databases	2792-1
databases	with	constraint	a predicate succ	2792-1
a predicate succ	providing	action	a successor relation	2792-1
a successor relation	among	constraint	all constants	2792-1
all constants	and	conjunctive	max	2792-1
all constants	and	conjunctive	max	2792-1
max	and	conjunctive	the largest constant	2792-1
max	containing	attribute	the smallest	2792-1
Lemma		sequential	15.4.7	2793-1
Crux		sequential	Crux	2794-1
<B>	Because	constraint	T	2794-2
T	in	constraint	T	2794-2
T	is	attribute	positive	2794-2
T		sequential	we	2794-2
we	that	constraint	T	2794-2
we	can assume	action	T	2794-2
T	in	constraint	prenex normal form Q1x1Q2x2	2794-2
T	is	attribute	prenex normal form Q1x1Q2x2	2794-2
<B>	.	sequential	<B>	2794-3
<B>	.	sequential	<B>	2794-4
Qkxk		sequential	ψ	2794-5
ψ		sequential	ψ	2794-5
ψ	is	attribute	where a quantifier free formula	2794-5
where a quantifier free formula	in	constraint	disjunctive normal form	2794-5
disjunctive normal form	and	conjunctive	T	2794-5
T	in	constraint	ψ	2794-5
T	is not negated	action	ψ	2794-5
We	by	constraint	induction	2794-6
We	show	action	induction	2794-6
induction	on	constraint	k	2794-6
k	that	constraint	there	2794-6
there	exists	action	a semipositive datalog¬ program	2794-6
<B>	Suppose	action	k	2794-7
k	=	sequential	0	2794-7
0		sequential	ϕ	2794-7
ϕ	=	sequential	ψ	2794-7
Pϕ	is	attribute	Then the nr-datalog¬ program	2794-8
Then the nr-datalog¬ program	to	constraint	ψ	2794-8
Then the nr-datalog¬ program	corresponding	action	ψ	2794-8
ψ		sequential	the answer relation	2794-8
the answer relation	is	attribute	where T	2794-8
<B>	Because	constraint	ψ	2794-9
ψ	is	attribute	quantifier	2794-9
quantifier	and	conjunctive	T	2794-9
T	in	constraint	ψ	2794-9
T	is not negated	action	ψ	2794-9
ψ		sequential	Pϕ	2794-9
Pϕ	is	attribute	clearly semipositive	2794-9
<B>	Next suppose	action	the statement	2794-10
the statement	for	constraint	some k ≥ 0	2794-10
the statement	is	attribute	true	2794-10
some k ≥ 0	and	conjunctive	ϕ	2794-10
some k ≥ 0	let	action	ϕ	2794-10
ϕ		sequential	T	2794-10
T	have	action	quantifier depth k 1	2794-10
There	are	attribute	two cases	2794-11
two cases	i =	sequential	∃xψ	2794-11
∃xψ		sequential	x v	2794-11
x v		sequential	ψ	2794-11
ψ	where has	action	quantifier depth k	2794-11
R′		sequential	x	2795-1
x		sequential	v	2795-1
v	←	sequential	T	2795-1
T		sequential	′	2795-1
′		sequential	x	2795-1
x		sequential	v	2795-1
v		sequential	min	2795-1
min		sequential	x	2795-1
x		sequential	R′	2795-1
R′		sequential	x′	2795-1
x′		sequential	v	2795-1
the program	through	constraint	all x	2795-2
the program	Thus steps	action	all x	2795-2
all x	using	action	the successor relation succ	2795-2
the successor relation succ	from	constraint	the minimum constant	2795-2
the successor relation succ	starting	action	the minimum constant	2795-2
<B>	If	constraint	the maximum constant	2795-3
the maximum constant	is reached	action	T	2795-3
T		sequential	x	2795-3
x		sequential	v	2795-3
v	for	constraint	all x	2795-3
v	is	attribute	satisfied	2795-3
all x	and	conjunctive	T	2795-3
T		sequential	v	2795-3
v	is inferred	action	<B>	2795-3
<B>	completes	action	the induction	2796-1
Negation	in	constraint	Datalog	2797-1
Datalog	in	constraint	time polynomial	2797-1
Datalog	queries	attribute	computable	2797-1
time polynomial	in	constraint	the size	2797-1
the size	of	constraint	the database	2797-1
the database		sequential	qptime	2797-1
we	Thus obtain	action	the following result	2797-2
<B>	In	constraint	semantics	2797-3
<B>	comparing	action	semantics	2797-3
<B>	well founded	action	semantics	2797-3
semantics	with	constraint	the others	2797-3
the others		sequential	we	2797-3
we	take	action	the positive portion	2797-3
the positive portion	of	constraint	the semantics	2797-3
the positive portion	well founded	action	the semantics	2797-3
the semantics	as	constraint	the answer	2797-3
Theorem		sequential	15.4.8	2798-1
They	to	constraint	semipositive datalog¬	2798-2
They	are	attribute	also equivalent	2798-2
semipositive datalog¬	on	constraint	ordered databases	2798-2
ordered databases	with	constraint	min	2798-2
min	and	conjunctive	max	2798-2
max	and	conjunctive	exactly qptime	2798-2
max	express	action	exactly qptime	2798-2
Negation	as	constraint	Failure	2799-1
Failure	in	constraint	Brief	2799-1
One	if	constraint	such a counterpart	2800-1
One	might naturally wonder	action	such a counterpart	2800-1
such a counterpart	in	constraint	the case	2800-1
such a counterpart	exists	action	the case	2800-1
the case	of	constraint	datalog¬	2800-1
The answer	and	conjunctive	<B>	2800-2
The answer	is	attribute	<B>	2800-2
proof		sequential	Such a approach	2800-3
Such a approach	and	conjunctive	negation	2800-3
Such a approach	has indeed been proposed	action	negation	2800-3
Such a approach	is called	action	negation	2800-3
negation	as	constraint	failure	2800-3
<B>	for	constraint	logic programming	2800-4
<B>	was originally developed	action	logic programming	2800-4
logic programming	and	conjunctive	semantics	2800-4
logic programming	and	conjunctive	semantics	2800-4
logic programming	predates	action	semantics	2800-4
logic programming	stratified	action	semantics	2800-4
logic programming	well founded	action	semantics	2800-4
the approach	Unfortunately has	action	two major drawbacks	2800-5
<B>	that	constraint	it	2800-6
<B>	is	attribute	it	2800-6
it	in	constraint	proof building	2800-6
it	results	action	proof building	2800-6
proof building		sequential	a procedure	2800-6
a procedure		sequential	that	2800-6
that	does not always terminate	action	<B>	2800-6
<B>	that	constraint	it	2800-7
<B>	is	attribute	it	2800-7
it	is	attribute	not the exact counterpart	2800-7
not the exact counterpart	of	constraint	any other existing semantics	2800-7
The semantics		sequential	that	2801-1
that	as	constraint	a possible match	2801-1
that	has been proposed	action	a possible match	2801-1
a possible match	is	attribute	Clark	2801-1
Clark		sequential	completion	2801-1
completion	but	conjunctive	the match	2801-1
the match	and	conjunctive	Clark	2801-1
the match	is	attribute	not perfect	2801-1
Clark		sequential	completion	2801-1
completion	has	action	its own problems	2801-1
We	and	conjunctive	only a presentation	2801-2
We	provide here	attribute	brief	2801-2
only a presentation	of	constraint	negation	2801-2
negation	as	constraint	failure	2801-2
failure	and	conjunctive	Clark	2801-2
Clark		sequential	the related completion	2801-2
The idea	behind	constraint	negation	2802-1
negation	as	constraint	failure	2802-1
failure	is	attribute	simple	2802-1
We	to	constraint	a negative fact resolution	2802-2
We	would like	action	a negative fact resolution	2802-2
We	infer	action	a negative fact resolution	2802-2
we	to	constraint	a weaker notion	2802-3
we	Instead have	action	a weaker notion	2802-3
we	use	action	a weaker notion	2802-3
a weaker notion	of	constraint	negation	2802-3
negation	by	constraint	failure	2802-3
failure		sequential	which	2802-3
which	can be checked	action	<B>	2802-3
<B>	as	constraint	<B>	2802-4
<B>	is done	action	<B>	2802-4
<B>	follows	action	<B>	2802-4
fact		sequential	A A	2802-5
A A	if	constraint	all SLD derivations	2802-5
A A	is proven	action	all SLD derivations	2802-5
all SLD derivations	from	constraint	the goal	2802-5
all SLD derivations	starting	action	the goal	2802-5
the goal	←	sequential	<B>	2802-5
<B>	In	constraint	other words	2802-6
other words	finitely fails	action	<B>	2802-6
This procedure	to	constraint	ground atoms A	2802-7
This procedure	applies only	action	ground atoms A	2802-7
It	gives	action	rise	2802-8
rise	to	constraint	a proof procedure	2802-8
a proof procedure	called	action	SLDNF resolution	2802-8
SLDNF resolution	Briefly extends	action	SLD resolution	2802-9
SLD resolution	as	constraint	<B>	2802-9
SLD resolution	follows	action	<B>	2802-9
Refutations	of	constraint	positive facts	2802-10
positive facts	as for	constraint	SLD resolution	2802-10
positive facts	proceed	action	SLD resolution	2802-10
a negative ground goal	←	sequential	A	2802-11
A	to	constraint	SLD resolution	2802-11
A	Whenever has	action	SLD resolution	2802-11
A	be proven	action	SLD resolution	2802-11
SLD resolution	to	constraint	A	2802-11
SLD resolution	←	sequential	A	2802-11
SLD resolution	is applied	action	A	2802-11
A	and	conjunctive	A	2802-11
A	if	constraint	the SLD resolution	2802-11
A	is proven	action	the SLD resolution	2802-11
the SLD resolution	for	constraint	<B>	2802-11
the SLD resolution	finitely fails	action	<B>	2802-11
The idea	of	constraint	SLDNF	2802-12
SLDNF	as	constraint	the version	2802-12
SLDNF	seems	attribute	appealing	2802-12
the version	of	constraint	the closed world assumption	2802-12
<B>	as	constraint	it	2802-13
<B>	illustrated next	action	it	2802-13
it	to	constraint	significant problems	2802-13
it	However quickly leads	action	significant problems	2802-13
Example		sequential	15.5.1	2803-1
<B>	Consider	action	the instance	2804-1
the instance		sequential	I	2804-1
I		sequential	G	2804-1
G	where has	action	edges	2804-1
edges		sequential	c	2804-1
c		sequential	a }	2804-1
a c	in	constraint	Clearly not the transitive closure	2804-2
a c	is	attribute	Clearly not the transitive closure	2804-2
Clearly not the transitive closure	of	constraint	G	2804-2
G	in	constraint	so not T	2804-2
G	and	conjunctive	so not T	2804-2
so not T	by	constraint	the usual datalog semantics	2804-2
<B>	Suppose	action	we	2804-3
we	to	constraint	the fact	2804-3
we	wish	action	the fact	2804-3
we	prove	action	the fact	2804-3
the fact		sequential	¬T	2804-3
¬T		sequential	a c	2804-3
a c	using	action	negation	2804-3
negation	as	constraint	failure	2804-3
We	to	constraint	SLD resolution	2804-4
We	that	constraint	SLD resolution	2804-4
We	have	action	SLD resolution	2804-4
We	show	action	SLD resolution	2804-4
SLD resolution	on	constraint	T	2804-4
SLD resolution	finitely fails	action	T	2804-4
T		sequential	a c	2804-4
a c	with	constraint	the preceding program	2804-4
the preceding program	and	conjunctive	input	2804-4
SLD resolution	Unfortunately can enter	action	a negative loop	2804-5
a negative loop	to	constraint	T	2804-5
a negative loop	when applied	action	T	2804-5
T		sequential	a	2804-5
a		sequential	c	2804-5
One	obtains	action	the following SLD derivation	2804-6
<B>	that	constraint	the last goal	2805-1
<B>	Note	action	the last goal	2805-1
the last goal	as	constraint	an infinite derivation	2805-1
the last goal	to	constraint	an infinite derivation	2805-1
the last goal	is	attribute	the same	2805-1
the last goal	so can be extended	action	an infinite derivation	2805-1
It	that	constraint	SLD resolution	2805-2
It	follows	action	SLD resolution	2805-2
SLD resolution	on	constraint	T	2805-2
SLD resolution	←	sequential	T	2805-2
SLD resolution	does not finitely fail	action	T	2805-2
T		sequential	a c	2805-2
a c		sequential	SLDNF	2805-2
SLDNF	so does not yield	action	a proof	2805-2
a proof	of	constraint	¬T	2805-2
¬T		sequential	a c	2805-2
it	that	constraint	the particular program	2805-3
it	on	constraint	the particular program	2805-3
it	Moreover has been shown	attribute	this	2805-3
it	does not depend	action	the particular program	2805-3
the particular program	to	constraint	transitive closure	2805-3
the particular program	used	action	transitive closure	2805-3
the particular program	define	action	transitive closure	2805-3
<B>	In	constraint	other words	2805-4
other words		sequential	there	2805-4
there	is	attribute	no datalog¬ program	2805-4
no datalog¬ program		sequential	that	2805-4
that	under	constraint	SLDNF	2805-4
SLDNF	and	conjunctive	the facts	2805-4
SLDNF	can prove	attribute	positive	2805-4
the facts	of	constraint	the transitive closure	2805-4
the transitive closure	of	constraint	a graph	2805-4
The preceding example	that	constraint	SLDNF	2806-1
The preceding example	shows	action	SLDNF	2806-1
SLDNF	in	constraint	even some simple cases	2806-1
SLDNF	can behave counterintuitively	action	even some simple cases	2806-1
The behavior	with	constraint	all the semantics	2806-2
The behavior	is	attribute	also incompatible	2806-2
all the semantics	for	constraint	negation	2806-2
negation		sequential	that	2806-2
that		sequential	we	2806-2
we	have discussed so far	action	<B>	2806-2
one	for	constraint	a match	2806-3
one	Thus can not hope	action	a match	2806-3
a match	between	constraint	SLDNF	2806-3
SLDNF	and	conjunctive	these semantics	2806-3
a semantics	called	action	Clark	2807-1
Clark		sequential	completion	2807-1
completion	as	constraint	a candidate match	2807-1
completion	Instead has been proposed	action	a candidate match	2807-1
a candidate match	for	constraint	negation	2807-1
negation	as	constraint	failure	2807-1
It	as	constraint	<B>	2807-2
It	works	action	<B>	2807-2
It	follows	action	<B>	2807-2
<B>	For	constraint	a datalog¬ program P	2807-3
a datalog¬ program P		sequential	the completion	2807-3
the completion	of	constraint	P	2807-3
P		sequential	comp	2807-3
comp		sequential	P	2807-3
P	as	constraint	<B>	2807-3
P	is constructed	action	<B>	2807-3
P	follows	action	<B>	2807-3
<B>	For	constraint	each idb predicate R	2807-4
each idb predicate R		sequential	each rule ρ	2807-4
each rule ρ		sequential	R	2807-4
R		sequential	u	2807-4
u		sequential	L1	2807-4
L1		sequential	v1	2807-4
<B>	.	sequential	<B>	2807-5
<B>	.	sequential	<B>	2807-6
Ln		sequential	vn	2807-7
vn	defining	action	R	2807-7
R	is rewritten	action	there	2807-7
there	so is	action	a uniform set	2807-7
a uniform set	of	constraint	distinct variables	2807-7
distinct variables	in	constraint	the rule head	2807-7
the rule head	and	conjunctive	all free variables	2807-7
all free variables	in	constraint	the body	2807-7
the body	so are existentially quantified	action	<B>	2807-7
l		sequential	l	2808-1
<B>	Intuitively states	action	that	2809-1
that		sequential	ground atom R	2809-1
ground atom R		sequential	w	2809-1
w	iff	constraint	it	2809-1
w	is	attribute	true	2809-1
it	by	constraint	one	2809-1
it	is supported	action	one	2809-1
one	of	constraint	the rules	2809-1
the rules	defining	action	R.	2809-1
R.		sequential	the completion	2809-1
the completion	of	constraint	P	2809-1
P	is	attribute	Finally the set	2809-1
Finally the set	of	constraint	completions	2809-1
completions	of	constraint	all idb predicates	2809-1
all idb predicates	of	constraint	P	2809-1
P	along	constraint	the axioms	2809-1
P	with	constraint	the axioms	2809-1
the axioms	of	constraint	equality	2809-1
equality	if	constraint	<B>	2809-1
equality	needed	action	<B>	2809-1
Negation	in	constraint	Datalog	2810-1
A first problem now	that	constraint	comp	2810-2
A first problem now	is	attribute	comp	2810-2
comp		sequential	P	2810-2
P	in	constraint	fact	2810-2
P	is	attribute	not always consistent	2810-2
fact		sequential	its consistency	2810-2
its consistency	is	attribute	undecidable	2810-2
What	is	attribute	the connection	2810-3
the connection	between	constraint	SLDNF	2810-3
SLDNF	and	conjunctive	Clark	2810-3
Clark		sequential	completion	2810-3
<B>	Because	constraint	SLDNF	2810-4
SLDNF	is	attribute	consistent	2810-4
it	clearly can not prove	action	A	2810-4
A	and	conjunctive	¬	2810-4
¬		sequential	A	2810-4
A	and	conjunctive	comp	2810-4
comp		sequential	P	2810-4
P	is	attribute	SLDNF	2810-4
SLDNF	with	constraint	respect	2810-4
SLDNF	is	attribute	not always complete	2810-4
respect	to	constraint	comp	2810-4
comp		sequential	P	2810-4
<B>	For	constraint	consistent comp	2810-5
consistent comp		sequential	P	2810-5
P		sequential	it	2810-5
it	that	constraint	SLDNF resolution	2810-5
it	can be shown	action	SLDNF resolution	2810-5
SLDNF resolution	is	attribute	sound	2810-5
additional conditions	on	constraint	the datalog¬ programs	2810-6
additional conditions	However must be imposed	action	the datalog¬ programs	2810-6
the datalog¬ programs	for	constraint	SLDNF resolution	2810-6
SLDNF resolution	to	constraint	<B>	2810-6
SLDNF resolution	be	attribute	complete	2810-6
<B>	Consider again	action	the transitive closure program P TC	2811-1
the transitive closure program P TC	and	conjunctive	input instance I	2811-1
input instance I	of	constraint	Example 15.5.1	2811-1
the completion	of	constraint	T	2811-2
T	to	constraint	T	2811-2
T	is	attribute	Then equivalent	2811-2
T		sequential	x	2811-2
x	↔	sequential	G	2811-2
G		sequential	x	2811-2
x		sequential	∃z	2811-2
∃z		sequential	G	2811-2
G		sequential	x	2811-2
x		sequential	z	2811-2
z		sequential	∧ T	2811-2
∧ T		sequential	z	2811-2
z		sequential	y	2811-2
<B>	that	constraint	T	2812-1
<B>	neither	conjunctive	T	2812-1
<B>	Note	action	T	2812-1
T		sequential	a c	2812-1
a c	nor	conjunctive	¬T	2812-1
¬T		sequential	a c	2812-1
a c	are	attribute	consequences	2812-1
consequences	of	constraint	comp	2812-1
comp		sequential	P TC	2812-1
P TC		sequential	I	2812-1
<B>	In	constraint	summary	2813-1
summary		sequential	negation	2813-1
negation	as	constraint	failure	2813-1
failure	to	constraint	a convincing counterpart	2813-1
failure	does not appear	attribute	proof theoretic	2813-1
failure	provide	attribute	proof theoretic	2813-1
a convincing counterpart	to	constraint	the semantics	2813-1
the semantics		sequential	we	2813-1
we	have considered	action	<B>	2813-1
The search	for	constraint	more successful approaches	2813-2
more successful approaches	is	attribute	an active research area	2813-2
Other proposals	in	constraint	the Bibliographic Notes	2813-3
Other proposals	are described briefly	action	the Bibliographic Notes	2813-3
Bibliographic Notes		sequential	Bibliographic Notes	2814-1
<B>		sequential	it	2814-2
it	by	constraint	quite a few investigators	2814-2
it	was proposed independently	action	quite a few investigators	2814-2
quite a few investigators		sequential	CH85	2814-2
CH85		sequential	ABW88	2814-2
ABW88		sequential	Lif88	2814-2
Lif88		sequential	VanG86	2814-2
The independence	of	constraint	the semantics	2814-3
the semantics	from	constraint	a particular stratification	2814-3
a particular stratification		sequential	Theorem	2814-3
Theorem		sequential	15.2.10	2814-3
15.2.10	in	constraint	<B>	2814-3
15.2.10	was shown	action	<B>	2814-3
Research	on	constraint	semantics	2815-1
Research	well founded	action	semantics	2815-1
semantics	and	conjunctive	the related notion	2815-1
the related notion	of	constraint	a model	2815-1
a model	has	action	its roots	2815-1
its roots	in	constraint	investigations	2815-1
investigations	of	constraint	default	2815-1
investigations	and	conjunctive	default	2815-1
default		sequential	model semantics	2815-1
<B>	Although	constraint	the notion	2815-2
<B>	formulated somewhat differently	action	the notion	2815-2
the notion	of	constraint	default	2815-2
the notion	/	sequential	default	2815-2
default		sequential	a stable model	2815-2
a stable model	to	constraint	a total model	2815-2
a stable model	of	constraint	a total model	2815-2
a stable model	is	attribute	equivalent	2815-2
a total model		sequential	Prz90	2815-2
Stable model semantics	in	constraint	GL88	2815-3
Stable model semantics	was introduced	action	GL88	2815-3
GL88	and	conjunctive	default model semantics	2815-3
default model semantics	in	constraint	BF87	2815-3
default model semantics	was introduced	action	BF87	2815-3
BF87		sequential	BF88	2815-3
Stable semantics	on	constraint	Moore	2815-4
Stable semantics	is based	action	Moore	2815-4
Moore		sequential	autoepistemic logic	2815-4
autoepistemic logic		sequential	Moo85	2815-4
Moo85	and	conjunctive	default semantics	2815-4
default semantics	on	constraint	Reiter	2815-4
default semantics	is based	action	Reiter	2815-4
Reiter		sequential	default logic	2815-4
Several equivalent definitions	of	constraint	the semantics	2816-1
Several equivalent definitions	well founded	action	the semantics	2816-1
the semantics	have been proposed	action	<B>	2816-1
The definition	in	constraint	this chapter	2816-2
The definition	used	action	this chapter	2816-2
this chapter	from	constraint	Prz90	2816-2
this chapter	comes	action	Prz90	2816-2
The alternating fixpoint computation		sequential	we	2816-3
we	as	constraint	VanG89	2816-3
we	in	constraint	VanG89	2816-3
we	described	attribute	essentially the same	2816-3
we	is	attribute	essentially the same	2816-3
Alternative procedures	for	constraint	the semantics	2816-4
Alternative procedures	computing	action	the semantics	2816-4
Alternative procedures	well founded	action	the semantics	2816-4
the semantics	in	constraint	BF88	2816-4
the semantics	are exhibited	action	BF88	2816-4
BF88		sequential	Prz89	2816-4
the first definition	of	constraint	semantics	2816-5
the first definition	well founded	action	semantics	2816-5
semantics	in	constraint	VanGRS88	2816-5
semantics	Historically was proposed	action	VanGRS88	2816-5
VanGRS88		sequential	VanGRS91	2816-5
<B>	in	constraint	Exercise 15.24	2816-6
<B>	is described	action	Exercise 15.24	2816-6
The fact	that	constraint	semantics	2817-1
The fact	and	conjunctive	semantics	2817-1
The fact	well founded	action	semantics	2817-1
The fact	stratified	action	semantics	2817-1
semantics	on	constraint	stratifiable datalog¬ programs	2817-1
semantics	agree	action	stratifiable datalog¬ programs	2817-1
stratifiable datalog¬ programs		sequential	Theorem	2817-1
Theorem		sequential	15.3.11	2817-1
15.3.11	in	constraint	VanGRS88	2817-1
15.3.11	was shown	action	VanGRS88	2817-1
<B>	Both	conjunctive	the semantics	2818-1
<B>	and	conjunctive	the semantics	2818-1
<B>	stratified	action	the semantics	2818-1
<B>	well founded	action	the semantics	2818-1
the semantics	for	constraint	general logic programming	2818-1
the semantics	were originally introduced	action	general logic programming	2818-1
general logic programming		sequential	the more restricted case	2818-1
the more restricted case	of	constraint	datalog	2818-1
<B>	In	constraint	the context	2818-2
the context	of	constraint	logic programming	2818-2
logic programming		sequential	both semantics	2818-2
both semantics	have	action	expressive power	2818-2
expressive power	to	constraint	the arithmetic hierarchy	2818-2
The result		sequential	that datalog¬	2819-1
that datalog¬	with	constraint	semantics	2819-1
that datalog¬	well founded	action	semantics	2819-1
semantics	expresses	action	exactly the fixpoint Bibliographic Notes queries	2819-1
exactly the fixpoint Bibliographic Notes queries	in	constraint	VanG89	2819-1
exactly the fixpoint Bibliographic Notes queries	is shown	action	VanG89	2819-1
Citation		sequential	FKL87	2819-2
FKL87	that	constraint	every datalog¬ program	2819-2
FKL87	for	constraint	every datalog¬ program	2819-2
FKL87	proves	action	every datalog¬ program	2819-2
every datalog¬ program		sequential	P	2819-2
P		sequential	there	2819-2
there	is	attribute	a total datalog¬ program Q	2819-2
a total datalog¬ program Q	that	constraint	the positive portions	2819-2
the positive portions	of	constraint	P wf	2819-2
P wf		sequential	I	2819-2
I	and	conjunctive	Qwf	2819-2
Qwf		sequential	I	2819-2
I	for	constraint	every I	2819-2
I	coincide	action	every I	2819-2
The fact	that	constraint	stratified datalog¬	2819-3
stratified datalog¬	than	constraint	fixpoint	2819-3
stratified datalog¬	is	attribute	weaker	2819-3
fixpoint	than	constraint	semantics	2819-3
fixpoint	and	conjunctive	semantics	2819-3
fixpoint	founded	action	semantics	2819-3
semantics	in	constraint	Kol91	2819-3
semantics	was shown	action	Kol91	2819-3
Kol91	making	action	use	2819-3
use	of	constraint	earlier results	2819-3
earlier results	from	constraint	Dal87	2819-3
Dal87	and	conjunctive	CH82	2819-3
<B>	In	constraint	Lemma 15.4.1	2819-4
Lemma 15.4.1	on	constraint	Lemma 3.9	2819-4
Lemma 15.4.1	is based	action	Lemma 3.9	2819-4
Lemma 3.9	in	constraint	CH82	2819-4
The result	that	constraint	semipositive datalog¬	2820-1
semipositive datalog¬	expresses	action	qptime	2820-1
qptime	on	constraint	ordered databases	2820-1
ordered databases	with	constraint	min	2820-1
min	and	conjunctive	max	2820-1
max	to	constraint	Pap85	2820-1
max	is	attribute	due	2820-1
The investigation	of	constraint	negation	2821-1
negation	as	constraint	failure	2821-1
failure	in	constraint	Cla	2821-1
failure	was initiated	action	Cla	2821-1
Cla		sequential	78	2821-1
78	in	constraint	connection	2821-1
connection	with	constraint	general logic programming	2821-1
<B>	In	constraint	SLDNF resolution	2821-2
SLDNF resolution		sequential	Clark	2821-2
Clark		sequential	completion	2821-2
completion	are introduced	action	<B>	2821-2
The fact	that	constraint	there	2821-3
there	is	attribute	no datalog¬ program	2821-3
no datalog¬ program	for	constraint	which	2821-3
which	and	conjunctive	the facts	2821-3
the facts	about	constraint	the transitive closure	2821-3
the transitive closure	of	constraint	the graph	2821-3
the graph	by	constraint	SLDNF resolution	2821-3
the graph	can be proven	action	SLDNF resolution	2821-3
SLDNF resolution	in	constraint	Kun88	2821-3
SLDNF resolution	was shown	action	Kun88	2821-3
Other work	to	constraint	Clark	2821-4
Clark		sequential	completion	2821-4
completion	in	constraint	She88	2821-4
completion	can be found	action	She88	2821-4
She88		sequential	Llo87	2821-4
Llo87		sequential	Fit85	2821-4
Fit85		sequential	Kun87	2821-4
Several variations	of	constraint	SLDNF resolutions	2822-1
SLDNF resolutions	have been proposed	action	<B>	2822-1
SLS resolution	in	constraint	Prz	2822-2
SLS resolution	is introduced	action	Prz	2822-2
Prz		sequential	88	2822-2
88	to	constraint	stratified programs	2822-2
88	with	constraint	stratified programs	2822-2
88	deal	action	stratified programs	2822-2
An exact match	between	constraint	stratified semantics	2822-3
An exact match	is achieved	action	stratified semantics	2822-3
stratified semantics	and	conjunctive	the proof procedure	2822-3
the proof procedure	by	constraint	SLS resolution	2822-3
the proof procedure	provided	action	SLS resolution	2822-3
<B>	Although	constraint	SLS resolution	2822-4
SLS resolution	in	constraint	the context	2822-4
SLS resolution	is	attribute	effective	2822-4
the context	of	constraint	databases	2822-4
databases		sequential	it	2822-4
it	to	constraint	general logic programs	2822-4
it	is	attribute	general logic programs	2822-4
it	when applied	action	general logic programs	2822-4
general logic programs	with	constraint	function symbols	2822-4
<B>	To	constraint	this shortcoming	2822-5
<B>	with	constraint	this shortcoming	2822-5
<B>	deal	action	this shortcoming	2822-5
this shortcoming		sequential	several restrictions	2822-5
several restrictions	of	constraint	SLS resolution	2822-5
SLS resolution	have been proposed	action	that	2822-5
that	in	constraint	the general framework	2822-5
that	are	attribute	effective	2822-5
the general framework		sequential	KT88	2822-5
KT88		sequential	SI88	2822-5
proof		sequential	Several approaches	2823-1
Several approaches	to	constraint	the semantics	2823-1
Several approaches	corresponding	action	the semantics	2823-1
Several approaches	well founded	action	the semantics	2823-1
the semantics	have been proposed	action	<B>	2823-1
SLS resolution	from	constraint	arbitrary datalog¬ programs	2823-2
SLS resolution	to	constraint	arbitrary datalog¬ programs	2823-2
SLS resolution	is extended	action	arbitrary datalog¬ programs	2823-2
SLS resolution	stratified	action	arbitrary datalog¬ programs	2823-2
arbitrary datalog¬ programs	in	constraint	Prz88	2823-2
Prz88	under	constraint	semantics	2823-2
Prz88	founded	action	semantics	2823-2
another extension	of	constraint	SLS resolution	2823-3
SLS resolution	called	action	global SLS resolution	2823-3
global SLS resolution	in	constraint	Ros89	2823-3
global SLS resolution	Independently is proposed	action	Ros89	2823-3
Ros89	with	constraint	similar results	2823-3
These proposals	yield	action	noneffective resolution procedures	2823-4
An effective procedure	in	constraint	<B>	2823-5
An effective procedure	is described	action	<B>	2823-5
<B>	In	constraint	SZ90	2824-1
SZ90		sequential	an interesting connection	2824-1
an interesting connection	between	constraint	models	2824-1
an interesting connection	and	conjunctive	models	2824-1
models	of	constraint	a program	2824-1
a program		sequential	total models	2824-1
total models	see	action	also Exercise 15.20	2824-1
also Exercise 15.20	is pointed out	action	<B>	2824-1
it	that	constraint	the stable models	2824-2
it	Essentially is shown	action	the stable models	2824-2
the stable models	of	constraint	a datalog¬ program	2824-2
a datalog¬ program	as	constraint	the result	2824-2
a datalog¬ program	can be viewed	action	the result	2824-2
the result	of	constraint	a natural nondeterministic choice	2824-2
<B>	uses	action	the choice construct	2824-3
the choice construct	in	constraint	KN88	2824-3
the choice construct	introduced earlier	action	KN88	2824-3
Another use	of	constraint	nondeterminism	2824-4
nondeterminism	in	constraint	PY92	2824-4
nondeterminism	is exhibited	action	PY92	2824-4
PY92		sequential	an extension	2824-4
an extension	of	constraint	semantics	2824-4
an extension	well founded	action	semantics	2824-4
semantics	where is provided	action	which	2824-4
which	involves	action	the nondeterministic choice	2824-4
the nondeterministic choice	of	constraint	a fixpoint	2824-4
a fixpoint	of	constraint	a datalog¬ program	2824-4
<B>	is called	action	tie	2824-5
tie	breaking	action	semantics	2824-5
A discussion	of	constraint	nondeterminism	2824-6
nondeterminism	in	constraint	deductive databases	2824-6
deductive databases	in	constraint	GPSZ91	2824-6
deductive databases	is provided	action	GPSZ91	2824-6
There	are	attribute	a few prototypes	2825-1
a few prototypes	but	conjunctive	no commercial system	2825-1
no commercial system	implementing	action	stratified datalog¬	2825-1
The language		sequential	LDL	2825-2
LDL		sequential	NT89	2825-2
NT89		sequential	BNR+87	2825-2
BNR+87		sequential	NK88	2825-2
NK88	besides	constraint	the stratified semantics	2825-2
NK88	implements	action	the stratified semantics	2825-2
the stratified semantics	for	constraint	datalog¬	2825-2
datalog¬		sequential	an extension	2825-2
an extension	to	constraint	complex objects	2825-2
complex objects	see	action	also Chapter 20	2825-2
The implementation	uses	action	heuristics	2825-3
heuristics	on	constraint	the magic set technique	2825-3
heuristics	based	action	the magic set technique	2825-3
the magic set technique	in	constraint	Chapter 13	2825-3
the magic set technique	described	action	Chapter 13	2825-3
The language NAIL		sequential	The language NAIL	2826-1
<B>	Yet	conjunctive	Not Another Implementation	2826-2
Not Another Implementation	of	constraint	Logic	2826-2
<B>	at	constraint	Stanford	2826-3
<B>	developed	action	Stanford	2826-3
Stanford	is	attribute	another implementation	2826-3
another implementation	of	constraint	the stratified semantics	2826-3
the stratified semantics	allowing	action	function symbols	2826-3
function symbols	and	conjunctive	a set construct	2826-3
The implementation	of	constraint	NAIL	2826-4
MUG86 Mor88	uses	action	a battery	2826-5
a battery	of	constraint	evaluation techniques	2826-5
evaluation techniques	including	action	magic sets	2826-5
The language EKS		sequential	VBKL89	2826-6
VBKL89	at	constraint	Negation	2826-6
VBKL89	developed	action	Negation	2826-6
Negation	in	constraint	Datalog ECRC	2826-6
Datalog ECRC		sequential	Computer Industry	2826-6
Computer Industry		sequential	European Research Center	2826-6
European Research Center	in	constraint	Munich	2826-6
Munich	implements	action	the stratified semantics	2826-6
the stratified semantics	and	conjunctive	extensions	2826-6
extensions	allowing	action	quantifiers	2826-6
quantifiers	in	constraint	rule bodies	2826-6
rule bodies		sequential	aggregate functions	2826-6
aggregate functions	and	conjunctive	constraint specification	2826-6
The CORAL system		sequential	RSS92	2826-7
RSS92		sequential	RSSS93	2826-7
RSSS93	provides	action	a database programming language	2826-7
a database programming language		sequential	that	2826-7
that	both	conjunctive	capabilities	2826-7
that	and	conjunctive	capabilities	2826-7
that	supports	attribute	imperative	2826-7
capabilities	including	action	stratification	2826-7
An implementation	of	constraint	semantics	2826-8
An implementation	well founded	action	semantics	2826-8
semantics	in	constraint	CW92	2826-8
semantics	is described	action	CW92	2826-8
Nicole Bidoit		sequential	survey	2827-1
survey	on	constraint	negation	2827-1
negation	in	constraint	databases	2827-1
databases		sequential	Bid91	2827-1
Bid91		sequential	b	2827-1
b		sequential	her book	2827-1
her book	on	constraint	datalog	2827-1
datalog		sequential	Bid91a	2827-1
Bid91a	provided	action	an invaluable source	2827-1
an invaluable source	of	constraint	information	2827-1
information	and	conjunctive	our presentation	2827-1
information	inspired	action	our presentation	2827-1
our presentation	of	constraint	the topic	2827-1
Exercises Exercise		sequential	15.1	2828-1
Exercise		sequential	15.2	2829-1
<B>	that	constraint	TP	2829-2
<B>	Verify	action	TP	2829-2
TP	has	action	a least fixpoint	2829-2
a least fixpoint	but	conjunctive	T	2829-2
T	on	constraint	<B>	2829-2
T	∅	sequential	<B>	2829-2
T	does not converge	action	<B>	2829-2
T	when starting	action	<B>	2829-2
P3 Exercise		sequential	15.3	2830-1
Exercise 15.4 Prove Lemma 15.2.8		sequential	Exercise 15.4 Prove Lemma 15.2.8	2831-1
<B>	Exercise	action	15.5	2832-1
15.5	Consider	action	a database	2832-1
a database	for	constraint	metro	2832-1
metro	and	conjunctive	bus	2832-1
bus		sequential	the Parisian lines	2832-1
the Parisian lines	of	constraint	two relations Metro	2832-1
the Parisian lines	consisting	action	two relations Metro	2832-1
two relations Metro		sequential	Station	2832-1
Station		sequential	Next Station	2832-1
Next Station	and	conjunctive	Bus	2832-1
Bus		sequential	Station	2832-1
Station		sequential	Next Station	2832-1
<B>	Write	action	stratifiable datalog¬ programs	2832-2
stratifiable datalog¬ programs	to	constraint	the following queries	2832-2
stratifiable datalog¬ programs	answer	action	the following queries	2832-2
Exercises Exercise 15.6		sequential	Exercises Exercise 15.6	2833-1
<B>	Let	action	P	2833-2
P	be	attribute	a stratifiable datalog¬ program	2833-2
a stratifiable datalog¬ program	and	conjunctive	σ	2833-2
a stratifiable datalog¬ program	let	action	σ	2833-2
σ	=	sequential	P 1	2833-2
<B>	.	sequential	<B>	2833-3
<B>	.	sequential	<B>	2833-4
P	be	attribute	n a stratification	2833-5
n a stratification	for	constraint	P	2833-5
<B>	For	constraint	each instance	2833-6
<B>	or	conjunctive	each instance	2833-6
each instance		sequential	I	2833-6
I		sequential	edb	2833-6
edb		sequential	P	2833-6
P		sequential	σ	2833-6
σ		sequential	I	2833-6
I	to	constraint	the finite case	2833-6
I	is defined similarly	action	the finite case	2833-6
<B>	consider	action	the sequence I0	2833-7
the sequence I0		sequential	I Ii	2833-7
I Ii	=	sequential	P i	2833-7
P i		sequential	Ii−1	2833-7
Ii−1		sequential	edb	2833-7
edb		sequential	P	2833-7
P		sequential	i	2833-7
i		sequential	j P	2833-7
j P		sequential	i	2833-7
i		sequential	Ii−1	2833-7
Ii−1		sequential	edb	2833-7
edb		sequential	P	2833-7
P		sequential	i	2833-7
i	where =	sequential	∪j	2833-7
i	that	constraint	the definition	2834-1
i	Note	action	the definition	2834-1
the definition	because	constraint	P	2834-1
the definition	is	attribute	now noneffective	2834-1
P		sequential	i	2834-1
i		sequential	Ii−1	2834-1
Ii−1		sequential	edb	2834-1
edb		sequential	P i	2834-1
P i	be	attribute	may infinite	2834-1
<B>	Consider	action	a database	2835-1
a database	of	constraint	one binary relation succ	2835-1
a database	consisting	action	one binary relation succ	2835-1
one binary relation succ	providing	action	a successor relation	2835-1
a successor relation	on	constraint	an infinite set	2835-1
an infinite set	of	constraint	constants	2835-1
one	Clearly can identify	action	these constants	2835-2
these constants	with	constraint	the positive integers	2835-2
Exercise 15.7 Prove Theorem 15.2.2		sequential	Exercise 15.7 Prove Theorem 15.2.2	2836-1
Exercise		sequential	15.8	2837-1
Exercise Let		sequential	15.9	2838-1
15.9	be	attribute	A a partially ordered set	2838-1
A listing		sequential	a1	2838-2
<B>	.	sequential	<B>	2838-3
<B>	.	sequential	<B>	2838-4
<B>	of	constraint	the elements	2838-5
the elements	in	constraint	A	2838-5
A	with	constraint	iff	2838-5
A	is	attribute	compatible	2838-5
iff	for	constraint	i	2838-5
i		sequential	j	2838-5
j		sequential	it	2838-5
it	is	attribute	not the case	2838-5
not the case		sequential	that	2838-5
that		sequential	aj	2838-5
aj		sequential	ai	2838-5
<B>	Let	action	σ	2838-6
σ		sequential	′	2838-6
′		sequential	′′	2838-6
′′	be	attribute	listings	2838-6
listings	of	constraint	A	2838-6
A	with	constraint	<B>	2838-6
<B>	that	constraint	one	2838-7
<B>	Prove	action	one	2838-7
one	can obtain	action	σ ′′	2838-7
σ ′′	from	constraint	σ	2838-7
σ	by	constraint	a sequence	2838-7
a sequence	of	constraint	exchanges al	2838-7
exchanges al	of	constraint	adjacent elements	2838-7
adjacent elements	am	attribute	such	2838-7
al		sequential	am	2838-7
am	and	conjunctive	am	2838-7
am		sequential	al	2838-7
Exercise Prove Lemma 15.2.9		sequential	15.10	2839-1
<B>	Exercise	attribute	15.11 such	2840-1
that		sequential	sch	2840-1
sch		sequential	P1	2840-1
P1	=	sequential	sch	2840-1
sch		sequential	P2	2840-1
P2	and	conjunctive	there	2840-1
P2	$ P	sequential	there	2840-1
P2	≡	sequential	there	2840-1
P2	$	sequential	there	2840-1
there	is	attribute	a minimal model	2840-1
a minimal model		sequential	I	2840-1
I	of	constraint	I	2840-1
I	that	constraint	I	2840-1
I	$ such	sequential	I	2840-1
I	is	attribute	a P2 P1 supported model	2840-1
a P2 P1 supported model	for	constraint	P1	2840-1
P1	for	constraint	not P2	2840-1
P1	but	conjunctive	not P2	2840-1
<B>	In	constraint	other words	2840-2
other words		sequential	the notion	2840-2
the notion	of	constraint	supported model	2840-2
supported model	on	constraint	also the syntax	2840-2
supported model	on	constraint	also the syntax	2840-2
supported model	but	conjunctive	also the syntax	2840-2
supported model	not $ P	sequential	also the syntax	2840-2
supported model	depends	action	also the syntax	2840-2
also the syntax	of	constraint	P	2840-2
Exercise		sequential	15.12	2841-1
15.12	Prove	action	part	2841-1
part		sequential	b	2841-1
b	of	constraint	Proposition 15.2.11	2841-1
Exercise Prove Proposition 15.2.12		sequential	15.13	2842-1
Negation	in	constraint	Datalog	2843-1
Exercise		sequential	15.15	2844-1
<B>	Prove	attribute	the following	2844-2
Exercise Prove Lemma 15.3.4		sequential	15.16	2845-1
Exercise		sequential	15.17	2846-1
<B>	Recall	action	the definition	2846-2
the definition	of	constraint	positivized ground version	2846-2
positivized ground version	of	constraint	P	2846-2
P	given	action	I	2846-2
I		sequential	denoted pg	2846-2
denoted pg		sequential	P	2846-2
P		sequential	I	2846-2
I		sequential	I	2846-2
I	is	attribute	a instance	2846-2
I	3 valued	action	a instance	2846-2
<B>	Prove	attribute	the following	2846-3
I0		sequential	Ii+1	2847-1
Ii+1	=	sequential	pg	2847-1
pg		sequential	P	2847-1
P		sequential	Ii	2847-1
Ii	⊥ =	sequential	conseq P	2847-1
conseq P		sequential	Ii	2847-1
<B>	that	constraint	I0	2848-1
<B>	Prove	action	I0	2848-1
I0		sequential	I2	2848-1
I2		sequential	I2	2848-1
I2		sequential	i	2848-1
i		sequential	I2i+2	2848-1
I2i+2		sequential	I2i+1	2848-1
I2i+1		sequential	I2i−1	2848-1
I2i−1	≺	sequential	I1	2848-1
Exercise		sequential	15.18	2849-1
Exercise		sequential	15.19	2850-1
Exercises Exercise 15.22		sequential	Exercises Exercise 15.22	2851-1
program		sequential	P	2852-1
P	is	attribute	always total	2852-1
<B>	is	attribute	it	2852-2
it	whether	constraint	each instance	2852-2
it	for	constraint	each instance	2852-2
it	is	attribute	undecidable	2852-2
each instance		sequential	I	2852-2
I		sequential	wf	2852-2
wf		sequential	edb	2852-2
edb		sequential	P	2852-2
P		sequential	P	2852-2
P	is	attribute	total	2852-2
I		sequential	I	2853-1
The immediate consequence operator		sequential	TP	2854-1
TP	of	constraint	P	2854-1
P	to	constraint	sets	2854-1
P	on	constraint	sets	2854-1
P	is extended	action	sets	2854-1
P	operate	action	sets	2854-1
sets	of	constraint	ground literals	2854-1
sets	and	conjunctive	ground literals	2854-1
ground literals	as	constraint	<B>	2854-1
ground literals	follows	action	<B>	2854-1
<B>	Let	action	I	2854-2
I	be	attribute	a set	2854-2
a set	of	constraint	ground literals	2854-2
TP		sequential	I	2854-3
I	of	constraint	all literals	2854-3
I	consists	action	all literals	2854-3
all literals		sequential	A	2854-3
A	for	constraint	which	2854-3
which		sequential	there	2854-3
there	is	attribute	a ground rule	2854-3
a ground rule	of	constraint	P	2854-3
P		sequential	A	2854-3
A	←	sequential	L1	2854-3
<B>	.	sequential	<B>	2854-4
<B>	.	sequential	<B>	2854-5
Lk	that	constraint	Li ∈	2854-6
Li ∈		sequential	I	2854-6
I	for	constraint	<B>	2854-6
<B>	that	constraint	TP	2854-7
<B>	Note	action	TP	2854-7
TP	can produce	action	an inconsistent set	2854-7
an inconsistent set	of	constraint	literals	2854-7
literals		sequential	which	2854-7
which	to	constraint	a model	2854-7
which	therefore does not correspond	action	a model	2854-7
which	3 valued	action	a model	2854-7
<B>	Now let	action	I	2854-8
I	be	attribute	a set	2854-8
a set	of	constraint	ground literals	2854-8
ground literals	and	conjunctive	J	2854-8
J		sequential	a set	2854-8
a set	of	constraint	positive ground literals	2854-8
J	to	constraint	an unfounded set	2854-9
J	be	attribute	an unfounded set	2854-9
J	is said	action	an unfounded set	2854-9
an unfounded set	of	constraint	P	2854-9
P	with	constraint	respect	2854-9
respect	to	constraint	I	2854-9
I	if	constraint	∈ J	2854-9
I	for	constraint	∈ J	2854-9
∈ J	and	conjunctive	ground	2854-9
ground		sequential	each A rule r	2854-9
each A rule r	of	constraint	P	2854-9
P	with	constraint	the head	2854-9
P	in	constraint	the head	2854-9
the head		sequential	at least one	2854-9
at least one	of	constraint	the following holds	2854-9
<B>	that	constraint	all atoms	2855-1
<B>	if	constraint	all atoms	2855-1
<B>	Intuitively means	action	all atoms	2855-1
all atoms	of	constraint	I	2855-1
I	and	conjunctive	all atoms	2855-1
I	are assumed	attribute	true	2855-1
all atoms	in	constraint	J	2855-1
J	are assumed	attribute	false	2855-1
no atom	of	constraint	J	2855-1
J	under	constraint	one application	2855-1
J	is	attribute	true	2855-1
one application	of	constraint	TP	2855-1
<B>	Let	action	the greatest unfounded set	2856-1
the greatest unfounded set	of	constraint	P	2856-1
P	with	constraint	respect	2856-1
respect	to	constraint	I	2856-1
I	be	attribute	the union	2856-1
the union	of	constraint	all unfounded sets	2856-1
all unfounded sets	of	constraint	P	2856-1
P	with	constraint	respect	2856-1
respect	to	constraint	I	2856-1
I		sequential	denoted UP	2856-1
denoted UP		sequential	I	2856-1
<B>	Next consider	action	the operator	2856-2
the operator		sequential	WP	2856-2
WP	on	constraint	sets	2856-2
sets	of	constraint	ground literals	2856-2
ground literals	by	constraint	WP	2856-2
ground literals	defined	action	WP	2856-2
WP		sequential	I	2856-2
I	=	sequential	TP	2856-2
TP		sequential	I	2856-2
I		sequential	∪ ¬.UP	2856-2
∪ ¬.UP		sequential	I	2856-2
<B>	Prove	attribute	the following	2857-1
P P	is	attribute	the immediate consequence operator	2858-1
the immediate consequence operator	on	constraint	sets	2858-1
sets	of	constraint	ground literals	2858-1
ground literals	in	constraint	Exercise 15.24	2858-1
ground literals	defined	action	Exercise 15.24	2858-1
P		sequential	I	2858-2
I	Furthermore denotes	action	the complement	2858-2
the complement	of	constraint	P	2858-2
P		sequential	I	2858-2
I		sequential	B	2858-2
B		sequential	P	2858-2
P		sequential	I	2858-2
I		sequential	P	2858-2
P		sequential	I	2858-2
<B>	Consider	action	the sequence	2858-3
the sequence	of	constraint	sets	2858-3
sets	of	constraint	negative facts	2858-3
negative facts	by	constraint	N0 Ni+1	2858-3
negative facts	defined	action	N0 Ni+1	2858-3
N0 Ni+1	=	sequential	¬.P	2858-3
¬.P		sequential	¬.P	2858-3
¬.P		sequential	Ni	2858-3
The intuition	behind	constraint	the definition	2859-1
the definition	is	attribute	the following	2859-1
N0	is	attribute	an underestimate	2859-2
an underestimate	of	constraint	the set	2859-2
the set	of	constraint	negative facts	2859-2
negative facts	in	constraint	the model	2859-2
negative facts	well founded	action	the model	2859-2
P		sequential	N	2859-3
N	is	attribute	Then an underestimate	2859-3
Then an underestimate	of	constraint	the positive facts	2859-3
the positive facts	and	conjunctive	the negated complement	2859-3
the negated complement		sequential	¬.P	2859-3
¬.P		sequential	N	2859-3
N	is	attribute	an overestimate	2859-3
an overestimate	of	constraint	the negative facts	2859-3
<B>	Using	action	this overestimate	2859-4
this overestimate		sequential	one	2859-4
one	can infer	action	an overestimate	2859-4
an overestimate	of	constraint	the positive facts	2859-4
the positive facts		sequential	P	2859-4
P		sequential	¬.P	2859-4
¬.P		sequential	N	2859-4
¬.P		sequential	¬.P	2859-5
¬.P		sequential	N	2859-5
N	is	attribute	Therefore now a new underestimate	2859-5
Therefore now a new underestimate	of	constraint	the negative facts	2859-5
the negative facts	containing	action	the previous underestimate	2859-5
Ni		sequential	i≥0	2859-6
i≥0	is	attribute	So Negation	2859-6
So Negation	in	constraint	Datalog	2859-6
Exercise		sequential	15.26	2860-1
<B>	Let	action	TP	2860-2
TP	be	attribute	the immediate consequence operator	2860-2
the immediate consequence operator	on	constraint	sets	2860-2
sets	of	constraint	ground literals	2860-2
ground literals	in	constraint	Exercise	2860-2
ground literals	defined	action	Exercise	2860-2
Exercise		sequential	15.24	2860-2
15.24	and	conjunctive	¯ TP	2860-2
15.24	let	action	¯ TP	2860-2
¯ TP	by	constraint	¯	2860-2
¯ TP	be defined	action	¯	2860-2
¯		sequential	TP	2860-2
TP		sequential	I	2860-2
I	=	sequential	I	2860-2
I	∪	action	TP	2860-2
TP		sequential	I	2860-2
<B>	Given	action	a set	2861-1
a set		sequential	I	2861-1
I	of	constraint	ground literals	2861-1
ground literals	let	action	P	2861-1
P		sequential	I	2861-1
I	denote	action	the limit	2861-1
the limit	of	constraint	the increasing sequence	2861-1
the increasing sequence		sequential	¯	2861-1
<B>	with	constraint	respect	2862-1
<B>	is	attribute	maximally consistent	2862-1
respect	to	constraint	P	2862-1
P	if	constraint	it	2862-1
it	among	constraint	the sets	2862-1
it	is	attribute	maximal	2862-1
the sets	of	constraint	negative literals	2862-1
negative literals	with	constraint	P	2862-1
<B>	Investigate	action	the connection	2862-2
the connection	between	constraint	maximal consistency	2862-2
maximal consistency		sequential	models	2862-2
models	and	conjunctive	semantics	2862-2
models	founded	action	semantics	2862-2
<B>	Exercise	action	15.27	2863-1
15.27	to	constraint	the proof	2863-1
15.27	Refer	action	the proof	2863-1
the proof	of	constraint	Lemma 15.4.4	2863-1
Exercise		sequential	15.28	2864-1
Exercise		sequential	15.29	2865-1
15.29	Consider	action	an ordered database	2865-1
an ordered database	with	constraint	binary relation succ	2865-1
binary relation succ	providing	action	a successor relation	2865-1
a successor relation	on	constraint	the constants	2865-1
<B>	that	constraint	the constants	2865-2
<B>	and	conjunctive	the constants	2865-2
<B>	Prove	attribute	minimum	2865-2
the constants	can not be computed	action	a semipositive program	2865-2
the constants	using	action	a semipositive program	2865-2
<B>	for	constraint	i 0	2866-1
P		sequential	A R T E Expressivenessand Complexity Various query languages	2867-1
A R T E Expressivenessand Complexity Various query languages	in	constraint	Parts	2867-1
A R T E Expressivenessand Complexity Various query languages	were presented	action	Parts	2867-1
Parts		sequential	B	2867-1
B	and	conjunctive	D.	2867-1
D.		sequential	Simple languages	2867-1
Simple languages	like	constraint	conjunctive queries	2867-1
conjunctive queries	with	constraint	various constructs	2867-1
conjunctive queries	were successively augmented	action	various constructs	2867-1
various constructs		sequential	union	2867-1
union		sequential	negation	2867-1
negation	and	conjunctive	recursion	2867-1
The primary motivation	for	constraint	increasingly powerful languages	2867-2
The primary motivation	defining	action	increasingly powerful languages	2867-2
increasingly powerful languages	was	attribute	the need	2867-2
the need	to	constraint	useful queries	2867-2
the need	express	action	useful queries	2867-2
useful queries	by	constraint	the simpler languages	2867-2
useful queries	not captured	action	the simpler languages	2867-2
<B>	In	constraint	the presentation	2867-3
the presentation		sequential	the process	2867-3
the process		sequential	example	2867-3
example	was primarily driven	action	<B>	2867-3
The following chapters	and	conjunctive	a perspective	2867-4
The following chapters	present	attribute	more advanced	2867-4
a perspective	on	constraint	query languages	2867-4
<B>	In	constraint	addition	2867-5
addition	to	constraint	their ability	2867-5
their ability	to	constraint	specific queries	2867-5
their ability	express	action	specific queries	2867-5
specific queries		sequential	we	2867-5
we	consider more broadly	action	the capability	2867-5
the capability	of	constraint	languages	2867-5
languages	to	constraint	queries	2867-5
languages	express	action	queries	2867-5
queries	of	constraint	a given complexity	2867-5
<B>	to	constraint	formal connections	2867-6
<B>	leads	action	formal connections	2867-6
<B>	establishing	action	formal connections	2867-6
formal connections	between	constraint	languages	2867-6
languages	and	conjunctive	complexity classes	2867-6
complexity classes	of	constraint	queries	2867-6
This approach	on	constraint	the border	2867-7
This approach	lies	action	the border	2867-7
the border	between	constraint	databases	2867-7
databases		sequential	complexity theory	2867-7
complexity theory	and	conjunctive	logic	2867-7
It	to	constraint	characterizations	2867-8
It	is	attribute	related	2867-8
characterizations	of	constraint	complexity classes	2867-8
complexity classes	in	constraint	terms	2867-8
terms	of	constraint	various logics	2867-8
The basic framework	for	constraint	the formal development	2868-1
the formal development	in	constraint	Chapter 16	2868-1
the formal development	is presented	action	Chapter 16	2868-1
Chapter 16	in	constraint	which	2868-1
which		sequential	we	2868-1
we	discuss	action	the notion	2868-1
the notion	of	constraint	a query	2868-1
a query	and	conjunctive	a formal definition	2868-1
a query	produce	action	a formal definition	2868-1
It	that	constraint	it	2868-2
It	turns out	action	it	2868-2
it	to	constraint	languages	2868-2
it	is	attribute	relatively easy	2868-2
it	define	action	languages	2868-2
languages	expressing	action	all queries	2868-2
Such languages	are called	attribute	complete	2868-3
the real challenge	for	constraint	the language designer	2868-4
the language designer	to	constraint	increasingly powerful languages	2868-4
the language designer	is	attribute	increasingly powerful languages	2868-4
the language designer	However not simply define	action	increasingly powerful languages	2868-4
an important aspect	of	constraint	language design	2868-5
language design	to	constraint	a good balance	2868-5
language design	is	attribute	a good balance	2868-5
language design	Instead achieve	action	a good balance	2868-5
a good balance	between	constraint	expressiveness	2868-5
expressiveness	and	conjunctive	the complexity	2868-5
the complexity	of	constraint	queries	2868-5
the complexity	evaluating	action	queries	2868-5
The ideal language	would allow	action	expression	2869-1
expression	of	constraint	most useful queries	2869-1
most useful queries	while	constraint	all queries	2869-1
most useful queries	that	constraint	all queries	2869-1
most useful queries	guaranteeing	action	all queries	2869-1
all queries	in	constraint	the language	2869-1
the language	with	constraint	reasonable complexity	2869-1
the language	can be evaluated	action	reasonable complexity	2869-1
<B>	To	constraint	we	2869-2
<B>	formalize	attribute	this	2869-2
we	raise	action	the following basic question	2869-2
<B>	In	constraint	an attempt	2869-3
an attempt	to	constraint	this question	2869-3
an attempt	answer	action	this question	2869-3
this question		sequential	we	2869-3
we	discuss	action	the issue	2869-3
the issue	of	constraint	languages	2869-3
the issue	sizing up	action	languages	2869-3
languages	in	constraint	Chapter 16	2869-3
Chapter 17	of	constraint	the classes	2870-1
Chapter 17	considers	attribute	some	2870-1
the classes	of	constraint	queries	2870-1
queries	in	constraint	Part B	2870-1
queries	discussed	action	Part B	2870-1
Part B	from	constraint	the viewpoint	2870-1
the viewpoint	of	constraint	expressiveness	2870-1
expressiveness	and	conjunctive	complexity	2870-1
The focus	on	constraint	the relational calculus	2870-2
The focus	is	attribute	the relational calculus	2870-2
the relational calculus	of	constraint	Chapter 5	2870-2
Chapter 5	on	constraint	its extensions fixpoint	2870-2
Chapter 5	and	conjunctive	its extensions fixpoint	2870-2
its extensions fixpoint	while	constraint	Chapter 14	2870-2
its extensions fixpoint	in	constraint	Chapter 14	2870-2
its extensions fixpoint	and	conjunctive	Chapter 14	2870-2
its extensions fixpoint	defined	action	Chapter 14	2870-2
We	show	action	the connection	2870-3
the connection	of	constraint	these languages	2870-3
these languages	to	constraint	complexity classes	2870-3
Several techniques	for	constraint	the nonexpressibility	2870-4
Several techniques	showing	action	the nonexpressibility	2870-4
the nonexpressibility	of	constraint	queries	2870-4
queries	are also presented	action	games	2870-4
queries	including	action	games	2870-4
games	and	conjunctive	1	2870-4
games	-	sequential	1	2870-4
1		sequential	0 laws	2870-4
Chapter 17	also explores	action	the intriguing theoretical implications	2871-1
the intriguing theoretical implications	of	constraint	one	2871-1
one	of	constraint	the basic assumptions	2871-1
the basic assumptions	of	constraint	the pure relational model	2871-1
the pure relational model	that	constraint	the underlying domain dom	2871-1
the underlying domain dom	of	constraint	uninterpreted unordered elements	2871-1
the underlying domain dom	consists	action	uninterpreted unordered elements	2871-1
This assumption	as	constraint	a metaphor	2871-2
This assumption	can be viewed	action	a metaphor	2871-2
a metaphor	for	constraint	the data independence principle	2871-2
the data independence principle	because	constraint	it	2871-2
it	implies	action	only logical properties	2871-2
it	using	action	only logical properties	2871-2
only logical properties	of	constraint	data	2871-2
data	as	constraint	415 Expressiveness	2871-2
415 Expressiveness	and	conjunctive	Complexity	2871-2
Complexity	to	constraint	the underlying implementation	2871-2
Complexity	opposed	action	the underlying implementation	2871-2
the underlying implementation		sequential	which	2871-2
which	would provide	action	additional information	2871-2
additional information		sequential	an order	2871-2
Chapter 18	and	conjunctive	languages	2872-1
Chapter 18	presents	attribute	highly expressive	2872-1
languages		sequential	all the way up	2872-1
all the way up	to	constraint	complete languages	2872-1
<B>	In	constraint	we	2872-2
we	discuss	action	constructs	2872-2
constructs	for	constraint	value invention	2872-2
value invention		sequential	which	2872-2
which	to	constraint	the object creation mechanisms	2872-2
which	are	attribute	similar	2872-2
the object creation mechanisms	in	constraint	object languages	2872-2
the object creation mechanisms	encountered	action	object languages	2872-2
object languages	see	action	Chapter 21	2872-2
<B>	For	constraint	easy reference	2873-1
easy reference		sequential	the expressiveness	2873-1
the expressiveness	and	conjunctive	complexity	2873-1
complexity	of	constraint	relational query languages	2873-1
relational query languages	at	constraint	the end	2873-1
relational query languages	are summarized	action	the end	2873-1
the end	of	constraint	Chapter 18	2873-1
you	about	constraint	it	2874-1
you	Do ever worry	action	it	2874-1
it	to	constraint	queries	2874-1
it	is	attribute	queries	2874-1
it	answer	action	queries	2874-1
Riccardo		sequential	my laptop	2875-1
my laptop	can only do	action	conjunctive queries	2875-1
Sergio		sequential	I	2876-1
I	can do	action	the while queries	2876-1
the while queries	on	constraint	my Sun	2876-1
Vittorio		sequential	I	2877-1
I	about	constraint	it	2877-1
I	don worry	action	it	2877-1
it		sequential	I	2877-1
I	have	action	a Cray	2877-1
a Cray	in	constraint	my office	2877-1
This chapter	lays	action	the groundwork	2878-1
the groundwork	for	constraint	the study	2878-1
the study	of	constraint	the complexity	2878-1
the complexity	and	conjunctive	expressiveness	2878-1
expressiveness	of	constraint	query languages	2878-1
the notion	of	constraint	query	2878-2
query	and	conjunctive	<B>	2878-2
query	First is carefully reconsidered	action	<B>	2878-2
query	formally defined	action	<B>	2878-2
the complexity	of	constraint	individual queries	2878-3
individual queries	Then is considered	action	<B>	2878-3
definitions		sequential	that	2878-4
that	allow	action	comparison	2878-4
comparison	of	constraint	query languages	2878-4
query languages	and	conjunctive	complexity classes	2878-4
complexity classes	Finally are developed	action	<B>	2878-4
Queries		sequential	Queries	2879-1
The first step	to	constraint	a precise definition	2879-2
The first step	is	attribute	a precise definition	2879-2
The first step	formulate	action	a precise definition	2879-2
a precise definition	of	constraint	what	2879-2
what	constitutes	action	a query	2879-2
The focus	on	constraint	a fairly high level	2880-1
The focus	is	attribute	a fairly high level	2880-1
a fairly high level	of	constraint	abstraction	2880-1
abstraction	on	constraint	thus the mappings	2880-1
abstraction	and	conjunctive	thus the mappings	2880-1
thus the mappings	by	constraint	queries	2880-1
thus the mappings	expressible	action	queries	2880-1
queries	on	constraint	the syntax	2880-1
the syntax	to	constraint	them	2880-1
the syntax	used	action	them	2880-1
the syntax	specify	action	them	2880-1
<B>	unlike	constraint	Part B	2880-2
Part B	in	constraint	this part	2880-2
this part		sequential	we	2880-2
we	Thus use	action	the term query	2880-2
the term query	to	constraint	mappings	2880-2
the term query	to	constraint	mappings	2880-2
the term query	primarily refer	action	mappings	2880-2
mappings	from	constraint	instances	2880-2
instances	to	constraint	instances	2880-2
instances	to	constraint	syntactic objects	2880-2
<B>	Although	constraint	there	2880-3
there	are	attribute	several correct definitions	2880-3
several correct definitions	for	constraint	the set	2880-3
the set	of	constraint	permissible queries	2880-3
permissible queries		sequential	the one	2880-3
the one	on	constraint	three fundamental assumptions	2880-3
the one	presented here	action	three fundamental assumptions	2880-3
the one	is based	action	three fundamental assumptions	2880-3
three fundamental assumptions		sequential	typedness	2880-3
typedness		sequential	computability	2880-3
computability	and	conjunctive	genericity	2880-3
The first assumption	involves	action	the schemas	2881-1
the schemas	of	constraint	the input	2881-1
the input	and	conjunctive	the answer	2881-1
the answer	to	constraint	a query	2881-1
A query	over	constraint	a particular database schema	2881-2
A query	is	attribute	a particular database schema	2881-2
a particular database schema	say	action	R	2881-2
<B>	Because	constraint	we	2882-1
we	in	constraint	effective queries	2882-1
we	are	attribute	only interested	2882-1
effective queries		sequential	we	2882-1
we	also make	action	the natural assumption	2882-1
the natural assumption	that	constraint	query mappings	2882-1
query mappings	are	attribute	computable	2882-1
Query computability	is defined	action	classical models	2882-2
Query computability	using	action	classical models	2882-2
classical models	of	constraint	computation	2882-2
computation		sequential	Turing machines	2882-2
Turing machines		sequential	TM	2882-2
The basic idea	that	constraint	the query	2882-3
The basic idea	is	attribute	the query	2882-3
the query	by	constraint	a TM	2882-3
the query	be	attribute	must implementable	2882-3
there	Thus must exist	action	a TM	2882-4
a TM		sequential	that	2882-4
that	as	constraint	input	2882-4
that	given	action	input	2882-4
input		sequential	a natural encoding	2882-4
a natural encoding	of	constraint	a database instance	2882-4
a database instance	on	constraint	the tape	2882-4
the tape	produces	action	an encoding	2882-4
an encoding	of	constraint	the output	2882-4
The formalization	of	constraint	these notions	2882-5
these notions	requires	action	some care	2882-5
some care	and	conjunctive	<B>	2882-5
some care	is done next	action	<B>	2882-5
<B>	Sizing	action	Up Languages	2883-1
Up Languages		sequential	P	2883-1
P		sequential	Q b c c P	2883-1
Q b c c P		sequential	b	2883-1
b		sequential	0 # 1	2883-1
0 # 1		sequential	1 # 0 Q	2883-1
1 # 0 Q		sequential	10 # 10	2883-1
10 # 10		sequential	Figure	2883-1
Figure		sequential	16.1	2883-1
We	by	constraint	standard encodings	2883-2
We	resolve	attribute	this	2883-2
We	using	action	standard encodings	2883-2
standard encodings	for	constraint	dom	2883-2
<B>	As	constraint	we	2883-3
we	although	constraint	us	2883-3
we	shall see later on	attribute	this	2883-3
we	permits	action	us	2883-3
us	to	constraint	conventional complexity theory	2883-3
us	use	action	conventional complexity theory	2883-3
conventional complexity theory	in	constraint	our study	2883-3
our study	of	constraint	query language expressiveness	2883-3
query language expressiveness		sequential	it	2883-3
it	also takes	action	us	2883-3
us		sequential	a bit	2883-3
a bit	of	constraint	the pure relational model	2883-3
We	on	constraint	encodings	2884-1
We	focus	action	encodings	2884-1
encodings	of	constraint	dom	2884-1
encodings	both	conjunctive	dom	2884-1
dom	of	constraint	subsets	2884-1
dom	and	conjunctive	subsets	2884-1
subsets	of	constraint	dom	2884-1
dom	and	conjunctive	we	2884-1
we	use	action	the symbols	2884-1
the symbols		sequential	0	2884-1
We	can now describe	action	the encoding	2885-1
the encoding	of	constraint	instances	2885-1
<B>	that	constraint	a set d ⊆ dom	2885-2
<B>	Suppose	action	a set d ⊆ dom	2885-2
a set d ⊆ dom		sequential	enumeration α	2885-2
enumeration α	for	constraint	d	2885-2
d		sequential	source schema	2885-2
source schema		sequential	R	2885-2
R	=	sequential	R1	2885-2
R	{	sequential	R1	2885-2
<B>	.	sequential	<B>	2885-3
<B>	.	sequential	<B>	2885-4
Rm }	and	conjunctive	schema S	2885-5
Rm }	target	action	schema S	2885-5
schema S	are given	action	<B>	2885-5
The encoding	of	constraint	instances	2885-6
instances	of	constraint	R	2885-6
R	uses	action	the alphabet	2885-6
the alphabet		sequential	0	2885-6
0		sequential	1	2885-6
1	# ∪ R ∪	sequential	}	2885-6
}		sequential	S	2885-6
S		sequential	}	2885-6
An instance		sequential	I	2885-7
I		sequential	R	2885-7
R	with	constraint	adom	2885-7
adom		sequential	I	2885-7
I		sequential	⊆ d	2885-7
⊆ d	to	constraint	α	2885-7
⊆ d	is encoded	attribute	relative	2885-7
α	as	constraint	1 enc α	2885-7
α	follows	action	1 enc α	2885-7
1 enc α		sequential	a 1	2885-7
<B>	.	sequential	<B>	2885-8
<B>	.	sequential	<B>	2885-9
ak	is	attribute	enc α	2885-10
enc α	a 1	sequential	<B>	2885-10
enc α	#	sequential	<B>	2885-10
<B>	.	sequential	<B>	2885-11
<B>	.	sequential	<B>	2885-12
# enc α		sequential	ak	2885-13
Example		sequential	16.1.1	2886-1
16.1	and	conjunctive	α	2886-2
16.1	let	action	α	2886-2
α	=	sequential	<B>	2886-2
<B>	Let	action	α	2887-1
α	be	attribute	a fixed enumeration	2887-1
a fixed enumeration	of	constraint	dom	2887-1
<B>	In	constraint	this case	2887-2
this case		sequential	the encoding enc α	2887-2
the encoding enc α	is	attribute	one	2887-2
the encoding enc α	described earlier	action	one	2887-2
one	to	constraint	one	2887-2
one	on	constraint	instances	2887-2
instances	and	conjunctive	an inverse enc−1	2887-2
instances	thus has	action	an inverse enc−1	2887-2
an inverse enc−1	as	constraint	a mapping α	2887-2
an inverse enc−1	when considered	action	a mapping α	2887-2
a mapping α	on	constraint	instances	2887-2
We	to	constraint	the notion	2887-3
We	are	attribute	now ready	2887-3
We	formalize	action	the notion	2887-3
the notion	of	constraint	computability	2887-3
computability	to	constraint	an encoding	2887-3
an encoding	of	constraint	dom	2887-3
Definition		sequential	16.1.2	2888-1
A mapping q	from	constraint	inst	2888-2
inst		sequential	R	2888-2
R	to	constraint	S	2888-2
R	inst	action	S	2888-2
S	to	constraint	α	2888-2
S	is	attribute	computable	2888-2
α	if	constraint	there	2888-2
there	exists	action	a TM M such	2888-2
a TM M such		sequential	that	2888-2
that	for	constraint	each instance	2888-2
each instance		sequential	I	2888-2
I		sequential	<B>	2888-2
representation		sequential	the extra information	2889-1
the extra information	of	constraint	primarily the enumeration α	2889-1
the extra information	consists	action	primarily the enumeration α	2889-1
primarily the enumeration α	of	constraint	constants	2889-1
constants	to	constraint	enc α	2889-1
constants	define	action	enc α	2889-1
<B>	In	constraint	the pure relational model	2889-2
the pure relational model		sequential	this kind	2889-2
this kind	of	constraint	information	2889-2
information	is	attribute	not part	2889-2
not part	of	constraint	the database	2889-2
the database	is	attribute	Instead an abstraction	2889-3
Instead an abstraction	of	constraint	TM	2889-3
Instead an abstraction	or	conjunctive	TM	2889-3
TM		sequential	its representation	2889-3
This additional information	as	constraint	noise	2890-1
This additional information	can be viewed	action	noise	2890-1
noise	with	constraint	the internal representation	2890-1
noise	associated	action	the internal representation	2890-1
the internal representation	and	conjunctive	any visible impact	2890-1
the internal representation	thus should not have	action	any visible impact	2890-1
any visible impact	for	constraint	the user	2890-1
the user	at	constraint	the conceptual level	2890-1
<B>	by	constraint	the data independence principle	2890-2
<B>	is captured	action	the data independence principle	2890-2
the data independence principle	in	constraint	databases	2890-2
databases		sequential	which	2890-2
which	that	constraint	a database	2890-2
which	postulates	action	a database	2890-2
a database	provides	action	an abstract interface	2890-2
an abstract interface		sequential	that	2890-2
that	hides	action	the internal representation	2890-2
the internal representation	of	constraint	data	2890-2
We	can now state	action	the intuition	2891-1
the intuition	behind	constraint	the requirement	2891-1
the intuition	and	conjunctive	the requirement	2891-1
the requirement	of	constraint	queries	2891-1
queries		sequential	which	2891-1
which	formalizes	action	the data independence principle	2891-1
<B>	Although	constraint	computations	2891-2
computations	on	constraint	the internal representation	2891-2
computations	performed	action	the internal representation	2891-2
the internal representation	may take	action	advantage	2891-2
advantage	of	constraint	all information	2891-2
all information	at	constraint	this level	2891-2
all information	provided	action	this level	2891-2
this level		sequential	it	2891-2
it	in	constraint	the definition	2891-2
it	is explicitly prohibited	action	the definition	2891-2
the definition	of	constraint	a query	2891-2
a query	that	constraint	the result	2891-2
the result	on	constraint	such information	2891-2
the result	depend	action	such information	2891-2
The property		sequential	that	2892-1
that		sequential	a query	2892-1
a query	on	constraint	only information	2892-1
a query	depends	action	only information	2892-1
only information	by	constraint	the input instance	2892-1
only information	provided	action	the input instance	2892-1
the input instance	is called	action	genericity	2892-1
genericity	and	conjunctive	<B>	2892-1
genericity	is formalized next	action	<B>	2892-1
The idea	that	constraint	the constants	2892-2
The idea	is	attribute	the constants	2892-2
the constants	in	constraint	the database	2892-2
the database	have	action	no properties	2892-2
no properties	than	constraint	the relationships	2892-2
the relationships	with	constraint	the database	2892-2
the relationships	by	constraint	the database	2892-2
the relationships	specified	action	the database	2892-2
Definition		sequential	16.1.3	2893-1
A mapping q	from	constraint	inst	2893-2
inst		sequential	R	2893-2
R	to	constraint	inst	2893-2
inst		sequential	S	2893-2
S	is	attribute	C	2893-2
C		sequential	generic iff	2893-2
generic iff	for	constraint	I	2893-2
I	over	constraint	R	2893-2
R	and	conjunctive	each permutation ρ	2893-2
each permutation ρ	of	constraint	dom	2893-2
dom		sequential	that	2893-2
that	is	attribute	the identity	2893-2
the identity	on	constraint	C	2893-2
C		sequential	ρ	2893-2
ρ		sequential	q	2893-2
q		sequential	I	2893-2
I	=	sequential	q	2893-2
q		sequential	ρ	2893-2
ρ		sequential	I	2893-2
C	is	attribute	When empty	2893-3
we	that	constraint	the query	2893-3
we	simply say	action	the query	2893-3
the query	is	attribute	generic	2893-3
<B>	Sizing Up	action	Languages	2894-1
<B>	In	constraint	other words	2895-1
other words		sequential	a query	2895-1
a query	is	attribute	C	2895-1
C	if	constraint	it	2895-1
it	with	constraint	permutations	2895-1
it	commutes	action	permutations	2895-1
permutations		sequential	that	2895-1
that	leave	action	C	2895-1
C	fixed	action	<B>	2895-1
Genericity	that	constraint	the query	2896-1
Genericity	states	action	the query	2896-1
the query	to	constraint	renaming	2896-1
the query	is	attribute	insensitive	2896-1
renaming	of	constraint	the constants	2896-1
the constants	in	constraint	the database	2896-1
the database	using	action	the permutation ρ	2896-1
It	uses	action	only the relationships	2896-2
only the relationships	among	constraint	constants	2896-2
constants	by	constraint	the database	2896-2
constants	provided	action	the database	2896-2
the database	of	constraint	any other information	2896-2
the database	and	conjunctive	any other information	2896-2
the database	is	attribute	independent	2896-2
any other information	about	constraint	the constants	2896-2
The set C	specifies	action	the exceptional constants	2896-3
the exceptional constants	in	constraint	the query	2896-3
the exceptional constants	named explicitly	action	the query	2896-3
<B>	without	constraint	the effect	2896-4
<B>	can not be renamed	action	the effect	2896-4
<B>	changing	action	the effect	2896-4
the effect	of	constraint	the query	2896-4
Permutations ρ	for	constraint	which	2897-1
which		sequential	ρ	2897-1
ρ		sequential	I	2897-1
Such ρ	are called	action	automorphisms	2897-2
automorphisms	for	constraint	I	2897-2
<B>	If	constraint	ρ	2897-3
ρ	is	attribute	an automorphism	2897-3
an automorphism	for	constraint	I	2897-3
I	and	conjunctive	ρ	2897-3
ρ	a =	sequential	b	2897-3
b	that	constraint	b	2897-3
b	and	conjunctive	b	2897-3
b	says intuitively	attribute	a	2897-3
b	can not be distinguished	action	the structure	2897-3
b	using	action	the structure	2897-3
the structure	of	constraint	I	2897-3
<B>	Let	action	q	2897-4
q	be	attribute	a generic query	2897-4
a generic query		sequential	I	2897-4
I		sequential	an instance	2897-4
an instance	and	conjunctive	ρ an automorphism	2897-4
ρ an automorphism	for	constraint	I	2897-4
<B>	by	constraint	genericity	2897-5
genericity		sequential	ρ	2897-5
ρ	is	attribute	Then so also an automorphism	2897-5
Then so also an automorphism	for	constraint	q	2897-5
q		sequential	I	2897-5
<B>	In	constraint	a generic query	2897-6
a generic query	between	constraint	constants	2897-6
a generic query	can not distinguish	action	constants	2897-6
constants		sequential	that	2897-6
that	in	constraint	the input	2897-6
that	are	attribute	undistinguishable	2897-6
the input	see	action	Exercise 16.5	2897-6
<B>	is	attribute	Of course not the case	2897-7
Of course not the case	if	constraint	the query	2897-7
the query	explicitly names	action	some constants	2897-7
We	illustrate	action	these various aspects	2898-1
these various aspects	of	constraint	genericity	2898-1
genericity	in	constraint	an example	2898-1
Example		sequential	16.1.4	2899-1
<B>	Let	action	I	2899-2
I	be	attribute	the instance	2899-2
the instance		sequential	c	2899-2
c		sequential	b	2899-2
b		sequential	c	2899-2
c		sequential	}	2899-2
<B>	Let	action	σ	2900-1
σ	be	attribute	the CALC query	2900-1
<B>	that	constraint	σ I	2901-1
<B>	Note	action	σ I	2901-1
σ I	=	sequential	a	2901-1
a		sequential	b	2901-1
b		sequential	}	2901-1
<B>	Let	action	ρ	2901-2
ρ	be	attribute	the permutation	2901-2
the permutation	by	constraint	ρ	2901-2
the permutation	defined	action	ρ	2901-2
ρ	a =	sequential	b	2901-2
b		sequential	ρ	2901-2
ρ		sequential	b	2901-2
b	=	sequential	c	2901-2
c	and	conjunctive	ρ	2901-2
ρ		sequential	c	2901-2
c	=	sequential	d	2901-2
Genericity	that	constraint	σ	2901-3
Genericity	requires	action	σ	2901-3
σ		sequential	ρ	2901-3
ρ		sequential	I	2901-3
<B>	that	constraint	b	2902-1
<B>	and	conjunctive	b	2902-1
<B>	Note also	attribute	a	2902-1
b	in	constraint	I	2902-1
b	are	attribute	undistinguishable	2902-1
<B>		sequential	the renaming ρ	2902-2
the renaming ρ	by	constraint	ρ	2902-2
the renaming ρ	defined	action	ρ	2902-2
ρ	a =	sequential	b	2902-2
b		sequential	ρ	2902-2
ρ		sequential	b	2902-2
b	=	sequential	a	2902-2
a	and	conjunctive	ρ	2902-2
ρ		sequential	c	2902-2
c	=	sequential	c	2902-2
c	has	action	the property	2902-2
the property		sequential	that	2902-2
that		sequential	ρ	2902-2
ρ		sequential	I	2902-2
<B>	Let	action	q	2902-3
q	be	attribute	a generic query	2902-3
a generic query	on	constraint	G	2902-3
a generic query	between	constraint	b	2902-4
a generic query	and	conjunctive	b	2902-4
a generic query	Thus can not distinguish	attribute	a	2902-4
<B>	for	constraint	queries	2902-5
<B>	is	attribute	Of course not true	2902-5
queries	for	constraint	C nonempty	2902-5
<B>	For	constraint	instance	2902-6
instance	let	action	qb	2902-6
qb	=	sequential	π 1	2902-6
π 1		sequential	σ 2=b	2902-6
σ 2=b		sequential	G	2902-6
qb	is	attribute	Now b	2903-1
Now b	and	conjunctive	qb	2903-1
qb		sequential	I	2903-1
I	=	sequential	a }	2903-1
qb	between	constraint	b	2903-2
qb	and	conjunctive	b	2903-2
qb	Thus distinguishes	attribute	a	2903-2
It	that	constraint	a database mapping q	2904-1
It	if	constraint	a database mapping q	2904-1
It	is easily verified	action	a database mapping q	2904-1
a database mapping q	is	attribute	C generic	2904-1
C generic	for	constraint	each input instance	2904-1
each input instance		sequential	I	2904-1
I		sequential	adom	2904-1
adom		sequential	q	2904-1
q		sequential	I	2904-1
I		sequential	⊆ C ∪ adom	2904-1
⊆ C ∪ adom		sequential	I	2904-1
I	see	action	Exercise 16.1	2904-1
<B>	In	constraint	most cases	2905-1
most cases		sequential	we	2905-1
we	will ignore	action	the issue	2905-1
the issue	of	constraint	constants	2905-1
constants	in	constraint	queries	2905-1
queries	because	constraint	it	2905-1
it	is	attribute	not central	2905-1
<B>	that	constraint	a query	2906-1
<B>	Note	attribute	C generic	2906-1
a query	as	constraint	a generic query	2906-1
a query	can be viewed	action	a generic query	2906-1
a generic query	by	constraint	the constants	2906-1
a generic query	including	action	the constants	2906-1
the constants	in	constraint	C	2906-1
C	in	constraint	the input	2906-1
the input	using	action	one relation	2906-1
one relation	for	constraint	<B>	2906-1
<B>	For	constraint	instance	2906-2
instance		sequential	}	2906-2
}		sequential	the b query qb	2906-2
the b query qb	over	constraint	G	2906-2
G	in	constraint	Example 16.1.4	2906-2
Example 16.1.4	to	constraint	a generic query q′	2906-2
Example 16.1.4	is reduced	action	a generic query q′	2906-2
a generic query q′	{	sequential	<B>	2906-2
<B>	In	constraint	we	2907-1
<B>	following	action	we	2907-1
we	that	constraint	queries	2907-1
we	will usually assume	action	queries	2907-1
queries	have	action	no constants	2907-1
no constants	unless	constraint	<B>	2907-1
no constants	explicitly stated	action	<B>	2907-1
<B>	that	constraint	α	2908-1
<B>	Suppose now	action	α	2908-1
α	and	conjunctive	β	2908-1
β	are	attribute	two enumerations	2908-1
two enumerations	of	constraint	dom	2908-1
dom	that	constraint	a generic mapping q	2908-1
dom	and	conjunctive	a generic mapping q	2908-1
a generic mapping q	from	constraint	R	2908-1
R	to	constraint	S	2908-1
S	by	constraint	a TM M	2908-1
S	is computed	action	a TM M	2908-1
a TM M	using	action	enc α	2908-1
It	that	constraint	the same query	2908-2
It	is easily verified	action	the same query	2908-2
the same query	by	constraint	M	2908-2
the same query	is computed	action	M	2908-2
M	if	constraint	enc β	2908-2
enc β	in	constraint	place	2908-2
enc β	is used	action	place	2908-2
place	of	constraint	enc α	2908-2
enc α	see	action	Exercise 16.2	2908-2
<B>	permits	action	us	2908-3
us	to	constraint	the following notion	2908-3
us	adopt	action	the following notion	2908-3
the following notion	of	constraint	which	2908-3
which	to	constraint	enumeration	2908-3
which	to	constraint	enumeration	2908-3
which	is	attribute	equivalent	2908-3
enumeration		sequential	α	2908-3
α	in	constraint	the case	2908-3
the case	of	constraint	generic queries	2908-3
This definition	has	action	the advantage	2908-4
the advantage	of	constraint	infinite enumerations	2908-4
the advantage	on	constraint	infinite enumerations	2908-4
the advantage	relying	attribute	finite	2908-4
Definition		sequential	16.1.5	2909-1
We	to	constraint	queries	2910-1
We	are	attribute	now ready	2910-1
We	define formally	action	queries	2910-1
Definition		sequential	16.1.6	2911-1
A query	from	constraint	R	2911-2
R	to	constraint	S	2911-2
S	is	attribute	a partial mapping	2911-2
a partial mapping	from	constraint	inst	2911-2
inst		sequential	R	2911-2
R	to	constraint	S	2911-2
R	inst	action	S	2911-2
S		sequential	that	2911-2
that	and	conjunctive	<B>	2911-2
that	is	attribute	generic	2911-2
<B>	that	constraint	all queries	2912-1
<B>	Note	action	all queries	2912-1
all queries	in	constraint	previous chapters	2912-1
all queries	discussed	action	previous chapters	2912-1
previous chapters	satisfy	action	the preceding definition	2912-1
the preceding definition		sequential	modulo constants	2912-1
modulo constants	in	constraint	queries	2912-1
Queries	and	conjunctive	Query Languages	2913-1
<B>	in	constraint	query	2913-2
<B>	Given	action	query	2913-2
query		sequential	an expression E language L	2913-2
an expression E language L		sequential	the mapping	2913-2
the mapping	between	constraint	instances	2913-2
instances		sequential	that	2913-2
that		sequential	E	2913-2
E	describes	action	the effect	2913-2
E	is called	action	the effect	2913-2
the effect	of	constraint	E.	2913-2
E.	on	constraint	the language	2913-2
E.	Depending	action	the language	2913-2
the language		sequential	there	2913-2
there	may be	action	several alternative semantics	2913-2
several alternative semantics	versus	constraint	the query	2913-2
several alternative semantics	for	constraint	the query	2913-2
several alternative semantics	defining	action	the query	2913-2
the query	by	constraint	an expression	2913-2
the query	expressed	action	an expression	2913-2
A related issue	concerns	action	the specification	2913-3
the specification	of	constraint	the output schema	2913-3
the output schema	of	constraint	an expression	2913-3
<B>	In	constraint	calculus	2913-4
calculus	based	action	languages	2913-4
languages		sequential	the output schema	2913-4
the output schema	by	constraint	the form	2913-4
the output schema	is unambiguously specified	action	the form	2913-4
the form	of	constraint	the expression	2913-4
The situation	for	constraint	other languages	2913-5
The situation	is	attribute	more ambiguous	2913-5
other languages		sequential	datalog	2913-5
datalog	and	conjunctive	while	2913-5
Programs	in	constraint	these languages	2913-6
these languages	typically manipulate	action	several relations	2913-6
several relations	and	conjunctive	which	2913-6
several relations	may not specify explicitly	action	which	2913-6
which	to	constraint	the answer	2913-6
which	as	constraint	the answer	2913-6
which	is be taken	action	the answer	2913-6
the answer	to	constraint	the query	2913-6
<B>	In	constraint	such cases	2913-7
such cases		sequential	the concepts	2913-7
the concepts	of	constraint	input	2913-7
input		sequential	output	2913-7
output	and	conjunctive	temporary relations	2913-7
temporary relations	may become	attribute	important	2913-7
<B>	in	constraint	addition	2913-8
addition	to	constraint	semantically significant input	2913-8
semantically significant input	and	conjunctive	output relations	2913-8
output relations		sequential	the programs	2913-8
the programs	Thus may use	action	temporary relations	2913-8
temporary relations		sequential	whose content	2913-8
whose content	outside	constraint	the Sizing Up Languages computation	2913-8
whose content	is	attribute	immaterial	2913-8
We	will state explicitly	action	which relations	2913-9
which relations	and	conjunctive	which	2913-9
which relations	are	attribute	temporary	2913-9
which	constitute	action	the output	2913-9
the output	from	constraint	the context	2913-9
the output	is	attribute	whenever not clear	2913-9
We	will discuss	action	such languages	2914-1
such languages	in	constraint	Chapter 18	2914-1
Complexity	of	constraint	Queries	2915-1
<B>	by	constraint	reference	2915-2
<B>	is done	action	reference	2915-2
reference	to	constraint	TMs	2915-2
TMs	and	conjunctive	classical complexity classes	2915-2
classical complexity classes	defined	action	the TM model	2915-2
classical complexity classes	using	action	the TM model	2915-2
There	are	attribute	several ways	2916-1
several ways	to	constraint	the complexity	2916-1
several ways	at	constraint	the complexity	2916-1
several ways	look	action	the complexity	2916-1
the complexity	of	constraint	queries	2916-1
They	in	constraint	the parameters	2916-2
They	differ	action	the parameters	2916-2
the parameters	with	constraint	respect	2916-2
respect	to	constraint	which	2916-2
which		sequential	the complexity	2916-2
the complexity	is measured	action	<B>	2916-2
The two main possibilities	as	constraint	<B>	2916-3
The two main possibilities	are	attribute	<B>	2916-3
The two main possibilities	follows	action	<B>	2916-3
<B>	in	constraint	Thus the data complexity perspective	2917-1
Thus the data complexity perspective		sequential	the complexity	2917-1
the complexity	with	constraint	respect	2917-1
the complexity	is	attribute	respect	2917-1
respect	to	constraint	the database input	2917-1
the database input	and	conjunctive	the query	2917-1
the query	is considered	attribute	constant	2917-1
<B>	with	constraint	expression complexity	2917-2
expression complexity		sequential	the database input	2917-2
the database input	and	conjunctive	the complexity	2917-2
the database input	Conversely is fixed	action	the complexity	2917-2
the complexity	with	constraint	respect	2917-2
the complexity	is	attribute	respect	2917-2
respect	to	constraint	the size	2917-2
the size	of	constraint	the query expression	2917-2
the measures	Clearly provide	action	different information	2918-1
different information	about	constraint	the complexity	2918-1
the complexity	of	constraint	queries	2918-1
the complexity	evaluating	action	queries	2918-1
The usual situation	that	constraint	the size	2918-2
The usual situation	is	attribute	the size	2918-2
the size	of	constraint	the database input	2918-2
the database input	by	constraint	the size	2918-2
the database input	dominates	action	the size	2918-2
the size	of	constraint	the query	2918-2
the query	and	conjunctive	data complexity	2918-2
data complexity	is	attribute	so typically most relevant	2918-2
<B>	is	attribute	the primary focus	2918-3
the primary focus	of	constraint	Part E	2918-3
Part E	and	conjunctive	we	2918-3
we	use	action	the term complexity	2918-3
the term complexity	to	constraint	data complexity	2918-3
the term complexity	to	constraint	data complexity	2918-3
the term complexity	refer	action	data complexity	2918-3
data complexity	unless	constraint	<B>	2918-3
data complexity	otherwise stated	action	<B>	2918-3
The complexity	of	constraint	queries	2919-1
queries	on	constraint	the recognition problem	2919-1
queries	is defined	action	the recognition problem	2919-1
queries	based	action	the recognition problem	2919-1
the recognition problem	with	constraint	the query	2919-1
the recognition problem	associated	action	the query	2919-1
<B>	For	constraint	a query	2919-2
a query		sequential	q	2919-2
q		sequential	the recognition problem	2919-2
the recognition problem	as	constraint	<B>	2919-2
the recognition problem	is	attribute	<B>	2919-2
the recognition problem	follows	action	<B>	2919-2
<B>	To	constraint	the recognition problem	2919-3
<B>	be	attribute	more precise	2919-3
the recognition problem	of	constraint	a query q	2919-3
a query q	is	attribute	the language	2919-3
data		sequential	The complexity	2920-1
The complexity	of	constraint	q	2920-1
q	is	attribute	conventional	2920-1
the complexity	of	constraint	its recognition problem	2920-1
<B>		sequential	the complexity	2921-1
the complexity	with	constraint	respect	2921-1
the complexity	is	attribute	respect	2921-1
respect	to	constraint	the size	2921-1
the size	of	constraint	the input	2921-1
the input		sequential	the length # enc α	2921-1
the length # enc α	of	constraint	the word enc	2921-1
the word enc		sequential	α	2921-1
α		sequential	I	2921-1
I		sequential	u	2921-1
<B>	Because	constraint	an instance	2921-2
<B>	for	constraint	an instance	2921-2
an instance		sequential	I	2921-2
I		sequential	the size	2921-2
the size		sequential	number	2921-2
number	of	constraint	tuples	2921-2
tuples	in	constraint	I	2921-2
I	to	constraint	the length	2921-2
I	is	attribute	closely related	2921-2
the length	of	constraint	enc α	2921-2
enc α		sequential	I	2921-2
I	see	action	Exercise 16.12	2921-2
Exercise 16.12		sequential	the size	2921-2
the size	of	constraint	I	2921-2
I	as	constraint	the measure	2921-2
I	is usually taken	action	the measure	2921-2
the measure	of	constraint	the input	2921-2
<B>	For	constraint	Turing time	2922-1
Turing time	or	conjunctive	each space complexity class c	2922-1
each space complexity class c		sequential	one	2922-1
one	can define	action	a corresponding complexity class	2922-1
a corresponding complexity class	of	constraint	queries	2922-1
queries	by	constraint	qc	2922-1
queries	denoted	action	qc	2922-1
The class qc	of	constraint	queries	2922-2
queries	of	constraint	all queries	2922-2
queries	consists	action	all queries	2922-2
all queries		sequential	whose recognition problem	2922-2
whose recognition problem	in	constraint	c	2922-2
whose recognition problem	is	attribute	c	2922-2
There	is	attribute	another way	2923-1
another way	to	constraint	the complexity	2923-1
another way	define	action	the complexity	2923-1
the complexity	of	constraint	queries	2923-1
queries		sequential	that	2923-1
that	on	constraint	the complexity	2923-1
that	is based	action	the complexity	2923-1
the complexity	of	constraint	the result	2923-1
the complexity	actually constructing	action	the result	2923-1
the result	of	constraint	the query	2923-1
the query		sequential	the recognition problem	2923-1
the recognition problem	for	constraint	individual tuples	2923-1
The two definitions	in	constraint	most cases	2923-2
The two definitions	are	attribute	most cases	2923-2
most cases	see	action	Exercise 16.13	2923-2
<B>	In	constraint	complexity classes	2923-3
<B>	for	constraint	complexity classes	2923-3
complexity classes	to	constraint	a polynomial factor	2923-3
a polynomial factor		sequential	the definitions	2923-3
the definitions	are	attribute	equivalent	2923-3
<B>	In	constraint	the definition	2923-4
the definition	on	constraint	the result	2923-4
the definition	based	action	the result	2923-4
the definition	constructing	action	the result	2923-4
the result	between	constraint	a query	2923-4
the result	distinguishes	action	a query	2923-4
a query	with	constraint	a large answer	2923-4
a large answer	and	conjunctive	one	2923-4
one	with	constraint	a small answer	2923-4
a small answer		sequential	which	2923-4
which	to	constraint	the definition	2923-4
which	is	attribute	irrelevant	2923-4
the definition	on	constraint	recognition	2923-4
the definition	based	action	recognition	2923-4
<B>	On	constraint	the other hand	2923-5
the other hand		sequential	the definition	2923-5
the definition	on	constraint	the result	2923-5
the definition	based	action	the result	2923-5
the definition	constructing	action	the result	2923-5
the result	between	constraint	queries	2923-5
the result	and	conjunctive	queries	2923-5
the result	may not distinguish	attribute	easy	2923-5
queries	with	constraint	large results	2923-5
Example		sequential	16.2.1	2924-1
<B>	Consider	action	first cross	2925-1
first cross	and	conjunctive	path	2925-1
<B>	have	action	potentially large answers	2925-2
potentially large answers	but	conjunctive	cross	2925-2
cross	than	constraint	path	2925-2
cross	is	attribute	clearly easier	2925-2
path	though	constraint	the time complexity	2925-2
the time complexity	of	constraint	the result	2925-2
the time complexity	constructing	action	the result	2925-2
the result	is	attribute	even O	2925-2
even O	n	conjunctive	2	2925-2
2	for	constraint	cross	2925-2
2	both	conjunctive	cross	2925-2
cross	and	conjunctive	path	2925-2
The time complexity	of	constraint	the recognition problem	2925-3
the recognition problem	is	attribute	O	2925-3
O		sequential	n	2925-3
n	for	constraint	cross	2925-3
cross	and	conjunctive	O	2925-3
O	n	conjunctive	2	2925-3
2	for	constraint	path	2925-3
the measure	on	constraint	the result	2925-4
the measure	based	action	the result	2925-4
the measure	constructing	action	the result	2925-4
the result	Thus does not detect	action	a difference	2925-4
a difference	between	constraint	cross	2925-4
cross	and	conjunctive	path	2925-4
path	whereas	constraint	the complexity	2925-4
path	by	constraint	the complexity	2925-4
path	is detected	action	the complexity	2925-4
the complexity	of	constraint	the recognition problem	2925-4
<B>	Next consider	action	cross	2925-5
cross	and	conjunctive	self	2925-5
The time complexity	of	constraint	the recognition problem	2925-6
the recognition problem	in	constraint	both cases	2925-6
the recognition problem	is	attribute	both cases	2925-6
both cases		sequential	O	2925-6
O		sequential	n	2925-6
n	but	conjunctive	the complexity	2925-6
the complexity	of	constraint	computing	2925-6
computing		sequential	the result	2925-6
the result	is	attribute	O	2925-6
O		sequential	n	2925-6
n	for	constraint	self	2925-6
self	whereas	constraint	it	2925-6
it	is	attribute	O	2925-6
O	n	conjunctive	2	2925-6
2	for	constraint	cross	2925-6
the complexity	of	constraint	the recognition problem	2925-7
the recognition problem	between	constraint	cross	2925-7
the recognition problem	Thus does not distinguish	action	cross	2925-7
cross	and	conjunctive	self	2925-7
self	although	constraint	cross	2925-7
cross	can potentially generate	action	a much larger answer	2925-7
This difference	by	constraint	the complexity	2925-8
This difference	is detected	action	the complexity	2925-8
the complexity	of	constraint	the result	2925-8
the complexity	constructing	action	the result	2925-8
<B>	In	constraint	Part E	2926-1
Part E		sequential	we	2926-1
we	will use	action	the definition	2926-1
the definition	of	constraint	query complexity	2926-1
query complexity	on	constraint	the associated recognition problem	2926-1
query complexity	based	action	the associated recognition problem	2926-1
Languages	and	conjunctive	Complexity	2927-1
<B>	To	constraint	the complexity	2928-1
<B>	measure	action	the complexity	2928-1
the complexity	of	constraint	a query language L	2928-1
a query language L		sequential	we	2928-1
we	to	constraint	a correspondence between	2928-1
we	need	action	a correspondence between	2928-1
we	establish	action	a correspondence between	2928-1
Expressiveness	with	constraint	Respect	2929-1
Respect	to	constraint	Complexity Classes	2929-1
<B>	In	constraint	every case	2929-2
every case		sequential	each query	2929-2
each query	in	constraint	L	2929-2
L	has	action	complexity c	2929-2
complexity c	and	conjunctive	conversely L	2929-2
conversely L	can express	action	every query	2929-2
every query	of	constraint	complexity c	2929-2
<B>	Sizing Up	action	Languages	2930-1
we	that	constraint	<B>	2930-2
we	Unfortunately will see	attribute	this	2930-2
we	is	attribute	not always possible	2930-2
<B>	In	constraint	fact	2930-3
fact		sequential	there	2930-3
there	are	attribute	no such results	2930-3
no such results	for	constraint	the pure relational model	2930-3
the pure relational model	for	constraint	complexity classes	2930-3
complexity classes	of	constraint	polynomial time	2930-3
polynomial time	and	conjunctive	that	2930-3
that	of	constraint	most interest	2930-3
that	are	attribute	most interest	2930-3
We	consider	action	this phenomenon	2930-4
this phenomenon	at	constraint	length	2930-4
length	in	constraint	the next chapter	2930-4
the shapes	of	constraint	classes	2930-5
classes	of	constraint	queries	2930-5
queries	of	constraint	low complexity	2930-5
low complexity	of	constraint	classes	2930-5
low complexity	Intuitively do not match	attribute	those	2930-5
classes	of	constraint	queries	2930-5
queries	by	constraint	any known language	2930-5
queries	defined	action	any known language	2930-5
we	to	constraint	a less straightforward way	2930-6
we	Therefore are led	action	a less straightforward way	2930-6
we	consider	action	a less straightforward way	2930-6
a less straightforward way	to	constraint	languages	2930-6
a less straightforward way	match	action	languages	2930-6
languages	to	constraint	complexity classes	2930-6
Completeness	with	constraint	Respect	2931-1
Respect	to	constraint	Complexity Classes	2931-1
Complexity Classes	Consider	action	a language L	2931-1
a language L		sequential	that	2931-1
that	to	constraint	any natural complexity class	2931-1
that	does not correspond precisely	action	any natural complexity class	2931-1
any natural complexity class	of	constraint	queries	2931-1
we	to	constraint	something	2931-2
we	Nonetheless would like	action	something	2931-2
we	say	action	something	2931-2
something	about	constraint	the complexity	2931-2
the complexity	of	constraint	queries	2931-2
queries	in	constraint	L	2931-2
<B>	For	constraint	we	2931-3
<B>	to	constraint	we	2931-3
<B>	be	attribute	meaningful	2931-3
we	that	constraint	c	2931-3
we	would also like	action	c	2931-3
c	in	constraint	some sense	2931-3
c	is	attribute	some sense	2931-3
some sense		sequential	a tight upper bound	2931-3
a tight upper bound	for	constraint	the complexity	2931-3
the complexity	of	constraint	queries	2931-3
queries	in	constraint	L	2931-3
The property	of	constraint	a problem	2931-4
a problem	in	constraint	a complexity class	2931-4
a problem	being	attribute	hardest	2931-4
a complexity class		sequential	c	2931-4
c	in	constraint	complexity theory	2931-4
c	is captured	action	complexity theory	2931-4
complexity theory	by	constraint	the notion	2931-4
the notion	of	constraint	completeness	2931-4
completeness	of	constraint	the problem	2931-4
the problem	in	constraint	the class	2931-4
the class	see	action	Chapter 2	2931-4
<B>	By	constraint	extension	2931-5
extension	to	constraint	a language	2931-5
a language	to	constraint	the following Definition 16.3.1	2931-5
a language	leads	action	the following Definition 16.3.1	2931-5
<B>	In	constraint	some sense	2932-1
some sense		sequential	completeness	2932-1
completeness	without	constraint	expressiveness	2932-1
expressiveness	says	action	something	2932-1
something	about	constraint	the language L. L	2932-1
the language L. L	can express	action	some queries	2932-1
some queries		sequential	that	2932-1
that	as	constraint	any query	2932-1
that	are	attribute	as hard	2932-1
any query	in	constraint	qc	2932-1
qc	on	constraint	the other hand	2932-1
the other hand		sequential	there	2932-1
there	may be	action	easy queries	2932-1
easy queries	in	constraint	qc	2932-1
qc		sequential	that	2932-1
that	in	constraint	L	2932-1
that	are	attribute	not expressible	2932-1
there	However is	action	no contradiction	2932-2
The reduction	of	constraint	the query	2933-1
the query	to	constraint	the complete query	2933-1
the complete query	in	constraint	L.	2933-1
the complete query	but	conjunctive	L.	2933-1
the complete query	be	attribute	may computationally easy	2933-1
L.		sequential	Examples	2933-1
Examples	of	constraint	this situation	2933-1
this situation	involve	action	the familiar languages fixpoint	2933-1
the familiar languages fixpoint	and	conjunctive	while	2933-1
<B>	As	constraint	Section 17.3	2933-2
<B>	in	constraint	Section 17.3	2933-2
<B>	will be shown	action	Section 17.3	2933-2
Section 17.3		sequential	these languages	2933-2
these languages	in	constraint	ptime	2933-2
these languages	are	attribute	complete respectively	2933-2
ptime	and	conjunctive	pspace	2933-2
<B>	neither	conjunctive	the simple parity query	2933-3
<B>	However can express	action	the simple parity query	2933-3
the simple parity query	on	constraint	a unary relation R	2933-3
a unary relation R		sequential	even R	2933-3
even R	if	constraint	R|	2933-3
even R	=	sequential	R|	2933-3
R|	and	conjunctive	<B>	2933-3
R|	is	attribute	false otherwise	2933-3
Bibliographic Notes		sequential	Complexity	2934-1
Complexity	and	conjunctive	Genericity	2934-1
The foregoing query	even illustrates	action	a fundamental phenomenon	2935-1
a fundamental phenomenon	relating	action	genericity	2935-1
genericity	to	constraint	the complexity	2935-1
the complexity	of	constraint	queries	2935-1
<B>	As	constraint	fixpoint	2935-2
<B>	by	constraint	fixpoint	2935-2
<B>	stated earlier	action	fixpoint	2935-2
<B>	even can not be computed	action	fixpoint	2935-2
fixpoint	by	constraint	while	2935-2
fixpoint	or	conjunctive	while	2935-2
while	of	constraint	which	2935-2
which	are	attribute	powerful languages	2935-2
The difficulty	in	constraint	computing even	2935-3
computing even	due to	constraint	the lack	2935-3
computing even	is	attribute	the lack	2935-3
the lack	of	constraint	information	2935-3
information	about	constraint	the elements	2935-3
the elements	of	constraint	the set	2935-3
<B>	Because	constraint	the database	2935-4
the database	only provides	action	a set	2935-4
a set	of	constraint	undifferentiated elements	2935-4
undifferentiated elements		sequential	genericity	2935-4
genericity	that	constraint	they	2935-4
genericity	implies	action	they	2935-4
they	in	constraint	queries	2935-4
they	are treated uniformly	action	queries	2935-4
<B>	rules out	action	the straightforward solution	2936-1
the straightforward solution	of	constraint	one arbitrary element	2936-1
the straightforward solution	repeatedly extracting	action	one arbitrary element	2936-1
one arbitrary element	from	constraint	the set	2936-1
the set	until	constraint	the set	2936-1
the set	while	constraint	a binary counter	2936-1
the set	is	attribute	empty	2936-1
the set	keeping	action	a binary counter	2936-1
<B>	On	constraint	the other hand	2937-1
the other hand	consider	action	the problem	2937-1
the problem	of	constraint	computing	2937-1
computing	with	constraint	even a TM	2937-1
The additional information	by	constraint	the encoding	2937-2
The additional information	provided	action	the encoding	2937-2
the encoding	of	constraint	the input	2937-2
the input	on	constraint	the tape	2937-2
the tape	makes	action	the problem	2937-2
the problem	and	conjunctive	linear time	2937-2
the problem	allows	action	linear time	2937-2
linear time		sequential	a solution	2937-2
<B>	highlights	action	the interesting fact	2938-1
the interesting fact	that	constraint	genericity	2938-1
genericity	may complicate	action	the task	2938-1
the task	of	constraint	a query	2938-1
the task	computing	action	a query	2938-1
a query	whereas	constraint	access	2938-1
access	to	constraint	the internal representation	2938-1
the internal representation	may simplify considerably	action	this task	2938-1
<B>	Thus suggests	action	a trade off	2938-2
a trade off	between	constraint	genericity	2938-2
genericity	and	conjunctive	complexity	2938-2
<B>	by	constraint	complexity classes	2938-3
<B>	can be formalized	action	complexity classes	2938-3
<B>	defining	action	complexity classes	2938-3
complexity classes	on	constraint	a computing device	2938-3
complexity classes	based	action	a computing device	2938-3
a computing device		sequential	that	2938-3
that	by	constraint	definition	2938-3
that	is	attribute	generic	2938-3
definition	in	constraint	place	2938-3
place	of	constraint	a TM	2938-3
Such a device	can not take	action	advantage	2938-4
advantage	of	constraint	the representation	2938-4
the representation	of	constraint	data	2938-4
data	in	constraint	the same manner	2938-4
the same manner	as	constraint	a TM	2938-4
a TM	and	conjunctive	it	2938-4
it	treats generically	action	data	2938-4
data	at	constraint	all points	2938-4
all points	in	constraint	the computation	2938-4
It	that	constraint	respect	2938-5
It	with	constraint	respect	2938-5
It	can be shown	attribute	even hard	2938-5
It	is	attribute	even hard	2938-5
respect	to	constraint	complexity measures	2938-5
complexity measures	on	constraint	such a device	2938-5
complexity measures	based	action	such a device	2938-5
The query	to	constraint	various aspects	2938-6
The query	even will be used repeatedly	action	various aspects	2938-6
The query	illustrate	action	various aspects	2938-6
various aspects	of	constraint	the complexity	2938-6
the complexity	of	constraint	queries	2938-6
Bibliographic Notes		sequential	Bibliographic Notes	2939-1
<B>	In	constraint	addition	2939-2
addition	to	constraint	languages	2939-2
addition	well typed	action	languages	2939-2
languages		sequential	they	2939-2
they	also considered	action	languages	2939-2
languages	defining	action	queries	2939-2
queries	with	constraint	data	2939-2
data		sequential	output schemas	2939-2
data	and	conjunctive	expression	2939-3
expression		sequential	The complexity	2939-3
The complexity	of	constraint	queries	2939-3
queries	in	constraint	CH80a	2939-3
queries	and	conjunctive	CH80a	2939-3
queries	were introduced	action	CH80a	2939-3
queries	studied	action	CH80a	2939-3
CH80a		sequential	CH82	2939-3
CH82	in	constraint	<B>	2939-3
CH82	and	conjunctive	<B>	2939-3
CH82	further investigated	action	<B>	2939-3
The notion	of	constraint	genericity	2940-1
genericity	in	constraint	AU79	2940-1
genericity	was formalized	action	AU79	2940-1
AU79		sequential	CH80b	2940-1
CH80b	with	constraint	different terminology	2940-1
The term		sequential	C	2941-1
C		sequential	genericity	2941-1
genericity	in	constraint	HY84	2941-1
genericity	was first used	action	HY84	2941-1
Other notions	in	constraint	spirit	2941-2
spirit	to	constraint	genericity	2941-2
genericity	in	constraint	Hul86	2941-2
genericity	are studied	action	Hul86	2941-2
The definition	of	constraint	genericity	2941-3
genericity	in	constraint	AK89	2941-3
genericity	is extended	action	AK89	2941-3
AK89	to	constraint	queries	2941-3
AK89	object	action	queries	2941-3
AK89	oriented	action	queries	2941-3
queries		sequential	that	2941-3
that	can produce	action	new constants	2941-3
new constants	in	constraint	the result	2941-3
the result	from	constraint	new object identifiers	2941-3
the result	arising	action	new object identifiers	2941-3
new object identifiers	see also	action	VandBGAG92	2941-3
VandBGAG92		sequential	HY90	2941-3
<B>	in	constraint	Chapters 18	2941-4
<B>	is further discussed	action	Chapters 18	2941-4
Chapters 18	and	conjunctive	21	2941-4
<B>	Sizing Up	action	Languages complexity classes	2942-1
Languages complexity classes	of	constraint	queries	2942-1
queries	to	constraint	the trade off	2942-1
queries	and	conjunctive	the trade off	2942-1
queries	investigate	action	the trade off	2942-1
the trade off	between	constraint	genericity	2942-1
genericity	and	conjunctive	complexity	2942-1
Informative discussions	of	constraint	the connection	2943-1
the connection	between	constraint	query languages	2943-1
query languages	and	conjunctive	complexity classes	2943-1
complexity classes	in	constraint	Gur84	2943-1
complexity classes	are provided	action	Gur84	2943-1
Gur84		sequential	Gur88	2943-1
Gur88		sequential	Imm87	2943-1
Imm87		sequential	b	2943-1
b		sequential	Lei89a	2943-1
Exercises Exercise 16.1		sequential	Exercises Exercise 16.1	2944-1
<B>	that	constraint	each input instance	2944-2
<B>	for	constraint	each input instance	2944-2
<B>	Show	action	each input instance	2944-2
each input instance		sequential	I	2944-2
I		sequential	adom	2944-2
adom		sequential	q	2944-2
q		sequential	I	2944-2
Exercise		sequential	16.2	2945-1
16.2		sequential	Genericity	2945-1
<B>	that	constraint	each instance	2946-1
<B>	for	constraint	each instance	2946-1
<B>	Prove	action	each instance	2946-1
each instance		sequential	I	2946-1
I	over	constraint	R	2946-1
R		sequential	enc	2946-1
enc		sequential	α	2946-1
α		sequential	M	2946-1
M	◦	sequential	enc−1	2946-1
enc−1	=	sequential	<B>	2946-1
enc β	◦	sequential	M	2947-1
M	◦	sequential	enc−1	2947-1
enc−1	that	constraint	M	2947-1
enc−1	Conclude	action	M	2947-1
M	computes	action	q	2947-1
q	using	action	enc β	2947-1
Exercise		sequential	16.4	2948-1
<B>	For	constraint	a natural definition	2948-2
<B>	of	constraint	a natural definition	2948-2
<B>	develop	action	a natural definition	2948-2
a natural definition	for	constraint	a nongeneric query	2948-2
a natural definition	and	conjunctive	a nongeneric query	2948-2
a natural definition	exhibit	action	a nongeneric query	2948-2
a nongeneric query	if	constraint	there	2948-2
there	is	attribute	one	2948-2
Exercise		sequential	16.5	2949-1
<B>	Let	action	ρ	2949-2
ρ	be	attribute	an automorphism	2949-2
an automorphism	of	constraint	I	2949-2
I	is	attribute	the identity	2949-2
the identity	on	constraint	C	2949-2
C	and	conjunctive	b	2949-2
C	let	attribute	a	2949-2
b	be	attribute	constants	2949-2
constants	in	constraint	I	2949-2
I	that	constraint	ρ	2949-2
ρ	a =	sequential	b	2949-2
<B>	that	constraint	q	2949-3
<B>	in	constraint	q	2949-3
<B>	Show	attribute	a	2949-3
<B>	occurs	action	q	2949-3
q		sequential	I	2949-3
I	iff	constraint	b	2949-3
b	in	constraint	q	2949-3
b	occurs	action	q	2949-3
q		sequential	I	2949-3
The next several exercises	use	action	the following notions	2950-1
<B>	Let	action	R	2950-2
R	be	attribute	a database schema	2950-2
<B>	Let	action	k	2950-3
k	be	attribute	a positive integer	2950-3
a positive integer	and	conjunctive	I	2950-3
I		sequential	an instance	2950-3
an instance	over	constraint	R. 8I	2950-3
R. 8I	denotes	action	the set	2950-3
the set	of	constraint	k tuples	2950-3
k tuples		sequential	that	2950-3
that	can be formed	action	k	2950-3
k	using	action	just constants	2950-3
just constants	in	constraint	I	2950-3
<B>	Define	action	the following relation	2950-4
the following relation	≡	sequential	I	2950-4
I	on	constraint	8I	2950-4
8I		sequential	u	2950-4
u	≡	sequential	I	2950-4
I	v	action	iff	2950-4
iff		sequential	there	2950-4
there	exists	action	an k k k	2950-4
k Exercises Exercise 16.6		sequential	k Exercises Exercise 16.6	2951-1
k k		sequential	k k	2952-1
k		sequential	k	2953-1
Exercise		sequential	16.8	2954-1
<B>	n	conjunctive	k	2955-1
there	is	attribute	a CALC query q	2956-1
a CALC query q	with	constraint	no constants	2956-1
no constants		sequential	q	2956-1
q		sequential	I	2956-1
I	=	sequential	J iff	2956-1
J iff	for	constraint	each automorphism ρ	2956-1
each automorphism ρ	of	constraint	I	2956-1
I		sequential	ρ	2956-1
ρ		sequential	J	2956-1
J	=	sequential	J	2956-1
<B>	Sizing Up	action	Languages	2957-1
Languages		sequential	Exercise 16.12	2957-1
Exercise		sequential	16.13	2958-1
Exercise		sequential	16.14	2959-1
I	get	action	it	2960-1
it		sequential	we	2960-1
we	now ’ ll match	action	languages	2960-1
languages	to	constraint	complexity classes	2960-1
Sergio		sequential	Sergio	2961-1
Riccardo		sequential	Riccardo	2962-1
Vittorio		sequential	Vittorio	2963-1
<B>	In	constraint	Chapter 16	2964-1
Chapter 16		sequential	we	2964-1
we	laid	action	the framework	2964-1
the framework	for	constraint	the expressiveness	2964-1
the framework	studying	action	the expressiveness	2964-1
the expressiveness	and	conjunctive	complexity	2964-1
complexity	of	constraint	query languages	2964-1
<B>	In	constraint	this chapter	2964-2
this chapter		sequential	we	2964-2
we	evaluate	action	three	2964-2
three	of	constraint	the most important classes	2964-2
the most important classes	of	constraint	languages	2964-2
languages	discussed so far	action	CALC	2964-2
CALC		sequential	fixpoint	2964-2
fixpoint	while	constraint	respect	2964-2
fixpoint	with	constraint	respect	2964-2
fixpoint	and	conjunctive	respect	2964-2
respect	to	constraint	expressiveness	2964-2
expressiveness	and	conjunctive	complexity	2964-2
We	that	constraint	CALC	2964-3
We	show	action	CALC	2964-3
CALC	in	constraint	logspace	2964-3
CALC	is	attribute	logspace	2964-3
logspace	and	conjunctive	that fixpoint	2964-3
that fixpoint	in	constraint	ptime	2964-3
that fixpoint	is	attribute	complete	2964-3
ptime	while	constraint	pspace	2964-3
ptime	in	constraint	pspace	2964-3
ptime	and	conjunctive	pspace	2964-3
ptime	is	attribute	complete	2964-3
We	that	constraint	CALC	2965-1
We	first show	action	CALC	2965-1
CALC	in	constraint	logspace	2965-1
CALC	can be evaluated	action	logspace	2965-1
This complexity result	partly explains	action	the success	2965-2
the success	of	constraint	relational database systems	2965-2
relational database systems		sequential	Relational queries	2965-2
Relational queries	can be evaluated efficiently	action	<B>	2965-2
it	that	constraint	these queries	2965-3
it	Furthermore implies	action	these queries	2965-3
these queries	within	constraint	nc	2965-3
these queries	are	attribute	nc	2965-3
nc	that	constraint	they	2965-3
nc	and	conjunctive	they	2965-3
they	thus have	action	a high potential	2965-3
a high potential	of	constraint	intrinsic parallelism	2965-3
intrinsic parallelism	in	constraint	actual systems	2965-3
intrinsic parallelism	not yet fully exploited	action	actual systems	2965-3
We	that	constraint	CALC queries	2965-4
We	prove	action	CALC queries	2965-4
CALC queries	in	constraint	constant time	2965-4
CALC queries	can be evaluated	action	constant time	2965-4
constant time	in	constraint	standard	2965-4
standard		sequential	a particular model	2965-4
a particular model	of	constraint	parallel computation	2965-4
parallel computation	on	constraint	circuits	2965-4
parallel computation	based	action	circuits	2965-4
<B>	While	constraint	the expressive power	2966-1
<B>	at	constraint	the expressive power	2966-1
<B>	looking	action	the expressive power	2966-1
the expressive power	of	constraint	CALC	2966-1
CALC	and	conjunctive	the other two languages	2966-1
the other two languages		sequential	we	2966-1
we	study	action	their limitations	2966-1
their limitations	by	constraint	queries	2966-1
their limitations	examining	action	queries	2966-1
queries		sequential	that	2966-1
that	in	constraint	these languages	2966-1
that	can not be expressed	action	these languages	2966-1
<B>	leads	action	us	2967-1
us	to	constraint	important tools	2967-1
us	introduce	action	important tools	2967-1
important tools		sequential	that	2967-1
that	in	constraint	the expressive power	2967-1
that	are	attribute	useful	2967-1
that	investigating	action	the expressive power	2967-1
the expressive power	of	constraint	query languages	2967-1
We	first present	action	an elegant characterization	2967-2
an elegant characterization	of	constraint	CALC	2967-2
CALC	on	constraint	Ehrenfeucht	2967-2
CALC	based	action	Ehrenfeucht	2967-2
Ehrenfeucht		sequential	Fraissé	2967-2
Fraissé		sequential	games	2967-2
<B>	to	constraint	limitations	2967-3
<B>	is used	action	limitations	2967-3
<B>	show	action	limitations	2967-3
limitations	in	constraint	the expressive power	2967-3
the expressive power	of	constraint	CALC	2967-3
CALC		sequential	the nonexpressibility	2967-3
the nonexpressibility	of	constraint	the transitive closure query	2967-3
the transitive closure query	on	constraint	a graph	2967-3
A second tool	to	constraint	expressiveness	2967-4
expressiveness		sequential	which	2967-4
which	to	constraint	all languages	2967-4
which	applies	action	all languages	2967-4
all languages	in	constraint	this chapter	2967-4
all languages	discussed	action	this chapter	2967-4
this chapter	of	constraint	1	2967-4
this chapter	-	sequential	1	2967-4
this chapter	consists	action	1	2967-4
this chapter	proving	action	1	2967-4
1		sequential	0 laws	2967-4
0 laws	for	constraint	languages	2967-4
This powerful approach	on	constraint	probabilities	2967-5
This powerful approach	based	action	probabilities	2967-5
probabilities	allows	action	us	2967-5
us	to	constraint	certain queries	2967-5
us	that	constraint	certain queries	2967-5
us	show	action	certain queries	2967-5
certain queries	in	constraint	while	2967-5
certain queries	are	attribute	not expressible	2967-5
while	in	constraint	thus not fixpoint	2967-5
while	and	conjunctive	thus not fixpoint	2967-5
thus not fixpoint	or	conjunctive	CALC	2967-5
First Order		sequential	Fixpoint	2968-1
Fixpoint	and	conjunctive	an ordering	2968-1
an ordering	of	constraint	the constants	2968-1
<B>	For	constraint	instance	2968-2
instance		sequential	the query	2968-2
the query	in	constraint	while	2968-2
the query	is	attribute	even easily expressible	2968-2
while	if	constraint	an order	2968-2
an order	is provided	action	<B>	2968-2
This chapter	with	constraint	two recent developments	2969-1
This chapter	concludes	action	two recent developments	2969-1
two recent developments		sequential	that	2969-1
that	shed	action	further light	2969-1
further light	on	constraint	the interplay	2969-1
the interplay	of	constraint	order	2969-1
order	and	conjunctive	expressiveness	2969-1
<B>	shows	action	that	2969-2
that		sequential	a while query	2969-2
a while query	on	constraint	an unordered database	2969-2
an unordered database	to	constraint	a while query	2969-2
an unordered database	can be reduced	action	a while query	2969-2
a while query	on	constraint	an ordered database	2969-2
an ordered database	via	constraint	a fixpoint query	2969-2
The fixpoint query	produces	action	an ordered database	2969-3
an ordered database	from	constraint	a given unordered one	2969-3
a given unordered one	by	constraint	tuples	2969-3
a given unordered one	grouping	action	tuples	2969-3
tuples	into	constraint	a sequence	2969-3
a sequence	of	constraint	blocks	2969-3
blocks		sequential	that	2969-3
that	in	constraint	the computation	2969-3
that	are never split	action	the computation	2969-3
the computation	of	constraint	the while query	2969-3
the while query		sequential	the blocks	2969-3
the blocks	of	constraint	elements	2969-3
the blocks	as	constraint	elements	2969-3
the blocks	can be thought	action	elements	2969-3
elements	of	constraint	an ordered database	2969-3
<B>	also allows	action	us	2969-4
us	to	constraint	the connection	2969-4
us	clarify	action	the connection	2969-4
the connection	between	constraint	fixpoint	2969-4
fixpoint	and	conjunctive	while	2969-4
The second recent development	considers	action	nondeterminism	2970-1
nondeterminism	as	constraint	a means	2970-1
a means	for	constraint	limitations	2970-1
a means	overcoming	action	limitations	2970-1
limitations	due to	constraint	the absence	2970-1
the absence	of	constraint	ordering	2970-1
ordering	of	constraint	the domain	2970-1
Several nondeterministic extensions	of	constraint	CALC	2970-2
CALC		sequential	fixpoint	2970-2
fixpoint	and	conjunctive	while	2970-2
while	are shown	action	<B>	2970-2
The impact	of	constraint	order	2971-1
order	is	attribute	a constant theme	2971-1
a constant theme	throughout	constraint	the discussion	2971-1
the discussion	of	constraint	expressive power	2971-1
Complexity	of	constraint	First Order	2972-1
First Order		sequential	Queries	2972-1
This result	is	attribute	particularly significant	2972-2
This result	given	action	its implications	2972-2
its implications	about	constraint	the parallel complexity	2972-2
the parallel complexity	of	constraint	CALC	2972-2
CALC	of	constraint	thus relational languages	2972-2
CALC	and	conjunctive	thus relational languages	2972-2
thus relational languages	in	constraint	<B>	2972-2
<B>		sequential	logspace	2972-3
logspace		sequential	⊆ nc	2972-3
We	by	constraint	the connection	2973-1
We	begin	action	the connection	2973-1
We	showing	action	the connection	2973-1
the connection	between	constraint	CALC	2973-1
CALC	and	conjunctive	qlogspace	2973-1
Theorem		sequential	17.1.1	2974-1
17.1.1		sequential	CALC	2974-1
CALC	in	constraint	qlogspace	2974-1
CALC	is included	action	qlogspace	2974-1
Proof	Let	action	ϕ	2975-1
ϕ	be	attribute	a query	2975-1
a query	in	constraint	CALC	2975-1
CALC	over	constraint	some database schema R	2975-1
<B>	that	constraint	Mϕ	2976-1
<B>	Suppose	action	Mϕ	2976-1
Mϕ	with	constraint	input enc α	2976-1
Mϕ	is started	action	input enc α	2976-1
input enc α		sequential	I	2976-1
I		sequential	# enc α	2976-1
# enc α		sequential	u	2976-1
u	for	constraint	some instance	2976-1
some instance		sequential	I	2976-1
I	over	constraint	R	2976-1
R		sequential	some enumeration	2976-1
some enumeration		sequential	α	2976-1
α	of	constraint	the constants	2976-1
the constants	and	conjunctive	some tuple u	2976-1
some tuple u	over	constraint	adom	2976-1
adom		sequential	I	2976-1
I		sequential	whose arity	2976-1
whose arity	as	constraint	the result of	2976-1
whose arity	of	constraint	the result of	2976-1
whose arity	is	attribute	the same	2976-1
We	assume	action	w.l.o.g	2976-2
<B>	that	constraint	prenex normal form	2977-1
<B>	in	constraint	prenex normal form	2977-1
<B>	is	attribute	prenex normal form	2977-1
We	by	constraint	induction	2977-2
We	show	action	induction	2977-2
induction	on	constraint	the number	2977-2
the number	of	constraint	quantifiers	2977-2
quantifiers	of	constraint	the computation	2977-2
quantifiers	that	constraint	the computation	2977-2
the computation	can be performed	action	k log	2977-2
the computation	using	action	k log	2977-2
k log		sequential	α	2977-2
α		sequential	I	2977-2
I		sequential	# enc α	2977-2
# enc α		sequential	u	2977-2
u		sequential	enc cells	2977-2
enc cells	of	constraint	the work tape	2977-2
the work tape	for	constraint	some constant k	2977-2
Basis		sequential	Basis	2978-1
<B>	If	constraint	ϕ	2978-2
ϕ	has	action	no quantifiers	2978-2
no quantifiers		sequential	all the variables	2978-2
all the variables	of	constraint	ϕ	2978-2
ϕ	are	attribute	free	2978-2
<B>	ν	constraint	the valuation	2978-3
<B>	be	attribute	the valuation	2978-3
<B>	Let	action	the valuation	2978-3
the valuation	mapping	action	the free variables	2978-3
the free variables	of	constraint	u	2978-3
the free variables	to	constraint	u	2978-3
the free variables	ϕ	sequential	u	2978-3
<B>	To	constraint	the truth value	2978-4
<B>	determine	action	the truth value	2978-4
the truth value	of	constraint	each literal L	2978-4
each literal L	under	constraint	ν	2978-4
ν	in	constraint	one	2978-4
ν	occurring	action	one	2978-4
one	needs	action	the input tape	2978-4
one	only scan	action	the input tape	2978-4
the input tape	for	constraint	ν	2978-4
the input tape	looking	action	ν	2978-4
ν		sequential	L	2978-4
<B>	by	constraint	each tuple	2978-5
<B>	can be accomplished	action	each tuple	2978-5
<B>	considering	action	each tuple	2978-5
each tuple	of	constraint	I	2978-5
I	in	constraint	turn	2978-5
turn	comparing	action	it	2978-5
it	with	constraint	relevant portions	2978-5
relevant portions	of	constraint	u	2978-5
<B>	For	constraint	each such tuple	2978-6
each such tuple		sequential	the address	2978-6
the address	of	constraint	the beginning	2978-6
the beginning	of	constraint	the tuple	2978-6
the tuple	on	constraint	the tape	2978-6
the tuple	should be stored	action	the tape	2978-6
the tape	along	constraint	the offset	2978-6
the tape	with	constraint	the offset	2978-6
the offset	to	constraint	the current location	2978-6
the current location	of	constraint	the tuple	2978-6
the tuple	being scanned	action	<B>	2978-6
<B>	within	constraint	logarithmic space	2978-7
<B>	can be accomplished	action	logarithmic space	2978-7
Induction		sequential	Induction	2979-1
<B>	that	constraint	each prenex normal form CALC formula	2979-2
<B>	Now suppose	action	each prenex normal form CALC formula	2979-2
each prenex normal form CALC formula	with	constraint	quantifiers	2979-2
each prenex normal form CALC formula	than	constraint	quantifiers	2979-2
each prenex normal form CALC formula	n	conjunctive	quantifiers	2979-2
quantifiers	in	constraint	logspace	2979-2
quantifiers	can be evaluated	action	logspace	2979-2
logspace	and	conjunctive	ϕ	2979-2
logspace	let	action	ϕ	2979-2
ϕ	be	attribute	a prenex normal form formula	2979-2
a prenex normal form formula	with	constraint	quantifiers	2979-2
a prenex normal form formula	n	conjunctive	quantifiers	2979-2
<B>	of	constraint	the form ∃x ψ	2979-3
<B>	is	attribute	the form ∃x ψ	2979-3
<B>	Suppose	action	the form ∃x ψ	2979-3
The case		sequential	ϕ	2979-4
ϕ	of	constraint	when the form	2979-4
ϕ	is	attribute	when the form	2979-4
when the form		sequential	∀x	2979-4
∀x		sequential	ψ	2979-4
ψ	is	attribute	similar	2979-4
<B>	Because	constraint	nc	2980-1
nc	than	constraint	the length	2980-1
nc	is	attribute	less	2980-1
the length	of	constraint	the input	2980-1
the input		sequential	the number	2980-1
the number	of	constraint	cells	2980-1
cells	than	constraint	log	2980-1
cells	needed	attribute	no more	2980-1
cells	is	attribute	no more	2980-1
log		sequential	enc	2980-1
enc		sequential	α	2980-1
α		sequential	I	2980-1
I		sequential	# enc α	2980-1
# enc α		sequential	u	2980-1
The problem	to	constraint	ψ	2980-2
The problem	is now reduced	action	ψ	2980-2
The problem	evaluating	action	ψ	2980-2
ψ	for	constraint	each value	2980-2
each value	of	constraint	x	2980-2
<B>	By	constraint	the induction hypothesis	2981-1
the induction hypothesis	can be done	action	k log	2981-1
the induction hypothesis	using	action	k log	2981-1
k log		sequential	enc	2981-1
enc		sequential	α	2981-1
α		sequential	I	2981-1
I		sequential	# enc α	2981-1
# enc α		sequential	u	2981-1
u	work	action	tape cells	2981-1
tape cells	for	constraint	some k	2981-1
CALC	of	constraint	qlogspace	2982-1
CALC	Unfortunately does not express	attribute	all	2982-1
It	in	constraint	Section 17.3	2982-2
It	will be shown	action	Section 17.3	2982-2
Section 17.3		sequential	that	2982-2
that	although	constraint	clearly qlogspace	2982-2
that	in	constraint	clearly qlogspace	2982-2
clearly qlogspace	is	attribute	first order	2982-2
first order		sequential	not a query	2982-2
We	next consider informally	action	the parallel complexity	2983-1
the parallel complexity	of	constraint	CALC	2983-1
We	with	constraint	two parallel complexity classes	2983-2
We	are	attribute	concerned	2983-2
two parallel complexity classes		sequential	nc	2983-2
nc	and	conjunctive	<B>	2983-2
nc	is	attribute	Intuitively the class	2983-3
Intuitively the class	of	constraint	problems	2983-3
problems		sequential	that	2983-3
that	can be solved	action	polynomially many processors	2983-3
that	using	action	polynomially many processors	2983-3
polynomially many processors	in	constraint	time polynomial	2983-3
time polynomial	in	constraint	the logarithm	2983-3
the logarithm	of	constraint	the input size	2983-3
the input size		sequential	ac0	2983-3
ac0	also allows	action	polynomially many processors	2983-3
polynomially many processors	but	conjunctive	only constant time	2983-3
The formal definitions	of	constraint	nc	2983-4
nc	and	conjunctive	ac0	2983-4
ac0	on	constraint	a circuit model	2983-4
ac0	are based	action	a circuit model	2983-4
a circuit model	in	constraint	which	2983-4
which		sequential	time	2983-4
time	to	constraint	the depth	2983-4
time	corresponds	action	the depth	2983-4
the depth	of	constraint	the circuit	2983-4
the circuit	and	conjunctive	the number	2983-4
the number	of	constraint	gates	2983-4
gates	to	constraint	its size	2983-4
gates	corresponds	action	its size	2983-4
The circuits	and	conjunctive	not gates	2983-5
The circuits	or	conjunctive	not gates	2983-5
The circuits	and	conjunctive	not gates	2983-5
The circuits	use	action	not gates	2983-5
not gates	and	conjunctive	unbounded fan in.2	2983-5
not gates	have	action	unbounded fan in.2	2983-5
The fact	that	constraint	the complexity	2984-1
the complexity	of	constraint	CALC	2984-1
CALC	is	attribute	logspace	2984-1
logspace	that	constraint	its parallel complexity	2984-1
logspace	implies	action	its parallel complexity	2984-1
its parallel complexity	is	attribute	nc	2984-1
nc	because	constraint	it	2984-1
it	that	constraint	logspace ⊆ nc	2984-1
it	is well known	action	logspace ⊆ nc	2984-1
one	However can prove	action	a tighter result	2984-2
a tighter result		sequential	which	2984-2
which	that	constraint	the parallel complexity	2984-2
which	says	action	the parallel complexity	2984-2
the parallel complexity	of	constraint	CALC	2984-2
CALC	in	constraint	fact	2984-2
CALC	is	attribute	fact	2984-2
fact		sequential	ac0	2984-2
only constant time	to	constraint	CALC queries	2984-3
only constant time	So is needed	action	CALC queries	2984-3
only constant time	evaluate	action	CALC queries	2984-3
<B>	than	constraint	any other known complexity result	2984-4
any other known complexity result	on	constraint	CALC	2984-4
CALC	captures	action	the fundamental intuition	2984-4
the fundamental intuition		sequential	that	2984-4
that		sequential	first order	2984-4
first order		sequential	queries	2984-4
queries	in	constraint	2	2984-4
queries	can be evaluated	action	2	2984-4
First Order		sequential	Fixpoint	2985-1
Fixpoint	While	constraint	they	2985-1
Fixpoint	that	constraint	they	2985-1
Fixpoint	and	conjunctive	they	2985-1
Fixpoint	and	conjunctive	they	2985-1
they	in	constraint	some sense	2985-1
they	represent	action	some sense	2985-1
some sense		sequential	primitive manipulations	2985-1
primitive manipulations	of	constraint	relations	2985-1
We	sketch	action	only the proof	2986-1
only the proof	and	conjunctive	the details	2986-1
only the proof	leave	action	the details	2986-1
the details	for	constraint	Exercise 17.2	2986-1
Theorem		sequential	17.1.2	2987-1
Crux		sequential	Crux	2988-1
We	will use	action	the relational algebra	2988-2
We	that	constraint	the operations	2988-3
We	of	constraint	the operations	2988-3
We	will argue	attribute	each	2988-3
the operations		sequential	π	2988-3
π		sequential	σ	2988-3
σ		sequential	×	2988-3
×		sequential	−	2988-3
−		sequential	∪	2988-3
∪	in	constraint	constant parallel time	2988-3
∪	can be performed	action	constant parallel time	2988-3
constant parallel time	using	action	only polynomially many processors	2988-3
<B>	Let	action	e	2989-1
e	be	attribute	an expression	2989-1
an expression	in	constraint	the algebra	2989-1
the algebra	over	constraint	some database schema	2989-1
some database schema		sequential	R.	2989-1
R.	Consider	action	the following infinite space	2989-1
the following infinite space	of	constraint	processors	2989-1
There	is	attribute	one processor	2989-2
one processor	for	constraint	each pair f	2989-2
each pair f		sequential	u	2989-2
u		sequential	f	2989-2
f	is	attribute	where a subexpression	2989-2
where a subexpression	of	constraint	e	2989-2
e	and	conjunctive	u	2989-2
u	is	attribute	a tuple	2989-2
a tuple	of	constraint	the same arity	2989-2
the same arity	as	constraint	the result	2989-2
the result	of	constraint	f	2989-2
f	using	action	constants	2989-2
constants	from	constraint	dom	2989-2
<B>	Let	action	us	2989-3
us	denote	action	one such processor	2989-3
one such processor	by	constraint	pf	2989-3
pf		sequential	u	2989-3
<B>	that	constraint	each relation name Q	2989-4
<B>	in	constraint	each relation name Q	2989-4
<B>	for	constraint	each relation name Q	2989-4
<B>	Note	attribute	particular	2989-4
each relation name Q	in	constraint	f	2989-4
each relation name Q	occurring	action	f	2989-4
f	and	conjunctive	each u	2989-4
each u	of	constraint	the arity	2989-4
the arity	of	constraint	Q	2989-4
Q		sequential	pQ	2989-4
pQ		sequential	u	2989-4
u	is	attribute	one	2989-4
one	of	constraint	the processors	2989-4
Each processor	has	action	two possible states	2990-1
two possible states	whether	constraint	u	2990-1
two possible states	or	conjunctive	u	2990-1
two possible states	indicating	action	u	2990-1
u	in	constraint	the result	2990-1
u	is	attribute	the result	2990-1
the result	of	constraint	f	2990-1
It	to	constraint	each algebra operation	2991-1
It	that	constraint	each algebra operation	2991-1
It	remains	action	each algebra operation	2991-1
It	show	action	each algebra operation	2991-1
each algebra operation	takes	action	constant time	2991-1
<B>	for	constraint	instance	2991-2
<B>	Consider	action	instance	2991-2
instance	cross	action	product	2991-2
<B>	f	constraint	× g	2991-3
<B>	Suppose	action	× g	2991-3
× g	is	attribute	a subexpression	2991-3
a subexpression	of	constraint	e	2991-3
Processor p		sequential	f	2991-4
f		sequential	×g	2991-4
×g		sequential	uv	2991-4
uv	to	constraint	two true messages	2991-4
uv	goes	attribute	true	2991-4
uv	state	attribute	true	2991-4
uv	when receiving	action	two true messages	2991-4
The other operations	are	attribute	similar	2991-5
e	in	constraint	constant time	2991-6
e	Thus is evaluated	action	constant time	2991-6
constant time	in	constraint	our informal model	2991-6
our informal model	of	constraint	parallel computation	2991-6
<B>	To	constraint	the foregoing intuition	2992-1
<B>	formalize	action	the foregoing intuition	2992-1
the foregoing intuition	using	action	the circuit model	2992-1
the circuit model		sequential	one	2992-1
one	for	constraint	each n	2992-1
one	must construct	action	each n	2992-1
each n		sequential	a circuit	2992-1
The idea	for	constraint	the circuit	2992-2
The idea	constructing	action	the circuit	2992-2
the circuit	to	constraint	the informal construction	2992-2
the circuit	is	attribute	similar	2992-2
the informal construction	in	constraint	the previous paragraph	2992-2
the previous paragraph	except	constraint	processors	2992-2
the previous paragraph	that	constraint	processors	2992-2
processors	by	constraint	wires	2992-2
processors	are replaced	action	wires	2992-2
wires		sequential	edges	2992-2
edges	in	constraint	the graph	2992-2
the graph	representing	action	the circuit	2992-2
the circuit		sequential	that	2992-2
that	either	conjunctive	the value 1	2992-2
that	carry	action	the value 1	2992-2
the value 1	or	conjunctive	0	2992-2
<B>		sequential	<B>	2992-3
only wires		sequential	that	2992-4
that	for	constraint	some input	2992-4
that	can become	attribute	active	2992-4
some input	Thus are included	action	<B>	2992-4
Figure		sequential	17.1	2992-5
17.1	represents	action	fragments	2992-5
fragments	of	constraint	circuits	2992-5
circuits	computing	action	some relational operations	2992-5
<B>	In	constraint	the figure	2992-6
the figure		sequential	f	2992-6
f	is	attribute	the cross product	2992-6
the cross product	of	constraint	g	2992-6
g	and	conjunctive	h	2992-6
h		sequential	g	2992-6
g		sequential	×	2992-6
×		sequential	h	2992-6
h	f	constraint	the difference g	2992-6
h	is	attribute	the difference g	2992-6
the difference g		sequential	h	2992-6
h	f	constraint	′′	2992-6
h	and	conjunctive	′′	2992-6
′′	is	attribute	the projection	2992-6
the projection	of	constraint	h	2992-6
h	on	constraint	the first coordinate	2992-6
<B>	that	constraint	projection	2992-7
<B>	Observe	action	projection	2992-7
projection	is	attribute	the most tricky operation	2992-7
<B>	In	constraint	the figure	2992-8
the figure		sequential	it	2992-8
it	that	constraint	the active domain	2992-8
it	is assumed	action	the active domain	2992-8
the active domain	of	constraint	four constants	2992-8
the active domain	consists	action	four constants	2992-8
<B>	that	constraint	projection	2992-9
<B>	because of	constraint	projection	2992-9
<B>	Note also	action	projection	2992-9
projection		sequential	the circuits	2992-9
the circuits	have	action	fan	2992-9
fan		sequential	unbounded in	2992-9
We	leave	action	the details	2993-1
the details	of	constraint	the construction	2993-1
the construction	of	constraint	the circuits	2993-1
<B>	In	constraint	one	2993-2
<B>	that	constraint	one	2993-2
<B>	note	action	one	2993-2
one	must use	action	a slightly more cumbersome encoding	2993-2
a slightly more cumbersome encoding	than	constraint	Turing machines	2993-2
a slightly more cumbersome encoding	for	constraint	Turing machines	2993-2
a slightly more cumbersome encoding	used	action	Turing machines	2993-2
Turing machines	because	constraint	the alphabet	2993-2
the alphabet	to	constraint	0	2993-2
the alphabet	{	sequential	0	2993-2
the alphabet	is now restricted	action	0	2993-2
0		sequential	1 }	2993-2
<B>	or	conjunctive	not Figure	2994-1
not Figure		sequential	17.1	2994-1
17.1		sequential	Some fragments	2994-1
Some fragments	of	constraint	circuits	2994-1
It	that	constraint	there	2994-2
It	turns out	action	there	2994-2
there	are	attribute	queries	2994-2
queries	in	constraint	ac0	2994-2
ac0		sequential	that	2994-2
that	are	attribute	not first order	2994-2
<B>	in	constraint	Section 17.4	2994-3
<B>	is demonstrated	action	Section 17.4	2994-3
Expressiveness	of	constraint	First Order	2995-1
First Order		sequential	Queries	2995-1
there	However is	action	a price	2996-1
a price	to	constraint	terms	2996-1
a price	for	constraint	terms	2996-1
a price	in	constraint	terms	2996-1
a price	pay	attribute	this	2996-1
terms	of	constraint	expressiveness	2996-1
Typical examples	of	constraint	such queries	2996-2
such queries	and	conjunctive	closure	2996-2
such queries	are	attribute	transitive	2996-2
closure	of	constraint	a graph	2996-2
This section	presents	action	an elegant technique	2996-3
an elegant technique	on	constraint	two player	2996-3
an elegant technique	based	action	two player	2996-3
two player		sequential	a game	2996-3
a game		sequential	that	2996-3
that	to	constraint	certain queries	2996-3
that	that	constraint	certain queries	2996-3
that	can be used	action	certain queries	2996-3
that	prove	action	certain queries	2996-3
certain queries	and	conjunctive	closure	2996-3
certain queries	including	attribute	transitive	2996-3
closure	are	attribute	not first order	2996-3
<B>	Although	constraint	the game	2996-4
the game		sequential	we	2996-4
we	toward	constraint	order	2996-4
we	describe	attribute	first	2996-4
we	is geared	attribute	first	2996-4
order		sequential	queries	2996-4
queries		sequential	games	2996-4
games	provide	action	a general technique	2996-4
a general technique		sequential	that	2996-4
that	in	constraint	conjunction	2996-4
that	is used	action	conjunction	2996-4
conjunction	with	constraint	many other languages	2996-4
The connection	between	constraint	CALC sentences	2997-1
CALC sentences	and	conjunctive	games	2997-1
games	is	attribute	<B>	2997-1
games	the following	action	<B>	2997-1
<B>	as	constraint	an example	2998-1
<B>	Consider	action	an example	2998-1
an example		sequential	a CALC sentence	2998-1
a CALC sentence	of	constraint	the form	2998-1
One	can view	action	the sentence	2999-1
the sentence	as	constraint	a statement	2999-1
a statement	about	constraint	a game	2999-1
a game	with	constraint	two players	2999-1
two players		sequential	1	2999-1
1	and	conjunctive	2	2999-1
2		sequential	who	2999-1
who	in	constraint	values	2999-1
who	alternate	action	values	2999-1
who	picking	action	values	2999-1
values	for	constraint	x1	2999-1
x1		sequential	x2	2999-1
x2		sequential	x3	2999-1
The sentence	that	constraint	Player 2	2999-2
The sentence	says	action	Player 2	2999-2
Player 2	can always force	action	a choice	2999-2
a choice	of	constraint	values	2999-2
values		sequential	that	2999-2
that	makes	action	ψ true	2999-2
ψ true		sequential	x1	2999-2
x1		sequential	x2	2999-2
x2		sequential	x3	2999-2
<B>	In	constraint	other words	2999-3
other words		sequential	no matter	2999-3
no matter		sequential	which value	2999-3
which value		sequential	Player 1	2999-3
Player 1	for	constraint	x1	2999-3
Player 1	chooses	action	x1	2999-3
x1		sequential	Player 2	2999-3
Player 2	can pick	action	an x2	2999-3
an x2		sequential	that	2999-3
that		sequential	no matter	2999-3
no matter		sequential	which x3	2999-3
which x3	by	constraint	Player	2999-3
which x3	is chosen next	action	Player	2999-3
Player		sequential	1	2999-3
1		sequential	ψ	2999-3
ψ		sequential	x1	2999-3
x1		sequential	x2	2999-3
x2		sequential	x3	2999-3
x3	is	attribute	true	2999-3
The actual game		sequential	we	3000-1
we	use	action	Ehrenfeucht	3000-1
we	called	action	Ehrenfeucht	3000-1
Ehrenfeucht		sequential	Fraissé	3000-1
Fraissé		sequential	the game	3000-1
the game	on	constraint	a similar intuition	3000-1
the game	but	conjunctive	a similar intuition	3000-1
the game	is	attribute	slightly more involved	3000-1
the game	is based	action	a similar intuition	3000-1
It	on	constraint	two instances	3000-2
It	is played	action	two instances	3000-2
<B>	that	constraint	R	3000-3
<B>	Suppose	action	R	3000-3
R	is	attribute	a database schema	3000-3
<B>	Let	action	I	3000-4
I	and	conjunctive	J	3000-4
J	be	attribute	instances	3000-4
instances	over	constraint	R	3000-4
R	with	constraint	disjoint sets	3000-4
disjoint sets	of	constraint	constants	3000-4
<B>	Let	action	r	3000-5
r	be	attribute	First Order	3000-5
First Order		sequential	Fixpoint	3000-5
Fixpoint	While	constraint	R	3000-5
Fixpoint	and	conjunctive	R	3000-5
R		sequential	x	3000-5
x		sequential	y	3000-5
y		sequential	P	3000-5
P		sequential	x	3000-5
x		sequential	z	3000-5
z		sequential	Figure 17.2	3000-5
<B>	in	constraint	I	3001-1
<B>	Let	action	I	3001-1
<B>	be the ith constant picked	action	I	3001-1
I		sequential	bi	3001-1
bi	in	constraint	J	3001-1
The set	of	constraint	pairs	3001-2
pairs		sequential	a 1	3001-2
a 1		sequential	b1	3001-2
Duplicator	wins	action	the round	3002-1
the round		sequential	a 1	3002-1
a 1		sequential	b1	3002-1
<B>	.	sequential	<B>	3002-2
<B>	.	sequential	<B>	3002-3
ar		sequential	br	3002-4
br		sequential	iff	3002-4
iff		sequential	the mapping ai	3002-4
the mapping ai	→	sequential	bi	3002-4
bi	is	attribute	an isomorphism	3002-4
an isomorphism	of	constraint	the subinstances	3002-4
the subinstances		sequential	I/	3002-4
I/		sequential	a 1	3002-4
<B>	.	sequential	<B>	3002-5
<B>	.	sequential	<B>	3002-6
ar		sequential	}	3002-7
}	and	conjunctive	J/	3002-7
J/	{	sequential	b1	3002-7
<B>	.	sequential	<B>	3002-8
<B>	.	sequential	<B>	3002-9
br		sequential	}	3002-10
Duplicator	wins	action	the game	3003-1
the game	of	constraint	length	3003-1
length	with	constraint	I	3003-1
length	r associated	action	I	3003-1
I	and	conjunctive	J	3003-1
J	if	constraint	he	3003-1
he	or	conjunctive	she	3003-1
she	has	action	a winning strategy	3003-1
a winning strategy		sequential	Duplicator	3003-1
Duplicator	can always win r	action	any game	3003-1
any game	of	constraint	length	3003-1
length	on	constraint	I	3003-1
I	and	conjunctive	J	3003-1
J		sequential	no matter	3003-1
no matter		sequential	Spoiler	3003-1
Spoiler	how plays	action	<B>	3003-1
<B>	by	constraint	I	3003-2
<B>	is denoted	action	I	3003-2
I	≡r	action	J	3003-2
<B>	that	constraint	the relation	3003-3
<B>	Note	action	the relation	3003-3
the relation		sequential	≡r	3003-3
≡r	is	attribute	an equivalence relation	3003-3
an equivalence relation	on	constraint	instances	3003-3
instances	over	constraint	R	3003-3
R	see	action	Exercise 17.3	3003-3
<B>		sequential	the equivalence	3004-1
the equivalence		sequential	I	3004-1
I	≡r	action	J	3004-1
J	that	constraint	I	3004-1
J	says	action	I	3004-1
I	and	conjunctive	J	3004-1
J	by	constraint	just constants	3004-1
J	at	constraint	just constants	3004-1
J	can not be distinguished	action	just constants	3004-1
J	looking	action	just constants	3004-1
J	r	action	just constants	3004-1
just constants	at	constraint	a time	3004-1
a time	in	constraint	the two instances	3004-1
<B>	that	constraint	the quantifier depth	3004-2
<B>	Recall	action	the quantifier depth	3004-2
the quantifier depth	of	constraint	a CALC formula	3004-2
a CALC formula	is	attribute	the maximum number	3004-2
the maximum number	of	constraint	quantifiers	3004-2
quantifiers	in	constraint	a path	3004-2
a path	from	constraint	the root	3004-2
the root	to	constraint	a leaf	3004-2
a leaf	in	constraint	the representation	3004-2
the representation	of	constraint	the sentence	3004-2
the sentence	as	constraint	a tree	3004-2
The main result	of	constraint	Ehrenfeucht	3004-3
Ehrenfeucht		sequential	Fraissé	3004-3
Fraissé		sequential	games	3004-3
games	that	constraint	the ability	3004-3
games	is	attribute	the ability	3004-3
the ability	to	constraint	instances	3004-3
the ability	among	constraint	instances	3004-3
the ability	distinguish	action	instances	3004-3
instances	using	action	games	3004-3
games	of	constraint	length r	3004-3
length r	to	constraint	the ability	3004-3
length r	is	attribute	equivalent	3004-3
the ability	to	constraint	instances	3004-3
the ability	among	constraint	instances	3004-3
the ability	distinguish	action	instances	3004-3
instances	using	action	some CALC sentence	3004-3
some CALC sentence	of	constraint	quantifier depth r	3004-3
Example		sequential	17.2.1	3005-1
Its syntax tree	in	constraint	Fig	3005-2
Its syntax tree	is represented	action	Fig	3005-2
17.2		sequential	17.2	3005-3
The sentence	has	action	quantifier depth 2	3005-4
<B>	that	constraint	a sentence	3005-5
<B>	for	constraint	a sentence	3005-5
<B>	Note	action	a sentence	3005-5
a sentence	in	constraint	prenex normal form	3005-5
prenex normal form		sequential	the quantifier depth	3005-5
the quantifier depth	is	attribute	simply the number	3005-5
simply the number	of	constraint	quantifiers	3005-5
quantifiers	in	constraint	the formula	3005-5
The main result	of	constraint	Ehrenfeucht	3006-1
Ehrenfeucht		sequential	Fraissé	3006-1
Fraissé		sequential	games	3006-1
games	in	constraint	Theorem	3006-1
games	stated	action	Theorem	3006-1
Theorem		sequential	17.2.2	3006-1
17.2.2	that	constraint	I	3006-1
17.2.2	if	constraint	I	3006-1
17.2.2	is	attribute	I	3006-1
I	and	conjunctive	J	3006-1
J	are	attribute	two instances	3006-1
two instances		sequential	Duplicator	3006-1
Duplicator	has	action	a winning strategy	3006-1
a winning strategy	for	constraint	the game r	3006-1
the game r	of	constraint	length	3006-1
length	on	constraint	the two instances	3006-1
the two instances		sequential	I	3006-1
I	and	conjunctive	J	3006-1
J	by	constraint	any CALC sentence	3006-1
J	can not be distinguished	action	any CALC sentence	3006-1
any CALC sentence	of	constraint	quantifier depth	3006-1
<B>	if	constraint	two instances	3006-2
two instances	are	attribute	undistinguishable	3006-2
two instances	using	action	sentences	3006-2
sentences	of	constraint	quantifier depth r	3006-2
quantifier depth r		sequential	they	3006-2
they	with	constraint	respect	3006-2
they	are	attribute	Thus equivalent	3006-2
respect	to	constraint	≡r	3006-2
<B>	Although	constraint	less use	3006-3
<B>	of	constraint	less use	3006-3
<B>	is	attribute	less use	3006-3
less use	as	constraint	a tool	3006-3
a tool	for	constraint	expressibility results	3006-3
a tool	proving	action	expressibility results	3006-3
expressibility results	and	conjunctive	we	3006-3
we	leave	action	it	3006-3
it	as	constraint	<B>	3006-3
<B>	exercise	action	<B>	3006-4
The main idea	to	constraint	each equivalence class	3006-5
The main idea	that	constraint	each equivalence class	3006-5
The main idea	is	attribute	each equivalence class	3006-5
The main idea	show	action	each equivalence class	3006-5
each equivalence class	of	constraint	≡r	3006-5
≡r	by	constraint	a sentence quantifier depth	3006-5
≡r	is	attribute	definable	3006-5
a sentence quantifier depth	of	constraint	r	3006-5
r	see	action	Exercises 17.9	3006-5
Exercises 17.9	and	conjunctive	17.10	3006-5
Theorem		sequential	17.2.2	3007-1
Crux	that	constraint	I	3008-1
Crux	Suppose	action	I	3008-1
I	and	conjunctive	J	3008-1
J	for	constraint	some ϕ	3008-1
J	|=	sequential	some ϕ	3008-1
some ϕ	of	constraint	quantifier depth	3008-1
We	provide	action	only a sketch	3008-2
only a sketch	of	constraint	the proof	3008-2
the proof	in	constraint	an example	3008-2
<B>	Let	action	ϕ	3009-1
ϕ	be	attribute	the sentence ∀x1 ∃	3009-1
the sentence ∀x1 ∃		sequential	x2 ∀x3 ψ	3009-1
x2 ∀x3 ψ		sequential	x1	3009-1
x1		sequential	x2	3009-1
x2		sequential	x3	3009-1
x3		sequential	ψ	3009-1
ψ	where has	action	no quantifiers	3009-1
no quantifiers	and	conjunctive	I	3009-1
no quantifiers	let	action	I	3009-1
I	and	conjunctive	J	3009-1
J	be	attribute	two instances	3009-1
two instances		sequential	I	3009-1
I		sequential	J	3009-1
J		sequential	ϕ	3009-1
Then I		sequential	∀x1	3009-2
∀x1	∃	sequential	x2	3009-2
x2		sequential	∀x3	3009-2
∀x3		sequential	ψ	3009-2
ψ		sequential	x1	3009-2
x1		sequential	x2	3009-2
x2		sequential	x3	3009-2
x3	and	conjunctive	J	3009-2
J		sequential	∃x1	3009-2
∃x1	∀	sequential	x2 ∃x3 ¬ψ	3009-2
x2 ∃x3 ¬ψ		sequential	x1	3009-2
x1		sequential	x2	3009-2
x2		sequential	x3	3009-2
We	that	constraint	Spoiler	3010-1
We	will show	action	Spoiler	3010-1
Spoiler	can prevent	action	Duplicator	3010-1
Duplicator	from	constraint	the choice	3010-1
Duplicator	by	constraint	the choice	3010-1
Duplicator	winning	action	the choice	3010-1
Duplicator	forcing	action	the choice	3010-1
the choice	of	constraint	constants	3010-1
constants		sequential	a 1	3010-1
a 1		sequential	a 2	3010-1
a 2		sequential	a3	3010-1
a3	in	constraint	I	3010-1
I	and	conjunctive	b1	3010-1
b1		sequential	b2	3010-1
b2		sequential	b3	3010-1
b3	in	constraint	J	3010-1
J		sequential	that	3010-1
that		sequential	I	3010-1
I		sequential	ψ	3010-1
ψ		sequential	a 1	3010-1
a 1		sequential	a 2	3010-1
a 2		sequential	a 3	3010-1
a 3	and	conjunctive	J	3010-1
Spoiler	by	constraint	a constant b1	3011-1
Spoiler	starts	action	a constant b1	3011-1
Spoiler	picking	action	a constant b1	3011-1
a constant b1	in	constraint	J such	3011-1
J such		sequential	J	3011-1
J		sequential	∀ x2 ∃x3 ¬ψ b1	3011-1
∀ x2 ∃x3 ¬ψ b1		sequential	x2	3011-1
x2		sequential	x3	3011-1
Duplicator	by	constraint	a constant a1	3012-1
Duplicator	must respond	action	a constant a1	3012-1
Duplicator	picking	action	a constant a1	3012-1
a constant a1	in	constraint	I	3012-1
<B>	Due to	constraint	the universal quantification	3012-2
the universal quantification	in	constraint	I	3012-2
I		sequential	∃x2 ∀x3 ψ	3012-2
∃x2 ∀x3 ψ		sequential	a 1	3012-2
a 1		sequential	x2	3012-2
x2		sequential	x3	3012-2
x3	of	constraint	which	3012-2
which		sequential	a1	3012-2
a1	was picked	action	<B>	3012-2
Next Spoiler	picks	action	a constant a2	3012-3
a constant a2	in	constraint	I	3012-3
I	that	constraint	I	3012-3
I		sequential	∀x3 ψ	3012-3
∀x3 ψ		sequential	a 1	3012-3
a 1		sequential	a 2	3012-3
a 2		sequential	x3	3012-3
<B>	of	constraint	which constant b2	3013-1
which constant b2	in	constraint	J Duplicator	3013-1
J Duplicator	picks	action	J	3013-1
J		sequential	∃x3	3013-1
∃x3		sequential	¬ψ	3013-1
¬ψ		sequential	b1	3013-1
b1		sequential	b2	3013-1
b2		sequential	x3	3013-1
Spoiler	Finally picks	action	b3	3014-1
b3	in	constraint	J	3014-1
J		sequential	J	3014-1
J		sequential	¬ψ	3014-1
¬ψ		sequential	b1	3014-1
b1		sequential	b2	3014-1
b2		sequential	b3	3014-1
b3		sequential	Duplicator	3014-1
Duplicator	picks	attribute	some	3014-1
a 3	in	constraint	I	3014-1
I	and	conjunctive	I	3014-1
I	|=	sequential	ψ	3014-1
ψ		sequential	a 1	3014-1
a 1		sequential	a 2	3014-1
a 2	a	sequential	3	3014-1
First Order		sequential	Fixpoint	3015-1
Fixpoint	While	constraint	B B 1 b b	3015-1
Fixpoint	and	conjunctive	B B 1 b b	3015-1
B B 1 b b		sequential	b 2 B 2	3015-1
b 2 B 2		sequential	Figure 17.3	3015-1
Figure 17.3		sequential	Two undistinguishable graphs	3015-1
It	to	constraint	each r	3015-2
It	for	constraint	each r	3015-2
It	is	attribute	sufficient	3015-2
It	exhibit	action	each r	3015-2
each r		sequential	two instances	3015-2
<B>	In	constraint	the next proposition	3015-3
the next proposition		sequential	we	3015-3
we	illustrate	action	the use	3015-3
the use	of	constraint	this technique	3015-3
this technique	by	constraint	graph connectivity	3015-3
this technique	that	constraint	graph connectivity	3015-3
this technique	showing	action	graph connectivity	3015-3
graph connectivity	and	conjunctive	therefore transitive closure	3015-3
therefore transitive closure	in	constraint	CALC	3015-3
therefore transitive closure	is	attribute	not expressible	3015-3
Proposition		sequential	17.2.3	3016-1
the query conn	by	constraint	conn	3016-2
the query conn	defined	action	conn	3016-2
conn		sequential	I	3016-2
I	=	sequential	true iff	3016-2
true iff		sequential	I	3016-2
I	is	attribute	a connected graph	3016-2
a connected graph	in	constraint	CALC	3016-2
a connected graph	is	attribute	Then not expressible	3016-2
Crux	that	constraint	there	3017-1
Crux	Suppose	action	there	3017-1
there	is	attribute	a CALC sentence	3017-1
a CALC sentence	checking	action	graph connectivity	3017-1
<B>	Let	action	r	3017-2
r	be	attribute	the quantifier depth	3017-2
the quantifier depth	of	constraint	ϕ	3017-2
We	exhibit	action	a connected graph	3017-3
<B>	For	constraint	a sufficiently large n	3018-1
a sufficiently large n	on	constraint	only r	3018-1
a sufficiently large n	depending	action	only r	3018-1
only r	see	action	Exercise 17.5	3018-1
Exercise 17.5		sequential	the graph	3018-1
17.3		sequential	17.3	3018-2
We	outline	action	the winning strategy	3018-3
the winning strategy	for	constraint	Duplicator	3018-3
The main idea	is	attribute	simple	3018-4
<B>	In	constraint	Spoiler	3018-5
Spoiler	can not take	action	advantage	3018-5
advantage	of	constraint	the fact	3018-5
the fact	that	constraint	<B>	3018-5
<B>	For	constraint	example	3019-1
example	if	constraint	Spoiler	3019-1
Spoiler	picks	action	an element a1	3019-1
an element a1	in	constraint	Ir	3019-1
Ir		sequential	Duplicator	3019-1
Duplicator	picks	action	an arbitrary element b1	3019-1
an arbitrary element b1	in	constraint	B1	3019-1
an arbitrary element b1	say	action	B1	3019-1
<B>	if	constraint	Spoiler	3019-2
Spoiler	picks	action	an element b2	3019-2
an element b2	in	constraint	B2	3019-2
B2		sequential	Duplicator	3019-2
Duplicator	Now picks	action	an element	3019-2
an element		sequential	a 2	3019-2
a 2	in	constraint	Ir	3019-2
Ir	from	constraint	a 1	3019-2
<B>	if	constraint	Spoiler	3019-3
Spoiler	picks	action	a b3	3019-3
a b3	in	constraint	B1	3019-3
B1	to	constraint	b1	3019-3
b1		sequential	Duplicator	3019-3
Duplicator	Next picks	action	an element	3019-3
an element		sequential	a 3	3019-3
a 3	in	constraint	Ir	3019-3
Ir	to	constraint	a 1	3019-3
The graphs	that	constraint	r moves	3019-4
The graphs	for	constraint	r moves	3019-4
The graphs	are	attribute	sufficiently large	3019-4
The graphs	can proceed	action	r moves	3019-4
r moves	with	constraint	the resulting subgraphs isomorphic	3019-4
The full proof	requires	action	a complete case analysis	3019-5
a complete case analysis	on	constraint	the moves	3019-5
the moves		sequential	that	3019-5
that		sequential	Spoiler	3019-5
Spoiler	can make	action	<B>	3019-5
The preceding technique	to	constraint	many other properties	3020-1
The preceding technique	that	constraint	many other properties	3020-1
The preceding technique	can be used	action	many other properties	3020-1
The preceding technique	show	action	many other properties	3020-1
many other properties	in	constraint	CALC	3020-1
many other properties	are	attribute	not expressible	3020-1
CALC	for	constraint	instance	3020-1
instance		sequential	2 colorability	3020-1
2 colorability	of	constraint	graphs	3020-1
graphs	or	conjunctive	Eulerian graphs	3020-1
Eulerian graphs		sequential	graphs	3020-1
graphs	for	constraint	which	3020-1
which		sequential	there	3020-1
there	is	attribute	a cycle	3020-1
a cycle		sequential	that	3020-1
that	through	constraint	each edge	3020-1
that	passes exactly once	action	each edge	3020-1
each edge	see	action	Exercise 17.7	3020-1
Fixpoint	While	constraint	Queries	3021-1
Fixpoint	and	conjunctive	Queries	3021-1
<B>	In	constraint	this section	3021-2
this section		sequential	we	3021-2
we	discuss	action	the expressiveness	3021-2
the expressiveness	and	conjunctive	complexity	3021-2
complexity	of	constraint	the two main extensions	3021-2
the two main extensions	of	constraint	these languages	3021-2
these languages	with	constraint	recursion	3021-2
recursion		sequential	the fixpoint	3021-2
the fixpoint	while	constraint	queries	3021-2
the fixpoint	and	conjunctive	queries	3021-2
It	to	constraint	an upper bound	3022-1
It	is	attribute	relatively easy	3022-1
It	place	action	an upper bound	3022-1
an upper bound	on	constraint	the complexity	3022-1
the complexity	of	constraint	fixpoint	3022-1
fixpoint	while	constraint	queries	3022-1
fixpoint	and	conjunctive	queries	3022-1
<B>	that	constraint	the main distinction	3022-2
<B>	Recall	action	the main distinction	3022-2
the main distinction	between	constraint	languages	3022-2
languages	defining	action	fixpoint queries	3022-2
fixpoint queries	while	constraint	queries	3022-2
fixpoint queries	and	conjunctive	queries	3022-2
fixpoint queries	defining	action	queries	3022-2
queries	that	constraint	the second	3022-2
queries	and	conjunctive	the second	3022-2
queries	is	attribute	the first	3022-2
queries	are	attribute	inflationary	3022-2
the second	are	attribute	Chapter 14	3022-2
the second	see	action	Chapter 14	3022-2
It	that	constraint	fixpoint queries	3022-3
It	follows	action	fixpoint queries	3022-3
fixpoint queries	in	constraint	polynomial time	3022-3
fixpoint queries	can be implemented	action	polynomial time	3022-3
polynomial time	while	constraint	queries	3022-3
polynomial time	and	conjunctive	queries	3022-3
queries	in	constraint	polynomial space	3022-3
these bounds	as	constraint	<B>	3022-4
these bounds	are	attribute	Moreover tight	3022-4
these bounds	shown next	action	<B>	3022-4
Theorem		sequential	17.3.1	3023-1
Crux		sequential	Crux	3024-1
<B>	For	constraint	while	3024-2
while		sequential	inclusion	3024-2
inclusion	in	constraint	pspace	3024-2
pspace	follows similarly	action	Exercise 17.11	3024-2
pspace	see	action	Exercise 17.11	3024-2
The completeness	from	constraint	an important result	3024-3
The completeness	follows	action	an important result	3024-3
an important result		sequential	that	3024-3
that	in	constraint	Section 17.4	3024-3
that	will be shown	action	Section 17.4	3024-3
The result		sequential	Theorem	3024-4
Theorem		sequential	17.4.2	3024-4
17.4.2	that	constraint	an order	3024-4
17.4.2	if	constraint	an order	3024-4
17.4.2	states	action	an order	3024-4
an order	on	constraint	the constants	3024-4
the constants	of	constraint	the domain	3024-4
the domain	is	attribute	available	3024-4
fixpoint	expresses	action	exactly qptime	3024-4
exactly qptime	while	constraint	exactly qpspace	3024-4
exactly qptime	and	conjunctive	exactly qpspace	3024-4
exactly qptime	expresses	action	exactly qpspace	3024-4
The completeness	from	constraint	the fact	3025-1
The completeness	follows	action	the fact	3025-1
the fact	that	constraint	there	3025-1
there	exist	action	problems	3025-1
problems		sequential	that	3025-1
that	in	constraint	ptime	3025-1
that	are	attribute	complete	3025-1
ptime	and	conjunctive	problems	3025-1
problems		sequential	that	3025-1
that	in	constraint	pspace	3025-1
that	are	attribute	complete	3025-1
pspace	see	action	Exercise 17.11	3025-1
The Parity Query		sequential	The Parity Query	3026-1
First Order		sequential	Fixpoint	3027-1
Fixpoint	While	constraint	Proposition 17.3.2	3027-1
Fixpoint	and	conjunctive	Proposition 17.3.2	3027-1
Proof	Let	action	R	3028-1
R	be	attribute	a unary relation	3028-1
<B>	that	constraint	there	3028-2
<B>	Suppose	action	there	3028-2
there	exists	action	a while program	3028-2
a while program	w	constraint	that	3028-2
that	computes	action	the query	3028-2
the query	on	constraint	even input R.	3028-2
even input R.		sequential	We	3028-2
We	can assume	action	w.l.o.g.	3028-2
w.l.o.g.	that	constraint	R	3028-2
R	contains	action	a unary relation	3028-2
a unary relation	so that	constraint	input	3028-2
a unary relation	on	constraint	input	3028-2
a unary relation	ans	conjunctive	input	3028-2
input		sequential	I	3028-2
I	w	constraint	I	3028-2
I		sequential	ans	3028-2
ans	if	constraint	I|	3028-2
ans	=	sequential	I|	3028-2
I|	w	constraint	I	3028-2
I|	and	conjunctive	I	3028-2
I|	is	attribute	I	3028-2
I	= otherwise	sequential	I	3028-2
<B>	Let	action	R	3028-3
R	be	attribute	the schema	3028-3
the schema	of	constraint	R	3028-3
the schema	w	constraint	R	3028-3
R	so contains	action	R	3028-3
R	and	conjunctive	ans	3028-3
We	will reach	action	a contradiction	3028-4
a contradiction	by	constraint	the computation	3028-4
a contradiction	that	constraint	the computation	3028-4
a contradiction	showing	action	the computation	3028-4
the computation	of	constraint	a given input	3028-4
the computation	w	constraint	a given input	3028-4
the computation	on	constraint	a given input	3028-4
a given input	of	constraint	its size	3028-4
a given input	is	attribute	essentially independent	3028-4
<B>	for	constraint	the computations greater	3028-5
<B>	n	conjunctive	the computations greater	3028-5
the computations greater	of	constraint	all inputs	3028-5
the computations greater	w	constraint	all inputs	3028-5
the computations greater	on	constraint	all inputs	3028-5
all inputs	of	constraint	size	3028-5
size	than	constraint	some sense	3028-5
size	in	constraint	some sense	3028-5
size	n	conjunctive	some sense	3028-5
size	will	action	some sense	3028-5
some sense	be	attribute	identical	3028-5
<B>	contradicts	action	the fact	3028-6
the fact	that	constraint	ans	3028-6
ans	at	constraint	the end	3028-6
ans	be	attribute	should empty	3028-6
the end	of	constraint	some computations	3028-6
some computations	but	conjunctive	not others	3028-6
<B>	To	constraint	we	3029-1
<B>	show	attribute	this	3029-1
we	need	action	a short digression	3029-1
a short digression	to	constraint	computations	3029-1
computations	on	constraint	unary relations	3029-1
We	that	constraint	constants	3030-1
We	w	constraint	constants	3030-1
We	assume here	action	constants	3030-1
We	does not use	action	constants	3030-1
constants	but	conjunctive	the construction	3030-1
the construction	to	constraint	that case	3030-1
the construction	can be generalized	action	that case	3030-1
that case	see	action	Exercise 17.14	3030-1
<B>	Let	action	I	3030-2
I	be	attribute	an input instance	3030-2
an input instance	and	conjunctive	an integer	3030-2
an input instance	k	action	an integer	3030-2
We	consider	action	a partition	3030-3
a partition	of	constraint	the set	3030-3
the set	of	constraint	k tuples	3030-3
k tuples	with	constraint	entries	3030-3
entries	in	constraint	adom	3030-3
adom		sequential	I	3030-3
I	into	constraint	hyperplanes	3030-3
hyperplanes	on	constraint	patterns	3030-3
hyperplanes	based	action	patterns	3030-3
patterns	of	constraint	equalities	3030-3
equalities	and	conjunctive	inequalities	3030-3
inequalities	between	constraint	components	3030-3
components	as	constraint	<B>	3030-3
components	follows	action	<B>	3030-3
<B>	For	constraint	each equivalence relation	3030-4
each equivalence relation		sequential	H≃	3030-4
H≃		sequential	I	3030-4
I	=	sequential	u1	3030-4
I	{	sequential	u1	3030-4
<B>	.	sequential	<B>	3030-5
<B>	.	sequential	<B>	3030-6
uk	for	constraint	i	3030-7
i		sequential	j ∈	3030-7
j ∈		sequential	1	3030-7
1		sequential	k	3030-7
k		sequential	ui	3030-7
ui		sequential	uj ∈	3030-7
uj ∈		sequential	adom	3030-7
adom		sequential	I	3030-7
I	and	conjunctive	ui	3030-7
ui	=	sequential	uj ⇔	3030-7
uj ⇔		sequential	i	3030-7
i		sequential	≃ j	3030-7
<B>	For	constraint	instance	3031-1
instance	let	action	adom	3031-1
adom		sequential	I	3031-1
I	=	sequential	b	3031-1
b		sequential	c }	3031-1
c }		sequential	k	3031-1
k	=	sequential	3	3031-1
3	and	conjunctive	<B>	3031-1
H≃		sequential	I	3032-1
I	Then =	sequential	a	3032-1
a		sequential	a	3032-1
a		sequential	a	3032-1
a		sequential	c	3032-1
c		sequential	a	3032-1
a		sequential	b	3032-1
b		sequential	c	3032-1
c		sequential	c	3032-1
c		sequential	c	3032-1
c		sequential	c	3032-1
c		sequential	c	3032-1
c		sequential	b }	3032-1
there	Finally are	action	0 ary	3033-1
0 ary		sequential	two hyperplanes	3033-1
two hyperplanes	and	conjunctive	that	3033-1
two hyperplanes	denoted	attribute	true	3033-1
that	to	constraint	}	3033-1
that	evaluate	action	}	3033-1
}	and	conjunctive	}	3033-1
}	{	sequential	}	3033-1
}		sequential	<B>	3033-1
We	that	constraint	a while computation	3034-1
We	will see	action	a while computation	3034-1
a while computation	between	constraint	two k tuples	3034-1
a while computation	can not distinguish	action	two k tuples	3034-1
two k tuples	in	constraint	the same hyperplane	3034-1
the same hyperplane	and	conjunctive	intermediate relations	3034-1
intermediate relations	of	constraint	arity k	3034-1
arity k	of	constraint	a union	3034-1
arity k	so will always consist	action	a union	3034-1
a union	of	constraint	hyperplanes	3034-1
<B>	Now consider	action	the while program w	3035-1
We	label	action	the statements	3035-2
the statements	of	constraint	the program	3035-2
the program		sequential	we	3035-2
we	about	constraint	the program state	3035-2
we	so can talk	action	the program state	3035-2
the program state		sequential	the label	3035-2
the label	after	constraint	some number	3035-2
some number	of	constraint	computation steps	3035-2
computation steps	on	constraint	input I	3035-2
We	include	action	two labels	3035-3
two labels	in	constraint	a while statement	3035-3
a while statement	in	constraint	the following manner	3035-3
the following manner		sequential	label1	3035-3
label1	while	constraint	condition	3035-3
condition	do	action	label2 statement	3035-3
<B>	Let	action	N	3036-1
N	be	attribute	the maximum arity	3036-1
the maximum arity	of	constraint	any relation	3036-1
any relation	in	constraint	R	3036-1
<B>	for	constraint	each step m	3036-2
each step m		sequential	there	3036-2
there	Furthermore exists	action	a label jm	3036-2
a label jm	for	constraint	each relation	3036-2
a label jm	and	conjunctive	each relation	3036-2
each relation		sequential	T	3036-2
T	of	constraint	arity	3036-2
arity	k	action	a set ET	3036-2
a set ET		sequential	m	3036-2
m	of	constraint	equivalence relations	3036-2
equivalence relations	over	constraint	1	3036-2
equivalence relations	{	sequential	1	3036-2
<B>	.	sequential	<B>	3036-3
<B>	.	sequential	<B>	3036-4
k	that	constraint	each input	3036-5
k	for	constraint	each input	3036-5
each input		sequential	I	3036-5
I	of	constraint	size	3036-5
size	than	constraint	N	3036-5
<B>	To	constraint	the result	3037-1
<B>	that	constraint	the result	3037-1
<B>	see	attribute	this	3037-1
<B>	yields	action	the result	3037-1
the result	that	constraint	it	3037-1
the result	suppose	action	it	3037-1
it	is	attribute	true	3037-1
<B>	for	constraint	Then I	3037-2
Then I	with	constraint	size	3037-2
The claim	from	constraint	an inductive proof of	3038-1
The claim	follows	action	an inductive proof of	3038-1
It	that	constraint	the 0th step	3038-2
It	at	constraint	the 0th step	3038-2
It	is	attribute	clear	3038-2
It	holds	action	the 0th step	3038-2
<B>	At	constraint	the start	3038-3
the start	of	constraint	the computation	3038-3
the computation		sequential	all T	3038-3
all T	except	constraint	input	3038-3
all T	for	constraint	input	3038-3
all T	are	attribute	empty	3038-3
input		sequential	the unary relation R	3038-3
the unary relation R		sequential	which	3038-3
which	contains	action	all constants	3038-3
all constants	of	constraint	the hyperplane H≃	3038-3
all constants	and	conjunctive	the hyperplane H≃	3038-3
all constants	so consists where	action	the hyperplane H≃	3038-3
<B>	Let	action	k	3039-1
k	be	attribute	the arities	3039-1
the arities	of	constraint	Q1	3039-1
Q1		sequential	Q2	3039-1
Q2	for	constraint	EQ2	3039-1
Q2	in	constraint	EQ2	3039-1
Q2	and	conjunctive	EQ2	3039-1
Q2	≃ 2	sequential	EQ2	3039-1
EQ2		sequential	m−1	3039-1
m−1	let	action	<B>	3039-1
<B>	For	constraint	an arbitrary binary relation	3040-1
an arbitrary binary relation		sequential	⊆	3040-1
⊆		sequential	1	3040-1
1		sequential	k	3040-1
k	+	sequential	l	3040-1
l		sequential	1	3040-1
1		sequential	k	3040-1
k	+	sequential	l	3040-1
l	let	action	γ	3040-1
γ		sequential	∗	3040-1
∗	and	conjunctive	the closure	3040-1
∗	denote	attribute	reflexive	3040-1
the closure	of	constraint	γ	3040-1
<B>	For	constraint	1	3040-2
<B>	≃	sequential	1	3040-2
1		sequential	≃ 2	3040-2
≃ 2	in	constraint	EQ1	3040-2
EQ1		sequential	m−1	3040-2
m−1		sequential	EQ2	3040-2
EQ2		sequential	m−1	3040-2
m−1	set	action	First Order	3040-2
First Order		sequential	Fixpoint	3040-2
Fixpoint	and	conjunctive	<B>	3040-2
It	to	constraint	each pair	3041-1
It	that	constraint	each pair	3041-1
It	for	constraint	each pair	3041-1
It	is	attribute	straightforward	3041-1
It	verify	action	each pair	3041-1
each pair		sequential	1	3041-1
1	≃	sequential	2	3041-1
2	in	constraint	EQ1	3041-1
EQ1		sequential	m−1	3041-1
m−1		sequential	EQ2	3041-1
EQ2		sequential	m−1	3041-1
m−1	and	conjunctive	I	3041-1
I	with	constraint	size	3041-1
<B>	that	constraint	the assumption	3042-1
<B>	Note	attribute	this	3042-1
<B>	uses	action	the assumption	3042-1
the assumption	that	constraint	the size	3042-1
the size	of	constraint	I	3042-1
I	than	constraint	N	3042-1
I	is	attribute	greater	3042-1
N		sequential	the maximum arity	3042-1
the maximum arity	of	constraint	relations	3042-1
relations	in	constraint	<B>	3042-1
ET		sequential	m	3043-1
m	=	sequential	<B>	3043-1
<B>	for	constraint	T	3044-1
<B>	Thus 2 also holds	action	T	3044-1
T	at	constraint	step m	3044-1
step m	and	conjunctive	the induction	3044-1
the induction	is completed	action	<B>	3044-1
The hyperplane technique	in	constraint	the preceding proof	3045-1
The hyperplane technique	used	action	the preceding proof	3045-1
the preceding proof	on	constraint	the fact	3045-1
the preceding proof	is based	action	the fact	3045-1
the fact	that	constraint	the context	3045-1
the fact	in	constraint	the context	3045-1
the context	of	constraint	a unary relation input	3045-1
a unary relation input		sequential	there	3045-1
there	are	attribute	families	3045-1
families	of	constraint	tuples	3045-1
tuples	in	constraint	this case	3045-1
this case		sequential	the different hyperplanes	3045-1
the different hyperplanes		sequential	that	3045-1
that	that	constraint	the results	3045-1
that	and	conjunctive	the results	3045-1
that	and	conjunctive	the results	3045-1
that	travel together	attribute	intermediate	3045-1
the results	are	attribute	hence unions	3045-1
hence unions	of	constraint	these families	3045-1
these families	of	constraint	tuples	3045-1
<B>	Although	constraint	there	3045-2
there	are	attribute	other cases	3045-2
other cases	in	constraint	which	3045-2
which		sequential	the technique	3045-2
the technique	of	constraint	hyperplanes	3045-2
hyperplanes	can be applied	action	Exercise 17.15	3045-2
hyperplanes	see	action	Exercise 17.15	3045-2
Exercise 17.15	in	constraint	the general case	3045-2
the general case		sequential	the input	3045-2
the input	is	attribute	not a union	3045-2
not a union	of	constraint	hyperplanes	3045-2
hyperplanes	and	conjunctive	the members	3045-2
the members	of	constraint	a hyperplane	3045-2
a hyperplane	so do not travel together	action	<B>	3045-2
there	However is	action	a generalization	3045-3
a generalization	of	constraint	hyperplanes	3045-3
hyperplanes	on	constraint	automorphisms	3045-3
hyperplanes	based	action	automorphisms	3045-3
automorphisms		sequential	that	3045-3
that	yields	action	the same effect	3045-3
<B>	that	constraint	an automorphism	3045-4
<B>	Recall	action	an automorphism	3045-4
an automorphism	of	constraint	I	3045-4
I	is	attribute	one	3045-4
one	to	constraint	one	3045-4
one		sequential	a mapping ρ	3045-4
a mapping ρ	on	constraint	adom	3045-4
adom		sequential	I	3045-4
I	that	constraint	ρ I	3045-4
ρ I	=	sequential	I	3045-4
<B>	For	constraint	I	3045-5
<B>	fixed	action	I	3045-5
I	consider	action	the following equivalence relation	3045-5
the following equivalence relation		sequential	I	3045-5
I	on	constraint	k k	3045-5
k k		sequential	tuples	3045-5
tuples	of	constraint	adom	3045-5
adom		sequential	I	3045-5
I		sequential	u	3045-5
u		sequential	I	3045-5
I	v	action	iff	3045-5
iff		sequential	there	3045-5
there	exists	action	an automorphism	3045-5
an automorphism		sequential	ρ	3045-5
ρ	of	constraint	I	3045-5
I	that	constraint	such ρ	3045-5
such ρ		sequential	u	3045-5
u	=	sequential	v	3045-5
<B>		sequential	w	3046-1
w	on	constraint	input	3046-1
w	when is executed	action	input	3046-1
input		sequential	I	3046-1
<B>	that	constraint	J	3046-2
<B>	suppose	action	J	3046-2
J	is	attribute	an instance	3046-2
an instance	at	constraint	some point	3046-2
an instance	obtained	action	some point	3046-2
some point	in	constraint	the computation	3046-2
the computation	of	constraint	input I	3046-2
the computation	w	constraint	input I	3046-2
the computation	on	constraint	input I	3046-2
The genericity of	while	constraint	programs	3046-3
programs	that	constraint	ρ	3046-3
programs	if	constraint	ρ	3046-3
programs	implies	action	ρ	3046-3
ρ	is	attribute	an automorphism	3046-3
an automorphism	of	constraint	I	3046-3
I		sequential	it	3046-3
it	is	attribute	also an automorphism	3046-3
also an automorphism	of	constraint	J	3046-3
<B>	for	constraint	each k tuple	3046-4
each k tuple		sequential	u	3046-4
u	in	constraint	some relation	3046-4
some relation	of	constraint	J	3046-4
J	and	conjunctive	each v	3046-4
each v	that	constraint	u	3046-4
u		sequential	I	3046-4
I	v	action	v	3046-4
v	to	constraint	that relation	3046-4
v	also belongs	action	that relation	3046-4
each k relation k	in	constraint	J	3046-5
J	of	constraint	arity	3046-5
arity	is	attribute	Thus a union	3046-5
Thus a union	of	constraint	equivalence classes	3046-5
equivalence classes	of	constraint	I	3046-5
equivalence classes	≡	sequential	I	3046-5
The equivalence relation	≡	sequential	I	3046-6
I	k	action	k	3046-6
k	in	constraint	our development	3046-6
k	will be used	action	our development	3046-6
our development	of	constraint	1	3046-6
our development	-	sequential	1	3046-6
1		sequential	0 laws	3046-6
0 laws	presented next	action	<B>	3046-6
We	now develop	action	a powerful tool	3047-1
a powerful tool		sequential	that	3047-1
that	provides	action	a uniform approach	3047-1
a uniform approach	to	constraint	the negative a large spectrum	3047-1
a uniform approach	in	constraint	the negative a large spectrum	3047-1
a uniform approach	resolving	action	the negative a large spectrum	3047-1
the negative a large spectrum	of	constraint	expressibility problems	3047-1
It	on	constraint	the probability	3047-2
It	is based	action	the probability	3047-2
the probability	that	constraint	a property	3047-2
a property	in	constraint	instances	3047-2
a property	is	attribute	true	3047-2
instances	of	constraint	a given size	3047-2
We	shall prove	action	a surprising fact	3047-3
we	More precisely prove	action	the result	3047-4
the result	for	constraint	sentences	3047-4
the result	while	constraint	sentences	3047-4
sentences		sequential	Definition 17.3.3	3047-4
<B>	Let	action	q	3048-1
q	be	attribute	a sentence	3048-1
a sentence	over	constraint	some schema R.	3048-1
some schema R.	For	constraint	µn	3048-1
some schema R.	n	conjunctive	µn	3048-1
some schema R.	let	action	µn	3048-1
µn		sequential	q	3048-1
q	denote	action	the fraction	3048-1
the fraction	of	constraint	instances	3048-1
instances	over	constraint	R	3048-1
R	with	constraint	entries	3048-1
entries	in	constraint	<B>	3048-1
entries	{ 1	sequential	<B>	3048-1
<B>	.	sequential	<B>	3048-2
<B>	.	sequential	<B>	3048-3
<B>	n	conjunctive	}	3048-4
}		sequential	that	3048-4
that	satisfy	action	q	3048-4
<B>	is	attribute	<B>	3048-5
Definition		sequential	17.3.4	3049-1
<B>	To	constraint	the discussion	3050-1
<B>	simplify	action	the discussion	3050-1
the discussion	of	constraint	1	3050-1
the discussion	-	sequential	1	3050-1
1		sequential	0 laws	3050-1
0 laws		sequential	we	3050-1
we	to	constraint	queries	3050-1
we	on	constraint	queries	3050-1
we	continue	attribute	constant	3050-1
we	focus exclusively	attribute	constant	3050-1
queries	see	action	Exercise 17.19	3050-1
We	that	constraint	CALC	3051-1
We	will show	action	CALC	3051-1
CALC		sequential	fixpoint	3051-1
fixpoint	while	constraint	sentences	3051-1
fixpoint	and	conjunctive	sentences	3051-1
sentences	-	sequential	1	3051-1
sentences	have	action	1	3051-1
1		sequential	0 laws	3051-1
<B>	provides	action	substantial insight	3051-2
substantial insight	into	constraint	limitations	3051-2
limitations	of	constraint	the expressive power	3051-2
the expressive power	of	constraint	these languages	3051-2
these languages	to	constraint	they	3051-2
these languages	that	constraint	they	3051-2
these languages	and	conjunctive	they	3051-2
these languages	can be used	action	they	3051-2
these languages	show	action	they	3051-2
they	can not express	action	a variety	3051-2
a variety	of	constraint	properties	3051-2
<B>	For	constraint	example	3051-3
example		sequential	it	3051-3
it	that	constraint	these languages	3051-3
it	in	constraint	these languages	3051-3
it	of	constraint	these languages	3051-3
it	follows immediately	attribute	even not expressible	3051-3
it	is	attribute	even not expressible	3051-3
<B>	is	attribute	1	3051-4
1	if	constraint	0	3051-4
1	n	conjunctive	0	3051-4
1	and	conjunctive	0	3051-4
1	is	attribute	0	3051-4
0	if	constraint	<B>	3051-4
0	n	conjunctive	<B>	3051-4
0	is	attribute	odd	3051-4
µn	in	constraint	a language	3051-5
µn	Thus even does not converge	attribute	so even not expressible	3051-5
µn	is	attribute	so even not expressible	3051-5
a language		sequential	that	3051-5
that	has	action	1	3051-5
1		sequential	a 0 law	3051-5
<B>	While	constraint	1	3052-1
<B>	-	sequential	1	3052-1
1		sequential	0 laws	3052-1
0 laws	and	conjunctive	an tool	3052-1
0 laws	provide	attribute	elegant	3052-1
an tool		sequential	they	3052-1
they	require	action	the development	3052-1
the development	of	constraint	some nontrivial machinery	3052-1
<B>	is	attribute	Interestingly one	3052-2
Interestingly one	of	constraint	the rare occasions	3052-2
the rare occasions		sequential	we	3052-2
we	to	constraint	infinite instances	3052-2
we	when will need	action	infinite instances	3052-2
we	consider	action	infinite instances	3052-2
infinite instances	though	constraint	we	3052-2
we	to	constraint	something	3052-2
we	even aim	action	something	3052-2
we	prove	action	something	3052-2
something	about	constraint	finite instances only	3052-2
We	by	constraint	CALC	3053-1
We	that	constraint	CALC	3053-1
We	start	action	CALC	3053-1
We	proving	action	CALC	3053-1
CALC	-	sequential	1	3053-1
CALC	has	action	1	3053-1
1		sequential	a 0 law	3053-1
a 0 law	and	conjunctive	the result	3053-1
a 0 law	extend	action	the result	3053-1
the result	to	constraint	fixpoint	3053-1
fixpoint	and	conjunctive	while	3053-1
<B>	For	constraint	simplicity	3053-2
simplicity		sequential	we	3053-2
we	consider	action	only the case	3053-2
only the case		sequential	the input	3053-2
the input	to	constraint	the query	3053-2
the query	is	attribute	when a binary relation G	3053-2
when a binary relation G	representing	action	edges	3053-2
edges	in	constraint	a directed graph	3053-2
a directed graph	with	constraint	no edges	3053-2
no edges	of	constraint	the form	3053-2
the form		sequential	<B>	3053-2
It	to	constraint	the development	3053-3
It	is	attribute	straightforward	3053-3
It	generalize	action	the development	3053-3
the development	to	constraint	arbitrary inputs	3053-3
arbitrary inputs	see	action	Exercise 17.19	3053-3
We	will use	action	an infinite set A	3054-1
an infinite set A	of	constraint	CALC sentences	3054-1
CALC sentences	called	action	extension axioms	3054-1
extension axioms		sequential	which	3054-1
which	to	constraint	graphs	3054-1
which	refer	action	graphs	3054-1
They	that	constraint	every subgraph	3054-2
They	say intuitively	action	every subgraph	3054-2
every subgraph	by	constraint	one node	3054-2
every subgraph	can be extended	action	one node	3054-2
one node	in	constraint	all possible ways	3054-2
<B>		sequential	A	3054-3
A	for	constraint	each k	3054-3
A	contains	action	each k	3054-3
each k		sequential	all sentences	3054-3
all sentences	of	constraint	the form	3054-3
<B>		sequential	i	3055-1
i		sequential	where connections	3055-1
where connections		sequential	x1	3055-1
<B>	.	sequential	<B>	3055-2
<B>	.	sequential	<B>	3055-3
xk		sequential	y	3055-4
y	is	attribute	some conjunction	3055-4
some conjunction	of	constraint	literals	3055-4
literals	for	constraint	each xi	3055-4
literals	containing	action	each xi	3055-4
each xi		sequential	one	3055-4
one	of	constraint	G	3055-4
G		sequential	xi	3055-4
xi		sequential	y	3055-4
y	or	conjunctive	¬G	3055-4
¬G		sequential	xi	3055-4
xi		sequential	y	3055-4
y	and	conjunctive	one	3055-4
one	of	constraint	G	3055-4
G		sequential	y	3055-4
y		sequential	xi	3055-4
xi	or	conjunctive	¬G	3055-4
¬G		sequential	y	3055-4
y		sequential	xi	3055-4
<B>	For	constraint	example	3055-5
example	for	constraint	k	3055-5
k	=	sequential	3	3055-5
3		sequential	one	3055-5
one	of	constraint	the 26 extension axioms	3055-5
the 26 extension axioms	is	attribute	G	3055-5
G		sequential	x1	3055-5
x1		sequential	y	3055-5
y		sequential	∧	3055-5
∧		sequential	¬G	3055-5
¬G		sequential	y	3055-5
y		sequential	x1	3055-5
x1		sequential	¬G	3055-5
¬G		sequential	x2	3055-5
x2		sequential	y	3055-5
y		sequential	∧	3055-5
∧		sequential	¬G	3055-5
¬G		sequential	y	3055-5
y		sequential	x2	3055-5
x2		sequential	∧ G	3055-5
∧ G		sequential	x3	3055-5
x3		sequential	y	3055-5
y		sequential	∧ G	3055-5
∧ G		sequential	y	3055-5
y		sequential	x3	3055-5
x3	specifying	action	the pattern	3055-5
the pattern	of	constraint	connections	3055-5
connections	in	constraint	Fig	3055-5
connections	represented	action	Fig	3055-5
17.4		sequential	17.4	3055-6
First Order		sequential	Fixpoint	3056-1
Fixpoint	While	constraint	y x 1	3056-1
Fixpoint	and	conjunctive	y x 1	3056-1
y x 1	x	sequential	2	3056-1
2	x	sequential	3	3056-1
3		sequential	Figure 17.4	3056-1
<B>	that	constraint	A	3057-1
<B>	Note	action	A	3057-1
A	of	constraint	an infinite set	3057-1
A	consists	action	an infinite set	3057-1
an infinite set	of	constraint	sentences	3057-1
sentences	that	constraint	each finite subset	3057-1
sentences	and	conjunctive	each finite subset	3057-1
each finite subset	of	constraint	A	3057-1
A	by	constraint	some infinite instance	3057-1
A	is	attribute	satisfied	3057-1
The instance	by	constraint	one node	3057-2
The instance	from	constraint	one node	3057-2
The instance	is obtained	action	one node	3057-2
The instance	starting	action	one node	3057-2
one node	and	conjunctive	nodes	3057-2
one node	repeatedly adding	action	nodes	3057-2
nodes	by	constraint	the extension axioms	3057-2
nodes	required	action	the extension axioms	3057-2
the extension axioms	in	constraint	the subset	3057-2
<B>	by	constraint	the compactness theorem	3057-3
the compactness theorem		sequential	there	3057-3
there	Then is	action	an infinite instance	3057-3
an infinite instance	of	constraint	A	3057-3
an infinite instance	satisfying	attribute	all	3057-3
A	by	constraint	Löwenheim	3057-3
A	and	conjunctive	Löwenheim	3057-3
Löwenheim		sequential	Skolem	3057-3
Skolem		sequential	the theorem	3057-3
the theorem	see	action	Chapter 2	3057-3
Chapter 2		sequential	there	3057-3
there	is	attribute	a countably infinite instance R satisfying A	3057-3
The following lemma	that	constraint	R	3058-1
The following lemma	shows	action	R	3058-1
R	to	constraint	isomorphism	3058-1
R	is	attribute	unique up	3058-1
Lemma		sequential	17.3.5	3059-1
Proof	that	constraint	a 1a2	3060-1
Proof	Suppose	action	a 1a2	3060-1
<B>	.	sequential	<B>	3060-2
<B>	.	sequential	<B>	3060-3
<B>	is	attribute	an enumeration	3060-4
an enumeration	of	constraint	all constants	3060-4
all constants	in	constraint	R	3060-4
R	and	conjunctive	b1b2	3060-4
<B>	.	sequential	<B>	3060-5
<B>	.	sequential	<B>	3060-6
<B>	is	attribute	an enumeration	3060-7
an enumeration	of	constraint	P	3060-7
an enumeration	in	constraint	P	3060-7
<B>	.	sequential	<B>	3060-8
<B>	.	sequential	<B>	3060-9
<B>		sequential	<B>	3060-10
<B>	.	sequential	<B>	3060-11
<B>	.	sequential	<B>	3060-12
<B>	and	conjunctive	1 ik bi	3060-13
<B>	.	sequential	<B>	3060-14
<B>	.	sequential	<B>	3060-15
<B>		sequential	<B>	3060-16
<B>	.	sequential	<B>	3060-17
<B>	.	sequential	<B>	3060-18
<B>	that	constraint	a b	3060-19
a b	is	attribute	an isomorphism	3060-19
an isomorphism	from	constraint	R	3060-19
R	to	constraint	P	3060-19
<B>	For	constraint	the k ik base case	3060-20
the k ik base case	let	action	ai	3060-20
ai	=	sequential	a ik i1 ik	3060-20
a ik i1 ik	been defined	action	<B>	3060-20
<B>	If	constraint	k	3060-21
k	is	attribute	the first constant	3060-21
k	be	attribute	the first constant	3060-21
k	let	action	the first constant	3060-21
the first constant	in	constraint	a k+1	3060-21
a k+1	in	constraint	the sequence	3060-21
<B>	Let	action	σk	3060-22
σk	be	attribute	the sentence	3060-22
the sentence	in	constraint	A	3060-22
A	describing	action	the way	3060-22
the way		sequential	ai	3060-22
ai	extends	action	sub k+1	3060-22
sub k+1		sequential	the graph	3060-22
the graph	with	constraint	nodes ai	3060-22
<B>	.	sequential	<B>	3060-23
<B>	.	sequential	<B>	3060-24
<B>		sequential	<B>	3060-25
<B>	Because	constraint	P	3060-26
P	also satisfies	action	σ	3060-26
σ		sequential	k	3060-26
k		sequential	there	3060-26
there	exists	action	a constant b	3060-26
a constant b	in	constraint	P	3060-26
P		sequential	that	3060-26
that	extends	action	the subgraph bi	3060-26
<B>	.	sequential	<B>	3060-27
<B>	.	sequential	<B>	3060-28
<B>	in	constraint	the same manner	3060-29
<B>	b	action	the same manner	3060-29
<B>	Let	action	b	3060-30
b		sequential	ik ik +1	3060-30
ik ik +1	is reversed	action	it	3060-30
it	by	constraint	a new constant	3060-30
it	starts	action	a new constant	3060-30
it	choosing first	action	a new constant	3060-30
a new constant	from	constraint	b1	3060-30
b1		sequential	b2	3060-30
<B>	.	sequential	<B>	3060-31
<B>	.	sequential	<B>	3060-32
<B>	)	sequential	<B>	3060-33
<B>	and	conjunctive	This procedure	3060-34
This procedure	that	constraint	all constants	3060-34
This procedure	ensures	action	all constants	3060-34
all constants	from	constraint	R	3060-34
all constants	both	conjunctive	R	3060-34
R	and	conjunctive	P	3060-34
P	among	constraint	the chosen constants	3060-34
P	1 occur eventually	action	the chosen constants	3060-34
the chosen constants	and	conjunctive	the mapping ai	3060-34
the mapping ai		sequential	→ b	3060-34
→ b	is	attribute	2 an isomorphism	3060-34
k		sequential	ik	3061-1
ik		sequential	the foregoing proof	3061-1
the foregoing proof	that	constraint	there	3061-1
the foregoing proof	Thus shows	action	there	3061-1
there	exists	attribute	unique	3061-1
up	to	constraint	isomorphism	3061-1
isomorphism		sequential	a countable graph R satisfying A	3061-1
This graph	by	constraint	Rado	3061-2
This graph	studied extensively	action	Rado	3061-2
Rado		sequential	Rad64	3061-2
Rad64	and	conjunctive	others	3061-2
others	to	constraint	the Rado graph	3061-2
others	as	constraint	the Rado graph	3061-2
others	is usually referred	action	the Rado graph	3061-2
We	can now prove	action	the following crucial lemma	3061-3
The key point	is	attribute	the equivalence	3062-1
the equivalence	between	constraint	c	3062-1
the equivalence	and	conjunctive	c	3062-1
c	a called	action	the transfer property	3062-1
Lemma		sequential	17.3.6	3063-1
<B>	are	attribute	equivalent	3063-2
Proof satisfying A	but	conjunctive	not σ	3064-1
<B>	Because	constraint	P	3064-2
P	satisfies	action	A	3064-2
A		sequential	P	3064-2
P	be	attribute	must infinite	3064-2
<B>	By	constraint	Lowënheim	3064-3
Lowënheim		sequential	Skolem	3064-3
Skolem		sequential	the theorem	3064-3
the theorem	see	action	Chapter 2	3064-3
Chapter 2		sequential	we	3064-3
we	that	constraint	P	3064-3
we	can assume	action	P	3064-3
P	is	attribute	countable	3064-3
<B>	by	constraint	Lemma 17.3.5	3064-4
<B>	But	conjunctive	Lemma 17.3.5	3064-4
Lemma 17.3.5		sequential	P	3064-4
P	to	constraint	R	3064-4
P	is	attribute	isomorphic	3064-4
<B>	Suppose	attribute	this	3065-1
<B>	is	attribute	the case	3065-1
the case	and	conjunctive	A	3065-1
A	implies	action	σ	3065-1
<B>	By	constraint	the compactness theorem	3065-2
the compactness theorem		sequential	σ	3065-2
σ	by	constraint	some finite subset	3065-2
σ	is implied	action	some finite subset	3065-2
some finite subset		sequential	A′	3065-2
A′	of	constraint	A	3065-2
<B>	Because	constraint	every sentence	3065-3
every sentence	in	constraint	A′	3065-3
A′	is	attribute	almost surely true	3065-3
the conjunction		sequential	<B>	3065-3
It	to	constraint	each sentence	3066-1
It	that	constraint	each sentence	3066-1
It	remains	action	each sentence	3066-1
It	show	action	each sentence	3066-1
each sentence	in	constraint	A	3066-1
A	is	attribute	almost surely true	3066-1
<B>	Consider	action	the following sentence σk	3066-2
the following sentence σk	in	constraint	A	3066-2
i=j i		sequential	i=j i	3067-1
i=j		sequential	i=j	3068-1
i		sequential	We	3069-1
We	will show	action	the following property	3069-1
the following property	on	constraint	the probability	3069-1
the probability	that	constraint	an instance	3069-1
an instance	with	constraint	constants	3069-1
an instance	n	conjunctive	constants	3069-1
constants	does not satisfy	action	σk	3069-1
<B>	Because	constraint	limn→∞	3070-1
limn→∞		sequential	n	3070-1
n		sequential	n	3070-1
n	−	sequential	1	3070-1
<B>	.	sequential	<B>	3070-2
<B>	.	sequential	<B>	3070-3
n		sequential	1	3070-4
1	−	sequential	1	3070-4
1		sequential	n−k	3070-4
n−k	=	sequential	0	3070-4
0		sequential	it	3070-4
it	k follows	action	that lim 22 k	3070-4
that lim 22 k		sequential	n→∞	3070-4
n→∞		sequential	µn	3070-4
<B>	Let	action	N	3071-1
N	be	attribute	the number	3071-1
the number	of	constraint	instances	3071-1
instances	with	constraint	constants	3071-1
constants	in	constraint	<B>	3071-1
constants	{ 1	sequential	<B>	3071-1
<B>	.	sequential	<B>	3071-2
<B>	.	sequential	<B>	3071-3
<B>	n	conjunctive	}	3071-4
<B>	To	constraint	<B>	3071-5
<B>	prove	attribute	the following	3071-5
<B>	observe	attribute	the following	3071-5
First Order		sequential	Fixpoint	3072-1
Fixpoint	and	conjunctive	<B>	3072-1
i	−	sequential	1	3073-1
i	is	attribute	1	3073-1
1		sequential	1 n−k N	3073-1
1 n−k N	because	constraint	there	3073-1
there	are	attribute	n	3073-1
n	−	sequential	k	3073-1
k		sequential	ways	3073-1
ways	of	constraint	b	3073-1
ways	picking	action	b	3073-1
b	from	constraint	22 k	3073-1
<B>	n	conjunctive	n − 1	3074-1
<B>	.	sequential	<B>	3074-2
<B>	.	sequential	<B>	3074-3
n		sequential	k	3074-4
k		sequential	1	3074-4
<B>	is	attribute	almost surely true	3075-1
σ	be	attribute	Then can not almost surely true	3075-2
The 0 1 law	for	constraint	CALC	3076-1
CALC	follows immediately	action	<B>	3076-1
Theorem		sequential	17.3.7	3077-1
Proof	Let	action	σ	3078-1
σ	be	attribute	a CALC sentence	3078-1
The Rado graph R	either	conjunctive	σ	3078-2
The Rado graph R	satisfies	action	σ	3078-2
σ	or	conjunctive	¬σ	3078-2
<B>	By	constraint	the transfer property	3078-3
the transfer property		sequential	a c	3078-3
a c	in	constraint	Lemma	3078-3
Lemma		sequential	17.3.6	3078-3
17.3.6		sequential	σ	3078-3
σ	or	conjunctive	¬σ	3078-3
σ	is	attribute	almost surely true	3078-3
¬σ	is	attribute	almost surely true	3078-3
σ	or	conjunctive	<B>	3078-4
σ	is	attribute	Thus almost surely true	3078-4
The 0 1 law	for	constraint	CALC	3079-1
CALC	to	constraint	fixpoint	3079-1
CALC	can be extended	action	fixpoint	3079-1
fixpoint	and	conjunctive	while	3079-1
We	prove next	action	it	3079-2
it	for	constraint	while	3079-2
while	and	conjunctive	therefore fixpoint	3079-2
the proof	Once again uses	action	the Rado graph	3079-3
the Rado graph	and	conjunctive	the transfer property	3079-3
the Rado graph	extends	action	the transfer property	3079-3
the transfer property	to	constraint	the while sentences	3079-3
Theorem		sequential	17.3.8	3080-1
Proof		sequential	Proof	3081-1
The main idea	of	constraint	the proof	3082-1
the proof	to	constraint	every CALC	3082-1
the proof	that	constraint	every CALC	3082-1
the proof	is	attribute	every CALC	3082-1
the proof	show	action	every CALC	3082-1
every CALC	+	sequential	µ sentence	3082-1
µ sentence		sequential	that	3082-1
that	on	constraint	all instances	3082-1
that	is defined	action	all instances	3082-1
all instances	in	constraint	fact	3082-1
all instances	is	attribute	fact	3082-1
fact	to	constraint	a CALC sentence	3082-1
a CALC sentence	by	constraint	the previous result	3082-1
a CALC sentence	and	conjunctive	the previous result	3082-1
the previous result	or	conjunctive	<B>	3082-1
the previous result	is	attribute	so almost surely true	3082-1
We	for	constraint	CALC +µ sentences	3082-2
We	show	attribute	this	3082-2
<B>	By	constraint	Theorem 14.4.7	3083-1
Theorem 14.4.7		sequential	we	3083-1
we	can consider	action	w.l.o.g	3083-1
only sentences	involving	action	one application	3083-2
one application	of	constraint	the partial fixpoint operator µ	3083-2
<B>	Thus consider	action	a CALC +µ sentence	3083-3
a CALC +µ sentence		sequential	ξ	3083-3
ξ	of	constraint	the form	3083-3
the form		sequential	ξ	3083-3
ξ	=	sequential	∃	3083-3
∃		sequential	x	3083-3
x		sequential	µT	3083-3
µT		sequential	ϕ	3083-3
ϕ		sequential	T	3083-3
T		sequential	t	3083-3
t	over	constraint	schema R	3083-3
schema R		sequential	where distinct free variables	3083-3
where distinct free variables	in	constraint	t	3083-3
<B>		sequential	a computation	3084-1
a computation	of	constraint	a query	3084-1
a query	of	constraint	the CALC formula	3084-1
a query	ξ	sequential	the CALC formula	3084-1
a query	consists	action	the CALC formula	3084-1
a query	iterating	action	the CALC formula	3084-1
the CALC formula	until	constraint	convergence	3084-1
convergence	if	constraint	<B>	3084-1
convergence	occurs	action	<B>	3084-1
<B>	Consider	action	the sequence	3084-2
the sequence		sequential	ϕi	3084-2
ϕi		sequential	I	3084-2
I		sequential	i	3084-2
<B>	If	constraint	I	3084-3
I	is	attribute	finite	3084-3
the sequence	is	attribute	periodic	3084-3
there	exist	action	N	3084-3
N	and	conjunctive	p	3084-3
p	for	constraint	each n ≥ N	3084-3
each n ≥ N		sequential	ϕn	3084-3
ϕn		sequential	I	3084-3
I	=	sequential	ϕn+p	3084-3
ϕn+p		sequential	I	3084-3
<B>	If	constraint	p	3084-4
p	=	sequential	1	3084-4
1		sequential	the sequence	3084-4
the sequence	converges	action	it	3084-4
it	at	constraint	some point	3084-4
it	becomes	attribute	constant	3084-4
some point		sequential	it	3084-4
it	otherwise does not	action	<B>	3084-4
<B>	Now consider	action	the sequence	3084-5
the sequence		sequential	ϕi	3084-5
ϕi		sequential	R	3084-5
R		sequential	i	3084-5
<B>	Because	constraint	the set	3084-6
the set	of	constraint	constants	3084-6
constants	involved	attribute	no longer finite	3084-6
constants	is	attribute	no longer finite	3084-6
the sequence	or	conjunctive	<B>	3084-6
the sequence	may	attribute	not periodic	3084-6
the sequence	may	attribute	not periodic	3084-6
the sequence	be	attribute	not periodic	3084-6
A key point	in	constraint	our proof	3084-7
our proof	is	attribute	the observation	3084-7
the observation	that	constraint	the sequence	3084-7
the sequence		sequential	ϕi	3084-7
ϕi		sequential	R	3084-7
R		sequential	i	3084-7
<B>	To	constraint	we	3085-1
<B>	see	attribute	this	3085-1
we	use	action	a technique	3085-1
a technique	to	constraint	the hyperplane technique	3085-1
the hyperplane technique	in	constraint	the proof	3085-1
the proof	of	constraint	Lemma 17.3.5	3085-1
<B>	Let	action	k	3085-2
k	be	attribute	some integer	3085-2
We	that	constraint	each k	3085-3
We	for	constraint	each k	3085-3
We	argue next	action	each k	3085-3
each k		sequential	there	3085-3
there	is	attribute	a finite number	3085-3
a finite number	of	constraint	equivalence classes	3085-3
equivalence classes	of	constraint	k tuples	3085-3
k tuples	by	constraint	automorphisms	3085-3
k tuples	induced	action	automorphisms	3085-3
automorphisms	of	constraint	R	3085-3
<B>	Let	action	u	3086-1
u	≃R	action	v	3086-1
v	if	constraint	the patterns	3086-1
v	both	conjunctive	the patterns	3086-1
the patterns	of	constraint	equality	3086-1
equality	and	conjunctive	the patterns	3086-1
the patterns	of	constraint	connection	3086-1
connection	within	constraint	u	3086-1
u	and	conjunctive	k	3086-1
k		sequential	v	3086-1
v	are	attribute	identical	3086-1
<B>	for	constraint	u	3086-2
u	=	sequential	a 1	3086-2
<B>	.	sequential	<B>	3086-3
<B>	.	sequential	<B>	3086-4
ak		sequential	v	3086-5
v	=	sequential	b1	3086-5
<B>	.	sequential	<B>	3086-6
<B>	.	sequential	<B>	3086-7
bk		sequential	ai	3086-8
ai	and	conjunctive	bi	3086-8
bi	are	attribute	where constants	3086-8
where constants	in	constraint	R	3086-8
R		sequential	u	3086-8
u		sequential	≃R v	3086-8
≃R v	if	constraint	k	3086-8
We	that	constraint	u	3087-1
We	claim	action	u	3087-1
u		sequential	≡R k v iff	3087-1
≡R k v iff		sequential	u ≃R k v	3087-1
<B>	only if	constraint	The part	3088-1
The part	from	constraint	the definitions	3088-1
The part	follows immediately	action	the definitions	3088-1
<B>	For	constraint	the part	3088-2
<B>	if	constraint	the part	3088-2
the part	that	constraint	u	3088-2
the part	suppose	action	u	3088-2
u		sequential	≃R v	3088-2
<B>	by	constraint	back	3089-1
<B>	k k is done	action	back	3089-1
back	and	conjunctive	a construction	3089-1
a construction	as	constraint	Lemma 17.3.5	3089-1
a construction	in	constraint	Lemma 17.3.5	3089-1
Lemma 17.3.5	using	action	the extension axioms	3089-1
the extension axioms	by	constraint	R	3089-1
R	see	action	Exercise 17.18	3089-1
<B>	Because	constraint	there	3090-1
there	are	attribute	finitely many patterns	3090-1
finitely many patterns	of	constraint	connection	3090-1
connection	and	conjunctive	equality	3090-1
equality	among	constraint	k vertexes	3090-1
k vertexes		sequential	there	3090-1
there	are	attribute	finitely many equivalence classes	3090-1
finitely many equivalence classes	of	constraint	≃R	3090-1
≃R	of	constraint	so ≡R	3090-1
<B>	Due to	constraint	genericity	3090-2
genericity	of	constraint	the while k k computation	3090-2
the while k k computation		sequential	each ϕi	3090-2
each ϕi		sequential	R	3090-2
R	is	attribute	a union	3090-2
a union	of	constraint	such equivalence classes	3090-2
such equivalence classes	see	action	Exercise 16.6	3090-2
Exercise 16.6	in	constraint	the previous chapter	3090-2
there	Thus must exist	action	m	3090-3
m		sequential	l	3090-3
l		sequential	0 ≤ m	3090-3
0 ≤ m		sequential	l	3090-3
l	that	constraint	ϕm	3090-3
ϕm		sequential	R	3090-3
R	=	sequential	ϕl	3090-3
ϕl		sequential	R	3090-3
<B>	Let	action	N	3090-4
N	=	sequential	m	3090-4
m	and	conjunctive	p	3090-4
p	=	sequential	l m	3090-4
It	that	constraint	ϕi	3090-5
It	follows	action	ϕi	3090-5
ϕi		sequential	R	3090-5
R		sequential	i 0	3090-5
i 0	is	attribute	1 periodic	3090-5
<B>	Using	action	this fact	3091-1
this fact		sequential	we	3091-1
we	show	attribute	the following	3091-1
<B>	Before	constraint	we	3092-1
<B>	proving	attribute	these	3092-1
we	that	constraint	3	3092-1
we	and	conjunctive	3	3092-1
we	argue	action	3	3092-1
3	2 will imply	action	the statement	3092-1
the statement	of	constraint	the theorem	3092-1
<B>	Suppose	attribute	that	3093-1
2	and	conjunctive	<B>	3093-1
2	3 holds	action	<B>	3093-1
<B>	that	constraint	σ	3093-2
<B>	Suppose also	action	σ	3093-2
σ	in	constraint	R.	3093-2
σ	is	attribute	false	3093-2
R.	By	constraint	Lemma 17.3.6	3093-2
Lemma 17.3.6		sequential	σ	3093-2
σ	is	attribute	almost surely false	3093-2
µn		sequential	ξ	3093-3
ξ		sequential	≤	3093-3
≤		sequential	µn	3093-3
µn		sequential	ξ	3093-3
ξ	≡	sequential	σ	3093-3
σ	+	sequential	µn	3093-3
µn		sequential	σ	3093-3
σ	and	conjunctive	both µn	3093-3
both µn		sequential	ξ	3093-3
ξ	≡	sequential	σ	3093-3
σ	and	conjunctive	σ	3093-3
σ		sequential	First Order	3093-3
First Order		sequential	Fixpoint	3093-3
Fixpoint	While	constraint	0	3093-3
Fixpoint	to	constraint	0	3093-3
Fixpoint	and	conjunctive	0	3093-3
Fixpoint	converge	action	0	3093-3
0		sequential	µn	3093-3
µn		sequential	ξ	3093-3
ξ	Then =	sequential	0	3093-3
<B>	ξ	sequential	<B>	3093-4
<B>	is	attribute	Thus also almost surely false	3093-4
<B>	By	constraint	a similar argument	3093-5
a similar argument	if	constraint	σ	3093-5
a similar argument	ξ	sequential	σ	3093-5
a similar argument	is	attribute	almost surely true	3093-5
σ	in	constraint	R	3093-5
σ	is	attribute	true	3093-5
We	now prove	action	2	3094-1
<B>	$ ij	sequential	the CALC sentence	3094-2
<B>	be	attribute	the CALC sentence	3094-2
<B>	Let	action	the CALC sentence	3094-2
the CALC sentence	that	constraint	ϕi	3094-2
the CALC sentence	stating	action	ϕi	3094-2
ϕi	and	conjunctive	ϕj	3094-2
ϕj	are	attribute	equivalent	3094-2
<B>	Suppose	action	ϕi	3095-1
ϕi		sequential	R	3095-1
R		sequential	i 0	3095-1
i 0	does not converge	action	<B>	3095-1
the period	of	constraint	the sequence	3095-2
the sequence	than	constraint	1	3095-2
the sequence	is	attribute	Thus greater	3095-2
1		sequential	there	3095-2
there	so exist	action	m such	3095-2
m such		sequential	j	3095-2
j		sequential	l	3095-2
l		sequential	m	3095-2
m		sequential	j	3095-2
j		sequential	l	3095-2
R	Thus satisfies	action	the CALC sentence	3096-1
<B>	Let	action	I	3097-1
I	over	constraint	finite databases	3097-1
I	range	action	finite databases	3097-1
<B>	Because	constraint	all finite inputs	3097-2
<B>	on	constraint	all finite inputs	3097-2
<B>	ξ	sequential	all finite inputs	3097-2
<B>	is defined	action	all finite inputs	3097-2
all finite inputs		sequential	ϕi	3097-2
ϕi		sequential	I	3097-2
I		sequential	i≥0	3097-2
i≥0	converges	action	<B>	3097-2
<B>	On	constraint	the other hand	3097-3
the other hand	by	constraint	the transfer property	3097-3
the transfer property		sequential	Lemma	3097-3
Lemma		sequential	17.3.6	3097-3
17.3.6		sequential	χ	3097-3
χ	is	attribute	almost surely true	3097-3
It	that	constraint	the sequence	3097-4
It	follows	action	the sequence	3097-4
the sequence		sequential	ϕi	3097-4
ϕi		sequential	I	3097-4
I		sequential	i 0	3097-4
i 0	diverges almost surely	action	<B>	3097-4
<B>	In	constraint	there	3097-5
there	exist	attribute	finite	3097-5
I	for	constraint	which	3097-5
which		sequential	ϕi	3097-5
ϕi		sequential	I	3097-5
I		sequential	i 0	3097-5
i 0	diverges	action	a contradiction	3097-5
The proof	of	constraint	3	3098-1
3	is	attribute	similar	3098-1
<B>	By	constraint	the sequence	3098-2
<B>	and	conjunctive	the sequence	3098-2
the sequence		sequential	ϕi	3098-2
ϕi		sequential	R	3098-2
R		sequential	i 0	3098-2
i 0	after	constraint	finitely many iterations	3098-2
i 0	1 2 becomes	attribute	constant	3098-2
finitely many iterations	say	action	N	3098-2
<B>	on	constraint	R	3098-3
<B>	ξ	sequential	R	3098-3
<B>	is	attribute	Then equivalent	3098-3
R	to	constraint	the CALC sentence	3098-3
the CALC sentence		sequential	σ	3098-3
σ	=	sequential	x	3098-3
x	ϕ	sequential	N	3098-3
N		sequential	t	3098-3
<B>	Suppose	action	R	3098-4
R	satisfies ξ	action	<B>	3098-4
R	Thus satisfies	action	σ	3098-5
R	$ N	sequential	N+1	3098-6
R	Furthermore satisfies	action	N+1	3098-6
N+1	because	constraint	ϕi	3098-6
ϕi		sequential	R	3098-6
R		sequential	i 0	3098-6
i 0	at	constraint	the Nth iteration	3098-6
i 0	becomes	attribute	constant	3098-6
R	Thus satisfies	action	σ	3098-7
σ	∧ $ N	sequential	N+1	3098-7
<B>	By	constraint	the transfer property	3099-1
the transfer property	for	constraint	CALC	3099-1
CALC		sequential	σ ∧	3099-1
σ ∧	$ N	sequential	N+1	3099-1
N+1	is	attribute	almost surely true	3099-1
<B>	For	constraint	each finite instance	3099-2
each finite instance		sequential	I	3099-2
I	$ N	sequential	N+1	3099-2
I	where	action	N+1	3099-2
N+1	holds	action	ϕi	3099-2
ϕi		sequential	I	3099-2
I		sequential	i 0	3099-2
i 0	after	constraint	N iterations	3099-2
i 0	converges	action	N iterations	3099-2
N iterations	to	constraint	σ	3099-2
N iterations	ξ	sequential	σ	3099-2
N iterations	is	attribute	so equivalent	3099-2
It	that	constraint	σ	3099-3
It	to	constraint	σ	3099-3
It	follows	attribute	almost surely equivalent	3099-3
It	is	attribute	almost surely equivalent	3099-3
The case		sequential	R	3099-4
R	ξ	sequential	<B>	3099-4
R	where does not satisfy	attribute	similar	3099-4
R	is	attribute	similar	3099-4
we	that	constraint	sentences	3100-1
we	while	constraint	sentences	3100-1
we	Thus have shown	action	sentences	3100-1
sentences	have	action	1	3100-1
1		sequential	a 0 law	3100-1
It	that	constraint	many queries	3100-2
It	follows immediately	action	many queries	3100-2
many queries	while	constraint	even not sentences	3100-2
many queries	are	attribute	even not sentences	3100-2
many queries	including	action	even not sentences	3100-2
The technique	of	constraint	1	3100-3
The technique	-	sequential	1	3100-3
1		sequential	0 laws	3100-3
0 laws	to	constraint	languages	3100-3
0 laws	has been extended successfully	action	languages	3100-3
languages	beyond	constraint	while	3100-3
Many languages		sequential	that	3100-4
that	-	sequential	1	3100-4
that	do not have	action	1	3100-4
1		sequential	0 laws	3100-4
0 laws	are also known	attribute	such as	3100-4
order		sequential	existential logic	3100-4
existential logic	see	action	Exercise 17.21	3100-4
The precise border		sequential	that	3100-5
that	separates	action	languages	3100-5
languages		sequential	that	3100-5
that	-	sequential	1	3100-5
that	have	action	1	3100-5
1		sequential	0 laws	3100-5
0 laws	from	constraint	that	3100-5
that	to	constraint	an area	3100-5
that	and	conjunctive	an area	3100-5
that	and	conjunctive	an area	3100-5
that	do not has yet	attribute	interesting	3100-5
that	be determined	attribute	interesting	3100-5
that	remains	attribute	interesting	3100-5
an area	of	constraint	research	3100-5
The Impact	of	constraint	Order	3101-1
Order	In	constraint	this section	3101-1
this section		sequential	we	3101-1
we	in	constraint	detail	3101-1
we	consider	action	detail	3101-1
detail		sequential	the impact	3101-1
the impact	of	constraint	order	3101-1
order	on	constraint	the expressive power	3101-1
the expressive power	of	constraint	query languages	3101-1
<B>	As	constraint	the beginning	3101-2
<B>	at	constraint	the beginning	3101-2
<B>	mentioned	action	the beginning	3101-2
the beginning	of	constraint	this chapter	3101-2
this chapter		sequential	we	3101-2
we	view	action	the assumption	3101-2
the assumption	of	constraint	order	3101-2
order	as	constraint	some sense	3101-2
order	in	constraint	some sense	3101-2
some sense	suspending	action	the data independence principle	3101-2
the data independence principle	in	constraint	a database	3101-2
<B>	Because	constraint	data independence	3101-3
data independence	is	attribute	one	3101-3
one	of	constraint	the main guiding principles	3101-3
the main guiding principles	of	constraint	the pure relational model	3101-3
the pure relational model		sequential	it	3101-3
it	to	constraint	its consequences	3101-3
it	is	attribute	important	3101-3
it	understand	action	its consequences	3101-3
its consequences	in	constraint	the expressiveness	3101-3
the expressiveness	and	conjunctive	complexity	3101-3
complexity	of	constraint	query languages	3101-3
P succ b c b b b		sequential	d b c c	3102-1
d b c c		sequential	d	3102-1
d		sequential	c	3102-1
c		sequential	d d b	3102-1
d d b		sequential	Figure 17.5	3102-1
Figure 17.5		sequential	languages	3102-1
languages	are known	action	that	3102-1
that	express precisely	action	the queries	3102-1
the queries	of	constraint	those complexity classes	3102-1
<B>	With	constraint	order	3102-2
order		sequential	there	3102-2
there	are	attribute	numerous such results	3102-2
We	present	action	two	3102-3
two	of	constraint	the most prominent ones	3102-3
We	by	constraint	the notion	3103-1
We	begin	action	the notion	3103-1
We	making	action	the notion	3103-1
the notion	of	constraint	an ordered database more precise	3103-1
A database	to	constraint	it	3103-2
A database	if	constraint	it	3103-2
A database	is said	action	it	3103-2
A database	be ordered	action	it	3103-2
it	includes	action	a designated binary relation succ	3103-2
a designated binary relation succ		sequential	that	3103-2
that	provides	action	a successor relation	3103-2
a successor relation	on	constraint	the constants	3103-2
the constants	in	constraint	the database	3103-2
the constants	occurring	action	the database	3103-2
A query	on	constraint	an ordered database	3103-3
an ordered database	is	attribute	a query	3103-3
a query		sequential	whose input database schema	3103-3
whose input database schema	over	constraint	only the ordered instances	3103-3
whose input database schema	and	conjunctive	only the ordered instances	3103-3
whose input database schema	contains	attribute	succ	3103-3
whose input database schema	ranges	action	only the ordered instances	3103-3
only the ordered instances	of	constraint	the input database schema	3103-3
Example		sequential	17.4.1	3104-1
An ordered instance	of	constraint	R	3104-2
R	in	constraint	Fig	3104-2
R	is represented	action	Fig	3104-2
17.5		sequential	17.5	3104-3
<B>	According to	action	succ	3104-4
succ	is	attribute	the first constant	3104-4
b	is	attribute	the successor	3104-4
the successor	of	constraint	c	3104-4
c	is	attribute	the successor	3104-4
the successor	of	constraint	b	3104-4
b	and	conjunctive	d	3104-4
d	is	attribute	the successor	3104-4
the successor	of	constraint	c	3104-4
We	now consider	action	the power	3105-1
the power	of	constraint	fixpoint	3105-1
fixpoint	while	constraint	ordered databases	3105-1
fixpoint	on	constraint	ordered databases	3105-1
fixpoint	and	conjunctive	ordered databases	3105-1
<B>	In	constraint	we	3105-2
we	prove	action	the fundamental result	3105-2
the fundamental result		sequential	that fixpoint	3105-2
that fixpoint	expresses	action	precisely qptime	3105-2
precisely qptime	on	constraint	ordered databases	3105-2
ordered databases	while	constraint	expresses	3105-2
ordered databases	and	conjunctive	expresses	3105-2
expresses		sequential	precisely qpspace	3105-2
precisely qpspace	on	constraint	ordered databases	3105-2
<B>	that	constraint	order	3105-3
<B>	shows	action	order	3105-3
order	has	action	a impact	3105-3
order	far reaching	action	a impact	3105-3
a impact	on	constraint	expressiveness	3105-3
expressiveness	beyond	constraint	isolated cases	3105-3
isolated cases		sequential	the even query	3105-3
the characterization	of	constraint	qptime	3105-4
qptime	by	constraint	fixpoint	3105-4
fixpoint	with	constraint	the order assumption	3105-4
the order assumption	More broadly provides	action	an elegant logical description	3105-4
an elegant logical description	of	constraint	what	3105-4
what	have traditionally been considered	action	the tractable problems	3105-4
<B>	Beyond	constraint	databases	3105-5
databases	to	constraint	logic	3105-5
databases	both	conjunctive	logic	3105-5
databases	is	attribute	significant	3105-5
logic	and	conjunctive	complexity	3105-5
complexity		sequential	theory	3105-5
Theorem		sequential	17.4.2	3106-1
Proof	Consider a	action	<B>	3107-1
We	have already seen	action	that fixpoint ⊆ qptime	3107-2
that fixpoint ⊆ qptime	see	action	Exercise 17.11	3107-2
Exercise 17.11	and	conjunctive	it	3107-2
it	to	constraint	all qptime queries	3107-2
it	that	constraint	all qptime queries	3107-2
it	so remains	action	all qptime queries	3107-2
it	show	action	all qptime queries	3107-2
all qptime queries	on	constraint	ordered databases	3107-2
ordered databases	in	constraint	fixpoint	3107-2
ordered databases	are	attribute	expressible	3107-2
<B>	Let	action	q	3107-3
q	be	attribute	a query	3107-3
a query	on	constraint	a database	3107-3
a database	with	constraint	schema R	3107-3
schema R		sequential	that	3107-3
that	that	constraint	q	3107-3
that	includes	attribute	succ	3107-3
q	is	attribute	First Order	3107-3
First Order		sequential	Fixpoint	3107-3
Fixpoint	While	constraint	qptime	3107-3
Fixpoint	in	constraint	qptime	3107-3
Fixpoint	and	conjunctive	qptime	3107-3
qptime	on	constraint	the ordered instances	3107-3
the ordered instances	of	constraint	R	3107-3
<B>	In	constraint	this section	3107-4
this section		sequential	encodings	3107-4
encodings	of	constraint	ordered instances	3107-4
ordered instances	with	constraint	respect	3107-4
ordered instances	are	attribute	respect	3107-4
respect	to	constraint	the enumeration	3107-4
the enumeration	of	constraint	constants	3107-4
constants	by	constraint	succ	3107-4
constants	provided	action	succ	3107-4
succ	see also	action	Chapter 16	3107-4
<B>	Because	constraint	q	3107-5
q		sequential	I	3107-5
I	has	action	size polynomial	3107-5
size polynomial	in	constraint	I	3107-5
I		sequential	a TM M	3107-5
a TM M	can be constructed	action	that	3107-5
that	in	constraint	polynomial time	3107-5
that	runs	action	polynomial time	3107-5
polynomial time	on	constraint	input enc	3107-5
polynomial time	and	conjunctive	input enc	3107-5
input enc		sequential	I	3107-5
I	as	constraint	output enc	3107-5
I	produces	action	output enc	3107-5
output enc		sequential	q	3107-5
q		sequential	I	3107-5
We	now describe	action	the construction	3107-6
the construction	of	constraint	a CALC +µ+ query qM	3107-6
a CALC +µ+ query qM		sequential	that	3107-6
that	to	constraint	q	3107-6
that	is	attribute	equivalent	3107-6
q	on	constraint	ordered instances	3107-6
ordered instances	of	constraint	R	3107-6
The fixpoint query qM		sequential	we	3108-1
we	construct	action	ordered input I	3108-1
we	when given	action	ordered input I	3108-1
ordered input I	in	constraint	three phases	3108-1
ordered input I	will operate	action	three phases	3108-1
three phases		sequential	α	3108-1
α	construct	action	an encoding	3108-1
an encoding	of	constraint	I	3108-1
I		sequential	that	3108-1
that	to	constraint	M	3108-1
that	can be used	action	M	3108-1
that	simulate	action	M	3108-1
M		sequential	β	3108-1
β	simulate	action	M	3108-1
M	and	conjunctive	the output	3108-1
M	γ decode	action	the output	3108-1
the output	of	constraint	M	3108-1
<B>	that	constraint	this restriction	3108-2
<B>	Note	action	this restriction	3108-2
this restriction	to	constraint	which	3108-2
this restriction	does not apply	action	which	3108-2
which	simplifies	action	the simulation	3108-2
the simulation	in	constraint	that case	3108-2
We	next describe	action	the encoding	3109-1
the encoding	in	constraint	the simulation	3109-1
the encoding	used	action	the simulation	3109-1
the simulation	of	constraint	M	3109-1
<B>	Representing	action	a tape	3110-1
<B>	Because	constraint	the tape	3110-2
the tape	is	attribute	infinite	3110-2
we	only represent	action	the finite portion	3110-2
the finite portion	in	constraint	length	3110-2
length		sequential	that	3110-2
that	is potentially used	action	<B>	3110-2
We	need	action	a way	3110-3
a way	to	constraint	each cell	3110-3
a way	identify	action	each cell	3110-3
each cell	of	constraint	the tape	3110-3
<B>	Let	action	nc	3110-4
nc	be	attribute	the number	3110-4
the number	of	constraint	constants	3110-4
constants	in	constraint	I	3110-4
<B>	Because	constraint	M	3110-5
M	in	constraint	polynomial time	3110-5
M	runs	action	polynomial time	3110-5
polynomial time		sequential	there	3110-5
there	is	attribute	some k such	3110-5
some k such	that	constraint	M	3110-5
M	on	constraint	input	3110-5
input		sequential	enc	3110-5
enc		sequential	I	3110-5
I	takes	action	time	3110-5
time		sequential	nk	3110-5
nk	and	conjunctive	thus ≤ tape cells	3110-5
thus ≤ tape cells	see	action	also c	3110-5
also c		sequential	nkc Exercise 16.12	3110-5
nkc Exercise 16.12	in	constraint	the previous chapter	3110-5
<B>	Consider	action	the world	3110-6
the world	of	constraint	k tuples	3110-6
k tuples	with	constraint	entries	3110-6
entries	in	constraint	the constants	3110-6
the constants	from	constraint	I	3110-6
<B>	that	constraint	there	3110-7
<B>	Note	action	there	3110-7
there	are	attribute	nk such tuples	3110-7
nk such tuples	that	constraint	they	3110-7
nk such tuples	and	conjunctive	they	3110-7
they		sequential	lexicographically c	3110-7
lexicographically c	can be ordered	attribute	succ	3110-7
lexicographically c	using	attribute	succ	3110-7
each cell	by	constraint	a k tuple	3110-8
each cell	Thus can be uniquely identified	action	a k tuple	3110-8
a k tuple	of	constraint	constants	3110-8
constants	from	constraint	I	3110-8
One	by	constraint	a fixpoint query	3110-9
One	can define	action	a fixpoint query	3110-9
a fixpoint query		sequential	2 k ary	3110-9
2 k ary		sequential	a relation	3110-9
a relation		sequential	succ k	3110-9
succ k	providing	action	the successor relation	3110-9
the successor relation	on	constraint	k tuples	3110-9
k tuples	in	constraint	the lexicographic order	3110-9
the lexicographic order	by	constraint	succ	3110-9
the lexicographic order	induced	action	succ	3110-9
succ	see	action	Exercise 17.23a	3110-9
The ordered k- tuples	thus allow	action	us	3110-10
us	to	constraint	a sequence	3110-10
us	represent	action	a sequence	3110-10
a sequence	of	constraint	cells	3110-10
cells	and	conjunctive	M	3110-10
M		sequential	hence tape	3110-10
<B>	Representing	action	all the configurations	3111-1
<B>	that	constraint	one	3111-2
<B>	Note	action	one	3111-2
one	can not remove	action	the tuples	3111-2
the tuples	representing	action	old configurations	3111-2
old configurations	of	constraint	M	3111-2
M	due to	constraint	the inflationary nature	3111-2
the inflationary nature	of	constraint	fixpoint computations	3111-2
one	Thus represents	action	all the configurations	3111-3
all the configurations	in	constraint	a single relation	3111-3
<B>	To	constraint	a particular configuration	3111-4
<B>	distinguish	action	a particular configuration	3111-4
a particular configuration	at	constraint	time	3111-4
time		sequential	i	3111-4
i		sequential	i	3111-4
i	≤	action	nk	3111-4
nk		sequential	c	3111-4
c		sequential	k	3111-4
k		sequential	columns	3111-4
columns	as	constraint	timestamp	3111-4
columns	are used	action	timestamp	3111-4
<B>	to	constraint	track	3111-5
<B>	keep	action	track	3111-5
track	of	constraint	the sequence	3111-5
the sequence	of	constraint	configurations	3111-5
configurations	in	constraint	a computation	3111-5
a computation	of	constraint	M	3111-5
M		sequential	one	3111-5
one	Thus can use	action	2 k	3111-5
2 k	+	sequential	2	3111-5
2		sequential	ary	3111-5
ary		sequential	a relation RM where	3111-5
<B>	that	constraint	we	3112-1
<B>	Note	action	we	3112-1
we	with	constraint	a double encoding	3112-1
we	now are dealing	action	a double encoding	3112-1
<B>	To	constraint	this situation	3113-1
<B>	but	conjunctive	this situation	3113-1
<B>	illustrate	attribute	simple	3113-1
this situation		sequential	we	3113-1
we	consider	action	an example	3113-1
<B>	Let	action	R	3114-1
R	=	sequential	P	3114-1
P		sequential	}	3114-1
}	and	conjunctive	I	3114-1
}	let	action	I	3114-1
I	be	attribute	the ordered instance	3114-1
the ordered instance	of	constraint	R	3114-1
R	in	constraint	Fig	3114-1
R	represented	action	Fig	3114-1
17.5		sequential	17.5	3114-2
enc		sequential	I	3114-3
I	in	constraint	Fig	3114-3
I	Then is represented	action	Fig	3114-3
17.6		sequential	17.6	3114-4
We	without	constraint	loss	3114-5
We	assume	action	loss	3114-5
loss	of	constraint	generality	3114-5
generality	that	constraint	symbols	3114-5
symbols	in	constraint	the tape alphabet	3114-5
the tape alphabet	and	conjunctive	the states	3114-5
the states	of	constraint	M	3114-5
M	in	constraint	dom	3114-5
M	are	attribute	dom	3114-5
Parts	of	constraint	the first two configurations	3114-6
the first two configurations	in	constraint	the relation	3114-6
the first two configurations	are represented	action	the relation	3114-6
the relation	in	constraint	Fig	3114-6
the relation	shown	action	Fig	3114-6
17.7		sequential	17.7	3114-7
The representation	that	constraint	k	3114-8
The representation	assumes	action	k	3114-8
k	=	sequential	4	3114-8
4		sequential	the arity	3114-8
the arity	of	constraint	the relation	3114-8
the relation	is	attribute	so 10	3114-8
<B>	Because	constraint	single volume	3114-9
<B>	is	attribute	single volume	3114-9
single volume		sequential	a book	3114-9
a book		sequential	only part	3114-9
only part	of	constraint	the relation	3114-9
the relation	is shown	action	<B>	3114-9
<B>		sequential	we	3114-10
we	show	action	the first tuples	3114-10
the first tuples	from	constraint	the representation	3114-10
the representation	of	constraint	the P	3114-10
the P		sequential	1	3114-10
1	#	sequential	0	3114-10
0	# 10	sequential	1	3114-10
1	#	sequential	1	3114-10
1	# 11	sequential	10	3114-10
10	# # 11	sequential	0	3114-10
0		sequential	11 succ	3114-10
11 succ	#	sequential	1	3114-10
1	#	sequential	0	3114-10
0		sequential	0	3114-10
0	#	sequential	1	3114-10
1		sequential	1	3114-10
1	#	sequential	10	3114-10
10		sequential	10	3114-10
10	#	sequential	11	3114-10
11		sequential	Figure	3114-10
Figure		sequential	17.6	3114-10
17.6		sequential	Encoding	3114-10
Encoding	of	constraint	I	3114-10
I	and	conjunctive	u	3114-10
u	on	constraint	a TM tape first two configurations	3114-10
It	that	constraint	the original state	3114-11
It	is assumed	action	the original state	3114-11
the original state	and	conjunctive	the head	3114-11
the original state	is	attribute	s	3114-11
the head	to	constraint	the first cell	3114-11
the head	points	action	the first cell	3114-11
the first cell	of	constraint	the tape	3114-11
the tape	that	constraint	that state	3114-11
the tape	in	constraint	that state	3114-11
the tape	and	conjunctive	that state	3114-11
that state		sequential	the head	3114-11
the head	to	constraint	P	3114-11
the head	moves	attribute	the right	3114-11
the head	changing	action	P	3114-11
P	to	constraint	0	3114-11
0	and	conjunctive	the machine	3114-11
the machine	to	constraint	state	3114-11
the machine	goes	action	state	3114-11
<B>	Observe also	action	the numbering	3114-12
the numbering	of	constraint	tape cells	3114-12
tape cells		sequential	<B>	3114-12
<B>	.	sequential	<B>	3114-13
<B>	.	sequential	<B>	3114-14
<B>		sequential	a c	3114-15
a c		sequential	d	3114-15
d		sequential	<B>	3114-15
We	can now describe more precisely	action	the three phases	3115-1
the three phases	of	constraint	the operation	3115-1
the operation	of	constraint	qM	3115-1
We	sketch	action	the construction	3116-1
the construction	of	constraint	the fixpoint queries	3116-1
the fixpoint queries	realizing	action	α	3116-1
α	and	conjunctive	β	3116-1
β	and	conjunctive	we	3116-1
we	leave	action	γ	3116-1
γ	as	constraint	an exercise	3116-1
an exercise		sequential	17.23	3116-1
<B>	Consider	action	phase	3117-1
phase		sequential	α	3117-1
<B>	that	constraint	each constant	3117-2
<B>	Recall	action	each constant	3117-2
each constant	on	constraint	the tape	3117-2
each constant	is encoded	action	the tape	3117-2
the tape	of	constraint	M	3117-2
M	as	constraint	the binary representation	3117-2
the binary representation	of	constraint	its rank	3117-2
its rank	in	constraint	the successor relation succ	3117-2
the successor relation succ		sequential	e.g. c	3117-2
e.g. c	as	constraint	10	3117-2
<B>	To	constraint	the encoding	3117-3
<B>	perform	action	the encoding	3117-3
the encoding	of	constraint	the initial configuration	3117-3
the initial configuration		sequential	it	3117-3
it	to	constraint	an auxiliary relation	3117-3
it	is	attribute	useful first	3117-3
it	construct	action	an auxiliary relation	3117-3
an auxiliary relation		sequential	that	3117-3
that	provides	action	the encoding	3117-3
the encoding	of	constraint	<B>	3117-3
<B>	Because	constraint	there	3117-4
there	are	attribute	nc constants	3117-4
nc constants		sequential	the code	3117-4
the code	of	constraint	each constant	3117-4
each constant	requires	action	≤ ⌈log	3117-4
≤ ⌈log		sequential	nc	3117-4
nc		sequential	bits	3117-4
bits	than	constraint	nc	3117-4
bits	and	conjunctive	nc	3117-4
nc		sequential	bits	3117-4
We	can therefore use	action	a ternary relation constant coding	3117-5
a ternary relation constant coding	to	constraint	the encoding	3117-5
a ternary relation constant coding	record	action	the encoding	3117-5
A tuple		sequential	y	3117-6
y		sequential	x z	3117-6
x z	in	constraint	that relation	3117-6
that relation	that	constraint	the kth bit	3117-6
that relation	indicates	action	the kth bit	3117-6
the kth bit	of	constraint	the encoding	3117-6
the encoding	of	constraint	constant x	3117-6
constant x	is	attribute	z	3117-6
z		sequential	k	3117-6
k	is	attribute	where the rank	3117-6
where the rank	of	constraint	constant y	3117-6
constant y	in	constraint	the succ relation	3117-6
<B>	For	constraint	instance	3117-7
instance		sequential	the relation	3117-7
the relation	_	sequential	coding	3117-7
coding	to	constraint	the succ	3117-7
coding	corresponding	action	the succ	3117-7
the succ	in	constraint	Fig	3117-7
17.5	in	constraint	Fig	3117-8
17.5	is represented	action	Fig	3117-8
17.8		sequential	17.8	3117-9
The tuples c		sequential	1	3117-10
1	and	conjunctive	c	3117-10
c		sequential	b	3117-10
b		sequential	0	3117-10
0	for	constraint	instance	3117-10
0	indicate	action	instance	3117-10
instance		sequential	that c	3117-10
that c	as	constraint	10	3117-10
that c	is encoded	action	10	3117-10
It	that	constraint	coding	3117-11
It	_	sequential	coding	3117-11
It	is easily seen	attribute	constant	3117-11
coding	from	constraint	succ	3117-11
coding	is	attribute	definable	3117-11
succ	by	constraint	a fixpoint query	3117-11
a fixpoint query	see	action	Exercise	3117-11
Exercise		sequential	17.23 b	3117-11
<B>	With	constraint	relation	3118-1
relation	_	sequential	coding	3118-1
coding	constructed	action	the task	3118-1
the task	of	constraint	the encoding	3118-1
the task	computing	action	the encoding	3118-1
the encoding	of	constraint	I	3118-1
I	and	conjunctive	u	3118-1
u	into	constraint	RM	3118-1
RM	is	attribute	straightforward	3118-1
We	will illustrate	attribute	this	3118-2
We	using again	action	the example	3118-2
the example	in	constraint	Fig	3118-2
17.5		sequential	17.5	3118-3
<B>	To	constraint	relation P	3118-4
<B>	encode	action	relation P	3118-4
relation P		sequential	one steps	3118-4
one steps	through	constraint	all 3 tuples	3118-4
all 3 tuples	of	constraint	constants	3118-4
constants	and	conjunctive	checks	3118-4
checks	if	constraint	a tuple	3118-4
a tuple	in	constraint	P	3118-4
P	has been reached	action	<B>	3118-4
<B>	To	constraint	the 3 tuples	3118-5
<B>	through	constraint	the 3 tuples	3118-5
<B>	step	action	the 3 tuples	3118-5
the 3 tuples		sequential	one	3118-5
one	first constructs	action	the successor relation	3118-5
the successor relation		sequential	succ 3	3118-5
succ 3	on	constraint	3 tuples	3118-5
The first tuple	in	constraint	P	3118-6
P		sequential	that	3118-6
that	is	attribute	b	3118-6
that	is reached	action	b	3118-6
b		sequential	<B>	3118-6
17.7		sequential	17.7	3118-7
<B>	proceeds	action	the next tuples	3118-8
<B>	yielding	action	the next tuples	3118-8
the next tuples	in	constraint	Fig	3118-8
17.7		sequential	17.7	3118-9
The binary representation	for	constraint	b	3118-10
The binary representation	of	constraint	b	3118-10
b		sequential	a c	3118-10
a c	from	constraint	relation	3118-10
a c	is obtained	action	relation	3118-10
relation	_	sequential	<B>	3118-10
<B>	by	constraint	the next 3 tuple	3118-11
<B>	to	constraint	the next 3 tuple	3118-11
<B>	proceeds	action	the next 3 tuple	3118-11
<B>	moving	action	the next 3 tuple	3118-11
It	to	constraint	the reader	3118-12
It	is left	action	the reader	3118-12
the reader	to	constraint	the details	3118-12
the reader	complete	action	the details	3118-12
the details	of	constraint	the fixpoint query	3118-12
the fixpoint query	constructing	action	RM	3118-12
RM	see	action	Exercise	3118-12
Exercise		sequential	17.23	3118-12
17.23		sequential	c	3118-12
Several additional relations	to	constraint	bookkeeping purposes	3118-13
Several additional relations	for	constraint	bookkeeping purposes	3118-13
Several additional relations	have	action	bookkeeping purposes	3118-13
Several additional relations	be used	action	bookkeeping purposes	3118-13
<B>	For	constraint	instance	3118-14
instance	through	constraint	the tuples	3118-14
instance	when stepping	action	the tuples	3118-14
the tuples	in	constraint	one	3118-14
one	must keep	action	track	3118-14
track	of	constraint	the last tuple	3118-14
the last tuple		sequential	that	3118-14
that	has been processed	action	<B>	3118-14
We	next outline	action	the construction	3119-1
the construction	for	constraint	β	3119-1
One	must simulate	action	the computation	3119-2
the computation	of	constraint	M	3119-2
M	from	constraint	the initial configuration	3119-2
M	starting	action	the initial configuration	3119-2
the initial configuration	in	constraint	RM	3119-2
the initial configuration	represented	action	RM	3119-2
<B>	To	constraint	a new configuration	3119-3
<B>	construct	action	a new configuration	3119-3
a new configuration	from	constraint	the current one	3119-3
the current one		sequential	one	3119-3
one	must simulate	action	a move	3119-3
a move	of	constraint	M	3119-3
b b b b d b b b b b b b c b b		sequential	r	3120-1
r		sequential	b c	3120-1
b c		sequential	d b	3120-1
d b		sequential	c b	3120-1
c b		sequential	c b b c	3120-1
c b b c		sequential	c b c d	3120-1
Figure		sequential	17.7	3121-1
17.7		sequential	Coding	3121-1
Coding	of	constraint	part	3121-1
part	of	constraint	the first two configurations	3121-1
the first two configurations		sequential	CALC	3121-1
CALC	+	sequential	µ+	3121-1
Each step	of	constraint	the new configuration	3121-2
Each step	consists	action	the new configuration	3121-2
Each step	defining	action	the new configuration	3121-2
the new configuration	from	constraint	the current one	3121-2
the current one	timestamping	action	it	3121-2
it	and	conjunctive	it	3121-2
it	adding	action	it	3121-2
it	to	constraint	RM	3121-2
<B>	with	constraint	a CALC formula	3121-3
<B>	can be done	action	a CALC formula	3121-3
<B>	For	constraint	instance	3121-4
instance	suppose	action	the current state	3121-4
the current state	of	constraint	M	3121-4
M	is	attribute	q	3121-4
q		sequential	the content	3121-4
the content	of	constraint	the current cell	3121-4
the current cell	is	attribute	0	3121-4
0	and	conjunctive	the corresponding move	3121-4
the corresponding move	of	constraint	M	3121-4
M	to	constraint	0	3121-4
M	is	attribute	0	3121-4
M	change	action	0	3121-4
0	to	constraint	1	3121-4
1	and	conjunctive	states	3121-4
1	move right	action	states	3121-4
1	change	action	states	3121-4
states	from	constraint	q	3121-4
q	to	constraint	r.	3121-4
The tuples	describing	action	the new configuration	3122-1
the new configuration	of	constraint	M	3122-1
M	are	attribute	t	3122-1
t	if	constraint	i	3122-1
i	=	sequential	i	3122-1
i	=	sequential	j	3122-1
j	and	conjunctive	x	3122-1
x		sequential	y	3122-1
y		sequential	∈ RM	3122-1
∈ RM		sequential	t	3122-1
t		sequential	j	3122-1
j		sequential	1	3122-1
1		sequential	0	3122-1
0		sequential	t	3122-1
t		sequential	′	3122-1
′		sequential	j	3122-1
j		sequential	′	3122-1
′		sequential	x	3122-1
x	if	constraint	j	3122-1
x	r	action	j	3122-1
j	′	sequential	x	3122-1
x		sequential	0 ∈ RM	3122-1
<B>	In	constraint	other words	3123-1
other words	that	constraint	the cells	3123-1
other words	a says	action	the cells	3123-1
the cells	than	constraint	the j th cell	3123-1
the j th cell	and	conjunctive	the next cell	3123-1
the next cell	that	constraint	the content	3123-1
the next cell	remain	attribute	unchanged	3123-1
the next cell	b says	action	the content	3123-1
the content	of	constraint	cell j	3123-1
cell j	from	constraint	0	3123-1
cell j	changes	action	0	3123-1
0	to	constraint	1	3123-1
1	and	conjunctive	the head	3123-1
the head	to	constraint	the j th cell	3123-1
the head	no longer points	action	the j th cell	3123-1
the j th cell		sequential	c	3123-1
c	that	constraint	the head	3123-1
c	says	action	the head	3123-1
the head	to	constraint	the right adjacent cell	3123-1
the head	points	action	the right adjacent cell	3123-1
the right adjacent cell		sequential	the new state	3123-1
the new state	is	attribute	r	3123-1
r	and	conjunctive	the content	3123-1
the content	of	constraint	that cell	3123-1
that cell	is	attribute	unchanged	3123-1
<B>	through	constraint	c	3123-2
c	by	constraint	a CALC formula	3123-2
c	Clearly a can be expressed	action	a CALC formula	3123-2
a CALC formula		sequential	Exercise	3123-2
Exercise		sequential	17.23d	3123-2
One such formula	for	constraint	each move	3123-3
One such formula	is needed	action	each move	3123-3
each move	of	constraint	M	3123-3
M	and	conjunctive	the formula	3123-3
the formula	to	constraint	the finite set	3123-3
the formula	corresponding	action	the finite set	3123-3
the finite set	of	constraint	possible moves	3123-3
possible moves	by	constraint	their disjunction	3123-3
possible moves	is obtained	action	their disjunction	3123-3
We	have outlined	action	queries	3124-1
queries		sequential	that	3124-1
that	realize	action	α	3124-1
α	and	conjunctive	β	3124-1
β	perform	action	the encoding	3124-1
the encoding	to	constraint	M	3124-1
the encoding	needed	action	M	3124-1
the encoding	run	action	M	3124-1
M	and	conjunctive	the run	3124-1
M	simulate	action	the run	3124-1
the run	of	constraint	M	3124-1
<B>	Using	action	these fixpoint queries	3124-2
these fixpoint queries	and	conjunctive	their analog	3124-2
their analog	for	constraint	phase	3124-2
phase		sequential	γ	3124-2
γ		sequential	it	3124-2
it	to	constraint	the fixpoint query qM	3124-2
it	is	attribute	now easy	3124-2
it	construct	action	the fixpoint query qM	3124-2
the fixpoint query qM		sequential	that	3124-2
that	carries out	action	the complete computation	3124-2
the complete computation	of	constraint	q	3124-2
<B>	completes	action	the proof	3124-3
the proof	of	constraint	<B>	3124-3
The construction	for	constraint	<B>	3125-1
The construction	is	attribute	b similar	3125-1
The difference	in	constraint	the fact	3125-2
The difference	lies	action	the fact	3125-2
the fact	that	constraint	a while computation	3125-2
a while computation	unlike	constraint	fixpoint computations	3125-2
a while computation	be	attribute	need not inflationary	3125-2
<B>	simplifies	action	the simulation	3125-3
<B>	For	constraint	instance	3126-1
instance		sequential	only the tuples	3126-1
only the tuples	to	constraint	the current configuration	3126-1
only the tuples	corresponding	action	the current configuration	3126-1
the current configuration	of	constraint	M	3126-1
M	in	constraint	RM	3126-1
M	are kept	action	RM	3126-1
RM		sequential	Exercise	3126-1
Exercise		sequential	17.24	3126-1
First Order		sequential	Fixpoint	3127-1
Fixpoint	While	constraint	closure	3127-1
Fixpoint	and	conjunctive	closure	3127-1
closure		sequential	one	3127-1
one	can obtain	action	languages	3127-1
languages	expressing	action	qlogspace	3127-1
qlogspace	and	conjunctive	qnlogspace	3127-1
qnlogspace	on	constraint	ordered databases	3127-1
Theorem 17.4.2	that	constraint	the presence	3128-1
Theorem 17.4.2	implies	action	the presence	3128-1
the presence	of	constraint	order	3128-1
order	in	constraint	increased expressive power	3128-1
order	results	action	increased expressive power	3128-1
increased expressive power	for	constraint	the fixpoint	3128-1
the fixpoint	while	constraint	queries	3128-1
the fixpoint	and	conjunctive	queries	3128-1
<B>	For	constraint	these languages	3128-2
these languages	for	constraint	instance	3128-2
these languages	is easily seen	action	instance	3128-2
instance	by	constraint	fixpoint	3128-2
instance	even can be expressed	action	fixpoint	3128-2
fixpoint		sequential	an order	3128-2
an order	when is provided	action	<B>	3128-2
<B>	For	constraint	weaker languages	3128-3
weaker languages		sequential	the impact	3128-3
the impact	of	constraint	order	3128-3
order	to	constraint	<B>	3128-3
order	be	attribute	may harder	3128-3
order	see	action	<B>	3128-3
<B>	For	constraint	instance	3128-4
instance		sequential	it	3128-4
it	whether	constraint	the presence	3128-4
it	is	attribute	not obvious	3128-4
the presence	of	constraint	order	3128-4
order	in	constraint	increased expressive power	3128-4
order	results	action	increased expressive power	3128-4
increased expressive power	for	constraint	CALC	3128-4
The query	of	constraint	even no immediate help	3128-5
The query	is	attribute	even no immediate help	3128-5
even no immediate help	because	constraint	it	3128-5
it	by	constraint	CALC	3128-5
it	can not be expressed	action	CALC	3128-5
CALC	in	constraint	even the presence	3128-5
even the presence	of	constraint	order	3128-5
order		sequential	Exercise	3128-5
Exercise		sequential	17.8	3128-5
a more complicated query	on	constraint	CALC	3128-6
a more complicated query	to	constraint	CALC	3128-6
a more complicated query	that	constraint	CALC	3128-6
a more complicated query	based even	action	CALC	3128-6
a more complicated query	However can be used	action	CALC	3128-6
a more complicated query	show	action	CALC	3128-6
CALC	with	constraint	an order	3128-6
CALC	does indeed become	attribute	more expressive	3128-6
an order		sequential	Exercise	3128-6
Exercise		sequential	17.27	3128-6
<B>	Because	constraint	the CALC	3128-7
the CALC	on	constraint	ordered instances	3128-7
the CALC	queries	action	ordered instances	3128-7
ordered instances	in	constraint	ac0	3128-7
ordered instances	remain	action	ac0	3128-7
ac0	in	constraint	there	3128-7
ac0	that	constraint	there	3128-7
ac0	shows	attribute	particular	3128-7
there	are	attribute	queries	3128-7
queries	in	constraint	ac0	3128-7
ac0	that	constraint	CALC	3128-7
CALC	can not express	action	<B>	3128-7
<B>	From	constraint	Chaos	3129-1
Chaos	to	constraint	Order	3129-1
Order		sequential	A Normal Form	3129-1
A Normal Form	for	constraint	<B>	3129-1
<B>	helps	action	us	3129-2
us	understand	action	the impact	3129-2
the impact	of	constraint	order	3129-2
order	and	conjunctive	the cost	3129-2
the cost	of	constraint	computation	3129-2
computation	without	constraint	order	3129-2
The normal form	that	constraint	query	3130-1
The normal form	while	constraint	query	3130-1
The normal form	says	attribute	each	3130-1
query	on	constraint	an unordered instance	3130-1
an unordered instance	to	constraint	a while query	3130-1
an unordered instance	can be reduced	action	a while query	3130-1
a while query	over	constraint	an ordered instance	3130-1
an ordered instance	via	constraint	a fixpoint query	3130-1
a while program	in	constraint	the normal form	3130-2
the normal form	of	constraint	two phases	3130-2
the normal form	More precisely consists	action	two phases	3130-2
<B>	is	attribute	a fixpoint query	3130-3
a fixpoint query		sequential	that	3130-3
that	performs	action	an analysis	3130-3
an analysis	of	constraint	the input	3130-3
It	computes	action	an equivalence relation	3130-4
an equivalence relation	on	constraint	tuples	3130-4
tuples		sequential	that	3130-4
that	is	attribute	a congruence	3130-4
a congruence	with	constraint	respect	3130-4
respect	to	constraint	the rest	3130-4
the rest	of	constraint	the computation	3130-4
the computation	in that	constraint	equivalent tuples	3130-4
equivalent tuples	throughout	constraint	the computation	3130-4
equivalent tuples	are treated identically	action	the computation	3130-4
each equivalence class	as	constraint	an indivisible block	3130-5
each equivalence class	Thus is treated	action	an indivisible block	3130-5
an indivisible block	of	constraint	tuples	3130-5
tuples		sequential	that	3130-5
that	in	constraint	the computation	3130-5
that	is never split later	action	the computation	3130-5
The fixpoint query	outputs	action	the equivalence classes	3130-6
the equivalence classes	in	constraint	some order	3130-6
some order	so that	constraint	each class	3130-6
each class	of	constraint	an integer	3130-6
each class	as	constraint	an integer	3130-6
each class	can be thought abstractly	action	an integer	3130-6
The second phase	of	constraint	a while query	3130-7
The second phase	consists	action	a while query	3130-7
a while query		sequential	that	3130-7
that	as	constraint	computing	3130-7
that	can be viewed	action	computing	3130-7
computing	on	constraint	an ordered database	3130-7
an ordered database	by	constraint	each equivalence class	3130-7
an ordered database	obtained	action	each equivalence class	3130-7
an ordered database	replacing	action	each equivalence class	3130-7
each equivalence class	in	constraint	the analysis phase	3130-7
each equivalence class	produced	action	the analysis phase	3130-7
the analysis phase	by	constraint	its corresponding integer	3130-7
The normal form	also allows	action	the clarification	3131-1
the clarification	of	constraint	the relationship	3131-1
the relationship	between	constraint	fixpoint	3131-1
fixpoint	and	conjunctive	while	3131-1
<B>	Because	constraint	ordered databases	3131-2
<B>	on	constraint	ordered databases	3131-2
ordered databases		sequential	the two languages	3131-2
the two languages	express	action	qptime	3131-2
qptime	and	conjunctive	qpspace	3131-2
qpspace		sequential	the languages	3131-2
the languages	on	constraint	ordered databases	3131-2
the languages	are	attribute	equivalent	3131-2
ordered databases	iff	constraint	ptime	3131-2
ptime		sequential	pspace	3131-2
What	about	constraint	the relationship	3131-3
the relationship	of	constraint	these languages	3131-3
these languages	without	constraint	the order assumption	3131-3
It	that	constraint	the normal form	3131-4
It	turns out	action	the normal form	3131-4
the normal form	to	constraint	this result	3131-4
the normal form	can be used	action	this result	3131-4
the normal form	extend	action	this result	3131-4
this result	to	constraint	the general case	3131-4
the general case		sequential	no order	3131-4
no order	is	attribute	when present	3131-4
We	do not describe	action	the normal form	3132-1
the normal form	in	constraint	detail	3132-1
detail	but	conjunctive	we	3132-1
we	provide	action	some intuition	3132-1
some intuition	on	constraint	a query	3132-1
a query	on	constraint	an unordered database	3132-1
an unordered database	to	constraint	a query	3132-1
an unordered database	how reduces	action	a query	3132-1
a query	on	constraint	an ordered database	3132-1
<B>	Consider	action	a while program q	3133-1
a while program q	and	conjunctive	a particular instance	3133-1
There	are	attribute	only finitely many CALC queries	3133-2
only finitely many CALC queries		sequential	that	3133-2
that	in	constraint	q	3133-2
that	are used	action	q	3133-2
q	and	conjunctive	the number	3133-2
the number	of	constraint	their variables	3133-2
their variables	by	constraint	some integer	3133-2
their variables	is bounded	action	some integer	3133-2
some integer	say	action	k	3133-2
<B>	For	constraint	a query	3133-3
a query	in	constraint	q	3133-3
q		sequential	R1	3133-3
<B>	.	sequential	<B>	3133-4
<B>	.	sequential	<B>	3133-5
Rn	that	constraint	R1	3133-6
Rn	indicates	action	R1	3133-6
<B>	.	sequential	<B>	3133-7
<B>	.	sequential	<B>	3133-8
Rn	are	attribute	the relation names	3133-9
the relation names	in	constraint	ϕ	3133-9
the relation names	occurring	action	ϕ	3133-9
<B>	Consider	action	the set J	3134-1
the set J	of	constraint	k- tuples	3134-1
k- tuples	with	constraint	the constants	3134-1
k- tuples	formed	action	the constants	3134-1
the constants	from	constraint	I	3134-1
we	between	constraint	tuples	3134-2
we	First can distinguish	action	tuples	3134-2
tuples	on	constraint	their presence I	3134-2
tuples	based	action	their presence I	3134-2
their presence I	in	constraint	absence from	3134-2
their presence I	or	conjunctive	absence from	3134-2
<B>	yields	action	a first par- tition	3134-3
a first par- tition	of	constraint	J	3134-3
<B>	Now using	action	the conjunctive queries	3134-4
the conjunctive queries	in	constraint	q	3134-4
the conjunctive queries	occurring	action	q	3134-4
q		sequential	we	3134-4
we	can iteratively refine	action	this partition	3134-4
this partition	in	constraint	the following way	3134-4
<B>	.	sequential	<B>	3134-5
<B>	.	sequential	<B>	3134-6
Rn	in	constraint	q	3134-7
Rn	occurring	action	q	3134-7
q	and	conjunctive	some blocks B1	3134-7
<B>	.	sequential	<B>	3134-8
<B>	.	sequential	<B>	3134-9
Bn	of	constraint	the current partition	3134-10
the current partition		sequential	B1	3134-10
<B>	.	sequential	<B>	3134-11
<B>	.	sequential	<B>	3134-12
Bn	and	conjunctive	B1	3134-13
<B>	.	sequential	<B>	3134-14
<B>	.	sequential	<B>	3134-15
Bn	have	action	nonempty intersection	3134-16
nonempty intersection	with	constraint	some block	3134-16
<B>	.	sequential	<B>	3134-17
<B>	.	sequential	<B>	3134-18
Bn	and	conjunctive	B′ ∩ ¬ϕ	3134-19
B′ ∩ ¬ϕ		sequential	B1	3134-19
<B>	.	sequential	<B>	3134-20
<B>	.	sequential	<B>	3134-21
Bn		sequential	Bn	3134-22
<B>	until	constraint	no further refinement	3134-23
<B>	is repeated	action	no further refinement	3134-23
no further refinement	occurs	action	a final partition	3134-23
no further refinement	yielding	action	a final partition	3134-23
a final partition	of	constraint	J	3134-23
the blocks	as	constraint	they	3134-24
the blocks	Furthermore can be numbered	action	they	3134-24
they	are produced	action	which	3134-24
which	provides	action	an ordering J1	3134-24
<B>	.	sequential	<B>	3134-25
<B>	.	sequential	<B>	3134-26
Jm	of	constraint	the blocks	3134-27
the blocks	of	constraint	the partition	3134-27
The entire computation	by	constraint	a fixpoint query	3134-28
The entire computation	can be performed	action	a fixpoint query	3134-28
a fixpoint query	from	constraint	q	3134-28
a fixpoint query	constructed	action	q	3134-28
It	to	constraint	two tuples u v	3135-1
It	that	constraint	two tuples u v	3135-1
It	is	attribute	important	3135-1
It	note	action	two tuples u v	3135-1
two tuples u v	in	constraint	one block	3135-1
one block	of	constraint	the final partition	3135-1
the final partition	by	constraint	the computation	3135-1
the final partition	can not be separated	action	the computation	3135-1
the computation	of	constraint	q	3135-1
q	on	constraint	input	3135-1
input		sequential	I	3135-1
I	at	constraint	each step	3135-1
each step	of	constraint	this computation	3135-1
this computation		sequential	each relation	3135-1
each relation	either	conjunctive	u	3135-1
each relation	both	conjunctive	u	3135-1
each relation	contains	action	u	3135-1
u	and	conjunctive	v	3135-1
v	or	conjunctive	none	3135-1
<B>	In	constraint	other words	3135-2
other words		sequential	each relation	3135-2
each relation	contains	action	a union	3135-2
a union	of	constraint	blocks	3135-2
blocks	of	constraint	the final partition	3135-2
one	Then can reduce	action	the original computation	3135-3
the original computation	to	constraint	an abstract computation q′	3135-3
an abstract computation q′	on	constraint	the integers	3135-3
the integers	by	constraint	the ith block	3135-3
the integers	replacing	action	the ith block	3135-3
the ith block	of	constraint	the partition	3135-3
the partition	by	constraint	integer	3135-3
integer		sequential	i	3135-3
the original query q	as	constraint	the composition	3135-4
the original query q	Thus can be rewritten	action	the composition	3135-4
the composition	of	constraint	a fixpoint query f	3135-4
a fixpoint query f	by	constraint	a while query q′	3135-4
a fixpoint query f	followed	action	a while query q′	3135-4
a while query q′		sequential	that	3135-4
that	on	constraint	an ordered input	3135-4
that	essentially operates	action	an ordered input	3135-4
<B>	Using	action	this normal form	3136-1
this normal form		sequential	one	3136-1
one	can show	action	the following Theorem 17.4.3	3136-1
Crux		sequential	Crux	3137-1
The normal form	for	constraint	<B>	3137-2
The normal form	is used	attribute	the	3137-2
Results		sequential	Theorem 17.4.2	3138-1
Theorem 17.4.2	that	constraint	the presence	3138-1
Theorem 17.4.2	show	action	the presence	3138-1
the presence	of	constraint	order	3138-1
order	of	constraint	the problems	3138-1
order	can solve	attribute	some	3138-1
the problems	of	constraint	expressiveness	3138-1
expressiveness	of	constraint	query languages	3138-1
<B>	as	constraint	a trade off	3138-2
<B>	can be interpreted	action	a trade off	3138-2
a trade off	between	constraint	expressiveness	3138-2
expressiveness	and	conjunctive	the data independence	3138-2
the data independence	by	constraint	the abstract interface	3138-2
the data independence	provided	action	the abstract interface	3138-2
the abstract interface	to	constraint	the database system	3138-2
We	conclude	action	this section	3138-3
this section	by	constraint	an alternative	3138-3
this section	considering	action	an alternative	3138-3
an alternative	to	constraint	order	3138-3
order	for	constraint	increasing expressive power	3138-3
It	on	constraint	the use	3138-4
It	is based	action	the use	3138-4
the use	of	constraint	nondeterminism	3138-4
We	will use	action	the following terminology	3139-1
A deterministic query	is	attribute	a classical query	3139-2
a classical query		sequential	that	3139-2
that	at	constraint	most one output	3139-2
that	always produces	action	most one output	3139-2
most one output	for	constraint	each input instance	3139-2
A nondeterministic query	is	attribute	a query	3139-3
a query		sequential	that	3139-3
that	may have	action	more than one possible outcome	3139-3
more than one possible outcome	on	constraint	a given input instance	3139-3
we	that	constraint	all possible outcomes	3139-4
we	Generally assume	action	all possible outcomes	3139-4
all possible outcomes	as	constraint	answers	3139-4
all possible outcomes	are	attribute	acceptable	3139-4
answers	to	constraint	the query	3139-4
<B>	For	constraint	example	3139-5
example		sequential	the query	3139-5
the query	Find	action	one cinema	3139-5
one cinema	showing	action	Casablanca	3139-5
Casablanca	is	attribute	nondeterministic	3139-5
<B>	Consider again	action	the query	3140-1
the query		sequential	which	3140-1
which	by	constraint	fixpoint	3140-1
which	is	attribute	even not expressible	3140-1
fixpoint	or	conjunctive	while	3140-1
The query	by	constraint	fixpoint	3140-2
The query	even is easily computed	action	fixpoint	3140-2
fixpoint	in	constraint	the presence	3140-2
the presence	of	constraint	order	3140-2
order	see	action	Exercise 17.25	3140-2
Another way	to	constraint	the difficulty	3140-3
Another way	circumvent	action	the difficulty	3140-3
the difficulty	of	constraint	computing even	3140-3
computing even	to	constraint	the determinism	3140-3
computing even	is	attribute	the determinism	3140-3
computing even	relax	action	the determinism	3140-3
the determinism	of	constraint	the query language	3140-3
<B>	If	constraint	one	3140-4
one	could choose	action	an arbitrary element	3140-4
one	whenever desired	action	an arbitrary element	3140-4
an arbitrary element	from	constraint	the set	3140-4
the set	would provide even	action	another way	3140-4
another way	of	constraint	the elements	3140-4
another way	enumerating	action	the elements	3140-4
the elements	of	constraint	the set	3140-4
the set	and	conjunctive	computing	3140-4
First Order		sequential	Fixpoint	3141-1
Fixpoint	While	constraint	R B R B R B	3141-1
Fixpoint	and	conjunctive	R B R B R B	3141-1
R B R B R B		sequential	R B R B	3141-1
R B R B		sequential	b b b c	3141-1
b b b c		sequential	c c b b b c b b b c b b b c	3141-1
c c b b b c b b b c b b b c		sequential	I	3141-1
I		sequential	I1	3141-1
I1		sequential	I2 I3 I4	3141-1
I2 I3 I4		sequential	Figure 17.9	3141-1
trade		sequential	The offs	3142-1
The offs	on	constraint	order	3142-1
The offs	based	action	order	3142-1
order	and	conjunctive	nondeterminism	3142-1
nondeterminism	as	constraint	it	3142-1
nondeterminism	are	attribute	not unrelated	3142-1
it	at	constraint	<B>	3142-1
it	may seem	action	<B>	3142-1
<B>	that	constraint	an order	3142-2
<B>	Suppose	action	an order	3142-2
an order	is given	action	<B>	3142-2
<B>	As	constraint	the data independence principle	3142-3
<B>	to	constraint	the data independence principle	3142-3
<B>	argued earlier	attribute	this	3142-3
<B>	comes down	action	the data independence principle	3142-3
<B>	suspending	action	the data independence principle	3142-3
the data independence principle	and	conjunctive	the internal representation	3142-3
the data independence principle	accessing	action	the internal representation	3142-3
<B>	In	constraint	the computation	3142-4
the computation	on	constraint	the particular order	3142-4
the computation	may depend	action	the particular order	3142-4
the particular order	accessed	action	<B>	3142-4
<B>	at	constraint	the conceptual level	3142-5
the conceptual level		sequential	the order	3142-5
the order	is	attribute	where not visible	3142-5
the mapping	by	constraint	the query	3142-5
the mapping	defined	action	the query	3142-5
the query	as	constraint	<B>	3142-5
the query	Then appears	attribute	nondeterministic	3142-5
Different outcomes	for	constraint	level	3142-6
Different outcomes	are	attribute	possible	3142-6
level		sequential	the same view	3142-6
the same view	of	constraint	the input	3142-6
trade		sequential	the offs	3142-7
the offs	on	constraint	order	3142-7
the offs	based	action	order	3142-7
order	on	constraint	determinism	3142-7
order	and	conjunctive	determinism	3142-7
order	relaxing	action	determinism	3142-7
determinism	Thus are intimately connected	action	<B>	3142-7
<B>	To	constraint	we	3143-1
<B>	illustrate	attribute	this	3143-1
we	exhibit	action	nondeterministic versions	3143-1
nondeterministic versions	of	constraint	the while	3143-1
the while	and	conjunctive	+µ	3143-1
the while	+	sequential	+µ	3143-1
+µ	+	sequential	CALC queries	3143-1
<B>	In	constraint	both cases	3143-2
both cases		sequential	we	3143-2
we	and	conjunctive	exactly the queries	3143-2
we	obtain	attribute	deterministic	3143-2
exactly the queries	in	constraint	polynomial space	3143-2
polynomial space		sequential	time	3143-2
Analogous results	for	constraint	lower complexity classes	3143-3
Analogous results	can be shown	action	lower complexity classes	3143-3
lower complexity classes	of	constraint	queries	3143-3
<B>	Consider first	action	the algebraic setting	3144-1
We	introduce	action	a new operator	3144-2
a new operator	called	action	witness	3144-2
witness		sequential	that	3144-2
that	provides	action	the nondeterminism	3144-2
<B>	To	constraint	the use	3144-3
<B>	illustrate	action	the use	3144-3
the use	of	constraint	this operator	3144-3
this operator	consider	action	the relation	3144-3
the relation		sequential	I	3144-3
I	in	constraint	Fig	3144-3
17.9		sequential	17.9	3144-4
An application	of	constraint	witness B	3144-5
witness B	to	constraint	I	3144-5
I	to	constraint	several results	3144-5
I	may lead	action	several results	3144-5
several results		sequential	witness B	3144-5
witness B		sequential	I	3144-5
I	either	conjunctive	I1	3144-5
I	is	attribute	I1	3144-5
I1		sequential	I2	3144-5
I2		sequential	I3	3144-5
I3	or	conjunctive	I4	3144-5
<B>	for	constraint	each x	3144-6
each x	in	constraint	the A column	3144-6
each x	occurring	action	the A column	3144-6
the A column		sequential	witness B	3144-6
witness B	Intuitively selects	action	some tuple	3144-6
some tuple		sequential	x	3144-6
x		sequential	y	3144-6
y	in	constraint	I	3144-6
I	thus choosing nondeterministically	action	a B value y	3144-6
a B value y	for	constraint	x	3144-6
<B>	for	constraint	each relation	3145-1
each relation		sequential	J	3145-1
J	over	constraint	some schema	3145-1
some schema		sequential	U	3145-1
U	=	sequential	XY	3145-1
XY		sequential	X ∩	3145-1
X ∩		sequential	Y	3145-1
Y	=	sequential	∅	3145-1
∅		sequential	witness Y	3145-1
witness Y		sequential	I	3145-1
I	selects	action	one tuple	3145-1
one tuple		sequential	x	3145-1
x		sequential	y	3145-1
y	for	constraint	GX	3145-1
y	in	constraint	GX	3145-1
y	x	sequential	GX	3145-1
y	occurring	action	GX	3145-1
GX		sequential	J	3145-1
<B>	that	constraint	this definition	3145-2
<B>	from	constraint	this definition	3145-2
<B>	Observe	action	this definition	3145-2
this definition		sequential	witness U	3145-2
witness U		sequential	J	3145-2
J	selects	action	one tuple	3145-2
one tuple	in	constraint	J	3145-2
J	if	constraint	<B>	3145-2
It	to	constraint	the semantics	3146-1
It	is	attribute	also possible	3146-1
It	describe	action	the semantics	3146-1
the semantics	of	constraint	the witness operator	3146-1
the witness operator	using	action	functional dependencies	3146-1
The witness operator	provides	action	a uniform way	3147-1
a uniform way	of	constraint	nondeterministic counterparts	3147-1
a uniform way	obtaining	action	nondeterministic counterparts	3147-1
nondeterministic counterparts	for	constraint	traditional deterministic languages	3147-1
The extension	of	constraint	while	3148-1
while	with	constraint	witness	3148-1
while	+	sequential	witness	3148-1
witness	by	constraint	+ +W	3148-1
witness	while	constraint	+ +W	3148-1
witness	is denoted	action	+ +W	3148-1
<B>	is	attribute	a useful example	3148-2
<B>	Following	action	a useful example	3148-2
a useful example		sequential	that	3148-2
that	that	constraint	an arbitrary order	3148-2
that	shows	action	an arbitrary order	3148-2
an arbitrary order	can be constructed	action	the witness operator	3148-2
an arbitrary order	using	action	the witness operator	3148-2
Example		sequential	17.4.4	3149-1
A unary relation max	contains	action	the current maximum element	3149-2
the current maximum element	in	constraint	<B>	3149-2
Some steps	of	constraint	a possible computation	3149-3
a possible computation	on	constraint	input	3149-3
input		sequential	R	3149-3
R	=	sequential	b	3149-3
R	{	sequential	b	3149-3
b		sequential	c	3149-3
c		sequential	d	3149-3
This query	in	constraint	++W	3150-1
This query	while	constraint	++W	3150-1
This query	can also be expressed	action	++W	3150-1
<B>	See	action	Exercise 17.31	3150-2
<B>	To	constraint	the nondeterministic languages	3150-3
<B>	with	constraint	the nondeterministic languages	3150-3
<B>	continue	action	the nondeterministic languages	3150-3
the nondeterministic languages		sequential	we	3150-3
we	next consider	action	the language	3150-3
the language		sequential	First Order	3150-3
First Order		sequential	Fixpoint	3150-3
Fixpoint	While	constraint	CALC +µ	3150-3
Fixpoint	and	conjunctive	CALC +µ	3150-3
CALC +µ	+	sequential	<B>	3150-3
The nondeterminism	by	constraint	a logical operator	3150-4
The nondeterminism	is again provided	action	a logical operator	3150-4
a logical operator	called	action	witness 4	3150-4
witness 4	and	conjunctive	W	3150-4
witness 4	denoted	action	W	3150-4
<B>	Suppose	action	x	3150-5
x		sequential	y	3150-5
y	is	attribute	a formula	3150-5
a formula	with	constraint	free variables	3150-5
free variables		sequential	x	3150-5
x		sequential	y	3150-5
<B>		sequential	x	3150-6
x		sequential	y	3150-6
y	that	constraint	one witness	3150-6
y	indicates	action	one witness	3150-6
one witness		sequential	yx	3150-6
yx	for	constraint	y	3150-6
yx	is chosen	attribute	each	3150-6
y		sequential	x	3150-6
x		sequential	y	3150-6
<B>	For	constraint	example	3151-1
example	if	constraint	R	3151-1
R	of	constraint	the relation	3151-1
R	consists	action	the relation	3151-1
the relation		sequential	I	3151-1
I	in	constraint	Fig	3151-1
the formula		sequential	WyR	3151-2
WyR		sequential	x	3151-2
x		sequential	y	3151-2
y	17.9 defines	action	the possible answers	3151-2
the possible answers		sequential	I1	3151-2
I1		sequential	I2	3151-2
I2		sequential	I3	3151-2
I3		sequential	I4	3151-2
I4	in	constraint	the same figure	3151-2
WyR		sequential	x	3151-3
x		sequential	y	3151-3
y	to	constraint	witness B	3151-3
y	is	attribute	Thus equivalent	3151-3
witness B		sequential	R	3151-3
<B>	for	constraint	each formula	3151-4
each formula		sequential	x	3151-4
x		sequential	y	3151-4
y		sequential	x	3151-4
x	and	conjunctive	y	3151-4
y	are	attribute	vectors ϕ	3151-4
vectors ϕ	of	constraint	the variables	3151-4
the variables		sequential	that	3151-4
that	in	constraint	x	3151-4
that	are	attribute	free	3151-4
x		sequential	y	3151-4
y	is	attribute	a formula	3151-4
a formula	where y remain	attribute	free	3151-4
a formula	defining	action	the set	3151-4
the set	of	constraint	relations	3151-4
relations		sequential	I	3151-4
I	for	constraint	some J	3151-4
I	such	attribute	that	3151-4
some J	by	constraint	I	3151-4
some J	defined	action	I	3151-4
I	⊆	action	J	3151-4
J	for	constraint	x	3151-4
J	and	conjunctive	x	3151-4
x	for	constraint	which	3151-4
which		sequential	x	3151-4
x		sequential	y	3151-4
y	in	constraint	J	3151-4
y	is	attribute	J	3151-4
J	for	constraint	there	3151-4
there	exists	attribute	unique	3151-4
a yx		sequential	that	3151-4
that		sequential	x	3151-4
x		sequential	yx	3151-4
yx	in	constraint	I	3151-4
yx	is	attribute	I	3151-4
The extension	of	constraint	CALC	3152-1
CALC		sequential	+µ	3152-1
+µ	with	constraint	the witness operator	3152-1
+µ	+	sequential	the witness operator	3152-1
the witness operator	by	constraint	CALC +µ	3152-1
the witness operator	is denoted	action	CALC +µ	3152-1
CALC +µ	+	sequential	+W	3152-1
<B>	is	attribute	a useful example	3152-2
<B>	Following	action	a useful example	3152-2
a useful example		sequential	that	3152-2
that	that	constraint	an arbitrary order	3152-2
that	shows	action	an arbitrary order	3152-2
an arbitrary order	can be constructed	action	CALC +µ++W	3152-2
an arbitrary order	using	action	CALC +µ++W	3152-2
Example		sequential	17.4.5	3153-1
<B>	+µ++	sequential	W	3153-2
W		sequential	The following CALC query	3153-2
The following CALC query	on	constraint	each instance	3153-2
The following CALC query	defines	action	each instance	3153-2
each instance		sequential	I	3153-2
I	of	constraint	R	3153-2
R		sequential	all possible successor relations	3153-2
all possible successor relations	on	constraint	the constants	3153-2
the constants	in	constraint	I	3153-2
The output	if	constraint	I	3153-3
The output	is	attribute	empty	3153-3
I	contains	action	fewer than two constants	3153-3
The query	uses	action	a binary relation schema succ	3153-4
a binary relation schema succ		sequential	which	3153-4
which	to	constraint	the successor relation	3153-4
which	is used	action	the successor relation	3153-4
which	construct iteratively	action	the successor relation	3153-4
The query	is	attribute	µ+ succ	3153-5
µ+ succ		sequential	ϕ	3153-5
ϕ		sequential	succ	3153-5
succ		sequential	x	3153-5
x		sequential	y	3153-5
y	ϕ	sequential	1 ∨	3153-5
y	where =	sequential	1 ∨	3153-5
y	ϕ	sequential	1 ∨	3153-5
1 ∨	ϕ	sequential	2	3153-5
The formula ϕ 1	initializes	action	the iteration	3154-1
the iteration		sequential	succ	3154-1
succ	is	attribute	when empty	3154-1
2	to	constraint	succ a tuple	3154-1
2	adds	action	succ a tuple	3154-1
succ a tuple		sequential	x	3154-1
x		sequential	y	3154-1
y		sequential	y	3154-1
y	is	attribute	where an arbitrarily chosen element	3154-1
where an arbitrarily chosen element	of	constraint	I	3154-1
I		sequential	R	3154-1
R	in	constraint	x	3154-1
R	and	conjunctive	x	3154-1
x	is	attribute	the current maximum element	3154-1
the current maximum element	in	constraint	<B>	3154-1
The ability of	while	constraint	++W	3155-1
++W	and	conjunctive	CALC	3155-1
CALC	+µ++	constraint	W	3155-1
W	to	constraint	nondeterministically a successor relation	3155-1
W	define	action	nondeterministically a successor relation	3155-1
nondeterministically a successor relation	on	constraint	the constants	3155-1
the constants	that	constraint	the impact	3155-1
the constants	suggests	action	the impact	3155-1
the impact	of	constraint	nondeterminism	3155-1
nondeterminism	on	constraint	expressive power	3155-1
expressive power	to	constraint	order	3155-1
expressive power	of	constraint	order	3155-1
expressive power	is	attribute	similar	3155-1
<B>	by	constraint	the following result	3155-2
<B>	is confirmed	action	the following result	3155-2
Theorem		sequential	17.4.6	3156-1
Proof		sequential	Proof	3157-1
<B>	Conversely let	action	q	3157-2
q	be	attribute	a query	3157-2
a query	in	constraint	qptime	3157-2
<B>	By	constraint	Theorem 17.4.2	3157-3
Theorem 17.4.2		sequential	there	3157-3
there	exists	action	a while	3157-3
a while	+	sequential	query	3157-3
query	w	constraint	that	3157-3
that	expresses	action	q	3157-3
q	if	constraint	a successor relation	3157-3
a successor relation	on	constraint	the constants	3157-3
the constants	is given	action	<B>	3157-3
the while		sequential	++W query	3157-4
++W query	expressing	action	q	3157-4
q	of	constraint	<B>	3157-4
q	Then consists	attribute	the following	3157-4
Bibliographic Notes		sequential	Bibliographic Notes	3158-1
<B>	that	constraint	Theorem 17.4.6	3159-1
<B>	Note	action	Theorem 17.4.6	3159-1
Theorem 17.4.6	does not provide	action	a language	3159-1
a language		sequential	that	3159-1
that	expresses	action	precisely qptime	3159-1
precisely qptime	because	constraint	nondeterministic queries	3159-1
nondeterministic queries	and	conjunctive	it	3159-1
nondeterministic queries	can also be expressed	action	it	3159-1
it	if	constraint	a while	3159-1
it	is	attribute	undecidable	3159-1
a while		sequential	++W	3159-1
++W	or	conjunctive	CALC +µ++ W query	3159-1
CALC +µ++ W query	defines	action	a deterministic query	3159-1
a deterministic query		sequential	Exercise	3159-1
Exercise		sequential	17.32	3159-1
the result	Instead shows	action	the power	3159-2
the power	of	constraint	nondeterministic constructs	3159-2
nondeterministic constructs	to	constraint	a trade off	3159-2
nondeterministic constructs	and	conjunctive	a trade off	3159-2
nondeterministic constructs	so points	action	a trade off	3159-2
a trade off	between	constraint	expressive power	3159-2
expressive power	and	conjunctive	determinism	3159-2
Bibliographic Notes		sequential	Bibliographic Notes	3160-1
The parallel complexity	of	constraint	CALC	3160-2
CALC		sequential	specifically the connection	3160-2
specifically the connection	with	constraint	ac0	3160-2
ac0	by	constraint	Immerman	3160-2
ac0	was studied	action	Immerman	3160-2
Immerman		sequential	Imm87a	3160-2
<B>	In	constraint	DV91	3160-3
DV91		sequential	a database model	3160-3
a database model	for	constraint	parallel computation	3160-3
parallel computation	and	conjunctive	CALC	3160-3
parallel computation	is defined	action	CALC	3160-3
CALC	to	constraint	exactly its restriction	3160-3
CALC	with	constraint	exactly its restriction	3160-3
CALC	is shown	action	exactly its restriction	3160-3
CALC	coincide	action	exactly its restriction	3160-3
exactly its restriction	to	constraint	constant time	3160-3
constant time	and	conjunctive	polynomial size	3160-3
<B>	from	constraint	ac0	3160-4
<B>	differs	action	ac0	3160-4
ac0	in	constraint	the match	3160-4
ac0	that	constraint	the match	3160-4
the match	is	attribute	precise	3160-4
<B>	due to	constraint	the fact	3161-1
<B>	is	attribute	the fact	3161-1
the fact	that	constraint	the model	3161-1
the model	in	constraint	DV91	3161-1
DV91	and	conjunctive	an ordered encoding	3161-1
DV91	is	attribute	generic	3161-1
DV91	does not assume	action	an ordered encoding	3161-1
an ordered encoding	of	constraint	the input	3161-1
The first results	on	constraint	the expressiveness	3162-1
the expressiveness	and	conjunctive	complexity	3162-1
complexity	of	constraint	fixpoint	3162-1
fixpoint	and	conjunctive	while	3162-1
while	by	constraint	Chandra	3162-1
while	were obtained	action	Chandra	3162-1
Chandra	and	conjunctive	Harel	3162-1
Harel		sequential	Vardi	3162-1
Vardi	and	conjunctive	Immerman	3162-1
it	by	constraint	a direct proof	3162-2
it	In CH80 b is shown	action	a direct proof	3162-2
a direct proof	that	constraint	fixpoint	3162-2
fixpoint	can not express even	action	<B>	3162-2
The result	to	constraint	Cha81a	3162-3
The result	while	constraint	Cha81a	3162-3
The result	in	constraint	Cha81a	3162-3
The result	is extended	action	Cha81a	3162-3
The fundamental result		sequential	that	3163-1
that		sequential	fixpoint	3163-1
fixpoint	expresses	action	qptime	3163-1
qptime	on	constraint	ordered instances	3163-1
ordered instances	by	constraint	Immerman	3163-1
ordered instances	was obtained independently	action	Immerman	3163-1
Immerman		sequential	Imm86	3163-1
Imm86	and	conjunctive	Vardi	3163-1
Vardi		sequential	Var82a	3163-1
The fact	that	constraint	ordered instances	3163-2
The fact	while	constraint	ordered instances	3163-2
The fact	on	constraint	ordered instances	3163-2
ordered instances	expresses	action	qpspace	3163-2
qpspace	in	constraint	Var82a	3163-2
qpspace	is shown	action	Var82a	3163-2
Languages	expressing	action	complexity classes	3164-1
complexity classes	of	constraint	queries	3164-1
queries	below	constraint	qptime	3164-1
qptime	in	constraint	Imm87 b	3164-1
qptime	are investigated	action	Imm87 b	3164-1
They	on	constraint	CALC	3164-2
They	are based	action	CALC	3164-2
They	augmenting	action	CALC	3164-2
CALC	with	constraint	operators	3164-2
operators	providing	action	limited recursion	3164-2
limited recursion		sequential	various forms	3164-2
various forms	of	constraint	transitive closure	3164-2
The classes	of	constraint	queries	3164-3
queries	by	constraint	the resulting languages	3164-3
queries	expressed	action	the resulting languages	3164-3
the resulting languages	on	constraint	ordered databases	3164-3
ordered databases	include	action	deterministic logspace	3164-3
deterministic logspace		sequential	denoted logspace	3164-3
denoted logspace		sequential	nondeterministic logspace	3164-3
nondeterministic logspace		sequential	denoted nlogspace	3164-3
denoted nlogspace	and	conjunctive	symmetric logspace	3164-3
symmetric logspace		sequential	denoted slogspace	3164-3
There	has been	action	a long quest	3165-1
a long quest	for	constraint	a language	3165-1
a language	expressing	action	precisely qptime	3165-1
precisely qptime	on	constraint	arbitrary databases	3165-1
The problem	in	constraint	a general setting	3165-2
The problem	is formalized	action	a general setting	3165-2
a general setting	in	constraint	Gur88	3165-2
Gur88		sequential	it	3165-2
it	that	constraint	no such language	3165-2
it	where is also conjectured	action	no such language	3165-2
no such language	exists	action	<B>	3165-2
The issue	in	constraint	<B>	3165-3
The issue	is further investigated	action	<B>	3165-3
<B>	In	constraint	the absence	3166-1
the absence	of	constraint	a language	3166-1
a language	for	constraint	qptime	3166-1
qptime		sequential	there	3166-1
there	have been	action	several proposals	3166-1
several proposals	to	constraint	the fixpoint queries	3166-1
several proposals	extend	action	the fixpoint queries	3166-1
the fixpoint queries	to	constraint	qptime	3166-1
the fixpoint queries	of	constraint	qptime	3166-1
the fixpoint queries	capture	attribute	more	3166-1
<B>	that	constraint	queries	3166-2
<B>	Recall	action	queries	3166-2
queries	involving	action	counting	3166-2
counting	in	constraint	not fixpoint	3166-2
counting	are	attribute	not fixpoint	3166-2
it	to	constraint	extensions	3166-3
it	is	attribute	Therefore natural	3166-3
it	consider	action	extensions	3166-3
extensions	of	constraint	fixpoint	3166-3
fixpoint	with	constraint	counting constructs	3166-3
An early proposal	by	constraint	Chandra	3166-4
Chandra		sequential	Cha81a	3166-4
Cha81a	to	constraint	a bounded looping construct	3166-4
Cha81a	is	attribute	a bounded looping construct	3166-4
Cha81a	add	action	a bounded looping construct	3166-4
a bounded looping construct	of	constraint	the form	3166-4
the form	For	constraint	R| do	3166-4
R| do		sequential	which	3166-4
which	iterates	action	the body	3166-4
the body	of	constraint	the loop	3166-4
the loop		sequential	R| times	3166-4
this construct	Clearly allows	action	us	3166-5
us	to	constraint	<B>	3166-5
us	express even	action	<B>	3166-5
it	that	constraint	bounded looping	3166-6
it	However has been shown	action	bounded looping	3166-6
bounded looping	to	constraint	qptime	3166-6
bounded looping	of	constraint	qptime	3166-6
bounded looping	is	attribute	not sufficient	3166-6
bounded looping	yield	attribute	all	3166-6
qptime	because	constraint	tests	3166-6
tests		sequential	R1	3166-6
R1	=	sequential	R2	3166-6
R2	can not be expressed	action	Cha88	3166-6
R2	see	action	Cha88	3166-6
extensions	of	constraint	fixpoint	3166-7
fixpoint	with	constraint	counting constructs	3166-7
counting constructs	in	constraint	CFI89	3166-7
counting constructs	and	conjunctive	CFI89	3166-7
counting constructs	More recently have been considered	action	CFI89	3166-7
counting constructs	studied	action	CFI89	3166-7
CFI89		sequential	GO93	3166-7
They	allow	action	access	3166-8
access	to	constraint	the cardinality	3166-8
the cardinality	of	constraint	relations	3166-8
relations		sequential	limited integer manipulation	3166-8
These languages	than	constraint	fixpoint First Order	3166-9
These languages	are	attribute	more powerful	3166-9
fixpoint First Order		sequential	Fixpoint	3166-9
Fixpoint	While	constraint	CFI89	3166-9
Fixpoint	as	constraint	CFI89	3166-9
Fixpoint	in	constraint	CFI89	3166-9
Fixpoint	and	conjunctive	CFI89	3166-9
Fixpoint	but	conjunctive	CFI89	3166-9
Fixpoint	shown	action	CFI89	3166-9
CFI89	of	constraint	qptime	3166-9
CFI89	of	constraint	qptime	3166-9
CFI89	still fall	attribute	short	3166-9
CFI89	expressing	attribute	all	3166-9
Other results	of	constraint	this flavor	3166-10
this flavor	in	constraint	Daw93	3166-10
this flavor	are proven	action	Daw93	3166-10
Daw93		sequential	Hel92	3166-10
They	that	constraint	fixpoint	3166-11
They	show	action	fixpoint	3166-11
They	extending	action	fixpoint	3166-11
fixpoint	with	constraint	a finite set	3166-11
a finite set	of	constraint	polynomial time	3166-11
polynomial time		sequential	computable constructs	3166-11
computable constructs	of	constraint	certain forms	3166-11
certain forms		sequential	generalized quantifiers	3166-11
generalized quantifiers	like	constraint	oracles	3166-11
generalized quantifiers	acting much	action	oracles	3166-11
oracles	can not yield	action	a language	3166-11
a language	expressing	action	exactly qptime	3166-11
exactly qptime	see	action	Exercise 17.35	3166-11
Exercise 17.35	for	constraint	a simplified version	3166-11
a simplified version	of	constraint	this result	3166-11
The normal form	for	constraint	AV91	3167-1
The normal form	while	constraint	AV91	3167-1
The normal form	in	constraint	AV91	3167-1
The normal form	was proven	action	AV91	3167-1
AV91		sequential	b	3167-1
b		sequential	AV94	3167-1
It	was also shown	action	the normal form	3167-2
It	using	action	the normal form	3167-2
the normal form		sequential	that fixpoint	3167-2
that fixpoint	while	constraint	ptime	3167-2
that fixpoint	and	conjunctive	ptime	3167-2
that fixpoint	are	attribute	equivalent	3167-2
ptime	=	sequential	iff pspace	3167-2
The cost	of	constraint	computing	3167-3
computing	without	constraint	an order	3167-3
an order	in	constraint	AV91 b	3167-3
an order	is also investigated	action	AV91 b	3167-3
AV91 b		sequential	AV94	3167-3
<B>	is formalized	action	an alternative model	3167-4
<B>	using	action	an alternative model	3167-4
an alternative model	of	constraint	computation	3167-4
computation	called	action	generic machine	3167-4
generic machine		sequential	GM	3167-4
<B>	Unlike	constraint	Turing machines	3167-5
Turing machines		sequential	GMs	3167-5
GMs	do not require	action	an ordered encoding	3167-5
an ordered encoding	of	constraint	the input	3167-5
the input	and	conjunctive	only the information	3167-5
the input	use	action	only the information	3167-5
only the information	by	constraint	the input instance	3167-5
only the information	provided	action	the input instance	3167-5
<B>	on	constraint	GM	3167-6
<B>	Based	action	GM	3167-6
GM		sequential	generic complexity classes	3167-6
generic complexity classes	of	constraint	queries	3167-6
queries	are defined	action	<B>	3167-6
<B>	For	constraint	example	3167-7
example		sequential	gen-ptime	3167-7
gen-ptime	and	conjunctive	gen-pspace	3167-7
gen-pspace	by	constraint	polynomial time	3167-7
gen-pspace	are obtained	action	polynomial time	3167-7
gen-pspace	taking	action	polynomial time	3167-7
polynomial time	and	conjunctive	space restrictions	3167-7
space restrictions	of	constraint	GM	3167-7
<B>	As	constraint	a typical result	3167-8
a typical result		sequential	it	3167-8
it	that	constraint	even not gen- pspace	3167-8
it	in	constraint	even not gen- pspace	3167-8
it	is	attribute	even not gen- pspace	3167-8
it	is shown	action	even not gen- pspace	3167-8
even not gen- pspace		sequential	which	3167-8
which	captures	action	the intuition	3167-8
the intuition		sequential	that	3167-8
that		sequential	this query	3167-8
this query	to	constraint	order	3167-8
this query	without	constraint	order	3167-8
this query	is	attribute	hard	3167-8
this query	compute	action	order	3167-8
Another more restricted device	without	constraint	encodings	3167-9
Another more restricted device	also operating	action	encodings	3167-9
encodings	is	attribute	the relational machine	3167-9
the relational machine	in	constraint	AV91	3167-9
the relational machine	also considered	action	AV91	3167-9
AV91		sequential	b	3167-9
b		sequential	AV94	3167-9
There	is	attribute	a close match	3167-10
a close match	between	constraint	complexity classes	3167-10
complexity classes	defined	action	this device	3167-10
complexity classes	using	action	this device	3167-10
this device	called	action	relational complexity classes	3167-10
relational complexity classes	and	conjunctive	various languages	3167-10
<B>	For	constraint	example	3167-11
example		sequential	relational polynomial time	3167-11
relational polynomial time	with	constraint	fixpoint	3167-11
relational polynomial time	coincides	action	fixpoint	3167-11
fixpoint	and	conjunctive	relational polynomial space	3167-11
relational polynomial space	with	constraint	while	3167-11
Further connections	between	constraint	languages	3167-12
languages	and	conjunctive	relational complexity classes	3167-12
relational complexity classes	in	constraint	AVV92	3167-12
relational complexity classes	are shown	action	AVV92	3167-12
Nondeterministic languages	and	conjunctive	their expressive power	3168-1
their expressive power	in	constraint	ASV90	3168-1
their expressive power	are investigated	action	ASV90	3168-1
ASV90		sequential	AV91a	3168-1
AV91a		sequential	AV91c	3168-1
The languages	include	action	nondeterministic extensions	3168-2
nondeterministic extensions	of	constraint	CALC	3168-2
CALC		sequential	+µ+	3168-2
+µ+	and	conjunctive	CALC +µ	3168-2
CALC +µ	of	constraint	rule	3168-2
CALC +µ	and	conjunctive	rule	3168-2
rule	based	action	languages	3168-2
languages		sequential	datalog¬	3168-2
Strong connections	between	constraint	these languages	3168-3
these languages	are shown	action	Exercise 17.33	3168-3
these languages	see	action	Exercise 17.33	3168-3
Nondeterministic languages		sequential	that	3168-4
that	can express	action	all the qptime queries	3168-4
all the qptime queries	are exhibited	action	<B>	3168-4
Fraissé		sequential	The Ehrenfeucht games	3169-1
The Ehrenfeucht games	due to	constraint	Ehrenfeucht	3169-1
The Ehrenfeucht games	are	attribute	Ehrenfeucht	3169-1
Ehrenfeucht		sequential	Ehr61	3169-1
Ehr61	and	conjunctive	Fraissé	3169-1
Fraissé		sequential	Fra54	3169-1
<B>	Since	constraint	their work	3170-1
their work		sequential	extensions	3170-1
extensions	of	constraint	the games	3170-1
the games	to	constraint	various languages	3170-1
the games	and	conjunctive	various languages	3170-1
the games	have been proposed	attribute	related	3170-1
various languages		sequential	datalog	3170-1
datalog		sequential	LM89	3170-1
LM89		sequential	fragments	3170-1
fragments	of	constraint	infinitary logic	3170-1
infinitary logic		sequential	KV90	3170-1
KV90		sequential	c	3170-1
c		sequential	fixpoint queries	3170-1
fixpoint queries	and	conjunctive	order	3170-1
order		sequential	logic	3170-1
logic		sequential	Fag75	3170-1
Fag75		sequential	AF90	3170-1
AF90		sequential	dR87	3170-1
<B>	In	constraint	Imm82	3170-2
Imm82		sequential	CFI89	3170-2
CFI89		sequential	games	3170-2
games	to	constraint	lower bounds	3170-2
games	are used	action	lower bounds	3170-2
games	prove	action	lower bounds	3170-2
lower bounds	on	constraint	the number	3170-2
the number	of	constraint	variables	3170-2
variables	to	constraint	certain graph properties	3170-2
variables	needed	action	certain graph properties	3170-2
variables	express	action	certain graph properties	3170-2
<B>	in	constraint	the extensions	3170-3
the extensions	of	constraint	Ehrenfeucht	3170-3
Ehrenfeucht		sequential	Fraissé	3170-3
Fraissé		sequential	games	3170-3
games	in	constraint	an instance	3170-3
games	choosing	attribute	a constant	3170-3
an instance	of	constraint	a pebble	3170-3
an instance	as	constraint	a pebble	3170-3
an instance	is thought	action	a pebble	3170-3
an instance	placing	action	a pebble	3170-3
a pebble	over	constraint	the games	3170-3
the games	to	constraint	pebble games	3170-3
the games	as	constraint	pebble games	3170-3
the games	are often referred	action	pebble games	3170-3
<B>	Like	constraint	Ehrenfeucht	3170-4
Ehrenfeucht		sequential	Fraissé	3170-4
Fraissé		sequential	the games	3170-4
the games	are	attribute	two player	3170-4
two player		sequential	games	3170-4
games	in	constraint	which	3170-4
which		sequential	one player	3170-4
one player	to	constraint	the instances	3170-4
one player	that	constraint	the instances	3170-4
one player	attempts	action	the instances	3170-4
one player	prove	action	the instances	3170-4
the instances	and	conjunctive	the other attempts	3170-4
the instances	are	attribute	not the same	3170-4
the other attempts	to	constraint	the contrary	3170-4
the other attempts	prove	action	the contrary	3170-4
the contrary	by	constraint	the pebbles	3170-4
the contrary	placing	action	the pebbles	3170-4
the pebbles		sequential	the corresponding subinstances	3170-4
the corresponding subinstances	are	attribute	isomorphic	3170-4
The games	in	constraint	the rules	3170-5
The games	differ	action	the rules	3170-5
the rules	for	constraint	turns	3170-5
the rules	taking	action	turns	3170-5
turns	among	constraint	players	3170-5
players	and	conjunctive	instances	3170-5
instances		sequential	the number	3170-5
the number	of	constraint	pebbles	3170-5
pebbles	in	constraint	one move	3170-5
pebbles	placed	action	one move	3170-5
one move	whether	constraint	the pebbles	3170-5
the pebbles	are colored	action	<B>	3170-5
<B>	In	constraint	games	3170-6
games	to	constraint	languages	3170-6
games	corresponding	action	languages	3170-6
languages	with	constraint	recursion	3170-6
recursion		sequential	players	3170-6
players	have	action	more than one chance	3170-6
more than one chance	for	constraint	Exercises G	3170-6
more than one chance	achieving	action	Exercises G	3170-6
Exercises G		sequential	00	3170-6
00	# 01	sequential	10	3170-6
10	#	sequential	00	3170-6
00		sequential	10	3170-6
10	#	sequential	01	3170-6
01		sequential	01 # 01 #	3170-6
01 # 01 #		sequential	10	3170-6
10		sequential	Figure	3170-6
Figure		sequential	17.11	3170-6
17.11		sequential	Encoding	3170-6
Encoding	of	constraint	an instance	3170-6
an instance	and	conjunctive	their objective	3170-6
an instance	tuple	action	their objective	3170-6
their objective	by	constraint	the pebbles	3170-6
their objective	of	constraint	the pebbles	3170-6
their objective	removing	attribute	some	3170-6
the pebbles	and	conjunctive	the game	3170-6
the pebbles	restarting	action	the game	3170-6
Our presentation	of	constraint	Ehrenfeucht	3170-7
Ehrenfeucht		sequential	Fraissé	3170-7
Fraissé		sequential	games	3170-7
games	by	constraint	Kolaitis	3170-7
games	was inspired	action	Kolaitis	3170-7
Kolaitis		sequential	excellent lecture notes	3170-7
excellent lecture notes		sequential	Kol83	3170-7
The study	of	constraint	1	3171-1
The study	-	sequential	1	3171-1
1		sequential	0 laws	3171-1
0 laws	by	constraint	Fagin	3171-1
0 laws	was initiated	action	Fagin	3171-1
Fagin	and	conjunctive	Glebski˘i	3171-1
The 0 1 law	for	constraint	CALC	3171-2
CALC	in	constraint	Fag72	3171-2
CALC	was proven	action	Fag72	3171-2
Fag72		sequential	Fag76	3171-2
Fag76	by	constraint	independently Glebski˘i	3171-2
Fag76	and	conjunctive	independently Glebski˘i	3171-2
independently Glebski˘i		sequential	et	3171-2
et		sequential	al	3171-2
GKLT69		sequential	GKLT69	3171-3
The 0 1 law	for	constraint	fixpoint	3171-4
fixpoint	by	constraint	Blass	3171-4
fixpoint	was shown	action	Blass	3171-4
Blass		sequential	Gurevich	3171-4
Gurevich	and	conjunctive	Kozen	3171-4
Kozen		sequential	BGK85	3171-4
BGK85	and	conjunctive	Talanov	3171-4
Talanov	and	conjunctive	Knyazev	3171-4
Knyazev		sequential	TK84	3171-4
<B>	to	constraint	Kolaitis	3171-5
<B>	while	constraint	Kolaitis	3171-5
<B>	by	constraint	Kolaitis	3171-5
<B>	was extended	action	Kolaitis	3171-5
Kolaitis	and	conjunctive	Vardi	3171-5
Vardi		sequential	who	3171-5
who	proved	action	further extensions	3171-5
further extensions	of	constraint	1	3171-5
further extensions	-	sequential	1	3171-5
1		sequential	0 laws	3171-5
0 laws	for	constraint	certain fragments	3171-5
certain fragments	of	constraint	order	3171-5
order		sequential	logic	3171-5
logic		sequential	KV87	3171-5
KV87		sequential	KV90b	3171-5
KV90b	for	constraint	infinitary logic	3171-5
KV90b	and	conjunctive	infinitary logic	3171-5
infinitary logic	with	constraint	finitely many variables	3171-5
finitely many variables		sequential	KV92	3171-5
KV92	of	constraint	which	3171-5
which	subsume	action	while	3171-5
<B>	For	constraint	instance	3172-1
instance	-	sequential	1	3172-1
1		sequential	0 laws	3172-1
0 laws	for	constraint	order	3172-1
0 laws	were proven	attribute	second	3172-1
order		sequential	existential sentences Q1	3172-1
<B>	.	sequential	<B>	3172-2
<B>	.	sequential	<B>	3172-3
Qkσ		sequential	the Qi	3172-4
the Qi	are	attribute	where relation variables	3172-4
where relation variables	and	conjunctive	σ	3172-4
σ	is	attribute	a CALC formula	3172-4
a CALC formula	in	constraint	prenex form	3172-4
prenex form		sequential	whose quantifier portion	3172-4
whose quantifier portion	has	action	one	3172-4
one	of	constraint	the shapes	3172-4
the shapes	or	conjunctive	<B>	3172-4
the shapes	∃∗∀∗	sequential	<B>	3172-4
It	that	constraint	order	3172-5
It	is known	attribute	second	3172-5
order		sequential	arbitrary existential sentences	3172-5
arbitrary existential sentences	do not have	action	1	3172-5
1		sequential	a 0 law	3172-5
a 0 law	see	action	Exercise 17.21	3172-5
Infinitary logic	is	attribute	an extension	3172-6
an extension	of	constraint	CALC	3172-6
CALC		sequential	that	3172-6
that	allows	action	infinite disjunctions	3172-6
infinite disjunctions	and	conjunctive	conjunctions	3172-6
Kolaitis	and	conjunctive	Vardi	3172-7
Vardi	that	constraint	the language	3172-7
Vardi	proved	action	the language	3172-7
the language	of	constraint	infinitary logic sentences	3172-7
the language	consisting	action	infinitary logic sentences	3172-7
infinitary logic sentences		sequential	that	3172-7
that	use	action	only finitely many variables	3172-7
only finitely many variables	has	action	1	3172-7
1		sequential	a 0 law	3172-7
<B>	that	constraint	this language	3172-8
<B>	Note	action	this language	3172-8
this language	while	constraint	Exercise 17.22	3172-8
this language	subsumes	action	Exercise 17.22	3172-8
Another aspect	of	constraint	1	3172-9
Another aspect	-	sequential	1	3172-9
1		sequential	0 laws	3172-9
0 laws		sequential	that	3172-9
that	has been studied	action	the difficulty	3172-9
that	involves	action	the difficulty	3172-9
the difficulty	of	constraint	a sentence	3172-9
the difficulty	whether	constraint	a sentence	3172-9
the difficulty	deciding	action	a sentence	3172-9
a sentence	in	constraint	a language	3172-9
a language		sequential	that	3172-9
that	has	action	1	3172-9
1		sequential	a 0 law	3172-9
a 0 law	whether	constraint	it	3172-9
a 0 law	or	conjunctive	it	3172-9
a 0 law	is	attribute	almost surely true	3172-9
it	is	attribute	almost surely false	3172-9
<B>	For	constraint	instance	3172-10
instance		sequential	Grandjean	3172-10
Grandjean	that	constraint	the problem	3172-10
Grandjean	proved	action	the problem	3172-10
the problem	is	attribute	pspace	3172-10
pspace	for	constraint	CALC	3172-10
Fagin		sequential	Fag93	3173-1
Fag93	presents	action	a survey	3173-1
a survey	of	constraint	finite model theory	3173-1
finite model theory	-	sequential	1	3173-1
finite model theory	including	action	1	3173-1
1		sequential	0 laws	3173-1
0 laws		sequential	that	3173-1
that	inspired	action	our presentation	3173-1
our presentation	of	constraint	this topic	3173-1
Exercises Exercise 17.1		sequential	Exercises Exercise 17.1	3174-1
<B>	Consider	action	the instance	3175-1
the instance		sequential	I	3175-1
I	over	constraint	G	3175-1
G	and	conjunctive	tuple	3175-1
tuple	on	constraint	a Turing input tape	3175-1
tuple	encoded	action	a Turing input tape	3175-1
a Turing input tape	as	constraint	Fig	3175-1
a Turing input tape	in	constraint	Fig	3175-1
a Turing input tape	shown	action	Fig	3175-1
17.11		sequential	17.11	3175-2
<B>	in	constraint	detail	3176-1
<B>	Describe	action	detail	3176-1
detail		sequential	the computation	3176-1
the computation	of	constraint	the Turing machine Mϕ	3176-1
the Turing machine Mϕ	in	constraint	the proof	3176-1
the Turing machine Mϕ	outlined	action	the proof	3176-1
the proof	of	constraint	Theorem 17.1.1	3176-1
Theorem 17.1.1	on	constraint	this input	3176-1
Exercise		sequential	17.3	3177-1
Exercise		sequential	17.4	3178-1
First Order		sequential	Fixpoint	3179-1
Fixpoint	While	constraint	Exercise 17.6	3179-1
Fixpoint	and	conjunctive	Exercise 17.6	3179-1
Exercise 17.6	Extend	action	Proposition 17.2.3	3179-1
Proposition 17.2.3	by	constraint	connectivity	3179-1
Proposition 17.2.3	that	constraint	connectivity	3179-1
Proposition 17.2.3	showing	action	connectivity	3179-1
connectivity	of	constraint	graphs	3179-1
graphs	is	attribute	not first order definable	3179-1
not first order definable	if	constraint	an order	3179-1
an order		sequential	≤	3179-1
≤	on	constraint	the constants	3179-1
the constants	even is provided	action	<B>	3179-1
<B>	let	action	R	3179-2
R	be	attribute	the database schema	3179-2
the database schema	of	constraint	two binary relations	3179-2
the database schema	consisting	action	two binary relations	3179-2
two binary relations		sequential	G	3179-2
G	and	conjunctive	≤	3179-2
<B>	Let	action	<B>	3179-3
<B>	Outline	action	a proof	3179-4
a proof	that	constraint	there	3179-4
there	is	attribute	no CALC sentence σ such that	3179-4
no CALC sentence σ such that	for	constraint	I	3179-4
I	∈	action	I≤	3179-4
The following two exercises	to	constraint	a proof	3180-1
The following two exercises	lead	action	a proof	3180-1
a proof	of	constraint	the converse	3180-1
the converse	of	constraint	Theorem 17.2.2	3180-1
It	that	constraint	instances	3180-2
It	states	action	instances	3180-2
instances		sequential	that	3180-2
that	by	constraint	CALC sentences	3180-2
that	are	attribute	undistinguishable	3180-2
CALC sentences	of	constraint	quantifier depth	3180-2
quantifier depth	with	constraint	respect	3180-2
quantifier depth	are	attribute	r equivalent	3180-2
respect	to	constraint	≡r	3180-2
<B>	by	constraint	each equivalence class	3180-3
<B>	that	constraint	each equivalence class	3180-3
<B>	is shown	action	each equivalence class	3180-3
<B>	proving	action	each equivalence class	3180-3
each equivalence class	of	constraint	≡r	3180-3
≡r	by	constraint	a special CALC sentence	3180-3
≡r	is	attribute	definable	3180-3
a special CALC sentence	of	constraint	quantifier depth r	3180-3
quantifier depth r	called	action	the r-type	3180-3
the r-type	of	constraint	the equivalence class	3180-3
the r-type sentence	Intuitively describes	action	all patterns	3181-1
all patterns		sequential	that	3181-1
that	by	constraint	games r	3181-1
that	can be detected	action	games r	3181-1
that	playing	action	games r	3181-1
games r	of	constraint	length	3181-1
length	on	constraint	pairs	3181-1
pairs	of	constraint	instances	3181-1
instances	in	constraint	the equivalence class	3181-1
<B>	To	constraint	the r-types	3182-1
<B>	define	action	the r-types	3182-1
the r-types		sequential	one	3182-1
one	first defines	action	formulas	3182-1
formulas	with	constraint	m free variables	3182-1
m free variables	called	action	m	3182-1
m		sequential	r	3182-1
r		sequential	types	3182-1
ik		sequential	i1 ik	3183-1
i1 ik	in	constraint	<B>	3183-1
i1 ik	is	attribute	<B>	3183-1
<B>	Suppose	action	the set	3183-2
the set	of	constraint	m	3183-2
m	+	sequential	1	3183-2
1		sequential	r	3183-2
r		sequential	types	3183-2
types	has been defined	action	<B>	3183-2
Each set S	of	constraint	m	3183-3
m	+	sequential	1	3183-3
1		sequential	r	3183-3
r		sequential	types	3183-3
types	gives	action	rise	3183-3
rise	to	constraint	m	3183-3
m		sequential	r	3183-3
r		sequential	one type	3183-3
one type	by	constraint	<B>	3183-3
one type	defined	action	<B>	3183-3
sentence	of	constraint	quantifier depth r. Hint	3184-1
<B>	Exercise	attribute	17.11 Complete	3185-1
the proof	of	constraint	Theorem 17.3.1	3185-1
Theorem 17.3.1	specifically show	action	that Exercises	3185-1
Exercise		sequential	17.12	3186-1
<B>	Describe	action	the constructions	3186-2
the constructions	for	constraint	the other algebra operators	3186-2
the constructions	needed	action	the other algebra operators	3186-2
<B>	Point out	action	the assumption	3186-3
the assumption	that	constraint	the size	3186-3
the size	of	constraint	I	3186-3
I	than	constraint	N	3186-3
I	is	attribute	greater	3186-3
N	where is used	action	<B>	3186-3
Exercise		sequential	17.15	3187-1
D		sequential	×	3188-1
×		sequential	× D	3188-1
× D		sequential	arity	3188-1
arity	of	constraint	R times	3188-1
The cross-product instance	of	constraint	database D schema R	3188-2
database D schema R	over	constraint	D	3188-2
D	is	attribute	instance	3188-2
instance		sequential	the IR	3188-2
the IR	for	constraint	each R ∈ R.	3188-2
each R ∈ R.	Let	action	P D	3188-2
P D	be	attribute	a datalog¬ program	3188-2
a datalog¬ program	with	constraint	no constants	3188-2
no constants		sequential	input schema R	3188-2
input schema R	and	conjunctive	output schema S	3188-2
output schema S	with	constraint	arity k	3188-2
P		sequential	IR D	3189-1
Exercise		sequential	17.16	3190-1
<B>	that	constraint	its limit	3191-1
<B>	Prove	action	its limit	3191-1
its limit	is	attribute	0	3191-1
0	to	constraint	∞	3191-1
0	n	conjunctive	∞	3191-1
0	when goes	action	∞	3191-1
Exercise		sequential	17.17	3192-1
Exercise		sequential	17.18	3193-1
Hint		sequential	Hint	3193-2
<B>	To	constraint	all tuples	3193-3
<B>	that	constraint	all tuples	3193-3
<B>	for	constraint	all tuples	3193-3
<B>	see	attribute	this	3193-3
<B>	show	action	all tuples	3193-3
all tuples		sequential	u	3193-3
u	and	conjunctive	v	3193-3
v	satisfying	action	this property	3193-3
this property		sequential	one	3193-3
one	can construct	action	an automorphism ρ	3193-3
an automorphism ρ	of	constraint	the Rado graph	3193-3
the Rado graph		sequential	that	3193-3
that		sequential	ρ	3193-3
ρ		sequential	u	3193-3
u	=	sequential	<B>	3193-3
Exercise		sequential	17.20	3194-1
First Order		sequential	Fixpoint	3195-1
Fixpoint	While	constraint	Exercise 17.21	3195-1
Fixpoint	and	conjunctive	Exercise 17.21	3195-1
<B>	.	sequential	<B>	3195-2
<B>	.	sequential	<B>	3195-3
Qkσ		sequential	Qi	3195-4
Qi	are	attribute	where relations	3195-4
where relations	and	conjunctive	σ	3195-4
σ	is	attribute	first	3195-4
order		sequential	a sentence	3195-4
a sentence	using	action	the relations Qi	3195-4
the relations Qi	among	constraint	others	3195-4
<B>	that	constraint	∃SO	3195-5
<B>	Show	action	∃SO	3195-5
∃SO	does not have	action	1	3195-5
1		sequential	a 0 law	3195-5
Hint	Exhibit	action	a property	3195-6
a property	in	constraint	∃SO	3195-6
∃SO		sequential	that	3195-6
that	neither	conjunctive	<B>	3195-6
that	nor	conjunctive	<B>	3195-6
that	is	attribute	almost surely true	3195-6
CALC		sequential	that	3196-1
that	allows	action	formulas	3196-1
formulas	with	constraint	infinitely long conjunctions	3196-1
infinitely long conjunctions	and	conjunctive	disjunctions	3196-1
disjunctions	but	conjunctive	only a finite number	3196-1
disjunctions	using	action	only a finite number	3196-1
only a finite number	of	constraint	variables	3196-1
<B>	that	constraint	query	3196-2
<B>	while	constraint	query	3196-2
<B>	Show	attribute	each	3196-2
query	in	constraint	L	3196-2
query	can be expressed	action	L	3196-2
L	ω	sequential	<B>	3196-2
<B>	with	constraint	a specific example	3197-1
a specific example		sequential	transitive closure	3197-1
Exercise		sequential	17.23	3198-1
Exercise		sequential	17.24	3199-1
Exercise		sequential	17.25	3200-1
<B>	Exercise	action	17.26	3201-1
17.26	Consider	action	queries	3201-1
queries	of	constraint	the form	3201-1
P	is	attribute	where an exptime property	3202-1
where an exptime property	of	constraint	the integers	3202-1
the integers		sequential	a property	3202-1
a property		sequential	that	3202-1
that	for	constraint	integer	3202-1
that	can be checked	action	integer	3202-1
integer	in	constraint	time	3202-1
integer	n	conjunctive	time	3202-1
time	in	constraint	n	3202-1
time	in	constraint	n	3202-1
time	log n	conjunctive	n	3202-1
time	or	conjunctive	n	3202-1
<B>	that	constraint	each query	3202-2
<B>	Show	action	each query	3202-2
each query	as	constraint	a fixpoint query	3202-2
each query	is	attribute	a fixpoint query	3202-2
T	=	sequential	x	3203-1
x		sequential	S s	3203-1
S s		sequential	x	3203-1
x		sequential	}	3203-1
<B>	Consider	action	the query q	3204-1
the query q	by	constraint	q	3204-1
the query q	defined	action	q	3204-1
q		sequential	I	3204-1
I	=	sequential	true iff	3204-1
true iff		sequential	I	3204-1
I	is	attribute	a good input	3204-1
a good input	and	conjunctive	I	3204-1
I		sequential	D	3204-1
D	is even	action	<B>	3204-1
Exercises		sequential	Exercises	3205-1
<B>	Explain	action	the difficulty	3206-1
the difficulty	of	constraint	a successor relation	3206-1
the difficulty	if	constraint	a successor relation	3206-1
the difficulty	proving	action	a successor relation	3206-1
a successor relation	b is used	action	≤	3206-1
Hint	For	constraint	Ehrenfeucht	3207-1
Hint	a use	action	Ehrenfeucht	3207-1
Ehrenfeucht		sequential	Fraissé	3207-1
Fraissé		sequential	games	3207-1
<B>	Consider	action	<B>	3207-2
<B>	To	constraint	the input	3207-3
<B>	that	constraint	the input	3207-3
<B>	check	action	the input	3207-3
the input	that	constraint	all singleton subsets	3207-3
the input	is	attribute	good	3207-3
the input	check	action	all singleton subsets	3207-3
all singleton subsets	of	constraint	I	3207-3
I		sequential	D	3207-3
D	if	constraint	T1	3207-3
D	and	conjunctive	T1	3207-3
D	1 are represented	action	T1	3207-3
T1	and	conjunctive	T2	3207-3
T2	is	attribute	2 so T1 ∪ T2	3207-3
T2	are represented	action	2 so T1 ∪ T2	3207-3
<B>	To	constraint	evenness	3207-4
<B>	check	action	evenness	3207-4
evenness	of	constraint	I	3207-4
I		sequential	D	3207-4
D	on	constraint	good inputs	3207-4
good inputs	from	constraint	a successor relation succ D	3207-4
good inputs	≤	conjunctive	a successor relation succ D	3207-4
good inputs	define first	action	a successor relation succ D	3207-4
a successor relation succ D	on	constraint	the constants	3207-4
the constants	in	constraint	I	3207-4
I		sequential	D	3207-4
D	that	constraint	there	3207-4
D	check	action	there	3207-4
there	exists	action	a subset	3207-4
a subset		sequential	T	3207-4
T	of	constraint	I	3207-4
I		sequential	D	3207-4
D	of	constraint	the even constants	3207-4
D	consisting	action	the even constants	3207-4
the even constants	according to	action	succ D	3207-4
succ D	that	constraint	the last element	3207-4
succ D	and	conjunctive	the last element	3207-4
the last element	in	constraint	succ D	3207-4
succ D	in	constraint	T	3207-4
succ D	is	attribute	T	3207-4
Exercise		sequential	17.29	3208-1
<B>	Exercise	action	17.30	3209-1
17.30	Write	action	CALC	3209-1
CALC	+µ++	sequential	W	3209-1
W		sequential	a formula	3209-1
a formula	defining even	action	the query	3209-1
<B>	Exercise	action	17.31 Express	3210-1
17.31 Express		sequential	the query	3210-1
the query	of	constraint	Example 17.4.4	3210-1
Example 17.4.4	in	constraint	++W	3210-1
Example 17.4.4	while	constraint	++W	3210-1
First Order		sequential	Fixpoint	3211-1
Fixpoint	While	constraint	the query	3211-1
Fixpoint	and	conjunctive	the query	3211-1
Fixpoint	computes	action	the query	3211-1
the query		sequential	P	3211-1
P		sequential	π A	3211-1
π A		sequential	Q	3211-1
<B>	that	constraint	N datalog¬∀	3211-2
<B>	Prove	action	N datalog¬∀	3211-2
N datalog¬∀	to	constraint	CALC +µ++W	3211-2
N datalog¬∀	is	attribute	equivalent	3211-2
CALC +µ++W	while	constraint	++W	3211-2
CALC +µ++W	and	conjunctive	++W	3211-2
++W	and	conjunctive	all nondeterministic queries	3211-2
++W	expresses	action	all nondeterministic queries	3211-2
all nondeterministic queries	in	constraint	polynomial time	3211-2
<B>	with	constraint	a variation	3212-1
a variation	of	constraint	the choice operator	3212-1
the choice operator	see	action	Bibliographic Notes	3212-1
Bibliographic Notes	in	constraint	CGP93	3212-1
Bibliographic Notes	is introduced	action	CGP93	3212-1
Datalog= programs	by	constraint	atoms	3213-1
Datalog= programs	are extended	action	atoms	3213-1
Datalog= programs	allowing	action	atoms	3213-1
atoms	of	constraint	the form choice	3213-1
the form choice		sequential	X Y	3213-1
X Y	in	constraint	rules	3213-1
rules	of	constraint	bodies	3213-1
bodies		sequential	X	3213-1
X	and	conjunctive	Y	3213-1
Y	are	attribute	where disjoint sets	3213-1
where disjoint sets	of	constraint	variables	3213-1
variables	in	constraint	regular atoms	3213-1
variables	occurring	action	regular atoms	3213-1
regular atoms	of	constraint	the rule	3213-1
Several choice atoms	in	constraint	one rule	3213-2
Several choice atoms	can appear	action	one rule	3213-2
The language	obtained	action	datalog=	3213-3
The language	is called	action	datalog=	3213-3
datalog=	+	sequential	choice	3213-3
The semantics	is	attribute	<B>	3213-4
The semantics	the following	action	<B>	3213-4
The choice atoms	render	action	the immediate consequence operator	3213-5
the immediate consequence operator	of	constraint	datalog=	3213-5
datalog=	+	sequential	choice	3213-5
choice		sequential	a program	3213-5
a program		sequential	P	3213-5
P		sequential	<B>	3213-5
<B>	In	constraint	each application	3213-6
each application	of	constraint	TP	3213-6
TP		sequential	a subset	3213-6
a subset	of	constraint	the applicable valuations	3213-6
the applicable valuations	so that	constraint	each rule	3213-6
the applicable valuations	for	constraint	each rule	3213-6
the applicable valuations	is chosen	action	each rule	3213-6
each rule	containing	action	an occurrence choice	3213-6
an occurrence choice		sequential	X	3213-6
X		sequential	Y	3213-6
Y		sequential	the functional dependency	3213-6
the functional dependency		sequential	X → Y	3213-6
X → Y	holds	action	<B>	3213-6
<B>	is	attribute	one instantiation	3213-7
one instantiation	for	constraint	the Y variables	3213-7
the Y variables	for	constraint	each instantiation	3213-7
the Y variables	is chosen	action	each instantiation	3213-7
each instantiation	of	constraint	the X variables	3213-7
the nondeterministic choices	at	constraint	each application	3213-8
the nondeterministic choices	operated	action	each application	3213-8
each application	of	constraint	TP	3213-8
TP	for	constraint	a given occurrence	3213-8
a given occurrence	of	constraint	a choose atom	3213-8
a choose atom	Moreover extend	action	the choices	3213-8
the choices	in	constraint	previous applications	3213-8
the choices	made	action	previous applications	3213-8
previous applications	of	constraint	TP	3213-8
TP	for	constraint	that atom	3213-8
<B>	Thus choose	action	a more global nature	3213-9
<B>	has	action	a more global nature	3213-9
a more global nature	than	constraint	the witness operator	3213-9
<B>	Although	constraint	negation	3213-10
negation	in	constraint	datalog=	3213-10
negation	is not used	action	datalog=	3213-10
datalog=	+	sequential	choice	3213-10
choice		sequential	it	3213-10
it	can be simulated	action	<B>	3213-10
datalog=	+	sequential	choice	3213-11
choice		sequential	The following program	3213-11
The following program	in	constraint	¯ P	3213-11
The following program	computes	action	¯ P	3213-11
¯ P		sequential	the complement	3213-11
the complement	of	constraint	a nonempty relation P	3213-11
a nonempty relation P	with	constraint	respect	3213-11
respect	to	constraint	relation	3213-11
relation		sequential	a universal T	3213-11
a universal T	of	constraint	the same arity	3213-11
the same arity		sequential	CGP93	3213-11
CGP93		sequential	TAG	3213-11
TAG		sequential	X	3213-11
X		sequential	0	3213-11
0		sequential	TAG	3213-11
TAG		sequential	X	3213-11
X		sequential	1	3213-11
1		sequential	COMP	3213-11
COMP		sequential	X	3213-11
X		sequential	I	3213-11
I		sequential	TAG	3213-11
TAG		sequential	X	3213-11
X		sequential	I	3213-11
I	choose	action	X	3213-11
X		sequential	I	3213-11
I		sequential	P	3213-11
P		sequential	X	3213-11
<B>	When first applied	action	it	3213-12
it	with	constraint	each X	3213-12
it	associates	action	each X	3213-12
each X	in	constraint	P	3213-12
P		sequential	the tag	3213-12
the tag		sequential	I	3213-12
I	=	sequential	0	3213-12
<B>	At	constraint	the second application	3213-13
the second application		sequential	it	3213-13
it	chooses	action	a tag	3213-13
a tag	of	constraint	0	3213-13
0	or	conjunctive	1	3213-13
1	for	constraint	all tuples	3213-13
all tuples	in	constraint	T	3213-13
tuples	in	constraint	P	3213-14
P	by	constraint	0	3213-14
P	However have already been tagged	action	0	3213-14
0	in	constraint	the previous application	3213-14
the previous application	of	constraint	the tuples	3213-14
the previous application	choose	action	the tuples	3213-14
the tuples	by	constraint	1	3213-14
the tuples	tagged	action	1	3213-14
1	in	constraint	the complement	3213-14
1	are	attribute	so precisely those	3213-14
Exercises		sequential	Exercises	3214-1
<B>	while	constraint	Q	3215-1
<B>	+	sequential	Q	3215-1
<B>	Let	action	Q	3215-1
Q	be	attribute	the extension of	3215-1
the extension of	while	constraint	loops	3215-1
the extension of	+	sequential	loops	3215-1
the extension of	allowing	action	loops	3215-1
loops	of	constraint	the form	3215-1
the form	while	constraint	q	3215-1
q		sequential	R1	3215-1
<B>	.	sequential	<B>	3215-2
<B>	.	sequential	<B>	3215-3
Rn	do	action	where q ∈ Q	3215-4
where q ∈ Q	and	conjunctive	R1	3215-4
<B>	.	sequential	<B>	3215-5
<B>	.	sequential	<B>	3215-6
Rn	are	attribute	relation variables	3215-7
relation variables	with	constraint	the schema	3215-7
the schema	of	constraint	q	3215-7
<B>	Intuitively allows	action	us	3215-8
us	to	constraint	R1	3215-8
us	whether	constraint	R1	3215-8
us	ask	action	R1	3215-8
<B>	.	sequential	<B>	3215-9
<B>	.	sequential	<B>	3215-10
Rn	have	action	property q	3215-11
<B>	while	constraint	Q	3215-12
<B>	+	sequential	Q	3215-12
Q	Clearly generally has	action	more power	3215-12
more power	than	constraint	<B>	3215-12
more power	while	constraint	<B>	3215-12
more power	+	sequential	<B>	3215-12
<B>	For	constraint	example	3215-13
example		sequential	the query	3215-13
the query	in	constraint	even }	3215-13
the query	while	constraint	even }	3215-13
the query	+	sequential	even }	3215-13
the query	is	attribute	even trivially expressible	3215-13
One	if	constraint	there	3216-1
One	might wonder	action	there	3216-1
there	is	attribute	choice	3216-1
choice	of	constraint	Q such	3216-1
Q such		sequential	that while	3216-1
<B>	Let	action	ptime	3217-1
ptime	k	action	the set	3217-1
ptime	denote	action	the set	3217-1
the set	of	constraint	properties	3217-1
properties		sequential	whose time complexity	3217-1
whose time complexity	by	constraint	some polynomial	3217-1
whose time complexity	is bounded	action	some polynomial	3217-1
some polynomial	of	constraint	degree k	3217-1
Hint		sequential	Hint	3217-2
<B>	.	sequential	<B>	3217-3
<B>	.	sequential	<B>	3217-4
qm	of	constraint	integers	3217-5
integers		sequential	each qi	3217-5
each qi		sequential	n	3217-5
n	in	constraint	time	3217-5
n	where can be checked	action	time	3217-5
time	in	constraint	n	3217-5
n		sequential	the program	3217-5
the program	to	constraint	a Boolean combination	3217-5
the program	is	attribute	equivalent	3217-5
a Boolean combination	of	constraint	tests	3217-5
tests	n	conjunctive	≥	3217-5
≥		sequential	j	3217-5
j	n	conjunctive	j	3217-5
j	=	sequential	j	3217-5
j		sequential	qi	3217-5
qi		sequential	n	3217-5
n	n	conjunctive	where the size	3217-5
n	is	attribute	where the size	3217-5
where the size	of	constraint	the input	3217-5
the input		sequential	0 ≤	3217-5
0 ≤		sequential	j	3217-5
j	≤	sequential	N	3217-5
N	and	conjunctive	1 ≤	3217-5
1 ≤		sequential	i	3217-5
i		sequential	≤ m	3217-5
Languages		sequential	Languages	3218-1
Riccardo		sequential	Riccardo	3219-1
Sergio		sequential	Sergio	3220-1
Vittorio		sequential	Vittorio	3221-1
<B>	In	constraint	previous chapters	3222-1
previous chapters		sequential	we	3222-1
we	studied	action	a number	3222-1
a number	of	constraint	powerful query languages	3222-1
powerful query languages		sequential	the fixpoint	3222-1
the fixpoint	while	constraint	queries	3222-1
the fixpoint	and	conjunctive	queries	3222-1
there	Nonetheless are	action	queries	3222-2
queries	that	constraint	these languages	3222-2
these languages	can not express	action	<B>	3222-2
<B>	As	constraint	the introduction	3222-3
<B>	in	constraint	the introduction	3222-3
<B>	pointed out	action	the introduction	3222-3
the introduction	to	constraint	Chapter 14	3222-3
Chapter 14		sequential	fixpoint	3222-3
fixpoint	within	constraint	ptime	3222-3
fixpoint	lies	action	ptime	3222-3
ptime	while	constraint	pspace	3222-3
ptime	within	constraint	pspace	3222-3
ptime	and	conjunctive	pspace	3222-3
The complexity bound	that	constraint	there	3222-4
The complexity bound	implies	action	there	3222-4
there	are	attribute	queries	3222-4
queries	of	constraint	complexity	3222-4
complexity	than	constraint	pspace	3222-4
pspace		sequential	that	3222-4
that	in	constraint	the languages	3222-4
that	are	attribute	not expressible	3222-4
the languages	considered so far	action	<B>	3222-4
we	Moreover showed	action	simple specific queries	3222-5
simple specific queries		sequential	that	3222-5
that	in	constraint	not fixpoint	3222-5
that	are	attribute	not fixpoint	3222-5
not fixpoint	or	conjunctive	while	3222-5
while		sequential	the query even	3222-5
<B>	In	constraint	this chapter	3223-1
this chapter		sequential	we	3223-1
we	exhibit	action	several powerful languages	3223-1
several powerful languages		sequential	that	3223-1
that	have	action	no complexity	3223-1
no complexity	on	constraint	the queries	3223-1
no complexity	bound	action	the queries	3223-1
the queries		sequential	they	3223-1
they	can express	action	<B>	3223-1
We	toward	constraint	languages	3223-2
We	build up	action	languages	3223-2
languages		sequential	that	3223-2
that	are	attribute	complete	3223-2
they	express	action	all queries	3223-2
<B>	that	constraint	the notion	3223-3
<B>	Recall	action	the notion	3223-3
the notion	of	constraint	query	3223-3
query	in	constraint	Chapter 16	3223-3
query	was made	attribute	formal	3223-3
a query	is	attribute	Basically a mapping	3224-1
Basically a mapping	from	constraint	instances	3224-1
instances	of	constraint	a fixed input schema	3224-1
a fixed input schema	to	constraint	instances	3224-1
instances	of	constraint	a fixed answer schema	3224-1
a fixed answer schema		sequential	that	3224-1
that	and	conjunctive	<B>	3224-1
that	is	attribute	computable	3224-1
<B>	that	constraint	a consequence	3224-2
<B>	as	constraint	a consequence	3224-2
<B>	Recall	action	a consequence	3224-2
a consequence		sequential	answers	3224-2
answers	to	constraint	queries	3224-2
queries	contain	action	only constants	3224-2
only constants	from	constraint	the input	3224-2
the input	except	constraint	possibly some finite set	3224-2
the input	for	constraint	possibly some finite set	3224-2
the input	fixed	action	possibly some finite set	3224-2
possibly some finite set	of	constraint	new constants	3224-2
We	with	constraint	a language	3225-1
We	begin	action	a language	3225-1
a language		sequential	that	3225-1
that	while	constraint	arbitrary computing power	3225-1
that	by	constraint	arbitrary computing power	3225-1
that	extends	action	arbitrary computing power	3225-1
that	providing	action	arbitrary computing power	3225-1
arbitrary computing power	outside	constraint	the database	3225-1
the database	yields	action	a language	3225-1
a language	while	constraint	N	3225-1
a language	denoted	action	N	3225-1
N	in	constraint	the style	3225-1
the style	of	constraint	embedded relational languages	3225-1
embedded relational languages	like	constraint	C+SQL	3225-1
<B>	to	constraint	the simplest cure	3225-2
<B>	would seem	action	the simplest cure	3225-2
<B>	provide	action	the simplest cure	3225-2
the simplest cure	for	constraint	the computational limitations	3225-2
the computational limitations	of	constraint	the languages	3225-2
the languages	exhibited so far	action	<B>	3225-2
There	is	attribute	no complexity	3225-3
no complexity	on	constraint	the queries	3225-3
no complexity	bound	action	the queries	3225-3
the queries	while	constraint	N	3225-3
N	can express	action	<B>	3225-3
we	that	constraint	N	3225-4
we	while	constraint	N	3225-4
we	Surprisingly show	action	N	3225-4
N	is	attribute	not complete	3225-4
<B>	In	constraint	fact	3225-5
fact	while	constraint	N	3225-5
N	can not express	action	certain simple queries	3225-5
certain simple queries	including	action	the infamous query even	3225-5
<B>	while	constraint	N	3225-6
N	because	constraint	the external computation	3225-6
N	is	attribute	not complete	3225-6
the external computation	has	action	limited interaction	3225-6
limited interaction	with	constraint	the database	3225-6
Complete languages	by	constraint	this limitation	3225-7
Complete languages	are obtained	action	this limitation	3225-7
Complete languages	overcoming	action	this limitation	3225-7
we	Specifically present 1	action	two ways	3225-8
two ways	to	constraint	the ability	3225-8
two ways	by	constraint	the ability	3225-8
two ways	while	constraint	the ability	3225-8
two ways	with	constraint	the ability	3225-8
two ways	do	attribute	this	3225-8
two ways	extending	action	the ability	3225-8
the ability	to	constraint	new values	3225-8
the ability	create	action	new values	3225-8
new values	in	constraint	the course	3225-8
the course	of	constraint	the computation	3225-8
the computation	by	constraint	an untyped version	3225-8
the computation	while	constraint	an untyped version	3225-8
the computation	with	constraint	an untyped version	3225-8
the computation	and	conjunctive	an untyped version	3225-8
the computation	2 extending	action	an untyped version	3225-8
an untyped version	of	constraint	relational algebra	3225-8
relational algebra		sequential	that	3225-8
that	allows	action	relations	3225-8
relations	of	constraint	variable arity	3225-8
<B>	For	constraint	conciseness	3226-1
conciseness	in	constraint	this chapter	3226-1
this chapter		sequential	we	3226-1
we	do not pursue	action	the simultaneous development	3226-1
the simultaneous development	of	constraint	languages	3226-1
languages	in	constraint	the three paradigms	3226-1
the three paradigms		sequential	logic	3226-1
logic	and	conjunctive	<B>	3226-1
we	to	constraint	the algebraic paradigm	3226-2
we	on	constraint	the algebraic paradigm	3226-2
we	Instead choose	action	the algebraic paradigm	3226-2
we	focus	action	the algebraic paradigm	3226-2
analogous languages	in	constraint	the other paradigms	3226-3
analogous languages	However could be developed	action	the other paradigms	3226-3
the other paradigms	see	action	Exercise 18.22	3226-3
WhileN	while	constraint	Arithmetic	3227-1
WhileN	with	constraint	Arithmetic	3227-1
We	that	constraint	it	3227-2
We	have seen	action	it	3227-2
it	within	constraint	pspace	3227-2
it	lies	action	pspace	3227-2
it	Thus does not have	action	full computing power	3227-3
a complete language	Clearly must provide	action	such power	3227-4
<B>	In	constraint	this section	3227-5
this section		sequential	we	3227-5
we	consider	action	an extension of	3227-5
an extension of	while	constraint	full computing power	3227-5
an extension of	does provide	action	full computing power	3227-5
full computing power	outside	constraint	the database	3227-5
we	that	constraint	the resulting language	3227-6
we	Nonetheless will show	action	the resulting language	3227-6
the resulting language	is	attribute	not complete	3227-6
it	to	constraint	more exotic ways	3227-6
it	before	constraint	more exotic ways	3227-6
it	is	attribute	important	3227-6
it	understand	attribute	this	3227-6
it	is	attribute	more exotic ways	3227-6
it	considering	action	more exotic ways	3227-6
more exotic ways	of	constraint	languages	3227-6
more exotic ways	augmenting	action	languages	3227-6
The extension	of	constraint	we	3228-1
The extension	while	constraint	we	3228-1
we	consider	action	us	3228-1
we	allows	action	us	3228-1
us	to	constraint	the database	3228-1
us	outside	constraint	the database	3228-1
us	perform	action	the database	3228-1
the database		sequential	arbitrary computations	3228-1
arbitrary computations	on	constraint	the integers	3228-1
<B>	to	constraint	the while language	3228-2
<B>	Specifically are added	action	the while language	3228-2
The semantics	is	attribute	straightforward	3229-1
All integer variables	to	constraint	zero	3229-2
All integer variables	are initialized	action	zero	3229-2
The semantics	of	constraint	the while change construct	3229-3
the while change construct	by	constraint	the integer variables	3229-3
the while change construct	is not affected	action	the integer variables	3229-3
the integer variables		sequential	the loop	3229-3
the loop	as	constraint	there	3229-3
the loop	is executed	action	there	3229-3
there	is	attribute	a change	3229-3
a change	in	constraint	the content	3229-3
the content	of	constraint	a relational variable	3229-3
The resulting language	by	constraint	N	3230-1
The resulting language	while	constraint	N	3230-1
The resulting language	is denoted	action	N	3230-1
<B>	Because	constraint	the language	3231-1
the language	while	constraint	N	3231-1
N	can simulate	action	an arbitrary number	3231-1
an arbitrary number	of	constraint	counters	3231-1
counters		sequential	it	3231-1
it	on	constraint	the integers	3231-1
it	is	attribute	computationally complete	3231-1
the integers	see	action	Chapter 2	3231-1
<B>		sequential	the following holds Fact	3231-2
<B>	.	sequential	<B>	3231-3
<B>	.	sequential	<B>	3231-4
ik	on	constraint	integers	3231-5
integers		sequential	there	3231-5
there	exists	action	a while N program wf	3231-5
a while N program wf		sequential	that	3231-5
that	computes	action	f	3231-5
f		sequential	i1	3231-5
<B>	.	sequential	<B>	3231-6
<B>	.	sequential	<B>	3231-7
ik	for	constraint	every integer initialization	3231-8
every integer initialization	of	constraint	i1	3231-8
<B>	.	sequential	<B>	3231-9
<B>	.	sequential	<B>	3231-10
<B>		sequential	<B>	3231-11
<B>	In	constraint	wf	3231-12
wf	on	constraint	input	3231-12
wf	stops	action	input	3231-12
input		sequential	i1	3231-12
<B>	.	sequential	<B>	3231-13
<B>	.	sequential	<B>	3231-14
ik iff		sequential	f	3231-15
f	on	constraint	i1	3231-15
f	is defined	action	i1	3231-15
<B>	.	sequential	<B>	3231-16
<B>	.	sequential	<B>	3231-17
ik		sequential	ik	3231-18
<B>	In	constraint	view	3232-1
view	of	constraint	this fact	3232-1
this fact		sequential	one	3232-1
one	while	constraint	N programs	3232-1
one	can use in	action	N programs	3232-1
N programs		sequential	statements n	3232-1
statements n	of	constraint	the form	3232-1
the form	=	sequential	f	3232-1
f		sequential	i1	3232-1
<B>	.	sequential	<B>	3232-2
<B>	.	sequential	<B>	3232-3
ik where	n	conjunctive	i1	3232-4
<B>	.	sequential	<B>	3232-5
<B>	.	sequential	<B>	3232-6
ik	are	attribute	integer variables	3232-7
integer variables	and	conjunctive	f	3232-7
f	is	attribute	a computable function	3232-7
a computable function	on	constraint	the integers	3232-7
<B>	in	constraint	the following example	3232-8
<B>	is used	action	the following example	3232-8
Example		sequential	18.1.1	3233-1
<B>	Consider	action	the query	3233-2
the query	on	constraint	the graph G	3233-2
the graph G		sequential	square	3233-2
square		sequential	G	3233-2
G	if	constraint	the diameter	3233-2
G	=	sequential	the diameter	3233-2
the diameter	of	constraint	G	3233-2
G	is	attribute	a perfect square	3233-2
a perfect square	and	conjunctive	G otherwise	3233-2
<B>	while	constraint	The following N program	3234-1
The following N program	computes	action	square	3234-1
square		sequential	G	3234-1
G		sequential	the output relation	3234-1
the output relation	is	attribute	answer	3234-1
answer		sequential	it	3234-1
it	that	constraint	G	3234-1
it	is assumed	action	G	3234-1
G	=	sequential	∅	3234-1
∅		sequential	i	3234-1
i	=	sequential	0	3234-1
0		sequential	T	3234-1
T	=	sequential	G	3234-1
G		sequential	Highly Expressive Languages	3234-1
Highly Expressive Languages	while	constraint	change	3234-1
change	do begin	action	T	3234-1
T	=	sequential	T ∪	3234-1
T ∪		sequential	πAB	3234-1
πAB		sequential	δ B→C	3234-1
δ B→C		sequential	T	3234-1
T		sequential	δ A→C	3234-1
δ A→C		sequential	G	3234-1
G		sequential	increment	3234-1
increment		sequential	end	3234-1
end		sequential	j	3234-1
j	=	sequential	f	3234-1
f	if	constraint	j 0	3234-1
j 0		sequential	answer	3234-1
answer	=	sequential	<B>	3234-1
answer	∅	sequential	<B>	3234-1
<B>		sequential	f	3235-1
f	is	attribute	the function such	3235-1
the function such	that	constraint	f	3235-1
f		sequential	x	3235-1
x	=	sequential	1	3235-1
1	if	constraint	x	3235-1
x	is	attribute	a perfect square	3235-1
a perfect square	and	conjunctive	f	3235-1
f		sequential	x	3235-1
x	= otherwise	sequential	0	3235-1
It	that	constraint	the preceding program	3236-1
It	turns out	action	the preceding program	3236-1
the preceding program	in	constraint	even fixpoint	3236-1
the preceding program	while	constraint	even fixpoint	3236-1
the preceding program	and	conjunctive	even fixpoint	3236-1
the preceding program	can been expressed	attribute	alone	3236-1
even fixpoint	without	constraint	the need	3236-1
the need	for	constraint	arithmetic	3236-1
arithmetic	see	action	Exercise 18.2	3236-1
<B>	is	attribute	However clearly not the case	3236-2
However clearly not the case	in	constraint	<B>	3236-2
<B>	For	constraint	instance	3236-3
instance	while	constraint	N program	3236-3
instance	consider	attribute	the	3236-3
N program	by	constraint	the preceding program	3236-3
N program	f	constraint	the preceding program	3236-3
N program	in	constraint	the preceding program	3236-3
N program	obtained	action	the preceding program	3236-3
N program	replacing	action	the preceding program	3236-3
the preceding program	by	constraint	some arbitrary computable function	3236-3
<B>	Despite	constraint	its considerable power	3237-1
its considerable power	while	constraint	N	3237-1
N	can not express	action	certain simple queries	3237-1
certain simple queries		sequential	<B>	3237-1
There	are	attribute	several ways	3237-2
several ways	to	constraint	we	3237-2
several ways	as	constraint	we	3237-2
several ways	show	attribute	this	3237-2
we	for	constraint	while	3237-2
we	just did	action	while	3237-2
<B>	that	constraint	Chapter 17	3237-3
<B>	in	constraint	Chapter 17	3237-3
<B>	Recall	action	Chapter 17	3237-3
Chapter 17		sequential	it	3237-3
it	that	constraint	1	3237-3
it	while	constraint	1	3237-3
it	was shown	action	1	3237-3
it	has	action	1	3237-3
1		sequential	a 0 law	3237-3
It	that	constraint	N	3237-4
It	while	constraint	N	3237-4
It	turns out	action	N	3237-4
N	also has	action	1	3237-4
1		sequential	a 0 law	3237-4
a 0 law	although	constraint	the scope	3237-4
a 0 law	beyond	constraint	the scope	3237-4
a 0 law	proving	attribute	this	3237-4
a 0 law	is	attribute	the scope	3237-4
the scope	of	constraint	this book	3237-4
there	Thus are	action	many queries	3237-5
many queries	that	constraint	N	3237-5
many queries	while	constraint	N	3237-5
many queries	including	action	N	3237-5
N	can not express	action	<B>	3237-5
One	can also give	action	a direct proof	3237-6
a direct proof	that	constraint	N	3237-6
a direct proof	by	constraint	N	3237-6
a direct proof	while	constraint	N	3237-6
a direct proof	even can not be expressed	action	N	3237-6
N	by	constraint	the hyperplane technique	3237-6
N	extending straightforwardly	action	the hyperplane technique	3237-6
the hyperplane technique	in	constraint	the direct proof	3237-6
the hyperplane technique	used	action	the direct proof	3237-6
the direct proof	that	constraint	Proposition 17.3.2	3237-6
the direct proof	while	constraint	Proposition 17.3.2	3237-6
the direct proof	can not express even	action	Proposition 17.3.2	3237-6
Proposition 17.3.2	see	action	Exercise 18.3	3237-6
Theorem		sequential	18.1.2	3238-1
Crux	Let	action	q	3239-1
q	be	attribute	a query	3239-1
a query	on	constraint	an ordered database	3239-1
an ordered database	with	constraint	schema	3239-1
schema		sequential	R.	3239-1
R.	Let	action	I	3239-1
I	denote	action	an input instance	3239-1
an input instance	over	constraint	R	3239-1
R	and	conjunctive	α	3239-1
α		sequential	the enumeration	3239-1
the enumeration	of	constraint	constants	3239-1
constants	in	constraint	I	3239-1
I	by	constraint	the relation succ	3239-1
I	given	action	the relation succ	3239-1
<B>	By	constraint	the definition	3239-2
the definition	of	constraint	query	3239-2
query		sequential	there	3239-2
there	exists	action	a Turing machine Mq	3239-2
a Turing machine Mq		sequential	that	3239-2
that	as	constraint	input encα	3239-2
that	given	action	input encα	3239-2
input encα		sequential	I	3239-2
I	as	constraint	output encα	3239-2
I	produces	action	output encα	3239-2
output encα		sequential	q	3239-2
q		sequential	I	3239-2
I		sequential	q	3239-2
q	on	constraint	I	3239-2
q	whenever is defined	action	I	3239-2
<B>	Because	constraint	N	3239-3
<B>	while	constraint	N	3239-3
N	manipulates	action	integers	3239-3
integers		sequential	we	3239-3
we	to	constraint	I	3239-3
we	wish	action	I	3239-3
we	encode	action	I	3239-3
I	as	constraint	an integer	3239-3
an integer		sequential	a Turing machine tape	3239-3
<B>	because	constraint	each word	3239-4
<B>	can be done easily	action	each word	3239-4
each word	over	constraint	some finite alphabet	3239-4
some finite alphabet	with	constraint	k symbols	3239-4
k symbols	with	constraint	some arbitrary order	3239-4
some arbitrary order	among	constraint	the symbols	3239-4
the symbols	as	constraint	an integer	3239-4
the symbols	can be viewed	action	an integer	3239-4
an integer	in	constraint	base k	3239-4
It	to	constraint	there	3239-5
It	that	constraint	there	3239-5
It	is	attribute	easy	3239-5
It	see	action	there	3239-5
there	is	attribute	a computable function fq	3239-5
a computable function fq	on	constraint	the integers	3239-5
the integers		sequential	fq	3239-5
fq		sequential	enc∗α	3239-5
enc∗α		sequential	I	3239-5
I	=	sequential	enc∗α	3239-5
enc∗α		sequential	q	3239-5
q		sequential	I	3239-5
I		sequential	q	3239-5
q	on	constraint	I	3239-5
q	whenever is defined	action	I	3239-5
<B>	because	constraint	N	3239-6
<B>	while	constraint	N	3239-6
N	can express	action	any computable function	3239-6
any computable function	over	constraint	the integers	3239-6
the integers	see	action	the preceding Fact	3239-6
the preceding Fact		sequential	there	3239-6
there	Furthermore exists	action	a while N program wf i q	3239-6
a while N program wf i q		sequential	that	3239-6
that	computes	action	fq	3239-6
It	to	constraint	N	3239-7
It	that	constraint	N	3239-7
It	while	constraint	N	3239-7
It	is left	action	N	3239-7
It	show	action	N	3239-7
N	can compute	action	enc∗α	3239-7
enc∗α		sequential	I	3239-7
I	and	conjunctive	q I	3239-7
I	can decode	action	q I	3239-7
q I	from	constraint	enc∗α	3239-7
enc∗α		sequential	q	3239-7
q		sequential	I	3239-7
<B>	that	constraint	the proof	3239-8
<B>	in	constraint	the proof	3239-8
<B>	Recall	action	the proof	3239-8
the proof	of	constraint	Theorem	3239-8
Theorem		sequential	17.4.2	3239-8
17.4.2		sequential	it	3239-8
it	that	constraint	a relational representation	3239-8
it	while	constraint	a relational representation	3239-8
it	was shown	action	a relational representation	3239-8
it	can compute	action	a relational representation	3239-8
a relational representation	of	constraint	encα	3239-8
encα		sequential	I	3239-8
I	and	conjunctive	it	3239-8
it	can decode	action	q I	3239-8
q I	from	constraint	the representation	3239-8
the representation	of	constraint	encα	3239-8
encα		sequential	q	3239-8
q		sequential	I	3239-8
A slight modification	of	constraint	that construction	3239-9
that construction	to	constraint	S R b b c c c c Figure 18.1	3239-9
that construction	can be used	action	S R b b c c c c Figure 18.1	3239-9
S R b b c c c c Figure 18.1	that	constraint	N	3239-9
S R b b c c c c Figure 18.1	while	constraint	N	3239-9
S R b b c c c c Figure 18.1	show	action	N	3239-9
N	can compute	action	the desired integer encoding	3239-9
the desired integer encoding	and	conjunctive	decoding	3239-9
a while N program	Thus computes	action	q	3239-10
q	in	constraint	three phases	3239-10
<B>	while	constraint	New Values	3240-1
<B>	with	constraint	New Values	3240-1
New Values	as	constraint	the introduction	3240-1
New Values	in	constraint	the introduction	3240-1
New Values	Recall	attribute	that	3240-1
New Values	discussed	action	the introduction	3240-1
the introduction	to	constraint	Chapter 14	3240-1
Chapter 14	while	constraint	pspace	3240-1
Chapter 14	beyond	constraint	pspace	3240-1
Chapter 14	can not go	action	pspace	3240-1
pspace	because	constraint	the computation	3240-1
pspace	throughout	constraint	the computation	3240-1
the computation		sequential	it	3240-1
it	1 uses	action	only values	3240-1
only values	from	constraint	the input	3240-1
the input	and	conjunctive	it	3240-1
it	2 uses	action	relations	3240-1
relations	of	constraint	fixed arity	3240-1
The addition	of	constraint	integers	3240-2
integers	as	constraint	N	3240-2
integers	in	constraint	N	3240-2
integers	while	constraint	N	3240-2
N	is	attribute	one way	3240-2
one way	to	constraint	the space barrier	3240-2
one way	break	action	the space barrier	3240-2
<B>	to	constraint	1	3240-3
<B>	is	attribute	1	3240-3
<B>	relax	action	1	3240-3
1	or	conjunctive	2	3240-3
<B>	Relaxing	action	1	3240-4
1	by	constraint	the creation	3240-4
1	is done	action	the creation	3240-4
1	allowing	action	the creation	3240-4
the creation	of	constraint	new values	3240-4
new values	in	constraint	the input	3240-4
<B>	Relaxing	action	2	3240-5
2	yields	action	an extension of	3240-5
an extension of	while	constraint	untyped algebra	3240-5
an extension of	with	constraint	untyped algebra	3240-5
untyped algebra		sequential	an algebra	3240-5
an algebra	of	constraint	relations	3240-5
relations	with	constraint	variable arities	3240-5
<B>	In	constraint	the next section	3240-6
<B>	and	conjunctive	the next section	3240-6
the next section		sequential	we	3240-6
we	describe	action	two languages	3240-6
two languages	by	constraint	1	3240-6
two languages	obtained	action	1	3240-6
two languages	relaxing	action	1	3240-6
1	and	conjunctive	2	3240-6
2	and	conjunctive	their completeness	3240-6
2	prove	action	their completeness	3240-6
We	first present	action	the extension	3241-1
the extension	of	constraint	denoted whilenew	3241-1
the extension	while	constraint	denoted whilenew	3241-1
denoted whilenew		sequential	which	3241-1
which	allows	action	the creation	3241-1
the creation	of	constraint	new values	3241-1
new values	throughout	constraint	the computation	3241-1
The language	while	constraint	i	3241-2
The language	as	constraint	i	3241-2
The language	is modified	action	i	3241-2
The language	follows	action	i	3241-2
The semantics	of	constraint	Relation R	3242-1
The semantics	as	constraint	Relation R	3242-1
The semantics	is	attribute	Relation R	3242-1
The semantics	i follows	action	Relation R	3242-1
Relation R	by	constraint	each tuple	3242-1
Relation R	is obtained	action	each tuple	3242-1
Relation R	extending	action	each tuple	3242-1
each tuple	of	constraint	S	3242-1
S	by	constraint	one distinct new value	3242-1
one distinct new value	from	constraint	dom	3242-1
dom	in	constraint	the input	3242-1
dom	not occurring	action	the input	3242-1
the input		sequential	the current state	3242-1
the current state	in	constraint	the program	3242-1
the current state	or	conjunctive	the program	3242-1
<B>	For	constraint	example	3242-2
example	if	constraint	the value	3242-2
the value	of	constraint	S	3242-2
S	is	attribute	the relation	3242-2
the relation	in	constraint	Fig	3242-2
R	of	constraint	18.1 the form	3242-3
R	is	attribute	18.1 the form	3242-3
18.1 the form	in	constraint	that figure	3242-3
18.1 the form	shown	action	that figure	3242-3
The values		sequential	α	3242-4
α		sequential	β	3242-4
β		sequential	γ	3242-4
γ	are	attribute	distinct new values1	3242-4
distinct new values1	in	constraint	dom	3242-4
The semantics	of	constraint	R	3243-1
The semantics	while	constraint	R	3243-1
R	do	attribute	s	3243-1
R	is	attribute	that statement	3243-1
that statement	while	constraint	R	3243-1
that statement	is executed	action	R	3243-1
R	is	attribute	nonempty	3243-1
We	while	constraint	change	3244-1
We	could have used instead	action	change	3244-1
change	because	constraint	each looping construct	3244-1
each looping construct	can simulate	attribute	the other	3244-1
<B>	in	constraint	our context	3244-2
our context	of	constraint	value invention	3244-2
value invention		sequential	it	3244-2
it	to	constraint	the more direct control	3244-2
it	is	attribute	However practical	3244-2
it	have	action	the more direct control	3244-2
the more direct control	on	constraint	loops	3244-2
loops	by	constraint	R	3244-2
loops	while	constraint	R	3244-2
loops	provided	action	R	3244-2
Highly Expressive Languages		sequential	Highly Expressive Languages	3245-1
The new values	are	attribute	arbitrary	3245-2
several possible outcomes	are	attribute	so possible	3245-2
several possible outcomes	depending on	action	the choice	3245-2
the choice	of	constraint	values	3245-2
the different outcomes	in	constraint	only the choice	3246-1
the different outcomes	However differ	action	only the choice	3246-1
only the choice	of	constraint	new values	3246-1
<B>	by	constraint	the following Lemma 18.2.1	3246-2
<B>	is formalized	action	the following Lemma 18.2.1	3246-2
there	Then exists	action	an isomorphism	3246-3
an isomorphism		sequential	ρ	3246-3
ρ	from	constraint	J	3246-3
J	to	constraint	J	3246-3
J	is	attribute	′ the identity	3246-3
′ the identity	on	constraint	the constants	3246-3
the constants	in	constraint	I	3246-3
the constants	occurring	action	I	3246-3
I	w	constraint	<B>	3246-3
I	or	conjunctive	<B>	3246-3
The proof	of	constraint	Lemma 18.2.1	3247-1
Lemma 18.2.1	by	constraint	a straightforward induction	3247-1
Lemma 18.2.1	is done	action	a straightforward induction	3247-1
a straightforward induction	on	constraint	the number	3247-1
the number	of	constraint	steps	3247-1
steps	in	constraint	a partial execution	3247-1
a partial execution	of	constraint	I	3247-1
a partial execution	w	constraint	I	3247-1
a partial execution	on	constraint	I	3247-1
I		sequential	Exercise	3247-1
Exercise		sequential	18.7	3247-1
<B>	that	constraint	our definition	3248-1
<B>	Recall	action	our definition	3248-1
our definition	of	constraint	query	3248-1
query	that	constraint	the answer	3248-1
query	requires	action	the answer	3248-1
the answer	be	attribute	unique	3248-1
the query	be	attribute	must deterministic	3248-1
we	Therefore must consider	action	only whilenew programs	3248-2
only whilenew programs		sequential	whose answer	3248-2
whose answer	never contains	action	values	3248-2
values	by	constraint	the new statements	3248-2
values	introduced	action	the new statements	3248-2
Such programs	are called	action	whilenew programs	3248-3
Such programs	behaved	action	whilenew programs	3248-3
It	to	constraint	a syntactic restriction	3248-4
It	is	attribute	possible	3248-4
It	give	action	a syntactic restriction	3248-4
a syntactic restriction	on	constraint	whilenew programs	3248-4
whilenew programs		sequential	that	3248-4
that	guarantees	action	good behavior	3248-4
good behavior	and	conjunctive	a class	3248-4
good behavior	can be checked	action	a class	3248-4
good behavior	yields	action	a class	3248-4
a class	of	constraint	programs	3248-4
programs	to	constraint	all whilenew programs	3248-4
programs	well behaved	action	all whilenew programs	3248-4
all whilenew programs	see	action	Exercises 18.8	3248-4
Exercises 18.8	and	conjunctive	18.9	3248-4
We	to	constraint	whilenew programs	3249-1
We	that	constraint	whilenew programs	3249-1
We	wish	action	whilenew programs	3249-1
We	show	action	whilenew programs	3249-1
We	well behaved	action	whilenew programs	3249-1
whilenew programs	can express	action	all queries	3249-1
we	to	constraint	that whilenew programs	3249-2
we	First have	attribute	sure	3249-2
we	make	attribute	sure	3249-2
we	well behaved	action	that whilenew programs	3249-2
that whilenew programs	in	constraint	fact	3249-2
fact	do express	action	queries	3249-2
<B>	is shown next	action	<B>	3249-3
Lemma		sequential	18.2.2	3250-1
Proof		sequential	Proof	3251-1
Computability	and	conjunctive	genericity	3251-2
genericity	are	attribute	straightforward	3251-2
<B>	be	attribute	a whilenew program	3251-3
<B>	Let	action	a whilenew program	3251-3
<B>	well behaved	action	a whilenew program	3251-3
a whilenew program	with	constraint	R	3251-3
R	and	conjunctive	output	3251-3
output		sequential	input schema answer	3251-3
<B>	Let	action	I	3251-4
I		sequential	I	3251-4
I	be	attribute	′ two possible values	3251-4
′ two possible values	of	constraint	answer	3251-4
answer	after	constraint	the execution	3251-4
the execution	of	constraint	an instance	3251-4
the execution	w	constraint	an instance	3251-4
the execution	on	constraint	an instance	3251-4
an instance		sequential	I	3251-4
I	of	constraint	R.	3251-4
R.	By	constraint	Lemma	3251-4
Lemma		sequential	18.2.1	3251-4
18.2.1		sequential	there	3251-4
there	exists	action	an isomorphism	3251-4
an isomorphism		sequential	ρ	3251-4
ρ	from	constraint	I	3251-4
I	to	constraint	I	3251-4
I	′	attribute	that	3251-4
I	is	attribute	the identity	3251-4
the identity	on	constraint	values	3251-4
values	in	constraint	I	3251-4
I	w	constraint	<B>	3251-4
I	or	conjunctive	<B>	3251-4
<B>	that	constraint	programs	3252-1
<B>	although	constraint	programs	3252-1
<B>	Note	action	programs	3252-1
<B>	well behaved	action	programs	3252-1
programs	with	constraint	respect	3252-1
programs	are	attribute	deterministic	3252-1
respect	to	constraint	their final answer	3252-1
their final answer		sequential	they	3252-1
they	with	constraint	respect	3252-1
they	are	attribute	not deterministic	3252-1
respect	to	constraint	intermediate results	3252-1
intermediate results		sequential	that	3252-1
that	may contain	action	new values	3252-1
We	that	constraint	whilenew programs	3253-1
We	next show	action	whilenew programs	3253-1
We	well behaved	action	whilenew programs	3253-1
whilenew programs	express	action	all queries	3253-1
The basic idea	is	attribute	simple	3253-2
<B>	that	constraint	N	3253-3
<B>	while	constraint	N	3253-3
<B>	Recall	action	N	3253-3
N	on	constraint	ordered databases	3253-3
N	is	attribute	complete	3253-3
<B>	for	constraint	each query	3253-4
<B>	is	attribute	each query	3253-4
each query		sequential	q	3253-4
q		sequential	there	3253-4
there	is	attribute	a while N program	3253-4
a while N program	w	constraint	that	3253-4
that	given	action	an enumeration	3253-4
an enumeration	of	constraint	the input values	3253-4
the input values	in	constraint	a relation succ	3253-4
a relation succ	computes	action	q	3253-4
<B>	If	constraint	an input	3253-5
<B>	given	action	an input	3253-5
an input		sequential	we	3253-5
we	to	constraint	such an enumeration	3253-5
we	were	attribute	able	3253-5
we	construct	action	such an enumeration	3253-5
such an enumeration		sequential	we	3253-5
we	while	constraint	N	3253-5
we	could simulate	action	N	3253-5
N	to	constraint	any desired query	3253-5
N	compute	action	any desired query	3253-5
<B>	Because of	constraint	genericity	3253-6
genericity		sequential	we	3253-6
we	to	constraint	one such enumeration	3253-6
we	can not hope	action	one such enumeration	3253-6
we	construct	action	one such enumeration	3253-6
<B>	constructing	action	all enumerations	3253-7
all enumerations	of	constraint	values	3253-7
values	in	constraint	the input	3253-7
the input	However would not violate	action	genericity	3253-7
Both whilenew	and	conjunctive	the language	3253-8
the language	with	constraint	variable arities	3253-8
variable arities	in	constraint	the next section	3253-8
variable arities	considered	action	the next section	3253-8
the next section	can compute precisely	action	arbitrary queries	3253-8
arbitrary queries	in	constraint	this fashion	3253-8
These computations	yield	action	the same result	3254-1
the same result	for	constraint	all enumerations	3254-1
all enumerations	because	constraint	queries	3254-1
queries	are	attribute	generic	3254-1
the result	of	constraint	the particular enumeration	3254-1
the result	is	attribute	so independent	3254-1
the particular enumeration	to	constraint	the database	3254-1
the particular enumeration	used	action	the database	3254-1
the particular enumeration	encode	action	the database	3254-1
the database	see	action	Chapter 16	3254-1
<B>	Before	constraint	the result	3255-1
<B>	proving	action	the result	3255-1
the result		sequential	we	3255-1
we	show	action	we	3255-1
we	how can construct	action	all the possible enumerations	3255-1
all the possible enumerations	of	constraint	the elements	3255-1
the elements	in	constraint	the active domain	3255-1
the active domain	of	constraint	the input	3255-1
Representation	Let	action	I	3256-1
I	be	attribute	an instance	3256-1
an instance	over	constraint	R.	3256-1
R.	Let	action	Success	3256-1
Success	be	attribute	the set	3256-1
the set	of	constraint	all binary relations	3256-1
all binary relations	defining	action	a successor relation	3256-1
a successor relation	over	constraint	adom	3256-1
adom		sequential	I	3256-1
We	can represent	action	all the enumerations	3256-2
all the enumerations	in	constraint	Success	3256-2
Success	with	constraint	3 ary	3256-2
3 ary		sequential	a relation	3256-2
succ	=	sequential	I	3257-1
I	×	action	}	3257-1
}		sequential	I	3257-1
I	∈	action	Success	3257-1
Success		sequential	αI	3257-1
αI		sequential	I	3257-1
I	∈	action	Success	3257-1
Success	is	attribute	where a set	3257-1
where a set	of	constraint	distinct new values	3257-1
Each such αI	to	constraint	a particular enumeration	3257-2
Each such αI	is used	action	a particular enumeration	3257-2
Each such αI	denote	action	a particular enumeration	3257-2
a particular enumeration	of	constraint	adom	3257-2
adom		sequential	I	3257-2
<B>	For	constraint	example	3257-3
example		sequential	Fig	3257-3
18.2	represents	action	an instance	3257-4
an instance		sequential	I	3257-4
I	and	conjunctive	the corresponding succ	3257-4
Computation	of	constraint	succ	3258-1
there	Clearly is	action	a whilenew program	3258-2
a whilenew program		sequential	that	3258-2
that	given	action	I	3258-2
I	produces	action	a unary relation D	3258-2
a unary relation D	containing	action	all values	3258-2
all values	in	constraint	I	3258-2
<B>	Following is	action	a whilenew program	3258-3
a whilenew program	w	constraint	succ	3258-3
succ		sequential	that	3258-3
that	computes	action	the relation succ	3258-3
the relation succ	from	constraint	D	3258-3
the relation succ	starting	action	D	3258-3
D	using	action	a query q	3258-3
a query q	explained next	action	<B>	3258-3
succ b b b b c c b c b c b c c c c c b c b c b c b b b b c c c b c b c b c b c c c b c c c c b b b c b c b c b c b b b		sequential	c b Figure	3259-1
c b Figure		sequential	18.2	3259-1
18.2		sequential	succ Highly Expressive Languages succ	3259-1
succ Highly Expressive Languages succ	=	sequential	σ	3259-1
σ		sequential	1=2	3259-1
1=2		sequential	D	3259-1
D		sequential	×	3259-1
×		sequential	D	3259-1
D	while	constraint	8	3259-1
8	do begin	action	S	3259-1
S	=	sequential	8	3259-1
<B>	=	sequential	x	3260-1
x		sequential	y	3260-1
y	α′	sequential	<B>	3260-1
end		sequential	end	3261-1
An enumeration	of	constraint	a subset	3261-2
a subset	of	constraint	D	3261-2
D	of	constraint	successor	3261-2
D	consists	action	successor	3261-2
successor		sequential	a relation	3261-2
a relation	over	constraint	that subset	3261-2
<B>	As	constraint	the program	3261-3
<B>	mentioned earlier	action	the program	3261-3
the program	associates	action	a marking	3261-3
a marking		sequential	invented value	3261-3
invented value	with	constraint	each such successor relation	3261-3
<B>	During	constraint	the computation	3262-1
the computation		sequential	succ	3262-1
succ	contains	action	the successor relation	3262-1
the successor relation	of	constraint	subsets	3262-1
subsets	of	constraint	size	3262-1
size		sequential	i	3262-1
i	computed so far	action	<B>	3262-1
A triple a b	that	constraint	b	3262-2
A triple a b	α	sequential	b	3262-2
A triple a b	indicates	action	b	3262-2
b	in	constraint	a enumeration	3262-2
b	follows	action	a enumeration	3262-2
a enumeration	denoted	action	α	3262-2
The first instruction	computes	action	the enumerations	3263-1
the enumerations	of	constraint	subsets	3263-1
subsets	of	constraint	size	3263-1
size		sequential	2	3263-1
2		sequential	the distinct pairs	3263-1
the distinct pairs	of	constraint	elements	3263-1
elements	of	constraint	D	3263-1
D	and	conjunctive	them	3263-1
D	marks	action	them	3263-1
them	with	constraint	new values	3263-1
<B>	At	constraint	each iteration	3263-2
each iteration		sequential	8	3263-2
8	for	constraint	each enumeration	3263-2
8	indicates	action	each enumeration	3263-2
each enumeration		sequential	the elements	3263-2
the elements		sequential	that	3263-2
that	in	constraint	this enumeration	3263-2
that	are	attribute	missing	3263-2
relation 8	More precisely must contain	action	the following set	3263-3
the following set	of	constraint	triples	3263-3
<B>	in	constraint	the successor relation	3264-1
<B>	b does not occur	action	the successor relation	3264-1
the successor relation	to	constraint	α	3264-1
the successor relation	corresponding	action	α	3264-1
The relational query		sequential	q	3265-1
q	computes	action	the set 8	3265-1
the set 8	given	action	a particular relation succ	3265-1
<B>	If	constraint	8	3265-2
8	for	constraint	each α	3265-2
8	is	attribute	not empty	3265-2
each α		sequential	a new value α′	3265-2
a new value α′	for	constraint	each element	3265-2
a new value α′	is created	action	each element	3265-2
each element	in	constraint	α	3265-2
each element	missing	action	α	3265-2
α		sequential	the enumeration	3265-2
the enumeration		sequential	α	3265-2
α	in	constraint	all possible ways	3265-2
α	is extended	action	all possible ways	3265-2
all possible ways	with	constraint	the missing elements	3265-2
all possible ways	of	constraint	the missing elements	3265-2
<B>	yields	action	as many new enumerations	3265-3
as many new enumerations	from	constraint	each α	3265-3
each α	as	constraint	missing elements	3265-3
<B>	until	constraint	8	3266-1
<B>	is iterated	action	8	3266-1
8	at	constraint	which point	3266-1
8	becomes	attribute	empty	3266-1
which point		sequential	all enumerations	3266-1
all enumerations	are	attribute	complete	3266-1
<B>	that	constraint	D	3267-1
<B>	if	constraint	D	3267-1
<B>	Note	action	D	3267-1
D	n	conjunctive	elements	3267-1
D	contains	action	elements	3267-1
elements		sequential	the final result succ	3267-1
the final result succ	contains	action	n	3267-1
enumerations		sequential	enumerations	3267-2
Theorem		sequential	18.2.3	3268-1
Crux		sequential	Crux	3269-1
<B>	Assume	action	the query	3269-2
the query	is	attribute	generic	3269-2
C	with	constraint	C	3269-2
C	=	sequential	∅	3269-2
The proof	for	constraint	the case	3269-3
The proof	is easily modified	action	the case	3269-3
the case		sequential	the query	3269-3
the query	is	attribute	when C	3269-3
when C	with	constraint	C	3269-3
C		sequential	∅	3269-3
It	to	constraint	N program	3269-4
It	that	constraint	N program	3269-4
It	for	constraint	N program	3269-4
It	while	constraint	N program	3269-4
It	is	attribute	sufficient	3269-4
It	observe	attribute	each	3269-4
N program		sequential	there	3269-4
there	exists	action	an equivalent whilenew program	3269-4
there	well behaved	action	an equivalent whilenew program	3269-4
<B>	that	constraint	<B>	3270-1
<B>	Suppose	action	<B>	3270-1
<B>	holds	action	<B>	3270-1
<B>	w	constraint	succ the whilenew program computing succ	3270-2
<B>	be	attribute	succ the whilenew program computing succ	3270-2
<B>	Let	action	succ the whilenew program computing succ	3270-2
succ the whilenew program computing succ	from	constraint	I	3270-2
succ the whilenew program computing succ	given	action	I	3270-2
I	over	constraint	R.	3270-2
R.	By	constraint	Theorem	3270-2
Theorem		sequential	18.1.2	3270-2
18.1.2	and	conjunctive	there	3270-2
there	exists	action	a whilenew program	3270-2
a whilenew program	w	constraint	that	3270-2
that	computes	action	q	3270-2
q	using	action	a successor relation succ	3270-2
We	construct	action	another whilenew program	3270-3
another whilenew program	w	constraint	that	3270-3
that	computes	action	q	3270-3
q	given	action	I	3270-3
I	and	conjunctive	<B>	3270-3
<B>	w	constraint	succ	3270-4
succ	in	constraint	all possible enumerations	3270-4
succ	for	constraint	all possible enumerations	3270-4
succ	Intuitively is run	attribute	parallel	3270-4
all possible enumerations	by	constraint	<B>	3270-4
all possible enumerations	succ provided	attribute	succ	3270-4
All computations	produce	action	the same result	3270-5
the same result	in	constraint	answer	3270-5
the same result	and	conjunctive	answer	3270-5
the same result	are placed	action	answer	3270-5
The computations	for	constraint	different enumerations	3270-6
different enumerations	in	constraint	succ	3270-6
succ	by	constraint	the α	3270-6
succ	are identified	action	the α	3270-6
the α	marking	action	the enumeration	3270-6
the enumeration	in	constraint	<B>	3270-6
<B>	To	constraint	this end	3270-7
this end		sequential	each relation R	3270-7
each relation R	of	constraint	arity k	3270-7
arity k	in	constraint	succ	3270-7
arity k	w	constraint	succ	3270-7
succ	by	constraint	a relation	3270-7
succ	is replaced	action	a relation	3270-7
a relation		sequential	R	3270-7
R	of	constraint	arity k	3270-7
arity k	+	sequential	1	3270-7
The extended database relations	by	constraint	statements	3270-8
The extended database relations	are first initialized	action	statements	3270-8
statements	of	constraint	the form R	3270-8
the form R	=	sequential	R × π 3	3270-8
R × π 3		sequential	succ	3270-8
the instructions	of	constraint	succ	3270-9
the instructions	w	constraint	succ	3270-9
succ	as	constraint	<B>	3270-9
succ	Next are modified	action	<B>	3270-9
succ	follows	action	<B>	3270-9
Finally the instruction answer	=	sequential	π	3271-1
π		sequential	1	3271-1
1	n	conjunctive	answer	3271-1
answer	n	conjunctive	arity	3271-1
answer	=	sequential	arity	3271-1
arity		sequential	answer	3271-1
answer	at	constraint	the end	3271-1
answer	is appended	action	the end	3271-1
the end	of	constraint	the program	3271-1
<B>	by	constraint	induction	3271-2
<B>	following	action	induction	3271-2
<B>	can be shown	action	induction	3271-2
induction	on	constraint	the steps	3271-2
the steps	of	constraint	a partial execution	3271-2
a partial execution	of	constraint	succ	3271-2
a partial execution	w	constraint	succ	3271-2
succ	on	constraint	I	3271-2
I		sequential	Exercise	3271-2
Exercise		sequential	18.10	3271-2
18.10	with	constraint	α	3271-2
18.10	marked	action	α	3271-2
α	with	constraint	the value	3271-2
α	coincides	action	the value	3271-2
the value	of	constraint	R	3271-2
R	at	constraint	the same point	3271-2
the same point	in	constraint	the computation	3271-2
the computation	w	constraint	succ	3271-2
succ	on	constraint	I	3271-2
succ	when is run	action	I	3271-2
I	and	conjunctive	succ	3271-2
succ	is	attribute	the successor relation	3271-2
the successor relation	to	constraint	α	3271-2
the successor relation	corresponding	action	α	3271-2
<B>	In	constraint	the end	3272-1
<B>	at	constraint	the end	3272-1
the end	of	constraint	the computation	3272-1
the computation	of	constraint	succ	3272-1
the computation	w	constraint	succ	3272-1
succ	on	constraint	I	3272-1
I		sequential	answer	3272-1
answer	w	constraint	α	3272-1
answer	=	sequential	α	3272-1
α		sequential	I	3272-1
I		sequential	× α }	3272-1
× α }		sequential	α	3272-1
α	over	constraint	the enumeration markers	3272-1
α	where ranges	action	the enumeration markers	3272-1
<B>	Because w	constraint	α	3272-2
α		sequential	I	3272-2
I	=	sequential	q	3272-2
q		sequential	I	3272-2
I	for	constraint	each α	3272-2
each α		sequential	it	3272-2
it	follows	action	that answer	3272-2
that answer	contains	action	q	3272-2
q		sequential	I	3272-2
I	at	constraint	the end	3272-2
the end	of	constraint	the computation	3272-2
query		sequential	q	3272-3
q	by	constraint	a whilenew program	3272-3
q	is	attribute	Thus computable	3272-3
q	well behaved	action	a whilenew program	3272-3
it	to	constraint	<B>	3273-1
it	Thus remains	action	<B>	3273-1
it	show	action	<B>	3273-1
Integer variables	as	constraint	<B>	3273-2
Integer variables	are easily simulated	action	<B>	3273-2
Integer variables	follows	action	<B>	3273-2
An integer variable		sequential	i	3273-3
i	by	constraint	a binary variable Ri	3273-3
i	is represented	action	a binary variable Ri	3273-3
<B>	If	constraint	i	3273-4
i	contains	action	the integer n	3273-4
the integer n		sequential	Ri	3273-4
Ri	contains	action	a successor relation	3273-4
a successor relation	for	constraint	n	3273-4
n	+	sequential	1	3273-4
1		sequential	distinct new values	3273-4
We	that	constraint	whilenew programs	3274-1
We	showed	action	whilenew programs	3274-1
We	well behaved	action	whilenew programs	3274-1
whilenew programs	with	constraint	respect	3274-1
whilenew programs	are	attribute	complete	3274-1
respect	to	constraint	our definition	3274-1
our definition	of	constraint	query	3274-1
<B>	that	constraint	whilenew programs	3274-2
<B>	Recall	action	whilenew programs	3274-2
whilenew programs		sequential	that	3274-2
that	are not well behaved	action	a different kind	3274-2
that	can compute	action	a different kind	3274-2
a different kind	of	constraint	query	3274-2
query		sequential	that	3274-2
that		sequential	we	3274-2
we	excluded deliberately	action	which	3274-2
which	contains	action	new values	3274-2
new values	in	constraint	the answer	3274-2
It	that	constraint	such queries	3274-3
It	turns out	action	such queries	3274-3
such queries	in	constraint	the context	3274-3
such queries	arise naturally	action	the context	3274-3
the context	of	constraint	object	3274-3
object	oriented	action	databases	3274-3
databases		sequential	new object identifiers	3274-3
new object identifiers	in	constraint	query results	3274-3
new object identifiers	where appear	action	query results	3274-3
query results	see	action	Chapter 21	3274-3
<B>	requires	action	our definition	3275-1
<B>	extending	action	our definition	3275-1
our definition	of	constraint	query	3275-1
<B>	In	constraint	the query	3275-2
the query	as	constraint	the different answers	3275-2
the query	but	conjunctive	the different answers	3275-2
the query	is	attribute	nondeterministic	3275-2
the query	discussed earlier	action	the different answers	3275-2
the different answers	in	constraint	only the particular choice	3275-2
the different answers	differ	action	only the particular choice	3275-2
only the particular choice	of	constraint	new values	3275-2
<B>	to	constraint	the following extended notion	3275-3
<B>	leads	action	the following extended notion	3275-3
the following extended notion	of	constraint	query	3275-3
query		sequential	Definition 18.2.4 Highly Expressive Languages b Figure 18.3	3275-3
<B>	Let	action	Q	3276-1
Q	be	attribute	a determinate query	3276-1
<B>	If	constraint	I	3276-2
I		sequential	J ∈ Q	3276-2
J ∈ Q	and	conjunctive	ρ	3276-2
ρ	is	attribute	one	3276-2
one	to	constraint	one	3276-2
one		sequential	a mapping	3276-2
a mapping	on	constraint	constants	3276-2
constants	leaving	action	I	3276-2
I	fixed	action	I	3276-2
I		sequential	ρ	3276-2
ρ		sequential	J	3276-2
J		sequential	∈ Q	3276-2
The question	whether	constraint	whilenew	3277-1
The question	arises	action	whilenew	3277-1
whilenew	with	constraint	respect	3277-1
whilenew	remains	attribute	complete	3277-1
respect	to	constraint	this extended notion	3277-1
this extended notion	of	constraint	query	3277-1
the answer	is	attribute	Surprisingly negative	3277-2
Each whilenew query	is	attribute	determinate	3277-3
we	However exhibit	action	a simple determinate query	3277-4
a simple determinate query		sequential	that	3277-4
that		sequential	whilenew	3277-4
whilenew	can not express	action	<B>	3277-4
<B>	Let	action	q	3277-5
q	be	attribute	the query	3277-5
the query	with	constraint	input schema	3277-5
input schema		sequential	R	3277-5
R	=	sequential	S }	3277-5
S }		sequential	S	3277-5
S	and	conjunctive	output G	3277-5
S	is	attribute	where unary	3277-5
output G		sequential	G	3277-5
G	is	attribute	where binary	3277-5
<B>	Let	action	q	3277-6
q	as	constraint	<B>	3277-6
q	be defined	action	<B>	3277-6
q	follows	action	<B>	3277-6
18.3		sequential	18.3	3277-7
Theorem		sequential	18.2.5	3278-1
Proof		sequential	Proof	3279-1
<B>	w	constraint	a whilenew program	3279-2
<B>	is	attribute	a whilenew program	3279-2
<B>	Suppose	action	a whilenew program	3279-2
a whilenew program	expressing	action	q	3279-2
<B>	Consider	action	the sequence	3280-1
the sequence	of	constraint	steps	3280-1
steps	in	constraint	the execution	3280-1
the execution	of	constraint	an input	3280-1
the execution	w	constraint	an input	3280-1
the execution	on	constraint	an input	3280-1
an input		sequential	I	3280-1
I	=	sequential	b }	3280-1
We	without	constraint	loss	3280-2
We	can assume	action	loss	3280-2
loss	of	constraint	generality	3280-2
generality		sequential	that	3280-2
that		sequential	no invented value	3280-2
no invented value	from	constraint	the database	3280-2
no invented value	is ever deleted	action	the database	3280-2
the database	otherwise modify	action	the program	3280-2
the program	to	constraint	all invented values	3280-2
the program	keep	action	all invented values	3280-2
all invented values	in	constraint	some new unary relation	3280-2
<B>	For	constraint	each invented value	3280-3
each invented value	in	constraint	the computation	3280-3
each invented value	occurring	action	the computation	3280-3
the computation		sequential	we	3280-3
we	define	action	a trace	3280-3
a trace		sequential	that	3280-3
that	records	action	the value	3280-3
the value	and	conjunctive	it	3280-3
the value	how was invented	action	it	3280-3
the value	uniquely identifies	action	it	3280-3
trace		sequential	α	3280-4
α	as	constraint	<B>	3280-4
α	More precisely is defined inductively	action	<B>	3280-4
α	follows	action	<B>	3280-4
<B>	If	constraint	α	3280-5
α	is	attribute	a constant	3280-5
trace		sequential	α	3280-5
α	=	sequential	α	3280-5
<B>	Suppose	action	α	3280-6
α	is	attribute	a new value	3280-6
a new value	at	constraint	step	3280-6
a new value	created	action	step	3280-6
step		sequential	i	3280-6
i	with	constraint	a new statement	3280-6
a new statement	associating	action	it	3280-6
it	with	constraint	tuple x1	3280-6
<B>	.	sequential	<B>	3280-7
<B>	.	sequential	<B>	3280-8
xk		sequential	xk	3280-9
Then trace		sequential	α	3280-10
α	=	sequential	i	3280-10
i		sequential	trace	3280-10
trace		sequential	x1	3280-10
<B>	.	sequential	<B>	3280-11
<B>	.	sequential	<B>	3280-12
<B>	trace	action	xk	3280-13
one	Clearly can extend	action	trace	3280-14
trace	to	constraint	tuples	3280-14
tuples	and	conjunctive	rela tions	3280-14
rela tions	in	constraint	the natural manner	3280-14
It	is easily shown	action	Exercise	3280-15
Exercise		sequential	18.11	3280-15
18.11	by	constraint	induction	3280-15
induction	on	constraint	the number	3280-15
the number	of	constraint	steps	3280-15
steps	in	constraint	a partial execution	3280-15
a partial execution	of	constraint	I	3280-15
a partial execution	w	constraint	I	3280-15
a partial execution	on	constraint	I	3280-15
<B>	Consider now	action	trace	3281-1
trace		sequential	q	3281-1
q		sequential	I	3281-1
I	and	conjunctive	the automorphism ρ	3281-1
the automorphism ρ	of	constraint	I	3281-1
I	of	constraint	therefore trace	3281-1
I	and	conjunctive	therefore trace	3281-1
therefore trace		sequential	q	3281-1
q		sequential	I	3281-1
I	by	constraint	ρ	3281-1
I	defined	action	ρ	3281-1
ρ	a =	sequential	b	3281-1
b		sequential	ρ	3281-1
ρ		sequential	b	3281-1
b	=	sequential	a	3281-1
<B>	that	constraint	ρ 2	3281-2
<B>	Note	action	ρ 2	3281-2
ρ 2	=	sequential	id	3281-2
id		sequential	the identity	3281-2
the identity	and	conjunctive	ρ	3281-2
ρ	=	sequential	ρ −1	3281-2
<B>	Consider	action	ρ	3281-3
ρ		sequential	trace	3281-3
trace	ψ	sequential	0	3281-3
<B>	Because	constraint	ψ0	3281-4
ψ0		sequential	b	3281-4
b		sequential	∈ q	3281-4
∈ q		sequential	I	3281-4
I		sequential	it	3281-4
it	follows	action	that trace	3281-4
that trace	ψ	sequential	0	3281-4
0		sequential	b ∈ trace	3281-4
b ∈ trace		sequential	q	3281-4
q		sequential	I	3281-4
<B>	Because	constraint	ρ	3281-5
ρ	=	sequential	it	3281-5
it	b a further follows	action	that ρ	3281-5
that ρ		sequential	trace	3281-5
trace	ψ	sequential	0	3281-5
0		sequential	a ∈ trace	3281-5
a ∈ trace		sequential	q	3281-5
q		sequential	I	3281-5
I		sequential	ρ	3281-5
ρ		sequential	trace	3281-5
trace	ψ	sequential	0	3281-5
0	either	conjunctive	so trace	3281-5
0	is	attribute	so trace	3281-5
so trace	ψ	sequential	1	3281-5
1	or	conjunctive	trace	3281-5
trace	ψ	sequential	3	3281-5
<B>	Suppose	action	ρ	3281-6
ρ		sequential	trace	3281-6
trace		sequential	ψ	3281-6
ψ		sequential	0	3281-6
0	=	sequential	trace	3281-6
trace	ψ	sequential	1	3281-6
1		sequential	the other case	3281-6
the other case	is	attribute	similar	3281-6
<B>	From	constraint	the fact	3281-7
the fact	that	constraint	ρ	3281-7
ρ	is	attribute	an automorphism	3281-7
an automorphism	of	constraint	trace	3281-7
trace		sequential	q	3281-7
q		sequential	I	3281-7
I		sequential	it	3281-7
it	follows	action	that ρ	3281-7
that ρ		sequential	trace	3281-7
trace		sequential	ψ	3281-7
ψ		sequential	3	3281-7
3	=	sequential	trace	3281-7
trace	ψ	sequential	0	3281-7
0		sequential	ρ	3281-7
ρ		sequential	trace	3281-7
trace		sequential	ψ	3281-7
ψ		sequential	2	3281-7
2	=	sequential	trace	3281-7
trace	ψ	sequential	3	3281-7
3	and	conjunctive	ρ	3281-7
ρ		sequential	trace	3281-7
trace		sequential	ψ	3281-7
ψ		sequential	1	3281-7
1	=	sequential	trace	3281-7
trace	ψ	sequential	2	3281-7
<B>	now ρ 2	sequential	<B>	3281-8
<B>	Consider	action	<B>	3281-8
<B>	because	constraint	ρ 2	3282-1
ρ 2	=	sequential	id	3282-1
id		sequential	ρ	3282-1
ρ		sequential	2	3282-1
2		sequential	trace	3282-1
trace		sequential	ψi	3282-1
ψi	=	sequential	trace	3282-1
trace		sequential	ψi	3282-1
ψi		sequential	0 ≤ i ≤ 3	3282-1
<B>	On	constraint	the other hand	3282-2
the other hand		sequential	ρ	3282-2
ρ		sequential	2	3282-2
2		sequential	trace	3282-2
trace	ψ	sequential	0	3282-2
0	=	sequential	ρ	3282-2
ρ		sequential	ρ	3282-2
ρ		sequential	trace	3282-2
trace	ψ	sequential	0	3282-2
0	=	sequential	ρ	3282-2
ρ		sequential	trace	3282-2
trace		sequential	ψ	3282-2
ψ		sequential	1	3282-2
1	=	sequential	trace	3282-2
trace	ψ	sequential	2	3282-2
<B>	is	attribute	a contradiction	3282-3
q	by	constraint	whilenew	3283-1
q	Hence can not be computed	action	whilenew	3283-1
The preceding example	that	constraint	the presence	3284-1
The preceding example	shows	action	the presence	3284-1
the presence	of	constraint	new values	3284-1
new values	in	constraint	the answer	3284-1
the answer	raises	action	interesting questions	3284-1
interesting questions	with	constraint	regard	3284-1
regard	to	constraint	completeness	3284-1
There	exist	action	languages	3284-2
languages		sequential	that	3284-2
that	express	action	all queries	3284-2
all queries	with	constraint	invented values	3284-2
invented values	in	constraint	answers	3284-2
answers	see	action	Exercise 18.14	3284-2
Exercise 18.14	for	constraint	a complex construct	3284-2
a complex construct		sequential	that	3284-2
that	to	constraint	determinate	3284-2
that	leads	action	determinate	3284-2
determinate		sequential	a language	3284-2
Value invention	in	constraint	object	3284-3
Value invention	is	attribute	common	3284-3
object	oriented	action	languages	3284-3
languages	in	constraint	the form	3284-3
the form	of	constraint	object creation constructs	3284-3
object creation constructs	see	action	Chapter 21	3284-3
Whileuty	while	constraint	<B>	3285-1
This relaxation	is done	action	an untyped version	3285-2
This relaxation	using	action	an untyped version	3285-2
an untyped version	of	constraint	relational algebra	3285-2
relational algebra		sequential	the familiar typed version	3285-2
We	will obtain	action	a language	3285-3
a language	allowing	action	us	3285-3
us	to	constraint	relations	3285-3
us	construct	action	relations	3285-3
relations	of	constraint	data	3285-3
data		sequential	variable arity	3285-3
variable arity	in	constraint	the course	3285-3
the course	of	constraint	the computation	3285-3
<B>	Although	constraint	they	3285-4
<B>	strictly speaking	action	they	3285-4
they	are not needed	action	we	3285-4
we	also allow	action	integer variables	3285-4
integer variables	and	conjunctive	integer manipulation	3285-4
integer manipulation	as	constraint	N. Intuitively	3285-4
integer manipulation	in	constraint	N. Intuitively	3285-4
integer manipulation	while	constraint	N. Intuitively	3285-4
N. Intuitively		sequential	it	3285-4
it	to	constraint	a complete language	3285-4
it	is	attribute	easy	3285-4
it	see	attribute	this	3285-4
it	why yields	action	a complete language	3285-4
Variable arities	allow	action	us	3285-5
us	to	constraint	all enumerations	3285-5
us	construct	action	all enumerations	3285-5
all enumerations	of	constraint	constants	3285-5
constants	in	constraint	the input	3285-5
the input	by	constraint	sufficiently long tuples	3285-5
the input	represented	action	sufficiently long tuples	3285-5
sufficiently long tuples	containing	action	all constants	3285-5
The ability	to	constraint	the enumerations	3285-6
The ability	construct	action	the enumerations	3285-6
the enumerations	and	conjunctive	integers	3285-6
the enumerations	manipulate	action	integers	3285-6
integers	yields	action	a complete language	3285-6
The first step	in	constraint	the untyped version	3286-1
The first step	defining	action	the untyped version	3286-1
the untyped version	of	constraint	while	3286-1
while	to	constraint	an untyped version	3286-1
while	is	attribute	an untyped version	3286-1
while	define	action	an untyped version	3286-1
an untyped version	of	constraint	relational algebra	3286-1
<B>	that	constraint	operations	3286-2
<B>	means	action	operations	3286-2
operations	so that	constraint	they	3286-2
operations	must be defined	action	they	3286-2
they	on	constraint	relations	3286-2
they	work	action	relations	3286-2
relations	of	constraint	arbitrary unknown arity	3286-2
Expressions	in	constraint	the untyped algebra	3286-3
the untyped algebra	from	constraint	relation variables	3286-3
the untyped algebra	are built	action	relation variables	3286-3
relation variables	and	conjunctive	constants	3286-3
constants	and	conjunctive	integer variables	3286-3
constants	can also use	action	integer variables	3286-3
integer variables	and	conjunctive	constants	3286-3
<B>	Let	action	i	3286-4
i	be	attribute	integer variables	3286-4
integer variables	for	constraint	each integer k	3286-4
integer variables	and	conjunctive	each integer k	3286-4
each integer k	let	action	∅k	3286-4
∅k	denote	action	the empty relation	3286-4
the empty relation	of	constraint	arity k	3286-4
Untyped algebra expressions	are built up	action	the following operations	3287-1
Untyped algebra expressions	using	action	the following operations	3287-1
Highly Expressive Languages		sequential	Highly Expressive Languages	3288-1
We	may also consider	action	an untyped version	3289-1
an untyped version	of	constraint	tuple relational calculus	3289-1
tuple relational calculus	see	action	Exercise 18.15	3289-1
We	can now define	action	whileuty programs	3290-1
They	are	attribute	concatenations	3290-2
concatenations	of	constraint	statements	3290-2
statements	of	constraint	the form	3290-2
Example		sequential	18.3.1	3291-1
<B>	allows	action	us	3291-2
us	to	constraint	the appropriate arity	3291-2
us	detect	action	the appropriate arity	3291-2
the appropriate arity	when has been found	action	<B>	3291-2
Remark		sequential	18.3.2	3292-1
<B>	In	constraint	programs	3292-2
programs	to	constraint	the resulting language	3292-2
programs	in	constraint	the resulting language	3292-2
programs	are	attribute	much harder	3292-2
programs	write	action	the resulting language	3292-2
the resulting language	called	action	QL	3292-2
QL	than	constraint	whileuty	3292-2
QL	in	constraint	whileuty	3292-2
One	that	constraint	the set	3292-3
One	can show	action	the set	3292-3
the set	of	constraint	constructs	3292-3
constructs	of	constraint	QL	3292-3
QL	is	attribute	minimal	3292-3
The language		sequential	QL	3292-4
QL	is described next	action	it	3292-4
it	does not use	action	integer variables	3292-4
QL expressions	from	constraint	relational variables	3292-5
QL expressions	are built	action	relational variables	3292-5
relational variables	and	conjunctive	constant relations	3292-5
constant relations	as	constraint	D	3292-5
constant relations	follows	action	D	3292-5
D	denotes	action	the active domain	3292-5
Programs	by	constraint	concatenations	3293-1
Programs	are built	action	concatenations	3293-1
concatenations	of	constraint	assignment statements	3293-1
assignment statements		sequential	R	3293-1
R	=	sequential	e	3293-1
e	while	constraint	statements	3293-1
e	and	conjunctive	statements	3293-1
statements	while	constraint	R	3293-1
R	do	attribute	s	3293-1
The semantics	of	constraint	the while	3293-2
the while	that	constraint	the loop	3293-2
the while	is	attribute	the loop	3293-2
the loop	as	constraint	R	3293-2
the loop	is iterated	action	R	3293-2
R	is	attribute	nonempty	3293-2
We	leave	action	it	3294-1
it	to	constraint	the reader	3294-1
the reader	to	constraint	QL	3294-1
the reader	that	constraint	QL	3294-1
the reader	check	action	QL	3294-1
QL	to	constraint	whileuty	3294-1
QL	is	attribute	equivalent	3294-1
whileuty		sequential	Exercise	3294-1
Exercise		sequential	18.17	3294-1
We	briefly describe	action	the simulation	3295-1
the simulation	of	constraint	integers	3295-1
integers	by	constraint	QL	3295-1
<B>	Let	action	Z	3295-2
Z	denote	action	0 ary	3295-2
0 ary		sequential	the constant relation	3295-2
the constant relation		sequential	}	3295-2
We	can have	action	Z	3295-3
Z	represent	action	the integer 0	3295-3
the integer 0	and	conjunctive	Z	3295-3
Z		sequential	↑n	3295-3
↑n	represent	action	the integer n	3295-3
A test	of	constraint	the form	3295-4
the form		sequential	x	3295-4
x	=	sequential	0	3295-4
0	becomes	action	e	3295-4
e	↓=	sequential	e	3295-4
e	∅	sequential	e	3295-4
e	is	attribute	where the untyped algebra expression	3295-4
where the untyped algebra expression	representing	action	the value	3295-4
the value	of	constraint	x	3295-4
we	Thus can simulate	action	arbitrary computations	3295-5
arbitrary computations	on	constraint	the integers	3295-5
<B>	that	constraint	our definition	3296-1
<B>	Recall	action	our definition	3296-1
our definition	of	constraint	query	3296-1
query	that	constraint	the input	3296-1
query	both	conjunctive	the input	3296-1
query	requires	action	the input	3296-1
the input	and	conjunctive	output	3296-1
output	be	attribute	instances	3296-1
instances	over	constraint	fixed schemas	3296-1
<B>	On	constraint	the other hand	3296-2
the other hand	in	constraint	whileuty relation	3296-2
whileuty relation		sequential	arities	3296-2
arities	in	constraint	the arity	3296-2
arities	are	attribute	variable	3296-2
the arity	of	constraint	the answer	3296-2
the answer	is	attribute	data	3296-2
data		sequential	<B>	3296-2
<B>	is	attribute	a problem	3296-3
a problem	to	constraint	the one	3296-3
the one		sequential	we	3296-3
we	with	constraint	whilenew	3296-3
we	encountered	action	whilenew	3296-3
whilenew		sequential	which	3296-3
which	generally produces	action	new values	3296-3
new values	in	constraint	the result	3296-3
<B>	As	constraint	the case	3296-4
<B>	in	constraint	the case	3296-4
the case	of	constraint	whilenew	3296-4
whilenew		sequential	we	3296-4
we	and	conjunctive	restrictions	3296-4
we	can define	attribute	semantic	3296-4
restrictions	on	constraint	whileuty programs	3296-4
whileuty programs		sequential	that	3296-4
that	that	constraint	the programs	3296-4
that	guarantee	action	the programs	3296-4
the programs	compute	action	queries	3296-4
<B>	Call	action	a whileuty program	3296-5
a whileuty program	if	constraint	its answer	3296-5
a whileuty program	well behaved	action	its answer	3296-5
its answer	of	constraint	always the same arity	3296-5
its answer	is	attribute	always the same arity	3296-5
always the same arity	of	constraint	the input	3296-5
it	that	constraint	it	3296-6
it	Unfortunately can be shown	action	it	3296-6
it	if	constraint	a whileuty program	3296-6
it	is	attribute	undecidable	3296-6
a whileuty program	is well behaved	action	Exercise	3296-6
Exercise		sequential	18.19	3296-6
there	However is	action	a simple syntactic condition	3296-7
a simple syntactic condition		sequential	that	3296-7
that	guarantees	action	good behavior	3296-7
good behavior	and	conjunctive	all programs	3296-7
good behavior	covers	action	all programs	3296-7
good behavior	well behaved	action	all programs	3296-7
A whileuty program	with	constraint	answer relation answer	3296-8
answer relation answer	if	constraint	the last instruction	3296-8
answer relation answer	is syntactically well behaved	action	the last instruction	3296-8
the last instruction	of	constraint	the program	3296-8
the program	of	constraint	the form answer	3296-8
the program	is	attribute	the form answer	3296-8
the form answer	=	sequential	πmn	3296-8
πmn		sequential	R	3296-8
R		sequential	m	3296-8
m	n	conjunctive	where integer constants	3296-8
m	are	attribute	where integer constants	3296-8
syntactic good behavior	Clearly guarantees	action	good behavior	3296-9
good behavior	and	conjunctive	<B>	3296-9
good behavior	can be checked	action	<B>	3296-9
it	that	constraint	each whileuty program	3297-1
it	is	attribute	Furthermore obvious	3297-1
it	well behaved	action	each whileuty program	3297-1
each whileuty program	to	constraint	some program	3297-1
each whileuty program	is	attribute	equivalent	3297-1
each whileuty program	syntactically well behaved	action	some program	3297-1
some program		sequential	Exercise	3297-1
Exercise		sequential	18.19	3297-1
Highly Expressive Languages		sequential	Highly Expressive Languages	3298-1
Theorem		sequential	18.3.3	3299-1
Crux		sequential	Crux	3300-1
The proof	that	constraint	every query	3300-2
every query	by	constraint	a whileuty program	3300-2
every query	can be expressed	action	a whileuty program	3300-2
every query	well behaved	action	a whileuty program	3300-2
a whileuty program	to	constraint	the proof	3300-2
a whileuty program	is	attribute	similar	3300-2
the proof	of	constraint	Theorem 18.2.3	3300-2
<B>	Let	action	q	3300-3
q	be	attribute	a query	3300-3
a query	with	constraint	input schema R	3300-3
<B>	Next simulate	action	while N program	3300-4
while N program		sequential	the computing q	3300-4
the computing q	on	constraint	the ordered database	3300-4
the ordered database	to	constraint	each ordering	3300-4
the ordered database	corresponding	action	each ordering	3300-4
The main difference	with	constraint	whilenew	3300-5
whilenew	in	constraint	the orderings	3300-5
whilenew	lies	action	the orderings	3300-5
the orderings	are computed	action	<B>	3300-5
<B>	In	constraint	whileuty	3300-6
whileuty		sequential	we	3300-6
we	use	action	the arbitrary arity	3300-6
the arbitrary arity	to	constraint	a relation R	3300-6
the arbitrary arity	construct	action	a relation R	3300-6
a relation R	containing	action	sufficiently long tuples	3300-6
sufficiently long tuples	of	constraint	which	3300-6
which	provides	action	an enumeration	3300-6
an enumeration	of	constraint	all constants	3300-6
<B>	by	constraint	the following whileuty program	3300-7
<B>	is done	action	the following whileuty program	3300-7
the following whileuty program		sequential	D	3300-7
D	for	constraint	an algebra expression	3300-7
D	where stands	action	an algebra expression	3300-7
an algebra expression	computing	action	the active domain	3300-7
the active domain		sequential	R	3300-7
R	=	sequential	∅0	3300-7
∅0		sequential	C	3300-7
C	=	sequential	D	3300-7
D		sequential	arity	3300-7
arity		sequential	C	3300-7
C	=	sequential	1	3300-7
1	while	constraint	C	3300-7
C	do begin	action	R	3300-7
R	=	sequential	C	3300-7
C		sequential	C	3300-7
C	=	sequential	C	3300-7
C	×	constraint	D	3300-7
D		sequential	increment	3300-7
increment		sequential	arity	3300-7
arity		sequential	C	3300-7
C	for	constraint	i	3300-7
i	=	sequential	1	3300-7
1	to	constraint	arity C 1	3300-7
arity C 1		sequential	do	3300-7
do		sequential	C	3300-7
C	=	sequential	C	3300-7
C		sequential	∩ ¬σi= arity	3300-7
∩ ¬σi= arity		sequential	C	3300-7
C		sequential	C	3300-7
C		sequential	end	3300-7
end		sequential	Clearly the looping construct f	3300-7
Clearly the looping construct f	or	conjunctive	i	3300-7
i	=	sequential	1	3300-7
1	to	constraint	<B>	3300-7
<B>	.	sequential	<B>	3300-8
<B>	.	sequential	<B>	3300-9
<B>	can be easily simulated	action	<B>	3300-10
<B>	If	constraint	the size	3300-11
the size	of	constraint	D	3300-11
D	is	attribute	n	3300-11
n		sequential	the result	3300-11
the result	of	constraint	the program	3300-11
the program	is	attribute	the set	3300-11
the set	of	constraint	n-tuples	3300-11
n-tuples	with	constraint	distinct entries	3300-11
distinct entries	in	constraint	adom	3300-11
adom		sequential	D	3300-11
<B>	that	constraint	each such tuple t	3300-12
<B>	Note	action	each such tuple t	3300-12
each such tuple t	in	constraint	R	3300-12
R	provides	action	a complete enumeration	3300-12
a complete enumeration	of	constraint	the constants	3300-12
the constants	in	constraint	D	3300-12
<B>		sequential	one	3300-13
one	can construct	action	succ	3300-13
succ	=	sequential	succ t × t }	3300-13
succ t × t }		sequential	t ∈R	3300-13
t ∈R		sequential	succ	3300-13
succ		sequential	t	3300-13
t	where =	sequential	t	3300-13
t		sequential	t	3300-13
t		sequential	i	3300-13
i	+	sequential	1	3300-13
1		sequential	1	3300-13
1		sequential	i	3300-13
i		sequential	n	3300-13
n	see	action	Fig	3300-13
18.2	and	conjunctive	Exercise 18.20	3300-14
Untyped languages	allow	action	us	3301-1
us	to	constraint	the restriction	3301-1
us	relax	action	the restriction	3301-1
the restriction		sequential	that	3301-1
that		sequential	the output schema	3301-1
the output schema	is fixed	action	<B>	3301-1
<B>	may have	action	a practical advantage	3302-1
a practical advantage	because	constraint	some applications	3302-1
a practical advantage	in	constraint	some applications	3302-1
some applications		sequential	it	3302-1
it	to	constraint	the output schema	3302-1
it	be	attribute	may necessary	3302-1
it	have	action	the output schema	3302-1
the output schema	on	constraint	the input data	3302-1
the output schema	depend	action	the input data	3302-1
<B>	in	constraint	such cases	3302-2
such cases		sequential	one	3302-2
one	However would likely prefer	action	a richer type system	3302-2
a richer type system		sequential	no typing	3302-2
no typing	at	constraint	<B>	3302-2
The overall results	on	constraint	the expressiveness	3303-1
the expressiveness	and	conjunctive	complexity	3303-1
complexity	of	constraint	relational query languages	3303-1
relational query languages	in	constraint	Figs	3303-1
relational query languages	are summarized	action	Figs	3303-1
18.4	and	conjunctive	18.5	3303-2
The main classes	of	constraint	queries	3303-3
queries	and	conjunctive	their inclusion structure	3303-3
their inclusion structure	in	constraint	Fig	3303-3
their inclusion structure	are represented	action	Fig	3303-3
solid arrows	18.4 indicate	action	strict inclusion	3303-4
strict inclusion		sequential	the dotted arrow	3303-4
the dotted arrow	indicates	action	strict inclusion	3303-4
strict inclusion	if	constraint	ptime	3303-4
ptime	=	sequential	pspace	3303-4
Languages	expressing	action	each class	3303-5
each class	of	constraint	queries	3303-5
queries	in	constraint	Fig	3303-5
queries	are listed	action	Fig	3303-5
18.5		sequential	which	3303-6
which	also contains	action	information	3303-6
information	on	constraint	complexity	3303-6
complexity	without	constraint	first assumptions	3303-6
first assumptions	with	constraint	the assumption	3303-6
the assumption	of	constraint	an order	3303-6
an order	on	constraint	the database	3303-6
<B>	In	constraint	Fig	3303-7
18.5 Bibliographic Notes Figure 18.4	While	constraint	Fixpoint Stratified datalog¬ Semipositive datalog¬ First order	3303-8
Fixpoint Stratified datalog¬ Semipositive datalog¬ First order		sequential	Datalog	3303-8
Datalog		sequential	existential Conjunctive queries	3303-8
existential Conjunctive queries		sequential	Main classes	3303-8
Main classes	of	constraint	queries	3303-8
queries		sequential	CALC	3303-8
CALC		sequential	∃	3303-8
∃	denotes	action	the conjunctive calculus	3303-8
the conjunctive calculus	and	conjunctive	CALC	3303-8
CALC		sequential	∃	3303-8
∃		sequential	∨	3303-8
∨	denotes	attribute	positive	3303-8
Bibliographic Notes		sequential	Bibliographic Notes	3304-1
Chandra	also considered	action	a language	3305-1
a language	to	constraint	N	3305-1
a language	while	constraint	N	3305-1
N		sequential	which	3305-1
which		sequential	he	3305-1
he	called	action	LC	3305-1
LC		sequential	Cha81a	3305-1
It	that	constraint	LC	3306-1
It	was shown	action	LC	3306-1
LC	can not compute even	action	<B>	3306-1
Several other primitives	in	constraint	<B>	3306-2
Several other primitives	are considered	action	<B>	3306-2
The languages	in	constraint	this chapter	3307-1
The languages	considered	action	this chapter	3307-1
this chapter	as	constraint	practical languages	3307-1
this chapter	can be viewed	action	practical languages	3307-1
this chapter	formalizing	action	practical languages	3307-1
practical languages		sequential	C+SQL	3307-1
C+SQL	or	conjunctive	O2C	3307-1
O2C	to	constraint	database applications	3307-1
O2C	used	action	database applications	3307-1
O2C	develop	action	database applications	3307-1
These languages	combine	action	standard computation	3307-2
standard computation		sequential	C	3307-2
C	with	constraint	database computation	3307-2
database computation		sequential	SQL	3307-2
SQL	in	constraint	the relational world	3307-2
the relational world	or	conjunctive	O2	3307-2
O2	in	constraint	object	3307-2
object	oriented	action	the world	3307-2
<B>	In	constraint	this direction	3307-3
this direction		sequential	several computing devices	3307-3
several computing devices	in	constraint	AV91 b	3307-3
several computing devices	were defined	action	AV91 b	3307-3
AV91 b	and	conjunctive	complexity	3307-3
complexity		sequential	results	3307-3
results	are obtained	action	the devices	3307-3
results	using	action	the devices	3307-3
an extension	of	constraint	Turing machines	3307-4
Turing machines	with	constraint	a relational store	3307-4
a relational store	called	action	relational machine	3307-4
relational machine	to	constraint	N.	3307-4
relational machine	to	constraint	N.	3307-4
relational machine	while	constraint	N.	3307-4
relational machine	First was shown	attribute	equivalent	3307-4
relational machine	be	attribute	equivalent	3307-4
N.		sequential	A further extension	3307-4
A further extension	of	constraint	relational machines	3307-4
relational machines	to	constraint	whilenew	3307-4
whilenew	and	conjunctive	whileuty	3307-4
whileuty	called	action	generic machine	3307-4
generic machine	was also defined	action	<B>	3307-4
<B>	In	constraint	the generic machine	3307-5
the generic machine		sequential	Highly Expressive Languages	3307-5
Highly Expressive Languages		sequential	Class	3307-5
Class	of	constraint	Complexity	3307-5
Complexity	queries	action	Languages Complexity	3307-5
Languages Complexity	with	constraint	order conjunctive CALC	3307-5
order conjunctive CALC		sequential	∃	3307-5
∃		sequential	∧	3307-5
∧		sequential	SPJR algebra	3307-5
SPJR algebra		sequential	positive CALC	3307-5
positive CALC		sequential	∃	3307-5
∃		sequential	∧	3307-5
∧		sequential	∨	3307-5
∨		sequential	datalog¬ datalog¬ fixpoint CALC	3307-5
datalog¬ datalog¬ fixpoint CALC		sequential	existential SPJUR algebra nr-datalog datalog datalog ptime ptime semipositive semipositive datalog¬ datalog¬ first order CALC nr-stratified datalog¬ stratified stratified +µ+	3307-5
existential SPJUR algebra nr-datalog datalog datalog ptime ptime semipositive semipositive datalog¬ datalog¬ first order CALC nr-stratified datalog¬ stratified stratified +µ+	while	constraint	datalog¬	3307-5
existential SPJUR algebra nr-datalog datalog datalog ptime ptime semipositive semipositive datalog¬ datalog¬ first order CALC nr-stratified datalog¬ stratified stratified +µ+	+	sequential	datalog¬	3307-5
datalog¬		sequential	fixpoint	3307-5
fixpoint	and	conjunctive	semantics	3307-5
fixpoint	well founded	action	semantics	3307-5
semantics	while	constraint	CALC +µ	3307-5
CALC +µ	while	constraint	datalog¬¬	3307-5
datalog¬¬		sequential	fixpoint semantics	3307-5
fixpoint semantics		sequential	whileuty	3307-5
whileuty	bound	action	no bound whilenew Figure 18.5	3307-5
no bound whilenew Figure 18.5		sequential	Languages	3307-5
Languages	and	conjunctive	complexity parallelism	3307-5
complexity parallelism	to	constraint	simultaneous computations	3307-5
complexity parallelism	is used	action	simultaneous computations	3307-5
complexity parallelism	allow	action	simultaneous computations	3307-5
simultaneous computations	with	constraint	all possible successor relations	3307-5
Queries	with	constraint	new values	3308-1
new values	in	constraint	their answers	3308-1
their answers	in	constraint	AK89	3308-1
their answers	were first considered	action	AK89	3308-1
AK89	in	constraint	the context	3308-1
the context	of	constraint	an deductive language	3308-1
the context	object oriented	action	an deductive language	3308-1
an deductive language	with	constraint	object creation	3308-1
object creation	called	action	IQL	3308-1
The notion	of	constraint	determinate query	3308-2
determinate query		sequential	VandBGAG92	3308-2
VandBGAG92	is	attribute	a recasting	3308-2
a recasting	of	constraint	the essentially equivalent notion	3308-2
the essentially equivalent notion	of	constraint	db transformation	3308-2
db transformation	in	constraint	AK89	3308-2
db transformation	formulated	action	AK89	3308-2
<B>	In	constraint	AK89	3308-3
AK89		sequential	the query	3308-3
the query	in	constraint	Theorem 18.2.5	3308-3
Theorem 18.2.5	and	conjunctive	it	3308-3
Theorem 18.2.5	is also exhibited	action	it	3308-3
it	that	constraint	IQL	3308-3
it	is shown	action	IQL	3308-3
IQL	without	constraint	duplicate elimination	3308-3
duplicate elimination	can not express	action	it	3308-3
<B>	Because	constraint	IQL	3308-4
IQL	than	constraint	their result	3308-4
IQL	is	attribute	more powerful	3308-4
their result	implies	action	the result	3308-4
the result	of	constraint	Theorem 18.2.5	3308-4
The issue	of	constraint	completeness	3308-5
completeness	of	constraint	languages	3308-5
languages	with	constraint	object creation	3308-5
object creation	in	constraint	AP92	3308-5
object creation	was further investigated	action	AP92	3308-5
AP92		sequential	VandBG92	3308-5
VandBG92		sequential	VandBGAG92	3308-5
VandBGAG92		sequential	VandBP95	3308-5
VandBP95		sequential	DV91	3308-5
DV91		sequential	DV93	3308-5
Exercises		sequential	Exercises	3309-1
Exercises Exercise		sequential	18.1	3310-1
<B>	Consider	action	a query	3310-2
a query		sequential	the shortest path	3310-2
the shortest path	from	constraint	a b	3310-2
the shortest path	to	constraint	a b	3310-2
a b	in	constraint	G	3310-2
G	Does have	action	property P	3310-2
G	is	attribute	where a graph	3310-3
where a graph		sequential	P	3310-3
P	is	attribute	a recursive property	3310-3
a recursive property	of	constraint	the integers	3310-3
the integers	and	conjunctive	b	3310-3
b	are	attribute	two particular vertexes	3310-3
two particular vertexes	of	constraint	the graph	3310-3
<B>	that	constraint	such a query	3310-4
<B>	Show	action	such a query	3310-4
such a query	in	constraint	N	3310-4
such a query	while	constraint	N	3310-4
such a query	can be expressed	action	N	3310-4
Exercise		sequential	18.2	3311-1
Exercise		sequential	18.3	3312-1
<B>	Exercise	attribute	18.5 Complete	3313-1
the proof	of	constraint	Theorem 18.1.2	3313-1
Hint		sequential	Hint	3314-1
<B>	to	constraint	the integers	3314-2
<B>	represent	action	the integers	3314-2
the integers	to	constraint	a successor relation	3314-2
the integers	a relation succ int	constraint	a successor relation	3314-2
the integers	n	conjunctive	a successor relation	3314-2
the integers	construct	action	a successor relation	3314-2
the integers	containing	action	a successor relation	3314-2
a successor relation	on	constraint	values	3314-2
a successor relation	n	conjunctive	values	3314-2
The value	of	constraint	rank	3314-3
rank		sequential	i	3314-3
i	with	constraint	respect	3314-3
respect	to	constraint	succ	3314-3
succ	represents	action	integer	3314-3
integer		sequential	i	3314-3
Hint		sequential	Hint	3315-1
<B>	Then use	action	Exercise 18.4	3315-2
Exercise 18.7 Prove Lemma 18.2.1		sequential	Exercise 18.7 Prove Lemma 18.2.1	3316-1
Exercise		sequential	18.8	3317-1
Highly Expressive Languages		sequential	S	3318-1
S		sequential	arity	3318-1
arity		sequential	T	3318-1
T	+	sequential	j ∈	3318-1
j ∈		sequential	j ∈ Bad	3318-1
j ∈ Bad		sequential	w	3318-1
w		sequential	S	3318-1
S		sequential	j	3318-1
j		sequential	∈	3318-1
∈		sequential	<B>	3318-1
Exercise		sequential	18.10 Prove	3319-1
18.10 Prove	in	constraint	the proof	3319-1
the proof	of	constraint	Theorem 18.2.3	3319-1
Exercise		sequential	18.11 Prove	3320-1
18.11 Prove		sequential	†	3320-1
†	in	constraint	‡ the proof	3320-1
†	and	conjunctive	‡ the proof	3320-1
‡ the proof	of	constraint	Theorem 18.2.5	3320-1
Exercise		sequential	18.12	3321-1
<B>	Let	action	q2	3321-2
q2	be	attribute	the query	3321-2
the query		sequential	that	3321-2
that	on	constraint	input	3321-2
input		sequential	I	3321-2
I	=	sequential	a b }	3321-2
I	{	sequential	a b }	3321-2
a b }	as	constraint	answer	3321-2
a b }	produces	action	answer	3321-2
answer		sequential	two copies	3321-2
two copies	of	constraint	q I	3321-2
<B>	for	constraint	each ψi	3321-3
each ψi	in	constraint	q	3321-3
q	More precisely I let	action	ψ′	3321-3
ψ′	be	attribute	a distinct new value	3321-3
<B>	Let	action	q′	3321-4
q′		sequential	I	3321-4
I	from	constraint	q	3321-4
I	be obtained	action	q	3321-4
q		sequential	I	3321-4
I	by	constraint	ψ	3321-4
I	replacing	action	ψ	3321-4
ψ		sequential	i	3321-4
i		sequential	i	3321-4
i	by	constraint	i	3321-4
<B>	with	constraint	<B>	3322-1
<B>	whilenew	attribute	the	3322-1
<B>	choose	action	<B>	3322-1
<B>	construct	action	<B>	3322-1
A program	w	constraint	the instruction	3322-2
A program	may contain	action	the instruction	3322-2
the instruction	choose	action	R	3322-2
R	for	constraint	some unary relation R	3322-2
some unary relation R	On	constraint	input	3322-2
input		sequential	I	3322-2
I	when choose	action	R	3322-2
R	in	constraint	a state J	3322-2
R	is applied	action	a state J	3322-2
a state J		sequential	the next state	3322-2
the next state		sequential	J′	3322-2
J′	as	constraint	<B>	3322-2
J′	is defined	action	<B>	3322-2
J′	follows	action	<B>	3322-2
<B>	that	constraint	whilechoose	3323-1
<B>	Show	action	whilechoose	3323-1
whilechoose	is	attribute	determinate complete	3323-1
new Exercise 18.15		sequential	new Exercise 18.15	3324-1
Untyped relations	like	constraint	just typed relations	3324-2
Untyped relations	are used	action	just typed relations	3324-2
just typed relations	except	constraint	terms	3324-2
just typed relations	that	constraint	terms	3324-2
terms	of	constraint	the form t i	3324-2
the form t i	are allowed	action	t	3324-2
t	is	attribute	where a tuple variable	3324-2
where a tuple variable	and	conjunctive	i	3324-2
i		sequential	an integer variable	3324-2
Equivalence	of	constraint	queries	3324-3
queries	that	constraint	the queries	3324-3
queries	now means	action	the queries	3324-3
the queries	yield	action	the same answers	3324-3
the same answers	given	action	the same relations	3324-3
the same relations	and	conjunctive	values	3324-3
values	for	constraint	the integer variables	3324-3
<B>	that	constraint	untyped relational calculus	3324-4
<B>	Show	action	untyped relational calculus	3324-4
untyped relational calculus	and	conjunctive	untyped relational algebra	3324-4
untyped relational algebra	are	attribute	equivalent	3324-4
Exercise		sequential	18.16	3325-1
Exercises b b		sequential	b c c d	3326-1
b c c d		sequential	d b c c	3326-1
d b c c		sequential	b	3326-1
b		sequential	d b d c	3326-1
d b d c		sequential	c	3326-1
c		sequential	d d I	3326-1
d d I		sequential	J Figure 18.6	3326-1
Exercise		sequential	18.18	3327-1
Exercise		sequential	18.20	3328-1
Highly Expressive Languages	has	action	the same effect	3329-1
the same effect	as	constraint	the R	3329-1
the R	=	sequential	P	3329-1
P		sequential	new instruction	3329-1
new instruction	in	constraint	whilenew	3329-1
The resulting extension	of	constraint	datalog¬¬	3329-2
datalog¬¬	is	attribute	denoted datalog¬¬	3329-2
The programs	are	attribute	those	3329-3
that	never new	action	datalog¬¬ new	3329-3
that	well behaved	action	datalog¬¬ new	3329-3
datalog¬¬ new	produce	action	new values	3329-3
new values	in	constraint	the answer	3329-3
<B>	Sketch	action	a proof	3329-4
a proof	that	constraint	datalog¬¬ programs	3329-4
a proof	well behaved	action	datalog¬¬ programs	3329-4
datalog¬¬ programs		sequential	ex-new press all queries	3329-4
P A R T F		sequential	Finale Inthispart weconsiderfouradvancedtopics	3330-1
Interest	in	constraint	the other two topics	3330-2
the other two topics		sequential	complex values	3330-2
complex values	and	conjunctive	object databases	3330-2
object databases	and	conjunctive	our understanding	3330-2
object databases	is	attribute	more recent	3330-2
our understanding	of	constraint	them	3330-2
them	is	attribute	rudimentary	3330-2
<B>	In	constraint	all cases	3330-3
all cases		sequential	no clear consensus	3330-3
no clear consensus	has yet emerged	action	<B>	3330-3
Our choice	of	constraint	material	3330-4
material		sequential	our presentation	3330-4
our presentation	than	constraint	other parts	3330-4
our presentation	in	constraint	other parts	3330-4
our presentation	are	attribute	therefore unavoidably more subjective	3330-4
other parts	of	constraint	this book	3330-4
the importance	of	constraint	these issues	3330-5
these issues	for	constraint	practical systems	3330-5
practical systems		sequential	the interesting theoretical issues	3330-5
the interesting theoretical issues		sequential	they	3330-5
they	raise	action	us	3330-5
they	However led	action	us	3330-5
us	to	constraint	a discussion	3330-5
us	incorporate	action	a discussion	3330-5
a discussion	of	constraint	them	3330-5
them	in	constraint	this book	3330-5
<B>	In	constraint	Chapter 19	3331-1
Chapter 19		sequential	we	3331-1
we	address	action	the issue	3331-1
the issue	of	constraint	incomplete information	3331-1
<B>	In	constraint	many database applications	3331-2
many database applications		sequential	the knowledge	3331-2
the knowledge	of	constraint	the real world	3331-2
the real world	is	attribute	incomplete	3331-2
It	to	constraint	such incompleteness	3331-3
It	to	constraint	such incompleteness	3331-3
It	is	attribute	crucial	3331-3
It	be	attribute	able	3331-3
It	handle	action	such incompleteness	3331-3
such incompleteness	in	constraint	queries	3331-3
such incompleteness	to	constraint	queries	3331-3
such incompleteness	to	constraint	queries	3331-3
such incompleteness	and	conjunctive	queries	3331-3
such incompleteness	be	attribute	able	3331-3
such incompleteness	ask	action	queries	3331-3
queries	and	conjunctive	updates	3331-3
queries	perform	action	updates	3331-3
Chapter 19	surveys	action	various models	3332-1
various models	of	constraint	incomplete databases	3332-1
incomplete databases		sequential	research directions	3332-1
research directions	and	conjunctive	some results	3332-1
<B>	In	constraint	Chapter 20	3333-1
Chapter 20		sequential	we	3333-1
we	present	action	an extension	3333-1
an extension	of	constraint	relations	3333-1
relations	called	action	complex values	3333-1
<B>	from	constraint	atomic elements	3333-2
<B>	are obtained	action	atomic elements	3333-2
atomic elements	using	action	tuple	3333-2
tuple	and	conjunctive	constructors	3333-2
tuple	set	action	constructors	3333-2
The richer structure	allows	action	us	3333-3
us	to	constraint	some limitations	3333-3
us	overcome	action	some limitations	3333-3
some limitations	of	constraint	the relational model	3333-3
the relational model	in	constraint	complex data	3333-3
the relational model	describing	action	complex data	3333-3
We	generalize	action	results	3333-4
results	for	constraint	the relational model	3333-4
results	obtained	action	the relational model	3333-4
the relational model	in	constraint	we	3333-4
we	present	action	a calculus	3333-4
a calculus	and	conjunctive	an equivalent algebra	3333-4
Chapter 21	at	constraint	another way	3334-1
Chapter 21	looks	action	another way	3334-1
another way	to	constraint	the relational model	3334-1
another way	enrich	action	the relational model	3334-1
the relational model	by	constraint	a number	3334-1
the relational model	introducing	action	a number	3334-1
a number	of	constraint	features	3334-1
features	from	constraint	object	3334-1
features	and	conjunctive	object	3334-1
features	borrowed	action	object	3334-1
features	adapted	action	object	3334-1
object	oriented	action	programming	3334-1
programming		sequential	objects	3334-1
objects		sequential	classes	3334-1
classes	and	conjunctive	inheritance	3334-1
<B>	In	constraint	objects	3334-2
objects	of	constraint	a structural part	3334-2
objects	consist	action	a structural part	3334-2
a structural part		sequential	a data reposi-tory	3334-2
a data reposi-tory	and	conjunctive	a behavioral part	3334-2
a behavioral part		sequential	pieces	3334-2
pieces	of	constraint	code	3334-2
the extended framework	Thus encompasses	action	behavior	3334-3
behavior		sequential	a notion	3334-3
a notion	from	constraint	relational databases	3334-3
Chapter 22	with	constraint	dynamic aspects	3335-1
Chapter 22	deals	action	dynamic aspects	3335-1
<B>	is	attribute	one	3335-2
one	of	constraint	the less settled areas	3335-2
the less settled areas	in	constraint	databases	3335-2
databases	and	conjunctive	it	3335-2
it	and	conjunctive	questions	3335-2
it	raises	attribute	interesting	3335-2
We	through	constraint	a variety	3335-3
We	skim	action	a variety	3335-3
a variety	of	constraint	issues	3335-3
issues		sequential	languages	3335-3
languages	and	conjunctive	semantics	3335-3
semantics	for	constraint	updates	3335-3
updates	updating	action	views	3335-3
views	updating	action	incomplete information	3335-3
incomplete information	and	conjunctive	databases	3335-3
incomplete information	and	conjunctive	databases	3335-3
Somebody		sequential	Somebody	3336-1
Who	are	attribute	we	3337-1
Who	are	attribute	you	3337-2
Somebody		sequential	Somebody	3338-1
<B>	is	attribute	an instance	3338-2
an instance	of	constraint	incomplete information	3338-2
Somebody		sequential	Somebody	3339-1
<B>	In	constraint	the previous parts	3340-1
the previous parts		sequential	we	3340-1
we	that	constraint	a database	3340-1
we	have assumed	action	a database	3340-1
a database	always records	action	information	3340-1
information		sequential	that	3340-1
that	is completely known	action	<B>	3340-1
a database	of	constraint	a completely determined finite instance	3340-2
a database	Thus has consisted	action	a completely determined finite instance	3340-2
<B>	In	constraint	reality	3340-3
reality		sequential	we	3340-3
we	with	constraint	incomplete information	3340-3
we	often must deal	action	incomplete information	3340-3
<B>	of	constraint	can many kinds	3340-4
<B>	be	attribute	can many kinds	3340-4
There	can be	action	missing information	3340-5
missing information	as	constraint	John	3340-5
missing information	in	constraint	John	3340-5
John	bought	action	a car	3340-5
a car	but	conjunctive	I	3340-5
I	don ’ t know	action	which one	3340-5
<B>	In	constraint	other cases	3340-6
other cases		sequential	some attributes	3340-6
some attributes	to	constraint	some tuples	3340-6
some attributes	be	attribute	may relevant	3340-6
some tuples	to	constraint	others	3340-6
some tuples	and	conjunctive	others	3340-6
Alice	is	attribute	single	3340-7
the spouse field	in	constraint	her case	3340-7
the spouse field	is	attribute	so irrelevant	3340-7
some information	be	attribute	Furthermore may imprecise	3340-8
Heather	in	constraint	a apartment	3340-8
Heather	and	conjunctive	a apartment	3340-8
Heather	lives	attribute	large	3340-8
a apartment		sequential	the values	3340-8
the values	of	constraint	<B>	3340-8
the values	and	conjunctive	<B>	3340-8
the values	are	attribute	where fuzzy	3340-8
Partial information	may also arise	action	we	3340-9
we	on	constraint	the data	3340-9
we	when can not completely rely	action	the data	3340-9
the data	because of	constraint	possible inconsistencies	3340-9
possible inconsistencies	from	constraint	data	3340-9
possible inconsistencies	e.g. resulting	action	data	3340-9
possible inconsistencies	merging	action	data	3340-9
data	from	constraint	different sources	3340-9
The study	of	constraint	knowledge	3341-1
knowledge	is	attribute	a fascinating topic	3341-1
a fascinating topic		sequential	that	3341-1
that	outside	constraint	the scope	3341-1
that	is	attribute	the scope	3341-1
the scope	of	constraint	this book	3341-1
there	Clearly is	action	a trade off	3342-1
a trade off	between	constraint	the expressivity	3342-1
the expressivity	of	constraint	the model	3342-1
the model	for	constraint	incomplete information	3342-1
incomplete information	and	conjunctive	the difficulty	3342-1
incomplete information	used	action	the difficulty	3342-1
the difficulty	of	constraint	queries	3342-1
the difficulty	answering	action	queries	3342-1
<B>	From	constraint	the database perspective	3342-2
the database perspective		sequential	we	3342-2
we	with	constraint	the limits	3342-2
we	this trade off	constraint	the limits	3342-2
we	and	conjunctive	the limits	3342-2
we	are	attribute	primarily concerned	3342-2
we	identifying	action	the limits	3342-2
we	understanding	action	the limits	3342-2
the limits	of	constraint	what	3342-2
what	in	constraint	this context	3342-2
what	is	attribute	feasible	3342-2
The purpose	of	constraint	this chapter	3342-3
this chapter	to	constraint	a brief foray	3342-3
this chapter	is	attribute	a brief foray	3342-3
this chapter	make	action	a brief foray	3342-3
a brief foray	into	constraint	this topic	3342-3
We	limit	action	ourselves	3343-1
ourselves	to	constraint	mostly models	3343-1
mostly models	and	conjunctive	results	3343-1
results	of	constraint	a clear database nature	3343-1
We	consider	action	simple forms	3343-2
simple forms	of	constraint	incompleteness	3343-2
incompleteness	by	constraint	null values	3343-2
incompleteness	represented	action	null values	3343-2
The main problem		sequential	we	3343-3
we	to	constraint	queries	3343-3
we	is	attribute	queries	3343-3
we	examine	action	queries	3343-3
we	how answer	action	queries	3343-3
queries	on	constraint	such databases	3343-3
<B>	In	constraint	relation	3343-4
relation	to	constraint	we	3343-4
we	that	constraint	a representation system	3343-4
we	for	constraint	a representation system	3343-4
we	argue	action	a representation system	3343-4
a representation system	of	constraint	incomplete information	3343-4
incomplete information	to	constraint	the context	3343-4
incomplete information	in	constraint	the context	3343-4
incomplete information	be	attribute	adequate	3343-4
the context	of	constraint	a query language	3343-4
a query language		sequential	it	3343-4
it	of	constraint	answers	3343-4
it	be	attribute	must also capable	3343-4
it	representing	action	answers	3343-4
answers	to	constraint	queries	3343-4
<B>	to	constraint	a desirable closure property	3343-5
<B>	leads	action	a desirable closure property	3343-5
a desirable closure property	of	constraint	representations	3343-5
representations	of	constraint	incomplete information	3343-5
incomplete information	with	constraint	respect	3343-5
respect	to	constraint	query languages	3343-5
We	observe	action	the increase	3343-6
the increase	of	constraint	complexity	3343-6
complexity	from	constraint	the use	3343-6
complexity	resulting	action	the use	3343-6
the use	of	constraint	nulls	3343-6
We	also consider	action	briefly two approaches	3344-1
briefly two approaches	to	constraint	knowledge bases	3344-1
<B>	is based	action	487 Incomplete Information	3344-2
487 Incomplete Information	on	constraint	the introduction	3344-2
the introduction	of	constraint	disjunctions	3344-2
disjunctions	in	constraint	deductive databases	3344-2
deductive databases		sequential	which	3344-2
which	to	constraint	a form	3344-2
which	also leads	action	a form	3344-2
a form	of	constraint	incompleteness	3344-2
The second	with	constraint	the use	3344-3
The second	is	attribute	concerned	3344-3
the use	of	constraint	modalities	3344-3
We	briefly mention	action	the language KL	3344-4
the language KL		sequential	which	3344-4
which	permits	action	us	3344-4
us	to	constraint	knowledge	3344-4
us	about	constraint	knowledge	3344-4
us	talk	action	knowledge	3344-4
knowledge	of	constraint	the world	3344-4
Warm Up		sequential	Warm Up	3345-1
We	provide	action	a mechanism	3346-1
a mechanism	for	constraint	incomplete information	3346-1
a mechanism	representing	action	incomplete information	3346-1
incomplete information	using	action	null values	3346-1
The basic idea	to	constraint	occurrences	3347-1
The basic idea	is	attribute	occurrences	3347-1
The basic idea	allow	action	occurrences	3347-1
occurrences	of	constraint	variables	3347-1
variables	in	constraint	the tuples	3347-1
the tuples	of	constraint	the database	3347-1
The different possible values	of	constraint	the variables	3347-2
the variables	yield	action	the possible worlds	3347-2
The simplest model		sequential	that	3348-1
that		sequential	we	3348-1
we	is	attribute	the Codd table	3348-1
we	consider	action	the Codd table	3348-1
the Codd table	by	constraint	Codd	3348-1
the Codd table	introduced	action	Codd	3348-1
Codd	or	conjunctive	table	3348-1
table	for	constraint	<B>	3348-1
A table	is	attribute	a relation	3348-2
a relation	with	constraint	constants	3348-2
constants	and	conjunctive	variables	3348-2
variables	in	constraint	which	3348-2
which		sequential	no variable	3348-2
no variable	occurs twice	action	<B>	3348-2
<B>	More precisely let	action	U	3348-3
U	be	attribute	a finite set	3348-3
a finite set	of	constraint	attributes	3348-3
A table T	over	constraint	U	3348-4
U	is	attribute	a finite set	3348-4
a finite set	of	constraint	free tuples	3348-4
free tuples	over	constraint	U	3348-4
U	that	constraint	each variable	3348-4
each variable	at	constraint	<B>	3348-4
each variable	occurs	action	<B>	3348-4
An example	of	constraint	a table	3348-5
a table	in	constraint	Fig	3348-5
a table	is given	action	Fig	3348-5
19.1		sequential	19.1	3348-6
The figure	also illustrates	action	an alternative representation	3348-7
an alternative representation	@	constraint	that	3348-7
an alternative representation	using	action	that	3348-7
that	that	constraint	we	3348-7
that	but	conjunctive	we	3348-7
that	is	attribute	more visual	3348-7
we	because	constraint	it	3348-7
we	do not adopt here	action	it	3348-7
it	to	constraint	<B>	3348-7
it	is	attribute	more difficult	3348-7
it	generalize	action	<B>	3348-7
The preceding definition	to	constraint	database schemas	3349-1
The preceding definition	easily extends	action	database schemas	3349-1
A database table T	over	constraint	a database schema R	3349-2
a database schema R	is	attribute	a mapping	3349-2
a mapping	over	constraint	R	3349-2
R	that	constraint	each R	3349-2
R	for	constraint	each R	3349-2
each R	in	constraint	R	3349-2
R		sequential	T	3349-2
T		sequential	R	3349-2
R	is	attribute	a table	3349-2
a table	over	constraint	sort	3349-2
sort		sequential	R	3349-2
<B>	For	constraint	this generalization	3349-3
this generalization		sequential	we	3349-3
we	that	constraint	the sets	3349-3
we	assume	action	the sets	3349-3
the sets	of	constraint	variables	3349-3
variables	in	constraint	each table	3349-3
variables	appearing	action	each table	3349-3
each table	are	attribute	pairwise disjoint	3349-3
Relationships	between	constraint	the variables	3349-4
the variables	through	constraint	R B	3349-4
the variables	can be stated	action	R B	3349-4
R B		sequential	C R B C v Table T C	3349-4
C R B C v Table T C	x	sequential	y	3349-4
y		sequential	R B R B C R B C R B C I1	3349-4
R B R B C R B C R B C I1		sequential	I3 I4	3349-4
I3 I4		sequential	I2 Figure	3349-4
I2 Figure		sequential	19.1	3349-4
19.1		sequential	global conditions	3349-4
global conditions		sequential	which	3349-4
which		sequential	we	3349-4
we	in	constraint	the next section	3349-4
we	will introduce	action	the next section	3349-4
<B>	In	constraint	this section	3349-5
this section		sequential	we	3349-5
we	on	constraint	single tables	3349-5
we	will focus	action	single tables	3349-5
single tables		sequential	which	3349-5
which	illustrate well	action	the main issues	3349-5
<B>	To	constraint	the semantics	3350-1
<B>	specify	action	the semantics	3350-1
the semantics	of	constraint	a table	3350-1
a table		sequential	we	3350-1
we	use	action	the notion	3350-1
the notion	of	constraint	valuation	3350-1
valuation	see	action	Chapter 4	3350-1
The incomplete database	by	constraint	a table	3350-2
The incomplete database	represented	action	a table	3350-2
a table	as	constraint	rep	3350-2
a table	is defined	action	rep	3350-2
a table	follows	action	rep	3350-2
rep		sequential	T	3350-2
T	=	sequential	ν	3350-2
ν		sequential	T	3350-2
T	ν	action	a valuation	3350-2
a valuation	of	constraint	the variables	3350-2
the variables	in	constraint	T }	3350-2
<B>	Consider	action	the table T	3351-1
the table T	in	constraint	Fig	3351-1
19.1		sequential	19.1	3351-2
Then I1		sequential	Then I1	3351-3
<B>	.	sequential	<B>	3351-4
<B>	.	sequential	<B>	3351-5
I4 all	to	constraint	rep	3351-6
I4 all	belong	action	rep	3351-6
rep		sequential	T	3351-6
T	are	attribute	possible worlds	3351-6
The preceding definition	assumes	action	the Closed World Assumption	3352-1
the Closed World Assumption		sequential	CWA	3352-1
CWA	see	action	Chapter 2	3352-1
<B>	because	constraint	each tuple	3352-2
<B>	is	attribute	each tuple	3352-2
each tuple	in	constraint	an instance	3352-2
an instance	of	constraint	ref	3352-2
ref		sequential	T	3352-2
T	by	constraint	the presence	3352-2
T	must be justified	action	the presence	3352-2
the presence	of	constraint	a particular free tuple	3352-2
a particular free tuple	in	constraint	T	3352-2
An alternative approach	to	constraint	the Open World Assumption	3352-3
An alternative approach	is	attribute	the Open World Assumption	3352-3
An alternative approach	use	action	the Open World Assumption	3352-3
the Open World Assumption		sequential	OWA	3352-3
<B>	In	constraint	that case	3352-4
that case		sequential	the incomplete database	3352-4
the incomplete database	of	constraint	T	3352-4
T	would include	action	all instances	3352-4
all instances		sequential	that	3352-4
that	contain	action	an instance	3352-4
an instance	of	constraint	rep	3352-4
rep		sequential	T	3352-4
<B>	In	constraint	the choice	3352-5
the choice	of	constraint	CWA	3352-5
CWA	versus	constraint	OWA	3352-5
OWA	does not substantially affect	action	the results	3352-5
the results	for	constraint	incomplete databases	3352-5
the results	obtained	action	incomplete databases	3352-5
We	now have	action	a simple way	3353-1
a simple way	of	constraint	incomplete information	3353-1
a simple way	representing	action	incomplete information	3353-1
<B>		sequential	<B>	3353-2
we	to	constraint	the incomplete database	3353-3
we	to	constraint	the incomplete database	3353-3
we	Naturally wish	attribute	able	3353-3
we	be	attribute	able	3353-3
we	query	action	the incomplete database	3353-3
Exactly what	at	constraint	this point	3353-4
Exactly what	means	attribute	not clear	3353-4
Exactly what	is	attribute	not clear	3353-4
We	at	constraint	this issue	3353-5
We	next look	action	this issue	3353-5
this issue	that	constraint	the simple model	3353-5
this issue	and	conjunctive	the simple model	3353-5
this issue	argue	action	the simple model	3353-5
the simple model	of	constraint	tables	3353-5
tables	has	action	serious shortcomings	3353-5
serious shortcomings	with	constraint	respect	3353-5
respect	to	constraint	queries	3353-5
<B>	to	constraint	an extension	3353-6
<B>	will naturally lead	action	an extension	3353-6
an extension	of	constraint	tables	3353-6
tables		sequential	that	3353-6
that	models	action	more complicated situations	3353-6
<B>	Let	action	us	3354-1
us	consider	action	what	3354-1
what	querying	action	an incomplete database	3354-1
an incomplete database	might mean	action	<B>	3354-1
<B>	Consider	action	a table T	3354-2
<B>	is	attribute	an incomplete database	3355-1
The answer	to	constraint	q	3355-2
q	be	attribute	should a representation	3355-2
should a representation	of	constraint	this incomplete database	3355-2
<B>	consider	action	some particular representation system	3356-1
some particular representation system		sequential	tables	3356-1
Such a system	involves	action	a language	3356-2
a language	for	constraint	representations	3356-2
a language	describing	action	representations	3356-2
representations	and	conjunctive	a mapping rep	3356-2
a mapping rep		sequential	that	3356-2
that	associates	action	a set	3356-2
a set	of	constraint	instances	3356-2
instances	with	constraint	each representation	3356-2
<B>	that	constraint	we	3356-3
<B>	Suppose	action	we	3356-3
we	in	constraint	a particular query language L	3356-3
we	are	attribute	interested	3356-3
a particular query language L		sequential	e.g. relational algebra	3356-3
We	to	constraint	the result	3356-4
We	of	constraint	the result	3356-4
We	would always like	attribute	capable	3356-4
We	be	attribute	capable	3356-4
We	representing	action	the result	3356-4
the result	of	constraint	a query	3356-4
a query	in	constraint	the same system	3356-4
<B>	for	constraint	each representation T	3356-5
<B>	In	constraint	other words	3357-1
other words		sequential	q	3357-1
q		sequential	T	3357-1
T	represents	action	the possible answers	3357-1
the possible answers	of	constraint	q	3357-1
q		sequential	q	3357-1
q		sequential	I	3357-1
I		sequential	I	3357-1
I	∈	action	rep	3357-1
rep		sequential	T	3357-1
T		sequential	}	3357-1
<B>	If	constraint	some representation system	3358-1
some representation system		sequential	τ	3358-1
τ	has	action	the property	3358-1
the property	for	constraint	a query language L	3358-1
the property	described	action	a query language L	3358-1
a query language L		sequential	we	3358-1
we	that	constraint	τ	3358-1
we	will say	action	τ	3358-1
τ	is	attribute	a strong representation system Clearly	3358-1
a strong representation system Clearly	for	constraint	L.	3358-1
L.		sequential	we	3358-1
we	in	constraint	strong representation systems	3358-1
we	are	attribute	particularly interested	3358-1
strong representation systems	for	constraint	relational algebra	3358-1
relational algebra	and	conjunctive	we	3358-1
we	shall develop later	action	such a system	3358-1
<B>	Let	action	us	3359-1
us	to	constraint	tables	3359-1
us	now return	action	tables	3359-1
we	into	constraint	trouble	3359-2
we	Unfortunately quickly run	action	trouble	3359-2
trouble	when asking	action	queries	3359-2
queries	against	constraint	them	3359-2
them	as	constraint	the following example	3359-2
the following example	shows	action	<B>	3359-2
Example		sequential	19.1.1	3360-1
19.1.1	Consider	action	T	3360-1
T	of	constraint	Fig	3360-1
<B>	and	conjunctive	19.1 the algebraic query σ	3360-2
19.1 the algebraic query σ		sequential	A=3	3360-2
A=3		sequential	T	3360-2
There	is	attribute	no table	3360-3
no table	representing	action	the possible answers	3360-3
the possible answers	to	constraint	this query	3360-3
A possible answer	for	constraint	e.g. I1	3360-4
e.g. I1	is	attribute	the empty relation	3360-4
the empty relation	whereas	constraint	there	3360-4
there	are	attribute	nonempty possible answers	3360-4
nonempty possible answers	for	constraint	e.g. I2	3360-4
<B>	Suppose	action	Incomplete Information	3360-5
Incomplete Information		sequential	that	3360-5
that		sequential	there	3360-5
there	exists	action	a table	3360-5
a table		sequential	T	3360-5
T	representing	action	the set	3360-5
the set	of	constraint	possible answers	3360-5
<B>	Either	conjunctive	T	3360-6
T	and	conjunctive	σ	3360-6
T	is	attribute	empty	3360-6
σ		sequential	A=3	3360-6
A=3		sequential	I2	3360-6
I2	in	constraint	not rep	3360-6
I2	is	attribute	not rep	3360-6
not rep		sequential	T	3360-6
T		sequential	′	3360-6
′	or	conjunctive	T	3360-6
T	and	conjunctive	the empty relation	3360-6
T	is	attribute	nonempty	3360-6
the empty relation	in	constraint	not rep	3360-6
the empty relation	is	attribute	not rep	3360-6
not rep		sequential	T	3360-6
T		sequential	′	3360-6
<B>	is	attribute	a contradiction	3360-7
a contradiction		sequential	no such T ′	3360-7
no such T ′	so can exist	action	<B>	3360-7
The problem	in	constraint	the weakness	3361-1
The problem	lies	action	the weakness	3361-1
the weakness	of	constraint	the representation system	3361-1
the representation system	of	constraint	tables	3361-1
tables		sequential	we	3361-1
we	will consider	action	richer representation systems	3361-1
richer representation systems		sequential	that	3361-1
that	to	constraint	a complete representation system	3361-1
that	lead	action	a complete representation system	3361-1
a complete representation system	for	constraint	relational algebra	3361-1
a complete representation system	of	constraint	relational algebra	3361-1
An alternative approach	to	constraint	we	3361-2
An alternative approach	is	attribute	less demanding	3361-2
An alternative approach	be	attribute	less demanding	3361-2
we	and	conjunctive	the notion	3361-2
we	consider	attribute	this	3361-2
we	present	action	the notion	3361-2
the notion	of	constraint	weak representation systems	3361-2
Weak Representation Systems		sequential	Weak Representation Systems	3362-1
we	Instead will ask	action	which	3362-2
which	are	attribute	the tuples	3362-2
the tuples		sequential	that	3362-2
that	in	constraint	surely the answer	3362-2
that	are	attribute	surely the answer	3362-2
surely the answer		sequential	that	3362-2
that	to	constraint	all possible answers	3362-2
that	belong	action	all possible answers	3362-2
we	for	constraint	the tuples	3362-3
we	Similarly may ask	action	the tuples	3362-3
the tuples		sequential	that	3362-3
that	in	constraint	possibly the answer	3362-3
that	are	attribute	possibly the answer	3362-3
possibly the answer	to	constraint	some possible answer	3362-3
possibly the answer	belong	action	some possible answer	3362-3
We	make	attribute	this	3363-1
<B>	For	constraint	a table	3364-1
a table		sequential	T	3364-1
T	and	conjunctive	a query	3364-1
a query		sequential	q	3364-1
q		sequential	the set	3364-1
the set	of	constraint	sure facts	3364-1
sure facts		sequential	q	3364-1
q		sequential	T	3364-1
T	as	constraint	q	3364-1
T	is defined	attribute	sure	3364-1
q		sequential	T	3364-1
T	=	sequential	∩	3364-1
∩		sequential	q	3364-1
q		sequential	I	3364-1
I		sequential	I	3364-1
I	∈	action	rep	3364-1
rep		sequential	T	3364-1
a tuple	in	constraint	q	3365-1
a tuple	is	attribute	Clearly sure	3365-1
q		sequential	T	3365-1
T	iff	constraint	it	3365-1
it	in	constraint	the answer	3365-1
it	is	attribute	the answer	3365-1
the answer	for	constraint	every possible world	3365-1
<B>	that	constraint	the sure tuples	3365-2
<B>	Observe	action	the sure tuples	3365-2
the sure tuples	in	constraint	a table T	3365-2
a table T		sequential	the tuples	3365-2
the tuples	in	constraint	every possible world	3365-2
every possible world	in	constraint	rep	3365-2
rep		sequential	T	3365-2
T	by	constraint	all free tuples	3365-2
T	can be computed easily	action	all free tuples	3365-2
T	dropping	action	all free tuples	3365-2
all free tuples	with	constraint	variables	3365-2
One	could similarly define	action	the set poss	3365-3
the set poss		sequential	q	3365-3
q		sequential	T	3365-3
T	of	constraint	possible facts	3365-3
One	to	constraint	a weak system	3366-1
One	of	constraint	a weak system	3366-1
One	might be tempted	action	a weak system	3366-1
One	require	action	a weak system	3366-1
a weak system		sequential	just the ability	3366-1
just the ability	to	constraint	the set	3366-1
just the ability	represent	action	the set	3366-1
the set	of	constraint	tuples	3366-1
tuples	in	constraint	surely the answer	3366-1
the definition	However requires	action	some care	3366-2
some care	due to	constraint	the following subtlety	3366-2
<B>	Suppose	action	T	3366-3
T	is	attribute	the table	3366-3
the table	in	constraint	Fig	3366-3
19.1	and	conjunctive	the query σ	3366-4
19.1	q	action	the query σ	3366-4
the query σ		sequential	A=2	3366-4
A=2		sequential	R	3366-4
R	for	constraint	which	3366-4
which		sequential	q	3366-4
q		sequential	T	3366-4
T	=	sequential	<B>	3366-4
T	∅	sequential	<B>	3366-4
<B>	Consider now	action	the query q′	3366-5
the query q′		sequential	π AB	3366-5
π AB		sequential	R	3366-5
R	and	conjunctive	q	3366-5
q		sequential	the query q′	3366-5
<B>		sequential	q	3367-1
q		sequential	T	3367-1
T	=	sequential	q′	3367-1
q′		sequential	q	3367-1
q		sequential	rep	3367-1
rep		sequential	T	3367-1
T	=	sequential	2	3367-1
T	{	sequential	2	3367-1
2		sequential	0	3367-1
<B>	by	constraint	the tuples	3367-2
<B>	So can not be computed	action	the tuples	3367-2
<B>	first computing	action	the tuples	3367-2
the tuples	by	constraint	q	3367-2
the tuples	surely returned	action	q	3367-2
q	and	conjunctive	q′	3367-2
q	applying	action	q′	3367-2
<B>	because	constraint	it	3367-3
<B>	is	attribute	rather unpleasant	3367-3
it	that	constraint	the semantics	3367-3
it	is	attribute	generally desirable	3367-3
the semantics	of	constraint	queries	3367-3
queries	be	attribute	compositional	3367-3
the result	of	constraint	q	3367-3
q	◦	sequential	q′	3367-3
q′	by	constraint	q′	3367-3
q′	should be obtained	action	q′	3367-3
q′	applying	action	q′	3367-3
q′	to	constraint	the result	3367-3
the result	of	constraint	q	3367-3
The conclusion	that	constraint	the answer	3367-4
The conclusion	is	attribute	the answer	3367-4
the answer	to	constraint	q	3367-4
q	should provide	action	more information	3367-4
more information	than	constraint	q	3367-4
q		sequential	T	3367-4
T		sequential	the incomplete database	3367-4
the incomplete database		sequential	it	3367-4
it	to	constraint	q	3367-4
it	specifies	attribute	should equivalent	3367-4
it	be	attribute	should equivalent	3367-4
q		sequential	rep	3367-4
rep		sequential	T	3367-4
T	with	constraint	respect	3367-4
respect	to	constraint	its ability	3367-4
its ability	to	constraint	the sure tuples	3367-4
its ability	compute	action	the sure tuples	3367-4
the sure tuples	of	constraint	any query	3367-4
any query	in	constraint	the language	3367-4
the language	to	constraint	it	3367-4
the language	applied	action	it	3367-4
This notion	of	constraint	equivalence	3368-1
equivalence	of	constraint	two incomplete databases	3368-1
two incomplete databases	as	constraint	<B>	3368-1
two incomplete databases	is formalized	action	<B>	3368-1
two incomplete databases	follows	action	<B>	3368-1
<B>	If	constraint	L	3369-1
L	is	attribute	a query language	3369-1
a query language		sequential	we	3369-1
we	that	constraint	two incomplete databases	3369-1
we	will say	action	two incomplete databases	3369-1
two incomplete databases		sequential	I	3369-1
I		sequential	J	3369-1
J	are	attribute	L	3369-1
L	denoted	action	I	3369-1
I	≡L	action	J	3369-1
J	if	constraint	each q	3369-1
J	for	constraint	each q	3369-1
each q	in	constraint	L	3369-1
L		sequential	we	3369-1
we	have	action	<B>	3369-1
<B>	In	constraint	other words	3370-1
other words		sequential	the two incomplete databases	3370-1
the two incomplete databases	if	constraint	we	3370-1
the two incomplete databases	are	attribute	undistinguishable	3370-1
we	for	constraint	the set	3370-1
we	is	attribute	the set	3370-1
we	can ask	action	the set	3370-1
the set	of	constraint	sure tuples	3370-1
sure tuples	in	constraint	answers	3370-1
answers	to	constraint	queries	3370-1
queries	in	constraint	L	3370-1
We	can now define	action	weak representation systems	3371-1
<B>	Suppose	action	L	3371-2
L	is	attribute	a query language	3371-2
A representation system	for	constraint	L	3371-3
A representation system	is	attribute	weak	3371-3
L	if	constraint	each representation T	3371-3
L	for	constraint	each representation T	3371-3
each representation T	of	constraint	an incomplete database	3371-3
an incomplete database	and	conjunctive	each q	3371-3
each q	in	constraint	L	3371-3
L		sequential	there	3371-3
there	exists	action	a representation	3371-3
a representation	denoted	action	q	3371-3
q		sequential	T	3371-3
T		sequential	such that rep	3371-3
such that rep		sequential	q	3371-3
q		sequential	T	3371-3
T		sequential	≡L q	3371-3
≡L q		sequential	rep	3371-3
rep		sequential	T	3371-3
<B>	With	constraint	the preceding definition	3372-1
the preceding definition		sequential	q	3372-1
q		sequential	T	3372-1
T	does not provide	attribute	precisely sure	3372-1
q		sequential	T	3372-1
T	for	constraint	tables	3372-1
tables		sequential	T	3372-1
<B>	that	constraint	q	3372-2
<B>	However note	attribute	sure	3372-2
q		sequential	T	3372-2
T	at	constraint	the end	3372-2
T	can be obtained simply	action	the end	3372-2
the end	by	constraint	the answer	3372-2
the end	from	constraint	the answer	3372-2
the end	eliminating	action	the answer	3372-2
the answer		sequential	all rows	3372-2
all rows	with	constraint	occurrences	3372-2
occurrences	of	constraint	variables	3372-2
The next result	indicates	action	the power	3373-1
the power	of	constraint	tables	3373-1
tables	as	constraint	a weak representation system	3373-1
Theorem		sequential	19.2.1	3374-1
Crux		sequential	Crux	3375-1
Selections	on	constraint	tables	3376-1
Selections	operate conservatively	action	tables	3376-1
<B>	For	constraint	example	3376-2
example	for	constraint	all valuations	3376-2
all valuations		sequential	ν	3376-2
ν	of	constraint	the variables	3376-2
the variables	in	constraint	t }	3376-2
Projections	like	constraint	classical projections	3377-1
Projections	operate	action	classical projections	3377-1
<B>	For	constraint	example	3377-2
example	if	constraint	T	3377-2
T	is	attribute	again the table	3377-2
again the table	in	constraint	Fig	3377-2
19.1		sequential	19.1	3377-3
<B>	Let	action	us	3378-1
us	that	constraint	tables	3378-1
us	show	action	tables	3378-1
tables	are	attribute	no longer a weak representation system	3378-1
no longer a weak representation system	if	constraint	union	3378-1
no longer a weak representation system	or	conjunctive	union	3378-1
no longer a weak representation system	join	action	union	3378-1
union	to	constraint	SP	3378-1
union	are added	action	SP	3378-1
<B>	Consider	action	<B>	3378-2
<B>	join first	action	<B>	3378-2
the query language	is	attribute	So now SPJ	3378-3
<B>	Let	action	T	3378-4
T	be	attribute	the table R B C	3378-4
the table R B C		sequential	x	3378-4
x		sequential	c	3378-4
c		sequential	x′ c′	3378-4
x′ c′		sequential	x	3378-4
x		sequential	x′	3378-4
x′	are	attribute	where variables	3378-4
where variables	and	conjunctive	c	3378-4
c		sequential	c′	3378-4
c′	are	attribute	constants	3378-4
<B>	Let	action	q	3379-1
q		sequential	π AC	3379-1
π AC		sequential	R	3379-1
R	⊲⊳	sequential	π B	3379-1
π B		sequential	R	3379-1
<B>	Suppose	action	there	3379-2
there	is	attribute	table W	3379-2
table W		sequential	such that rep	3379-2
such that rep		sequential	W	3379-2
W		sequential	SPJ q	3379-2
SPJ q		sequential	rep	3379-2
rep		sequential	T	3379-2
T		sequential	<B>	3379-2
<B>	Because	constraint	a′	3379-3
a′		sequential	c ∈	3379-3
c ∈		sequential	q′	3379-3
q′		sequential	W	3379-3
W	for	constraint	each valuation	3379-3
each valuation		sequential	ν	3379-3
ν	of	constraint	variables	3379-3
variables	in	constraint	W	3379-3
W		sequential	there	3379-3
there	must exist	action	tuples	3379-3
tuples		sequential	u	3379-3
u		sequential	v ∈ W	3379-3
v ∈ W	that	constraint	u	3379-3
u		sequential	A	3379-3
A	=	sequential	a′	3379-3
a′		sequential	v	3379-3
v		sequential	C	3379-3
C	=	sequential	c	3379-3
c		sequential	ν	3379-3
ν		sequential	u	3379-3
u		sequential	B	3379-3
B	=	sequential	ν	3379-3
ν		sequential	v	3379-3
v		sequential	B	3379-3
<B>	Let	action	ν	3379-4
ν	be	attribute	a valuation such	3379-4
a valuation such		sequential	that	3379-4
that		sequential	ν	3379-4
ν		sequential	z	3379-4
z	=	sequential	ν	3379-4
ν		sequential	y	3379-4
y	for	constraint	all variables z	3379-4
all variables z		sequential	y	3379-4
y		sequential	z	3379-4
z	=	sequential	y	3379-4
<B>	If	constraint	u	3379-5
u	=	sequential	v	3379-5
v		sequential	u	3379-5
u		sequential	A	3379-5
A	=	sequential	a′	3379-5
a′	and	conjunctive	u	3379-5
u		sequential	C	3379-5
C	=	sequential	c	3379-5
c		sequential	a′	3379-5
a′		sequential	c	3379-5
c		sequential	∈	3379-5
∈		sequential	π AC	3379-5
π AC		sequential	R	3379-5
R		sequential	W	3379-5
<B>	because	constraint	can not a′ c ∈	3379-6
<B>	be	attribute	can not a′ c ∈	3379-6
can not a′ c ∈		sequential	π	3379-6
π		sequential	AC	3379-6
AC		sequential	R	3379-6
R		sequential	q	3379-6
q		sequential	rep	3379-6
rep		sequential	T	3379-6
<B>		sequential	u	3379-7
u	Because	constraint	ν	3379-7
u	=	sequential	ν	3379-7
ν		sequential	u	3379-7
u		sequential	B	3379-7
B	=	sequential	ν	3379-7
ν		sequential	v	3379-7
v		sequential	B	3379-7
B	and	conjunctive	W	3379-7
W	has	action	no repeated variables	3379-7
no repeated variables		sequential	it	3379-7
it	that	constraint	u	3379-7
it	follows	action	u	3379-7
u		sequential	B	3379-7
B	and	conjunctive	v	3379-7
v	B equal	action	some constant k.	3379-7
The proof	that	constraint	tables	3380-1
tables	do not provide	action	a weak representation system	3380-1
a weak representation system	for	constraint	SPU	3380-1
SPU	follows	action	similar lines	3380-1
<B>	Just consider	action	the table	3380-2
the table		sequential	T R B	3380-2
T R B		sequential	x b	3380-2
Naive Tables		sequential	Naive Tables	3381-1
We	next consider	action	a first extension	3382-1
a first extension	of	constraint	tables	3382-1
tables		sequential	that	3382-1
that	allows	action	repetitions	3382-1
repetitions	of	constraint	variables	3382-1
It	that	constraint	a weak representation system	3382-2
It	will turn out	attribute	this	3382-2
It	will provide	action	a weak representation system	3382-2
a weak representation system	for	constraint	a large subset	3382-2
a large subset	of	constraint	relational algebra	3382-2
Theorem		sequential	19.2.2	3383-1
Crux	Given	action	a naive table T	3384-1
a naive table T	and	conjunctive	a positive query q	3384-1
a positive query q		sequential	the evaluation	3384-1
the evaluation	of	constraint	q	3384-1
q		sequential	T	3384-1
T	is	attribute	extremely simple	3384-1
The variables	as	constraint	distinct new constants	3384-2
The variables	are treated	action	distinct new constants	3384-2
The standard evaluation	of	constraint	q	3384-3
q	on	constraint	the table	3384-3
q	is performed	action	the table	3384-3
<B>	that	constraint	incomplete information	3384-4
<B>	Note	action	incomplete information	3384-4
incomplete information	yields	action	no extra cost	3384-4
no extra cost	in	constraint	this case	3384-4
We	leave	action	it	3384-5
it	to	constraint	the reader	3384-5
the reader	to	constraint	<B>	3384-5
the reader	that	constraint	<B>	3384-5
the reader	verify	attribute	this	3384-5
the reader	works	action	<B>	3384-5
R B		sequential	C	3385-1
C		sequential	x x	3385-1
x x		sequential	v Figure	3385-1
v Figure		sequential	19.2	3385-1
19.2		sequential	Naive tables	3385-1
Naive tables	yield	action	a nice representation system	3385-1
a nice representation system	for	constraint	a rather large language	3385-1
<B>	But	conjunctive	the representation system	3385-2
the representation system	and	conjunctive	the language	3385-2
the representation system	is	attribute	weak	3385-2
the language	of	constraint	relational algebra	3385-2
the language	does not cover	attribute	all	3385-2
We	in	constraint	the next section	3385-3
We	introduce	action	the next section	3385-3
the next section		sequential	a representation	3385-3
a representation		sequential	that	3385-3
that	is	attribute	a strong system	3385-3
a strong system	for	constraint	relational algebra	3385-3
Conditional Tables		sequential	Conditional Tables	3386-1
<B>	To	constraint	what	3386-2
<B>	see	action	what	3386-2
what	that	constraint	we	3386-2
what	is	attribute	missing	3386-2
what	recall	action	we	3386-2
we	to	constraint	the result	3386-2
we	when attempt	action	the result	3386-2
we	represent	action	the result	3386-2
the result	of	constraint	a selection	3386-2
a selection	on	constraint	a table	3386-2
a table		sequential	we	3386-2
we	into	constraint	the problem	3386-2
we	run	action	the problem	3386-2
the problem		sequential	that	3386-2
that		sequential	the presence	3386-2
the presence	or	conjunctive	absence	3386-2
absence	of	constraint	certain tuples	3386-2
certain tuples	in	constraint	a possible answer	3386-2
a possible answer	by	constraint	certain properties	3386-2
a possible answer	is conditioned	action	certain properties	3386-2
certain properties	of	constraint	the valuation	3386-2
<B>	To	constraint	we	3386-3
<B>	capture	attribute	this	3386-3
we	extend	action	the representation	3386-3
the representation	with	constraint	conditions	3386-3
conditions	on	constraint	variables	3386-3
variables		sequential	which	3386-3
which	yields	action	conditional tables	3386-3
We	that	constraint	such tables	3386-4
We	will show	action	such tables	3386-4
such tables	form	action	a strong representation system	3386-4
a strong representation system	for	constraint	relational algebra	3386-4
<B>	If	constraint	formula P	3387-1
formula P	is	attribute	a condition	3387-1
a condition		sequential	we	3387-1
we	that	constraint	a valuation	3387-1
we	say	action	a valuation	3387-1
a valuation		sequential	ν	3387-1
ν	satisfies	action	P	3387-1
P	if	constraint	its assignment	3387-1
its assignment	of	constraint	constants	3387-1
constants	to	constraint	variables	3387-1
variables	makes	action	the formula	3387-1
the formula		sequential	<B>	3387-1
Conditions	with	constraint	table T	3388-1
Conditions	may be associated	action	table T	3388-1
table T	in	constraint	two ways	3388-1
two ways		sequential	A global condition PT	3388-1
A global condition PT	with	constraint	the entire table T	3388-1
A global condition PT	1 is associated	action	the entire table T	3388-1
the entire table T		sequential	a local condition ϕt	3388-1
a local condition ϕt	with	constraint	one tuple t	3388-1
a local condition ϕt	2 is associated	action	one tuple t	3388-1
one tuple t	of	constraint	table T	3388-1
A conditional table		sequential	c- table	3388-2
c- table	for	constraint	a triple	3388-2
c- table	is	attribute	a triple	3388-2
a triple		sequential	T where	3388-2
T where		sequential	PT	3388-2
PT		sequential	ϕ	3388-2
<B>	For	constraint	our purposes	3389-1
our purposes		sequential	the global conditions	3389-1
the global conditions	in	constraint	c-tables	3389-1
c-tables	at	constraint	the tuple level	3389-1
c-tables	could be distributed	action	the tuple level	3389-1
the tuple level	as	constraint	local conditions	3389-1
they	as	constraint	shorthand	3389-2
they	are	attribute	However convenient	3389-2
shorthand	and	conjunctive	dependencies	3389-2
dependencies	when are considered	action	<B>	3389-2
<B>	For	constraint	brevity	3390-1
brevity		sequential	we	3390-1
we	to	constraint	a c- table	3390-1
we	usually refer	action	a c- table	3390-1
a c- table		sequential	T	3390-1
T		sequential	PT	3390-1
PT		sequential	ϕ	3390-1
ϕ	as	constraint	simply T	3390-1
A given c-table T	represents	action	a set	3390-2
a set	of	constraint	instances	3390-2
instances	as	constraint	the CWA	3390-2
instances	follows	action	the CWA	3390-2
instances	again adopting	action	the CWA	3390-2
the CWA		sequential	Incomplete Information	3390-2
Incomplete Information		sequential	T′ B	3390-2
T′ B	x	sequential	≠ 2	3390-2
≠ 2		sequential	y	3390-2
y		sequential	≠ 2	3390-2
≠ 2	x	sequential	y	3390-2
y	=	sequential	0	3390-2
0		sequential	y x	3390-2
y x		sequential	x ≠	3390-2
x ≠		sequential	y J J	3390-2
y J J		sequential	J J B B B	3390-2
J J B B B		sequential	B Figure	3390-2
B Figure		sequential	19.3	3390-2
19.3		sequential	rep	3390-2
rep		sequential	T	3390-2
T	=	sequential	<B>	3390-2
T	{	sequential	<B>	3390-2
<B>	Consider	action	the table	3391-1
the table		sequential	T	3391-1
T	in	constraint	Fig	3391-1
19.3		sequential	19.3	3391-2
J1		sequential	J2	3391-3
J2		sequential	J3	3391-3
J3		sequential	J4	3391-3
J4	by	constraint	x	3391-3
J4	Then are obtained	action	x	3391-3
J4	valuating	action	x	3391-3
x		sequential	y	3391-3
y		sequential	z	3391-3
z	to	constraint	0,0,0	3391-3
0,0,0		sequential	0,1,0	3391-3
0,1,0		sequential	1,0,0	3391-3
1,0,0	and	conjunctive	3,0,0	3391-3
3,0,0		sequential	<B>	3391-3
The next example	illustrates	action	the considerable power	3392-1
the considerable power	of	constraint	the local conditions	3392-1
the local conditions	of	constraint	c-tables	3392-1
c-tables	including	action	the ability	3392-1
the ability	to	constraint	disjunctive information	3392-1
the ability	capture	action	disjunctive information	3392-1
Example		sequential	19.3.1	3393-1
Two representations		sequential	T	3393-2
T		sequential	T	3393-2
T	to	constraint	denoted T	3393-2
T	are said	attribute	equivalent	3393-2
T	be	attribute	equivalent	3393-2
denoted T		sequential	T	3393-2
T	if	constraint	rep	3393-2
rep		sequential	T	3393-2
T	=	sequential	rep	3393-2
rep		sequential	T	3393-2
T		sequential	′	3393-2
Testing	for	constraint	equivalence	3393-3
equivalence	of	constraint	c-tables	3393-3
c-tables	is	attribute	not a trivial task	3393-3
<B>	Just testing	action	membership	3393-4
membership	of	constraint	an instance	3393-4
an instance	in	constraint	rep	3393-4
rep		sequential	T	3393-4
T		sequential	apparently a simpler task	3393-4
apparently a simpler task	to	constraint	<B>	3393-4
apparently a simpler task	will be shown	attribute	np- complete	3393-4
apparently a simpler task	be	attribute	np- complete	3393-4
<B>	To	constraint	equivalence	3393-5
<B>	test	action	equivalence	3393-5
equivalence	of	constraint	two c-tables	3393-5
two c-tables		sequential	T	3393-5
T	and	conjunctive	T	3393-5
T	′	sequential	one	3393-5
one	that	constraint	each valuation	3393-5
one	for	constraint	each valuation	3393-5
one	must show	action	each valuation	3393-5
each valuation		sequential	ν	3393-5
ν	of	constraint	the variables	3393-5
the variables	in	constraint	T	3393-5
T		sequential	there	3393-5
there	exists	action	a valuation ν′	3393-5
a valuation ν′	for	constraint	T	3393-5
T	that	constraint	ν	3393-5
ν		sequential	T	3393-5
T	=	sequential	ν′	3393-5
ν′		sequential	T	3393-5
T		sequential	′	3393-5
′	and	conjunctive	<B>	3393-5
it	that	constraint	one	3394-1
it	Fortunately can be shown	action	one	3394-1
one	need only consider	action	valuations	3394-1
valuations	to	constraint	a set C	3394-1
a set C	of	constraint	constants	3394-1
constants	containing	action	all constants	3394-1
all constants	in	constraint	T	3394-1
T	or	conjunctive	T	3394-1
T	and	conjunctive	whose size	3394-1
whose size	at	constraint	the number	3394-1
whose size	is	attribute	most	3394-1
the number	of	constraint	variables	3394-1
variables	in	constraint	the two tables	3394-1
the two tables		sequential	Exercise	3394-1
Exercise		sequential	19.11	3394-1
<B>	that	constraint	equivalence	3394-2
<B>	shows	action	equivalence	3394-2
equivalence	of	constraint	c-tables	3394-2
c-tables	is	attribute	decidable	3394-2
<B>	In	constraint	a minimal representation	3395-1
<B>	finding	action	a minimal representation	3395-1
a minimal representation	be	attribute	can hard	3395-1
<B>	may affect	action	the computation	3395-2
the computation	of	constraint	the result	3395-2
the result	of	constraint	a query	3395-2
a query	in	constraint	various ways	3395-2
It	that	constraint	c-tables	3396-1
It	turns out	action	c-tables	3396-1
c-tables	form	action	a strong representation system	3396-1
a strong representation system	for	constraint	relational algebra	3396-1
Theorem		sequential	19.3.2	3397-1
Crux		sequential	Crux	3398-1
The example	in	constraint	Fig	3398-2
19.4	should clarify	action	the construction	3398-3
Selection	by	constraint	new conjuncts	3398-4
Selection	is performed	action	new conjuncts	3398-4
Selection	adding	action	new conjuncts	3398-4
new conjuncts	to	constraint	the local conditions	3398-4
Union	by	constraint	the union	3398-5
Union	is represented	action	the union	3398-5
the union	of	constraint	the two tables	3398-5
the two tables	after	constraint	they	3398-5
the two tables	that	constraint	they	3398-5
the two tables	making	attribute	sure	3398-5
they	use	action	distinct sets	3398-5
distinct sets	of	constraint	variables	3398-5
variables	and	conjunctive	the appropriate local conditions	3398-5
variables	choosing	action	the appropriate local conditions	3398-5
<B>	and	conjunctive	intersection	3398-6
<B>	Join	action	intersection	3398-6
intersection	involve	action	all pairs	3398-6
intersection	considering	action	all pairs	3398-6
all pairs	of	constraint	tuples	3398-6
tuples	from	constraint	the two tables	3398-6
<B>	For	constraint	difference	3398-7
difference		sequential	we	3398-7
we	consider	action	a tuple	3398-7
a tuple	in	constraint	the first table	3398-7
the first table	and	conjunctive	a huge conjunct	3398-7
the first table	add	action	a huge conjunct	3398-7
a huge conjunct	that	constraint	it	3398-7
a huge conjunct	stating	action	it	3398-7
it	does not match	action	any tuple	3398-7
any tuple	from	constraint	the second table	3398-7
the second table		sequential	disjunctions	3398-7
disjunctions	as	constraint	shorthand	3398-7
disjunctions	may be used	action	shorthand	3398-7
shorthand		sequential	they	3398-7
they	can be simulated	action	new variables	3398-7
they	using	action	new variables	3398-7
new variables	as	constraint	Example 19.3.1	3398-7
new variables	in	constraint	Example 19.3.1	3398-7
new variables	illustrated	action	Example 19.3.1	3398-7
<B>	To	constraint	this section	3399-1
<B>	conclude	action	this section	3399-1
this section		sequential	we	3399-1
we	consider	action	1 languages	3399-1
1 languages	with	constraint	recursion	3399-1
recursion	and	conjunctive	2 dependencies	3399-1
<B>	In	constraint	both cases	3399-2
both cases	for	constraint	related reasons	3399-2
both cases	and	conjunctive	related reasons	3399-2
related reasons		sequential	the aforementioned representation system	3399-2
the aforementioned representation system	behaves well	action	<B>	3399-2
The presentation	by	constraint	examples	3399-3
The presentation	is	attribute	examples	3399-3
examples	but	conjunctive	the formal results	3399-3
the formal results	can be derived easily	action	<B>	3399-3
Languages	with	constraint	Recursion	3400-1
Recursion	Consider	action	an incomplete database	3400-1
an incomplete database	and	conjunctive	a query	3400-1
a query	involving	action	fixpoint	3400-1
<B>	For	constraint	instance	3400-2
instance	consider	action	the table	3400-2
the table	in	constraint	Fig	3400-2
19.5		sequential	19.5	3400-3
The representation tc		sequential	T	3400-4
T	of	constraint	the answer	3400-4
the answer	to	constraint	the transitive closure query tc	3400-4
the transitive closure query tc	in	constraint	the same figure	3400-4
the transitive closure query tc	is also given	action	the same figure	3400-4
One	that	constraint	rep	3400-5
One	can easily verify	action	rep	3400-5
rep		sequential	tc	3400-5
tc		sequential	T	3400-5
T	=	sequential	tc	3400-5
tc		sequential	rep	3400-5
rep		sequential	T	3400-5
<B>	to	constraint	arbitrary languages	3401-1
<B>	can be generalized	action	arbitrary languages	3401-1
arbitrary languages	with	constraint	iteration	3401-1
<B>	For	constraint	example	3401-2
example	consider	action	a c- table T	3401-2
a c- table T	and	conjunctive	a relational algebra query q	3401-2
a relational algebra query q		sequential	that	3401-2
that		sequential	we	3401-2
we	to	constraint	a fixpoint	3401-2
we	until	constraint	a fixpoint	3401-2
we	want	action	a fixpoint	3401-2
we	iterate	action	a fixpoint	3401-2
a fixpoint	is reached	action	<B>	3401-2
Incomplete Information T		sequential	1 B C T	3402-1
1 B C T		sequential	2 B C	3402-1
2 B C	x	sequential	c	3402-1
c		sequential	y c	3402-1
y c		sequential	y	3402-1
y	w	constraint	T	3402-1
T		sequential	3 B B C y	3402-1
3 B B C y		sequential	y c T	3402-1
y c T		sequential	1 ∪ T 2 B C T 1 T	3402-1
1 ∪ T 2 B C T 1 T		sequential	3 A B C y c	3402-1
3 A B C y c		sequential	x	3402-1
x		sequential	c	3402-1
c		sequential	y	3402-1
y		sequential	c	3402-1
c	w	constraint	T	3402-1
T	–	sequential	T	3402-1
T		sequential	1 2 B C	3402-1
1 2 B C	x	sequential	c	3402-1
c	x	sequential	c	3402-1
c	x	sequential	c	3402-1
c		sequential	c Computing	3402-1
c Computing	with	constraint	c-tables	3402-1
<B>	.	sequential	<B>	3402-2
<B>	.	sequential	<B>	3402-3
qi		sequential	T	3402-4
<B>	.	sequential	<B>	3402-5
<B>	.	sequential	<B>	3402-6
<B>	.	sequential	<B>	3402-7
<B>	that	constraint	q	3403-1
<B>	Suppose now	action	q	3403-1
q	is	attribute	a positive query	3403-1
We	to	constraint	a fixpoint	3403-2
We	are guaranteed	action	a fixpoint	3403-2
We	reach	action	a fixpoint	3403-2
a fixpoint	on	constraint	every single complete instance	3403-2
<B>		sequential	a priori	3403-3
a priori	that	constraint	the sequence	3403-3
a priori	However does not imply	action	the sequence	3403-3
the sequence	of	constraint	representations	3403-3
representations		sequential	qi	3403-3
qi		sequential	T	3403-3
T		sequential	i 0	3403-3
i 0	converges	action	<B>	3403-3
we	that	constraint	fact	3403-4
we	in	constraint	fact	3403-4
we	Nonetheless can show	attribute	this	3403-4
we	is	attribute	fact	3403-4
fact		sequential	the case	3403-4
<B>	For	constraint	i	3403-5
i		sequential	rep	3403-5
rep		sequential	qi	3403-5
qi		sequential	T	3403-5
T	=	sequential	rep	3403-5
rep		sequential	qi+1	3403-5
qi+1		sequential	T	3403-5
T		sequential	B	3404-1
B		sequential	t c	3404-1
t c		sequential	T	3404-1
T		sequential	B b b x c c	3404-1
B b b x c c		sequential	x	3404-1
x		sequential	c d c d	3404-1
c d c d		sequential	x	3404-1
x	=	sequential	c b x d c c	3404-1
c b x d c c		sequential	x	3404-1
x	=	sequential	d x	3404-1
d x	=	sequential	b Figure 19.5	3404-1
b Figure 19.5		sequential	Transitive closure	3404-1
Transitive closure	of	constraint	a table	3404-1
<B>	to	constraint	the table	3405-1
<B>	find	action	the table	3405-1
the table	representing	action	the result	3405-1
the result		sequential	it	3405-1
it	to	constraint	the sequence	3405-1
it	Thus suffices	action	the sequence	3405-1
it	compute	action	the sequence	3405-1
Dependencies		sequential	Dependencies	3406-1
We	now reconsider	action	dependencies	3406-2
dependencies	in	constraint	the context	3406-2
the context	of	constraint	incomplete information	3406-2
<B>	Suppose	action	we	3406-3
we	are given	action	an incomplete database	3406-3
an incomplete database		sequential	a set I	3406-3
a set I	of	constraint	complete databases	3406-3
complete databases	in	constraint	addition	3406-3
complete databases	and	conjunctive	addition	3406-3
complete databases	are told	action	addition	3406-3
addition	that	constraint	dependencies	3406-3
addition	of	constraint	dependencies	3406-3
addition	some set $	sequential	dependencies	3406-3
dependencies	is	attribute	satisfied	3406-3
The question	arises	action	<B>	3406-4
The answer	on	constraint	our view	3407-1
The answer	depends	action	our view	3407-1
our view	of	constraint	the information	3407-1
the information	by	constraint	an incomplete database	3407-1
the information	provided	action	an incomplete database	3407-1
Dependencies	to	constraint	the information	3407-2
Dependencies	should add	action	the information	3407-2
the information		sequential	we	3407-2
we	have	action	<B>	3407-2
<B>	But	conjunctive	we	3407-3
we	how do compare	action	incomplete databases	3407-3
incomplete databases	with	constraint	respect	3407-3
respect	to	constraint	information content	3407-3
common sense		sequential	One approach	3407-4
One approach	in	constraint	line so far	3407-4
line so far	with	constraint	our discussion	3407-4
our discussion	that	constraint	more information	3407-4
our discussion	is	attribute	more information	3407-4
more information	means	action	the set	3407-4
more information	reducing further	action	the set	3407-4
the set	of	constraint	possible worlds	3407-4
an incomplete database		sequential	I	3407-5
I		sequential	a set	3407-5
a set	of	constraint	possible worlds	3407-5
possible worlds	than	constraint	J iff	3407-5
possible worlds	is	attribute	Thus more informative	3407-5
J iff		sequential	I	3407-5
I	⊂	action	J	3407-5
<B>	In	constraint	this spirit	3407-6
this spirit		sequential	the natural use	3407-6
the natural use	of	constraint	dependencies	3407-6
dependencies	to	constraint	I	3407-6
dependencies	from	constraint	I	3407-6
dependencies	be	attribute	I	3407-6
dependencies	would eliminate	action	I	3407-6
I		sequential	those possible worlds	3407-6
those possible worlds	$	sequential	<B>	3407-6
those possible worlds	not satisfying	action	<B>	3407-6
<B>	makes	action	sense	3407-7
sense	for	constraint	egd	3407-7
egd	in	constraint	particular fd	3407-7
egd	and	conjunctive	particular fd	3407-7
particular fd		sequential	s	3407-7
Incomplete Information I1 I2 I3 J1 J2 B C B C B C B C b c e f g c		sequential	C B	3408-1
C B		sequential	b c e f	3408-1
b c e f		sequential	b g	3408-1
b g		sequential	b′	3408-1
b′		sequential	c′ e	3408-1
c′ e		sequential	′	3408-1
′		sequential	f g′	3408-1
f g′		sequential	g b h b′ c′ e f	3408-1
g b h b′ c′ e f		sequential	′	3408-1
′		sequential	g′ e	3408-1
g′ e		sequential	f g′ b e f g e	3408-1
f g′ b e f g e		sequential	c′	3408-1
c′		sequential	′	3408-1
′		sequential	f g	3408-1
f g		sequential	b′ c e f	3408-1
b′ c e f		sequential	′	3408-1
′		sequential	g	3408-1
g		sequential	Figure	3408-1
Figure		sequential	19.6	3408-1
19.6		sequential	Incomplete databases	3408-1
Incomplete databases	and	conjunctive	dependencies	3408-1
dependencies	to	constraint	the instance	3408-1
dependencies	can be used	action	the instance	3408-1
dependencies	complete	action	the instance	3408-1
the instance	by	constraint	all missing tuples	3408-1
the instance	adding	action	all missing tuples	3408-1
all missing tuples	by	constraint	the tgd	3408-1
all missing tuples	implied	action	the tgd	3408-1
the tgd		sequential	s	3408-1
s	in	constraint	<B>	3408-1
s	$	sequential	<B>	3408-1
<B>	See	action	Exercise 19.18	3408-2
<B>	In	constraint	fact	3409-1
fact		sequential	the chase	3409-1
the chase	for	constraint	egd	3409-1
the chase	can be used	action	egd	3409-1
egd	and	conjunctive	tgd	3409-1
tgd		sequential	both s	3409-1
<B>	In	constraint	contrast	3409-2
contrast	to	constraint	tgd	3409-2
tgd		sequential	s	3409-2
s		sequential	the effect	3409-2
the effect	of	constraint	egd	3409-2
the effect	with	constraint	egd	3409-2
the effect	chasing	action	egd	3409-2
egd	in	constraint	fd s	3409-2
egd	and	conjunctive	fd s	3409-2
fd s	to	constraint	possible worlds	3409-2
fd s	be	attribute	possible worlds	3409-2
fd s	may eliminate	action	possible worlds	3409-2
possible worlds		sequential	that	3409-2
that	violate	action	them	3409-2
<B>	that	constraint	tuples	3409-3
<B>	Note	action	tuples	3409-3
tuples	by	constraint	tgd	3409-3
tuples	added	action	tgd	3409-3
tgd		sequential	s	3409-3
s	to	constraint	violations	3409-3
s	may lead	action	violations	3409-3
violations	of	constraint	egd	3409-3
egd		sequential	<B>	3409-3
<B>	that	constraint	an incomplete database	3409-4
<B>	suggests	action	an incomplete database	3409-4
an incomplete database		sequential	I	3409-4
I	with	constraint	a set	3409-4
a set	of	constraint	dependencies	3409-4
a set	$	sequential	dependencies	3409-4
dependencies	represents	action	<B>	3409-4
<B>	For	constraint	example	3410-1
example	consider	action	Fig	3410-1
19.6		sequential	which	3410-2
which	shows	action	the incomplete database	3410-2
the incomplete database		sequential	I	3410-2
I	=	sequential	I1	3410-2
I1		sequential	I2	3410-2
I2		sequential	I3	3410-2
I3		sequential	}	3410-2
<B>	Under	constraint	this perspective	3411-1
this perspective		sequential	the incorporation	3411-1
the incorporation	of	constraint	the dependencies $	3411-1
the dependencies $	=	sequential	A	3411-1
the dependencies $	{	sequential	A	3411-1
A	→	sequential	this incomplete database	3411-1
this incomplete database	to	constraint	J	3411-1
this incomplete database	leads	action	J	3411-1
J	=	sequential	J1 J2 }	3411-1
J	{	sequential	J1 J2 }	3411-1
<B>	that	constraint	the incomplete database	3412-1
<B>	Suppose now	action	the incomplete database	3412-1
the incomplete database		sequential	I	3412-1
I	as	constraint	a c- table T	3412-1
I	is represented	action	a c- table T	3412-1
the effect	of	constraint	full dependencies	3412-2
the effect	of	constraint	full dependencies	3412-2
the effect	a set $	sequential	full dependencies	3412-2
full dependencies	on	constraint	T	3412-2
T	by	constraint	another c- table T ′	3412-2
T	Can be represented	action	another c- table T ′	3412-2
The answer	and	conjunctive	T	3412-3
The answer	is	attribute	T	3412-3
T	by	constraint	the chase	3412-3
T	is obtained	action	the chase	3412-3
T	extending	action	the chase	3412-3
the chase	to	constraint	c-tables	3412-3
c-tables	in	constraint	the straightforward way	3412-3
<B>	For	constraint	example	3412-4
example		sequential	a table	3412-4
a table		sequential	T1	3412-4
T1	and	conjunctive	its completion T2	3412-4
its completion T2	by	constraint	A	3412-4
its completion T2	$	sequential	A	3412-4
its completion T2	=	sequential	A	3412-4
its completion T2	{	sequential	A	3412-4
A	in	constraint	Fig	3412-4
A	→	sequential	Fig	3412-4
19.7		sequential	19.7	3412-5
The reader	to	constraint	rep	3412-6
The reader	that chase $	sequential	rep	3412-6
The reader	might want	action	rep	3412-6
The reader	check	action	rep	3412-6
rep		sequential	T1	3412-6
T1	=	sequential	rep	3412-6
rep		sequential	T2	3412-6
T1 B C D T2 B C D b c d b c d x e y g x e y g b c b y g e		sequential	c	3413-1
c		sequential	d	3413-1
d		sequential	Figure	3413-1
Figure		sequential	19.7	3413-1
19.7		sequential	c-tables	3413-1
c-tables	and	conjunctive	dependencies	3413-1
dependencies		sequential	The Complexity Conditional tables	3413-1
The Complexity Conditional tables	of	constraint	Nulls	3413-1
Nulls	to	constraint	a minor variation	3413-1
Nulls	be	attribute	a minor variation	3413-1
Nulls	may appear	action	a minor variation	3413-1
a minor variation	from	constraint	the original model	3413-1
the original model	of	constraint	complete relational databases	3413-1
we	that	constraint	the use	3413-2
we	However see next	action	the use	3413-2
the use	of	constraint	nulls	3413-2
nulls	to	constraint	intractability	3413-2
nulls	easily leads	action	intractability	3413-2
<B>	painfully highlights	action	the trade off	3414-1
the trade off	between	constraint	modeling power	3414-1
modeling power	and	conjunctive	resources	3414-1
We	consider	action	some basic computational questions	3415-1
some basic computational questions	about	constraint	incomplete information databases	3415-1
the simplest question	is	attribute	Perhaps the possibility problem	3415-2
Perhaps the possibility problem	Given	action	a set	3415-2
a set	of	constraint	possible worlds	3415-2
possible worlds	for	constraint	instance	3415-2
possible worlds	specified	action	instance	3415-2
instance	by	constraint	a c- table	3415-2
a c- table	and	conjunctive	a set	3415-2
a set	of	constraint	tuples	3415-2
tuples	is	attribute	there	3415-2
there		sequential	a possible world	3415-2
a possible world		sequential	these tuples	3415-2
these tuples	are	attribute	where all true	3415-2
A second question	is	attribute	the certainty problem	3415-2
the certainty problem	Given	action	a set	3415-2
a set	of	constraint	possible worlds	3415-2
possible worlds	and	conjunctive	a set	3415-2
a set	of	constraint	tuples	3415-2
tuples	are	attribute	these tuples	3415-2
these tuples	in	constraint	every possible world	3415-2
<B>	Consider	action	c-	3416-1
c-		sequential	a table T	3416-1
a table T		sequential	a query q	3416-1
a query q		sequential	a relation I	3416-1
a relation I	and	conjunctive	a tuple	3416-1
a tuple		sequential	Some typical questions	3416-1
Some typical questions	include	attribute	the following	3416-1
we	Finally may consider	action	the following generalizations	3417-1
the following generalizations	of	constraint	the q-membership problem	3417-1
the q-membership problem		sequential	q Containment	3417-1
The crucial difference	between	constraint	information	3418-1
The crucial difference	and	conjunctive	information	3418-1
information	is	attribute	the large number	3418-1
the large number	of	constraint	possible valuations	3418-1
possible valuations	for	constraint	the latter case	3418-1
<B>	Because of	constraint	the finite number	3418-2
the finite number	of	constraint	variables	3418-2
variables	in	constraint	a set	3418-2
a set	of	constraint	c-tables	3418-2
c-tables		sequential	only a finite number	3418-2
only a finite number	of	constraint	valuations	3418-2
valuations	are	attribute	nonisomorphic	3418-2
valuations	see	action	Exercise 19.10	3418-2
the number	of	constraint	such valuations	3419-1
such valuations	in	constraint	the input size	3419-1
such valuations	However may grow exponentially	action	the input size	3419-1
<B>	By	constraint	simple reasoning	3419-2
simple reasoning	about	constraint	all valuations	3419-2
all valuations	by	constraint	particular valuations	3419-2
all valuations	and	conjunctive	particular valuations	3419-2
all valuations	guessing	action	particular valuations	3419-2
particular valuations		sequential	we	3419-2
we	have	action	some easy upper bounds	3419-2
<B>	For	constraint	a query q	3419-3
a query q		sequential	that	3419-3
that	in	constraint	polynomial time	3419-3
that	can be evaluated	action	polynomial time	3419-3
polynomial time	on	constraint	complete databases	3419-3
complete databases	whether	constraint	I	3419-3
complete databases	deciding	action	I	3419-3
I	∈	action	q	3419-3
q		sequential	rep	3419-3
rep		sequential	T	3419-3
T	whether	constraint	I	3419-3
T	or	conjunctive	I	3419-3
I	is	attribute	a set	3419-3
a set	of	constraint	possible answers	3419-3
possible answers	in	constraint	np	3419-3
possible answers	can be answered	action	np	3419-3
np	whether	constraint	q	3419-3
np	checking	action	q	3419-3
q		sequential	rep	3419-3
rep		sequential	T	3419-3
T	=	sequential	I	3419-3
I	if	constraint	I	3419-3
I	or	conjunctive	I	3419-3
I	}	action	I	3419-3
I	is	attribute	a set	3419-3
a set	of	constraint	certain tuples	3419-3
certain tuples	in	constraint	co-np	3419-3
certain tuples	is	attribute	co-np	3419-3
<B>	To	constraint	such complexity results	3420-1
<B>	illustrate	action	such complexity results	3420-1
such complexity results		sequential	we	3420-1
we	demonstrate	action	one lower bound	3420-1
one lower bound	concerning	action	the q-membership problem	3420-1
the q-membership problem	for	constraint	Codd	3420-1
Codd		sequential	tables	3420-1
Proposition		sequential	19.4.1	3421-1
Proof		sequential	Proof	3422-1
<B>	For	constraint	simplicity	3422-2
simplicity		sequential	we	3422-2
we	use	action	a query	3422-2
a query	mapping	action	two relation	3422-2
two relation		sequential	a database	3422-2
a database	into	constraint	two relation	3422-2
two relation		sequential	another database	3422-2
An easy modification	of	constraint	the proof	3422-3
the proof	that	constraint	the result	3422-3
the proof	shows	action	the result	3422-3
the result	for	constraint	databases	3422-3
the result	also holds	action	databases	3422-3
databases	with	constraint	one relation	3422-3
<B>	In	constraint	Incomplete Information	3422-4
Incomplete Information	increase	action	the arity	3422-4
the arity	of	constraint	the largest relation	3422-4
the largest relation	and	conjunctive	constants	3422-4
the largest relation	use	action	constants	3422-4
constants	in	constraint	the extra column	3422-4
the extra column	to	constraint	several relations	3422-4
the extra column	encode	action	several relations	3422-4
several relations	into	constraint	this one	3422-4
We	will use 1	action	an input schema R	3423-1
an input schema R	with	constraint	two relations	3423-1
two relations		sequential	R	3423-1
R		sequential	S	3423-1
S	of	constraint	arity 5	3423-1
arity 5	and	conjunctive	2	3423-1
2		sequential	2 an output schema	3423-1
The query q	on	constraint	each input	3423-2
The query q	returning	action	each input	3423-2
each input		sequential	I	3423-2
I	over	constraint	R	3423-2
R		sequential	two relations q1	3423-2
two relations q1		sequential	I	3423-2
I	and	conjunctive	q2	3423-2
q2		sequential	I	3423-2
I	over	constraint	R′	3423-2
R′	and	conjunctive	S′	3423-2
S′	as	constraint	q1	3423-2
S′	is defined	action	q1	3423-2
S′	follows	action	q1	3423-2
q1	=	sequential	x	3423-2
q1	{	sequential	x	3423-2
x		sequential	z	3423-2
z		sequential	z′	3423-2
z′		sequential	∃vw	3423-2
∃vw		sequential	R	3423-2
R		sequential	x	3423-2
x		sequential	y	3423-2
y		sequential	v	3423-2
v		sequential	w	3423-2
w		sequential	z	3423-2
z		sequential	∨	3423-2
∨		sequential	R	3423-2
R		sequential	v	3423-2
v		sequential	w	3423-2
w		sequential	x	3423-2
x		sequential	y	3423-2
y		sequential	z	3423-2
z		sequential	q2	3423-2
q2	=	sequential	z	3423-2
z		sequential	∃xyvw	3423-2
∃xyvw		sequential	R	3423-2
R		sequential	x	3423-2
x		sequential	y	3423-2
y		sequential	v	3423-2
v		sequential	w	3423-2
w		sequential	z	3423-2
z		sequential	∧ S	3423-2
∧ S		sequential	y	3423-2
y		sequential	w	3423-2
<B>	For	constraint	each input	3424-1
each input		sequential	G	3424-1
G	=	sequential	V	3424-1
V		sequential	E	3424-1
E	to	constraint	3 colorability	3424-1
3 colorability		sequential	the graph problem	3424-1
the graph problem		sequential	we	3424-1
we	construct	action	a table T	3424-1
a table T	over	constraint	the input schema R	3424-1
the input schema R	and	conjunctive	an instance	3424-1
<B>	Without	constraint	loss	3425-1
loss	of	constraint	generality	3425-1
generality	that	constraint	G	3425-1
generality	assume	action	G	3425-1
G	has	action	no self loops	3425-1
no self loops	that	constraint	E	3425-1
no self loops	and	conjunctive	E	3425-1
E	is	attribute	a binary relation	3425-1
a binary relation		sequential	we	3425-1
we	where list	action	each edge	3425-1
each edge	with	constraint	an arbitrary orientation	3425-1
<B>	Let	action	V	3426-1
V	=	sequential	ai	3426-1
ai		sequential	i	3426-1
i	∈	action	1	3426-1
1		sequential	n	3426-1
n		sequential	}	3426-1
}	and	conjunctive	E	3426-1
E	=	sequential	bj	3426-1
E	{	sequential	bj	3426-1
bj		sequential	cj	3426-1
cj		sequential	j ∈	3426-1
j ∈		sequential	1	3426-1
1		sequential	m	3426-1
<B>	Let	action	xj	3426-2
xj		sequential	j	3426-2
j		sequential	∈	3426-2
∈		sequential	1	3426-2
1		sequential	m	3426-2
m	and	conjunctive	<B>	3426-2
<B>	for	constraint	each tuple	3427-1
each tuple	in	constraint	I	3427-1
I		sequential	R	3427-1
R		sequential	the second column	3427-1
the second column	Intuitively contains	action	the color	3427-1
the color	of	constraint	the vertex	3427-1
the vertex	in	constraint	the first column	3427-1
the first column	and	conjunctive	the fourth column	3427-1
the fourth column	contains	action	the color	3427-1
the color	of	constraint	the vertex	3427-1
the vertex	in	constraint	the third column	3427-1
The edges	in	constraint	the fifth column	3428-1
The edges	are numbered	action	the fifth column	3428-1
The role	of	constraint	query q2	3428-2
query q2	to	constraint	an assignment	3428-2
query q2	whether	constraint	an assignment	3428-2
query q2	is	attribute	this	3428-2
query q2	check	attribute	this	3428-2
query q2	provides	action	an assignment	3428-2
an assignment	of	constraint	the three colors	3428-2
the three colors		sequential	1	3428-2
1		sequential	2	3428-2
2		sequential	3 }	3428-2
3 }	to	constraint	vertexes	3428-2
vertexes		sequential	the colors	3428-2
the colors	of	constraint	the endpoints	3428-2
the endpoints	of	constraint	each edge	3428-2
each edge	are	attribute	distinct	3428-2
<B>		sequential	q2	3428-3
q2	returns	action	the edges z	3428-3
the edges z	for	constraint	which	3428-3
which		sequential	the colors	3428-3
the colors		sequential	y	3428-3
y	w	constraint	its endpoints	3428-3
y	of	constraint	its endpoints	3428-3
its endpoints	among	constraint	{ 1	3428-3
its endpoints	are	attribute	{ 1	3428-3
{ 1		sequential	2	3428-3
2		sequential	3 }	3428-3
<B>	if	constraint	q	3428-4
q		sequential	I	3428-4
I		sequential	S′	3428-4
S′	=	sequential	I′	3428-4
I′		sequential	S′	3428-4
S′		sequential	all edges	3428-4
all edges	So have	action	color assignments	3428-4
color assignments	among	constraint	2	3428-4
color assignments	{ 1	sequential	2	3428-4
2	to	constraint	their endpoints	3428-4
2	3 }	sequential	their endpoints	3428-4
Next query q1	whether	constraint	a vertex	3428-5
Next query q1	checks	action	a vertex	3428-5
a vertex	is assigned consistently	action	the same color	3428-5
the same color	in	constraint	all edges	3428-5
all edges		sequential	it	3428-5
it	where occurs	action	<B>	3428-5
It	returns	action	the x	3428-6
the x		sequential	z	3428-6
z		sequential	x	3428-6
x	is	attribute	where a vertex	3428-6
where a vertex		sequential	z	3428-6
z	and	conjunctive	z′	3428-6
z′	are	attribute	edges	3428-6
edges		sequential	x	3428-6
x	as	constraint	an endpoint	3428-6
x	occurs	action	an endpoint	3428-6
an endpoint	and	conjunctive	x	3428-6
x	has	action	the same color assignment y	3428-6
the same color assignment y	in	constraint	both z	3428-6
both z	and	conjunctive	z′	3428-6
<B>	if	constraint	q1	3428-7
q1		sequential	I	3428-7
I		sequential	R′	3428-7
<B>	For	constraint	example	3429-1
example	consider	action	the graph G	3429-1
the graph G	in	constraint	Fig	3429-1
the graph G	given	action	Fig	3429-1
19.8		sequential	the corresponding I′	3429-2
the corresponding I′	and	conjunctive	T	3429-2
T	by	constraint	σ	3429-2
T	defined	action	σ	3429-2
σ		sequential	xj	3429-2
xj	=	sequential	f	3429-2
f		sequential	bj	3429-2
bj	and	conjunctive	σ	3429-2
σ		sequential	yj	3429-2
yj	=	sequential	f	3429-2
f		sequential	cj	3429-2
cj	for	constraint	all j	3429-2
It	that	constraint	I′	3429-3
It	is easily seen	action	I′	3429-3
I′	=	sequential	q	3429-3
q		sequential	σ	3429-3
σ		sequential	T	3429-3
it	to	constraint	G	3430-1
it	that	constraint	G	3430-1
it	is	attribute	Moreover straightforward	3430-1
it	show	action	G	3430-1
G	-	sequential	3 iff	3430-1
G	is	attribute	colorable	3430-1
Figure		sequential	19.8	3431-1
19.8		sequential	Graph G T	3431-1
Graph G T		sequential	R	3431-1
R		sequential	T	3431-1
T		sequential	S	3431-1
S		sequential	I′	3431-1
I′		sequential	R′	3431-1
R′		sequential	I′	3431-1
I′		sequential	S′	3431-1
S′		sequential	x1	3431-1
x1		sequential	y1 x2 y2 x3 y3	3431-1
y1 x2 y2 x3 y3		sequential	x4	3431-1
x4		sequential	y4 x5	3431-1
y4 x5		sequential	y5	3431-1
Figure		sequential	19.9	3432-1
19.9	for	constraint	the reduction	3432-1
19.9	Encoding	action	the reduction	3432-1
the reduction	of	constraint	3 colorability	3432-1
3 colorability		sequential	Other Approaches	3432-1
Other Approaches		sequential	Incomplete information	3432-1
Incomplete information	often arises naturally	action	the focus	3432-1
the focus	on	constraint	even when complete databases	3432-1
the focus	is	attribute	even when complete databases	3432-1
<B>	For	constraint	example	3432-2
example		sequential	the information	3432-2
the information	in	constraint	a view	3432-2
a view	by	constraint	nature	3432-2
a view	is	attribute	nature	3432-2
nature		sequential	which	3432-2
which	in	constraint	problems	3432-2
which	to	constraint	problems	3432-2
which	leads	action	problems	3432-2
problems	to	constraint	the view	3432-2
problems	when trying	action	the view	3432-2
problems	update	action	the view	3432-2
the view	as	constraint	Chapter 22	3432-2
the view	in	constraint	Chapter 22	3432-2
the view	discussed	action	Chapter 22	3432-2
Chapter 22	and	conjunctive	we	3432-2
we	already considered	action	relations	3432-2
relations	with	constraint	nulls	3432-2
nulls	in	constraint	the weak universal relations	3432-2
the weak universal relations	of	constraint	Chapter 11	3432-2
<B>	In	constraint	this section	3433-1
this section		sequential	we	3433-1
we	briefly present	action	some other aspects	3433-1
some other aspects	of	constraint	incomplete information	3433-1
We	consider	action	some alternative kinds	3433-2
some alternative kinds	of	constraint	null values	3433-2
null values		sequential	we	3433-2
we	at	constraint	disjunctive deductive databases	3433-2
we	look	action	disjunctive deductive databases	3433-2
disjunctive deductive databases		sequential	we	3433-2
we	mention	action	a language	3433-2
a language		sequential	that	3433-2
that	allows	action	us	3433-2
us	to	constraint	queries	3433-2
us	in	constraint	queries	3433-2
us	address directly	action	queries	3433-2
queries		sequential	the issue	3433-2
the issue	of	constraint	incompleteness	3433-2
incompleteness	and	conjunctive	we	3433-2
we	briefly mention	action	several situations	3433-2
several situations	in	constraint	which	3433-2
which		sequential	incomplete information	3433-2
incomplete information	arises naturally	action	the database itself	3433-2
the database itself	is	attribute	even when complete	3433-2
An additional approach	to	constraint	incomplete information	3433-3
An additional approach	representing	action	incomplete information	3433-3
incomplete information		sequential	which	3433-3
which	from	constraint	explicit logical theories	3433-3
which	stems	action	explicit logical theories	3433-3
which	using	action	explicit logical theories	3433-3
explicit logical theories	in	constraint	connection	3433-3
explicit logical theories	will be presented	action	connection	3433-3
connection	with	constraint	the view update problem	3433-3
the view update problem	in	constraint	Chapter 22	3433-3
Incomplete Information		sequential	Other Nulls	3434-1
Other Nulls	in	constraint	Brief	3434-1
Other forms	of	constraint	nulls	3435-1
nulls	may be considered	action	<B>	3435-1
We	for	constraint	instance	3435-2
We	may consider	action	instance	3435-2
instance		sequential	nonexisting nulls	3435-2
<B>	For	constraint	example	3436-1
example	in	constraint	the tuple	3436-1
the tuple	representing	action	a CEO	3436-1
a CEO		sequential	the field DirectManager	3436-1
the field DirectManager	has	action	no meaning	3436-1
no meaning	and	conjunctive	a nonexisting null	3436-1
no meaning	therefore contains	action	a nonexisting null	3436-1
Nonexisting nulls	at	constraint	the core	3436-2
Nonexisting nulls	are	attribute	the core	3436-2
the core	of	constraint	the weak universal model	3436-2
the weak universal model		sequential	that	3436-2
that		sequential	we	3436-2
we	in	constraint	Chapter 11	3436-2
we	considered	action	Chapter 11	3436-2
It	be	attribute	may also the case	3437-1
may also the case	that	constraint	we	3437-1
we	for	constraint	a specific field	3437-1
we	do not know	action	a specific field	3437-1
a specific field	if	constraint	a value	3437-1
a value	exists	action	<B>	3437-1
<B>	For	constraint	example	3437-2
example	if	constraint	the database	3437-2
the database	ignores	action	the marital status	3437-2
the marital status	of	constraint	a particular person	3437-2
a particular person		sequential	the spouse field	3437-2
the spouse field	either	conjunctive	<B>	3437-2
the spouse field	or	conjunctive	<B>	3437-2
the spouse field	is	attribute	unknown	3437-2
It	to	constraint	a formal treatment	3437-3
It	is	attribute	possible	3437-3
It	develop	action	a formal treatment	3437-3
a formal treatment	of	constraint	such no-information nulls	3437-3
An incomplete database	of	constraint	a set	3437-4
An incomplete database	consists	action	a set	3437-4
a set	of	constraint	sets	3437-4
sets	of	constraint	tuples	3437-4
tuples		sequential	each set	3437-4
each set	of	constraint	tuples	3437-4
tuples	under	constraint	projection	3437-4
tuples	where is closed	action	projection	3437-4
This closure	under	constraint	projection	3437-5
projection	that	constraint	a tuple	3437-5
projection	if	constraint	a tuple	3437-5
projection	indicates	action	a tuple	3437-5
a tuple	to	constraint	the projections	3437-5
a tuple	is known	attribute	true	3437-5
a tuple	be	attribute	true	3437-5
the projections	of	constraint	this tuple	3437-5
this tuple	although	constraint	<B>	3437-5
this tuple	to	constraint	<B>	3437-5
this tuple	are also known	attribute	true	3437-5
this tuple	be	attribute	true	3437-5
The reader	to	constraint	a nontrivial exercise	3437-6
The reader	as	constraint	a nontrivial exercise	3437-6
The reader	may want	action	a nontrivial exercise	3437-6
The reader	try	action	a nontrivial exercise	3437-6
a nontrivial exercise	to	constraint	tables	3437-6
a nontrivial exercise	define formally	action	tables	3437-6
tables	with	constraint	such nulls	3437-6
such nulls	and	conjunctive	a closure theorem	3437-6
such nulls	obtain	action	a closure theorem	3437-6
a closure theorem	to	constraint	Theorem 19.3.2	3437-6
<B>	For	constraint	each new form	3437-7
each new form	of	constraint	null values	3437-7
null values		sequential	the game	3437-7
the game	to	constraint	some form	3437-7
the game	is	attribute	some form	3437-7
the game	obtain	action	some form	3437-7
some form	of	constraint	representation	3437-7
representation	with	constraint	clear semantics	3437-7
clear semantics	to	constraint	a closure theorem	3437-7
clear semantics	and	conjunctive	a closure theorem	3437-7
clear semantics	try	action	a closure theorem	3437-7
clear semantics	obtain	action	a closure theorem	3437-7
a closure theorem	for	constraint	some reasonable language	3437-7
some reasonable language	like	constraint	we	3437-7
we	for	constraint	unknown nulls	3437-7
we	did	action	unknown nulls	3437-7
<B>	In	constraint	we	3437-8
we	on	constraint	the most important algebraic operations	3437-8
we	should focus	action	the most important algebraic operations	3437-8
the most important algebraic operations	for	constraint	data	3437-8
the most important algebraic operations	accessing	action	data	3437-8
data		sequential	projection	3437-8
projection	and	conjunctive	<B>	3437-8
projection	join	action	<B>	3437-8
It	to	constraint	a lattice structure	3437-9
It	is	attribute	also possible	3437-9
It	establish	action	a lattice structure	3437-9
a lattice structure	with	constraint	the different kinds	3437-9
the different kinds	of	constraint	nulls	3437-9
nulls	so that	constraint	they	3437-9
they	in	constraint	combination	3437-9
they	can be used meaningfully	action	combination	3437-9
Disjunctive Deductive Databases Disjunctive logic programming	is	attribute	an extension	3438-1
an extension	of	constraint	standard logic programming	3438-1
standard logic programming	with	constraint	rules	3438-1
rules	of	constraint	the form	3438-1
<B>	In	constraint	datalog	3439-1
datalog		sequential	the answer	3439-1
the answer	to	constraint	a query	3439-1
a query	is	attribute	a set	3439-1
a set	of	constraint	valuations	3439-1
<B>	For	constraint	instance	3439-2
instance		sequential	the answer	3439-2
the answer	to	constraint	a query	3439-2
Disjunctions	give	action	rise	3440-1
rise	to	constraint	new problems	3440-1
new problems	of	constraint	semantics	3440-1
semantics	for	constraint	logic programs	3440-1
<B>	Although	constraint	datalog	3440-2
<B>	in	constraint	datalog	3440-2
datalog		sequential	each program	3440-2
each program	has	action	a unique minimal model	3440-2
a unique minimal model	is	attribute	no longer the case	3440-2
no longer the case	for	constraint	datalog	3440-2
datalog	with	constraint	disjunctions	3440-2
<B>	For	constraint	instance	3440-3
instance	consider	action	the database	3440-3
the database	of	constraint	a single statement	3440-3
the database	consisting	action	a single statement	3440-3
Definition		sequential	19.5.1	3441-1
Then J		sequential	I	3441-2
I	iff	action	I	3441-2
I	∈	action	I	3441-2
I		sequential	∃ J ∈ J	3441-2
∃ J ∈ J		sequential	J	3441-2
J		sequential	⊆	3441-2
⊆		sequential	I	3441-2
<B>	Consider	action	the following immediate consequence operator	3442-1
<B>	Let	action	P	3442-2
P	be	attribute	a datalog program	3442-2
a datalog program	with	constraint	disjunctions	3442-2
disjunctions	and	conjunctive	I	3442-2
disjunctions	let	action	I	3442-2
I	be	attribute	a set	3442-2
a set	of	constraint	minimal interpretations	3442-2
A new set J	of	constraint	interpretations	3442-3
interpretations	as	constraint	<B>	3442-3
interpretations	is obtained	action	<B>	3442-3
interpretations	follows	action	<B>	3442-3
<B>	For	constraint	I	3442-4
I	in	constraint	I	3442-4
I		sequential	state P	3442-4
state P		sequential	I	3442-4
I	is	attribute	the set	3442-4
the set	of	constraint	disjunctions	3442-4
disjunctions	of	constraint	the form A1 ∨	3442-4
J	is	attribute	Then the set	3442-5
Then the set	of	constraint	instances J such	3442-5
Then the set	of	constraint	instances J such	3442-5
instances J such	that	constraint	I	3442-5
instances J such	for	constraint	I	3442-5
I	∈	action	I	3442-5
I		sequential	J	3442-5
J	is	attribute	a model	3442-5
a model	of	constraint	state P	3442-5
state P		sequential	I	3442-5
I	containing	action	I	3442-5
J	is	attribute	Clearly not a set	3442-6
Clearly not a set	of	constraint	minimal interpretations	3442-6
The immediate consequence I	of	constraint	denoted TP	3442-7
denoted TP		sequential	I	3442-7
I	is	attribute	the set	3442-7
the set	of	constraint	minimal interpretations	3442-7
minimal interpretations	in	constraint	J	3442-7
<B>	Now consider	action	the sequence I0	3442-8
the sequence I0	∅ Ii	sequential	TP	3442-8
the sequence I0	=	sequential	TP	3442-8
TP		sequential	Ii−1	3442-8
It	to	constraint	the sequence	3443-1
It	that	constraint	the sequence	3443-1
It	is	attribute	easy	3443-1
It	see	action	the sequence	3443-1
The semantics	of	constraint	P	3443-2
P	is	attribute	the limit	3443-2
the limit	of	constraint	the sequence	3443-2
negation	When is introduced	action	the situation	3444-1
the situation	as	constraint	<B>	3444-1
the situation	becomes	attribute	more complicated	3444-1
it	to	constraint	semantics	3444-2
it	is	attribute	However possible	3444-2
it	extend	action	semantics	3444-2
semantics	to	constraint	disjunctive deductive databases	3444-2
semantics	and	conjunctive	disjunctive deductive databases	3444-2
semantics	stratified	action	disjunctive deductive databases	3444-2
semantics	well founded	action	disjunctive deductive databases	3444-2
the major difficulty	in	constraint	disjunction	3445-1
the major difficulty	handling	action	disjunction	3445-1
disjunction	is	attribute	Overall the combinatorial explosion	3445-1
Overall the combinatorial explosion		sequential	it	3445-1
it	entails	action	<B>	3445-1
<B>	For	constraint	example	3445-2
example		sequential	the fixpoint semantics	3445-2
the fixpoint semantics	of	constraint	datalog	3445-2
datalog	with	constraint	disjunctions	3445-2
disjunctions	may yield	action	a set	3445-2
a set	of	constraint	interpretations	3445-2
interpretations	in	constraint	the input	3445-2
Logical Databases	and	conjunctive	KL	3446-1
One	can also use	attribute	proof theoretic	3446-2
a syntactic approach	to	constraint	incomplete information	3446-2
a syntactic approach	modeling	action	incomplete information	3446-2
<B>	by	constraint	the database	3446-3
<B>	is done	action	the database	3446-3
<B>	regarding	action	the database	3446-3
the database	as	constraint	a set	3446-3
a set	of	constraint	sentences	3446-3
sentences		sequential	which	3446-3
which	yields	action	the logical database approach	3446-3
<B>	in	constraint	the approaches	3447-1
<B>	both	conjunctive	the approaches	3447-1
<B>	and	conjunctive	the approaches	3447-1
<B>	Missing	attribute	semantic	3447-1
the approaches	is	attribute	the ability	3447-1
the ability	to	constraint	more refined statements	3447-1
the ability	make	action	more refined statements	3447-1
more refined statements	about	constraint	what	3447-1
what		sequential	the database	3447-1
the database	knows	action	<B>	3447-1
Such capabilities	in	constraint	applications	3447-2
Such capabilities	are	attribute	particularly important	3447-2
applications		sequential	the real world	3447-2
the real world	through	constraint	imprecise data	3447-2
the real world	where is slowly discovered	action	imprecise data	3447-2
<B>	In	constraint	such applications	3448-1
such applications		sequential	it	3448-1
it	to	constraint	a complete state	3448-1
it	for	constraint	a complete state	3448-1
it	is	attribute	general impossible	3448-1
it	wait	action	a complete state	3448-1
a complete state	to	constraint	queries	3448-1
a complete state	answer	action	queries	3448-1
queries	and	conjunctive	it	3448-1
it	to	constraint	the user	3448-1
it	is	attribute	often desirable	3448-1
it	provide	action	the user	3448-1
the user	with	constraint	information	3448-1
information	about	constraint	the current state	3448-1
the current state	of	constraint	knowledge	3448-1
knowledge	of	constraint	the database	3448-1
<B>	To	constraint	such limitations	3449-1
<B>	overcome	action	such limitations	3449-1
such limitations		sequential	we	3449-1
we	may use	action	languages	3449-1
languages	with	constraint	modalities	3449-1
We	briefly mention	action	one such language	3449-2
one such language		sequential	KL	3449-2
The language		sequential	KL	3449-3
KL	permits	action	us	3449-3
us	to	constraint	the real world	3449-3
us	between	constraint	the real world	3449-3
us	distinguish explicitly	action	the real world	3449-3
the real world	and	conjunctive	the knowledge	3449-3
the knowledge		sequential	the database	3449-3
the database	of	constraint	it	3449-3
the database	has	action	it	3449-3
It	uses Intuitively	action	the particular modal symbol	3449-4
the particular modal symbol		sequential	K.	3449-4
K.	whereas	constraint	the sentence	3449-4
the sentence	states	action	the truth	3449-4
the truth	of	constraint	the real world	3449-4
the truth	in	constraint	the real world	3449-4
the real world		sequential	Kϕ	3449-4
Kϕ	that	constraint	the database	3449-4
Kϕ	states	action	the database	3449-4
the database	that	constraint	<B>	3449-4
the database	knows	action	<B>	3449-4
the database	holds	action	<B>	3449-4
<B>	For	constraint	instance	3450-1
instance		sequential	the fact	3450-1
the fact	that	constraint	the database	3450-1
the database	that	constraint	Alice	3450-1
the database	neither	conjunctive	Alice	3450-1
the database	knows	action	Alice	3450-1
Alice	is	attribute	a student	3450-1
a student	that	constraint	Incomplete Information	3450-1
a student	nor	conjunctive	Incomplete Information	3450-1
Incomplete Information		sequential	she	3450-1
she	by	constraint	the statement	3450-1
she	is not is expressed	action	the statement	3450-1
The following KL statement	that	constraint	there	3451-1
The following KL statement	says	action	there	3451-1
there	is	attribute	a teacher	3451-1
a teacher		sequential	who	3451-1
who	is	attribute	unknown	3451-1
This language	allows	action	the database	3452-1
the database	to	constraint	queries	3452-1
the database	and	conjunctive	queries	3452-1
the database	reason	action	queries	3452-1
the database	answer	action	queries	3452-1
queries	about	constraint	its own knowledge	3452-1
its own knowledge	of	constraint	the world	3452-1
Incomplete Information Incomplete information	in	constraint	Complete Databases	3453-1
Complete Databases	often arises naturally	action	the focus	3453-1
the focus	on	constraint	even when complete databases	3453-1
the focus	is	attribute	even when complete databases	3453-1
<B>	are	attribute	several situations	3453-2
several situations		sequential	that	3453-2
that	naturally yield	action	incomplete information	3453-2
Bibliographic Notes		sequential	Bibliographic Notes	3454-1
<B>	of	constraint	the material	3455-1
the material	in	constraint	this chapter	3455-1
the material	presented	action	this chapter	3455-1
this chapter	from	constraint	IL84	3455-1
this chapter	is	attribute	IL84	3455-1
IL84	although	constraint	it	3455-1
it	was presented	action	the OWA	3455-1
it	assuming	action	the OWA	3455-1
the OWA	and	conjunctive	we	3455-1
we	refer	action	the reader	3455-1
the reader	to	constraint	it	3455-1
it	for	constraint	a detailed treatment	3455-1
Bibliographic Notes Tables	form	action	the central topic	3456-1
the central topic	of	constraint	the monograph	3456-1
the monograph		sequential	Gra91	3456-1
Examples	in	constraint	Section 19.1	3456-2
Section 19.1	from	constraint	<B>	3456-2
Section 19.1	are taken	action	<B>	3456-2
The naive tables	have been called	action	V tables	3456-3
V tables	and	conjunctive	e-tables	3456-3
e-tables	in	constraint	AG85	3456-3
AG85		sequential	Gra84	3456-3
Gra84		sequential	IL84	3456-3
The c-tables	with	constraint	local conditions	3456-4
local conditions	from	constraint	IL84	3456-4
local conditions	are	attribute	IL84	3456-4
IL84		sequential	they	3456-4
they	with	constraint	global conditions	3456-4
they	were augmented	action	global conditions	3456-4
global conditions	in	constraint	Gra84	3456-4
The fact	that	constraint	c-tables	3456-5
c-tables	provide	action	a strong representation system	3456-5
a strong representation system	for	constraint	relational algebra	3456-5
relational algebra	in	constraint	IL84	3456-5
relational algebra	is shown	action	IL84	3456-5
<B>	That	constraint	this strong representation property	3456-6
this strong representation property	to	constraint	query languages	3456-6
this strong representation property	extends	action	query languages	3456-6
query languages	with	constraint	fixpoint	3456-6
fixpoint	on	constraint	positive queries	3456-6
positive queries	in	constraint	Gra91	3456-6
positive queries	is reported	action	Gra91	3456-6
<B>	to	constraint	c-tables	3456-7
<B>	Chasing	action	c-tables	3456-7
<B>	is applied	action	c-tables	3456-7
c-tables	in	constraint	Gra91	3456-7
There	are	attribute	two main observations	3457-1
two main observations	in	constraint	the literature	3457-1
the literature	on	constraint	certainty semantics	3457-1
The first observation	from	constraint	the results	3457-2
The first observation	follows	action	the results	3457-2
the results	of	constraint	IL84	3457-2
IL84	on	constraint	c-tables	3457-2
IL84	based	action	c-tables	3457-2
c-tables	and	conjunctive	Rei86	3457-2
Rei86		sequential	Var86	3457-2
Var86		sequential	b	3457-2
data		sequential	complexity	3458-1
complexity		sequential	Comprehensive analysis	3458-1
Comprehensive analysis	of	constraint	problems	3458-1
problems	to	constraint	databases	3458-1
problems	and	conjunctive	databases	3458-1
problems	representing	action	databases	3458-1
problems	querying	action	databases	3458-1
databases	with	constraint	null values	3458-1
null values	in	constraint	IL84	3458-1
null values	is provided	action	IL84	3458-1
IL84		sequential	Var86	3458-1
Var86		sequential	b	3458-1
b		sequential	AKG91	3458-1
The program complexity	of	constraint	evaluation	3458-2
evaluation	by	constraint	the data complexity	3458-2
evaluation	than	constraint	the data complexity	3458-2
evaluation	is	attribute	higher	3458-2
the data complexity		sequential	Cos83	3458-2
Cos83		sequential	Var82a	3458-2
Such problems	in	constraint	HLY80	3458-3
Such problems	were first noted	action	HLY80	3458-3
HLY80		sequential	MSY81	3458-3
MSY81	as	constraint	part	3458-3
part	of	constraint	the study	3458-3
the study	of	constraint	nulls	3458-3
nulls	in	constraint	weak universal instances	3458-3
Early investigations	suggesting	action	the use	3459-1
the use	of	constraint	orderings	3459-1
orderings	in	constraint	the spirit	3459-1
the spirit	of	constraint	denotational semantics	3459-1
denotational semantics	for	constraint	incomplete information	3459-1
denotational semantics	capturing	action	incomplete information	3459-1
incomplete information	include	action	Vas79	3459-1
Vas79		sequential	Bis81	3459-1
The first paper	to	constraint	this approach	3459-2
The first paper	develop	action	this approach	3459-2
this approach	is	attribute	BJO91	3459-2
BJO91		sequential	which	3459-2
which	on	constraint	fd	3459-2
which	focused	action	fd	3459-2
fd	and	conjunctive	relations	3459-2
<B>	has spawned	action	several papers	3459-3
several papers	including	action	an extension	3459-3
an extension	to	constraint	complex objects	3459-3
complex objects	see	action	Chapter 20	3459-3
The logical database approach	by	constraint	the work	3460-1
The logical database approach	has been largely influenced	action	the work	3460-1
the work	of	constraint	Reiter	3460-1
<B>	or	conjunctive	21	3461-1
This approach	in	constraint	INV91a	3461-2
This approach	is introduced	action	INV91a	3461-2
INV91a		sequential	INV91b	3461-2
INV91b	in	constraint	the context	3461-2
the context	of	constraint	complex objects	3461-2
complex objects		sequential	subsequent works	3461-2
subsequent works	include	action	Rou91	3461-2
Rou91		sequential	LW93a	3461-2
One	in	constraint	Lev84 b	3462-1
One	will find	action	Lev84 b	3462-1
Lev84 b		sequential	Lev84a	3462-1
Lev84a		sequential	entry	3462-1
entry	to	constraint	the interesting world	3462-1
entry	points	action	the interesting world	3462-1
the interesting world	of	constraint	knowledge bases	3462-1
knowledge bases	from	constraint	the viewpoint	3462-1
the viewpoint	of	constraint	incompleteness	3462-1
incompleteness	of	constraint	information	3462-1
information	including	action	the language KL	3462-1
A related active area	of	constraint	research	3462-2
research	called	action	reasoning	3462-2
reasoning	about	constraint	knowledge	3462-2
knowledge	extends	action	modal operators	3462-2
modal operators	to	constraint	the knowledge	3462-2
modal operators	about	constraint	the knowledge	3462-2
modal operators	talk	action	the knowledge	3462-2
the knowledge	of	constraint	several agents	3462-2
several agents	about	constraint	facts	3462-2
facts	in	constraint	the world	3462-2
the world	about	constraint	knowledge	3462-2
the world	or	conjunctive	knowledge	3462-2
<B>	in	constraint	distributed databases	3462-3
<B>	be	attribute	may useful	3462-3
distributed databases		sequential	sites	3462-3
sites	where may have	action	different knowledge	3462-3
different knowledge	of	constraint	the world	3462-3
The semantics	of	constraint	such statements	3462-4
such statements	in	constraint	terms	3462-4
such statements	is	attribute	terms	3462-4
terms	of	constraint	an extension	3462-4
an extension	of	constraint	the possible worlds semantics	3462-4
the possible worlds semantics	on	constraint	Kripke structures	3462-4
the possible worlds semantics	based	action	Kripke structures	3462-4
An introduction	to	constraint	reasoning	3462-5
reasoning	about	constraint	knowledge	3462-5
knowledge	in	constraint	Hal93	3462-5
knowledge	can be found	action	Hal93	3462-5
Hal93		sequential	FHMV95	3462-5
<B>		sequential	nonapplicable nulls	3463-1
nonapplicable nulls	in	constraint	LL86	3463-1
nonapplicable nulls	are studied	action	LL86	3463-1
LL86		sequential	open nulls	3463-1
open nulls	in	constraint	GZ88	3463-1
open nulls	are studied	action	GZ88	3463-1
GZ88	and	conjunctive	weak instances	3463-1
weak instances	with	constraint	nonapplicable nulls	3463-1
nonapplicable nulls	in	constraint	AB87	3463-1
nonapplicable nulls	are studied	action	AB87	3463-1
AB87		sequential	b	3463-1
Incomplete Information Exercises Exercise 19.1	Consider	action	the c-table	3464-1
the c-table	in	constraint	Example 19.3.1	3464-1
<B>	Give	action	the c-tables	3464-2
the c-tables	for	constraint	the answers	3464-2
the answers	to	constraint	these queries	3464-2
these queries		sequential	Which students	3464-2
Which students	1 are taking	action	Math	3464-2
Which students	2 are not taking	action	Math	3464-3
Which students	3 are taking	action	Biology	3464-4
<B>	In	constraint	each case	3464-5
each case		sequential	what	3464-5
what	are	attribute	the sets	3464-5
the sets	of	constraint	tuples	3464-5
the sets	and	conjunctive	tuples	3464-5
tuples	of	constraint	the answer	3464-5
Exercise		sequential	19.2	3465-1
19.3		sequential	19.3	3465-2
<B>	that	constraint	I	3465-3
<B>	Show	attribute	each	3465-3
I	in	constraint	rep	3465-3
rep		sequential	T ′	3465-3
T ′	has	action	two tuples	3465-3
<B>	Is	action	T	3466-1
T	to	constraint	2 tuple	3466-1
T	′	sequential	2 tuple	3466-1
2 tuple		sequential	some c-table	3466-1
Exercise		sequential	19.3	3467-1
19.2		sequential	19.2	3467-2
<B>	In	constraint	the weak representation system	3467-3
the weak representation system	in	constraint	Section 19.1	3467-3
the weak representation system	described	action	Section 19.1	3467-3
Section 19.1	compute	action	the naive tables	3467-3
the naive tables	for	constraint	the answers	3467-3
the answers	to	constraint	the queries	3467-3
the queries		sequential	σ	3467-3
σ		sequential	A=C	3467-3
A=C		sequential	R	3467-3
R		sequential	π AB	3467-3
π AB		sequential	R	3467-3
R	⊲⊳	sequential	π AC	3467-3
π AC		sequential	R	3467-3
What surely	are	attribute	the tuples	3467-4
the tuples	in	constraint	the answers	3467-4
the answers	to	constraint	these queries	3467-4
Exercise		sequential	19.4	3468-1
<B>	Exercise	action	19.5	3469-1
19.5	Let	action	T	3469-1
T	be	attribute	the Codd table	3469-1
the Codd table	in	constraint	Fig	3469-1
19.1		sequential	19.1	3469-2
<B>	Compute	action	strong representations	3469-3
strong representations	of	constraint	the results	3469-3
the results	of	constraint	the following queries	3469-3
the following queries	using	action	c-tables	3469-3
c-tables		sequential	σ	3469-3
σ		sequential	A=3	3469-3
A=3		sequential	R	3469-3
R		sequential	q1	3469-3
q1	=	sequential	δ BC	3469-3
δ BC	→	sequential	AB	3469-3
AB		sequential	π	3469-3
π		sequential	BC	3469-3
BC		sequential	R	3469-3
R		sequential	c q1	3469-3
c q1		sequential	∪ π AB	3469-3
∪ π AB		sequential	R	3469-3
R		sequential	d	3469-3
d		sequential	q1 ∩	3469-3
q1 ∩		sequential	π AB	3469-3
π AB		sequential	R	3469-3
R		sequential	e q1	3469-3
e q1		sequential	π	3469-3
π		sequential	AB	3469-3
AB		sequential	R	3469-3
R		sequential	f q1	3469-3
f q1	⊲⊳	sequential	π BC	3469-3
π BC		sequential	R	3469-3
<B>	Exercise	action	19.6	3470-1
19.6	Consider	action	the c-table T4	3470-1
the c-table T4	=	sequential	T1 ∪ T2	3470-1
T1 ∪ T2	of	constraint	Fig	3470-1
19.4		sequential	19.4	3470-2
<B>	Compute	action	a strong representation	3470-3
a strong representation	of	constraint	the transitive closure	3470-3
the transitive closure	of	constraint	T4	3470-3
Exercise		sequential	19.7	3471-1
Exercise 19.8 Example 19.1.1	that	constraint	one	3472-1
Exercise 19.8 Example 19.1.1	shows	action	one	3472-1
one	can not strongly represent	action	the result	3472-1
the result	of	constraint	a selection	3472-1
a selection	on	constraint	a table	3472-1
a table	with	constraint	another table	3472-1
<B>	For	constraint	which operations	3472-2
which operations	of	constraint	relational algebra	3472-2
relational algebra	to	constraint	tables	3472-2
relational algebra	applied	action	tables	3472-2
tables	is	attribute	it	3472-2
it	to	constraint	the result	3472-2
it	strongly represent	action	the result	3472-2
Exercise		sequential	19.9	3473-1
Exercise		sequential	19.10	3474-1
<B>	Extend	action	the result	3474-2
the result	for	constraint	the case	3474-2
the case	with	constraint	constants	3474-2
Exercise		sequential	19.11	3475-1
Exercise 19.13 Prove Theorem 19.3.2		sequential	Exercise 19.13 Prove Theorem 19.3.2	3476-1
Exercise		sequential	19.14	3477-1
Hint		sequential	Hint	3477-2
Exercises Exercise 19.16		sequential	Exercises Exercise 19.16	3478-1
What	is	attribute	the complexity	3478-2
the complexity	of	constraint	your algorithms	3478-2
Exercise		sequential	19.17	3479-1
<B>	that	constraint	the sequence	3480-1
<B>	Show	action	the sequence	3480-1
the sequence		sequential	qi	3480-1
qi		sequential	T	3480-1
T	that	constraint	some i	3480-1
T	for	constraint	some i	3480-1
T	converges	action	some i	3480-1
some i		sequential	qi	3480-1
qi		sequential	T	3480-1
T		sequential	≡ qi+1	3480-1
≡ qi+1		sequential	T	3480-1
Hint		sequential	Hint	3480-2
Exercise		sequential	19.18	3481-1
<B>	If	constraint	an egd	3481-2
an egd	and	conjunctive	calls	3481-2
an egd	can be applied	action	calls	3481-2
calls	for	constraint	two distinct constants	3481-2
two distinct constants	to	constraint	the chase	3481-2
two distinct constants	be identified	action	the chase	3481-2
the chase	in	constraint	failure	3481-2
the chase	ends	action	failure	3481-2
<B>	that	constraint	instance	3481-3
<B>	for	constraint	instance	3481-3
<B>	Show	action	instance	3481-3
instance		sequential	I	3481-3
I	if	constraint	the chase	3481-3
the chase	of	constraint	I	3481-3
I	by	constraint	I	3481-3
I	succeeds	action	I	3481-3
I	chase	action	I	3481-3
Exercise		sequential	19.19	3482-1
What	about	constraint	the limit	3482-2
What	can be said	action	the limit	3482-2
the limit	in	constraint	model	3482-2
model		sequential	terms	3482-2
<B>		sequential	q	3483-1
q		sequential	I	3483-1
I	=	sequential	∩	3483-1
∩		sequential	J	3483-1
J		sequential	J ∈	3483-1
J ∈		sequential	q	3483-1
q		sequential	I	3483-1
I		sequential	poss	3483-1
poss		sequential	q	3483-1
q		sequential	I	3483-1
I	=	sequential	∪	3483-1
∪		sequential	J	3483-1
J		sequential	J ∈ q	3483-1
J ∈ q		sequential	I	3483-1
I	Consider	action	the language	3483-1
the language		sequential	FO	3483-1
<B>	Let	attribute	sure	3483-2
FO	+	sequential	W	3483-2
W	denote	action	all deterministic queries	3483-2
all deterministic queries		sequential	that	3483-2
that	as	constraint	q	3483-2
that	can be written	attribute	sure	3483-2
q	for	constraint	some FO	3483-2
<B>	that	constraint	a poss	3483-3
<B>	Prove	action	a poss	3483-3
a poss		sequential	FO	3483-3
FO	+	sequential	W	3483-3
W		sequential	=np	3483-3
=np	and	conjunctive	<B>	3483-3
Complex values		sequential	Complex values	3484-1
Riccardo		sequential	Riccardo	3485-1
<B>	.	sequential	<B>	3485-2
<B>	.	sequential	<B>	3485-3
Vittorio		sequential	Vittorio	3486-1
Sergio		sequential	Sergio	3487-1
<B>		sequential	<B>	3488-1
I	love	action	Matriochkas	3488-2
complex values	are	attribute	Intuitively relations	3489-1
Intuitively relations	in	constraint	which	3489-1
which		sequential	the entries	3489-1
the entries	to	constraint	the relational model	3489-1
the entries	as	constraint	the relational model	3489-1
the entries	in	constraint	the relational model	3489-1
the entries	are not required	attribute	atomic	3489-1
the entries	be	attribute	atomic	3489-1
the relational model	to	constraint	themselves relations	3489-1
the relational model	but	conjunctive	themselves relations	3489-1
the relational model	be	attribute	themselves relations	3489-1
the relational model	are allowed	action	themselves relations	3489-1
The data structure	in	constraint	the relational model	3489-2
the relational model		sequential	the relation	3489-2
the relation	as	constraint	the result	3489-2
the relation	can be viewed	action	the result	3489-2
the result	of	constraint	atomic values	3489-2
the result	to	constraint	atomic values	3489-2
the result	applying	action	atomic values	3489-2
atomic values		sequential	two constructors	3489-2
two constructors		sequential	a tuple constructor	3489-2
a tuple constructor	to	constraint	tuples	3489-2
a tuple constructor	make	action	tuples	3489-2
tuples	and	conjunctive	a set constructor	3489-2
a set constructor	to	constraint	sets	3489-2
a set constructor	make	action	sets	3489-2
sets	of	constraint	tuples	3489-2
tuples		sequential	relations	3489-2
Complex values	allow recursively	action	the application	3489-3
the application	of	constraint	tuple	3489-3
tuple	and	conjunctive	the constructor	3489-3
tuple	set	action	the constructor	3489-3
they	as	constraint	finite trees	3489-4
they	Thus can be viewed	action	finite trees	3489-4
finite trees		sequential	whose internal nodes	3489-4
whose internal nodes	indicate	action	the use	3489-4
the use	of	constraint	the tuple	3489-4
the tuple	and	conjunctive	finite set constructors	3489-4
a relation	is	attribute	Clearly a special kind	3489-5
Clearly a special kind	of	constraint	complex value	3489-5
complex value		sequential	a set	3489-5
a set	of	constraint	tuples	3489-5
tuples	of	constraint	atomic values	3489-5
Sort Complex Value dom Complex Values B C B C B C dom dom b e f E E E dom c d dom B C E c		sequential	b d E e	3490-1
b d E e		sequential	f	3490-1
f		sequential	Figure	3490-1
Figure		sequential	20.1	3490-1
20.1		sequential	Complex value	3490-1
We	that	constraint	it	3491-1
We	whereas	constraint	it	3491-1
We	will see	action	it	3491-1
it	to	constraint	the tuple constructor	3491-1
it	is	attribute	simple	3491-1
it	add	action	the tuple constructor	3491-1
the tuple constructor	to	constraint	the traditional relational data model	3491-1
the traditional relational data model		sequential	the set constructor	3491-1
the set constructor	requires	action	a number	3491-1
a number	of	constraint	interesting new ideas	3491-1
There	are	attribute	similarities	3491-2
similarities	between	constraint	this set construct	3491-2
this set construct	and	conjunctive	the set constructs	3491-2
the set constructs	in	constraint	general purpose	3491-2
the set constructs	used	action	general purpose	3491-2
general purpose		sequential	programming languages	3491-2
programming languages		sequential	Setl	3491-2
<B>	In	constraint	this chapter	3492-1
this chapter		sequential	we	3492-1
we	introduce	action	complex values	3492-1
complex values	and	conjunctive	a algebra	3492-1
complex values	present	attribute	many	3492-1
complex values	sorted	action	a algebra	3492-1
a algebra	and	conjunctive	an equivalent calculus	3492-1
an equivalent calculus	for	constraint	complex values	3492-1
The focus	on	constraint	the use	3492-2
The focus	is	attribute	the use	3492-2
the use	of	constraint	the two constructors	3492-2
the two constructors	of	constraint	complex values	3492-2
complex values	and	conjunctive	tuples sets	3492-2
Additional constructors Pleshette Hitchcock Perkins Psycho		sequential	list	3492-3
list		sequential	bags	3492-3
bags	and	conjunctive	Complex Values Director	3492-3
Complex Values Director		sequential	Movies Title Forsythe Gwenn	3492-3
Movies Title Forsythe Gwenn		sequential	The Trouble	3492-3
The Trouble	with	constraint	Harry MacLaine Hitchcock Hitchcock Hedren Taylor	3492-3
Harry MacLaine Hitchcock Hitchcock Hedren Taylor		sequential	The Birds	3492-3
The Birds		sequential	Leigh Hitchcock Title Sylwan Cries	3492-3
Leigh Hitchcock Title Sylwan Cries	and	conjunctive	Whispers Thulin Ullman Bergman von Sydow Björnstrand	3492-3
Whispers Thulin Ullman Bergman von Sydow Björnstrand		sequential	The Seventh Seal Ekerot Poppe Figure	3492-3
The Seventh Seal Ekerot Poppe Figure		sequential	20.2	3492-3
<B>	After	constraint	the algebra	3492-4
<B>	introducing	action	the algebra	3492-4
the algebra	and	conjunctive	calculus	3492-4
calculus		sequential	we	3492-4
we	present	action	examples	3492-4
examples	of	constraint	these interesting languages	3492-4
We	on	constraint	the issues	3492-5
We	comment	action	the issues	3492-5
the issues	of	constraint	expressive power	3492-5
expressive power	and	conjunctive	complexity	3492-5
complexity	and	conjunctive	equivalent languages	3492-5
complexity	describe	action	equivalent languages	3492-5
equivalent languages	with	constraint	fixpoint operators	3492-5
fixpoint operators		sequential	languages	3492-5
languages	in	constraint	the deductive paradigm	3492-5
we	Finally briefly examine	action	a subset	3492-6
a subset	of	constraint	the commercial query language O2SQL	3492-6
the commercial query language O2SQL		sequential	that	3492-6
that	provides	action	SQL style	3492-6
SQL style		sequential	an elegant syntax	3492-6
an elegant syntax	for	constraint	complex values	3492-6
an elegant syntax	querying	action	complex values	3492-6
The theory	in	constraint	this chapter	3493-1
The theory	described	action	this chapter	3493-1
this chapter	as	constraint	a starting point	3493-1
this chapter	serves	action	a starting point	3493-1
a starting point	for	constraint	object	3493-1
object	oriented	action	databases	3493-1
databases		sequential	which	3493-1
which	in	constraint	Chapter 21	3493-1
which	are considered	action	Chapter 21	3493-1
key features	of	constraint	the paradigm	3493-2
key features	object oriented	action	the paradigm	3493-2
the paradigm		sequential	objects	3493-2
objects	and	conjunctive	inheritance	3493-2
inheritance	in	constraint	the complex value framework	3493-2
inheritance	However are still missing	action	the complex value framework	3493-2
the complex value framework	for	constraint	Chapter 21	3493-2
the complex value framework	and	conjunctive	Chapter 21	3493-2
the complex value framework	are left	action	Chapter 21	3493-2
Complex Value Databases		sequential	Complex Value Databases	3494-1
The sorts	than	constraint	the relational model	3494-2
The sorts	for	constraint	the relational model	3494-2
The sorts	are	attribute	more complex	3494-2
Their abstract syntax	by	constraint	k	3494-3
Their abstract syntax	is given	action	k	3494-3
k		sequential	≥ 0	3494-3
≥ 0	and	conjunctive	B1	3494-3
<B>	.	sequential	<B>	3494-4
<B>	.	sequential	<B>	3494-5
Bk	are	attribute	distinct attributes	3494-6
an element	of	constraint	dom	3494-7
dom	is	attribute	Intuitively a constant	3494-7
Intuitively a constant		sequential	an element	3494-7
an element	of	constraint	B1	3494-7
B1	τ	sequential	1	3494-7
<B>	.	sequential	<B>	3494-8
<B>	.	sequential	<B>	3494-9
Bk		sequential	τk	3494-10
τk	is	attribute	k	3494-10
k		sequential	a tuple	3494-10
a tuple	with	constraint	an element	3494-10
an element	of	constraint	sort τi	3494-10
sort τi	in	constraint	entry Bi	3494-10
entry Bi	for	constraint	each i	3494-10
each i	and	conjunctive	an element	3494-10
an element	of	constraint	sort	3494-10
sort		sequential	τ	3494-10
τ		sequential	}	3494-10
}	is	attribute	a finite set	3494-10
a finite set	of	constraint	elements	3494-10
elements	of	constraint	sort τ	3494-10
the set	of	constraint	values	3495-1
values	of	constraint	sort τ	3495-1
sort τ		sequential	the interpretation	3495-1
the interpretation	of	constraint	τ	3495-1
τ	Formally denoted	action	τ	3495-1
τ	by	constraint	<B>	3495-1
τ	is defined	action	<B>	3495-1
Remark		sequential	20.1.1	3496-1
<B>	is	attribute	yet again the value	3496-2
yet again the value	of	constraint	Fig	3496-2
20.1		sequential	20.1	3496-3
It	to	constraint	dom	3496-4
It	is	attribute	customary	3496-4
It	omit	action	dom	3496-4
dom	for	constraint	instance	3496-4
dom	and	conjunctive	instance	3496-4
instance	write	action	this sort	3496-4
<B>	that	constraint	the empty set	3497-1
<B>	because of	constraint	the empty set	3497-1
<B>	Finally note	action	the empty set	3497-1
the empty set		sequential	a complex value	3497-1
a complex value	to	constraint	more than one sort	3497-1
a complex value	may belong	action	more than one sort	3497-1
<B>	For	constraint	instance	3497-2
instance		sequential	the value	3497-2
the value	of	constraint	Fig	3497-2
20.1	of	constraint	also sort	3497-3
20.1	is	attribute	also sort	3497-3
Relational algebra	with	constraint	sets	3498-1
Relational algebra	deals	action	sets	3498-1
sets	of	constraint	tuples	3498-1
complex value algebra	with	constraint	sets	3498-2
complex value algebra	Similarly deals	action	sets	3498-2
sets	of	constraint	complex values	3498-2
<B>	motivates	action	the following definition	3498-3
the following definition	of	constraint	sorted relation	3498-3
sorted relation		sequential	this Complex Values definition	3498-3
this Complex Values definition	is	attribute	frequently a source	3498-3
frequently a source	of	constraint	confusion	3498-3
We	use	action	the term relation	3499-1
the term relation	for	constraint	complex value relation	3499-1
we	When consider	action	the classical relational model	3499-2
the classical relational model		sequential	we	3499-2
we	sometimes use	action	the phrase flat relation	3499-2
the phrase flat relation	to	constraint	it	3499-2
the phrase flat relation	distinguish	action	it	3499-2
it	from	constraint	complex value relation	3499-2
It	that	constraint	the flat relations	3499-3
It	be	attribute	should clear	3499-3
the flat relations		sequential	that	3499-3
that		sequential	we	3499-3
we	are	attribute	special cases	3499-3
we	have studied	action	special cases	3499-3
special cases	of	constraint	complex value relations	3499-3
We	in	constraint	the sort	3500-1
We	be	attribute	must careful	3500-1
We	distinguishing	action	the sort	3500-1
the sort	of	constraint	a complex value relation	3500-1
a complex value relation	and	conjunctive	the sort	3500-1
the sort	of	constraint	the relation	3500-1
the relation	as	constraint	one complex value	3500-1
the relation	viewed	action	one complex value	3500-1
<B>	For	constraint	example	3500-2
example		sequential	a complex value relation	3500-2
a complex value relation	of	constraint	sort A	3500-2
sort A		sequential	B	3500-2
B		sequential	C	3500-2
C	is	attribute	a set	3500-2
a set	of	constraint	tuples	3500-2
tuples	over	constraint	attributes ABC	3500-2
<B>	At	constraint	the same time	3500-3
the same time		sequential	the entire relation	3500-3
the entire relation	as	constraint	one complex value	3500-3
the entire relation	can be viewed	action	one complex value	3500-3
one complex value	of	constraint	sort	3500-3
There	is	attribute	no contradiction	3500-4
no contradiction	between	constraint	these two ways	3500-4
these two ways	of	constraint	a relation	3500-4
these two ways	viewing	action	a relation	3500-4
We	that	constraint	the function sort	3501-1
We	now assume	action	the function sort	3501-1
the function sort	of	constraint	Chapter 3	3501-1
Chapter 3	from	constraint	relname	3501-1
Chapter 3	is	attribute	relname	3501-1
relname	to	constraint	the set	3501-1
the set	of	constraint	sorts	3501-1
We	that	constraint	each sort	3501-2
We	for	constraint	each sort	3501-2
We	also assume	action	each sort	3501-2
each sort		sequential	there	3501-2
there	is	attribute	an infinite number	3501-2
an infinite number	of	constraint	relations	3501-2
relations	having	action	that sort	3501-2
<B>	that	constraint	the sort	3502-1
<B>	Note	action	the sort	3502-1
the sort	of	constraint	a relation	3502-1
a relation	is	attribute	not necessarily a tuple sort	3502-1
not necessarily a tuple sort		sequential	it	3502-1
it	be	attribute	can a set sort	3502-1
relations	Thus do not always have	action	attributes	3502-2
attributes	at	constraint	the top level	3502-2
Such relations		sequential	whose sort	3502-3
whose sort	is	attribute	a set	3502-3
a set	are	attribute	essentially unary relations	3502-3
essentially unary relations	without	constraint	attribute names	3502-3
Example 20.1.2		sequential	Example 20.1.2	3503-1
20.3		sequential	20.3	3503-2
Variations		sequential	Variations	3504-1
The principal one		sequential	that	3505-1
that	is	attribute	the nested relation model	3505-1
that	has been considered	action	the nested relation model	3505-1
<B>	For	constraint	nested relations	3505-2
nested relations		sequential	set	3505-2
set	and	conjunctive	tuple	3505-2
tuple		sequential	constructors	3505-2
constructors	to	constraint	sets	3505-2
constructors	of	constraint	sets	3505-2
constructors	are required	action	sets	3505-2
constructors	alternate	action	sets	3505-2
constructors	set	action	sets	3505-2
sets	and	conjunctive	tuple	3505-2
tuple	with	constraint	a tuple component	3505-2
a tuple component	are prohibited	action	<B>	3505-2
<B>	For	constraint	instance	3505-3
instance		sequential	B B d	3505-3
B B d		sequential	1 d	3505-3
1 d		sequential	1 d	3505-3
1 d		sequential	2 d	3505-3
2 d		sequential	d	3505-3
d		sequential	3 d	3505-3
3 d		sequential	4 d	3505-3
4 d		sequential	1 d	3505-3
1 d		sequential	d	3505-3
d		sequential	d	3505-3
d		sequential	2 d	3505-3
2 d		sequential	5 d	3505-3
5 d		sequential	6 d	3505-3
6 d		sequential	d	3505-3
d		sequential	1 d	3505-3
1 d		sequential	2 d	3505-3
2 d		sequential	d	3505-3
d		sequential	d	3505-3
d		sequential	4 d	3505-3
4 d		sequential	1 d	3505-3
1 d		sequential	3 d	3505-3
3 d		sequential	3 d	3505-3
3 d		sequential	4 d	3505-3
4 d		sequential	2 d	3505-3
2 d		sequential	2 d	3505-3
2 d		sequential	4 d	3505-3
4 d		sequential	5 d	3505-3
5 d		sequential	6 d d	3505-3
6 d d		sequential	3 d	3505-3
3 d		sequential	4 d d d	3505-3
4 d d d		sequential	6 d	3505-3
6 d		sequential	1 d	3505-3
1 d		sequential	3 d	3505-3
3 d		sequential	2 d	3505-3
2 d		sequential	4 d	3505-3
4 d		sequential	2 d	3505-3
2 d		sequential	1 d 2 d	3505-3
1 d 2 d		sequential	3 d	3505-3
3 d		sequential	4 J	3505-3
4 J		sequential	R	3505-3
R		sequential	1	3505-3
1		sequential	J	3505-3
J		sequential	R	3505-3
R		sequential	2	3505-3
2		sequential	J	3505-3
J		sequential	R	3505-3
R		sequential	3	3505-3
3		sequential	Figure	3505-3
Figure		sequential	20.3	3505-3
The restriction	on	constraint	the structure	3506-1
The restriction	imposed	action	the structure	3506-1
the structure	of	constraint	nested relations	3506-1
nested relations	is	attribute	mostly cosmetic	3506-1
A more fundamental constraint	in	constraint	Verso- relations	3506-2
A more fundamental constraint	is imposed	action	Verso- relations	3506-2
A more fundamental constraint	so called	action	Verso- relations	3506-2
Verso- relations		sequential	V- relations	3506-2
which	is	attribute	also essentially a set	3507-1
also essentially a set	of	constraint	sets	3507-1
The V-relations	are	attribute	therefore much more limited data structures	3507-2
<B>	See	action	Exercise 20.1	3507-3
They	as	constraint	flat relational instances	3507-4
They	can be viewed essentially	action	flat relational instances	3507-4
Complex Values The Algebra		sequential	Complex Values The Algebra	3508-1
<B>	Like	constraint	relational algebra	3508-2
relational algebra		sequential	ALG cv	3508-2
ALG cv	is	attribute	a functional language	3508-2
a functional language	on	constraint	a small set	3508-2
a functional language	based	action	a small set	3508-2
a small set	of	constraint	operations	3508-2
This section	first presents	action	a family	3508-3
a family	of	constraint	core operators	3508-3
core operators	of	constraint	the algebra	3508-3
the algebra	and	conjunctive	an extended family	3508-3
an extended family	of	constraint	operators	3508-3
operators		sequential	that	3508-3
that	by	constraint	them	3508-3
that	can be simulated	action	them	3508-3
<B>	At	constraint	the end	3508-4
the end	of	constraint	the section	3508-4
the section		sequential	we	3508-4
we	introduce	action	an important subset	3508-4
an important subset	of	constraint	ALG cv	3508-4
ALG cv		sequential	denoted ALG cv−	3508-4
The Core Let I	of	constraint	ALG cv	3509-1
ALG cv		sequential	I1	3509-1
I1		sequential	I2	3509-1
<B>	.	sequential	<B>	3509-2
<B>	.	sequential	<B>	3509-3
<B>	be	attribute	relations	3509-4
relations	of	constraint	sort τ	3509-4
sort τ	τ	sequential	1	3509-4
1	τ	sequential	2	3509-4
<B>	.	sequential	<B>	3509-5
<B>	.	sequential	<B>	3509-6
<B>		sequential	<B>	3509-7
It	to	constraint	mind	3509-8
It	in	constraint	mind	3509-8
It	is	attribute	important	3509-8
It	keep	action	mind	3509-8
mind	that	constraint	a relation τ	3509-8
a relation τ	of	constraint	sort	3509-8
sort	is	attribute	a set	3509-8
a set	of	constraint	values	3509-8
values	of	constraint	sort τ	3509-8
Basic set operations	If	constraint	τ1	3510-1
τ1	=	sequential	τ	3510-1
τ		sequential	2	3510-1
2		sequential	I1 ∩	3510-1
I1 ∩		sequential	I2	3510-1
I2		sequential	I1 ∪ I2	3510-1
I1 ∪ I2		sequential	I1	3510-1
I1	−	sequential	I2	3510-1
I2	are	attribute	relations	3510-1
relations	of	constraint	sort τ1	3510-1
sort τ1	and	conjunctive	their values	3510-1
their values	in	constraint	the obvious manner	3510-1
their values	are defined	action	the obvious manner	3510-1
Tuple operations		sequential	Tuple operations	3511-1
<B>	.	sequential	<B>	3511-2
<B>	.	sequential	<B>	3511-3
Bk		sequential	<B>	3511-4
The selection condition		sequential	γ	3512-1
γ	with	constraint	obvious restrictions	3512-1
γ	is	attribute	obvious restrictions	3512-1
obvious restrictions	on	constraint	sorts	3512-1
sorts	of	constraint	the form	3512-1
the form		sequential	Bi	3512-1
Bi		sequential	d	3512-1
d		sequential	Bi	3512-1
Bi	=	sequential	Bj	3512-1
Bj		sequential	Bi ∈ Bj	3512-1
Bi ∈ Bj	or	conjunctive	Bi	3512-1
Bi	=	sequential	Bj .C	3512-1
Bj .C		sequential	d	3512-1
d	and	conjunctive	it	3512-1
d	is	attribute	where a constant	3512-1
it	in	constraint	the last case	3512-1
it	is required	action	the last case	3512-1
the last case		sequential	that	3512-1
that	be	attribute	τj a tuple sort	3512-1
τj a tuple sort	with	constraint	a C field	3512-1
<B>	by	constraint	<B>	3512-2
<B>	Then where is defined	action	<B>	3512-2
Constructive operations powerset		sequential	I	3513-1
I	=	sequential	v	3513-1
v		sequential	v ⊆	3513-1
v ⊆		sequential	I	3513-1
I	}	action	<B>	3513-1
tup	create	action	A	3514-1
Destructive operations		sequential	Destructive operations	3515-1
We	to	constraint	core the	3516-1
We	are now prepared	action	core the	3516-1
We	define	action	core the	3516-1
core the	of	constraint	the language	3516-1
the language		sequential	ALG cv	3516-1
<B>	Let	action	R	3516-2
R	be	attribute	a database schema	3516-2
A query	returns	action	a set	3516-3
a set	of	constraint	values	3516-3
values	of	constraint	the same sort	3516-3
<B>	By	constraint	analogy	3516-4
analogy	with	constraint	relations	3516-4
relations		sequential	a query τ	3516-4
a query τ	of	constraint	sort	3516-4
sort	returns	action	a set	3516-4
a set	of	constraint	values	3516-4
values	of	constraint	sort τ	3516-4
ALG cv	and	conjunctive	their answers	3516-5
ALG cv	queries	action	their answers	3516-5
their answers	as	constraint	<B>	3516-5
their answers	are defined	action	<B>	3516-5
their answers	follows	action	<B>	3516-5
There	are	attribute	two base cases	3516-6
The answer	to	constraint	query R	3516-7
query R	is	attribute	I	3516-7
I		sequential	R	3516-7
Constant values		sequential	Constant values	3517-1
The answer	to	constraint	query	3517-2
query		sequential	a }	3517-2
a }	is	attribute	simply a }	3517-2
Other queries	of	constraint	ALG cv	3518-1
ALG cv	as	constraint	<B>	3518-1
ALG cv	are obtained	action	<B>	3518-1
ALG cv	follows	action	<B>	3518-1
<B>	If	constraint	q1	3518-2
q1		sequential	q2	3518-2
<B>	.	sequential	<B>	3518-3
<B>	.	sequential	<B>	3518-4
<B>	are	attribute	queries	3518-5
queries	γ	sequential	a selection condition	3518-5
queries	is	attribute	a selection condition	3518-5
a selection condition	and	conjunctive	A1	3518-5
<B>	.	sequential	<B>	3518-6
<B>	.	sequential	<B>	3518-7
<B>	are	attribute	attributes	3518-8
attributes		sequential	q1	3518-8
q1		sequential	∩	3518-8
∩		sequential	q2	3518-8
q2		sequential	q1	3518-8
q1		sequential	∪	3518-8
∪		sequential	q2	3518-8
q2		sequential	q1	3518-8
q1		sequential	q2	3518-8
q2		sequential	tup	3518-8
tup	_	sequential	A1	3518-8
tup	create	action	A1	3518-8
A1		sequential	Ak	3518-8
Ak		sequential	1	3518-8
<B>	.	sequential	<B>	3518-9
<B>	.	sequential	<B>	3518-10
qk		sequential	powerset	3518-11
powerset		sequential	q1	3518-11
q1		sequential	tup	3518-11
tup	_	sequential	q1	3518-11
tup	destroy	action	q1	3518-11
q1		sequential	set	3518-11
set	destroy	action	q1	3518-11
q1		sequential	set	3518-11
set	create	action	q1	3518-11
<B>	To	constraint	these definitions	3519-1
<B>	illustrate	action	these definitions	3519-1
these definitions		sequential	we	3519-1
we	present	action	two examples	3519-1
We	consider	action	other algebraic operators	3519-2
other algebraic operators		sequential	that	3519-2
that	in	constraint	the algebra	3519-2
that	are	attribute	expressible	3519-2
<B>	In	constraint	Section 20.4	3519-3
Section 20.4		sequential	we	3519-3
we	provide	action	several more examples	3519-3
several more examples	of	constraint	algebraic queries	3519-3
Example		sequential	20.2.1	3520-1
20.3		sequential	20.3	3520-2
one	in	constraint	Fig	3520-3
one	Then can find	action	Fig	3520-3
20.4 J1	=	sequential	σ A=d R J2	3520-4
σ A=d R J2	=	sequential	π	3520-4
π		sequential	B	3520-4
B		sequential	J1	3520-4
J1		sequential	J3	3520-4
J3	=	sequential	tup	3520-4
tup	_	sequential	J2	3520-4
tup	destroy	action	J2	3520-4
J2		sequential	J4	3520-4
J4	=	sequential	set	3520-4
set	_	sequential	J3	3520-4
set	destroy	action	J3	3520-4
J3		sequential	J5	3520-4
J5	=	sequential	powerset	3520-4
powerset		sequential	J4	3520-4
J4		sequential	J6	3520-4
J6	=	sequential	tup	3520-4
tup	_	sequential	C	3520-4
tup	create	action	C	3520-4
C		sequential	J4	3520-4
J5	=	sequential	powerset	3521-1
powerset		sequential	set	3521-1
set	_	sequential	tup	3521-1
set	destroy	action	tup	3521-1
tup	destroy	action	πB	3521-1
πB		sequential	σ A=d	3521-1
σ A=d		sequential	R	3521-1
Complex Values B B d		sequential	d	3522-1
d		sequential	3 d	3522-1
3 d		sequential	d	3522-1
d		sequential	d	3522-1
d		sequential	4 d	3522-1
4 d		sequential	1 d	3522-1
1 d		sequential	3 d	3522-1
3 d		sequential	1 d	3522-1
1 d		sequential	3 d	3522-1
3 d		sequential	2 d	3522-1
2 d		sequential	4 d	3522-1
4 d		sequential	2 d	3522-1
2 d		sequential	4 J	3522-1
4 J		sequential	1 J	3522-1
1 J		sequential	2 J	3522-1
2 J		sequential	3 C	3522-1
3 C		sequential	d	3522-1
d		sequential	1 d	3522-1
1 d		sequential	3 d	3522-1
3 d		sequential	2 d	3522-1
2 d		sequential	4 d	3522-1
4 d		sequential	1 d	3522-1
1 d		sequential	3 d 3 C	3522-1
3 d 3 C		sequential	1 d	3522-1
1 d		sequential	d d d	3522-1
d d d		sequential	4 d	3522-1
4 d		sequential	4 d	3522-1
4 d		sequential	1 d	3522-1
1 d		sequential	3 d	3522-1
3 d		sequential	2 d	3522-1
2 d		sequential	4 J 4 J 5 J 6	3522-1
4 J 4 J 5 J 6		sequential	Figure	3522-1
Figure		sequential	20.4	3522-1
20.4		sequential	Example 20.2.2	3522-1
<B>	Consider	action	the relation	3522-2
the relation		sequential	I	3522-2
I	=	sequential	A	3522-2
I	{	sequential	A	3522-2
A		sequential	B	3522-2
B		sequential	b	3522-2
b		sequential	c	3522-2
c		sequential	}	3522-2
}		sequential	C	3522-2
C		sequential	d	3522-2
d		sequential	B	3522-2
B		sequential	e	3522-2
e		sequential	f	3522-2
f		sequential	}	3522-2
<B>		sequential	<B>	3523-1
We	next reconstruct	action	I	3524-1
I	from	constraint	singleton sets	3524-1
There	are	attribute	infinite possibilities	3525-1
infinite possibilities	in	constraint	the choice	3525-1
the choice	of	constraint	algebraic operations	3525-1
algebraic operations	for	constraint	complex values	3525-1
We	to	constraint	the core algebra	3526-1
We	in	constraint	the core algebra	3526-1
We	chose	action	the core algebra	3526-1
We	incorporate	action	the core algebra	3526-1
the core algebra		sequential	only a few basic operations	3526-1
only a few basic operations	to	constraint	the formal presentation	3526-1
only a few basic operations	simplify	action	the formal presentation	3526-1
the formal presentation	and	conjunctive	the proof	3526-1
the proof	of	constraint	the equivalence	3526-1
the equivalence	between	constraint	the algebra	3526-1
the algebra	and	conjunctive	calculus	3526-1
<B>	making	action	the core	3527-1
the core	too reduced	action	that proof	3527-1
the core	However would complicate	action	that proof	3527-1
<B>	For	constraint	example	3527-2
example		sequential	the operator set	3527-2
the operator set	_	sequential	the other operations	3527-2
the operator set	create	action	the other operations	3527-2
the operator set	can be expressed	action	the other operations	3527-2
the operator set	using	action	the other operations	3527-2
the other operations	in	constraint	the proof	3527-2
the other operations	but	conjunctive	the proof	3527-2
the other operations	is	attribute	convenient	3527-2
We	now present	action	several additional algebraic operations	3527-3
It	to	constraint	all these operations	3527-4
It	that	constraint	all these operations	3527-4
It	is	attribute	important	3527-4
It	note	action	all these operations	3527-4
all these operations	in	constraint	complex value algebra	3527-4
all these operations	can be expressed	action	complex value algebra	3527-4
<B>	In	constraint	that sense	3527-5
that sense		sequential	they	3527-5
they	as	constraint	macro operations	3527-5
they	can be viewed	action	macro operations	3527-5
<B>	but	conjunctive	the nest operator	3527-6
the nest operator	without	constraint	the powerset operator	3527-6
the nest operator	Furthermore can be expressed	action	the powerset operator	3527-6
the nest operator	using	action	the powerset operator	3527-6
We	first generalize	action	constant queries	3528-1
Complex constants		sequential	Complex constants	3529-1
<B>		sequential	a }	3529-2
a }	for	constraint	a atomic	3529-2
a atomic		sequential	we	3529-2
we	as	constraint	constant queries	3529-2
we	So use	action	constant queries	3529-2
constant queries		sequential	arbitrary complex value sets	3529-2
We	also generalize	action	relational operations	3530-1
<B>	Renaming	action	Renaming	3531-1
Renaming	can be computed	action	the other operations	3531-1
Renaming	using	action	the other operations	3531-1
the other operations	as	constraint	Section 20.4	3531-1
the other operations	in	constraint	Section 20.4	3531-1
the other operations	illustrated	action	Section 20.4	3531-1
Section 20.4		sequential	which	3531-1
which	presents	action	examples	3531-1
examples	of	constraint	queries	3531-1
Cross-product	For	constraint	i	3532-1
i	in	constraint	1,2	3532-1
1,2	let	action	<B>	3532-1
ji ji		sequential	ji ji	3533-1
j j1		sequential	j2	3534-1
j2		sequential	j2	3534-1
j2		sequential	I1	3534-1
I1	×	constraint	I2	3534-1
I2	=	sequential	B1 j x1	3534-1
I2	{	sequential	B1 j x1	3534-1
B1 j x1		sequential	B2 x2 j1 j2	3534-1
B2 x2 j1 j2		sequential	j2 Bi	3534-1
j2 Bi		sequential	I	3534-1
I		sequential	j i	3534-1
j i	for	constraint	i ∈	3534-1
i ∈		sequential	1	3534-1
1		sequential	2	3534-1
2		sequential	}	3534-1
i	ji	action	It	3535-1
It	to	constraint	cross-product	3535-1
It	is	attribute	easy	3535-1
It	simulate	action	cross-product	3535-1
cross-product	using	action	the operations	3535-1
the operations	of	constraint	the algebra	3535-1
<B>	in	constraint	Section 20.4	3535-2
<B>	is also illustrated	action	Section 20.4	3535-2
<B>	Join	action	<B>	3536-1
It	that	constraint	complex value algebra	3537-1
It	be	attribute	should now clear	3537-1
complex value algebra	subsumes	action	relational algebra	3537-1
relational algebra	to	constraint	flat relations	3537-1
relational algebra	when applied	action	flat relations	3537-1
We	also have	action	new operations	3537-2
We	set oriented	action	new operations	3537-2
Complex Values		sequential	N-ary set	3538-1
N-ary set	create	action	<B>	3538-1
We	also allow	action	n- ary set	3538-2
n- ary set	with	constraint	the meaning	3538-2
n- ary set	create	action	the meaning	3538-2
the meaning		sequential	that	3538-2
that		sequential	set	3538-2
set	create	action	I1	3538-2
<B>	.	sequential	<B>	3538-3
<B>	.	sequential	<B>	3538-4
<B>	In	constraint	set	3538-5
set	create	action	I1	3538-5
I1		sequential	∪	3538-5
∪		sequential	∪ set	3538-5
∪ set	create	action	<B>	3538-5
Singleton		sequential	Singleton	3539-1
<B>	.	sequential	<B>	3539-2
<B>	.	sequential	<B>	3539-3
an }	into	constraint	a set	3539-4
a set		sequential	a 1 }	3539-4
<B>	.	sequential	<B>	3539-5
<B>	.	sequential	<B>	3539-6
an }		sequential	}	3539-7
}	of	constraint	singletons	3539-7
Nest		sequential	<B>	3540-1
<B>	For	constraint	example	3541-1
example	for	constraint	J	3541-1
J	of	constraint	Fig	3541-1
we	20.3 have	action	unnest B	3541-2
unnest B		sequential	J	3541-2
J		sequential	R1	3541-2
R1	=	sequential	J	3541-2
J		sequential	R2	3541-2
R2		sequential	nest B=	3541-2
nest B=		sequential	A1A2	3541-2
A1A2		sequential	J	3541-2
J		sequential	R2	3541-2
R2	=	sequential	J	3541-2
J		sequential	R3	3541-2
<B>	that	constraint	we	3542-1
<B>	suppose	action	we	3542-1
we	have	action	R	3542-1
R	and	conjunctive	S	3542-1
S	with	constraint	sorts sort	3542-1
sorts sort		sequential	R	3542-1
R	=	sequential	A1	3542-1
A1	τ	sequential	1	3542-1
<B>	.	sequential	<B>	3542-2
<B>	.	sequential	<B>	3542-3
Ak		sequential	B	3542-4
B		sequential	Ak+1	3542-4
Ak+1		sequential	k+1	3542-4
<B>	.	sequential	<B>	3542-5
<B>	.	sequential	<B>	3542-6
<B>		sequential	τn	3542-7
τn		sequential	} sort	3542-7
} sort		sequential	S	3542-7
S	=	sequential	A1	3542-7
A1	τ	sequential	1	3542-7
<B>	.	sequential	<B>	3542-8
<B>	.	sequential	<B>	3542-9
Ak		sequential	Ak+1	3542-10
Ak+1		sequential	k+1	3542-10
<B>	.	sequential	<B>	3542-11
<B>	.	sequential	<B>	3542-12
<B>		sequential	<B>	3542-13
<B>	for	constraint	instances	3543-1
instances		sequential	I	3543-1
I	of	constraint	R	3543-1
R	and	conjunctive	J	3543-1
J	of	constraint	S	3543-1
S		sequential	we	3543-1
we	Then have	action	unnest B	3543-1
unnest B		sequential	I	3543-1
I	=	sequential	A1	3543-1
A1		sequential	x1	3543-1
<B>	.	sequential	<B>	3543-2
<B>	.	sequential	<B>	3543-3
<B>		sequential	xn	3543-4
xn		sequential	∃y nest B=	3543-4
∃y nest B=		sequential	Ak+1	3543-4
Ak+1		sequential	An	3543-4
An		sequential	J	3543-4
J	=	sequential	A1	3543-4
A1		sequential	x1	3543-4
<B>	.	sequential	<B>	3543-5
<B>	.	sequential	<B>	3543-6
Ak xk y		sequential	B	3543-7
<B>	that	constraint	unnest B	3544-1
<B>	Observe	action	unnest B	3544-1
unnest B		sequential	nest B=	3544-1
nest B=		sequential	A1A2	3544-1
A1A2		sequential	J	3544-1
J		sequential	R2	3544-1
R2	=	sequential	J	3544-1
J		sequential	R2	3544-1
nest B=		sequential	A1A2	3545-1
A1A2		sequential	unnest B	3545-1
unnest B		sequential	J	3545-1
J		sequential	R1	3545-1
R1	=	sequential	J	3545-1
J		sequential	R1	3545-1
<B>	is	attribute	indeed not an isolated phenomenon	3546-1
Unnest	in	constraint	the right inverse	3546-2
Unnest	is	attribute	general	3546-2
the right inverse	of	constraint	nest	3546-2
nest		sequential	nest	3546-2
nest		sequential	B=α	3546-2
B=α	◦	sequential	unnest B	3546-2
unnest B	is	attribute	the identity	3546-2
the identity	whereas	constraint	unnest	3546-2
unnest	in	constraint	not information	3546-2
unnest	is	attribute	general	3546-2
not information	preserving	action	one	3546-2
one	to	constraint	one	3546-2
one	and	conjunctive	no right inverse	3546-2
one	so has	action	no right inverse	3546-2
no right inverse	see	action	Exercise 20.8	3546-2
Relational projection	and	conjunctive	selection	3547-1
selection	were filtering	action	operations	3547-1
operations	in	constraint	the sense	3547-1
the sense	that	constraint	they	3547-1
they	intuitively scan	action	a set	3547-1
a set	and	conjunctive	only certain elements	3547-1
a set	keep	action	only certain elements	3547-1
only certain elements	possibly modifying	action	them	3547-1
them	in	constraint	a uniform way	3547-1
The filters	in	constraint	complex value algebra	3547-2
complex value algebra	are	attribute	more general	3547-2
we	Of course shall allow	action	Boolean expressions	3547-3
Boolean expressions	in	constraint	selection conditions	3547-3
<B>		sequential	we	3547-4
we	also allow	action	set comparators	3547-4
set comparators	in	constraint	addition	3547-4
addition	to	constraint	∈	3547-4
∈		sequential	⊂	3547-4
⊂		sequential	⊆	3547-4
⊆		sequential	⊃	3547-4
⊃	and	conjunctive	negations	3547-4
negations	of	constraint	these comparators	3547-4
these comparators		sequential	<B>	3547-4
Selection	is	attribute	a predicative filter	3548-1
a predicative filter	in	constraint	the sense	3548-1
the sense	that	constraint	a predicate	3548-1
a predicate	allows	action	us	3548-1
us	to	constraint	some elements	3548-1
us	select	action	some elements	3548-1
some elements	leaving	action	them	3548-1
them		sequential	<B>	3548-1
Other filters		sequential	projection	3548-2
projection	are	attribute	map filters	3548-2
They	transform	action	the elements	3548-3
one	Clearly can combine	action	both aspects	3548-4
both aspects	and	conjunctive	more complicated selection conditions	3548-4
both aspects	furthermore allow	action	more complicated selection conditions	3548-4
more complicated selection conditions	or	conjunctive	restructuring specifications	3548-4
<B>	For	constraint	instance	3548-5
instance	suppose	action	I	3548-5
I	is	attribute	<B>	3548-5
We	could use	action	an operation	3549-1
an operation		sequential	that	3549-1
that	first filters	action	all the values	3549-1
all the values	matching	action	the pattern A	3549-1
the pattern A		sequential	x	3549-1
x		sequential	B	3549-1
B		sequential	C E	3549-1
C E		sequential	y	3549-1
y		sequential	E′	3549-1
E′		sequential	z	3549-1
z		sequential	C′	3549-1
C′		sequential	x	3549-1
x		sequential	}	3549-1
This style	of	constraint	operations	3550-1
operations	in	constraint	functional languages	3550-1
operations	is	attribute	standard	3550-1
functional languages	to	constraint	fp	3550-1
functional languages	in	constraint	fp	3550-1
functional languages	apply	attribute	all	3550-1
Remark		sequential	20.2.3	3551-1
<B>	In	constraint	the following sections	3552-1
the following sections		sequential	we	3552-1
we	call	action	extended algebra	3552-1
extended algebra		sequential	the algebra	3552-1
the algebra	of	constraint	the operations	3552-1
the algebra	consisting	action	the operations	3552-1
the operations	of	constraint	ALG cv	3552-1
ALG cv	and	conjunctive	complex constants	3552-1
ALG cv	allowing	action	complex constants	3552-1
complex constants		sequential	renaming	3552-1
renaming		sequential	cross-product	3552-1
cross-product		sequential	join	3552-1
join		sequential	n- ary set	3552-1
n- ary set	create	action	singleton	3552-1
singleton		sequential	nest	3552-1
nest	and	conjunctive	<B>	3552-1
The Calculus		sequential	The Calculus	3553-1
<B>	as	constraint	we	3553-2
we	shall see	action	calculus variables	3553-2
calculus variables	However may denote	action	sets	3553-2
sets	so	constraint	the calculus	3553-2
the calculus	will permit	action	quantification	3553-2
quantification	over	constraint	sets	3553-2
sets		sequential	something	3553-2
something	to	constraint	second order	3553-2
something	be	attribute	second order	3553-2
something	normally considered	action	second order	3553-2
second order		sequential	a feature	3553-2
<B>	For	constraint	complex value calculus	3553-3
complex value calculus		sequential	the separation	3553-3
the separation	between	constraint	order	3553-3
the separation	and	conjunctive	order	3553-3
order	and	conjunctive	higher order as well	3553-3
higher order as well	is	attribute	somewhat blurred	3553-3
<B>	As with	constraint	the algebra	3553-4
the algebra		sequential	we	3553-4
we	first present	action	a core calculus	3553-4
a core calculus	and	conjunctive	it	3553-4
a core calculus	extend	action	it	3553-4
The issues	of	constraint	domain independence	3553-5
domain independence	and	conjunctive	safety	3553-5
safety	are also addressed	action	<B>	3553-5
<B>	For	constraint	each sort	3554-1
each sort		sequential	we	3554-1
we	assume	action	the existence	3554-1
the existence	of	constraint	a countably infinite set	3554-1
a countably infinite set	of	constraint	variables	3554-1
variables	of	constraint	that sort	3554-1
A variable	if	constraint	it	3554-2
A variable	is	attribute	atomic	3554-2
it	over	constraint	the sort dom	3554-2
it	ranges	action	the sort dom	3554-2
<B>	Let	action	R	3554-3
R	be	attribute	a schema	3554-3
A term	is	attribute	an atomic element	3554-4
an atomic element		sequential	a variable	3554-4
a variable	or	conjunctive	an expression x.A	3554-4
an expression x.A		sequential	x	3554-4
x	is	attribute	where a tuple variable	3554-4
where a tuple variable	and	conjunctive	A	3554-4
A	is	attribute	an attribute	3554-4
an attribute	of	constraint	x	3554-4
We	do not consider	action	fancier terms	3554-5
A positive literal	is	attribute	an expression	3554-6
an expression	of	constraint	the form Complex Values	3554-6
the form Complex Values		sequential	R	3554-6
R		sequential	t	3554-6
t		sequential	t	3554-6
t	=	sequential	t	3554-6
t		sequential	t ∈ t	3554-6
t ∈ t	or	conjunctive	t ⊆ t ′	3554-6
t ⊆ t ′		sequential	R	3554-6
R		sequential	∈ R	3554-6
∈ R		sequential	t	3554-6
t		sequential	t′	3554-6
t′	are	attribute	where terms	3554-6
where terms	and	conjunctive	the appropriate sort restrictions	3554-6
the appropriate sort restrictions	apply	action	<B>	3554-6
The following example	illustrates	action	this calculus	3555-1
Example		sequential	20.3.1	3556-1
20.3		sequential	20.3	3556-2
We	that	constraint	J	3556-3
We	can verify	action	J	3556-3
J		sequential	R2	3556-3
R2	is	attribute	the answer	3556-3
the answer	on	constraint	instance J	3556-3
instance J	to	constraint	the query	3556-3
the query		sequential	the sorts	3556-3
the sorts	of	constraint	the variables	3556-3
the variables	as	constraint	sort	3556-3
the variables	are	attribute	sort	3556-3
the variables	where follows	action	sort	3556-3
sort		sequential	x	3556-3
x	=	sequential	A	3556-3
A		sequential	A1	3556-3
A1		sequential	A2	3556-3
A2		sequential	sort	3556-3
sort		sequential	y	3556-3
y	=	sequential	A	3556-3
A		sequential	B	3556-3
B		sequential	A1	3556-3
A1		sequential	A2	3556-3
A2		sequential	}	3556-3
}		sequential	sort	3556-3
sort		sequential	u	3556-3
u	=	sequential	sort	3556-3
sort		sequential	v	3556-3
v	=	sequential	sort	3556-3
sort		sequential	w	3556-3
w	=	sequential	dom	3556-3
dom		sequential	sort	3556-3
sort		sequential	z′	3556-3
z′	=	sequential	A1	3556-3
A1		sequential	A2	3556-3
A2		sequential	sort	3556-3
sort		sequential	z	3556-3
z	=	sequential	A1	3556-3
A1		sequential	A2	3556-3
A2		sequential	}	3556-3
We	could also have used	action	an unsorted alphabet	3557-1
an unsorted alphabet	of	constraint	variables	3557-1
variables	and	conjunctive	them	3557-1
variables	sorted	action	them	3557-1
them	inside	constraint	the formula	3557-1
the formula	as	constraint	u	3557-1
the formula	in	constraint	u	3557-1
u		sequential	dom	3557-1
dom		sequential	v	3557-1
v		sequential	dom	3557-1
dom	w	constraint	dom	3557-1
The key difference	with	constraint	relational calculus	3558-1
relational calculus	is	attribute	the presence	3558-1
the presence	of	constraint	the predicates	3558-1
the predicates		sequential	∈	3558-1
∈	and	conjunctive	⊆	3558-1
⊆		sequential	which	3558-1
which	as	constraint	the standard set membership	3558-1
which	are interpreted	action	the standard set membership	3558-1
the standard set membership	and	conjunctive	inclusion	3558-1
Another difference	of	constraint	a more cosmetic nature	3558-2
a more cosmetic nature	that	constraint	we	3558-2
a more cosmetic nature	is	attribute	we	3558-2
we	allow	action	only one free variable	3558-2
only one free variable	in	constraint	relation atoms	3558-2
relation atoms	in	constraint	query formulas	3558-2
relation atoms	and	conjunctive	query formulas	3558-2
<B>	from	constraint	the stronger sorts	3558-3
<B>	comes	action	the stronger sorts	3558-3
The answer	to	constraint	a query q	3559-1
a query q	on	constraint	an instance	3559-1
an instance		sequential	I	3559-1
I	denoted	action	q	3559-1
q		sequential	I	3559-1
I	as	constraint	the relational model	3559-1
I	for	constraint	the relational model	3559-1
I	is defined	action	the relational model	3559-1
<B>	As	constraint	the relational case	3559-2
<B>	in	constraint	the relational case	3559-2
the relational case		sequential	we	3559-2
we	may define	action	various interpretations	3559-2
various interpretations	depending on	action	the underlying domain	3559-2
the underlying domain	of	constraint	base values	3559-2
base values	used	action	<B>	3559-2
<B>	As with	constraint	relational calculus	3559-3
relational calculus		sequential	the basis	3559-3
the basis	for	constraint	the semantics	3559-3
the basis	defining	action	the semantics	3559-3
the semantics	is	attribute	the notion	3559-3
the notion		sequential	I	3559-3
I	for	constraint	ν	3559-3
I	satisfies	action	ν	3559-3
ν	to	constraint	d	3559-3
<B>	Consider	action	the definition	3560-1
the definition	of	constraint	this notion	3560-1
this notion	in	constraint	Section 5.3	3560-1
Cases	through	constraint	g	3560-2
g	for	constraint	the complex object calculus	3560-2
g	a remain	attribute	valid	3560-2
We	to	constraint	two supplementary cases	3560-3
We	have	action	two supplementary cases	3560-3
We	consider	action	two supplementary cases	3560-3
<B>	that	constraint	equality	3560-4
<B>	for	constraint	equality	3560-4
<B>	Recall	action	equality	3560-4
equality		sequential	we	3560-4
we	had	action	case	3560-4
case		sequential	I	3560-4
I	b |=d	action	ν	3560-4
ν	if	constraint	ϕ	3560-4
ϕ	=	sequential	s′	3560-4
ϕ	s =	sequential	s′	3560-4
s′	and	conjunctive	ν s	3560-4
ν s	=	sequential	ν	3560-4
ν		sequential	s′	3560-4
<B>	In	constraint	the same spirit	3561-1
the same spirit		sequential	we	3561-1
we	add	action	I	3561-1
I	|=d	action	ν	3561-1
ν	if	constraint	∈ s′	3561-1
ν	=	sequential	∈ s′	3561-1
∈ s′	and	conjunctive	ν s ∈	3561-1
ν s ∈		sequential	ν	3561-1
ν		sequential	I	3561-1
I	|=d	action	ν	3561-1
ν	if	constraint	⊆ s′	3561-1
ν	=	sequential	⊆ s′	3561-1
⊆ s′	and	conjunctive	ν s ⊆ ν	3561-1
ν s ⊆ ν		sequential	<B>	3561-1
<B>	that	constraint	∈	3562-1
<B>	formally states	action	∈	3562-1
∈	as	constraint	set membership	3562-1
∈	is interpreted	action	set membership	3562-1
set membership	and	conjunctive	⊆	3562-1
⊆	as	constraint	set inclusion	3562-1
set inclusion	in	constraint	the same sense	3562-1
the same sense		sequential	that	3562-1
that	as	constraint	equality	3562-1
that	as	constraint	equality	3562-1
that	=	sequential	equality	3562-1
that	is interpreted	action	equality	3562-1
The issues	surrounding	action	domain independence	3563-1
domain independence	for	constraint	relational calculus	3563-1
relational calculus	with	constraint	CALC cv	3563-1
relational calculus	also arise	action	CALC cv	3563-1
We	develop	action	a syntactic condition	3563-2
a syntactic condition	ensuring	action	domain independence	3563-2
domain independence	but	conjunctive	we	3563-2
we	also occasionally use	action	an active domain interpretation	3563-2
Extensions		sequential	Extensions	3564-1
The standard abbreviations	for	constraint	relational calculus	3565-1
The standard abbreviations	used	action	relational calculus	3565-1
relational calculus		sequential	the logical connectives	3565-1
<B>	In	constraint	the core calculus	3566-1
the core calculus		sequential	only relation atoms	3566-1
only relation atoms	of	constraint	the form	3566-1
the form		sequential	R	3566-1
R		sequential	t	3566-1
t	are permitted	action	<B>	3566-1
<B>	that	constraint	the sort	3566-2
<B>	Suppose	action	the sort	3566-2
the sort	of	constraint	R	3566-2
R	is	attribute	A1	3566-2
A1	τ	sequential	1	3566-2
<B>	.	sequential	<B>	3566-3
<B>	.	sequential	<B>	3566-4
<B>	for	constraint	some n	3566-5
<B>	.	sequential	<B>	3566-6
<B>	.	sequential	<B>	3566-7
un	is	attribute	a shorthand	3566-8
a shorthand	for	constraint	y	3566-8
y	is	attribute	where a new variable	3566-8
<B>	In	constraint	R0	3566-9
<B>	if	constraint	R0	3566-9
R0	is	attribute	a relation	3566-9
a relation	of	constraint	sort	3566-9
sort		sequential	n	3566-9
n	=	sequential	0	3566-9
0	that	constraint	the only value	3566-9
0	observe	action	the only value	3566-9
the only value	of	constraint	that sort	3566-9
that sort	is	attribute	the empty tuple	3566-9
a variable y	of	constraint	that sort	3566-10
that sort	Thus has namely	action	only one possible value	3566-10
<B>	for	constraint	such y	3566-11
such y		sequential	we	3566-11
we	Thus can use	action	the following expression	3566-11
the following expression		sequential	R0 for	3566-11
Constructed Terms		sequential	Constructed Terms	3567-1
<B>	if	constraint	t1	3568-1
<B>	.	sequential	<B>	3568-2
<B>	.	sequential	<B>	3568-3
tk	are	attribute	terms	3568-4
terms	and	conjunctive	B1	3568-4
<B>	.	sequential	<B>	3568-5
<B>	.	sequential	<B>	3568-6
Bk	are	attribute	distinct attributes	3568-7
distinct attributes		sequential	B1 t1	3568-7
<B>	.	sequential	<B>	3568-8
<B>	.	sequential	<B>	3568-9
Bk		sequential	tk	3568-10
tk	is	attribute	a term	3568-10
<B>	if	constraint	the ti	3568-11
the ti	of	constraint	the same sort	3568-11
the ti	are	attribute	the same sort	3568-11
the same sort	{	sequential	Furthermore t1	3568-11
<B>	.	sequential	<B>	3568-12
<B>	.	sequential	<B>	3568-13
tk	is	attribute	a term	3568-14
a term		sequential	Complex Values	3568-14
The use	of	constraint	constructed terms	3569-1
constructed terms	as	constraint	syntactic sugaring	3569-1
constructed terms	can be viewed	action	syntactic sugaring	3569-1
<B>	For	constraint	instance	3569-2
instance	that	constraint	the term	3569-2
instance	suppose	action	the term	3569-2
the term		sequential	a y	3569-2
a y	in	constraint	a formula ψ	3569-2
a y	occurs	action	a formula ψ	3569-2
ψ	to	constraint	ψ′	3569-3
ψ	is	attribute	Then equivalent	3569-3
ψ′	from	constraint	ψ	3569-3
ψ′	is obtained	action	ψ	3569-3
ψ	by	constraint	the term	3569-3
ψ	replacing	action	the term	3569-3
the term		sequential	y }	3569-3
y }	by	constraint	x	3569-3
x		sequential	a fresh variable	3569-3
Complex Terms		sequential	Complex Terms	3570-1
<B>	For	constraint	instance	3570-2
instance	if	constraint	R	3570-2
R	is	attribute	a relation	3570-2
a relation	of	constraint	sort A	3570-2
sort A		sequential	B	3570-2
B		sequential	R	3570-2
R	in	constraint	the language	3570-2
R	can be used	action	the language	3570-2
the language	as	constraint	a term	3570-2
a term	of	constraint	sort	3570-2
We	may consider	action	literals	3570-3
literals		sequential	x ∈ R	3570-3
x ∈ R		sequential	which	3570-3
which	to	constraint	R	3570-3
which	is	attribute	equivalent	3570-3
R		sequential	x	3570-3
x	or	conjunctive	more complex ones	3570-3
more complex ones		sequential	S ∈ T	3570-3
S ∈ T		sequential	which	3570-3
which	essentially means	action	<B>	3570-3
The previous extension	on	constraint	the fact	3571-1
The previous extension	is based	action	the fact	3571-1
the fact	that	constraint	a relation	3571-1
a relation	in	constraint	our context	3571-1
our context	as	constraint	a complex value	3571-1
our context	can be viewed	action	a complex value	3571-1
<B>	due to	constraint	again the stronger sort system	3571-2
<B>	is	attribute	again the stronger sort system	3571-2
the answer	to	constraint	a query q	3571-3
a query q	is	attribute	Now also a complex value	3571-3
<B>	suggests	action	the use	3571-4
<B>	considering	action	the use	3571-4
the use	of	constraint	queries	3571-4
queries	as	constraint	terms	3571-4
terms	of	constraint	the language	3571-4
We	consider now	attribute	this	3571-5
A query q	≡	sequential	y	3571-5
y		sequential	ψ	3571-5
ψ		sequential	y	3571-5
y	is	attribute	a legal term	3571-5
a legal term		sequential	that	3571-5
that	in	constraint	the calculus	3571-5
that	can be used	action	the calculus	3571-5
the calculus	like	constraint	any other term	3571-5
<B>		sequential	we	3571-6
we	allow	action	terms	3571-6
terms	of	constraint	the form	3571-6
the form		sequential	the free variables	3571-6
the free variables	of	constraint	ψ	3571-6
ψ	are	attribute	where y	3571-6
where y		sequential	y1	3571-6
<B>	.	sequential	<B>	3571-7
<B>	.	sequential	<B>	3571-8
<B>		sequential	<B>	3571-9
we	Intuitively obtain	action	queries	3571-10
queries	by	constraint	bindings	3571-10
queries	providing	action	bindings	3571-10
bindings	for	constraint	y1	3571-10
<B>	.	sequential	<B>	3571-11
<B>	.	sequential	<B>	3571-12
<B>		sequential	<B>	3571-13
We	will call	action	such an expression	3571-14
such an expression		sequential	a parameterized query	3571-14
a parameterized query	and	conjunctive	it	3571-14
a parameterized query	denote	action	it	3571-14
it		sequential	q	3571-14
q		sequential	y1	3571-14
<B>	.	sequential	<B>	3571-15
<B>	.	sequential	<B>	3571-16
<B>		sequential	y1	3571-17
<B>	.	sequential	<B>	3571-18
<B>	.	sequential	<B>	3571-19
<B>	are	attribute	the parameters	3571-20
<B>	For	constraint	instance	3572-1
instance	that	constraint	a formula	3572-1
instance	suppose	action	a formula	3572-1
a formula	liked	action	x	3572-1
x		sequential	y	3572-1
y	computes	action	the films	3572-1
the films	y	constraint	that person	3572-1
that person		sequential	x	3572-1
x	and	conjunctive	another one	3572-1
x	liked	action	another one	3572-1
another one	saw	action	x	3572-1
x	y computes	attribute	those	3572-1
that		sequential	x	3572-1
x	has seen	action	<B>	3572-1
The set	of	constraint	persons	3572-2
persons		sequential	who	3572-2
who	liked	action	all the films	3572-2
all the films		sequential	that	3572-2
that		sequential	they	3572-2
they	by	constraint	<B>	3572-2
they	saw	action	<B>	3572-2
they	is given	action	<B>	3572-2
The following form	of	constraint	literals	3573-1
literals	will play	action	a particular role	3573-1
a particular role		sequential	we	3573-1
we	when study	action	safety	3573-1
safety	for	constraint	this calculus	3573-1
this calculus		sequential	x	3573-1
x	=	sequential	y	3573-1
y		sequential	ψ	3573-1
ψ		sequential	y	3573-1
y		sequential	y1	3573-1
<B>	.	sequential	<B>	3573-2
<B>	.	sequential	<B>	3573-3
<B>		sequential	}	3573-4
}		sequential	x′ ∈	3573-4
x′ ∈		sequential	y	3573-4
y		sequential	ψ	3573-4
ψ		sequential	y	3573-4
y		sequential	y1	3573-4
<B>	.	sequential	<B>	3573-5
<B>	.	sequential	<B>	3573-6
<B>		sequential	}	3573-7
}	and	conjunctive	x′′	3573-7
x′′		sequential	⊆	3573-7
⊆		sequential	y	3573-7
y		sequential	ψ	3573-7
ψ		sequential	y	3573-7
y		sequential	y1	3573-7
<B>	.	sequential	<B>	3573-8
<B>	.	sequential	<B>	3573-9
<B>		sequential	y	3573-10
y	is	attribute	where a free variable	3573-10
where a free variable	of	constraint	ψ	3573-10
<B>	Like	constraint	the previous extensions	3573-11
the previous extensions		sequential	the parameterized queries	3573-11
the parameterized queries	as	constraint	syntactic sugaring	3573-11
the parameterized queries	can be viewed simply	action	syntactic sugaring	3573-11
<B>	For	constraint	instance	3573-12
instance		sequential	the three last formulas	3573-12
the three last formulas	are	attribute	equivalent	3573-12
<B>	In	constraint	the following sections	3574-1
the following sections		sequential	we	3574-1
we	call	action	extended calculus	3574-1
extended calculus		sequential	the calculus	3574-1
the calculus	of	constraint	CALC cv	3574-1
the calculus	consisting	action	CALC cv	3574-1
CALC cv	with	constraint	the abbreviations	3574-1
CALC cv	extended	action	the abbreviations	3574-1
the abbreviations	and	conjunctive	terms	3574-1
the abbreviations	described earlier	attribute	such as	3574-1
the abbreviations	constructed	attribute	complex	3574-1
terms	and	conjunctive	parameterized queries	3574-1
Examples		sequential	Examples	3575-1
The queries	in	constraint	the examples	3575-2
the examples	to	constraint	schema	3575-2
the examples	apply	action	schema	3575-2
schema	{	sequential	R	3575-2
R		sequential	S }	3575-2
S }	with	constraint	sort	3575-2
sort		sequential	R	3575-2
R	=	sequential	A dom	3575-2
A dom		sequential	A′	3575-2
A′		sequential	dom	3575-2
dom		sequential	sort	3575-2
sort		sequential	S	3575-2
S	=	sequential	B	3575-2
B		sequential	dom	3575-2
dom		sequential	B′	3575-2
B′		sequential	dom	3575-2
dom		sequential	}	3575-2
<B>	For	constraint	each query	3576-1
each query		sequential	we	3576-1
we	give	action	an algebraic	3576-1
an algebraic	and	conjunctive	a calculus expression	3576-1
Example		sequential	20.4.1	3577-1
Example		sequential	20.4.2	3578-1
Example		sequential	20.4.3	3579-1
Example		sequential	20.4.4	3580-1
This query	is	attribute	the composition	3580-2
the composition	of	constraint	the cross-product	3580-2
the cross-product	of	constraint	Example 20.4.3	3580-2
Example 20.4.3	with	constraint	a selection	3580-2
<B>	In	constraint	Example 20.4.3	3580-3
Example 20.4.3	let	action	the formula	3580-3
the formula	describing	action	the cross-product	3580-3
the cross-product	be	attribute	ϕ3	3580-3
ϕ3	and	conjunctive	R	3580-3
ϕ3	let	action	R	3580-3
R	×	constraint	S	3580-3
S	be	attribute	the algebraic expression	3580-3
A	=	sequential	B	3580-4
B		sequential	the join	3580-4
the join	of	constraint	R	3580-4
R	and	conjunctive	S	3580-4
S	by	constraint	<B>	3580-4
S	Then is expressed	action	<B>	3580-4
Example		sequential	20.4.5	3581-1
<B>	In	constraint	the algebra	3581-2
the algebra		sequential	it	3581-2
it	by	constraint	πA	3581-2
it	is given	action	πA	3581-2
Example		sequential	20.4.6	3582-1
<B>	is	attribute	the unnest operation	3583-1
the unnest operation		sequential	unnest B′	3583-1
unnest B′	in	constraint	the extended algebra	3583-1
the extended algebra	in	constraint	the calculus	3583-1
the extended algebra	or	conjunctive	the calculus	3583-1
the calculus		sequential	t	3583-1
t	of	constraint	where sort B C	3583-1
t	is	attribute	where sort B C	3583-1
We	first obtain	action	the set	3583-2
the set	of	constraint	values	3583-2
values	in	constraint	the B′ sets	3583-2
values	occurring	action	the B′ sets	3583-2
the B′ sets	using	action	E1	3583-2
E1	=	sequential	tup	3583-2
tup	create	action	C	3583-2
C		sequential	set	3583-2
set	_	sequential	tup	3583-2
set	destroy	action	tup	3583-2
tup	destroy	action	π B′	3583-2
π B′		sequential	S	3583-2
We	can next compute	action	E1	3584-1
E1	×	constraint	S	3584-1
S	using	action	the same technique	3584-1
the same technique	as	constraint	Example 20.4.3	3584-1
the same technique	in	constraint	Example 20.4.3	3584-1
the desired query	by	constraint	<B>	3584-2
the desired query	Then is given	action	<B>	3584-2
<B>	to	constraint	sorts	3585-1
<B>	Flattening	action	sorts	3585-1
<B>	can be extended	action	sorts	3585-1
sorts	with	constraint	arbitrary nesting depth	3585-1
Example		sequential	20.4.7	3586-1
<B>	Consider	action	a relation	3586-2
a relation		sequential	T C	3586-2
T C	of	constraint	sort	3586-2
sort		sequential	dom }	3586-2
dom }		sequential	C′	3586-2
C′		sequential	dom }	3586-2
We	to	constraint	the query	3586-3
We	want	action	the query	3586-3
We	express	action	the query	3586-3
the query	in	constraint	the algebra	3586-3
We	in	constraint	stages	3586-4
We	do	attribute	this	3586-4
stages		sequential	F1	3586-4
F1		sequential	σ C′′∈C	3586-4
σ C′′∈C		sequential	T	3586-4
T		sequential	× tup	3586-4
× tup	_	sequential	C′′ destroy	3586-4
× tup	create	action	C′′ destroy	3586-4
C′′ destroy		sequential	set	3586-4
set	_	sequential	tup	3586-4
tup	destroy	action	πC	3586-4
πC		sequential	T	3586-4
T		sequential	F2	3586-4
F2	=	sequential	σ C′′∈C′	3586-4
σ C′′∈C′		sequential	F1	3586-4
F1		sequential	F3	3586-4
F3	=	sequential	F1	3586-4
F1		sequential	F2	3586-4
F2		sequential	F4	3586-4
F4	=	sequential	T ′	3586-4
T ′		sequential	πCC	3586-4
πCC		sequential	F3	3586-4
<B>	that	constraint	<B>	3587-1
<B>	Observe	action	<B>	3587-1
Example		sequential	20.4.8	3588-1
<B>	Consider	action	the algebraic query nest	3588-2
the algebraic query nest		sequential	C=	3588-2
C=		sequential	A	3588-2
A	◦	sequential	nest	3588-2
nest		sequential	C′=	3588-2
C′=		sequential	A′	3588-2
A′	◦	sequential	σ C=C	3588-2
σ C=C		sequential	′ ◦ unnest C	3588-2
′ ◦ unnest C	◦	sequential	C′	3588-2
C′		sequential	R	3588-2
It	in	constraint	the calculus	3589-1
It	is expressed	action	the calculus	3589-1
the calculus	by	constraint	<B>	3589-1
Our last example	highlights	action	an important difference	3590-1
an important difference	between	constraint	the flat relational calculus	3590-1
the flat relational calculus	and	conjunctive	CALC cv	3590-1
<B>	As	constraint	Proposition 17.2.3	3590-2
<B>	in	constraint	Proposition 17.2.3	3590-2
<B>	shown	action	Proposition 17.2.3	3590-2
Proposition 17.2.3		sequential	the flat calculus	3590-2
the flat calculus	can not express	action	the transitive closure	3590-2
the transitive closure	of	constraint	a binary relation	3590-2
<B>	In	constraint	contrast	3590-3
contrast		sequential	the following CALC cv query	3590-3
the following CALC cv query	does	action	where Complex Values	3590-3
the formula	Intuitively specifies	action	the set	3591-1
the set	of	constraint	pairs	3591-1
pairs		sequential	y	3591-1
y		sequential	that	3591-1
that		sequential	y	3591-1
y	to	constraint	each binary relation x	3591-1
y	belongs	action	each binary relation x	3591-1
each binary relation x	containing	action	R	3591-1
R	and	conjunctive	<B>	3591-1
R	transitively closed	action	<B>	3591-1
This construction	in	constraint	Section 20.6	3591-2
This construction	will be revisited	action	Section 20.6	3591-2
Equivalence Theorems		sequential	Equivalence Theorems	3592-1
we	First establish	action	the equivalence	3593-1
the equivalence	of	constraint	the algebra	3593-1
the algebra	and	conjunctive	domain	3593-1
domain		sequential	the calculus	3593-1
we	Next develop	action	a syntactic safeness condition	3594-1
a syntactic safeness condition	for	constraint	the calculus	3594-1
the calculus	that	constraint	it	3594-1
the calculus	and	conjunctive	it	3594-1
the calculus	show	action	it	3594-1
it	does not reduce	action	expressive power	3594-1
we	Finally develop	action	a natural syntactic condition	3594-2
a natural syntactic condition	on	constraint	CALC cv	3594-2
CALC cv		sequential	that	3594-2
that	yields	action	a subset	3594-2
a subset	to	constraint	ALG cv−	3594-2
Our first result	as	constraint	Theorem 20.5.1	3595-1
Our first result	is	attribute	Theorem 20.5.1	3595-1
Our first result	follows	action	Theorem 20.5.1	3595-1
<B>	In	constraint	the sketch	3596-1
the sketch	of	constraint	the proof	3596-1
the proof		sequential	we	3596-1
we	present	action	a simulation	3596-1
a simulation	of	constraint	the core algebra	3596-1
the core algebra	by	constraint	the extended calculus	3596-1
the extended calculus	and	conjunctive	the analogous simulation	3596-1
the analogous simulation	in	constraint	the opposite direction	3596-1
An important component	of	constraint	this proof	3596-2
this proof	that	constraint	the extended algebra	3596-2
the extended algebra		sequential	calculus	3596-2
calculus	than	constraint	the core algebra	3596-2
calculus	is	attribute	no stronger	3596-2
the core algebra		sequential	calculus	3596-2
calculus	for	constraint	the reader	3596-2
calculus	is left	action	the reader	3596-2
the reader	see	action	Exercises 20.6	3596-2
Exercises 20.6		sequential	20.7	3596-2
20.7		sequential	20.8	3596-2
20.8		sequential	20.10	3596-2
20.10	and	conjunctive	20.11	3596-2
<B>	From	constraint	Algebra	3597-1
Algebra	to	constraint	Calculus	3597-1
<B>	Let	action	q	3598-1
q	be	attribute	a named algebra query	3598-1
We	construct	attribute	domain independent	3598-2
a query		sequential	x	3598-2
x	to	constraint	q	3598-2
x	ϕq	sequential	q	3598-2
x	}	sequential	q	3598-2
The formula ϕq	by	constraint	induction	3598-3
The formula ϕq	is constructed	action	induction	3598-3
induction	on	constraint	subexpressions	3598-3
subexpressions	of	constraint	q	3598-3
<B>	For	constraint	a subexpression E	3598-4
a subexpression E	of	constraint	q	3598-4
q		sequential	we	3598-4
we	define	action	ϕE	3598-4
ϕE	as	constraint	<B>	3598-4
ϕE	follows	action	<B>	3598-4
x.Ai	=	sequential	x.	3599-1
i		sequential	A ik	3600-1
i1 ik ik E1		sequential	E1 E2 E1 E2	3601-1
E1 E2		sequential	E1 E2	3602-1
the field	of	constraint	y	3603-1
n		sequential	n	3604-1
We	leave	action	the verification	3605-1
the verification	of	constraint	this construction	3605-1
this construction	to	constraint	the reader	3605-1
the reader	see	action	Exercise 20.13	3605-1
The domain independence	of	constraint	the obtained calculus query	3605-2
the obtained calculus query	from	constraint	the fact	3605-2
the obtained calculus query	follows	action	the fact	3605-2
the fact	that	constraint	algebra queries	3605-2
algebra queries	are	attribute	domain	3605-2
domain		sequential	<B>	3605-2
<B>	From	constraint	Calculus	3606-1
Calculus	to	constraint	Algebra	3606-1
<B>	Let	action	q	3607-1
q		sequential	x	3607-1
x	be	attribute	domain	3607-1
domain		sequential	a query	3607-1
a query	over	constraint	R	3607-1
We	use	action	the active domain interpretation	3607-2
the active domain interpretation	for	constraint	the query	3607-2
the query	as	constraint	a subscript adom	3607-2
the query	with	constraint	a subscript adom	3607-2
the query	denoted	action	a subscript adom	3607-2
The crux	of	constraint	the proof	3608-1
the proof	to	constraint	each subformula	3608-1
the proof	for	constraint	each subformula	3608-1
the proof	is	attribute	each subformula	3608-1
the proof	construct	action	each subformula	3608-1
each subformula		sequential	ψ	3608-1
ψ	of	constraint	an algebra formula	3608-1
<B>	.	sequential	<B>	3608-2
<B>	.	sequential	<B>	3608-3
xn		sequential	y	3608-4
y	=	sequential	Ax	3608-4
Ax	n	conjunctive	∧	3608-4
Ax	x	sequential	∧	3608-4
∧		sequential	ψ	3608-4
ψ		sequential	x1	3608-4
<B>	.	sequential	<B>	3608-5
<B>	.	sequential	<B>	3608-6
xn		sequential	} adom	3608-7
} adom		sequential	I	3608-7
I		sequential	where x1	3608-7
<B>	.	sequential	<B>	3608-8
<B>	.	sequential	<B>	3608-9
xn	is	attribute	a listing	3608-10
a listing	of	constraint	ψ	3608-10
This construction	in	constraint	three stages	3609-1
This construction	is accomplished	action	three stages	3609-1
<B>	Computing	action	the Active Domain	3610-1
The construction adom	of	constraint	E	3610-2
E	than	constraint	the similar construction	3610-2
E	is	attribute	slightly more intricate	3610-2
the similar construction	for	constraint	the relational case	3610-2
We	by	constraint	induction	3610-3
We	prove	action	induction	3610-3
induction	that	constraint	each sort τ	3610-3
induction	for	constraint	each sort τ	3610-3
each sort τ		sequential	there	3610-3
there	exists	action	an algebra operation	3610-3
This induction	in	constraint	the flat case	3610-4
This induction	was	attribute	not necessary	3610-4
the flat case	because	constraint	the base relations	3610-4
the base relations	had fixed	action	depth	3610-4
<B>	For	constraint	the base case	3610-5
the base case		sequential	τ	3610-5
τ	=	sequential	dom	3610-5
dom		sequential	it	3610-5
it	to	constraint	Fτ an identity operation	3610-5
it	for	constraint	Fτ an identity operation	3610-5
it	suffices	action	Fτ an identity operation	3610-5
it	use	action	Fτ an identity operation	3610-5
Fτ an identity operation		sequential	tup	3610-5
tup	_	sequential	tup	3610-5
tup	◦	sequential	tup	3610-5
tup	create	attribute	A	3610-5
tup	_	sequential	<B>	3610-5
tup	destroy	action	<B>	3610-5
<B>	For	constraint	the induction	3610-6
the induction		sequential	the following cases	3610-6
the following cases	occur	action	Complex Values FA	3610-6
<B>	Now consider	action	the schema R	3611-1
adom		sequential	q	3611-2
q		sequential	I	3611-2
I	with	constraint	the query E	3611-2
I	Thus can be computed	action	the query E	3611-2
the query E		sequential	adom	3611-2
adom	=	sequential	F sort	3611-2
F sort		sequential	R1	3611-2
R1		sequential	R1	3611-2
R1		sequential	∪	3611-2
∪		sequential	∪ F sort	3611-2
∪ F sort		sequential	Rm	3611-2
Rm		sequential	Rm	3611-2
Rm		sequential	∪	3611-2
∪	{	sequential	∪	3611-2
∪		sequential	∪	3611-2
∪		sequential	ap	3611-2
ap		sequential	}	3611-2
}		sequential	where R1	3611-2
<B>	.	sequential	<B>	3611-3
<B>	.	sequential	<B>	3611-4
Rm	is	attribute	the list	3611-5
the list	of	constraint	relations	3611-5
relations	in	constraint	R	3611-5
R	and	conjunctive	a1	3611-5
<B>	.	sequential	<B>	3611-6
<B>	.	sequential	<B>	3611-7
ap	is	attribute	the list	3611-8
the list	of	constraint	elements	3611-8
elements	in	constraint	q	3611-8
elements	occurring	action	q	3611-8
<B>	Constructing	action	Complex Values	3612-1
<B>	For	constraint	τ	3612-2
τ	=	sequential	dom	3612-2
dom		sequential	we	3612-2
we	can use	action	E	3612-2
E		sequential	adom	3612-2
<B>	For	constraint	the induction	3612-3
the induction		sequential	two cases	3612-3
two cases	occur	action	<B>	3612-3
Last Stage		sequential	Last Stage	3613-1
We	without	constraint	loss	3613-2
We	assume	action	loss	3613-2
loss	of	constraint	generality	3613-2
generality		sequential	that	3613-2
that		sequential	the logical connectives	3613-2
We	that	constraint	relation atoms	3614-1
We	also assume	action	relation atoms	3614-1
relation atoms	in	constraint	constants	3614-1
relation atoms	ϕ	sequential	constants	3614-1
relation atoms	do not contain	action	constants	3614-1
constants	or	conjunctive	repeated variables	3614-1
We	only present	action	the new case	3614-2
the new case		sequential	the standard cases	3614-2
the standard cases	as	constraint	Exercise 20.13	3614-2
the standard cases	are left	action	Exercise 20.13	3614-2
<B>	Let	action	ψ	3614-3
ψ	be	attribute	x ∈ y	3614-3
<B>	that	constraint	x	3615-1
<B>	Suppose	action	x	3615-1
x	of	constraint	sort	3615-1
x	is	attribute	sort	3615-1
sort		sequential	τ	3615-1
τ		sequential	y	3615-1
y	of	constraint	so sort	3615-1
y	is	attribute	so sort	3615-1
so sort		sequential	τ	3615-1
τ		sequential	}	3615-1
The set	of	constraint	values	3615-2
values	of	constraint	sort τ	3615-2
sort τ	or	conjunctive	τ	3615-2
τ		sequential	}	3615-2
}	within	constraint	the active domain	3615-2
the active domain	by	constraint	query Gτ	3615-2
the active domain	is returned	action	query Gτ	3615-2
query Gτ	or	conjunctive	G	3615-2
G		sequential	τ	3615-2
τ		sequential	}	3615-2
The query	x	sequential	∈ Ay	3615-3
∈ Ay	returns	action	the desired result	3615-3
<B>	that	constraint	this construction	3616-1
<B>	with	constraint	this construction	3616-1
<B>	Observe	action	this construction	3616-1
this construction		sequential	Eϕ	3616-1
Eϕ	returns	action	a set	3616-1
a set	of	constraint	tuples	3616-1
tuples	with	constraint	a single attribute Ax	3616-1
The query		sequential	q	3616-2
q	to	constraint	tup	3616-2
q	is	attribute	equivalent	3616-2
tup	destroy	action	Eϕ	3616-2
Safe Queries		sequential	Safe Queries	3617-1
These conditions	of	constraint	relational calculus	3617-2
These conditions	for	constraint	relational calculus	3617-2
These conditions	are	attribute	reminiscent	3617-2
These conditions	presented	action	relational calculus	3617-2
relational calculus	in	constraint	Chapter 5	3617-2
<B>	As	constraint	we	3617-3
we	shall see	action	a variant	3617-3
a variant	of	constraint	safe range	3617-3
safe range	called	action	strongly safe range	3617-3
strongly safe range	will yield	action	a subset CALC cv	3617-3
a subset CALC cv	of	constraint	denoted CALC cv−	3617-3
denoted CALC cv−	to	constraint	ALG cv−	3617-3
denoted CALC cv−	is	attribute	equivalent	3617-3
We	could define	action	safe range	3618-1
safe range	on	constraint	the core calculus	3618-1
such a definition	be	attribute	However would cumbersome	3618-2
A much more elegant definition	can be given	action	the extended calculus	3618-3
A much more elegant definition	using	action	the extended calculus	3618-3
<B>	In	constraint	we	3619-1
we	consider here	action	the calculus	3619-1
the calculus	with	constraint	1 constructed terms	3619-1
the calculus	augmented	action	1 constructed terms	3619-1
1 constructed terms	and	conjunctive	2 parameterized queries	3619-1
<B>	that	constraint	a formula	3620-1
<B>	if	constraint	a formula	3620-1
<B>	Recall	action	a formula	3620-1
a formula	is	attribute	safe range	3620-1
safe range		sequential	each variable	3620-1
each variable	in	constraint	the sense	3620-1
each variable	intuitively is bounded	action	the sense	3620-1
the sense	that	constraint	it	3620-1
it	by	constraint	the formula	3620-1
it	is restricted	action	the formula	3620-1
the formula	to	constraint	the active domain	3620-1
the formula	within	constraint	the active domain	3620-1
the formula	lie	action	the active domain	3620-1
the active domain	of	constraint	the query	3620-1
the query	or	conjunctive	the input	3620-1
We	now define	action	the notions	3620-2
the notions	of	constraint	safe formulas	3620-2
safe formulas	and	conjunctive	safe terms	3620-2
<B>	To	constraint	these definitions	3620-3
<B>	give	action	these definitions	3620-3
these definitions		sequential	we	3620-3
we	define	action	the set	3620-3
the set	of	constraint	safe range	3620-3
safe range		sequential	variables	3620-3
variables	of	constraint	a formula	3620-3
a formula	using	action	the following procedure	3620-3
the following procedure		sequential	which	3620-3
which	either	conjunctive	the symbol ⊥	3620-3
which	returns	action	the symbol ⊥	3620-3
the symbol ⊥		sequential	which	3620-3
which	that	constraint	some quantified variable	3620-3
which	indicates	action	some quantified variable	3620-3
some quantified variable	or	conjunctive	the set	3620-3
some quantified variable	is not bounded	action	the set	3620-3
the set	of	constraint	free variables	3620-3
free variables		sequential	that	3620-3
that	are bounded	action	<B>	3620-3
<B>	In	constraint	this discussion	3620-4
this discussion		sequential	we	3620-4
we	consider	action	only formulas	3620-4
only formulas	in	constraint	which	3620-4
which		sequential	universal quantifiers	3620-4
universal quantifiers	do not occur	action	<B>	3620-4
<B>	In	constraint	the following procedure	3621-1
the following procedure	if	constraint	several rules	3621-1
several rules	are	attribute	applicable	3621-1
the one	returning	action	the largest set	3621-1
the largest set	of	constraint	safe range	3621-1
safe range		sequential	variables	3621-1
variables		sequential	which	3621-1
which	always exists	action	<B>	3621-1
which	is chosen	action	<B>	3621-1
procedure		sequential	range	3622-1
range		sequential	sr	3622-1
sr		sequential	input	3622-1
input		sequential	a calculus formula output	3622-1
a calculus formula output		sequential	a subset	3622-1
a subset	of	constraint	the free variables	3622-1
the free variables	of	constraint	⊥	3622-1
the free variables	or	conjunctive	⊥	3622-1
the free variables	ϕ	sequential	⊥	3622-1
<B>	In	constraint	each Z	3622-2
<B>	for	constraint	each Z	3622-2
<B>	the following	action	each Z	3622-2
each Z	⊥	sequential	∪ Z	3622-2
∪ Z	=	sequential	<B>	3622-2
<B>	if	constraint	some parameterized query	3623-1
<B>	for	constraint	some parameterized query	3623-1
<B>	begin	action	some parameterized query	3623-1
some parameterized query		sequential	x	3623-1
x		sequential	ψ	3623-1
ψ		sequential	}	3623-1
}	as	constraint	a term	3623-1
}	occurring	action	a term	3623-1
a term	in	constraint	ϕ	3623-1
ϕ		sequential	x ∈	3623-1
x ∈		sequential	sr	3623-1
sr		sequential	ψ	3623-1
ψ		sequential	return	3623-1
return		sequential	case	3623-1
case		sequential	ϕ	3623-1
ϕ	of	constraint	R	3623-1
R		sequential	t	3623-1
t		sequential	sr	3623-1
sr		sequential	ϕ	3623-1
ϕ	=	sequential	t	3623-1
t		sequential	ψ	3623-1
ψ		sequential	t	3623-1
t		sequential	t	3623-1
t		sequential	pred sr	3623-1
pred sr		sequential	ϕ	3623-1
ϕ	=	sequential	sr	3623-1
sr	ϕ	sequential	1	3623-1
1	−	sequential	else return ⊥ end	3623-1
1	x	sequential	else return ⊥ end	3623-1
It	to	constraint	new sets	3624-1
It	is	attribute	important	3624-1
It	understand	action	new sets	3624-1
new sets	in	constraint	a safe manner	3624-1
new sets	how are created	action	a safe manner	3624-1
The next example	illustrates	action	two essential techniques	3624-2
two essential techniques	for	constraint	such creation	3624-2
Complex Values Example 20.5.2		sequential	Complex Values Example 20.5.2	3625-1
The powerset	of	constraint	R	3625-2
R	in	constraint	a safe manner	3625-2
R	can be obtained	action	a safe manner	3625-2
a safe manner	with	constraint	the query	3625-2
<B>	For	constraint	y	3626-1
y		sequential	R	3626-1
R		sequential	y	3626-1
y	is	attribute	clearly a safe query	3626-1
clearly a safe query	by	constraint	the first case	3626-1
<B>	letting	action	t ≡	3626-2
t ≡		sequential	x	3626-2
x		sequential	t′	3626-2
t′		sequential	y	3626-2
y		sequential	R	3626-2
R		sequential	y	3626-2
y		sequential	}	3626-2
}		sequential	the formula	3626-2
the formula	by	constraint	the third case	3626-2
the formula	is	attribute	Now safe	3626-2
<B>	Now consider	action	the nesting	3627-1
the nesting	of	constraint	the B column	3627-1
the B column	of	constraint	R	3627-1
<B>	Let	action	t	3628-1
t		sequential	x	3628-1
x		sequential	t′ ≡ z	3628-1
t′ ≡ z		sequential	y	3628-1
y		sequential	R	3628-1
R		sequential	z	3628-1
z		sequential	y	3628-1
y		sequential	}	3628-1
}	and	conjunctive	ψ	3628-1
ψ		sequential	∃y′	3628-1
∃y′		sequential	R	3628-1
R		sequential	z	3628-1
z		sequential	y′	3628-1
First note	that	constraint	sr	3628-2
sr		sequential	R	3628-2
R		sequential	z	3628-2
z		sequential	y	3628-2
y	contains	action	y	3628-2
y		sequential	the parameterized query	3628-2
the parameterized query		sequential	y	3628-2
y		sequential	R	3628-2
R		sequential	z	3628-2
z		sequential	y	3628-2
y		sequential	}	3628-2
}	so can be used safely	action	<B>	3628-2
the formula		sequential	ψ	3628-3
ψ	is	attribute	Next safe	3628-3
the only free variable	in	constraint	t′	3628-4
t′	is	attribute	Finally z	3628-4
Finally z		sequential	which	3628-4
which	in	constraint	ψ	3628-4
which	is	attribute	also free	3628-4
x	is	attribute	Thus safe range	3628-5
Thus safe range	by	constraint	the second case	3628-5
the second case	and	conjunctive	the query	3628-5
the query	is	attribute	safe	3628-5
<B>	In	constraint	contrast	3629-1
contrast	as	constraint	that section	3629-1
contrast	in	constraint	that section	3629-1
contrast	discussed	action	that section	3629-1
that section		sequential	the nested relation algebra	3629-1
the nested relation algebra		sequential	ALG cv−	3629-1
ALG cv−		sequential	which	3629-1
which	uses	action	the nest operator	3629-1
the nest operator	but	conjunctive	not powerset	3629-1
not powerset	has	action	complexity	3629-1
complexity	in	constraint	ptime	3629-1
there	Interestingly is	action	a minor variation	3629-2
a minor variation	of	constraint	safe range	3629-2
safe range		sequential	the condition	3629-2
the condition		sequential	that	3629-2
that	yields	action	a subset	3629-2
a subset	of	constraint	the calculus	3629-2
the calculus	to	constraint	ALG cv−	3629-2
a formula	is	attribute	Specifically strongly safe range	3629-3
Specifically strongly safe range	if	constraint	it	3629-3
it	is	attribute	safe range	3629-3
safe range	and	conjunctive	the inclusion predicate	3629-3
the inclusion predicate	in	constraint	it	3629-3
the inclusion predicate	does not occur	action	it	3629-3
<B>	In	constraint	the previous example	3629-4
the previous example		sequential	the nesting	3629-4
the nesting	is	attribute	strongly safe range	3629-4
strongly safe range	whereas	constraint	powerset	3629-4
powerset	is not	action	<B>	3629-4
We	now have	action	the following Theorem 20.5.3	3630-1
Crux	Consider a	action	<B>	3631-1
<B>	By	constraint	inspection	3631-2
inspection	of	constraint	the construction	3631-2
the construction	in	constraint	the proof	3631-2
the proof	that	constraint	CALC	3631-2
CALC		sequential	ALG cv cv	3631-2
ALG cv cv		sequential	each algebra query	3631-2
each algebra query	to	constraint	safe range	3631-2
each algebra query	is	attribute	equivalent	3631-2
safe range		sequential	a calculus query	3631-2
safe range		sequential	each calculus query	3631-3
each calculus query	is	attribute	domain	3631-3
domain		sequential	Clearly a calculus query	3631-3
We	that	constraint	each calculus query	3631-4
We	have already shown	attribute	domain independent	3631-4
each calculus query	is	attribute	an algebra query	3631-4
<B>	Now consider	action	<B>	3632-1
<B>	that	constraint	the proof	3632-2
<B>	in	constraint	the proof	3632-2
<B>	Observe	action	the proof	3632-2
the proof	that	constraint	ALG cv CALC cv	3632-2
ALG cv CALC cv		sequential	⊆	3632-2
⊆	for	constraint	only powerset	3632-2
⊆	is used	action	only powerset	3632-2
each query	in	constraint	ALG cv−	3632-3
ALG cv−	is	attribute	strongly safe range	3632-3
strongly safe range		sequential	Thus a query	3632-3
<B>	Now consider	action	strongly safe range	3632-4
strongly safe range		sequential	a query	3632-4
a query		sequential	we	3632-4
we	construct	action	an equivalent algebra query	3632-4
We	can not use	action	the construction	3632-5
the construction	from	constraint	the proof	3632-5
the proof	of	constraint	the equivalence theorem	3632-5
the equivalence theorem	because	constraint	powerset	3632-5
powerset	for	constraint	complex domains	3632-5
powerset	is	attribute	crucial	3632-5
powerset	constructing	action	complex domains	3632-5
we	that	constraint	the ranges	3632-6
we	However can show	attribute	this	3632-6
we	can be avoided	action	the ranges	3632-6
we	using	action	the ranges	3632-6
the ranges	of	constraint	variables	3632-6
<B>	See	action	Exercise 20.16	3632-7
the brute force construction	of	constraint	the domain	3632-8
the domain	of	constraint	variables	3632-8
variables	using	action	powerset	3632-8
powerset	by	constraint	a careful construction	3632-8
powerset	More precisely is replaced	action	a careful construction	3632-8
a careful construction	on	constraint	strongly safe range	3632-8
a careful construction	based	action	strongly safe range	3632-8
strongly safe range		sequential	the restriction	3632-8
The remainder	of	constraint	the proof	3632-9
the proof	stays	attribute	unchanged	3632-9
<B>	Because of	constraint	part	3633-1
part	of	constraint	the previous result	3633-1
the previous result		sequential	we	3633-1
we	b denote	attribute	safe	3633-1
strongly range		sequential	the calculus	3633-1
the calculus	by	constraint	CALC cv−	3633-1
Fixpoint	and	conjunctive	Deduction	3634-1
Deduction		sequential	Example 20.4.9	3634-1
Example 20.4.9	that	constraint	the complex value algebra	3634-1
Example 20.4.9	suggests	action	the complex value algebra	3634-1
the complex value algebra	and	conjunctive	calculus	3634-1
calculus	can simulate	action	iteration	3634-1
<B>	In	constraint	this section	3634-2
this section		sequential	we	3634-2
we	examine	action	iteration	3634-2
iteration	in	constraint	the spirit	3634-2
the spirit	of	constraint	fixpoint queries	3634-2
the spirit	both	conjunctive	fixpoint queries	3634-2
fixpoint queries	and	conjunctive	datalog	3634-2
<B>	In	constraint	both cases	3635-1
both cases		sequential	they	3635-1
they	do not increase	action	the expressive power	3635-1
the expressive power	of	constraint	the algebra	3635-1
the algebra	or	conjunctive	calculus	3635-1
they	However allow	action	us	3635-2
us	to	constraint	certain queries	3635-2
us	express more efficiently	action	certain queries	3635-2
Fixpoint	for	constraint	Complex Values Languages	3636-1
Complex Values Languages	with	constraint	fixpoint semantics	3636-1
fixpoint semantics	in	constraint	the context	3636-1
fixpoint semantics	were considered	action	the context	3636-1
the context	of	constraint	the relational model	3636-1
the relational model	to	constraint	limitations	3636-1
the relational model	overcome	action	limitations	3636-1
limitations	of	constraint	relational algebra	3636-1
relational algebra	and	conjunctive	calculus	3636-1
<B>	In	constraint	we	3636-2
we	that	constraint	transitive closure	3636-2
we	observed	action	transitive closure	3636-2
transitive closure	in	constraint	relational calculus	3636-2
transitive closure	can not be computed	action	relational calculus	3636-2
<B>	as	constraint	Example 20.4.9	3636-3
<B>	by	constraint	Example 20.4.9	3636-3
<B>	shown	action	Example 20.4.9	3636-3
Example 20.4.9		sequential	transitive closure	3636-3
transitive closure	in	constraint	the complex value algebra	3636-3
transitive closure	However can be expressed	action	the complex value algebra	3636-3
the complex value algebra	and	conjunctive	calculus	3636-3
<B>	Although	constraint	transitive closure	3636-4
transitive closure	in	constraint	that manner	3636-4
transitive closure	can be expressed	action	that manner	3636-4
that manner		sequential	the use	3636-4
the use	of	constraint	powerset	3636-4
powerset	seems	attribute	unnecessarily expensive	3636-4
it	that	constraint	any query	3636-5
it	More precisely can be shown	action	any query	3636-5
any query	in	constraint	the complex value algebra	3636-5
the complex value algebra	and	conjunctive	calculus	3636-5
calculus		sequential	that	3636-5
that	expresses	action	transitive closure	3636-5
transitive closure	uses	action	exponential space	3636-5
exponential space	assuming	action	the straightforward evaluation	3636-5
the straightforward evaluation	of	constraint	the query	3636-5
<B>	In	constraint	other words	3636-6
other words		sequential	the blowup	3636-6
the blowup	by	constraint	the powerset operator	3636-6
the blowup	caused	action	the powerset operator	3636-6
the powerset operator	can not be avoided	action	<B>	3636-6
<B>	On	constraint	the other hand	3636-7
the other hand		sequential	a fixpoint construct	3636-7
a fixpoint construct	allows	action	us	3636-7
us	to	constraint	transitive closure	3636-7
us	express	action	transitive closure	3636-7
transitive closure	in	constraint	polynomial space	3636-7
polynomial space	and	conjunctive	time	3636-7
It	to	constraint	fixpoint extensions	3636-8
It	is	attribute	thus natural	3636-8
It	develop	action	fixpoint extensions	3636-8
fixpoint extensions	of	constraint	the calculus	3636-8
the calculus	and	conjunctive	algebra	3636-8
We	and	conjunctive	extensions	3637-1
We	can provide	attribute	inflationary	3637-1
extensions	of	constraint	the calculus	3637-1
the calculus	with	constraint	recursion	3637-1
<B>	As	constraint	the relational case	3637-2
<B>	in	constraint	the relational case	3637-2
the relational case		sequential	an inflationary fixpoint operator µ+	3637-2
an inflationary fixpoint operator µ+	allows	action	the iteration	3637-2
the iteration	of	constraint	a T CALC cv formula	3637-2
a T CALC cv formula		sequential	T	3637-2
T		sequential	a fixpoint	3637-2
<B>	essentially permits	action	the inductive definition	3637-3
the inductive definition	of	constraint	relations	3637-3
relations	using	action	calculus formulas	3637-3
The calculus CALC cv	with	constraint	the inflationary fixpoint operator	3637-4
The calculus CALC cv	augmented	action	the inflationary fixpoint operator	3637-4
the inflationary fixpoint operator	to	constraint	the flat case	3637-4
the inflationary fixpoint operator	is defined similarly	action	the flat case	3637-4
the flat case		sequential	Chapter 14	3637-4
Chapter 14	and	conjunctive	CALC cv	3637-4
Chapter 14	yields	action	CALC cv	3637-4
CALC cv	+	sequential	µ+	3637-4
We	only consider	action	the inflationary fixpoint operator	3638-1
Exercise 20.19	explores	action	the noninflationary version	3638-2
Theorem		sequential	20.6.1	3639-1
20.6.1		sequential	CALC cv	3639-1
CALC cv	+	sequential	µ+	3639-1
µ+	to	constraint	ALG cv	3639-1
µ+	is	attribute	equivalent	3639-1
ALG cv	and	conjunctive	CALC cv	3639-1
The proof	of	constraint	this theorem	3640-1
this theorem	for	constraint	Exercise 20.18	3640-1
this theorem	is left	action	Exercise 20.18	3640-1
It	involves	action	a fixpoint	3640-2
It	simulating	action	a fixpoint	3640-2
a fixpoint	in	constraint	a manner	3640-2
a manner	to	constraint	Example 20.4.9	3640-2
<B>	Before	constraint	the fixpoint extension	3641-1
<B>	leaving	action	the fixpoint extension	3641-1
the fixpoint extension		sequential	we	3641-1
we	show	action	powerset	3641-1
powerset	by	constraint	a ALG cv− formula	3641-1
powerset	how can be computed	action	a ALG cv− formula	3641-1
powerset	iterating	action	a ALG cv− formula	3641-1
a ALG cv− formula	to	constraint	a fixpoint	3641-1
We	that	constraint	powerset	3641-2
We	will see later	action	powerset	3641-2
powerset	in	constraint	ALG cv−	3641-2
powerset	can not be computed alone	action	ALG cv−	3641-2
Example		sequential	20.6.2	3642-1
The powerset	of	constraint	R	3642-2
R	by	constraint	x	3642-2
R	is computed	action	x	3642-2
x		sequential	µT }	3642-2
µT }		sequential	ϕ	3642-2
ϕ		sequential	T	3642-2
T		sequential	x	3642-2
x		sequential	T	3642-2
T	of	constraint	where sort dom }	3642-2
T	is	attribute	where sort dom }	3642-2
where sort dom }	and	conjunctive	ϕ	3642-2
ϕ		sequential	T	3642-2
T		sequential	y	3642-2
y		sequential	≡	3642-2
≡		sequential	y	3642-2
y	=	sequential	∨	3642-2
y	∅	sequential	∨	3642-2
∨		sequential	∃x′	3642-2
∃x′		sequential	y′	3642-2
y′		sequential	R	3642-2
R		sequential	x′	3642-2
x′		sequential	T	3642-2
T		sequential	y′	3642-2
y′		sequential	∧	3642-2
∧		sequential	y	3642-2
y	=	sequential	y′	3642-2
y′	∪	sequential	x′	3642-2
y′	{	sequential	x′	3642-2
x′		sequential	}	3642-2
Complex Values		sequential	Complex Values	3642-3
<B>	See	action	Exercise 20.15	3642-4
<B>	For	constraint	example	3642-5
example	that	constraint	R	3642-5
example	suppose	action	R	3642-5
R	contains	action	2	3642-5
2		sequential	3	3642-5
3		sequential	4	3642-5
4		sequential	}	3642-5
The iteration	of	constraint	J0	3642-6
The iteration	yields	action	J0	3642-6
J0		sequential	J1	3642-6
J1		sequential	J2	3642-6
J2		sequential	J3	3642-6
J3		sequential	J4	3642-6
Datalog	for	constraint	Complex Values	3643-1
The basic result	that	constraint	the extension	3643-2
The basic result	is	attribute	the extension	3643-2
the extension	to	constraint	the complex value algebra	3643-2
the extension	is	attribute	equivalent	3643-2
the complex value algebra	and	conjunctive	calculus	3643-2
We	also consider	action	a special grouping construct	3643-3
a special grouping construct		sequential	which	3643-3
which	for	constraint	set construction	3643-3
which	can be used	action	set construction	3643-3
set construction	in	constraint	this context	3643-3
<B>	In	constraint	the datalog extension	3644-1
the datalog extension	considered here	action	the predicates	3644-1
the predicates		sequential	⊆	3644-1
⊆	and	conjunctive	∈	3644-1
∈	are permitted	action	<B>	3644-1
A rule	is	attribute	safe range	3644-2
safe range	if	constraint	each variable	3644-2
each variable		sequential	that	3644-2
that	in	constraint	the head	3644-2
that	appears	action	the head	3644-2
the head	in	constraint	the body	3644-2
the head	also appears	action	the body	3644-2
the body	and	conjunctive	the body	3644-2
the body	is	attribute	safe	3644-2
the conjunction	of	constraint	the literals	3644-2
the literals	of	constraint	the body	3644-2
the body	is	attribute	a safe formula	3644-2
We	assume	action	henceforth	3644-3
henceforth	that	constraint	rules	3644-3
rules	are	attribute	safe	3644-3
Stratified negation	will be used	action	<B>	3644-4
The language	in	constraint	the following example	3644-5
The language	is illustrated	action	the following example	3644-5
Example		sequential	20.6.3	3645-1
<B>	Consider	action	the query	3645-2
the query	defining	action	an idb relation T	3645-2
an idb relation T		sequential	which	3645-2
which	contains	action	the tuples	3645-2
the tuples	of	constraint	R	3645-2
R	with	constraint	the B component	3645-2
the B component	by	constraint	its transitive closure	3645-2
the B component	replaced	action	its transitive closure	3645-2
<B>	Let	action	us	3645-3
us	that	constraint	we	3645-3
us	assume	action	we	3645-3
we	have	action	a ternary relation ins	3645-3
a ternary relation ins		sequential	ins	3645-3
ins		sequential	w y	3645-3
w y		sequential	z	3645-3
z	as	constraint	z	3645-3
z	where is interpreted	action	z	3645-3
z	by	constraint	y	3645-3
z	w	constraint	y	3645-3
z	into	constraint	y	3645-3
z	is obtained	action	y	3645-3
z	inserting	action	y	3645-3
y		sequential	We	3645-3
We	to	constraint	this relation	3645-3
We	show	action	this relation	3645-3
We	later how define	action	this relation	3645-3
this relation	in	constraint	the language	3645-3
The program	of	constraint	the following rules	3645-4
The program	consists	action	the following rules	3645-4
the following rules		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	y	3645-4
y		sequential	R	3645-4
R		sequential	x	3645-4
x		sequential	y	3645-4
y		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	z	3645-4
z		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	y	3645-4
y		sequential	u ∈	3645-4
u ∈		sequential	y	3645-4
y		sequential	v	3645-4
v		sequential	∈ y	3645-4
∈ y		sequential	u.C′	3645-4
u.C′	=	sequential	v.C	3645-4
v.C		sequential	ins	3645-4
ins		sequential	u.C	3645-4
u.C		sequential	v.C′	3645-4
v.C′		sequential	y	3645-4
y		sequential	z	3645-4
z		sequential	S′	3645-4
S′		sequential	x	3645-4
x		sequential	z	3645-4
z		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	z	3645-4
z		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	z′	3645-4
z′		sequential	z ⊆ z′	3645-4
z ⊆ z′		sequential	z	3645-4
z	=	sequential	z′ T	3645-4
z′ T	x	sequential	z	3645-4
z		sequential	S	3645-4
S		sequential	x	3645-4
x		sequential	z	3645-4
z		sequential	¬ S′	3645-4
¬ S′		sequential	x	3645-4
x		sequential	z	3645-4
The first two rules	in	constraint	S pairs	3646-1
The first two rules	compute	action	S pairs	3646-1
S pairs	to	constraint	pairs	3646-1
S pairs	corresponding	action	pairs	3646-1
pairs	from	constraint	R	3646-1
R		sequential	the second component	3646-1
the second component	of	constraint	a pair	3646-1
a pair	contains	action	the corresponding component	3646-1
the corresponding component	from	constraint	the pair	3646-1
the pair	in	constraint	R	3646-1
R	and	conjunctive	possibly additional elements	3646-1
possibly additional elements	by	constraint	transitivity	3646-1
possibly additional elements	derived	action	transitivity	3646-1
<B>	for	constraint	each pair x	3646-2
each pair x		sequential	y	3646-2
y	of	constraint	R	3646-2
R		sequential	there	3646-2
there	Obviously is	action	a pair	3646-2
a pair		sequential	x	3646-2
x		sequential	z	3646-2
z	in	constraint	S	3646-2
S	that	constraint	z	3646-2
z	is	attribute	the transitive closure	3646-2
the transitive closure	of	constraint	y	3646-2
y	but	conjunctive	there	3646-2
there	are as well	action	other tuples	3646-2
<B>	To	constraint	the query	3647-1
<B>	answer	action	the query	3647-1
the query		sequential	we	3647-1
we	to	constraint	each x	3647-1
we	for	constraint	each x	3647-1
we	need	action	each x	3647-1
we	select	action	each x	3647-1
each x		sequential	the unique tuple	3647-1
the unique tuple		sequential	x	3647-1
x		sequential	z	3647-1
z	of	constraint	S	3647-1
S		sequential	z	3647-1
z	is	attribute	where maximal	3647-1
The last rule	selects	attribute	those	3647-2
that	are	attribute	maximal	3647-2
that	using	action	negation	3647-2
We	now show	action	the program	3648-1
the program		sequential	that	3648-1
that	defines	action	ins	3648-1
ins	for	constraint	some given sort τ	3648-1
some given sort τ		sequential	the variables	3648-1
the variables	of	constraint	sort	3648-1
the variables	are	attribute	sort	3648-1
sort		sequential	τ	3648-1
τ		sequential	}	3648-1
}	except	constraint	which	3648-1
}	for	constraint	which	3648-1
}	w	constraint	which	3648-1
which	of	constraint	sort τ	3648-1
which	is	attribute	sort τ	3648-1
sort τ		sequential	w	3648-1
w		sequential	y	3648-1
y		sequential	z	3648-1
z		sequential	not min-	3648-1
not min-		sequential	super	3648-1
super		sequential	w	3648-1
w		sequential	y	3648-1
y		sequential	z	3648-1
z		sequential	w	3648-1
w		sequential	y	3648-1
y		sequential	z	3648-1
z		sequential	super	3648-1
super		sequential	w	3648-1
w		sequential	y	3648-1
y		sequential	z′	3648-1
z′		sequential	z′ ⊆ z	3648-1
z′ ⊆ z		sequential	z′	3648-1
z′	=	sequential	z ins	3648-1
z ins		sequential	w	3648-1
w		sequential	y	3648-1
y		sequential	z	3648-1
We	that	constraint	we	3649-1
We	although	constraint	we	3649-1
We	note	action	we	3649-1
we	used	action	⊆	3649-1
⊆	in	constraint	the example	3649-1
the example	as	constraint	a predicate	3649-1
the example	in	constraint	a predicate	3649-1
the example	built	action	a predicate	3649-1
a predicate		sequential	it	3649-1
it	can be expressed	action	membership	3649-1
it	using	action	membership	3649-1
membership	and	conjunctive	stratified negation	3649-1
The proof	of	constraint	the next result	3650-1
the next result	but	conjunctive	the technique	3650-1
the next result	is omitted	action	the technique	3650-1
the next result	can be reconstructed reasonably easily	action	the technique	3650-1
the next result	using	action	the technique	3650-1
the technique	of	constraint	Example 20.6.3	3650-1
Theorem		sequential	20.6.4	3651-1
The preceding language	on	constraint	negation	3652-1
The preceding language	relies heavily	action	negation	3652-1
negation	to	constraint	the new sets	3652-1
negation	specify	action	the new sets	3652-1
We	could consider	action	set	3652-2
set	oriented	action	more constructs	3652-2
An example	is	attribute	the grouping construct	3652-3
the grouping construct		sequential	which	3652-3
which	to	constraint	the algebraic nest operation	3652-3
which	is	attribute	closely related	3652-3
<B>	For	constraint	instance	3652-4
instance	in	constraint	the language LDL	3652-4
the language LDL		sequential	the rule	3652-4
the rule		sequential	S	3652-4
S		sequential	x	3652-4
x		sequential	y	3652-4
y	←	sequential	R	3652-4
R		sequential	x	3652-4
x		sequential	y	3652-4
y		sequential	groups	3652-4
groups	in	constraint	S	3652-4
S	for	constraint	each x	3652-4
each x		sequential	all the y	3652-4
all the y	to	constraint	it	3652-4
all the y	s	attribute	related	3652-4
it	in	constraint	R	3652-4
R		sequential	S	3652-4
S	is	attribute	the result	3652-4
the result	of	constraint	the nesting	3652-4
the nesting	of	constraint	R	3652-4
R	on	constraint	the second coordinate	3652-4
The grouping construct	to	constraint	negation	3653-1
The grouping construct	can be used	action	negation	3653-1
The grouping construct	simulate	action	negation	3653-1
<B>	Consider	action	a query q	3653-2
a query q		sequential	whose input	3653-2
whose input	of	constraint	two unary relations	3653-2
whose input	consists	action	two unary relations	3653-2
two unary relations		sequential	R	3653-2
R		sequential	S	3653-2
S	not containing	action	some particular element	3653-2
some particular element	and	conjunctive	that	3653-2
that	computes	action	R S.	3653-2
R S.		sequential	Query q	3653-2
Query q	by	constraint	the following LDL program	3653-2
Query q	can be answered	action	the following LDL program	3653-2
the following LDL program		sequential	Temp	3653-2
Temp		sequential	x	3653-2
x	←	sequential	R	3653-2
R		sequential	x	3653-2
x		sequential	Temp	3653-2
Temp		sequential	x	3653-2
x		sequential	x	3653-2
x		sequential	S	3653-2
S		sequential	x	3653-2
x		sequential	T	3653-2
T		sequential	x	3653-2
x		sequential	y	3653-2
y		sequential	Temp	3653-2
Temp		sequential	x	3653-2
x		sequential	y	3653-2
y		sequential	Res	3653-2
Res		sequential	x	3653-2
<B>	From	constraint	the previous example	3654-1
the previous example		sequential	it	3654-1
it	that	constraint	programs	3654-1
it	is	attribute	clear	3654-1
programs	with	constraint	grouping	3654-1
grouping	be	attribute	need not monotone	3654-1
<B>	gives	action	rise	3654-2
rise	to	constraint	semantic problems	3654-2
semantic problems	to	constraint	negation	3654-2
semantic problems	of	constraint	negation	3654-2
One possiblity	in	constraint	LDL	3654-3
One possiblity	adopted	action	LDL	3654-3
LDL	to	constraint	the semantics	3654-3
LDL	is	attribute	the semantics	3654-3
LDL	define	action	the semantics	3654-3
the semantics	of	constraint	programs	3654-3
programs	with	constraint	grouping analogously	3654-3
grouping analogously	to	constraint	stratification	3654-3
stratification	for	constraint	negation	3654-3
Complex Values		sequential	Expressive Power	3655-1
Expressive Power	and	conjunctive	Complexity	3655-1
the expressive power	and	conjunctive	complexity	3655-2
complexity	of	constraint	ALG cv/ CALC cv	3655-2
ALG cv/ CALC cv	First is established	action	it	3655-2
it	is	attribute	the family	3655-2
the family	of	constraint	queries	3655-2
queries	in	constraint	hyperexponential time	3655-2
<B>		sequential	we	3656-1
we	consider	action	the expressive power	3656-1
the expressive power	of	constraint	ALG cv−/CALC cv−	3656-1
ALG cv−/CALC cv−	in	constraint	algebraic terms	3656-1
algebraic terms		sequential	the expressive power	3656-1
the expressive power	of	constraint	the nest operator	3656-1
the expressive power	permitting	action	the nest operator	3656-1
the nest operator	but	conjunctive	not powerset	3656-1
we	that	constraint	the nest operator	3656-2
we	Surprisingly show	action	the nest operator	3656-2
the nest operator	from	constraint	ALG cv− queries	3656-2
the nest operator	can be eliminated	action	ALG cv− queries	3656-2
ALG cv− queries	with	constraint	flat input	3656-2
flat input	/	sequential	ouput	3656-2
Complex Value Languages	and	conjunctive	Elementary Queries	3657-1
the notion	of	constraint	computable query	3657-2
computable query	to	constraint	the complex value model	3657-2
computable query	First is extended	action	the complex value model	3657-2
the complex value model	in	constraint	the straightforward manner	3657-2
The complexity class	of	constraint	interest	3657-3
interest	is	attribute	the class	3657-3
the class	of	constraint	elementary queries	3657-3
elementary queries	defined next	action	<B>	3657-3
The hyperexponential functions	hyp	action	i	3658-1
i	for	constraint	i	3658-1
i	in	constraint	N	3658-1
N	by	constraint	1	3658-1
N	are defined	action	1	3658-1
1		sequential	hyp 0	3658-1
hyp 0		sequential	m	3658-1
m	=	sequential	m	3658-1
m	and	conjunctive	<B>	3658-1
It	that	constraint	a query	3659-1
It	turns out	action	a query	3659-1
a query	in	constraint	ALG cv/CALC cv iff	3659-1
a query	is	attribute	ALG cv/CALC cv iff	3659-1
ALG cv/CALC cv iff		sequential	it	3659-1
it	is	attribute	an elementary query	3659-1
Theorem		sequential	20.7.1	3660-1
Crux		sequential	Crux	3661-1
All operations	in	constraint	polynomial time	3661-2
All operations	can be evaluated	action	polynomial time	3661-2
polynomial time	in	constraint	the size	3661-2
the size	of	constraint	their arguments	3661-2
their arguments	except	constraint	powerset	3661-2
their arguments	for	constraint	powerset	3661-2
powerset		sequential	which	3661-2
which	takes	action	exponential time	3661-2
<B>	Conversely let	action	q	3662-1
q	of	constraint	complexity	3662-1
q	be	attribute	complexity	3662-1
complexity		sequential	hyp	3662-1
hyp	n	conjunctive	<B>	3662-1
<B>	that	constraint	an enumeration	3663-1
<B>	Suppose first	action	an enumeration	3663-1
an enumeration	of	constraint	adom	3663-1
adom		sequential	I	3663-1
I	in	constraint	some binary relation	3663-1
I	is provided	action	some binary relation	3663-1
some binary relation		sequential	<B>	3663-1
<B>	Let	action	X0	3664-1
X0	=	sequential	adom	3664-1
adom		sequential	I	3664-1
I	for	constraint	i	3664-1
I	and	conjunctive	i	3664-1
i		sequential	Xi	3664-1
Xi	=	sequential	powerset	3664-1
powerset		sequential	Xi−1	3664-1
<B>	that	constraint	each Xi	3664-2
<B>	for	constraint	each Xi	3664-2
<B>	Observe	action	each Xi	3664-2
each Xi		sequential	we	3664-2
we	can provide	action	an enumeration	3664-2
an enumeration	as	constraint	<B>	3664-2
an enumeration	follows	action	<B>	3664-2
there	Clearly exists	action	a query	3664-3
a query	in	constraint	CALC cv+µ+	3664-3
CALC cv+µ+		sequential	that	3664-3
that	constructs	action	<B>	3664-3
we	Now view	action	each element	3665-1
each element	of	constraint	Xn	3665-1
Xn	as	constraint	an atomic element	3665-1
The input instance together	with	constraint	Xn	3665-2
Xn	and	conjunctive	the enumeration	3665-2
the enumeration	as	constraint	an ordered database	3665-2
the enumeration	can be seen	action	an ordered database	3665-2
an ordered database	with	constraint	size	3665-2
size		sequential	the order	3665-2
the order	of	constraint	hyp	3665-2
we		sequential	Finally can easily 3	3665-3
<B>	that	constraint	the union	3665-4
<B>	Observe	action	the union	3665-4
<B>	when considering	action	the union	3665-4
the union	of	constraint	hyperexponential complexities	3665-4
hyperexponential complexities		sequential	time	3665-4
time	and	conjunctive	space	3665-4
space	coincide	action	<B>	3665-4
<B>	to	constraint	complex values	3666-1
<B>	extend	action	complex values	3666-1
complex values		sequential	the result	3666-1
the result	from	constraint	the flat case	3666-1
the flat case		sequential	that	3666-1
that		sequential	CALC +µ+	3666-1
CALC +µ+	can express	action	qptime	3666-1
qptime	on	constraint	ordered databases	3666-1
ordered databases		sequential	Theorem	3666-1
Theorem		sequential	17.4.2	3666-1
CALC cv+µ+	Thus can also express	action	all qptime queries	3666-2
all qptime queries	on	constraint	ordered complex value databases	3666-2
ordered complex value databases		sequential	q	3666-2
q	in	constraint	CALC	3666-2
q	so can be computed	action	CALC	3666-2
CALC	cv+µ+ using	action	<B>	3666-2
<B>	To	constraint	the proof	3667-1
<B>	conclude	action	the proof	3667-1
the proof		sequential	it	3667-1
it	to	constraint	the restriction	3667-1
it	remains	action	the restriction	3667-1
it	remove	action	the restriction	3667-1
the restriction	on	constraint	the existence	3667-1
the existence	of	constraint	an enumeration	3667-1
an enumeration	of	constraint	the active domain	3667-1
<B>	Let	action	ϕ′	3667-2
ϕ′	be	attribute	the formula	3667-2
the formula	from	constraint	1	3667-2
the formula	by	constraint	1	3667-2
the formula	obtained	action	1	3667-2
the formula	replacing	action	1	3667-2
1		sequential	succ	3667-2
succ	by	constraint	some fresh variable y	3667-2
some fresh variable y		sequential	the sort	3667-2
the sort	of	constraint	y	3667-2
y	of	constraint	pairs	3667-2
y	is set	action	pairs	3667-2
pairs	and	conjunctive	2 each literal succ	3667-2
2 each literal succ		sequential	t	3667-2
t		sequential	t′	3667-2
t′	by	constraint	t	3667-2
t		sequential	∈	3667-2
∈		sequential	y	3667-2
q	by	constraint	<B>	3668-1
q	Then can be computed	action	<B>	3668-1
<B>		sequential	ψ	3669-1
ψ	is	attribute	the CALC cv formula	3669-1
the CALC cv formula	that	constraint	y	3669-1
the CALC cv formula	stating	action	y	3669-1
y	is	attribute	the representation	3669-1
the representation	in	constraint	a binary relation	3669-1
a binary relation	of	constraint	an enumeration	3669-1
an enumeration	of	constraint	the active domain	3669-1
<B>	that	constraint	it	3669-2
<B>	Observe	action	it	3669-2
it	to	constraint	CALC cv	3669-2
it	in	constraint	CALC cv	3669-2
it	is	attribute	easy	3669-2
it	state	action	CALC cv	3669-2
CALC cv	that	constraint	the content	3669-2
the content	of	constraint	a binary relation	3669-2
a binary relation	is	attribute	an enumeration	3669-2
<B>	On	constraint	the Power	3670-1
the Power	of	constraint	the nest Operator	3670-1
We	can exhibit	action	hierarchies	3670-2
hierarchies	of	constraint	classes	3670-2
classes	of	constraint	queries	3670-2
queries	in	constraint	CALC cv	3670-2
CALC cv	on	constraint	the set height	3670-2
CALC cv	based	action	the set height	3670-2
the set height	of	constraint	the sorts	3670-2
the sorts	of	constraint	variables	3670-2
variables	in	constraint	the query	3670-2
variables	used	action	the query	3670-2
<B>	For	constraint	example	3670-3
example	consider	action	all queries	3670-3
all queries		sequential	that	3670-3
that	as	constraint	input	3670-3
that	take	action	input	3670-3
input		sequential	a flat relational schema	3670-3
a flat relational schema	as	constraint	output	3670-3
a flat relational schema	and	conjunctive	output	3670-3
a flat relational schema	produce	action	output	3670-3
output		sequential	a flat relation	3670-3
<B>	for	constraint	Then each n	3670-4
A similar hierarchy	for	constraint	ALG cv	3670-5
A similar hierarchy	exists	action	ALG cv	3670-5
ALG cv	on	constraint	the sorts	3670-5
ALG cv	based	action	the sorts	3670-5
the sorts	of	constraint	intermediate types	3670-5
intermediate types	used	action	<B>	3670-5
these results	from	constraint	the use	3670-6
these results	Intuitively follow	action	the use	3670-6
the use	of	constraint	the powerset operator	3670-6
the powerset operator		sequential	which	3670-6
which	essentially provides	action	an additional exponential amount	3670-6
an additional exponential amount	of	constraint	scratch paper	3670-6
scratch paper	for	constraint	each additional level	3670-6
each additional level	of	constraint	set nesting	3670-6
The bottom	of	constraint	this hierarchy	3671-1
this hierarchy	is	attribute	simply relational calculus	3671-1
<B>	that	constraint	ALG cv−	3671-2
<B>	Recall	action	ALG cv−	3671-2
ALG cv−	can use	action	the nest operator	3671-2
the nest operator	but	conjunctive	not the powerset operator	3671-2
It	to	constraint	ALG cv−/	3671-3
It	is	attribute	thus natural	3671-3
It	ask	action	ALG cv−/	3671-3
ALG cv−/		sequential	CALC cv−	3671-3
CALC cv−	assuming	action	flat input	3671-3
flat input	and	conjunctive	output	3671-3
output	to	constraint	the relational calculus	3671-3
output	Where do lie	action	the relational calculus	3671-3
the relational calculus	and	conjunctive	the first level	3671-3
the first level	of	constraint	the hierarchy	3671-3
it	that	constraint	the nest operator alone	3671-4
it	Rather surprisingly turns out	action	the nest operator alone	3671-4
the nest operator alone	does not increase	action	expressive power	3671-4
we	that	constraint	flat input	3671-5
we	with	constraint	flat input	3671-5
we	Specifically show now	action	flat input	3671-5
flat input	and	conjunctive	output	3671-5
output		sequential	ALG cv− /CALC cv−	3671-5
ALG cv− /CALC cv−	to	constraint	relational calculus	3671-5
ALG cv− /CALC cv−	is	attribute	equivalent	3671-5
Theorem		sequential	20.7.2	3672-1
Crux		sequential	Crux	3673-1
<B>	In	constraint	terms	3673-2
terms	of	constraint	ALG cv−	3673-2
ALG cv−		sequential	the intuitive reason	3673-2
the intuitive reason	for	constraint	sets	3673-2
the intuitive reason	that	constraint	sets	3673-2
the intuitive reason	is	attribute	sets	3673-2
sets	in	constraint	only two ways	3673-2
sets	can be created	action	only two ways	3673-2
<B>	Thus created	action	sets	3674-1
sets	can be identified	action	some flat key	3674-1
sets	using	action	some flat key	3674-1
some flat key	of	constraint	bounded length	3674-1
The sets	in	constraint	the computation	3674-2
The sets	can be simulated	action	the computation	3674-2
the computation	by	constraint	their flat representations	3674-2
The proof	of	constraint	<B>	3674-3
The proof	consists	action	<B>	3674-3
The details	of	constraint	the proof	3675-1
the proof	are omitted	action	<B>	3675-1
<B>	that	constraint	an immediate consequence	3676-1
<B>	Observe	action	an immediate consequence	3676-1
an immediate consequence	of	constraint	the previous result	3676-1
the previous result	that	constraint	transitive closure	3676-1
the previous result	is	attribute	transitive closure	3676-1
transitive closure	or	conjunctive	powerset	3676-1
powerset	in	constraint	ALG cv−	3676-1
powerset	are	attribute	not expressible	3676-1
Remark		sequential	20.7.3	3677-1
The same technique	for	constraint	nonflat inputs	3677-2
The same technique	can be used	action	nonflat inputs	3677-2
An arbitrary input		sequential	I	3677-3
I	by	constraint	a flat database	3677-3
I	can be represented	action	a flat database	3677-3
an arbitrary ALG cv− query	on	constraint	I	3677-4
I	by	constraint	a relational query	3677-4
I	Now can be simulated	action	a relational query	3677-4
a relational query	on	constraint	a flat database	3677-4
a relational query	If	constraint	a flat database	3677-4
a relational query	to	constraint	a flat database	3677-4
a relational query	yield	action	a flat database	3677-4
a flat database	representing	action	the result	3677-4
the complex object result	in	constraint	polynomial time	3677-5
the complex object result	Finally is constructed	action	polynomial time	3677-5
<B>	in	constraint	ALG cv−	3677-6
<B>	that	constraint	ALG cv−	3677-6
<B>	shows	attribute	particular	3677-6
ALG cv−	in	constraint	ptime	3677-6
ALG cv−	is	attribute	ptime	3677-6
We	conclude	action	our discussion	3678-1
our discussion	of	constraint	languages	3678-1
languages	for	constraint	complex values	3678-1
complex values	with	constraint	a brief survey	3678-1
a brief survey	of	constraint	a fragment	3678-1
a fragment	of	constraint	the query language O2SQL	3678-1
the query language O2SQL	by	constraint	object	3678-1
the query language O2SQL	supported	action	object	3678-1
object	oriented	action	the commercial database system	3678-1
the commercial database system		sequential	O2	3678-1
O2	see	action	Chapter 21	3678-1
This fragment	provides	action	an elegant syntax	3678-2
an elegant syntax	for	constraint	deeply nested complex values	3678-2
an elegant syntax	and	conjunctive	deeply nested complex values	3678-2
an elegant syntax	accessing	action	deeply nested complex values	3678-2
an elegant syntax	constructing	action	deeply nested complex values	3678-2
deeply nested complex values	and	conjunctive	it	3678-2
it	into	constraint	a recent standard	3678-2
it	in	constraint	a recent standard	3678-2
it	has been incorporated	attribute	dustrial	3678-2
a recent standard	for	constraint	object	3678-2
object	oriented	action	databases	3678-2
<B>	For	constraint	the first example	3679-1
the first example		sequential	we	3679-1
we	recall	action	the query	3679-1
<B>	Using	action	the CINEMA database	3680-1
the CINEMA database		sequential	Fig	3680-1
this query	in	constraint	O2SQL	3680-2
this query	3.1 can be expressed	action	O2SQL	3680-2
O2SQL	as	constraint	element	3680-2
element		sequential	select tuple	3680-2
select tuple		sequential	t.address	3680-2
t.address		sequential	t.phone	3680-2
t.phone	from	constraint	t	3680-2
t	in	constraint	Location	3680-2
Location		sequential	t.name	3680-2
t.name		sequential	Le Champo	3680-2
Le Champo		sequential	select	3680-2
select	from	constraint	The clause	3680-2
The clause	has	action	semantics	3680-2
semantics	to	constraint	SQL	3680-2
semantics	for	constraint	SQL	3680-2
<B>	Unlike	constraint	SQL	3680-3
SQL		sequential	the select part	3680-3
the select part	can specify	action	an essentially arbitrary complex value	3680-3
an essentially arbitrary complex value		sequential	not just tuples	3680-3
select	from	constraint	A clause	3680-4
A clause	returns	action	a set4	3680-4
a set4		sequential	the keyword element here	3680-4
the keyword element here	is	attribute	a desetting operator	3680-4
a desetting operator		sequential	that	3680-4
that	returns	action	a runtime error	3680-4
a runtime error	if	constraint	the set	3680-4
the set	does not have	action	exactly one element	3680-4
The next example	illustrates	action	O2SQL	3681-1
O2SQL	inside	constraint	nested structures	3681-1
O2SQL	can work	action	nested structures	3681-1
<B>	Recall	action	the complex value	3681-2
the complex value	in	constraint	Fig	3681-2
the complex value	shown	action	Fig	3681-2
20.2		sequential	which	3681-3
which	represents	action	a portion	3681-3
a portion	of	constraint	the CINEMA database	3681-3
<B>	Let	action	the full complex value	3682-1
the full complex value	be named	action	Films	3682-1
The following query	returns	action	all movies	3682-2
all movies	for	constraint	which	3682-2
which		sequential	the director	3682-2
the director	as	constraint	an actor	3682-2
the director	does not participate	action	an actor	3682-2
<B>	select	action	m.	3683-1
<B>	Again using	action	the complex value Films	3683-2
the complex value Films	of	constraint	Fig	3683-2
<B>	20.2 gives	action	the set	3683-3
the set	of	constraint	all directors	3683-3
all directors		sequential	that	3683-3
that	in	constraint	any Hitchcock film	3683-3
that	have not acted	action	any Hitchcock film	3683-3
<B>	select	action	f.Director	3684-1
f.Director	from	constraint	f	3684-1
f	in	constraint	Films	3684-1
The keyword flatten	has	action	the effect	3684-2
the effect	of	constraint	the union	3684-2
the effect	forming	action	the union	3684-2
the union	of	constraint	these sets	3684-2
these sets	to	constraint	a set	3684-2
these sets	yield	action	a set	3684-2
a set	of	constraint	actors	3684-2
We	with	constraint	an illustration	3685-1
We	conclude	action	an illustration	3685-1
an illustration	of	constraint	O2SQL	3685-1
O2SQL	to	constraint	a deeply nested complex value	3685-1
O2SQL	can be used	action	a deeply nested complex value	3685-1
O2SQL	construct	action	a deeply nested complex value	3685-1
The following query	from	constraint	the complex value Films	3685-2
The following query	builds	action	the complex value Films	3685-2
the complex value Films	of	constraint	Fig	3685-2
20.2		sequential	a complex value	3685-3
a complex value	of	constraint	the same type	3685-3
the same type		sequential	that	3685-3
that	holds	action	information	3685-3
information	about	constraint	all movies	3685-3
all movies	for	constraint	which	3685-3
which		sequential	the director	3685-3
the director	as	constraint	an actor	3685-3
the director	does not serve	action	an actor	3685-3
<B>	select	action	tuple	3686-1
tuple		sequential	Director	3686-1
Director		sequential	f. Director	3686-1
f. Director		sequential	Movies	3686-1
Movies	select	action	tuple	3686-1
tuple		sequential	Title m. Title	3686-1
Title m. Title	from	constraint	a m.	3686-1
Title m. Title	in	constraint	a m.	3686-1
we	Furthermore do not include	action	the keyword	3687-1
the keyword	in	constraint	our queries	3687-1
our queries	although	constraint	it	3687-1
it	to	constraint	duplicates	3687-1
it	technically should be included	action	duplicates	3687-1
it	remove	action	duplicates	3687-1
duplicates	from	constraint	answer sets	3687-1
Complex Values Bibliographic Notes		sequential	Complex Values Bibliographic Notes	3688-1
Our presentation	by	constraint	AB88	3688-2
Our presentation	is strongly influenced	action	AB88	3688-2
An extensive coverage	of	constraint	the field	3688-3
the field	in	constraint	Hul87	3688-3
the field	can be found	action	Hul87	3688-3
The nested relation model	in	constraint	JS82	3688-4
The nested relation model	is studied	action	JS82	3688-4
JS82		sequential	TF86	3688-4
TF86		sequential	RKS88	3688-4
The V-relation model	in	constraint	BRS82	3688-5
The V-relation model	is studied	action	BRS82	3688-5
BRS82		sequential	AB86	3688-5
AB86		sequential	Ver89	3688-5
Ver89	and	conjunctive	normal form	3688-5
normal form		sequential	PNF	3688-5
PNF		sequential	the essentially equivalent partition nested relation model	3688-5
the essentially equivalent partition nested relation model	in	constraint	RKS88	3688-5
the essentially equivalent partition nested relation model	is studied	action	RKS88	3688-5
The connection	of	constraint	the PNF nested relations	3688-6
the PNF nested relations	with	constraint	dependencies	3688-6
dependencies	in	constraint	TF86	3688-6
dependencies	has also been studied	action	TF86	3688-6
TF86		sequential	OY87	3688-6
References		sequential	DM86a	3688-7
DM86a		sequential	DM92	3688-7
DM92	develop	action	while	3688-7
while	like	constraint	a language	3688-7
a language		sequential	that	3688-7
that	expresses	action	all computable queries	3688-7
all computable queries	in	constraint	the sense	3688-7
the sense	of	constraint	CH80 b	3688-7
CH80 b		sequential	<B>	3688-7
There	been	action	have many proposals	3689-1
have many proposals	of	constraint	algebras	3689-1
<B>	In	constraint	the earlier ones	3689-2
the earlier ones	have essentially	action	the power	3689-2
the power	of	constraint	ALG cv−	3689-2
ALG cv−	due to	constraint	obvious complexity considerations	3689-2
The powerset operation	for	constraint	the Logical Data Model	3689-3
The powerset operation	was first proposed	action	the Logical Data Model	3689-3
the Logical Data Model	of	constraint	KV84	3689-3
KV84		sequential	KV93	3689-3
KV93		sequential	b	3689-3
The calculus	in	constraint	this chapter	3690-1
The calculus	presented	action	this chapter	3690-1
this chapter	on	constraint	Jacobs	3690-1
this chapter	is	attribute	Jacobs	3690-1
this chapter	based	action	Jacobs	3690-1
Jacobs		sequential	calculus	3690-1
calculus		sequential	Jac82	3690-1
This original proposal	allowed	action	noncomputable queries	3690-2
noncomputable queries		sequential	Var83	3690-2
We	in	constraint	this chapter	3690-3
We	use	action	this chapter	3690-3
this chapter		sequential	a computable version	3690-3
a computable version	of	constraint	that calculus	3690-3
that calculus		sequential	that	3690-3
that	with	constraint	minor variations	3690-3
that	is also used	action	minor variations	3690-3
minor variations	in	constraint	KV84	3690-3
KV84		sequential	KV93	3690-3
KV93		sequential	b	3690-3
b		sequential	AB88	3690-3
AB88		sequential	RKS88	3690-3
RKS88		sequential	Hul87	3690-3
Parameterized queries	to	constraint	the commonly used mathematical concept	3691-1
Parameterized queries	are	attribute	close	3691-1
the commonly used mathematical concept	of	constraint	set comprehension	3691-1
The equivalence	of	constraint	the algebra	3692-1
the algebra	and	conjunctive	the calculus	3692-1
the calculus	in	constraint	AB88	3692-1
the calculus	has been shown	action	AB88	3692-1
An equivalence result	for	constraint	a more general model	3692-2
a more general model	in	constraint	KV84	3692-2
a more general model	had been previously given	action	KV84	3692-2
KV84		sequential	KV93	3692-2
KV93		sequential	b	3692-2
The equivalence result	with	constraint	oracles	3692-3
The equivalence result	is preserved	action	oracles	3692-3
<B>	In	constraint	it	3692-4
it	in	constraint	AB88	3692-4
it	is shown	action	AB88	3692-4
AB88	that	constraint	the algebra	3692-4
AB88	if	constraint	the algebra	3692-4
the algebra	and	conjunctive	the calculus	3692-4
the calculus	with	constraint	an identical set	3692-4
the calculus	are extended	action	an identical set	3692-4
an identical set	of	constraint	oracles	3692-4
oracles		sequential	sorted functions	3692-4
sorted functions		sequential	that	3692-4
that	are evaluated externally	action	the equivalence result	3692-4
the equivalence result	still holds	action	<B>	3692-4
strongly safe range		sequential	The calculus	3693-1
The calculus	and	conjunctive	the equivalence	3693-1
the equivalence	of	constraint	ALG cv−	3693-1
ALG cv−	and	conjunctive	CALC	3693-1
CALC		sequential	cv−	3693-1
cv−	on	constraint	AB88	3693-1
cv−	are based	action	AB88	3693-1
The fact	that	constraint	transitive closure	3694-1
transitive closure	in	constraint	the calculus	3694-1
transitive closure	can be computed	action	the calculus	3694-1
the calculus	in	constraint	AB88	3694-1
the calculus	was noted	action	AB88	3694-1
The result	that	constraint	any algebra query computing transitive closure	3695-1
any algebra query computing transitive closure	requires	action	exponential space	3695-1
exponential space	with	constraint	the straightforward evaluation model	3695-1
the straightforward evaluation model	in	constraint	SP94	3695-1
the straightforward evaluation model	was shown	action	SP94	3695-1
The equivalence	between	constraint	the calculus	3695-2
the calculus	and	conjunctive	rule	3695-2
rule	based	action	various languages	3695-2
various languages	from	constraint	AB88	3695-2
various languages	is	attribute	AB88	3695-2
<B>	In	constraint	the paradigm	3695-3
<B>	rule based	action	the paradigm	3695-3
the paradigm		sequential	nesting	3695-3
nesting	in	constraint	many ways	3695-3
nesting	can be expressed	action	many ways	3695-3
A main difference	between	constraint	various proposals	3695-4
various proposals	of	constraint	logic programming	3695-4
logic programming	with	constraint	a set construct	3695-4
a set construct	in	constraint	their approach	3695-4
a set construct	is	attribute	their approach	3695-4
their approach	to	constraint	nesting	3695-4
nesting		sequential	grouping	3695-4
grouping	in	constraint	LDL	3695-4
LDL		sequential	BNR+87	3695-4
BNR+87		sequential	data functions	3695-4
data functions	in	constraint	COL	3695-4
COL		sequential	AG91	3695-4
AG91	and	conjunctive	a form	3695-4
a form	of	constraint	universal quantification	3695-4
universal quantification	in	constraint	Kup87	3695-4
<B>	In	constraint	Kup88	3695-5
Kup88		sequential	equivalence	3695-5
equivalence	of	constraint	rule	3695-5
rule	based	action	various languages	3695-5
various languages	is proved	action	<B>	3695-5
<B>	In	constraint	GG88	3695-6
GG88		sequential	it	3695-6
it	that	constraint	various programming primitives	3695-6
it	is shown	action	various programming primitives	3695-6
various programming primitives	are	attribute	interchangeable	3695-6
powerset		sequential	fixpoint	3695-6
fixpoint		sequential	various iterators	3695-6
The correspondence	between	constraint	ALG cv/CALC cv queries	3696-1
ALG cv/CALC cv queries	and	conjunctive	elementary queries	3696-1
elementary queries	in	constraint	HS93	3696-1
elementary queries	is studied	action	HS93	3696-1
HS93		sequential	KV93a	3696-1
Hierarchies	of	constraint	classes	3696-2
classes	of	constraint	queries	3696-2
queries	on	constraint	the level	3696-2
queries	based	action	the level	3696-2
the level	of	constraint	set nesting	3696-2
set nesting	in	constraint	HS93	3696-2
set nesting	are considered	action	HS93	3696-2
HS93		sequential	KV93a	3696-2
Related work	in	constraint	Lie89a	3696-3
Related work	is presented	action	Lie89a	3696-3
Exact complexity characterizations	with	constraint	fixpoint	3696-4
Exact complexity characterizations	are obtained	action	fixpoint	3696-4
fixpoint		sequential	which	3696-4
which	is	attribute	no longer redundant	3696-4
the level	of	constraint	set nesting	3696-4
set nesting	when is bounded	action	GV91	3696-4
Theorem 20.7.2	from	constraint	PG88	3697-1
Theorem 20.7.2	is	attribute	PG88	3697-1
PG88		sequential	which	3697-1
which	uses	action	a proof	3697-1
a proof	on	constraint	a strongly safe calculus	3697-1
a proof	based	action	a strongly safe calculus	3697-1
Exercises		sequential	Exercises	3698-1
Reference		sequential	BTBW92	3699-1
BTBW92	introduces	action	a rich family	3699-1
a rich family	of	constraint	languages	3699-1
languages	for	constraint	complex objects	3699-1
complex objects	to	constraint	lists	3699-1
complex objects	extended	action	lists	3699-1
complex objects	include	action	lists	3699-1
lists	and	conjunctive	bags	3699-1
bags		sequential	that	3699-1
that	on	constraint	structural recursion	3699-1
that	is based	action	structural recursion	3699-1
One language	in	constraint	this family	3699-2
this family	to	constraint	the nested algebra	3699-2
this family	corresponds	action	the nested algebra	3699-2
the nested algebra	in	constraint	this chapter	3699-2
the nested algebra	presented	action	this chapter	3699-2
<B>	Using	attribute	this	3699-3
an elegant family	of	constraint	generalizations	3699-3
generalizations	of	constraint	Theorem 20.7.2	3699-3
Theorem 20.7.2	in	constraint	Won93	3699-3
Theorem 20.7.2	is developed	action	Won93	3699-3
Exercises Exercise		sequential	20.1	3700-1
we	→	sequential	the fd A B	3701-1
we	Furthermore impose	action	the fd A B	3701-1
the fd A B		sequential	the generalization	3701-1
the generalization	of	constraint	a functional dependency	3701-1
<B>		sequential	<B>	3701-2
<B>		sequential	<B>	3701-3
One	with	constraint	some coding	3701-4
One	suffices	action	some coding	3701-4
<B>	c Formalize	action	the notion	3701-5
the notion	of	constraint	V-relation	3701-5
V-relation	of	constraint	Section 20.1	3701-5
Exercise 20.2	Consider	attribute	flat	3702-1
a relation		sequential	R	3702-1
R	of	constraint	sort name age address	3702-1
sort name age address		sequential	car child	3702-1
car child	_	sequential	name child	3702-1
name child	_	sequential	age	3702-1
age	in	constraint	a complex value relation	3702-1
age	can be stored	action	a complex value relation	3702-1
a complex value relation	of	constraint	sort name	3702-1
sort name		sequential	age	3702-1
age		sequential	address	3702-1
address		sequential	cars	3702-1
cars		sequential	dom	3702-1
dom		sequential	}	3702-1
}		sequential	children	3702-1
children		sequential	child	3702-1
child		sequential	name	3702-1
name		sequential	child age	3702-1
child age	_	sequential	the advantages	3702-1
child age	Discuss	action	the advantages	3702-1
the advantages	of	constraint	this alternative representation	3702-1
<B>	In	constraint	the same data	3702-2
<B>	that	constraint	the same data	3702-2
<B>	for	constraint	the same data	3702-2
<B>	show	action	the same data	3702-2
the same data		sequential	the size	3702-2
the size	of	constraint	the instance	3702-2
the instance	in	constraint	the second representation	3702-2
the second representation	is	attribute	smaller	3702-2
<B>	Also consider	action	update anomalies	3702-3
Exercise		sequential	20.3	3703-1
20.3	Consider	action	the value	3703-1
<B>	to	constraint	it	3704-1
<B>	Show	action	it	3704-1
<B>	construct	action	it	3704-1
it	in	constraint	the core algebra	3704-1
the core algebra	from	constraint	a }	3704-1
a }	and	conjunctive	b	3704-1
b		sequential	}	3704-1
Exercise		sequential	20.4	3705-1
Complex Values Exercise		sequential	20.5	3706-1
Exercise		sequential	20.6	3707-1
Hint		sequential	Hint	3707-2
Exercise		sequential	20.7	3708-1
<B>	In	constraint	each case	3708-2
each case	that	constraint	the operation	3708-2
each case	prove	action	the operation	3708-2
the operation	in	constraint	ALG cv	3708-2
the operation	is	attribute	expressible	3708-2
Which	of	constraint	powerset	3709-1
Which	without	constraint	powerset	3709-1
Which	can be expressed	action	powerset	3709-1
Exercise		sequential	20.8	3710-1
Exercise		sequential	20.9	3711-1
Then map C		sequential	q	3712-1
q		sequential	I	3712-1
I	=	sequential	C	3712-1
C		sequential	q	3712-1
q		sequential	I1	3712-1
I1		sequential	C′	3712-1
C′		sequential	J1	3712-1
J1		sequential	C	3712-1
C		sequential	q	3712-1
q		sequential	I2	3712-1
I2		sequential	C′	3712-1
C′		sequential	J2	3712-1
J2		sequential	C	3712-1
C		sequential	q	3712-1
q		sequential	I3	3712-1
I3		sequential	C′ J3 }	3712-1
Exercise		sequential	20.10	3713-1
Exercise		sequential	20.11	3714-1
<B>	that	constraint	the expressive power	3714-2
<B>	Prove	attribute	this	3714-2
<B>	does not modify	action	the expressive power	3714-2
the expressive power	of	constraint	the language	3714-2
<B>	in	constraint	the calculus terms	3714-3
<B>	consider	action	the calculus terms	3714-3
<B>	introducing	action	the calculus terms	3714-3
the calculus terms	of	constraint	the form q	3714-3
the form q		sequential	t1	3714-3
<B>	.	sequential	<B>	3714-4
<B>	.	sequential	<B>	3714-5
tn		sequential	q	3714-6
q	is	attribute	where an n-ary algebraic operation	3714-6
where an n-ary algebraic operation	and	conjunctive	the ti	3714-6
the ti	are	attribute	set terms	3714-6
set terms	of	constraint	appropriate sort	3714-6
Exercise		sequential	20.12	3715-1
<B>	Give	action	the same queries	3715-2
the same queries	in	constraint	CALC cv	3715-2
Exercises Exercise 20.13		sequential	Exercises Exercise 20.13	3716-1
<B>	Complete	action	the proof	3716-2
the proof	of	constraint	Last Stage	3716-2
Last Stage	for	constraint	Theorem 20.5.1	3716-2
Exercise		sequential	20.14	3717-1
<B>	In	constraint	the details	3717-2
<B>	give	action	the details	3717-2
the details	of	constraint	<B>	3717-2
Exercise		sequential	20.15	3718-1
Exercise		sequential	20.16	3719-1
Exercise		sequential	20.17	3720-1
Exercise		sequential	20.18	3721-1
Exercise		sequential	20.19	3722-1
<B>	that	constraint	it	3722-2
<B>	Show	action	it	3722-2
it	does not have	action	more power	3722-2
more power	than	constraint	ALG cv	3722-2
<B>	Exercise	action	20.20	3723-1
20.20	Consider	action	a query q	3723-1
a query q		sequential	whose input	3723-1
whose input	of	constraint	two relations	3723-1
whose input	consists	action	two relations	3723-1
two relations	of	constraint	sort A	3723-1
sort A		sequential	B	3723-1
B	of	constraint	two graphs	3723-1
B	consists	action	two graphs	3723-1
Query q	returns	action	a relation	3723-2
a relation	of	constraint	sort A	3723-2
sort A		sequential	B	3723-2
B		sequential	dom	3723-2
dom		sequential	}	3723-2
}	with	constraint	the following meaning	3723-2
tuple x		sequential	A X	3723-3
A X	in	constraint	the result	3723-3
A X	is	attribute	the result	3723-3
the result	if	constraint	x	3723-3
x	is	attribute	a vertex	3723-3
a vertex	and	conjunctive	X	3723-3
X	is	attribute	the set	3723-3
the set	of	constraint	vertexes	3723-3
vertexes	y	constraint	there	3723-3
vertexes	that	constraint	there	3723-3
there	exists	action	a path	3723-3
a path	from	constraint	y	3723-3
a path	to	constraint	y	3723-3
y	and	conjunctive	x edges	3723-3
y	alternating	attribute	blue	3723-3
<B>	in	constraint	one line	3723-4
<B>	Prove	action	one line	3723-4
one line	that	constraint	q	3723-4
q	in	constraint	ALG cv	3723-4
q	is	attribute	expressible	3723-4
<B>	to	constraint	q	3723-5
<B>	Show	action	q	3723-5
<B>	express	action	q	3723-5
q	in	constraint	some complex value language	3723-5
some complex value language	of	constraint	this chapter	3723-5
<B>	Exercise	action	20.21	3724-1
20.21	Generalize	action	the construction	3724-1
the construction	of	constraint	Example 20.6.2	3724-1
Example 20.6.2	to	constraint	Theorem 20.6.1	3724-1
Example 20.6.2	prove	action	Theorem 20.6.1	3724-1
Exercise		sequential	20.22	3725-1
<B>	Is	action	the situation	3725-2
the situation	for	constraint	datalog cv	3725-2
datalog cv	with	constraint	negation	3725-2
Exercise		sequential	20.23	3726-1
Exercise		sequential	20.24	3727-1
<B>	Let	action	whilecv	3728-1
whilecv	while	constraint	N	3728-1
whilecv	be like	action	N	3728-1
N		sequential	N	3728-1
N	except	constraint	the relational algebra expressions	3728-1
N	that	constraint	the relational algebra expressions	3728-1
the relational algebra expressions	in	constraint	ALG cv	3728-1
the relational algebra expressions	are	attribute	ALG cv	3728-1
<B>	that	constraint	whilecv	3728-2
<B>	Prove	action	whilecv	3728-2
whilecv	can express	action	all queries	3728-2
all queries	from	constraint	flat relations	3728-2
flat relations	to	constraint	flat relations	3728-2
N Minkisi	are	attribute	complex objects	3729-1
complex objects		sequential	clearly not the product	3729-1
clearly not the product	of	constraint	im	3729-1
im		sequential	a momentary pulse	3729-1
<B>	.	sequential	<B>	3729-2
<B>	.	sequential	<B>	3729-3
<B>	.	sequential	<B>	3729-4
<B>	To	constraint	justice	3729-5
<B>	do	action	justice	3729-5
justice	to	constraint	objects	3729-5
objects		sequential	a theory	3729-5
a theory	of	constraint	them	3729-5
them	as	constraint	them	3729-5
them	be	attribute	must as complex	3729-5
What	is	attribute	1 a Minkisi	3729-6
Sergio		sequential	Sergio	3730-1
Riccardo		sequential	Riccardo	3731-1
Inthischapter		sequential	weprovideabriefintroductiontoobject-orienteddatabases	3732-1
weprovideabriefintroductiontoobject-orienteddatabases		sequential	OODBs	3732-1
<B>	On	constraint	the one hand	3732-2
the one hand		sequential	we	3732-2
we	that	constraint	the most basic issues	3732-2
we	of	constraint	the most basic issues	3732-2
we	shall see	attribute	some	3732-2
the most basic issues	concerning	action	OODBs	3732-2
OODBs		sequential	the design	3732-2
the design	of	constraint	query languages	3732-2
query languages	or	conjunctive	the analysis	3732-2
the analysis	of	constraint	their expressive power	3732-2
their expressive power	can be largely resolved	action	techniques	3732-2
their expressive power	using	action	techniques	3732-2
techniques	in	constraint	connection	3732-2
techniques	already developed	action	connection	3732-2
connection	with	constraint	the value models	3732-2
connection	and	conjunctive	the value models	3732-2
<B>	On	constraint	the other hand	3732-3
the other hand		sequential	the presence	3732-3
the presence	of	constraint	new features	3732-3
new features		sequential	object identifiers	3732-3
object identifiers	and	conjunctive	methods	3732-3
methods	about	constraint	new questions	3732-3
methods	brings	action	new questions	3732-3
new questions	and	conjunctive	techniques	3732-3
This chapter	with	constraint	an informal presentation	3733-1
This chapter	begins	action	an informal presentation	3733-1
an informal presentation	of	constraint	the underlying constructs	3733-1
the underlying constructs	of	constraint	OODBs	3733-1
a formal definition	for	constraint	a particular OODB model	3733-2
a particular OODB model	Next is presented	action	<B>	3733-2
Two directions	of	constraint	theoretical research	3733-3
theoretical research	into	constraint	OODBs	3733-3
OODBs	are discussed	action	<B>	3733-3
First a family	of	constraint	languages 1	3733-4
languages 1	with	constraint	permission	3733-4
languages 1	Reprinted	action	permission	3733-4
Smithsonian Institution Press © 1993		sequential	Smithsonian Institution Press © 1993	3733-5
<B>	for	constraint	data access	3734-1
data access	with	constraint	an emphasis	3734-1
data access	is presented	action	an emphasis	3734-1
an emphasis	on	constraint	the languages	3734-1
the languages	with	constraint	the novel modeling constructs	3734-1
the languages	interact	action	the novel modeling constructs	3734-1
the novel modeling constructs	of	constraint	particular interest	3734-1
particular interest	is	attribute	the impact	3734-1
the impact	of	constraint	the notion	3734-1
the impact	generalizing	action	the notion	3734-1
the notion	of	constraint	complete query language	3734-1
complete query language	to	constraint	the presence	3734-1
complete query language	accommodate	action	the presence	3734-1
the presence	of	constraint	object identifiers	3734-1
object identifiers		sequential	OIDs	3734-1
Next two languages	for	constraint	methods	3734-2
methods	are described	action	<B>	3734-2
<B>	is	attribute	an imperative language	3734-3
an imperative language	allowing	action	us	3734-3
us	to	constraint	methods	3734-3
us	specify	action	methods	3734-3
methods	with	constraint	side effects	3734-3
<B>	In	constraint	both cases	3735-1
both cases		sequential	we	3735-1
we	present	action	some results	3735-1
some results	on	constraint	type safety	3735-1
type safety	and	conjunctive	expressive power	3735-1
<B>	Checking	action	type safety	3735-2
type safety	is	attribute	generally undecidable	3735-2
we	identify	action	a significant portion	3735-2
a significant portion	of	constraint	the functional language	3735-2
the functional language		sequential	monadic method schemas	3735-2
monadic method schemas	for	constraint	which	3735-2
which		sequential	type safety	3735-2
type safety	is	attribute	decidable	3735-2
<B>	With	constraint	respect	3735-3
respect	to	constraint	expressive power	3735-3
expressive power		sequential	the imperative language	3735-3
the imperative language	in	constraint	an extended sense	3735-3
the imperative language	is	attribute	complete	3735-3
an extended sense	in	constraint	this chapter	3735-3
an extended sense	formalized	action	this chapter	3735-3
The functional language	expresses	action	precisely qptime	3736-1
precisely qptime	on	constraint	ordered inputs	3736-1
ordered inputs	to	constraint	the fixpoint queries	3736-1
ordered inputs	by	constraint	the fixpoint queries	3736-1
ordered inputs	and	conjunctive	the fixpoint queries	3736-1
ordered inputs	so turns out	attribute	now famous	3736-1
ordered inputs	express	attribute	now famous	3736-1
The chapter	with	constraint	a brief survey	3736-2
The chapter	concludes	action	a brief survey	3736-2
a brief survey	of	constraint	additional research issues	3736-2
additional research issues	by	constraint	OODBs	3736-2
additional research issues	raised	action	OODBs	3736-2
Object	oriented	action	Informal Presentation database models	3737-1
Informal Presentation database models	from	constraint	a synthesis	3737-1
Informal Presentation database models	stem	action	a synthesis	3737-1
a synthesis	of	constraint	three worlds	3737-1
three worlds		sequential	the complex value model	3737-1
the complex value model		sequential	semantic database models	3737-1
semantic database models	and	conjunctive	object	3737-1
object	oriented	action	programming concepts	3737-1
<B>	At	constraint	the time	3737-2
the time	of	constraint	writing	3737-2
writing		sequential	there	3737-2
there	is not	action	widespread agreement	3737-2
widespread agreement	on	constraint	a specific OODB model	3737-2
a specific OODB model	on	constraint	what components	3737-2
a specific OODB model	nor	conjunctive	what components	3737-2
what components	to	constraint	an OODB model	3737-2
what components	even are required	action	an OODB model	3737-2
what components	constitute	action	an OODB model	3737-2
<B>	In	constraint	this section	3737-3
this section		sequential	we	3737-3
we	on	constraint	seven important ingredients	3737-3
we	shall focus	action	seven important ingredients	3737-3
seven important ingredients	of	constraint	OODB models	3737-3
<B>	In	constraint	this section	3738-1
this section		sequential	we	3738-1
we	and	conjunctive	these interrelated notions	3738-1
we	describe informally	action	these interrelated notions	3738-1
we	illustrate	action	these interrelated notions	3738-1
these interrelated notions		sequential	a more formal definition	3738-1
a more formal definition	in	constraint	the following section	3738-1
a more formal definition	is presented	action	the following section	3738-1
We	will also briefly discuss	action	alternatives	3738-2
Object Databases	create	action	schema PariscopeSchema	3739-1
schema PariscopeSchema	create	action	base PariscopeBase	3739-1
base PariscopeBase		sequential	class Person type tuple	3739-1
class Person type tuple		sequential	name	3739-1
name		sequential	string	3739-1
string		sequential	citizenship	3739-1
citizenship		sequential	string	3739-1
string		sequential	gender	3739-1
gender		sequential	string	3739-1
string		sequential	class Director	3739-1
class Director	inherit	action	Person type tuple	3739-1
Person type tuple		sequential	directs	3739-1
directs		sequential	set	3739-1
set		sequential	Movie	3739-1
Movie		sequential	class Actor	3739-1
class Actor		sequential	inherit Person type tuple	3739-1
inherit Person type tuple		sequential	acts_in	3739-1
acts_in		sequential	Movie	3739-1
Movie		sequential	}	3739-1
}		sequential	class Actor	3739-1
class Actor		sequential	Director inherit Director	3739-1
Director inherit Director		sequential	Actor class	3739-1
<B>	When performing	action	this update	3739-2
this update		sequential	there	3739-2
there	conceptually is	action	a break	3739-2
a break	in	constraint	the continuity	3739-2
the continuity	in	constraint	the representation	3739-2
the representation	of	constraint	the person	3739-2
care	to	constraint	all tuples	3739-3
care	Furthermore must be taken	action	all tuples	3739-3
care	update	action	all tuples	3739-3
all tuples	in	constraint	a number	3739-3
all tuples	typically arising	action	a number	3739-3
a number	of	constraint	different relations	3739-3
different relations		sequential	that	3739-3
that	to	constraint	this person	3739-3
that	refer	action	this person	3739-3
this person	to	constraint	the change	3739-3
this person	reflect	action	the change	3739-3
the change	of	constraint	name	3739-3
<B>	Following	action	the spirit	3740-1
the spirit	of	constraint	semantic data models	3740-1
semantic data models		sequential	OODB models	3740-1
OODB models	permit	action	the explicit representation	3740-1
the explicit representation	of	constraint	objects	3740-1
the explicit representation	and	conjunctive	objects	3740-1
objects	through	constraint	the use	3740-1
the use	of	constraint	object identifiers	3740-1
object identifiers		sequential	OIDs	3740-1
a unique OID	to	constraint	each object	3741-1
a unique OID	Conceptually is assigned	action	each object	3741-1
each object		sequential	that	3741-1
that	in	constraint	the database	3741-1
that	is represented	action	the database	3741-1
the database	and	conjunctive	this association	3741-1
this association	between	constraint	OID	3741-1
OID	and	conjunctive	object	3741-1
object	as	constraint	even attributes	3741-1
object	remains	action	even attributes	3741-1
object	fixed	action	even attributes	3741-1
even attributes	of	constraint	the object	3741-1
the object		sequential	name	3741-1
name	or	conjunctive	age	3741-1
age		sequential	change	3741-1
change	in	constraint	value	3741-1
The use	of	constraint	objects	3741-2
objects	and	conjunctive	OIDs	3741-2
OIDs	permits	action	OODBs	3741-2
OODBs	to	constraint	information	3741-2
OODBs	share gracefully	action	information	3741-2
information		sequential	a given object	3741-2
a given object		sequential	o	3741-2
o	by	constraint	many other objects	3741-2
o	is easily shared	action	many other objects	3741-2
many other objects	by	constraint	the OID	3741-2
many other objects	simply referencing	action	the OID	3741-2
the OID	of	constraint	<B>	3741-2
the OID	o	constraint	<B>	3741-2
<B>	in	constraint	the context	3741-3
<B>	is	attribute	especially important	3741-3
the context	of	constraint	updates	3741-3
updates	for	constraint	example	3741-3
example		sequential	the name	3741-3
the name	of	constraint	a person object	3741-3
a person object	o	constraint	need	3741-3
need	in	constraint	only one place	3741-3
need	be changed	action	only one place	3741-3
only one place	if	constraint	o	3741-3
o	by	constraint	many parts	3741-3
o	even is shared	action	many parts	3741-3
many parts	of	constraint	the database	3741-3
<B>	In	constraint	an OODB	3742-1
an OODB		sequential	a complex value	3742-1
a complex value	with	constraint	each object	3742-1
a complex value	is associated	action	each object	3742-1
This complex value	may involve	action	printables	3742-2
printables	and	conjunctive	OIDs	3742-2
printables	or	conjunctive	OIDs	3742-2
OIDs		sequential	references	3742-2
references	to	constraint	objects	3742-2
references	or	conjunctive	objects	3742-2
<B>	For	constraint	example	3742-3
example		sequential	each object	3742-3
each object	in	constraint	the class Movie	3742-3
the class Movie	in	constraint	Fig	3742-3
21.1	has	action	an associated triple	3742-4
an associated triple		sequential	whose second coordinate	3742-4
whose second coordinate	contains	action	a set	3742-4
a set	of	constraint	OIDs	3742-4
OIDs	to	constraint	actors	3742-4
OIDs	corresponding	action	actors	3742-4
<B>	In	constraint	this section	3742-5
this section		sequential	we	3742-5
we	on	constraint	complex values	3742-5
we	focus	action	complex values	3742-5
complex values	constructed	action	tuple	3742-5
complex values	using	action	tuple	3742-5
tuple	and	conjunctive	set	3742-5
set		sequential	the construct	3742-5
<B>	In	constraint	practical OODB models	3742-6
practical OODB models		sequential	other constructs	3742-6
other constructs	for	constraint	example	3742-6
other constructs	are also supported	action	example	3742-6
other constructs	including	action	example	3742-6
example		sequential	bags	3742-6
bags	and	conjunctive	lists	3742-6
Some commercial OODBs	on	constraint	an extension	3742-7
Some commercial OODBs	are based	action	an extension	3742-7
an extension	of	constraint	C++	3742-7
C++		sequential	that	3742-7
that	supports	action	persistence	3742-7
persistence	in	constraint	these models essentially	3742-7
these models essentially		sequential	any C++ structure	3742-7
any C++ structure	as	constraint	the value	3742-7
any C++ structure	can serve	action	the value	3742-7
the value	with	constraint	an object	3742-7
the value	associated	action	an object	3742-7
Objects		sequential	that	3743-1
that	have	action	complex values	3743-1
complex values	with	constraint	the same type	3743-1
the same type	into	constraint	classes	3743-1
the same type	may be grouped	action	classes	3743-1
classes	as	constraint	semantic data models	3743-1
classes	in	constraint	semantic data models	3743-1
classes	happens	action	semantic data models	3743-1
<B>	In	constraint	the running example	3743-2
the running example	include	action	Person	3743-2
Person		sequential	Director	3743-2
Director	and	conjunctive	Movie	3743-2
Classes	as	constraint	a natural focal point	3743-3
Classes	also serve	action	a natural focal point	3743-3
a natural focal point	for	constraint	the components	3743-3
a natural focal point	of	constraint	the components	3743-3
a natural focal point	or	conjunctive	the components	3743-3
a natural focal point	associating	attribute	some	3743-3
the components	of	constraint	a database application	3743-3
<B>	by	constraint	each class	3743-4
<B>	with	constraint	each class	3743-4
<B>	is accomplished	action	each class	3743-4
<B>	associating	action	each class	3743-4
each class		sequential	a family	3743-4
a family	of	constraint	methods	3743-4
methods	for	constraint	that class	3743-4
Methods	be	attribute	might simple	3743-5
Methods	e.g. producing	action	the name	3743-5
the name	of	constraint	a person	3743-5
a person	or	conjunctive	a representation	3743-5
a person	displaying	action	a representation	3743-5
a representation	of	constraint	an object	3743-5
an object	to	constraint	a graphical interface	3743-5
a graphical interface	or	conjunctive	a stress analysis	3743-5
a graphical interface	performing	action	a stress analysis	3743-5
a stress analysis	of	constraint	a proposed wing design	3743-5
<B>	In	constraint	OODB models	3744-1
OODB models		sequential	there	3744-1
there	are	attribute	two important implications	3744-1
two important implications	of	constraint	the statement	3744-1
the statement		sequential	that class c′	3744-1
that class c′	is	attribute	a subclass	3744-1
a subclass	of	constraint	c	3744-1
it	that	constraint	there	3745-1
it	if	constraint	there	3745-1
it	Second is required	action	there	3745-1
there	is	attribute	a method	3745-1
a method	with	constraint	name m	3745-1
name m	with	constraint	c	3745-1
name m	associated	action	c	3745-1
c		sequential	there	3745-1
there	is also	action	a method	3745-1
a method	with	constraint	name m	3745-1
name m	with	constraint	c′	3745-1
name m	associated	action	c′	3745-1
<B>	In	constraint	some cases	3745-2
some cases		sequential	the implementation	3745-2
the implementation		sequential	the actual code	3745-2
the actual code	of	constraint	m	3745-2
m	for	constraint	c′	3745-2
c′	to	constraint	c	3745-2
c′	for	constraint	c	3745-2
c′	is	attribute	identical	3745-2
c	in	constraint	this case	3745-2
this case		sequential	the code not Object Databases	3745-2
the code not Object Databases	of	constraint	m	3745-2
m	for	constraint	c′ need	3745-2
c′ need	because	constraint	it	3745-2
c′ need	be explicitly specified	action	it	3745-2
it	from	constraint	c	3745-2
it	is inherited	action	c	3745-2
21.1		sequential	21.1	3745-3
The determination	of	constraint	what implementation	3745-4
what implementation	with	constraint	a given method name	3745-4
what implementation	is associated	action	a given method name	3745-4
a given method name	and	conjunctive	class	3745-4
class	is called	action	method resolution	3745-4
A method	with	constraint	respect	3745-5
A method	is invoked	action	respect	3745-5
respect	to	constraint	an object o	3745-5
an object o	and	conjunctive	the class	3745-5
the class	to	constraint	which	3745-5
which	o	constraint	which implementation	3745-5
which	belongs	action	which implementation	3745-5
which	determines	action	which implementation	3745-5
which implementation	to	constraint	<B>	3745-5
which implementation	is be used	action	<B>	3745-5
This policy	is called	action	dynamic binding	3745-6
<B>	As	constraint	we	3745-7
we	shall see	action	the interaction	3745-7
the interaction	of	constraint	method calls	3745-7
method calls	and	conjunctive	dynamic binding	3745-7
dynamic binding	in	constraint	type	3745-7
dynamic binding	makes	action	type	3745-7
type	for	constraint	OODB schemas undecidable	3745-7
type	checking	action	OODB schemas undecidable	3745-7
It	to	constraint	such a schema	3745-8
It	whether	constraint	such a schema	3745-8
It	is	attribute	undecidable	3745-8
It	check	action	such a schema	3745-8
such a schema	to	constraint	a runtime type error	3745-8
such a schema	would lead	action	a runtime type error	3745-8
a runtime type error	on	constraint	the other hand	3745-8
the other hand		sequential	it	3745-8
it	to	constraint	decidable sufficient conditions	3745-8
it	is	attribute	clearly possible	3745-8
it	find	action	decidable sufficient conditions	3745-8
decidable sufficient conditions		sequential	that	3745-8
that	that	constraint	no such error	3745-8
that	will guarantee	action	no such error	3745-8
no such error	can arise	action	<B>	3745-8
<B>	In	constraint	the particular OODB model	3746-1
the particular OODB model	presented here	action	both values	3746-1
both values	in	constraint	the style	3746-1
the style	of	constraint	complex values	3746-1
complex values	and	conjunctive	objects	3746-1
objects	are supported	action	<B>	3746-1
<B>	For	constraint	example	3746-2
example	in	constraint	Fig	3746-2
a persistent set	of	constraint	triples	3746-3
triples	called	action	Pariscope	3746-3
Pariscope	21.1 is supported	action	Fig	3746-3
Pariscope	see also	action	Fig	3746-3
11.1		sequential	11.1	3746-4
The introduction	of	constraint	values	3746-5
values	with	constraint	OIDs	3746-5
values	not directly associated	action	OIDs	3746-5
OIDs	is	attribute	a departure	3746-5
a departure	from	constraint	the tradition	3746-5
the tradition	of	constraint	object	3746-5
object	oriented	action	programming	3746-5
programming	and	conjunctive	not all OODBs	3746-5
not all OODBs	in	constraint	the literature	3746-5
the literature	support	action	it	3746-5
<B>	in	constraint	databases	3746-6
databases		sequential	the use	3746-6
the use	of	constraint	explicit values	3746-6
explicit values	However often simplifies	action	the design	3746-6
the design	and	conjunctive	use	3746-6
use	of	constraint	a schema	3746-6
Their presence	also facilitates	action	queries	3746-7
Their presence	expressing	action	queries	3746-7
queries	in	constraint	a declarative manner	3746-7
The important principle	of	constraint	encapsulation	3747-1
encapsulation	in	constraint	object orientation	3747-1
object orientation	from	constraint	the field	3747-1
object orientation	stems	action	the field	3747-1
the field	of	constraint	abstract data types	3747-1
Encapsulation	to	constraint	a sharp boundary	3747-2
Encapsulation	is used	action	a sharp boundary	3747-2
Encapsulation	provide	action	a sharp boundary	3747-2
a sharp boundary	between	constraint	information	3747-2
information	about	constraint	objects	3747-2
objects	by	constraint	database users	3747-2
objects	how is accessed	action	database users	3747-2
database users	and	conjunctive	that information	3747-2
that information	and	conjunctive	<B>	3747-2
that information	how is actually stored	action	<B>	3747-2
that information	provided	action	<B>	3747-2
The principle	of	constraint	encapsulation	3747-3
encapsulation	if	constraint	we	3747-3
encapsulation	is most easily understood	action	we	3747-3
we	distinguish	action	two categories	3747-3
two categories	of	constraint	database use	3747-3
database use		sequential	dba mode	3747-3
dba mode		sequential	which	3747-3
which	to	constraint	activities	3747-3
which	refers	action	activities	3747-3
activities	to	constraint	database administrators	3747-3
database administrators	and	conjunctive	the database schema	3747-3
database administrators	including	action	the database schema	3747-3
database administrators	primarily creating	action	the database schema	3747-3
database administrators	modifying	action	the database schema	3747-3
the database schema	and	conjunctive	user mode	3747-3
user mode		sequential	which	3747-3
which	to	constraint	activities	3747-3
which	refers	action	activities	3747-3
activities	and	conjunctive	the actual data	3747-3
activities	querying	action	the actual data	3747-3
activities	updating	action	the actual data	3747-3
the actual data	in	constraint	the database	3747-3
some users	in	constraint	these modes	3747-4
some users	of	constraint	these modes	3747-4
some users	Of course may operate	attribute	both	3747-4
these modes	on	constraint	different occasions	3747-4
<B>	In	constraint	application software	3747-5
application software	as	constraint	the user mode	3747-5
application software	from	constraint	the user mode	3747-5
application software	is viewed	action	the user mode	3747-5
application software	invoked	action	the user mode	3747-5
Encapsulation	that	constraint	user mode	3748-1
Encapsulation	in	constraint	user mode	3748-1
Encapsulation	requires	action	user mode	3748-1
user mode		sequential	a user	3748-1
a user	or	conjunctive	information	3748-1
a user	when can access	action	information	3748-1
a user	modify	action	information	3748-1
information	about	constraint	a given object	3748-1
a given object	by	constraint	only means	3748-1
only means	of	constraint	the methods	3748-1
the methods	for	constraint	that object	3748-1
the methods	defined	action	that object	3748-1
that object		sequential	he	3748-1
he	or	conjunctive	she	3748-1
she	or	conjunctive	the complex value	3748-1
she	can not directly examine	action	the complex value	3748-1
she	modify	action	the complex value	3748-1
the complex value	or	conjunctive	the methods	3748-1
the methods	with	constraint	the object	3748-1
the methods	associated	action	the object	3748-1
<B>	In	constraint	all application software	3748-2
all application software	essentially can access	action	objects	3748-2
objects	through	constraint	only their methods	3748-2
<B>	has	action	two important implications	3748-3
<B>	as	constraint	the same set	3748-4
the same set	of	constraint	methods	3748-4
methods	is supported	action	the underlying implementation	3748-4
the underlying implementation	of	constraint	object methods	3748-4
object methods	of	constraint	even the complex value representation	3748-4
object methods	and	conjunctive	even the complex value representation	3748-4
even the complex value representation	of	constraint	objects	3748-4
objects	without	constraint	any application software	3748-4
objects	to	constraint	any application software	3748-4
objects	First can be changed	action	any application software	3748-4
objects	having	action	any application software	3748-4
objects	modify	action	any application software	3748-4
the methods	of	constraint	an object	3748-5
an object	and	conjunctive	a interface	3748-5
an object	Second often provide	action	a interface	3748-5
an object	focused	action	a interface	3748-5
an object	abstracted	action	a interface	3748-5
a interface	to	constraint	the object	3748-5
the object	thus making	action	it	3748-5
it	for	constraint	programmers	3748-5
programmers	to	constraint	the objects	3748-5
programmers	with	constraint	the objects	3748-5
programmers	work	action	the objects	3748-5
<B>	In	constraint	object	3749-1
object	oriented	action	programming languages	3749-1
programming languages		sequential	it	3749-1
it	to	constraint	encapsulation	3749-1
it	is	attribute	typical	3749-1
it	enforce	action	encapsulation	3749-1
encapsulation	except	constraint	the special case	3749-1
encapsulation	in	constraint	the special case	3749-1
the special case	of	constraint	method implementations	3749-1
the special case	rewriting	action	method implementations	3749-1
<B>	In	constraint	some OODB models	3749-2
some OODB models		sequential	there	3749-2
there	is	attribute	an important exception	3749-2
an important exception	to	constraint	connection	3749-2
an important exception	in	constraint	connection	3749-2
connection	with	constraint	query languages	3749-2
<B>	In	constraint	it	3749-3
it	to	constraint	a query language	3749-3
it	is	attribute	generally convenient	3749-3
it	permit	action	a query language	3749-3
a query language	to	constraint	the complex values	3749-3
a query language	examine explicitly	action	the complex values	3749-3
the complex values	with	constraint	objects	3749-3
the complex values	associated	action	objects	3749-3
The reader	with	constraint	no previous exposure	3750-1
no previous exposure	to	constraint	object	3750-1
object	oriented	action	languages	3750-1
languages	by	constraint	the terminology	3750-1
languages	may now be utterly overwhelmed	action	the terminology	3750-1
It	at	constraint	this point	3750-2
It	be	attribute	might helpful	3750-2
this point	to	constraint	a book	3750-2
this point	through	constraint	a book	3750-2
this point	scan	action	a book	3750-2
a book	or	conjunctive	manual	3750-2
manual	about	constraint	an programming language	3750-2
manual	object oriented	action	an programming language	3750-2
an programming language		sequential	C++	3750-2
C++	or	conjunctive	<B>	3750-2
Formal Definition	of	constraint	an OODB Model	3751-1
This model	by	constraint	IQL	3751-2
This model	is strongly influenced	action	IQL	3751-2
IQL	and	conjunctive	O2	3751-2
O2		sequential	the models	3751-2
Many features	by	constraint	most other OODB models	3751-3
Many features	are shared	action	most other OODB models	3751-3
<B>	While	constraint	the model	3751-4
<B>	presenting	action	the model	3751-4
the model		sequential	we	3751-4
we	also discuss	action	different choices	3751-4
different choices	in	constraint	other models	3751-4
different choices	made	action	other models	3751-4
The presentation	essentially follows	action	the preceding informal one	3751-5
the preceding informal one	with	constraint	definitions	3751-5
the preceding informal one	beginning	action	definitions	3751-5
definitions	for	constraint	the types	3751-5
the types	and	conjunctive	class hierarchy	3751-5
class hierarchy	and	conjunctive	methods	3751-5
class hierarchy	introducing	action	methods	3751-5
It	with	constraint	definitions	3751-6
It	concludes	action	definitions	3751-6
definitions	of	constraint	OODB schema	3751-6
OODB schema	and	conjunctive	instance	3751-6
Types	and	conjunctive	Class Hierarchy	3752-1
An object	of	constraint	a pair	3752-2
An object	consists	action	a pair	3752-2
a pair		sequential	identifier	3752-2
identifier		sequential	value	3752-2
The identifiers	from	constraint	a specific sort	3752-3
The identifiers	are taken	action	a specific sort	3752-3
a specific sort	containing	action	OIDs	3752-3
The values	are	attribute	essentially standard complex values	3752-4
essentially standard complex values	except	constraint	OIDs	3752-4
essentially standard complex values	that	constraint	OIDs	3752-4
OIDs	within	constraint	them	3752-4
OIDs	may occur	action	them	3752-4
<B>	Although	constraint	the definitions	3752-5
<B>	of	constraint	the definitions	3752-5
the definitions	on	constraint	complex values	3752-5
complex values	and	conjunctive	types	3752-5
types	to	constraint	Chapter 20	3752-5
types	in	constraint	Chapter 20	3752-5
types	are	attribute	almost identical	3752-5
Chapter 20		sequential	we	3752-5
we	include here	action	them	3752-5
them	to	constraint	the differences	3752-5
them	make	attribute	precise	3752-5
the differences	from	constraint	object	3752-5
object	oriented	action	the context	3752-5
<B>	As	constraint	we	3752-6
we	shall see	action	the class hierarchy	3752-6
the class hierarchy	obeys	action	a natural restriction	3752-6
a natural restriction	on	constraint	subtyping	3752-6
a natural restriction	based	action	subtyping	3752-6
<B>	To	constraint	we	3753-1
<B>	start	action	we	3753-1
we	assume	action	a number	3753-1
a number	of	constraint	atomic types	3753-1
atomic types	and	conjunctive	their pairwise disjoint corresponding domains	3753-1
their pairwise disjoint corresponding domains		sequential	integer	3753-1
integer		sequential	string	3753-1
string		sequential	bool	3753-1
bool		sequential	float	3753-1
The set dom	of	constraint	atomic values	3753-2
atomic values	is	attribute	disjoint	3753-2
the union	of	constraint	these domains	3753-2
these domains	as	constraint	the elements	3753-2
the elements	of	constraint	dom	3753-2
dom	are called	action	constants	3753-2
We	also assume	action	an infinite set	3753-3
an infinite set		sequential	obj	3753-3
obj	=	sequential	o1	3753-3
obj	{	sequential	o1	3753-3
o1		sequential	o2	3753-3
<B>	.	sequential	<B>	3753-4
<B>	}	sequential	<B>	3753-5
<B>	of	constraint	object identifiers	3753-6
object identifiers		sequential	OIDs	3753-6
OIDs		sequential	a set class	3753-6
a set class	of	constraint	class names	3753-6
class names	and	conjunctive	a set att	3753-6
a set att	of	constraint	attribute names	3753-6
A special constant nil	represents	attribute	null	3753-7
<B>	Given	action	a set O	3754-1
a set O	of	constraint	OIDs	3754-1
OIDs		sequential	the family	3754-1
the family	of	constraint	values	3754-1
values	over	constraint	O	3754-1
O	so that	constraint	nil	3754-1
O	is defined	action	nil	3754-1
nil		sequential	each element	3754-1
each element	of	constraint	dom	3754-1
dom	and	conjunctive	each element	3754-1
each element	of	constraint	O	3754-1
O	are	attribute	a values	3754-1
a values	over	constraint	O	3754-1
O	if	constraint	v1	3754-1
O	and	conjunctive	v1	3754-1
<B>	.	sequential	<B>	3754-2
<B>	.	sequential	<B>	3754-3
vn	are	attribute	values	3754-4
values	over	constraint	O	3754-4
O	and	conjunctive	A1	3754-4
<B>	.	sequential	<B>	3754-5
<B>	.	sequential	<B>	3754-6
An distinct attributes names		sequential	the tuple	3754-7
the tuple		sequential	A1	3754-7
A1		sequential	v1	3754-7
<B>	.	sequential	<B>	3754-8
<B>	.	sequential	<B>	3754-9
<B>		sequential	vn	3754-10
vn	and	conjunctive	the set	3754-10
the set		sequential	v1	3754-10
<B>	.	sequential	<B>	3754-11
<B>	.	sequential	<B>	3754-12
vn }	are	attribute	values	3754-13
values	over	constraint	O	3754-13
The set	of	constraint	all values	3755-1
all values	over	constraint	O	3755-1
O	is	attribute	denoted val	3755-1
denoted val		sequential	O	3755-1
An object	is	attribute	a pair	3755-2
a pair		sequential	o	3755-2
o		sequential	v	3755-2
v	is	attribute	where o an OID	3755-2
where o an OID	v	constraint	a value	3755-2
where o an OID	and	conjunctive	a value	3755-2
<B>	In	constraint	object	3756-1
object	oriented	action	database models	3756-1
database models	also include	action	constructors	3756-1
constructors	than	constraint	tuple	3756-1
tuple	and	conjunctive	set	3756-1
set		sequential	list	3756-1
list	and	conjunctive	bag	3756-1
bag		sequential	we	3756-1
we	do not consider here	action	them	3756-1
Example		sequential	21.2.1	3757-1
<B>	denote	action	OIDs	3757-2
OIDs		sequential	some examples	3757-2
some examples	of	constraint	values	3757-2
values	as	constraint	Object Databases schema	3757-2
values	are	attribute	Object Databases schema	3757-2
values	follows	action	Object Databases schema	3757-2
Types	with	constraint	respect	3758-1
Types	are defined	action	respect	3758-1
respect	to	constraint	a given set C	3758-1
a given set C	of	constraint	class names	3758-1
The family	of	constraint	types	3758-2
types	over	constraint	C	3758-2
C	is defined so	action	<B>	3758-2
The set	of	constraint	types	3759-1
types	over	constraint	C together	3759-1
C together	with	constraint	the special class name	3759-1
the special class name	are	attribute	denoted types	3759-1
denoted types		sequential	C	3759-1
Example		sequential	21.2.2	3760-1
Other examples	of	constraint	types	3760-2
types	with	constraint	names	3760-2
names	to	constraint	them	3760-2
names	associated	action	them	3760-2
them	include	action	Director	3760-2
Director		sequential	type	3760-2
type	=	sequential	name	3760-2
name		sequential	string	3760-2
string		sequential	citizenship	3760-2
citizenship		sequential	string	3760-2
string		sequential	gender	3760-2
gender		sequential	string	3760-2
string		sequential	directs	3760-2
directs		sequential	Movie	3760-2
Movie		sequential	}	3760-2
<B>	In	constraint	each object	3760-3
<B>	for	constraint	each object	3760-3
each object		sequential	o	3760-3
o		sequential	v	3760-3
v	in	constraint	class c	3760-3
class c		sequential	v	3760-3
v	must have	action	the exact structure	3760-3
the exact structure	by	constraint	σ	3760-3
the exact structure	described	action	σ	3760-3
σ		sequential	c	3760-3
<B>	from	constraint	the informal description	3761-1
<B>	Recall	action	the informal description	3761-1
the informal description	that	constraint	an OODB schema	3761-1
an OODB schema	includes	action	an ISA hierarchy	3761-1
an ISA hierarchy	among	constraint	the classes	3761-1
the classes	of	constraint	the schema	3761-1
The class hierarchy	has	action	three components	3761-2
three components		sequential	1 a set	3761-2
1 a set	of	constraint	classes	3761-2
classes		sequential	2 the types	3761-2
2 the types	with	constraint	these classes	3761-2
2 the types	associated	action	these classes	3761-2
these classes	and	conjunctive	3 a specification	3761-2
3 a specification	of	constraint	the ISA relationships	3761-2
the ISA relationships	between	constraint	the classes	3761-2
a class hierarchy	is	attribute	Formally a triple	3761-3
Formally a triple		sequential	C	3761-3
C		sequential	σ	3761-3
σ		sequential	≺	3761-3
≺		sequential	C	3761-3
C	is	attribute	where a finite set	3761-3
where a finite set	of	constraint	class names	3761-3
class names		sequential	σ	3761-3
σ		sequential	a mapping	3761-3
a mapping	from	constraint	C	3761-3
C	to	constraint	types	3761-3
types		sequential	C	3761-3
C	and	conjunctive	a partial order	3761-3
a partial order	on	constraint	C	3761-3
<B>	in	constraint	a class hierarchy	3762-1
a class hierarchy		sequential	the type	3762-1
the type	with	constraint	a subclass	3762-1
the type	associated	action	a subclass	3762-1
a subclass	be	attribute	Informally should a refinement	3762-1
Informally should a refinement	of	constraint	the type	3762-1
the type	with	constraint	its superclass	3762-1
the type	associated	action	its superclass	3762-1
<B>	For	constraint	example	3762-2
example		sequential	a class Student	3762-2
a class Student	to	constraint	the information	3762-2
a class Student	is expected	action	the information	3762-2
a class Student	refine	action	the information	3762-2
the information	on	constraint	its superclass Person	3762-2
its superclass Person	by	constraint	additional attributes	3762-2
its superclass Person	providing	action	additional attributes	3762-2
<B>	To	constraint	this notion	3762-3
<B>	capture	action	this notion	3762-3
this notion		sequential	we	3762-3
we	use	action	a subtyping relationship	3762-3
a subtyping relationship		sequential	≤	3762-3
≤		sequential	that	3762-3
that	specifies	action	one type	3762-3
one type	when refines	attribute	another	3762-3
Definition		sequential	21.2.3	3763-1
21.2.3		sequential	Let	3763-1
Let		sequential	C	3763-1
C		sequential	σ	3763-1
σ	be	attribute	≺ a class hierarchy	3763-1
The subtyping relationship	on	constraint	types	3763-2
types		sequential	C	3763-2
C	is	attribute	the smallest partial order	3763-2
the smallest partial order		sequential	≤	3763-2
≤	over	constraint	types	3763-2
types		sequential	C	3763-2
C	satisfying	action	the following conditions	3763-2
the following conditions	if	constraint	c ≺ c′	3763-2
c ≺ c′		sequential	c ≤ c′	3763-2
c ≤ c′		sequential	i	3763-2
i		sequential	n	3763-2
n		sequential	τ ′n	3763-2
<B>	By	constraint	way	3764-1
way	of	constraint	illustration	3764-1
illustration		sequential	it	3764-1
it	that	constraint	Director type	3764-1
it	is easily verified	action	Director type	3764-1
Director type		sequential	≤ Person	3764-1
≤ Person		sequential	type Director type	3764-1
type Director type		sequential	≤	3764-1
Thus the schema	by	constraint	the constraint Director	3765-1
Thus the schema	obtained	action	the constraint Director	3765-1
Thus the schema	adding	action	the constraint Director	3765-1
Henceforth		sequential	we	3766-1
we	consider	action	only class hierarchies	3766-1
we	well formed	action	only class hierarchies	3766-1
Example		sequential	21.2.4	3767-1
21.1		sequential	21.1	3767-2
The set	of	constraint	classes	3767-3
classes	is	attribute	C	3767-3
C	=	sequential	Person	3767-3
Person		sequential	Director	3767-3
Director		sequential	Actor	3767-3
Actor		sequential	Actor	3767-3
Actor		sequential	Director	3767-3
Director		sequential	Theater	3767-3
Theater		sequential	Movie }	3767-3
Movie }	with	constraint	Actor	3767-3
Actor		sequential	Person	3767-3
Person		sequential	Director ≺ Person	3767-3
Director ≺ Person		sequential	Actor	3767-3
Actor		sequential	Director	3767-3
Director		sequential	Director	3767-3
Director		sequential	Actor	3767-3
Actor		sequential	Director	3767-3
Object Databases		sequential	Object Databases	3768-1
We	would obtain	action	the same schema	3768-2
the same schema	if	constraint	we	3768-2
we	for	constraint	instance	3768-2
we	replaced	action	instance	3768-2
instance		sequential	Person	3768-2
Person		sequential	type	3768-2
type	with	constraint	the value	3768-2
the value	of	constraint	this type	3768-2
<B>	that	constraint	σ	3769-1
<B>	Observe	action	σ	3769-1
σ		sequential	Director	3769-1
Director		sequential	≤	3769-1
≤		sequential	σ	3769-1
σ		sequential	Person	3769-1
Person	and	conjunctive	σ	3769-1
σ		sequential	Actor	3769-1
Actor		sequential	≤ σ	3769-1
≤ σ		sequential	Person	3769-1
Person		sequential	<B>	3769-1
The Structural Semantics	of	constraint	a Class Hierarchy	3770-1
<B>	Because	constraint	the values	3770-2
the values	in	constraint	an OODB instance	3770-2
an OODB instance	may include	action	OIDs	3770-2
OIDs		sequential	the semantics	3770-2
the semantics	of	constraint	classes	3770-2
classes	and	conjunctive	types	3770-2
types	must be defined simultaneously	action	<B>	3770-2
The basis	for	constraint	these definitions	3770-3
these definitions	is	attribute	the notion	3770-3
the notion	of	constraint	OID assignment	3770-3
OID assignment		sequential	which	3770-3
which	assigns	action	a set	3770-3
a set	of	constraint	OIDs	3770-3
OIDs	to	constraint	each class	3770-3
Definition Let		sequential	21.2.5	3771-1
21.2.5		sequential	C	3771-1
C		sequential	σ	3771-1
σ	be	attribute	≺ a class hierarchy	3771-1
σ	well formed	action	≺ a class hierarchy	3771-1
An OID assignment	is	attribute	a function	3771-2
a function		sequential	π	3771-2
π	mapping	action	each name	3771-2
each name	in	constraint	C	3771-2
C	to	constraint	a disjoint finite set	3771-2
a disjoint finite set	of	constraint	OIDs	3771-2
Given OID		sequential	Given OID	3771-3
<B>	If	constraint	π	3772-1
π	is	attribute	an OID assignment	3772-1
an OID assignment		sequential	∗	3772-1
∗		sequential	c′	3772-1
c′		sequential	π ⊆	3772-1
π ⊆		sequential	π ∗	3772-1
π ∗		sequential	c	3772-1
c		sequential	c′	3772-1
c′		sequential	whenever ≺ c	3772-1
<B>	From	constraint	the perspective	3772-2
the perspective	of	constraint	typing	3772-2
typing	that	constraint	operations	3772-2
typing	suggests	action	operations	3772-2
operations		sequential	that	3772-2
that	are	attribute	type	3772-2
type	for	constraint	members	3772-2
members	of	constraint	c	3772-2
c	are	attribute	type	3772-2
type	for	constraint	members	3772-2
members	of	constraint	c′	3772-2
<B>	Unlike	constraint	the case	3773-1
the case	for	constraint	many semantic data models	3773-1
many semantic data models		sequential	the definition	3773-1
the definition	of	constraint	OID assignment	3773-1
OID assignment	for	constraint	OODB schemas	3773-1
OODB schemas	that	constraint	extensions	3773-1
OODB schemas	implies	action	extensions	3773-1
extensions	of	constraint	classes	3773-1
classes	of	constraint	an ISA hierarchy	3773-1
an ISA hierarchy	without	constraint	common subclasses	3773-1
common subclasses	are	attribute	necessarily disjoint	3773-1
<B>	In	constraint	extensions	3773-2
extensions	of	constraint	all leaf classes	3773-2
all leaf classes	of	constraint	the hierarchy	3773-2
the hierarchy	are	attribute	disjoint	3773-2
the hierarchy	see	action	Exercise 21.2	3773-2
<B>	is	attribute	a simplifying assumption	3773-3
a simplifying assumption		sequential	that	3773-3
that	makes	action	it	3773-3
it	to	constraint	objects	3773-3
it	associate	action	objects	3773-3
objects	to	constraint	classes	3773-3
There	is	attribute	a unique class	3773-4
a unique class	to	constraint	whose disjoint extension	3773-4
whose disjoint extension		sequential	each object	3773-4
each object	belongs	action	<B>	3773-4
The semantics	for	constraint	types	3774-1
types	to	constraint	a class hierarchy	3774-1
types	is now defined	action	a class hierarchy	3774-1
a class hierarchy		sequential	C	3774-1
C		sequential	σ	3774-1
σ	and	conjunctive	an OID assignment π	3774-1
<B>	Let	action	O	3774-2
O		sequential	∪	3774-2
∪		sequential	π c ∈ C }	3774-2
π c ∈ C }		sequential	c	3774-2
c	and	conjunctive	π	3774-2
c	define	action	π	3774-2
π	=	sequential	O	3774-2
The disjoint interpretation	of	constraint	a type	3774-3
a type		sequential	τ denoted dom	3774-3
τ denoted dom		sequential	τ	3774-3
τ	by	constraint	each atomic type	3774-3
τ	for	constraint	each atomic type	3774-3
τ	is given	action	each atomic type	3774-3
each atomic type		sequential	dom	3774-3
dom		sequential	τ	3774-3
τ	is	attribute	a τ the usual interpretation	3774-3
a τ the usual interpretation	of	constraint	that type	3774-3
that type		sequential	dom	3774-3
dom	is	attribute	b val	3774-3
b val		sequential	O	3774-3
Remark		sequential	21.2.6	3775-1
It	to	constraint	e	3775-2
It	is	attribute	interesting	3775-2
It	replace	action	e	3775-2
e	by	constraint	dom	3775-2
dom		sequential	A1	3775-2
A1	τ	sequential	1	3775-2
<B>	.	sequential	<B>	3775-3
<B>	.	sequential	<B>	3775-4
Ak		sequential	τk	3775-5
τk	=	sequential	vi ∈ dom	3775-5
vi ∈ dom		sequential	τi	3775-5
τi		sequential	i ∈	3775-5
i ∈		sequential	1	3775-5
1		sequential	k	3775-5
k		sequential	vj ∈ val	3775-5
vj ∈ val		sequential	O	3775-5
O		sequential	j ∈	3775-5
j ∈		sequential	k	3775-5
k	+	sequential	1	3775-5
1		sequential	l	3775-5
l	}	sequential	<B>	3775-5
<B>	Under	constraint	this alternative interpretation	3776-1
this alternative interpretation	for	constraint	each τ	3776-1
each τ		sequential	τ	3776-1
τ	in	constraint	types	3776-1
types		sequential	C	3776-1
C	if	constraint	τ	3776-1
τ		sequential	≤ τ dom	3776-1
≤ τ dom		sequential	τ	3776-1
τ		sequential	′	3776-1
′		sequential	⊆ dom	3776-1
⊆ dom		sequential	τ	3776-1
<B>	is	attribute	this	3776-2
<B>	is sometimes called	action	domain inclusion	3776-2
domain inclusion		sequential	the semantics	3776-2
<B>	From	constraint	a data model viewpoint	3776-3
a data model viewpoint	presents	action	the disadvantage	3776-3
the disadvantage	that	constraint	a correctly typed database instance	3776-3
the disadvantage	in	constraint	a correctly typed database instance	3776-3
a correctly typed database instance		sequential	a tuple	3776-3
a tuple	may have	action	a field	3776-3
a field		sequential	that	3776-3
that	in	constraint	the database schema	3776-3
that	is not even mentioned	action	the database schema	3776-3
<B>	For	constraint	this reason	3776-4
this reason		sequential	we	3776-4
we	do not adopt here	action	domain	3776-4
domain		sequential	inclusion	3776-4
inclusion		sequential	the semantics	3776-4
<B>	On	constraint	the other hand	3776-5
the other hand	from	constraint	a linguistic viewpoint	3776-5
a linguistic viewpoint		sequential	it	3776-5
it	to	constraint	this more liberal semantics	3776-5
it	be	attribute	may useful	3776-5
it	adopt	action	this more liberal semantics	3776-5
this more liberal semantics	in	constraint	languages	3776-5
languages	to	constraint	variables	3776-5
languages	allow	action	variables	3776-5
variables	denoting	action	tuples	3776-5
tuples	with	constraint	more attributes	3776-5
more attributes	than	constraint	<B>	3776-5
The final ingredient	of	constraint	the generic OODB model	3777-1
the generic OODB model	is	attribute	methods	3777-1
A method	has	action	three components	3777-2
There	is	attribute	no problem	3778-1
no problem	in	constraint	the names	3778-1
no problem	specifying	action	the names	3778-1
the names	and	conjunctive	signatures	3778-1
signatures	of	constraint	methods	3778-1
methods	in	constraint	an OODB schema	3778-1
<B>	To	constraint	the implementation	3778-2
<B>	specify	action	the implementation	3778-2
the implementation	of	constraint	methods	3778-2
methods		sequential	a language	3778-2
a language	for	constraint	methods	3778-2
methods	is needed	action	<B>	3778-2
We	do not consider	action	specific languages	3779-1
specific languages	in	constraint	the generic OODB model	3779-1
only names	and	conjunctive	signatures	3779-2
signatures	of	constraint	methods	3779-2
methods	at	constraint	the schema level	3779-2
methods	Therefore are specified	action	the schema level	3779-2
the schema level	in	constraint	this model	3779-2
<B>	In	constraint	Section 21.4	3779-3
Section 21.4		sequential	we	3779-3
we	shall consider	action	several languages	3779-3
several languages	for	constraint	methods	3779-3
methods	to	constraint	the implementation	3779-3
methods	and	conjunctive	the implementation	3779-3
methods	be	attribute	shall therefore able	3779-3
methods	add	action	the implementation	3779-3
the implementation	of	constraint	methods	3779-3
methods	to	constraint	the schema	3779-3
<B>	Without	constraint	the implementation	3780-1
<B>	specifying	action	the implementation	3780-1
the implementation	of	constraint	methods	3780-1
methods		sequential	the generic OODB model	3780-1
the generic OODB model	specifies	action	their semantics	3780-1
their semantics		sequential	the effect	3780-1
the effect	of	constraint	each method	3780-1
each method	in	constraint	the context	3780-1
the context	of	constraint	a given instance	3780-1
This effect		sequential	which	3780-2
which	is	attribute	a function	3780-2
a function	over	constraint	the domains	3780-2
the domains	of	constraint	the types	3780-2
the types	to	constraint	the signature	3780-2
the types	corresponding	action	the signature	3780-2
the signature	of	constraint	the method	3780-2
the method	at	constraint	the instance level	3780-2
the method	is therefore specified	action	the instance level	3780-2
We	assume	action	the existence	3781-1
the existence	of	constraint	an infinite set meth	3781-1
an infinite set meth	of	constraint	method names	3781-1
<B>	Let	action	C	3781-2
C		sequential	σ	3781-2
σ	be	attribute	≺ a class hierarchy	3781-2
<B>	For	constraint	method	3781-3
method		sequential	name m	3781-3
name m		sequential	a signature	3781-3
a signature	of	constraint	m	3781-3
m	is	attribute	an expression	3781-3
an expression	of	constraint	the form m	3781-3
the form m		sequential	c τ 1 ×	3781-3
c τ 1 ×		sequential	×	3781-3
×		sequential	×	3781-3
×	τn	constraint	−1	3781-3
−1	→	sequential	τn	3781-3
τn		sequential	c	3781-3
c	is	attribute	where a class name	3781-3
where a class name	in	constraint	C	3781-3
C	and	conjunctive	each τi	3781-3
each τi	is	attribute	a type	3781-3
a type	over	constraint	C	3781-3
Some restrictions	shall be specified later	action	<B>	3781-4
The notion	of	constraint	signature here	3781-5
signature here	generalizes	action	the one	3781-5
the one	in	constraint	Object Databases	3781-5
the one	typically found	action	Object Databases	3781-5
Object Databases		sequential	object	3781-5
object	oriented	action	programming languages	3781-5
programming languages	because	constraint	we	3781-5
we	permit	action	the τi	3781-5
the τi	to	constraint	types	3781-5
the τi	be	attribute	types	3781-5
types		sequential	only classes	3781-5
It	to	constraint	the notions	3782-1
It	is	attribute	easiest	3782-1
It	describe	action	the notions	3782-1
the notions	of	constraint	overloading	3782-1
overloading		sequential	method inheritance	3782-1
method inheritance	and	conjunctive	dynamic binding	3782-1
dynamic binding	in	constraint	terms	3782-1
terms	of	constraint	an example	3782-1
<B>	Consider	action	the methods	3782-2
the methods	in	constraint	the schema	3782-2
the methods	defined	action	the schema	3782-2
the schema	of	constraint	Fig	3782-2
21.1		sequential	21.1	3782-3
<B>	get	action	name	3783-1
name		sequential	Director	3783-1
Director	→	sequential	string get	3783-1
string get		sequential	name	3783-1
name		sequential	Actor	3783-1
Actor	→	sequential	Director string	3783-1
<B>	that	constraint	Actor	3784-1
<B>	Recall	action	Actor	3784-1
Actor	is	attribute	a subclass	3784-1
a subclass	of	constraint	Person	3784-1
<B>	According to	action	the informal discussion	3784-2
the informal discussion	if	constraint	name	3784-2
the informal discussion	get	action	name	3784-2
name	to	constraint	elements	3784-2
name	applies	action	elements	3784-2
elements	of	constraint	Person	3784-2
Person		sequential	it	3784-2
it	to	constraint	members	3784-2
it	should also apply	action	members	3784-2
members	of	constraint	Actor	3784-2
<B>	in	constraint	object	3785-1
object	oriented	action	the paradigm	3785-1
the paradigm	if	constraint	a method m	3785-1
a method m	for	constraint	a class c	3785-1
a method m	is defined	action	a class c	3785-1
a class c	for	constraint	not a subclass c′	3785-1
a class c	but	conjunctive	not a subclass c′	3785-1
not a subclass c′	of	constraint	c	3785-1
c	and	conjunctive	it	3785-1
it	along	constraint	a path	3785-1
it	is not defined anywhere else	action	a path	3785-1
a path	from	constraint	c′	3785-1
c′	to	constraint	c	3785-1
c		sequential	the definition	3785-1
the definition	of	constraint	m	3785-1
m	for	constraint	c′	3785-1
c′	from	constraint	c	3785-1
c′	Indeed is inherited	action	c	3785-1
The implementation	of	constraint	m	3785-2
m	for	constraint	c′	3785-2
c′	to	constraint	c	3785-2
c′	for	constraint	c	3785-2
c′	is	attribute	identical	3785-2
21.1		sequential	the signature	3785-3
the signature	of	constraint	get	3785-3
get		sequential	name	3785-3
name	for	constraint	Actor	3785-3
Actor	is	attribute	name	3785-3
Actor	get	action	name	3785-3
name		sequential	Actor	3785-3
Actor	→	sequential	string	3785-3
<B>	that	constraint	π	3786-1
<B>	Suppose	action	π	3786-1
π	is	attribute	an OID assignment	3786-1
an OID assignment	that	constraint	oid 25	3786-1
oid 25	in	constraint	the extension π	3786-1
oid 25	is	attribute	the extension π	3786-1
the extension π		sequential	Person	3786-1
Person	of	constraint	Person	3786-1
Person	and	conjunctive	name	3786-1
Person	that get	action	name	3786-1
name	on	constraint	oid 25	3786-1
name	is called	action	oid 25	3786-1
What implementation	of	constraint	get	3786-2
get		sequential	name	3786-2
name	will be used	action	<B>	3786-2
<B>	In	constraint	our OODB model	3786-3
our OODB model		sequential	we	3786-3
we	shall use	action	dynamic binding	3786-3
dynamic binding	also called	action	late binding	3786-3
late binding	or	conjunctive	value	3786-3
value		sequential	binding	3786-3
<B>	that	constraint	the specific implementation	3786-4
<B>	means	action	the specific implementation	3786-4
the specific implementation	for	constraint	get	3786-4
the specific implementation	chosen	action	get	3786-4
get		sequential	name	3786-4
name	on	constraint	oid 25	3786-4
oid 25	on	constraint	the most specific class	3786-4
oid 25	depends	action	the most specific class	3786-4
the most specific class		sequential	that	3786-4
that		sequential	oid 25	3786-4
oid 25	to	constraint	the class c	3786-4
oid 25	belongs	attribute	that	3786-4
oid 25	is	attribute	the class c	3786-4
the class c		sequential	such that oid 25 ∈ π	3786-4
such that oid 25 ∈ π		sequential	c	3786-4
<B>	Under	constraint	this discipline	3787-1
this discipline		sequential	the implementation	3787-1
the implementation	for	constraint	get	3787-1
the implementation	used	action	get	3787-1
get		sequential	name	3787-1
name	on	constraint	the type	3787-1
name	depends	action	the type	3787-1
the type	with	constraint	the variable holding oid 25	3787-1
the type	associated	action	the variable holding oid 25	3787-1
the variable holding oid 25	at	constraint	the point	3787-1
the point	in	constraint	program	3787-1
program	where get	action	name	3787-1
name	is invoked	action	<B>	3787-1
<B>	at	constraint	compile time	3788-1
<B>	can be determined	action	compile time	3788-1
compile time	and	conjunctive	static binding	3788-1
static binding	than	constraint	dynamic binding	3788-1
static binding	is	attribute	so generally much cheaper	3788-1
<B>	In	constraint	the language C++	3788-2
the language C++		sequential	the default	3788-2
the default	is	attribute	static binding	3788-2
static binding	but	conjunctive	dynamic binding	3788-2
dynamic binding	by	constraint	the keyword virtual	3788-2
dynamic binding	can be obtained	action	the keyword virtual	3788-2
dynamic binding	using	action	the keyword virtual	3788-2
the keyword virtual	when specifying	action	the method	3788-2
<B>	Consider	action	a call m	3788-3
a call m		sequential	v1	3788-3
<B>	.	sequential	<B>	3788-4
<B>	.	sequential	<B>	3788-5
vn−1	to	constraint	method m	3788-6
<B>	As	constraint	the implementation	3788-7
<B>	described here	action	the implementation	3788-7
the implementation	of	constraint	m	3788-7
m	with	constraint	this message	3788-7
m	associated	action	this message	3788-7
this message	on	constraint	the class	3788-7
this message	depends exclusively	action	the class	3788-7
the class	of	constraint	<B>	3788-7
the class	o	constraint	<B>	3788-7
<B>	To	constraint	the importance	3788-8
<B>	emphasize	action	the importance	3788-8
the importance	of	constraint	the receiver	3788-8
the receiver	for	constraint	the actual implementation	3788-8
the receiver	finding	action	the actual implementation	3788-8
the actual implementation	in	constraint	some languages	3788-8
some languages		sequential	the message	3788-8
the message	o	constraint	→ m	3788-8
the message	is denoted	action	→ m	3788-8
→ m		sequential	v1	3788-8
<B>	.	sequential	<B>	3788-9
<B>	.	sequential	<B>	3788-10
vn−1		sequential	vn−1	3788-11
<B>	In	constraint	some programming languages	3788-12
<B>	object oriented	action	some programming languages	3788-12
some programming languages		sequential	CommonLoops	3788-12
CommonLoops		sequential	object	3788-12
object	oriented	action	an extension	3788-12
an extension	of	constraint	LISP	3788-12
LISP		sequential	the implementation	3788-12
the implementation	on	constraint	m c′	3788-12
the implementation	depends	action	m c′	3788-12
m c′		sequential	c′′ m	3788-12
c′′ m		sequential	c′′′ m c	3788-12
c′′′ m c		sequential	Figure 21.2	3788-12
Figure 21.2		sequential	Unambiguous definition	3788-12
The set	of	constraint	methods	3789-1
methods	to	constraint	an object	3789-1
an object	is called	action	the interface	3789-1
the interface	of	constraint	the object	3789-1
<B>	As	constraint	the informal description	3789-2
<B>	in	constraint	the informal description	3789-2
<B>	noted	action	the informal description	3789-2
the informal description	of	constraint	OODB models	3789-2
OODB models	in	constraint	most cases	3789-2
most cases		sequential	objects	3789-2
objects	via	constraint	only their interface	3789-2
objects	are accessed	action	only their interface	3789-2
only their interface		sequential	this philosophy	3789-2
this philosophy	is called	action	encapsulation	3789-2
Unambiguity		sequential	Unambiguity	3790-1
21.2		sequential	21.2	3790-2
Covariance 4	If	constraint	m	3791-1
m		sequential	c ×	3791-1
c ×	τ	sequential	1	3791-1
1		sequential	×	3791-1
×		sequential	×	3791-1
×	τn	constraint	τ	3791-1
×	→	sequential	τ	3791-1
τ	and	conjunctive	m	3791-1
m		sequential	c′ × τ	3791-1
c′ × τ		sequential	×	3791-1
×		sequential	×	3791-1
×		sequential	τ	3791-1
τ	are	attribute	two defi-1 m nitions	3791-1
two defi-1 m nitions	and	conjunctive	c	3791-1
c		sequential	≺	3791-1
≺		sequential	c′	3791-1
c′		sequential	n	3791-1
n	=	sequential	m	3791-1
m	for	constraint	each i	3791-1
each i		sequential	τi	3791-1
τi		sequential	≤	3791-1
≤		sequential	τ	3791-1
τ	and	conjunctive	τ	3791-1
τ		sequential	≤	3791-1
≤	τ	sequential	′	3791-1
i		sequential	The first rule	3792-1
The first rule	prevents	action	ambiguity	3792-1
ambiguity	from	constraint	the presence	3792-1
ambiguity	resulting	action	the presence	3792-1
the presence	of	constraint	two method implementations	3792-1
two method implementations	for	constraint	the same object	3792-1
two method implementations	both	conjunctive	the same object	3792-1
A primary motivation	for	constraint	the second rule	3792-2
the second rule	is	attribute	intuitive	3792-2
<B>	also simplifies	action	the writing	3792-3
the writing	of	constraint	programs	3792-3
programs	although	constraint	type checking	3792-3
type checking	to	constraint	difficulties	3792-3
type checking	leads	action	difficulties	3792-3
difficulties	in	constraint	even the presence	3792-3
even the presence	of	constraint	the covariance assumption	3792-3
the covariance assumption	see	action	Section 21.4	3792-3
Database Schemas	and	conjunctive	Instances	3793-1
An important subtlety here	be	attribute	will the role	3793-2
will the role	of	constraint	OIDs	3793-2
OIDs	in	constraint	instances	3793-2
instances		sequential	4	3793-2
Contravariance	is	attribute	the proper notion	3793-3
the proper notion		sequential	functions	3793-3
functions	as	constraint	arguments	3793-3
functions	when are passed	action	arguments	3793-3
arguments		sequential	which	3793-3
which	is	attribute	not the case here	3793-3
Object Databases		sequential	Object Databases	3794-1
<B>	In	constraint	many practical OODBs	3795-1
many practical OODBs		sequential	it	3795-1
it	to	constraint	storage	3795-1
it	has been found	attribute	convenient	3795-1
it	allow	action	storage	3795-1
storage	of	constraint	complex values	3795-1
complex values		sequential	that	3795-1
that	with	constraint	any objects	3795-1
that	are not associated	action	any objects	3795-1
any objects	and	conjunctive	some name	3795-1
any objects	can be accessed	action	some name	3795-1
any objects	directly using	action	some name	3795-1
<B>	also allows	action	us	3795-2
us	to	constraint	the capabilities	3795-2
us	subsume gracefully	action	the capabilities	3795-2
the capabilities	of	constraint	value	3795-2
value	based	action	models	3795-2
models		sequential	relations	3795-2
relations	and	conjunctive	complex values	3795-2
It	also facilitates	action	writing queries	3795-3
<B>	To	constraint	this feature	3795-4
<B>	reflect	action	this feature	3795-4
this feature		sequential	we	3795-4
we	allow	action	a similar mechanism	3795-4
a similar mechanism	in	constraint	schemas	3795-4
schemas	and	conjunctive	instances	3795-4
schemas	Thus may include	action	a set	3795-5
a set	of	constraint	value names	3795-5
value names	with	constraint	associated types	3795-5
Instances	assign	action	values	3795-6
values	of	constraint	appropriate type	3795-6
appropriate type	to	constraint	the names	3795-6
Method implementations		sequential	external programming languages	3795-7
external programming languages	and	conjunctive	query languages	3795-7
query languages	may all use	action	these names	3795-7
these names	to	constraint	their current values	3795-7
these names	to	constraint	their current values	3795-7
these names	refer	action	their current values	3795-7
their current values	or	conjunctive	a class name	3795-7
a class name	to	constraint	the set	3795-7
a class name	to	constraint	the set	3795-7
a class name	refer	action	the set	3795-7
the set	of	constraint	objects	3795-7
objects	in	constraint	that class	3795-7
objects	currently residing	action	that class	3795-7
<B>	In	constraint	this manner	3795-8
this manner		sequential	named values	3795-8
named values	and	conjunctive	class names	3795-8
class names	to	constraint	relation names	3795-8
class names	are	attribute	analogous	3795-8
relation names	in	constraint	the relational model	3795-8
the relational model	to	constraint	complex value relation names	3795-8
the relational model	and	conjunctive	complex value relation names	3795-8
complex value relation names	in	constraint	the complex value model	3795-8
<B>	In	constraint	the schema	3796-1
the schema	of	constraint	Fig	3796-1
examples	of	constraint	named values	3796-2
named values	are	attribute	21.1 Pariscope	3796-2
21.1 Pariscope	holding	action	a set	3796-2
a set	of	constraint	triples	3796-2
triples		sequential	Persons	3796-2
These names	in	constraint	method implementations	3796-3
These names	can be used explicitly	action	method implementations	3796-3
method implementations	in	constraint	query	3796-3
method implementations	and	conjunctive	query	3796-3
query	and	conjunctive	programming	3796-3
programming		sequential	external languages	3796-3
We	now have	action	the following Definition 21.2.7	3797-1
Definition		sequential	21.2.8	3798-1
<B>	is	attribute	µ	3799-1
µ		sequential	m c ×	3799-1
<B>	that	constraint	a method m	3800-1
<B>	Recall	action	a method m	3800-1
a method m	with	constraint	different signatures	3800-1
a method m	can occur	action	different signatures	3800-1
different signatures	in	constraint	the same schema	3800-1
The mapping µ	can assign	action	different semantics	3800-2
different semantics	to	constraint	each signature	3800-2
each signature	of	constraint	m	3800-2
<B>	In	constraint	the preceding definitions	3801-1
the preceding definitions		sequential	the assignment	3801-1
the assignment	of	constraint	semantics	3801-1
semantics	to	constraint	method signatures	3801-1
method signatures	in	constraint	the instance	3801-1
method signatures	is included	action	the instance	3801-1
<B>	As	constraint	Section 21.4	3801-2
<B>	in	constraint	Section 21.4	3801-2
<B>	will be seen	action	Section 21.4	3801-2
Section 21.4	if	constraint	method implementations	3801-2
method implementations	in	constraint	the schema	3801-2
method implementations	are included	action	the schema	3801-2
the schema		sequential	they	3801-2
they	induce	action	the semantics	3801-2
the semantics	of	constraint	methods	3801-2
methods	at	constraint	the instance level	3801-2
the instance level	by	constraint	the semantics	3801-2
the instance level	is determined	action	the semantics	3801-2
the semantics	of	constraint	the particular programming language	3801-2
the particular programming language	in	constraint	the implementation	3801-2
the particular programming language	used	action	the implementation	3801-2
it	that	constraint	elements	3802-1
it	Intuitively is generally assumed	action	elements	3802-1
elements	of	constraint	the atomic domains	3802-1
the atomic domains	have universally understood	action	meaning	3802-1
<B>	In	constraint	contrast	3802-2
contrast		sequential	the actual OIDs	3802-2
the actual OIDs	in	constraint	an instance	3802-2
the actual OIDs	used	action	an instance	3802-2
an instance	are	attribute	not relevant	3802-2
They	as	constraint	placeholders	3803-1
They	serve essentially	action	placeholders	3803-1
placeholders		sequential	it	3803-1
it	is	attribute	only their relationship	3803-1
only their relationship	with	constraint	other OIDs	3803-1
other OIDs	and	conjunctive	constants	3803-1
constants		sequential	that	3803-1
that	matters	action	<B>	3803-1
<B>	in	constraint	the practical perspective	3803-2
<B>	arises	action	the practical perspective	3803-2
the practical perspective	in	constraint	two ways	3803-2
<B>	in	constraint	most practical systems	3803-3
most practical systems		sequential	OIDs	3803-3
OIDs	or	conjunctive	<B>	3803-3
OIDs	First can not be explicitly created	action	<B>	3803-3
OIDs	examined	action	<B>	3803-3
OIDs	manipulated	action	<B>	3803-3
<B>	in	constraint	object	3803-4
object	oriented	action	some systems	3803-4
some systems		sequential	the actual OIDs	3803-4
the actual OIDs	in	constraint	a physical instance	3803-4
the actual OIDs	used	action	a physical instance	3803-4
a physical instance	over	constraint	the course	3803-4
a physical instance	Second may change	action	the course	3803-4
the course	of	constraint	time	3803-4
time	as	constraint	a result	3803-4
a result	of	constraint	garbage collection	3803-4
garbage collection	or	conjunctive	reclustering	3803-4
reclustering	of	constraint	objects	3803-4
<B>	To	constraint	this aspect	3804-1
<B>	capture	action	this aspect	3804-1
this aspect	of	constraint	OIDs	3804-1
OIDs	in	constraint	the formal model	3804-1
the formal model		sequential	we	3804-1
we	introduce	action	the notion	3804-1
the notion	of	constraint	OID isomorphism	3804-1
Two instances		sequential	I J	3804-2
I J	are	attribute	OID	3804-2
OID	denoted	action	I	3804-2
I	≡	action	OID	3804-2
OID		sequential	J	3804-2
J	if	constraint	there	3804-2
there	exists	action	a bijection	3804-2
a bijection	on	constraint	dom ∪ obj	3804-2
dom ∪ obj		sequential	that	3804-2
that	to	constraint	obj	3804-2
that	maps	attribute	obj	3804-2
obj	is	attribute	the identity	3804-2
the identity	on	constraint	dom	3804-2
dom	and	conjunctive	I	3804-2
dom	transforms	action	I	3804-2
I	into	constraint	J	3804-2
<B>	To	constraint	object	3805-1
<B>	be	attribute	precise	3805-1
object	oriented	action	the term instance	3805-1
the term instance	to	constraint	an equivalence class	3805-1
the term instance	should refer	action	an equivalence class	3805-1
an equivalence class	under	constraint	OID isomorphism	3805-1
OID isomorphism	of	constraint	instances	3805-1
instances	as	constraint	<B>	3805-1
instances	defined earlier	action	<B>	3805-1
it	to	constraint	representatives	3805-2
it	with	constraint	representatives	3805-2
it	is	attribute	However usually more convenient	3805-2
it	work	action	representatives	3805-2
representatives	of	constraint	these equivalence classes	3805-2
these equivalence classes		sequential	we	3805-2
we	so follow here	action	that convention	3805-2
Remark		sequential	21.2.9	3806-1
It	that	constraint	one	3807-1
It	has been argued	action	one	3807-1
one	should not associate	action	explicit class extensions	3807-1
explicit class extensions	with	constraint	classes	3807-1
<B>	To	constraint	the disadvantage	3807-2
<B>	see	action	the disadvantage	3807-2
the disadvantage	of	constraint	class extensions	3807-2
class extensions	consider	action	object deletion	3807-2
<B>	To	constraint	the database	3807-3
<B>	from	constraint	the database	3807-3
<B>	be removed	action	the database	3807-3
the database		sequential	an object	3807-3
an object	to	constraint	its class extension	3807-3
an object	from	constraint	its class extension	3807-3
an object	has	action	its class extension	3807-3
an object	be deleted explicitly	action	its class extension	3807-3
<B>	in	constraint	some cases	3807-4
<B>	is	attribute	not convenient	3807-4
<B>	For	constraint	instance	3807-5
instance	that	constraint	the database	3807-5
instance	suppose	action	the database	3807-5
the database	contains	action	a class Polygon	3807-5
a class Polygon	and	conjunctive	polygons	3807-5
polygons	in	constraint	only figures	3807-5
polygons	are used	action	only figures	3807-5
a polygon	in	constraint	any figure	3807-6
a polygon	When is no longer used	action	any figure	3807-6
any figure	of	constraint	the current database	3807-6
the current database		sequential	it	3807-6
it	of	constraint	no longer interest	3807-6
it	is	attribute	no longer interest	3807-6
no longer interest	and	conjunctive	<B>	3807-6
no longer interest	should be deleted	action	<B>	3807-6
We	would like	action	this deletion	3807-7
this deletion	to	constraint	<B>	3807-7
this deletion	be	attribute	implicit	3807-7
the user	of	constraint	the database	3807-8
the database	to	constraint	all possible places	3807-8
the database	Otherwise would have	action	all possible places	3807-8
the database	search	action	all possible places	3807-8
all possible places	in	constraint	which	3807-8
which		sequential	a reference	3807-8
a reference	to	constraint	a polygon	3807-8
a polygon	to	constraint	a polygon	3807-8
a polygon	to	constraint	a polygon	3807-8
a polygon	may occur	attribute	able	3807-8
a polygon	be	attribute	able	3807-8
a polygon	delete	action	a polygon	3807-8
<B>	To	constraint	some OODBs	3807-9
<B>	capture	attribute	this	3807-9
some OODBs	use	action	an integrity constraint	3807-9
an integrity constraint		sequential	which	3807-9
which	that	constraint	Object Databases	3807-9
which	states	action	Object Databases	3807-9
Object Databases		sequential	every object	3807-9
every object	from	constraint	some named value	3807-9
every object	be	attribute	should accessible	3807-9
This integrity constraint	by	constraint	an automatic deletion	3808-1
This integrity constraint	is enforced	action	an automatic deletion	3808-1
an automatic deletion	of	constraint	all objects	3808-1
all objects		sequential	that	3808-1
that	from	constraint	the named values	3808-1
that	become	attribute	unreachable	3808-1
<B>	In	constraint	the polygon example	3808-2
the polygon example		sequential	this approach	3808-2
this approach	would allow	action	the class Polygon	3808-2
this approach	defining	action	the class Polygon	3808-2
the class Polygon	thus specifying	action	the structure	3808-2
the structure	and	conjunctive	methods	3808-2
methods	to	constraint	polygons	3808-2
the members	of	constraint	class Polygon	3809-1
class Polygon	be	attribute	However would only those polygons	3809-1
However would only those polygons		sequential	that	3809-1
that	are	attribute	currently relevant	3809-1
Relevance	by	constraint	membership	3809-2
Relevance	is determined	action	membership	3809-2
membership	in	constraint	accessibility from	3809-2
membership	or	conjunctive	accessibility from	3809-2
accessibility from		sequential	the named values	3809-2
the named values		sequential	My Figures	3809-2
My Figures		sequential	Your Figures	3809-2
Your Figures		sequential	that	3809-2
that	to	constraint	polygons	3809-2
that	refer	action	polygons	3809-2
<B>	From	constraint	a technical viewpoint	3809-3
a technical viewpoint	involves	action	techniques	3809-3
techniques		sequential	garbage collection	3809-3
<B>	In	constraint	these OODBs	3810-1
these OODBs		sequential	the set	3810-1
the set	of	constraint	objects	3810-1
objects	in	constraint	a class	3810-1
a class	is	attribute	not directly accessible	3810-1
<B>	For	constraint	this reason	3810-2
this reason		sequential	the corresponding models	3810-2
the corresponding models	are sometimes called	action	models	3810-2
models	without	constraint	class extension	3810-2
it	is	attribute	Of course always possible	3811-1
it	given	action	a schema	3811-1
a schema	to	constraint	the class extensions	3811-1
a schema	compute	action	the class extensions	3811-1
the class extensions	to	constraint	object creation	3811-1
the class extensions	or	conjunctive	object creation	3811-1
the class extensions	adapt	action	object creation	3811-1
object creation	in	constraint	a given class	3811-1
a given class	to	constraint	a named value	3811-1
a given class	maintain explicitly	action	a named value	3811-1
a named value	containing	action	that class extension	3811-1
<B>	In	constraint	these OODBs	3811-2
these OODBs		sequential	the named values	3811-2
the named values	to	constraint	roots	3811-2
the named values	be	attribute	roots	3811-2
the named values	are also said	action	roots	3811-2
roots	of	constraint	persistence	3811-2
persistence	because	constraint	the persistence	3811-2
the persistence	of	constraint	an object	3811-2
an object	on	constraint	its accessibility	3811-2
an object	is	attribute	dependent	3811-2
its accessibility	from	constraint	these named values	3811-2
Languages	for	constraint	OODB Queries	3812-1
These queries	against	constraint	the database	3812-2
These queries	are formulated	action	the database	3812-2
the database	as	constraint	a whole	3812-2
a whole	unlike	constraint	methods	3812-2
methods		sequential	they	3812-2
they	with	constraint	specific classes	3812-2
they	are not associated	action	specific classes	3812-2
<B>	In	constraint	the next section	3812-3
the next section		sequential	we	3812-3
we	will consider	action	languages	3812-3
languages	to	constraint	implementations	3812-3
languages	intended	action	implementations	3812-3
languages	provide	action	implementations	3812-3
implementations	for	constraint	methods	3812-3
<B>	In	constraint	the OODB query languages	3813-1
<B>	describing	action	the OODB query languages	3813-1
the OODB query languages		sequential	we	3813-1
we	emphasize	action	OODB features	3813-1
OODB features	into	constraint	them	3813-1
OODB features	are incorporated	action	them	3813-1
The first language	is	attribute	an extension	3813-2
an extension	of	constraint	the calculus	3813-2
the calculus	for	constraint	complex values	3813-2
complex values		sequential	which	3813-2
which	incorporates	action	object	3813-2
object	oriented	action	such components	3813-2
such components	as	constraint	OIDs	3813-2
OIDs		sequential	different notions	3813-2
different notions	of	constraint	equality	3813-2
equality	and	conjunctive	method calls	3813-2
<B>	is	attribute	an extension	3813-3
an extension	of	constraint	the while language	3813-3
the while language	in	constraint	Chapter 14	3813-3
the while language	initially introduced	action	Chapter 14	3813-3
<B>	Of	constraint	primary interest here	3813-4
primary interest here	is	attribute	the introduction	3813-4
the introduction	of	constraint	techniques	3813-4
techniques	for	constraint	new OIDs	3813-4
techniques	creating	action	new OIDs	3813-4
new OIDs	as	constraint	part	3813-4
part	of	constraint	a query	3813-4
<B>	At	constraint	this point	3813-5
this point		sequential	we	3813-5
we	examine	action	the notion	3813-5
the notion	of	constraint	completeness	3813-5
completeness	for	constraint	OODB access languages	3813-5
We	at	constraint	a language	3813-6
We	also briefly look	action	a language	3813-6
a language	introducing	action	a approach	3813-6
a language	logic based	action	a approach	3813-6
a approach	to	constraint	object creation	3813-6
we	Finally mention	action	a practical language O2SQL	3813-7
<B>	is	attribute	a variant	3813-8
a variant	of	constraint	SQL	3813-8
SQL	for	constraint	OODBs	3813-8
OODBs		sequential	that	3813-8
that	provides	action	object	3813-8
object	oriented	action	elegant features	3813-8
object	oriented	action	The calculus	3814-1
The calculus	is	attribute	a straightforward generalization	3814-1
The calculus	presented here	action	a straightforward generalization	3814-1
a straightforward generalization	of	constraint	the complex value calculus	3814-1
the complex value calculus	of	constraint	Chapter 20	3814-1
Chapter 20	to	constraint	objects	3814-1
Chapter 20	extended	action	objects	3814-1
Chapter 20	incorporate	action	objects	3814-1
objects		sequential	different notions	3814-1
different notions	of	constraint	equality	3814-1
equality	and	conjunctive	methods	3814-1
<B>	Let	action	C	3815-1
C		sequential	σ	3815-1
σ		sequential	M	3815-1
M		sequential	G	3815-1
G	be	attribute	an OODB schema	3815-1
an OODB schema	and	conjunctive	us	3815-1
an OODB schema	let	action	us	3815-1
us	ignore	action	object	3815-1
object	oriented	action	the features	3815-1
the features	for	constraint	a moment	3815-1
Each name	in	constraint	G	3815-2
G	as	constraint	a complex value	3815-2
G	can be viewed	action	a complex value	3815-2
a complex value		sequential	it	3815-2
it	to	constraint	the complex value calculus	3815-2
it	is	attribute	straightforward	3815-2
it	generalize	action	the complex value calculus	3815-2
the complex value calculus	to	constraint	the values	3815-2
the complex value calculus	on	constraint	the values	3815-2
the complex value calculus	operate	action	the values	3815-2
the values	to	constraint	G.	3815-2
the values	by	constraint	G.	3815-2
the values	referred	action	G.	3815-2
G.		sequential	The fact	3815-2
The fact	that	constraint	the complex value model	3815-2
The fact	in	constraint	the complex value model	3815-2
the complex value model		sequential	all relations	3815-2
all relations	are	attribute	sets	3815-2
sets	whereas	constraint	some names	3815-2
some names	in	constraint	G	3815-2
G	to	constraint	nonset values	3815-2
G	might refer	action	nonset values	3815-2
nonset values	requires	action	only a minor modification	3815-2
only a minor modification	of	constraint	the language	3815-2
<B>	Let	action	us	3815-3
us	now consider	action	objects	3815-3
OIDs	as	constraint	elements	3815-4
OIDs	may be viewed	action	elements	3815-4
elements	of	constraint	a specific sort	3815-4
<B>	If	constraint	isolation	3816-1
<B>	in	constraint	isolation	3816-1
<B>	viewed	action	isolation	3816-1
isolation	from	constraint	their associated values	3816-1
their associated values	that	constraint	OIDs	3816-1
their associated values	for	constraint	OIDs	3816-1
their associated values	suggests	attribute	the only primitive	3816-1
their associated values	comparing	action	OIDs	3816-1
OIDs	is	attribute	equality	3816-1
<B>	from	constraint	the schema	3816-2
<B>	Recall	action	the schema	3816-2
the schema	of	constraint	Fig	3816-2
21.1		sequential	the names	3816-3
the names		sequential	Actors	3816-3
Actors		sequential	I	3816-3
I	and	conjunctive	Actors	3816-3
I	_	sequential	Actors	3816-3
Actors		sequential	you	3816-3
you		sequential	<B>	3816-3
The query6		sequential	The query6	3816-4
The dot notation		sequential	The dot notation	3816-5
<B>	as	constraint	the value	3816-6
<B>	to	constraint	the value	3816-6
<B>	is used	action	the value	3816-6
<B>	obtain	action	the value	3816-6
the value	of	constraint	specific fields	3816-6
<B>	In	constraint	query	3817-1
query		sequential	21.1	3817-1
21.1		sequential	we	3817-1
we	tested	action	two objects	3817-1
two objects	for	constraint	equality	3817-1
equality	whether	constraint	they	3817-1
equality	essentially testing	action	they	3817-1
they	had	action	the same OID	3817-1
<B>	Although	constraint	it	3817-2
it	does not increase	action	the expressive power	3817-2
the expressive power	of	constraint	the language	3817-2
the language		sequential	it	3817-2
it	to	constraint	an alternative test	3817-2
it	is	attribute	customary	3817-2
it	introduce	action	an alternative test	3817-2
an alternative test	for	constraint	equality	3817-2
equality	called	action	value equality	3817-2
<B>	whether	constraint	the values	3817-3
<B>	tests	action	the values	3817-3
the values	of	constraint	two objects	3817-3
two objects	of	constraint	their OIDs	3817-3
two objects	whether	constraint	their OIDs	3817-3
two objects	are	attribute	equal	3817-3
their OIDs	are	attribute	distinct	3817-3
<B>	To	constraint	the three objects	3818-1
<B>	illustrate	action	the three objects	3818-1
<B>	consider	action	the three objects	3818-1
the three objects	having	action	Actor	3818-1
Actor		sequential	type	3818-1
type		sequential	oid	3818-1
oid		sequential	50	3818-1
50		sequential	name	3818-1
name		sequential	Martin	3818-1
Martin		sequential	citizenship	3818-1
citizenship		sequential	gender	3818-1
gender		sequential	male	3818-1
male		sequential	award	3818-1
award		sequential	}	3818-1
}		sequential	acts	3818-1
acts	in	constraint	oid	3818-1
acts	_	sequential	oid	3818-1
oid		sequential	33	3818-1
33		sequential	}	3818-1
<B>	Yet	conjunctive	another form	3818-2
another form	of	constraint	equality	3818-2
equality	is	attribute	deep equality	3818-2
<B>	If	constraint	oid 33	3818-3
oid 33	and	conjunctive	oid 34	3818-3
oid 34	are	attribute	value equal	3818-3
value equal		sequential	oid 50	3818-3
oid 50	and	conjunctive	oid	3818-3
oid		sequential	52	3818-3
52	are	attribute	deep equal	3818-3
two objects	if	constraint	the trees	3818-4
two objects	are	attribute	Intuitively deep equal	3818-4
the trees	by	constraint	each object	3818-4
the trees	obtained	action	each object	3818-4
the trees	recursively replacing	action	each object	3818-4
each object	by	constraint	its value	3818-4
its value	are	attribute	equal	3818-4
The infinite trees		sequential	that	3818-5
that		sequential	we	3818-5
we	obtain	action	the expansions	3818-5
we	are called	action	the expansions	3818-5
They	present	action	some regularity	3818-6
some regularity		sequential	they	3818-6
they	are	attribute	regular trees	3818-6
regular trees	see	action	Exercise 21.10	3818-6
The notion	of	constraint	deep equality	3819-1
deep equality	highlights	action	a major difference	3819-1
a major difference	between	constraint	value	3819-1
value	and	conjunctive	models	3819-1
value	based	action	models	3819-1
value	object based	action	models	3819-1
<B>	In	constraint	a model	3819-2
<B>	value based	action	a model	3819-2
a model	or	conjunctive	the value	3819-2
the value		sequential	6	3819-2
Object Databases models		sequential	the database	3820-1
the database	of	constraint	a collection	3820-1
the database	as	constraint	a collection	3820-1
the database	can be thought	action	a collection	3820-1
a collection	of	constraint	trees	3820-1
The connections	between	constraint	trees	3820-2
trees	as	constraint	a result	3820-2
trees	arise	action	a result	3820-2
a result	of	constraint	the contents	3820-2
the contents	of	constraint	atomic fields	3820-2
<B>	is	attribute	they	3820-3
they	are	attribute	implicit	3820-3
the same string	may appear twice	action	<B>	3820-3
<B>	In	constraint	the world	3820-4
<B>	object oriented	action	the world	3820-4
the world		sequential	a database instance	3820-4
a database instance	of	constraint	graph	3820-4
a database instance	as	constraint	graph	3820-4
a database instance	can be thought	action	graph	3820-4
Paths	in	constraint	the database	3820-5
the database	are	attribute	more explicit	3820-5
<B>	is	attribute	one	3820-6
one	may view	action	oid	3820-6
oid		sequential	value	3820-6
value		sequential	an pair	3820-6
an pair	as	constraint	a form	3820-6
a form	of	constraint	logical pointer	3820-6
logical pointer	and	conjunctive	a path	3820-6
a path	as	constraint	a sequence	3820-6
a sequence	of	constraint	pointer dereferencing	3820-6
graph	based	action	This perspective	3821-1
This perspective	to	constraint	a navigational form	3821-1
This perspective	leads naturally	action	a navigational form	3821-1
a navigational form	of	constraint	data access	3821-1
data access	e.g. using	action	a sequence	3821-1
a sequence		sequential	o	3821-1
director		sequential	director	3821-2
citizenship	to	constraint	the citizenship	3821-3
citizenship	find	action	the citizenship	3821-3
the citizenship	of	constraint	the director	3821-3
the director	of	constraint	a given movie object o	3821-3
<B>	to	constraint	object	3821-4
<B>	has led	attribute	some	3821-4
<B>	view	action	object	3821-4
object	oriented	action	models	3821-4
models	as	constraint	models	3821-4
models	than	constraint	models	3821-4
models	value based	action	models	3821-4
models		sequential	the relational model	3821-4
<B>	because	constraint	declarativeness	3821-5
<B>	is	attribute	inaccurate	3821-5
declarativeness	is	attribute	more a property	3821-5
more a property	of	constraint	access languages	3821-5
access languages	than	constraint	models	3821-5
the calculus	for	constraint	OODBs	3821-6
OODBs	that	constraint	a highly declarative language	3821-6
OODBs	described here	action	a highly declarative language	3821-6
OODBs	Indeed illustrates	action	a highly declarative language	3821-6
a highly declarative language	for	constraint	the OODB model	3821-6
a highly declarative language	can be developed	action	the OODB model	3821-6
We	conclude	action	the discussion	3822-1
the discussion	of	constraint	object	3822-1
object	oriented	action	the calculus	3822-1
the calculus	by	constraint	methods	3822-1
the calculus	incorporating	action	methods	3822-1
<B>	For	constraint	this discussion	3822-2
this discussion		sequential	it	3822-2
it	is	attribute	irrelevant	3822-2
the methods	or	conjunctive	this evaluation	3822-2
the methods	how are specified	action	this evaluation	3822-2
the methods	evaluated	action	this evaluation	3822-2
this evaluation	to	constraint	the query	3822-2
this evaluation	is	attribute	external	3822-2
The query	simply uses	action	the method invocations	3822-3
the method invocations	as	constraint	oracles	3822-3
Method resolution	uses	action	dynamic binding	3822-4
The value	of	constraint	an expression	3822-5
an expression	of	constraint	the form m	3822-5
the form m		sequential	t1	3822-5
<B>	.	sequential	<B>	3822-6
<B>	.	sequential	<B>	3822-7
tn	under	constraint	a given variable assignment	3822-8
a given variable assignment		sequential	ν	3822-8
ν	by	constraint	the implementation	3822-8
ν	is obtained	action	the implementation	3822-8
ν	evaluating	action	the implementation	3822-8
the implementation	of	constraint	m	3822-8
m	for	constraint	the class	3822-8
the class	of	constraint	ν	3822-8
ν		sequential	t1	3822-8
t1	on	constraint	input ν	3822-8
input ν		sequential	t1	3822-8
<B>	.	sequential	<B>	3822-9
<B>	.	sequential	<B>	3822-10
tn		sequential	tn	3822-11
<B>	In	constraint	this context	3822-12
this context		sequential	it	3822-12
it	that	constraint	m	3822-12
it	is assumed	action	m	3822-12
m	has	action	no side effects	3822-12
<B>	Although	constraint	the incorporation	3822-13
<B>	not defined formally here	attribute	the following	3822-13
<B>	illustrates	action	the incorporation	3822-13
the incorporation	of	constraint	methods	3822-13
methods	into	constraint	the calculus	3822-13
Object Creation	and	conjunctive	Completeness	3823-1
Completeness		sequential	Relational queries	3823-1
Relational queries	take	action	relational instances	3823-1
relational instances	as	constraint	input	3823-1
input	and	conjunctive	relational instances	3823-1
input	produce	action	relational instances	3823-1
relational instances	as	constraint	output	3823-1
The preceding calculus	to	constraint	the analogous capability	3823-2
The preceding calculus	fails	action	the analogous capability	3823-2
The preceding calculus	provide	action	the analogous capability	3823-2
the analogous capability	because	constraint	the output	3823-2
the output	of	constraint	a calculus query	3823-2
a calculus query	is	attribute	a set	3823-2
a set	of	constraint	values	3823-2
values	or	conjunctive	objects	3823-2
Two features	for	constraint	a query language	3823-3
Two features	are needed	action	a query language	3823-3
a query language	to	constraint	the structural portion	3823-3
a query language	produce	action	the structural portion	3823-3
a query language	full fledged	action	the structural portion	3823-3
the structural portion	of	constraint	object	3823-3
object	oriented	action	an instance	3823-3
an instance		sequential	the ability	3823-3
the ability	to	constraint	OIDs	3823-3
the ability	create	action	OIDs	3823-3
OIDs	and	conjunctive	the ability	3823-3
the ability	to	constraint	a family	3823-3
the ability	populate	action	a family	3823-3
a family	of	constraint	named values	3823-3
named values	producing	action	a single set	3823-3
We	first introduce	action	an extension	3824-1
an extension	of	constraint	the while language	3824-1
the while language	of	constraint	Chapter 14	3824-1
Chapter 14		sequential	that	3824-1
that	of	constraint	these capabilities	3824-1
that	incorporates	attribute	both	3824-1
This language	to	constraint	a discussion	3824-2
This language	leads naturally	action	a discussion	3824-2
a discussion	of	constraint	completeness	3824-2
completeness	of	constraint	OODB access languages	3824-2
<B>	After	constraint	we	3824-3
we	mention	action	a second approach	3824-3
a second approach	to	constraint	object creation	3824-3
object creation		sequential	that	3824-3
that	from	constraint	the perspective	3824-3
that	stems	action	the perspective	3824-3
the perspective	of	constraint	logic programming	3824-3
The extension	of	constraint	obj	3825-1
The extension	while	constraint	obj	3825-1
The extension	while	constraint	obj	3825-1
The extension	introduced here	action	obj	3825-1
The extension	is denoted	action	obj	3825-1
It	will create	action	new OIDs	3825-2
new OIDs	in	constraint	a manner	3825-2
a manner	of	constraint	the language	3825-2
the language	while	constraint	Chapter 18	3825-2
the language	of	constraint	Chapter 18	3825-2
Chapter 18	invented	action	new constants	3825-2
The language	while	constraint	obj	3826-1
obj	incorporates	action	features	3826-1
obj	object oriented	action	features	3826-1
features		sequential	dereferencing	3826-1
dereferencing	and	conjunctive	method	3826-1
method		sequential	calls	3826-1
calls	as	constraint	the calculus	3826-1
calls	in	constraint	the calculus	3826-1
<B>	To	constraint	we	3826-2
<B>	illustrate	action	we	3826-2
we	present	action	a while obj program	3826-2
a while obj program		sequential	that	3826-2
that	collects	action	all actors	3826-2
all actors	from	constraint	an actor	3826-2
an actor		sequential	I	3826-2
I	like	action	Liv Ullman	3826-2
<B>	In	constraint	this query	3826-3
this query		sequential	v_ movies	3826-3
v_ movies	and	conjunctive	v_ directors	3826-3
v_ directors	as	constraint	variables	3826-3
v_ directors	serve	action	variables	3826-3
variables	as	constraint	a new name	3826-3
variables	and	conjunctive	a new name	3826-3
variables	reachable serves	action	a new name	3826-3
a new name		sequential	that	3826-3
that	will hold	action	the output	3826-3
<B>	=	sequential	x	3827-1
x		sequential	x ∈ Actors	3827-1
x ∈ Actors		sequential	I	3827-1
I	_	sequential	∧ x	3827-1
name	=	sequential	Liv Ullman	3827-2
Liv Ullman		sequential	v_ movies	3827-2
v_ movies	=	sequential	}	3827-2
v_ movies	{	sequential	}	3827-2
}		sequential	v_ directors	3827-2
v_ directors	=	sequential	}	3827-2
v_ directors	{	sequential	}	3827-2
}	while	constraint	change	3827-2
change	=	sequential	reachable ∪	3827-2
change	do begin	attribute	reachable	3827-2
reachable ∪		sequential	x	3827-2
x		sequential	∃y	3827-2
∃y		sequential	y	3827-2
y		sequential	∈ v_ movies	3827-2
∈ v_ movies		sequential	∧ ∈	3827-2
∧ ∈		sequential	x	3827-2
x		sequential	y	3827-2
actors		sequential	}	3827-3
}		sequential	v_ directors	3827-3
v_ directors	=	sequential	v_ directors	3827-3
v_ directors		sequential	movies	3827-3
movies	=	sequential	v_ movies end	3827-3
The operator new	as	constraint	<B>	3827-4
The operator new	works	action	<B>	3827-4
The operator new	follows	action	<B>	3827-4
It	as	constraint	input	3827-5
It	takes	action	input	3827-5
input		sequential	a set	3827-5
a set	of	constraint	values	3827-5
values	or	conjunctive	objects	3827-5
objects	and	conjunctive	one new OID	3827-5
objects	produces	action	one new OID	3827-5
one new OID	for	constraint	each value	3827-5
each value	in	constraint	the set	3827-5
<B>	As	constraint	a simple example	3827-6
a simple example	that	constraint	we	3827-6
a simple example	suppose	action	we	3827-6
we	to	constraint	the quadruples	3827-6
we	want	action	the quadruples	3827-6
we	objectify	action	the quadruples	3827-6
the quadruples	in	constraint	the named value Pariscope	3827-6
the named value Pariscope	of	constraint	the schema	3827-6
the schema	of	constraint	Fig	3827-6
21.1		sequential	21.1	3827-7
<B>	with	constraint	the commands	3827-8
<B>	may be accomplished	action	the commands	3827-8
the commands	add	action	class Pariscope	3827-8
class Pariscope		sequential	obj type tuple	3827-8
obj type tuple		sequential	theater	3827-8
theater		sequential	Theater	3827-8
Theater		sequential	time	3827-8
time		sequential	string	3827-8
string		sequential	price	3827-8
price		sequential	integer	3827-8
integer		sequential	movie	3827-8
movie		sequential	Movie	3827-8
Movie		sequential	Pariscope	3827-8
Pariscope	_	sequential	obj	3827-8
obj	=	sequential	Pariscope	3827-8
The new operator	to	constraint	the new operator	3828-1
The new operator	used here	attribute	closely related	3828-1
The new operator	is	attribute	closely related	3828-1
the new operator	of	constraint	the language	3828-1
the language	while	constraint	Chapter 18	3828-1
the language	of	constraint	Chapter 18	3828-1
<B>	that	constraint	obj	3828-2
<B>	while	constraint	obj	3828-2
<B>	Given	action	obj	3828-2
obj	has	action	iteration	3828-2
iteration	and	conjunctive	the ability	3828-2
the ability	to	constraint	new OIDs	3828-2
the ability	create	action	new OIDs	3828-2
new OIDs		sequential	it	3828-2
it	to	constraint	the expressive power	3828-2
it	about	constraint	the expressive power	3828-2
it	is	attribute	natural	3828-2
it	ask	action	the expressive power	3828-2
the expressive power	of	constraint	this language	3828-2
<B>	To	constraint	the stage	3828-3
<B>	set	action	the stage	3828-3
the stage		sequential	we	3828-3
we	introduce	action	the following analogue	3828-3
the following analogue	of	constraint	the notion	3828-3
the notion	of	constraint	query	3828-3
query		sequential	which	3828-3
which	mimics	action	the one	3828-3
the one	of	constraint	Chapter 18	3828-3
The definition	on	constraint	the structural portion	3828-4
The definition	focuses	action	the structural portion	3828-4
the structural portion	of	constraint	the OODB model	3828-4
the OODB model		sequential	methods	3828-4
methods	from	constraint	consideration	3828-4
methods	are excluded	action	consideration	3828-4
Definition		sequential	21.3.1	3829-1
A determinate query	is	attribute	a relation Q	3829-2
a relation Q	from	constraint	inst	3829-2
inst		sequential	R	3829-2
R	to	constraint	S	3829-2
R	inst	action	S	3829-2
S	that	constraint	Q	3829-2
Q	is	attribute	such a computable	3829-2
Object Databases		sequential	Object Databases	3830-1
Parts		sequential	c	3830-2
c	and	conjunctive	d	3830-2
d	of	constraint	the definition	3830-2
the definition	that	constraint	a determinate query Q	3830-2
the definition	ensure	action	a determinate query Q	3830-2
a determinate query Q	as	constraint	a function	3830-2
a determinate query Q	can be viewed	action	a function	3830-2
a function	from	constraint	OID equivalence classes	3830-2
OID equivalence classes	of	constraint	instances	3830-2
instances	over	constraint	OID equivalence	3830-2
instances	to	constraint	OID equivalence	3830-2
OID equivalence		sequential	R classes	3830-2
R classes	of	constraint	instances	3830-2
instances	over	constraint	S.	3830-2
S.		sequential	OIDs	3830-2
OIDs	So serve here	action	two purposes	3830-2
two purposes		sequential	They	3830-2
They	to	constraint	the same way	3830-2
They	in	constraint	the same way	3830-2
They	1 are used	action	the same way	3830-2
They	compute	action	the same way	3830-2
the same way	that	constraint	invented values	3830-2
invented values	to	constraint	the polynomial space barrier	3830-2
invented values	were used	action	the polynomial space barrier	3830-2
invented values	break	action	the polynomial space barrier	3830-2
the polynomial space barrier	and	conjunctive	they	3830-2
they	are	attribute	2 now essential components	3830-2
2 now essential components	of	constraint	the data structure	3830-2
the data structure	in	constraint	the result	3830-2
the data structure	of	constraint	the result	3830-2
the data structure	and	conjunctive	the result	3830-2
<B>	With	constraint	respect	3830-3
respect	to	constraint	2	3830-3
2		sequential	an important aspect	3830-3
an important aspect	that	constraint	we	3830-3
an important aspect	is	attribute	we	3830-3
we	with	constraint	the actual value	3830-3
we	are	attribute	not concerned	3830-3
the actual value	of	constraint	the OIDs	3830-3
the OIDs		sequential	which	3830-3
which	motivates	action	the use	3830-3
the use	of	constraint	the equivalence relation	3830-3
Two results	as	constraint	they	3830-4
Two results	if	constraint	they	3830-4
Two results	are viewed	attribute	identical	3830-4
they	to	constraint	the renaming	3830-4
they	are	attribute	the same up	3830-4
the renaming	of	constraint	the OIDs	3830-4
<B>	Like	constraint	whilenew	3831-1
whilenew		sequential	whileobj	3831-1
whileobj	is	attribute	not determinate	3831-1
There	is	attribute	an elegant characterization	3831-2
an elegant characterization	of	constraint	the determinate queries	3831-2
the determinate queries	in	constraint	whileobj	3831-2
the determinate queries	expressible	action	whileobj	3831-2
This result		sequential	which	3831-3
which		sequential	we	3831-3
we	state next	action	a local characterization	3831-3
we	uses	action	a local characterization	3831-3
a local characterization	of	constraint	input	3831-3
input		sequential	output	3831-3
output		sequential	pairs	3831-3
pairs	of	constraint	whileobj programs	3831-3
That characterization	in	constraint	the spirit	3831-4
That characterization	is	attribute	the spirit	3831-4
the spirit	of	constraint	the notion	3831-4
the notion	of	constraint	bp completeness	3831-4
bp completeness	relating	action	input output	3831-4
input output		sequential	pairs	3831-4
pairs	of	constraint	relational calculus queries	3831-4
relational calculus queries	see	action	Exercise 16.11	3831-4
<B>	For	constraint	input	3831-5
input		sequential	output	3831-5
output		sequential	each pair	3831-5
each pair		sequential	I	3831-5
I		sequential	J	3831-5
J		sequential	the characterization	3831-5
the characterization	of	constraint	whileobj queries	3831-5
whileobj queries	requires	action	a simple connection	3831-5
a simple connection	between	constraint	the automorphism group	3831-5
the automorphism group	of	constraint	I	3831-5
I	of	constraint	J	3831-5
I	and	conjunctive	J	3831-5
<B>	For	constraint	an instance	3831-6
an instance		sequential	K	3831-6
K	let	action	Aut	3831-6
Aut	K denote	action	the set	3831-6
the set	of	constraint	automorphisms	3831-6
automorphisms	of	constraint	K	3831-6
Theorem		sequential	21.3.2	3832-1
<B>	if	constraint	The only part	3833-1
The only part	of	constraint	the theorem	3833-1
the theorem	by	constraint	an extension	3833-1
the theorem	is proven	action	an extension	3833-1
an extension	of	constraint	the trace technique	3833-1
the trace technique	in	constraint	the proof	3833-1
the trace technique	developed	action	the proof	3833-1
the proof	of	constraint	Theorem 18.2.5	3833-1
Theorem 18.2.5		sequential	Exercise	3833-1
Exercise		sequential	21.14	3833-1
<B>	if	constraint	The part	3833-2
The part	on	constraint	group	3833-2
The part	and	conjunctive	group	3833-2
The part	is	attribute	considerably more complex	3833-2
The part	is based	action	group	3833-2
group		sequential	a argument	3833-2
Proposition		sequential	21.3.3	3834-1
21.3.3		sequential	Query q	3834-1
Query q	of	constraint	Fig	3834-1
<B>	in	constraint	whileobj	3834-2
<B>	is	attribute	21.3 not expressible	3834-2
Proof	Let	action	I	3835-1
I		sequential	J	3835-1
J	be	attribute	input output	3835-1
input output		sequential	the pair	3835-1
the pair	of	constraint	Fig	3835-1
21.3		sequential	21.3	3835-2
The proof	by	constraint	contradiction	3835-3
The proof	is	attribute	contradiction	3835-3
<B>	Suppose	action	there	3836-1
there	is	attribute	a whileobj query	3836-1
a whileobj query		sequential	that	3836-1
that	produces	action	J	3836-1
J	on	constraint	input I	3836-1
<B>	By	constraint	Theorem 21.3.2	3836-2
Theorem 21.3.2		sequential	there	3836-2
there	is	attribute	an extension homomorphism h	3836-2
an extension homomorphism h	from	constraint	Aut	3836-2
Aut		sequential	I	3836-2
I	to	constraint	Aut	3836-2
Aut		sequential	I	3836-2
I		sequential	J	3836-2
<B>	Let	action	µ	3836-3
µ	be	attribute	the automorphism	3836-3
the automorphism	of	constraint	I	3836-3
I	and	conjunctive	b	3836-3
I	exchanging	attribute	a	3836-3
<B>	that	constraint	µ	3836-4
<B>	Note	action	µ	3836-4
µ		sequential	−1	3836-4
−1	=	sequential	µ	3836-4
µ		sequential	µ µ	3836-4
µ µ	so =	sequential	idI	3836-4
<B>	Consider	action	h	3836-5
h		sequential	µ	3836-5
µ	ψ	sequential	0	3836-5
<B>		sequential	µ	3836-6
µ	ψ	sequential	0	3836-6
0		sequential	∈	3836-6
∈	{	sequential	3 }	3836-6
∈	ψ 1	sequential	3 }	3836-6
∈	ψ	sequential	3 }	3836-6
<B>	Suppose	action	h	3836-7
h		sequential	µ	3836-7
µ		sequential	ψ0	3836-7
ψ0	=	sequential	the other case	3836-7
ψ0	ψ 1	sequential	the other case	3836-7
the other case	is	attribute	similar	3836-7
<B>	Then clearly b	action	Figure 21.3	3836-8
Figure 21.3		sequential	h	3836-8
h		sequential	µ	3836-8
µ	ψ	sequential	1	3836-8
1	=	sequential	<B>	3836-8
1	ψ 2	sequential	<B>	3836-8
<B>	Consider now	action	h	3836-9
h		sequential	µ	3836-9
µ	◦	sequential	µ	3836-9
µ	ψ	sequential	0	3836-9
We	on	constraint	one hand	3836-10
We	have	action	one hand	3836-10
one hand		sequential	h	3836-10
h		sequential	µ	3836-10
µ	◦	sequential	µ	3836-10
µ		sequential	ψ0	3836-10
ψ0	=	sequential	h	3836-10
h		sequential	µ	3836-10
µ	◦	sequential	h	3836-10
h		sequential	µ	3836-10
µ		sequential	ψ0	3836-10
ψ0		sequential	h	3836-10
h		sequential	µ	3836-10
µ	◦	sequential	µ	3836-10
µ		sequential	ψ0	3836-10
ψ0	=	sequential	h	3836-10
h		sequential	idI	3836-10
idI	ψ	sequential	0	3836-10
0		sequential	which	3836-10
which	is	attribute	a contradiction	3836-10
a contradiction	because	constraint	ψ0	3836-10
ψ0	=	sequential	<B>	3836-10
ψ0	ψ 2	sequential	<B>	3836-10
q	in	constraint	whileobj	3836-11
q	is	attribute	So not expressible	3836-11
It	to	constraint	a language	3837-1
It	is	attribute	possible	3837-1
It	obtain	action	a language	3837-1
a language	expressing	action	all determinate queries	3837-1
all determinate queries	by	constraint	whileobj	3837-1
all determinate queries	to	constraint	whileobj	3837-1
all determinate queries	adding	action	whileobj	3837-1
whileobj		sequential	a choose operator	3837-1
a choose operator		sequential	that	3837-1
that	allows	action	the selection	3837-1
the selection	in	constraint	nondeterministically a determinate manner	3837-1
the selection	but	conjunctive	nondeterministically a determinate manner	3837-1
nondeterministically a determinate manner	of	constraint	one object	3837-1
one object	out of	constraint	a set	3837-1
a set	of	constraint	objects	3837-1
objects		sequential	that	3837-1
that	are	attribute	isomorphic	3837-1
that	see	action	Exercise 18.14	3837-1
<B>	is	attribute	However a highly complex construct	3838-1
However a highly complex construct	because	constraint	it	3838-1
it	requires	action	the ability	3838-1
the ability	to	constraint	isomorphism	3838-1
the ability	for	constraint	isomorphism	3838-1
the ability	check	action	isomorphism	3838-1
isomorphism	of	constraint	graphs	3838-1
The search	for	constraint	simpler local constructs	3838-2
simpler local constructs		sequential	that	3838-2
that	yield	action	determinate	3838-2
determinate		sequential	a language	3838-2
a language	is	attribute	an active area	3838-2
an active area	of	constraint	research	3838-2
We	now briefly introduce	action	an alternative approach	3839-1
an alternative approach	for	constraint	OIDs	3839-1
an alternative approach	creating	action	OIDs	3839-1
OIDs		sequential	that	3839-1
that	from	constraint	the perspective	3839-1
that	stems	action	the perspective	3839-1
the perspective	of	constraint	datalog	3839-1
datalog	and	conjunctive	logic	3839-1
logic		sequential	programming	3839-1
<B>	that	constraint	a new OID	3839-2
<B>	Suppose	action	a new OID	3839-2
a new OID	to	constraint	each pair	3839-2
a new OID	for	constraint	each pair	3839-2
a new OID	is	attribute	each pair	3839-2
a new OID	be created	action	each pair	3839-2
each pair		sequential	t	3839-2
t		sequential	m	3839-2
m		sequential	movie m	3839-2
movie m	at	constraint	theater t	3839-2
movie m	where is playing	action	theater t	3839-2
theater t	according to	action	the current value	3839-2
the current value	of	constraint	Pariscope	3839-2
<B>	Consider	action	the following dataloglike rule	3839-3
the following dataloglike rule		sequential	Object Databases distinct pair	3839-3
Object Databases distinct pair	of	constraint	t	3839-3
t		sequential	m	3839-3
m		sequential	values	3839-3
<B>	Using	action	the symbol	3839-4
<B>	to	constraint	the following versions	3839-5
<B>	mean	attribute	a unique	3839-5
<B>	exists	attribute	a unique	3839-5
the following versions	of	constraint	the semantics	3839-5
the following versions	1 intuitively captures	action	the semantics	3839-5
<B>	that	constraint	Skolem functions	3840-1
<B>	suggests	action	Skolem functions	3840-1
Skolem functions	might be used	action	<B>	3840-1
<B>	Specifically let	action	ftm	3840-2
ftm	be	attribute	a function symbol	3840-2
a function symbol	with	constraint	the predicate create	3840-2
a function symbol	associated	action	the predicate create	3840-2
the predicate create		sequential	tm	3840-2
tm	_	sequential	object	3840-2
We	as	constraint	the universal quantifiers	3840-3
We	or	conjunctive	the universal quantifiers	3840-3
We	rewrite 2	action	the universal quantifiers	3840-3
We	leaving off	action	the universal quantifiers	3840-3
the universal quantifiers	as	constraint	datalog	3840-3
the universal quantifiers	in	constraint	datalog	3840-3
datalog		sequential	4	3840-3
4	create	action	tm	3840-3
tm	_	sequential	object	3840-3
object		sequential	ftm	3840-3
ftm		sequential	t	3840-3
t		sequential	m	3840-3
m		sequential	t	3840-3
t		sequential	m	3840-3
m		sequential	Pariscope	3840-3
Pariscope		sequential	t	3840-3
t		sequential	s	3840-3
s		sequential	m	3840-3
<B>	Under	constraint	some formulations	3840-4
some formulations	of	constraint	the approach	3840-4
the approach		sequential	syntactic objects	3840-4
syntactic objects		sequential	ftm	3840-4
ftm		sequential	oid	3840-4
oid		sequential	7	3840-4
7		sequential	oid	3840-4
oid		sequential	22	3840-4
22		sequential	oid 7	3840-4
oid 7	is	attribute	where the OID	3840-4
where the OID	of	constraint	some theater	3840-4
some theater	and	conjunctive	oid 22 the OID	3840-4
oid 22 the OID	of	constraint	some movie	3840-4
some movie	as	constraint	OIDs	3840-4
some movie	serve explicitly	action	OIDs	3840-4
<B>	Under	constraint	other formulations	3840-5
other formulations		sequential	such syntactic objects	3840-5
such syntactic objects	as	constraint	placeholders	3840-5
such syntactic objects	are viewed	action	placeholders	3840-5
placeholders	during	constraint	an intermediate stage	3840-5
an intermediate stage	of	constraint	query evaluation	3840-5
query evaluation	by	constraint	distinct new OIDs	3840-5
query evaluation	and	conjunctive	distinct new OIDs	3840-5
query evaluation	are replaced	action	distinct new OIDs	3840-5
distinct new OIDs	in	constraint	the final stage	3840-5
the final stage	of	constraint	query evaluation	3840-5
query evaluation	see	action	Exercise 21.13	3840-5
The latter approach	to	constraint	OID creation	3841-1
OID creation	into	constraint	complex value datalog	3841-1
OID creation	incorporated	action	complex value datalog	3841-1
complex value datalog	to	constraint	also OID dereferencing	3841-1
complex value datalog	extended	action	also OID dereferencing	3841-1
complex value datalog	include	action	also OID dereferencing	3841-1
also OID dereferencing	yields	action	a language	3841-1
a language	to	constraint	obj	3841-1
a language	while	constraint	obj	3841-1
<B>	As with	constraint	obj	3841-2
<B>	while	constraint	obj	3841-2
obj		sequential	this language	3841-2
this language	is	attribute	not determinate	3841-2
We	briefly illustrate	action	some features	3842-1
We	object oriented	action	some features	3842-1
some features	of	constraint	the language O2SQL	3842-1
the language O2SQL		sequential	which	3842-1
which	in	constraint	Section 20.8	3842-1
which	was introduced	action	Section 20.8	3842-1
Several examples	are presented	action	that	3842-2
that	show	action	O2SQL	3842-2
O2SQL	to	constraint	deeply nested complex values	3842-2
O2SQL	and	conjunctive	deeply nested complex values	3842-2
O2SQL	can be used	action	deeply nested complex values	3842-2
O2SQL	access	action	deeply nested complex values	3842-2
O2SQL	construct	action	deeply nested complex values	3842-2
We	now indicate	action	the use	3842-3
the use	of	constraint	objects	3842-3
objects	and	conjunctive	methods	3842-3
methods	into	constraint	the language	3842-3
methods	how is incorporated	action	the language	3842-3
It	to	constraint	methods	3842-4
It	that	constraint	methods	3842-4
It	is	attribute	interesting	3842-4
It	note	action	methods	3842-4
methods	and	conjunctive	nested complex values	3842-4
nested complex values	in	constraint	this language	3842-4
nested complex values	are elegantly combined	action	this language	3842-4
this language		sequential	which	3842-4
which	has	action	the appearance	3842-4
the appearance	of	constraint	SQL	3842-4
SQL	on	constraint	the functional programming paradigm	3842-4
SQL	but	conjunctive	the functional programming paradigm	3842-4
SQL	is essentially based	action	the functional programming paradigm	3842-4
<B>	For	constraint	this example	3843-1
this example		sequential	we	3843-1
we	again assume	action	the complex value Films	3843-1
the complex value Films	of	constraint	Fig	3843-1
20.2	but	conjunctive	we	3843-2
we	that	constraint	Age	3843-2
we	assume	action	Age	3843-2
Age	is	attribute	a method	3843-2
a method	for	constraint	the class Person	3843-2
a method	defined	action	the class Person	3843-2
the class Person	for	constraint	thus Director	3843-2
the class Person	and	conjunctive	thus Director	3843-2
<B>	select	action	tuple	3844-1
tuple		sequential	f. Director f.Director	3844-1
Languages	for	constraint	Methods	3845-1
<B>	In	constraint	this section	3845-2
this section		sequential	we	3845-2
we	present	action	two abstract programming languages	3845-2
two abstract programming languages	for	constraint	method implementations	3845-2
two abstract programming languages	specifying	action	method implementations	3845-2
Method implementations	in	constraint	the specification	3845-3
Method implementations	will be included	action	the specification	3845-3
the specification	of	constraint	methods	3845-3
methods	in	constraint	OODB schemas	3845-3
<B>	In	constraint	these languages	3845-4
<B>	studying	action	these languages	3845-4
these languages		sequential	we	3845-4
we	emphasize	action	two important issues	3845-4
two important issues		sequential	type safety	3845-4
type safety	and	conjunctive	expressive power	3845-4
This focus	largely motivates	action	our choice	3845-5
our choice	of	constraint	languages	3845-5
languages	and	conjunctive	the particular abstractions	3845-5
the particular abstractions	considered	action	<B>	3845-5
The first language	is	attribute	an imperative programming language	3846-1
The second method schemas	of	constraint	a functional style	3846-2
The second method schemas	is	attribute	representative	3846-2
a functional style	of	constraint	database access	3846-2
<B>	In	constraint	the first language	3846-3
the first language		sequential	we	3846-3
we	will gather	action	a number	3846-3
a number	of	constraint	features	3846-3
features	in	constraint	object	3846-3
object	oriented	action	practical database languages	3846-3
practical database languages		sequential	side	3846-3
side		sequential	effect	3846-3
effect		sequential	iteration	3846-3
iteration		sequential	conditionals	3846-3
We	that	constraint	these features	3846-4
We	with	constraint	these features	3846-4
We	will see	action	these features	3846-4
these features		sequential	we	3846-4
we	as	constraint	completeness	3846-4
we	get	action	completeness	3846-4
we	could be expected	action	completeness	3846-4
completeness	and	conjunctive	we	3846-4
we	pay	action	the obvious price	3846-4
the obvious price	for	constraint	it	3846-4
it		sequential	the undecidability	3846-4
the undecidability	of	constraint	many questions	3846-4
many questions		sequential	type safety	3846-4
<B>	With	constraint	method schemas	3846-5
method schemas		sequential	we	3846-5
we	on	constraint	the essence	3846-5
we	focus	action	the essence	3846-5
the essence	of	constraint	inheritance	3846-5
inheritance	and	conjunctive	methods	3846-5
We	voluntarily consider	action	a limited language	3846-6
We	that	constraint	the undecidability	3846-7
We	see	action	the undecidability	3846-7
the undecidability	of	constraint	type safety	3846-7
type safety	is	attribute	a consequence	3846-7
a consequence	of	constraint	recursion	3846-7
recursion	in	constraint	method calls	3846-7
We	obtain	action	decidability	3846-8
decidability	in	constraint	the restricted case	3846-8
the restricted case	of	constraint	monadic methods	3846-8
<B>	With	constraint	respect	3846-9
respect	to	constraint	expressiveness	3846-9
expressiveness		sequential	we	3846-9
we	present	action	a surprising characterization	3846-9
a surprising characterization	of	constraint	qptime	3846-9
qptime	in	constraint	terms	3846-9
terms	of	constraint	a simple language	3846-9
a simple language	with	constraint	methods	3846-9
<B>	For	constraint	both languages	3847-1
both languages		sequential	we	3847-1
we	study	action	type safety	3847-1
type safety	and	conjunctive	expressive power	3847-1
We	by	constraint	the meaning	3847-2
We	begin	action	the meaning	3847-2
We	discussing briefly	action	the meaning	3847-2
the meaning	of	constraint	these notions	3847-2
these notions	in	constraint	our context	3847-2
our context	and	conjunctive	we	3847-2
we	present	action	the two languages	3847-2
the two languages	and	conjunctive	the results	3847-2
<B>	To	constraint	the expressive power	3848-1
<B>	evaluate	action	the expressive power	3848-1
the expressive power	of	constraint	OODB schemas	3848-1
OODB schemas	using	action	a particular language	3848-1
a particular language	for	constraint	method implementation	3848-1
method implementation		sequential	a common approach	3848-1
a common approach	to	constraint	relational queries	3848-1
a common approach	is	attribute	relational queries	3848-1
a common approach	simulate	action	relational queries	3848-1
relational queries	and	conjunctive	what family	3848-1
relational queries	ask	action	what family	3848-1
what family	of	constraint	relational queries	3848-1
relational queries	can be simulated	action	<B>	3848-1
<B>	If	constraint	OID creation	3848-2
OID creation	is permitted	action	all computable relational queries	3848-2
all computable relational queries	can be simulated	action	the imperative language	3848-2
all computable relational queries	using	action	the imperative language	3848-2
The expressive power	of	constraint	imperative methods	3848-3
imperative methods	without	constraint	OID creation	3848-3
OID creation	on	constraint	the complex types	3848-3
OID creation	depends	action	the complex types	3848-3
the complex types	in	constraint	OODB schemas	3848-3
the complex types	permitted	action	OODB schemas	3848-3
We	also present	action	a result	3848-4
a result	for	constraint	the expressive power	3848-4
the expressive power	of	constraint	method schemas	3848-4
method schemas	that	constraint	the family	3848-4
method schemas	showing	action	the family	3848-4
the family	of	constraint	method schemas	3848-4
method schemas	using	action	an ordered domain	3848-4
an ordered domain	of	constraint	atomic elements	3848-4
atomic elements	expresses	action	exactly qptime	3848-4
<B>	To	constraint	the issue	3849-1
<B>	consider	action	the issue	3849-1
the issue	of	constraint	type safety	3849-1
type safety	in	constraint	a general context	3849-1
a general context		sequential	we	3849-1
we	present	action	imperative	3849-1
imperative		sequential	OODB	3849-1
OODB		sequential	the model	3849-1
the model		sequential	which	3849-1
which	incorporates	action	imperative method implementations	3849-1
This model	simplifies	action	the OODB model	3849-2
the OODB model	by	constraint	the type	3849-2
the OODB model	that	constraint	the type	3849-2
the OODB model	presented earlier	action	the type	3849-2
the OODB model	assuming	action	the type	3849-2
the type	of	constraint	each class	3849-2
each class	is	attribute	a tuple	3849-2
a tuple	of	constraint	values	3849-2
values	and	conjunctive	OIDs	3849-2
a schema	in	constraint	this model	3849-3
this model	However will include	action	an assignment	3849-3
an assignment	of	constraint	implementations	3849-3
implementations	to	constraint	method signatures	3849-3
Object Databases		sequential	Object Databases	3850-1
<B>	.	sequential	<B>	3850-2
<B>	.	sequential	<B>	3850-3
un		sequential	var	3850-4
var		sequential	x1	3850-4
<B>	.	sequential	<B>	3850-5
<B>	.	sequential	<B>	3850-6
xl		sequential	body	3850-7
body		sequential	s1	3850-7
<B>	.	sequential	<B>	3850-8
<B>	.	sequential	<B>	3850-9
sq		sequential	return x1	3850-10
return x1		sequential	the ui	3850-10
the ui		sequential	s	3850-10
s	are	attribute	where parameters	3850-10
where parameters	n	conjunctive	≥	3850-10
≥		sequential	1	3850-10
1		sequential	the xj	3850-10
the xj		sequential	s	3850-10
s	are	attribute	internal variables	3850-10
internal variables		sequential	l	3850-10
l	≥	sequential	1	3850-10
1	for	constraint	each p	3850-10
1	and	conjunctive	each p	3850-10
each p		sequential	∈	3850-10
∈		sequential	1	3850-10
1		sequential	q	3850-10
q		sequential	sp	3850-10
sp	is	attribute	a statement	3850-10
a statement	of	constraint	one	3850-10
one	of	constraint	the following forms	3850-10
the following forms	w	constraint	where y	3850-10
where y		sequential	z range	3850-10
z range	over	constraint	parameters	3850-10
parameters	and	conjunctive	internal variables	3850-10
internal variables		sequential	Basic operations	3850-10
Class operations		sequential	Class operations	3851-1
t	t having	action	forms	3852-1
forms	from	constraint	this list	3852-1
<B>		sequential	<B>	3853-1
It	that	constraint	all internal variables	3854-1
It	is assumed	action	all internal variables	3854-1
all internal variables	before	constraint	some default value	3854-1
all internal variables	to	constraint	some default value	3854-1
all internal variables	are initialized	action	some default value	3854-1
all internal variables	used	action	some default value	3854-1
some default value	depending on	action	their type	3854-1
The intended semantics	for	constraint	the forms	3854-2
the forms	than	constraint	viii	3854-2
viii	be	attribute	should clear	3854-2
<B>	to	constraint	<B>	3854-3
<B>	Here does not mean	attribute	easy	3854-3
<B>	implement	action	<B>	3854-3
The looping construct	for	constraint	each element	3854-4
The looping construct	executes	action	each element	3854-4
each element	of	constraint	the extension	3854-4
the extension		sequential	not disjoint extension	3854-4
not disjoint extension	of	constraint	class c	3854-4
<B>	In	constraint	we	3854-5
we	on	constraint	OODB schemas	3854-5
we	focus	action	OODB schemas	3854-5
OODB schemas	in	constraint	which	3854-5
which		sequential	different orders	3854-5
different orders	of	constraint	execution	3854-5
execution	of	constraint	the loops	3854-5
the loops	yield	action	OID	3854-5
OID		sequential	results	3854-5
results	that	constraint	this property	3854-5
results	note	action	this property	3854-5
this property	is	attribute	undecidable	3854-5
it	by	constraint	the programmer	3854-5
it	so must be ensured	action	the programmer	3854-5
<B>	is	attribute	an assignment	3855-1
an assignment	of	constraint	implementations	3855-1
implementations	to	constraint	signatures	3855-1
The notion	of	constraint	instance	3855-2
instance	for	constraint	this model	3855-2
this model	in	constraint	the natural fashion	3855-2
this model	is defined	action	the natural fashion	3855-2
It	to	constraint	operational semantics	3856-1
It	is	attribute	straightforward	3856-1
It	develop	action	operational semantics	3856-1
operational semantics	for	constraint	this model	3856-1
this model		sequential	the execution	3856-1
the execution	of	constraint	a given method call	3856-1
a given method call	as	constraint	the result	3856-1
a given method call	or	conjunctive	the result	3856-1
a given method call	be	attribute	where might successful	3856-1
a given method call	nonterminating	action	the result	3856-1
a given method call	aborted	action	the result	3856-1
the result	of	constraint	a runtime type error	3856-1
a runtime type error		sequential	Exercise	3856-1
Exercise		sequential	21.15a	3856-1
Type Safety	in	constraint	the Imperative Model	3857-1
<B>	Given	action	a Turing machine M	3858-1
a Turing machine M		sequential	it	3858-1
it	to	constraint	schema	3858-1
it	is	attribute	easy	3858-1
it	develop	action	schema	3858-1
schema		sequential	a S	3858-1
a S	in	constraint	this model	3858-1
this model		sequential	that	3858-1
that	can simulate	action	the operation	3858-1
the operation	of	constraint	M	3858-1
M	on	constraint	a suitable encoding	3858-1
a suitable encoding	of	constraint	an input tape	3858-1
an input tape		sequential	Exercise	3858-1
Exercise		sequential	21.15	3858-1
21.15		sequential	c	3858-1
<B>	that	constraint	such schemas	3858-2
<B>	shows	action	such schemas	3858-2
such schemas	and	conjunctive	the usual undecidability results	3858-2
such schemas	are	attribute	computationally powerful	3858-2
such schemas	implies	action	the usual undecidability results	3858-2
<B>	With	constraint	regard	3858-3
regard	to	constraint	type safety	3858-3
type safety		sequential	it	3858-3
it	to	constraint	Exercise 21.16	3858-3
it	is	attribute	easy	3858-3
it	verify	attribute	the	3858-3
it	following	action	Exercise 21.16	3858-3
Exercise 21.16		sequential	Proposition 21.4.1	3858-3
<B>	if	constraint	method implementations	3858-4
<B>	in	constraint	method implementations	3858-4
<B>	remains	attribute	true	3858-4
method implementations		sequential	conditional statements	3858-4
conditional statements	and	conjunctive	the new operator	3858-4
the new operator	and	conjunctive	all methods	3858-4
the new operator	even are prohibited	action	all methods	3858-4
all methods	are	attribute	monadic	3858-4
all methods	have	action	only one argument	3858-4
Reachability	for	constraint	imperative schemas	3859-1
Reachability	is	attribute	also undecidable	3859-1
Expressive Power	of	constraint	the Imperative Model	3860-1
the Imperative Model		sequential	v ∈ I	3860-1
v ∈ I		sequential	Ri	3860-1
Ri		sequential	there	3860-1
there	is	attribute	exactly one object	3860-1
exactly one object	o	constraint	the extension	3860-1
exactly one object	in	constraint	the extension	3860-1
the extension	of	constraint	ci	3860-1
ci	that	constraint	the value	3860-1
the value	with	constraint	o	3860-1
the value	associated	action	o	3860-1
o	is	attribute	v	3860-1
v	and	conjunctive	all other classes	3860-1
all other classes	of	constraint	S	3860-1
S	are	attribute	empty	3860-1
<B>	Following	action	this spirit	3860-2
this spirit		sequential	it	3860-2
it	to	constraint	what	3860-2
it	is	attribute	straightforward	3860-2
it	define	action	what	3860-2
what		sequential	it	3860-2
it	for	constraint	a method	3860-2
it	means	action	a method	3860-2
a method		sequential	call	3860-2
call	in	constraint	schema S	3860-2
schema S	to	constraint	a relational query	3860-2
schema S	simulate	action	a relational query	3860-2
a relational query	from	constraint	R	3860-2
R	to	constraint	relation schema R	3860-2
We	consider	action	only schema S	3861-1
only schema S	for	constraint	which	3861-1
which		sequential	different orders	3861-1
different orders	of	constraint	evaluation	3861-1
evaluation	of	constraint	the looping construct	3861-1
the looping construct	yield	action	the same final result	3861-1
the same final result		sequential	generic mappings	3861-1
We	now have	attribute	the	3861-2
We	following	action	Exercise 21.20	3861-2
We	see	action	Exercise 21.20	3861-2
Exercise 21.20		sequential	Theorem 21.4.2	3861-2
The preceding result	on	constraint	the presence	3862-1
The preceding result	relies	action	the presence	3862-1
the presence	of	constraint	the new operator	3862-1
It	to	constraint	the expressive power	3862-2
It	about	constraint	the expressive power	3862-2
It	is	attribute	natural	3862-2
It	ask	action	the expressive power	3862-2
the expressive power	of	constraint	imperative schemas	3862-2
imperative schemas		sequential	that	3862-2
that	do not support	attribute	new	3862-2
<B>	As	constraint	Exercise 21.21	3862-3
<B>	in	constraint	Exercise 21.21	3862-3
<B>	discussed	action	Exercise 21.21	3862-3
Exercise 21.21		sequential	the expressive power	3862-3
the expressive power	on	constraint	the complex types	3862-3
the expressive power	depends	action	the complex types	3862-3
the complex types	for	constraint	objects	3862-3
the complex types	permitted	action	objects	3862-3
Object Databases		sequential	Object Databases	3863-1
<B>	uses	action	the nondeterminism	3863-2
the nondeterminism	of	constraint	each construct	3863-2
the nondeterminism	for	constraint	each construct	3863-2
nondeterministic queries		sequential	that	3863-3
that	are	attribute	not determinate	3863-3
that	Naturally can also be expressed	action	<B>	3863-3
Method Schemas		sequential	Method Schemas	3864-1
<B>	In	constraint	this model	3865-1
this model		sequential	we	3865-1
we	on	constraint	methods	3865-1
we	focus almost exclusively	action	methods	3865-1
methods	and	conjunctive	their implementations	3865-1
Two kinds	of	constraint	methods	3865-2
methods		sequential	base	3865-2
base	and	conjunctive	composite	3865-2
The base methods	do not have	action	implementations	3865-3
The implementations	of	constraint	composite methods	3865-4
composite methods	of	constraint	a composition	3865-4
composite methods	consist	action	a composition	3865-4
a composition	of	constraint	other methods	3865-4
We	now introduce	action	method schemas	3866-1
<B>	In	constraint	the next definition	3866-2
the next definition		sequential	we	3866-2
we	make	action	the simplifying assumption	3866-2
the simplifying assumption	that	constraint	there	3866-2
there	are	attribute	no named values	3866-2
no named values		sequential	only class names	3866-2
only class names	in	constraint	database schemas	3866-2
<B>	In	constraint	fact	3866-3
fact		sequential	data	3866-3
data	in	constraint	base methods	3866-3
data	is only stored	action	base methods	3866-3
<B>	In	constraint	σ	3866-4
<B>	following	action	σ	3866-4
σ	denotes	action	the type assignment σ	3866-4
the type assignment σ		sequential	c	3866-4
c	for	constraint	every class	3866-4
c	=	sequential	every class	3866-4
Definition		sequential	21.4.3	3867-1
The semantics	of	constraint	methods	3868-1
methods	in	constraint	the obvious way	3868-1
methods	is defined	action	the obvious way	3868-1
<B>	For	constraint	instance	3868-2
instance	to	constraint	m	3868-2
instance	compute	action	m	3868-2
m		sequential	o	3868-2
o		sequential	o′	3868-2
o′		sequential	one	3868-2
one	computes	action	first o1	3868-2
first o1	=	sequential	m2	3868-2
m2		sequential	o	3868-2
o	and	conjunctive	o2	3868-2
o2	=	sequential	m1	3868-2
m1		sequential	o	3868-2
o		sequential	o′	3868-2
o′		sequential	the result	3868-2
the result	is	attribute	m1	3868-2
m1		sequential	o1	3868-2
o1		sequential	o2	3868-2
The range	of	constraint	composite methods	3868-3
composite methods	is left	attribute	unspecified	3868-3
it	because	constraint	it	3868-3
it	is	attribute	any	3868-3
it	by	constraint	the domain	3868-3
it	is determined	action	the domain	3868-3
the domain	and	conjunctive	the method implementation	3868-3
the method implementation	as	constraint	a composition	3868-3
a composition	of	constraint	methods	3868-3
<B>	Because	constraint	the range	3868-4
the range	of	constraint	composite methods	3868-4
composite methods	is	attribute	always any	3868-4
we	will sometimes only specify	action	their domain	3868-4
<B>	Let	action	S	3869-1
S		sequential	C	3869-1
C		sequential	≺	3869-1
≺		sequential	M base	3869-1
M base		sequential	M comp	3869-1
M comp		sequential	µ	3869-1
µ	be	attribute	a method	3869-1
a method		sequential	schema	3869-1
An instance	of	constraint	S	3869-2
S	is	attribute	a pair	3869-2
a pair		sequential	I	3869-2
I	=	sequential	π	3869-2
π		sequential	ν	3869-2
ν		sequential	π	3869-2
π	is	attribute	where an OID assignment	3869-2
where an OID assignment	for	constraint	C	3869-2
C	and	conjunctive	ν	3869-2
ν	where assigns	action	a semantics	3869-2
a semantics	to	constraint	the base methods	3869-2
<B>	Note	action	the difference	3869-3
the difference	from	constraint	the imperative schemas	3869-3
the imperative schemas	of	constraint	the previous section	3869-3
the previous section		sequential	π together	3869-3
π together	with	constraint	the method implementations	3869-3
the method implementations	to	constraint	the semantics	3869-3
the method implementations	was	attribute	where sufficient	3869-3
the method implementations	determine	action	the semantics	3869-3
the semantics	of	constraint	methods	3869-3
<B>	In	constraint	contrast	3869-4
contrast		sequential	the semantics	3869-4
the semantics	of	constraint	the base methods	3869-4
the base methods	in	constraint	instances	3869-4
the base methods	must be specified	action	instances	3869-4
instances	of	constraint	method schemas	3869-4
Inheritance	of	constraint	method implementations	3870-1
method implementations	for	constraint	method schemas	3870-1
method schemas	from	constraint	the OODB model	3870-1
method schemas	for	constraint	the OODB model	3870-1
method schemas	is defined slightly differently	attribute	that	3870-1
the OODB model	given earlier	action	<B>	3870-1
<B>	given	action	an n-ary method	3870-2
an n-ary method		sequential	m	3870-2
m	and	conjunctive	invocation m	3870-2
invocation m		sequential	o1	3870-2
<B>	.	sequential	<B>	3870-3
<B>	.	sequential	<B>	3870-4
<B>		sequential	oi	3870-5
oi	in	constraint	disjoint class	3870-5
oi	is	attribute	disjoint class	3870-5
disjoint class		sequential	where ci	3870-5
where ci	for	constraint	i ∈	3870-5
i ∈		sequential	1	3870-5
1		sequential	n	3870-5
n		sequential	the implementation	3870-5
the implementation	for	constraint	m	3870-5
m	from	constraint	the implementation	3870-5
m	is inherited	action	the implementation	3870-5
the implementation	of	constraint	signature m c′	3870-5
<B>	.	sequential	<B>	3870-6
<B>	.	sequential	<B>	3870-7
c′ c′	→	sequential	this 1 n	3870-8
this 1 n	is	attribute	where the unique signature	3870-8
where the unique signature		sequential	that	3870-8
that	above	constraint	c1	3870-8
that	is	attribute	pointwise	3870-8
<B>	.	sequential	<B>	3870-9
<B>	.	sequential	<B>	3870-10
cn		sequential	cn	3870-11
m	on	constraint	input	3870-12
m	is	attribute	Otherwise undefined	3870-12
input		sequential	o1	3870-12
<B>	.	sequential	<B>	3870-13
<B>	.	sequential	<B>	3870-14
<B>		sequential	<B>	3870-15
Example		sequential	21.4.4	3871-1
The classes	in	constraint	the schema	3871-2
the schema	are	attribute	class c class	3871-2
class c class		sequential	c′	3871-2
c′	c	sequential	<B>	3871-2
Type Safety	for	constraint	Method Schemas	3872-1
The following example	that	constraint	the schema	3873-1
The following example	demonstrates	action	the schema	3873-1
the schema	of	constraint	Example 21.4.4	3873-1
Example 21.4.4	is	attribute	type	3873-1
type		sequential	<B>	3873-1
<B>	Note	action	the interpretation	3873-2
the interpretation		sequential	ν	3873-2
ν	for	constraint	base methods	3873-2
base methods	as	constraint	an assignment	3873-2
base methods	how can be viewed	action	an assignment	3873-2
an assignment	of	constraint	values	3873-2
values	for	constraint	objects	3873-2
Example		sequential	21.4.5	3874-1
21.4.5	Recall	action	the method	3874-1
the method		sequential	schema	3874-1
schema	of	constraint	Example 21.4.4	3874-1
An instance	of	constraint	I	3874-2
An instance	is	attribute	I	3874-2
I	=	sequential	π	3874-2
π		sequential	ν	3874-2
ν		sequential	7	3874-2
Object Databases		sequential	Object Databases	3875-1
<B>	Consider	action	the execution	3876-1
the execution	of	constraint	m	3876-1
m		sequential	p	3876-1
<B>	for	constraint	the computation	3876-2
<B>	calls	action	the computation	3876-2
the computation	of	constraint	m2	3876-2
m2		sequential	m2	3876-2
m2		sequential	m1	3876-2
m1		sequential	p	3876-2
p	=	sequential	m2	3876-2
m2		sequential	m2	3876-2
m2		sequential	r	3876-2
r	=	sequential	r	3876-2
<B>	On	constraint	the other hand	3876-3
the other hand		sequential	m′	3876-3
m′		sequential	p	3876-3
p	to	constraint	a runtime type error	3876-3
p	leads	action	a runtime type error	3876-3
a runtime type error		sequential	m′	3876-3
m′		sequential	p	3876-3
p	=	sequential	m3	3876-3
m3		sequential	m′	3876-3
m′		sequential	m2	3876-3
m2		sequential	p	3876-3
p	=	sequential	m3	3876-3
m3		sequential	m′	3876-3
m′		sequential	q	3876-3
q	=	sequential	m3	3876-3
m3		sequential	m3	3876-3
m3		sequential	m′	3876-3
m′		sequential	q	3876-3
q	=	sequential	m3	3876-3
m3		sequential	m3	3876-3
m3		sequential	m′	3876-3
m′		sequential	r	3876-3
r	=	sequential	m3	3876-3
m3		sequential	m3	3876-3
m3		sequential	m1	3876-3
m1		sequential	r	3876-3
r	=	sequential	m3	3876-3
m3		sequential	m3	3876-3
m3		sequential	r	3876-3
r	=	sequential	m3	3876-3
m3		sequential	p	3876-3
p		sequential	which	3876-3
which	and	conjunctive	a runtime type error	3876-3
which	is	attribute	undefined	3876-3
which	raises	action	a runtime type error	3876-3
the schema	is	attribute	type	3876-4
type		sequential	<B>	3876-4
It	that	constraint	type safety	3877-1
It	turns out	action	type safety	3877-1
type safety	of	constraint	method schemas	3877-1
method schemas	permitting	action	polyadic methods	3877-1
polyadic methods	is	attribute	undecidable	3877-1
Exercise		sequential	21.19	3877-1
type safety	for	constraint	monadic method schemas	3877-2
type safety	is	attribute	Interestingly decidable	3877-2
We	now sketch	action	the proof	3877-3
the proof	of	constraint	this result	3877-3
Theorem		sequential	21.4.6	3878-1
Crux		sequential	Let S	3879-1
Let S	=	sequential	C	3879-1
C		sequential	≺	3879-1
≺		sequential	M base	3879-1
M base		sequential	M comp	3879-1
M comp		sequential	µ	3879-1
µ	be	attribute	a monadic method schema	3879-1
We	construct	attribute	context free	3879-2
a grammar	see	action	Chapter 2	3879-2
Chapter 2		sequential	that	3879-2
that	captures	action	possible executions	3879-2
possible executions	of	constraint	a method call	3879-2
a method call	over	constraint	all instances	3879-2
all instances	of	constraint	S	3879-2
c2	and	conjunctive	c′ c2	3880-1
c2	≺	sequential	c′ c2	3880-1
<B>	that	constraint	c′	3880-2
<B>	Note	action	c′	3880-2
c′	=	sequential	c2	3880-2
c2	is	attribute	just a particular case	3880-2
<B>	Given	action	a successful execution	3881-1
a successful execution	of	constraint	a method	3881-1
a method		sequential	call m	3881-1
call m		sequential	o	3881-1
o		sequential	it	3881-1
it	to	constraint	a word	3881-1
it	is	attribute	easy	3881-1
it	construct	action	a word	3881-1
a word	in	constraint	L	3881-1
L		sequential	GS	3881-1
GS	of	constraint	the form m1	3881-1
<B>	.	sequential	<B>	3881-2
<B>	.	sequential	<B>	3881-3
mn		sequential	the mi	3881-4
the mi		sequential	list	3881-4
list		sequential	the sequence	3881-4
the sequence	of	constraint	base methods	3881-4
base methods	during	constraint	the execution	3881-4
base methods	where called	action	the execution	3881-4
<B>	On	constraint	the other hand	3881-5
the other hand	if	constraint	the execution	3881-5
the execution	of	constraint	m	3881-5
m		sequential	o	3881-5
o	to	constraint	a runtime error	3881-5
o	leads	action	a runtime error	3881-5
a runtime error		sequential	a word	3881-5
a word	of	constraint	the form m1	3881-5
<B>	.	sequential	<B>	3881-6
<B>	.	sequential	<B>	3881-7
mi error		sequential	mi error	3881-8
<B>	.	sequential	<B>	3881-9
<B>	.	sequential	<B>	3881-10
<B>	can be formed	action	<B>	3881-11
The terminal	in	constraint	cases where	3881-12
The terminal	ignore	action	cases where	3881-12
The terminal	can be used	action	cases where	3881-12
It	that	constraint	S	3882-1
It	can be shown	action	S	3882-1
S	is	attribute	type safe iff	3882-1
type safe iff		sequential	L	3882-1
L		sequential	GS	3882-1
GS		sequential	∩	3882-1
∩		sequential	N	3882-1
N	∗	sequential	error V	3882-1
error V		sequential	∗	3882-1
∗	=	sequential	<B>	3882-1
∗	∅	sequential	<B>	3882-1
base t	Because	constraint	it	3883-1
it	if	constraint	the intersection	3883-1
it	can be tested	action	the intersection	3883-1
the intersection	of	constraint	a language	3883-1
a language	with	constraint	a regular language	3883-1
a regular language	is	attribute	empty	3883-1
the preceding	provides	action	an algorithm	3883-1
an algorithm	for	constraint	type safety	3883-1
an algorithm	checking	action	type safety	3883-1
a modification	of	constraint	the grammar GS	3883-2
the grammar GS	to	constraint	the polynomial time test	3883-2
the grammar GS	However is needed	action	the polynomial time test	3883-2
the grammar GS	obtain	action	the polynomial time test	3883-2
the polynomial time test	see	action	Exercise 21.18	3883-2
Expressive Power	of	constraint	Method Schemas	3884-1
object	oriented	action	The features	3884-2
The features	are	attribute	not central here	3884-2
we	Next represent	action	queries	3885-1
queries	by	constraint	composite methods	3885-1
A query q	by	constraint	method	3885-2
A query q	is computed	action	method	3885-2
method		sequential	mq	3885-2
mq	if	constraint	t	3885-2
t	in	constraint	not zero	3885-2
t	is	attribute	true	3885-2
not zero		sequential	iff t	3885-2
iff t	in	constraint	the answer	3885-2
iff t	is	attribute	the answer	3885-2
the answer	to	constraint	query q	3885-2
<B>	to	constraint	this simple language	3886-1
<B>	with	constraint	this simple language	3886-1
<B>	illustrates	action	this simple language	3886-1
<B>	compute	action	this simple language	3886-1
Example		sequential	21.4.7	3887-1
The class zero	with	constraint	the object 0	3887-2
The class zero	is populated	action	the object 0	3887-2
the object 0	and	conjunctive	the class elem	3887-2
the class elem	with	constraint	1	3887-2
1		sequential	2	3887-2
The base method		sequential	pred	3887-3
pred	by	constraint	pred	3887-3
pred	is defined	action	pred	3887-3
pred		sequential	2	3887-3
2	=	sequential	1	3887-3
1		sequential	pred	3887-3
pred		sequential	0	3887-3
0	=	sequential	pred	3887-3
pred		sequential	1	3887-3
1	=	sequential	0	3887-3
The base method mR	by	constraint	mR	3887-4
The base method mR	is defined	action	mR	3887-4
mR		sequential	1	3887-4
1		sequential	1	3887-4
1	=	sequential	mR	3887-4
mR		sequential	1	3887-4
1		sequential	2	3887-4
2	=	sequential	1	3887-4
1	and	conjunctive	mR	3887-4
mR		sequential	x	3887-4
x		sequential	y	3887-4
y	= otherwise	sequential	0	3887-4
Object Databases		sequential	Object Databases	3888-1
We	can code	action	the Boolean function	3888-2
the Boolean function	as	constraint	x	3888-2
the Boolean function	for	constraint	x	3888-2
the Boolean function	and	conjunctive	x	3888-2
the Boolean function	follows	action	x	3888-2
x		sequential	y	3888-2
y	in	constraint	x	3888-2
y	for	constraint	x	3888-2
x		sequential	y	3888-2
y	in	constraint	zero	3888-2
zero	for	constraint	x	3888-2
x		sequential	y	3888-2
y	in	constraint	x	3888-2
y	for	constraint	x	3888-2
x		sequential	y	3888-2
y	in	constraint	elem	3888-2
elem		sequential	elem	3888-2
The other standard Boolean functions	can be coded similarly	action	<B>	3889-1
We	can code	action	the intersection	3889-2
the intersection	between	constraint	two binary relations	3889-2
two binary relations		sequential	R	3889-2
R	and	conjunctive	S	3889-2
S	with	constraint	mR	3889-2
S	and	conjunctive	mR	3889-2
mR		sequential	x	3889-2
x		sequential	y	3889-2
y		sequential	mS	3889-2
mS		sequential	x	3889-2
x		sequential	y	3889-2
<B>	As	constraint	a last example	3889-3
a last example		sequential	the projection	3889-3
the projection	of	constraint	a binary relation R	3889-3
a binary relation R	over	constraint	the first coordinate	3889-3
the first coordinate	by	constraint	a method	3889-3
the first coordinate	can be coded	action	a method	3889-3
a method		sequential	πR,	3889-3
πR,		sequential	1	3889-3
1	by	constraint	m	3889-3
1	defined	action	m	3889-3
m	by	constraint	x	3889-3
m	for	constraint	x	3889-3
m	is given	action	x	3889-3
x		sequential	y	3889-3
y	in	constraint	elem	3889-3
elem		sequential	zero m	3889-3
zero m		sequential	x	3889-3
x		sequential	y	3889-3
y		sequential	mR	3889-3
mR		sequential	x	3889-3
x		sequential	y	3889-3
y	for	constraint	x	3889-3
x		sequential	y	3889-3
y	in	constraint	elem	3889-3
elem		sequential	elem m	3889-3
elem m		sequential	x	3889-3
x		sequential	y	3889-3
y		sequential	≡	3889-3
≡	or	conjunctive	mR	3889-3
mR		sequential	x	3889-3
x		sequential	y	3889-3
y		sequential	m	3889-3
m		sequential	x	3889-3
x		sequential	pred	3889-3
pred		sequential	y	3889-3
We	now state	action	the following Theorem 21.4.8	3890-1
Crux lexicographical ordering	of	constraint	u	3891-1
we	Indeed can simulate	action	an arbitrary relational operation	3891-2
an arbitrary relational operation	and	conjunctive	more generally an arbitrary inflationary fixpoint	3891-2
<B>	To	constraint	the transitive closure query	3891-3
<B>	see	attribute	this	3891-3
<B>	consider	action	the transitive closure query	3891-3
It	with	constraint	a method	3891-4
It	is computed	action	a method	3891-4
a method		sequential	tc	3891-4
tc	as	constraint	<B>	3891-4
tc	defined	action	<B>	3891-4
tc	follows	action	<B>	3891-4
<B>		sequential	a method	3891-5
a method		sequential	tc	3891-5
tc		sequential	x	3891-5
x		sequential	y	3891-5
y	asks	action	x y	3891-5
y	Is	action	x y	3891-5
x y	in	constraint	the transitive closure	3891-5
the transitive closure		sequential	Execution	3891-5
Execution	of	constraint	tc	3891-5
tc		sequential	x	3891-5
x		sequential	y	3891-5
y	first calls	action	a method	3891-5
a method		sequential	m1	3891-5
m1		sequential	x	3891-5
x		sequential	y	3891-5
y		sequential	N	3891-5
N		sequential	whose intuitive meaning	3891-5
whose intuitive meaning	is	attribute	there	3891-5
whose intuitive meaning	Is	action	there	3891-5
there		sequential	a path	3891-5
a path	of	constraint	length N	3891-5
length N	from	constraint	x	3891-5
x	to	constraint	y	3891-5
y	by	constraint	there	3891-5
y	whether	constraint	there	3891-5
y	will be computed	action	there	3891-5
y	asking	action	there	3891-5
there	is	attribute	a path	3891-5
a path	of	constraint	length	3891-5
length	N − 1	sequential	a recursive call	3891-5
a recursive call	to	constraint	m1	3891-5
m1		sequential	<B>	3891-5
<B>	to	constraint	a construction	3891-6
<B>	can be generalized	action	a construction	3891-6
a construction		sequential	that	3891-6
that	simulates	action	an arbitrary inflationary fixpoint query	3891-6
<B>	Because	constraint	the underlying domain	3891-7
the underlying domain	is ordered	action	we	3891-7
we	have captured	action	all qptime queries	3891-7
The converse	from	constraint	the fact	3891-8
The converse	follows	action	the fact	3891-8
the fact	that	constraint	there	3891-8
there	are	attribute	only polynomially many possible method calls	3891-8
only polynomially many possible method calls	in	constraint	the context	3891-8
the context	of	constraint	a given instance	3891-8
a given instance	and	conjunctive	each method	3891-8
each method	in	constraint	this model	3891-8
each method	call	action	this model	3891-8
this model	in	constraint	qptime	3891-8
this model	can be answered	action	qptime	3891-8
loops	in	constraint	method calls	3891-9
method calls	in	constraint	polynomial time	3891-9
method calls	Moreover can be detected	action	polynomial time	3891-9
polynomial time		sequential	calls	3891-9
calls	giving	action	rise	3891-9
rise	to	constraint	loops	3891-9
loops	to	constraint	some designated special value	3891-9
loops	are assumed	action	some designated special value	3891-9
loops	output	action	some designated special value	3891-9
<B>	See	action	Exercise 21.25	3891-10
We	have presented	action	an approach	3892-1
We	object oriented	action	an approach	3892-1
an approach	in	constraint	the applicative programming style	3892-1
There	exists	action	another important family	3893-1
another important family	of	constraint	functional languages	3893-1
functional languages	on	constraint	typed λ calculi	3893-1
functional languages	based	action	typed λ calculi	3893-1
It	to	constraint	database languages	3894-1
It	is	attribute	possible	3894-1
It	consider as well	action	database languages	3894-1
database languages	in	constraint	this family	3894-1
These calculi present		sequential	These calculi present	3894-2
Further Issues	for	constraint	OODBs	3895-1
<B>	is	attribute	not an exhaustive list	3896-1
not an exhaustive list	of	constraint	new features	3896-1
new features	but	conjunctive	a sample	3896-1
a sample	of	constraint	that	3896-1
that	are being studied	action	Views	3896-1
<B>	unlike	constraint	relational views	3896-2
relational views		sequential	OODB views	3896-2
OODB views	However might redefine	action	the behavior	3896-2
the behavior	of	constraint	objects	3896-2
objects	in	constraint	addition	3896-2
addition	to	constraint	their associated types	3896-2
addition	restructuring	action	their associated types	3896-2
There	are also	action	significant issues	3896-3
significant issues	by	constraint	the presence	3896-3
significant issues	raised	action	the presence	3896-3
the presence	of	constraint	OIDs	3896-3
<B>	For	constraint	example	3896-4
example	to	constraint	incrementally a materialized view	3896-4
example	maintain	action	incrementally a materialized view	3896-4
incrementally a materialized view	with	constraint	created OIDs	3896-4
created OIDs		sequential	the linkage	3896-4
the linkage	between	constraint	the base data	3896-4
the base data	and	conjunctive	the created OIDs	3896-4
the created OIDs	must be maintained	action	<B>	3896-4
<B>	if	constraint	the view	3897-1
the view	is	attribute	virtual	3897-1
virtual OIDs	and	conjunctive	<B>	3897-1
virtual OIDs	Furthermore how should be specified	action	<B>	3897-1
virtual OIDs	manipulated	action	<B>	3897-1
Object roles		sequential	Object roles	3898-1
<B>	For	constraint	instance	3898-2
instance		sequential	a director	3898-2
a director	be	attribute	may also an actor	3898-2
It	if	constraint	all cases	3898-3
It	to	constraint	all cases	3898-3
It	is	attribute	costly	3898-3
It	forecast	action	all cases	3898-3
all cases	in	constraint	which	3898-3
which	may happen	action	<B>	3898-3
<B>	Although	constraint	object	3898-4
<B>	in	constraint	object	3898-4
object	oriented	action	programming	3898-4
programming	in	constraint	OODBs	3898-4
OODBs		sequential	it	3898-4
it	to	constraint	the same object	3898-4
it	be	attribute	would useful	3898-4
it	permit	action	the same object	3898-4
the same object	to	constraint	several classes	3898-4
the same object	in	constraint	several classes	3898-4
the same object	live	action	several classes	3898-4
several classes		sequential	a departure	3898-4
a departure	from	constraint	the disjoint OID assignment	3898-4
the disjoint OID assignment	from	constraint	which	3898-4
which		sequential	we	3898-4
we	and	conjunctive	distinct repositories	3898-4
we	started	action	distinct repositories	3898-4
we	at least conceptually maintain	action	distinct repositories	3898-4
distinct repositories		sequential	one	3898-4
one	for	constraint	each role	3898-4
This feature	in	constraint	some semantic data models	3898-5
This feature	is	attribute	present	3898-5
some semantic data models	in	constraint	object	3898-5
object	oriented	action	the context	3898-5
the context		sequential	it	3898-5
it	raises	action	a number	3898-5
a number	of	constraint	interesting typing issues	3898-5
Schema design		sequential	Schema design techniques	3899-1
Schema design techniques	on	constraint	dependencies	3899-1
Schema design techniques	based	action	dependencies	3899-1
dependencies	and	conjunctive	normal forms	3899-1
normal forms	for	constraint	the relational model	3899-1
normal forms	have emerged	action	the relational model	3899-1
the relational model	see	action	Chapter 11	3899-1
<B>	Although	constraint	the richer model	3899-2
the richer model	in	constraint	the OODB	3899-2
the OODB	provides	action	greater flexibility	3899-2
greater flexibility	in	constraint	a schema	3899-2
greater flexibility	selecting	action	a schema	3899-2
a schema		sequential	there	3899-2
there	is	attribute	a concomitant need	3899-2
a concomitant need	for	constraint	richer tools	3899-2
richer tools	to	constraint	schema design	3899-2
richer tools	facilitate	action	schema design	3899-2
The scope	of	constraint	schema design	3899-3
schema design	in	constraint	the OODB context	3899-3
schema design	is en-larged	action	the OODB context	3899-3
the OODB context	because of	constraint	the interaction	3899-3
the interaction	of	constraint	methods	3899-3
methods	within	constraint	schema	3899-3
schema	and	conjunctive	application	3899-3
application		sequential	a software	3899-3
a software	for	constraint	the schema	3899-3
<B>	Querying	action	the schema	3900-1
<B>	for	constraint	example	3901-1
<B>	Suppose	action	example	3901-1
example	that	constraint	movies	3901-1
movies	were assigned	action	categories	3901-1
categories		sequential	drama west	3901-1
drama west		sequential	ern	3901-1
ern		sequential	suspense	3901-1
suspense		sequential	<B>	3901-1
<B>	In	constraint	the relational model	3901-2
the relational model		sequential	this information	3901-2
this information	would typically be represented	action	a new column	3901-2
this information	using	action	a new column	3901-2
a new column	in	constraint	the Movies relation	3901-2
A query		sequential	list	3901-3
list		sequential	all categories	3901-3
all categories	of	constraint	movie	3901-3
movie		sequential	that	3901-3
that		sequential	Bergman	3901-3
Bergman	directed	action	<B>	3901-3
Bergman	is easily answered	action	<B>	3901-3
<B>	In	constraint	an OODB	3901-4
an OODB		sequential	the category information	3901-4
the category information	might be represented	action	different subclasses	3901-4
the category information	using	action	different subclasses	3901-4
different subclasses	of	constraint	the Movie class	3901-4
<B>	Answering	action	this query	3901-5
this query	now requires	action	the ability	3901-5
the ability	of	constraint	the query language	3901-5
the query language	to	constraint	class names	3901-5
the query language	return	action	class names	3901-5
class names		sequential	a feature	3901-5
a feature	in	constraint	most current systems	3901-5
Object Databases Classification		sequential	A related problem	3902-1
A related problem	concerns	action	an OODB schema	3902-1
A related problem	given	action	an OODB schema	3902-1
an OODB schema	to	constraint	new data	3902-1
an OODB schema	classify	action	new data	3902-1
new data	for	constraint	this schema	3902-1
<B>	may arise	action	a view	3902-2
<B>	when constructing	action	a view	3902-2
a view	when merging	action	two databases	3902-2
two databases	or	conjunctive	a relational database	3902-2
two databases	when transforming	action	a relational database	3902-2
a relational database	into	constraint	an OODB one	3902-2
an OODB one	by	constraint	tuples	3902-2
an OODB one	objectifying	action	tuples	3902-2
The issue	of	constraint	classification	3902-3
classification	also called	action	taxonomic reasoning	3902-3
taxonomic reasoning	has	action	a long history	3902-3
a long history	in	constraint	the field	3902-3
the field	of	constraint	knowledge representation	3902-3
knowledge representation	in	constraint	artificial intelligence	3902-3
artificial intelligence	and	conjunctive	some research	3902-3
some research	in	constraint	this direction	3902-3
this direction	for	constraint	object	3902-3
this direction	and	conjunctive	object	3902-3
this direction	has been performed	attribute	semantic	3902-3
object	oriented	action	databases	3902-3
<B>	Incorporating	action	deductive capabilities	3903-1
<B>	For	constraint	the past several years	3904-1
the past several years		sequential	researchers	3904-1
researchers	have been developing	action	hybrids	3904-1
hybrids	of	constraint	logic programming	3904-1
logic programming	and	conjunctive	the paradigms	3904-1
logic programming	object oriented	action	the paradigms	3904-1
<B>	Although	constraint	it	3904-2
it	in	constraint	some ways	3904-2
it	is	attribute	very different	3904-2
some ways	because	constraint	the OO paradigm	3904-2
the OO paradigm	has	action	fundamentally imperative aspects	3904-2
fundamentally imperative aspects		sequential	the perspective	3904-2
the perspective	of	constraint	logic programming	3904-2
logic programming	provides	action	alternative approaches	3904-2
alternative approaches	to	constraint	data access	3904-2
data access	and	conjunctive	object creation	3904-2
Dynamic Issues		sequential	Dynamic Issues	3905-1
<B>	In	constraint	an OODB	3905-2
an OODB		sequential	the issue	3905-2
the issue	is	attribute	somewhat trickier	3905-2
<B>	For	constraint	instance	3906-1
instance		sequential	we	3906-1
we	can allow	action	the deletion	3906-1
the deletion	of	constraint	an object	3906-1
an object	if	constraint	this object	3906-1
this object	to	constraint	the database	3906-1
this object	in	constraint	the database	3906-1
this object	is referred	action	the database	3906-1
the database		sequential	the dangling reference problem	3906-1
<B>	in	constraint	some systems	3906-2
<B>	is prohibited	action	some systems	3906-2
some systems	whereas	constraint	other systems	3906-2
other systems	will accept	action	the deletion	3906-2
the deletion	and	conjunctive	the object	3906-2
the deletion	just mark	action	the object	3906-2
the object	as	constraint	<B>	3906-2
<B>	in	constraint	all references	3906-3
<B>	Semantically results	action	all references	3906-3
<B>	viewing	action	all references	3906-3
all references	to	constraint	this object	3906-3
this object	as	constraint	nil	3906-3
<B>	For	constraint	example	3907-1
example		sequential	we	3907-1
we	how do treat	action	a reference	3907-1
a reference	to	constraint	the manager	3907-1
the manager	of	constraint	a department	3907-1
a department	of	constraint	should type Employee	3907-1
a department	be	attribute	should type Employee	3907-1
should type Employee		sequential	he	3907-1
he	or	conjunctive	she	3907-1
she	when leaves	action	the company	3907-1
the company	into	constraint	a person	3907-1
the company	and	conjunctive	a person	3907-1
the company	is turned	attribute	normal	3907-1
<B>	as	constraint	the relational model	3908-1
<B>	with	constraint	the relational model	3908-1
the relational model		sequential	we	3908-1
we	to	constraint	evolution	3908-1
we	Finally need	action	evolution	3908-1
we	consider	action	evolution	3908-1
evolution	of	constraint	the schema itself	3908-1
The OODB context	than	constraint	there	3908-2
The OODB context	because	constraint	there	3908-2
The OODB context	is	attribute	much richer	3908-2
there	are	attribute	many more kinds	3908-2
many more kinds	of	constraint	changes	3908-2
changes	to	constraint	the class hierarchy	3908-2
changes	consider	action	the class hierarchy	3908-2
the class hierarchy		sequential	the type	3908-2
the type	of	constraint	a class	3908-2
a class		sequential	additions	3908-2
additions	or	conjunctive	deletions	3908-2
deletions	of	constraint	methods	3908-2
methods		sequential	<B>	3908-2
Bibliographic Notes		sequential	Bibliographic Notes Collections	3909-1
Bibliographic Notes Collections	of	constraint	papers	3909-1
papers	on	constraint	object	3909-1
object	oriented	action	databases	3909-1
databases	in	constraint	BDK92	3909-1
databases	can be found	action	BDK92	3909-1
BDK92		sequential	KL89	3909-1
KL89		sequential	ZM90	3909-1
The main characteristics	of	constraint	object	3910-1
object	oriented	action	database systems	3910-1
database systems	in	constraint	ABD+89	3910-1
database systems	are described	action	ABD+89	3910-1
Object	oriented	action	databases	3911-1
databases	to	constraint	object	3911-1
databases	are	attribute	of course closely related	3911-1
object	oriented	action	programming languages	3911-1
<B>	of	constraint	Smalltalk	3911-2
<B>	is	attribute	Smalltalk	3911-2
Smalltalk		sequential	GR83	3911-2
GR83	and	conjunctive	C++	3911-2
C++		sequential	Str91	3911-2
Str91	is	attribute	fast	3911-2
Str91	becoming	action	object	3911-2
object	oriented	action	the most widely used programming language	3911-2
Several commercial OODBs	are	attribute	essentially persistent versions	3911-3
essentially persistent versions	of	constraint	C++	3911-3
object	oriented	action	Several extensions	3911-4
Several extensions	of	constraint	Lisp	3911-4
Lisp	have been proposed	action	the article	3911-4
the article		sequential	B+86	3911-4
B+86	introduces	action	a rich extension	3911-4
a rich extension	called	action	CommonLoops	3911-4
CommonLoops	and	conjunctive	several others	3911-4
CommonLoops	surveys	action	several others	3911-4
There	have been	action	a number	3912-1
a number	of	constraint	approaches	3912-1
approaches	to	constraint	a formal foundation	3912-1
approaches	provide	action	a formal foundation	3912-1
a formal foundation		sequential	AK89	3912-1
AK89		sequential	Bee90	3912-1
Bee90		sequential	HTY89	3912-1
HTY89		sequential	KLW93	3912-1
KLW93	for	constraint	OODBs	3912-1
We	as	constraint	precursors	3912-2
We	can also cite	action	precursors	3912-2
precursors	to	constraint	semantic data models	3912-2
precursors	attempts	action	semantic data models	3912-2
precursors	formalize	action	semantic data models	3912-2
semantic data models		sequential	AH87	3912-2
AH87	and	conjunctive	object	3912-2
object	based	action	models	3912-2
models		sequential	KV84	3912-2
KV84		sequential	HY84	3912-2
graph	oriented	action	Recent models	3912-3
Recent models	although	constraint	they	3912-3
they	do not stress	action	object orientation	3912-3
object orientation	in	constraint	spirit	3912-3
object orientation	are	attribute	similar	3912-3
spirit		sequential	<B>	3912-3
The generic OODB model	from	constraint	the IQL model	3913-1
The generic OODB model	used here	action	the IQL model	3913-1
The generic OODB model	is directly inspired	action	the IQL model	3913-1
the IQL model		sequential	AK89	3913-1
OIDs	been	action	have part	3914-1
have part	of	constraint	many data models	3914-1
<B>	For	constraint	example	3914-2
example		sequential	they	3914-2
they	are called	action	surrogates	3914-2
surrogates	in	constraint	<B>	3914-2
<B>	Since	constraint	KV84	3915-1
KV84		sequential	various languages	3915-1
various languages	for	constraint	models	3915-1
models	with	constraint	objects	3915-1
objects	in	constraint	the various paradigms	3915-1
objects	have been proposed	action	the various paradigms	3915-1
the various paradigms		sequential	calculus	3915-1
calculus		sequential	algebra	3915-1
algebra		sequential	rule	3915-1
rule	or	conjunctive	<B>	3915-1
rule	based	attribute	functional	3915-1
<B>	Besides	constraint	standard features	3915-2
standard features	in	constraint	database languages	3915-2
standard features	found	action	database languages	3915-2
database languages	without	constraint	objects	3915-2
objects		sequential	the new primitives	3915-2
the new primitives	around	constraint	object creation	3915-2
the new primitives	are centered	action	object creation	3915-2
Language		sequential	issues	3915-3
issues	to	constraint	object creation	3915-3
object creation	in	constraint	the context	3915-3
object creation	were first considered	action	the context	3915-3
the context	of	constraint	IQL	3915-3
IQL		sequential	AK89	3915-3
Object creation	is	attribute	an essential component	3915-4
an essential component	of	constraint	IQL	3915-4
IQL	and	conjunctive	the main reason	3915-4
IQL	is	attribute	the main reason	3915-4
the main reason	for	constraint	the completeness	3915-4
the completeness	of	constraint	the language	3915-4
The need	for	constraint	the style	3915-5
The need	in	constraint	the style	3915-5
the style	of	constraint	copy elimination	3915-5
copy elimination	to	constraint	determinate completeness	3915-5
copy elimination	obtain	action	determinate completeness	3915-5
determinate completeness	in	constraint	AK89	3915-5
determinate completeness	was first noticed	action	AK89	3915-5
The IQL language	is	attribute	rule	3915-6
rule	with	constraint	an inflationary fixpoint semantics	3915-6
rule	based	action	an inflationary fixpoint semantics	3915-6
an inflationary fixpoint semantics	in	constraint	the style	3915-6
the style	of	constraint	datalog¬	3915-6
datalog¬	of	constraint	Chapter 14	3915-6
logic	based	action	The perspective	3916-1
The perspective	on	constraint	object creation	3916-1
object creation	on	constraint	Skolem	3916-1
object creation	based	action	Skolem	3916-1
Skolem	in	constraint	Mai86	3916-1
Skolem	was first informally discussed	action	Mai86	3916-1
Mai86	in	constraint	CW89a	3916-1
Mai86	and	conjunctive	CW89a	3916-1
Mai86	refined variously	action	CW89a	3916-1
CW89a		sequential	HY90	3916-1
HY90		sequential	KLW93	3916-1
KLW93		sequential	KW89	3916-1
<B>	In	constraint	F	3916-2
F		sequential	logic	3916-2
logic		sequential	KLW93	3916-2
KLW93	considers	action	a different approach	3916-2
a different approach	to	constraint	inheritance	3916-2
<B>	In	constraint	our framework	3916-3
our framework		sequential	the classification	3916-3
the classification	of	constraint	objects	3916-3
objects	in	constraint	an object	3916-3
objects	is	attribute	explicit	3916-3
an object	when is created	action	it	3916-3
it	within	constraint	an explicit class	3916-3
it	is	attribute	an explicit class	3916-3
<B>	In	constraint	KLW93	3916-4
KLW93		sequential	data organization	3916-4
data organization	by	constraint	rules	3916-4
data organization	is also specified	action	rules	3916-4
rules	on	constraint	the properties	3916-4
rules	and	conjunctive	the properties	3916-4
rules	thus may depend	action	the properties	3916-4
the properties	of	constraint	the objects	3916-4
the objects	involved	action	<B>	3916-4
<B>	For	constraint	instance	3916-5
instance		sequential	reasoning	3916-5
reasoning	about	constraint	the hierarchy	3916-5
the hierarchy	becomes	action	part	3916-5
part	of	constraint	the program	3916-5
Object Databases	Since	constraint	object creation	3917-1
object creation	been	action	has the center	3917-1
has the center	of	constraint	much interesting research	3917-1
much interesting research		sequential	DV93	3917-1
DV93		sequential	HS89	3917-1
HS89		sequential	b	3917-1
b		sequential	HY92	3917-1
HY92		sequential	VandBG92	3917-1
VandBG92		sequential	VandBGAG92	3917-1
VandBGAG92		sequential	VandB93	3917-1
The characterization	of	constraint	queries	3917-2
queries	in	constraint	whileobj	3917-2
queries	expressible	action	whileobj	3917-2
whileobj		sequential	Theorem	3917-2
Theorem		sequential	21.3.2	3917-2
21.3.2	from	constraint	VandBG92	3917-2
21.3.2	is	attribute	VandBG92	3917-2
VandBG92	extends	action	a previous result	3917-2
a previous result	from	constraint	AP92	3917-2
The proof	of	constraint	Proposition 21.3.3	3917-3
Proposition 21.3.3	from	constraint	also VandBGAG92	3917-3
Proposition 21.3.3	is	attribute	also VandBGAG92	3917-3
<B>	In	constraint	VandBGAG92	3917-4
VandBGAG92		sequential	VandB93	3917-4
VandB93		sequential	it	3917-4
it	that	constraint	the notion	3917-4
it	is argued	action	the notion	3917-4
the notion	of	constraint	determinate query	3917-4
determinate query	be	attribute	may not the most appropriate one	3917-4
may not the most appropriate one	for	constraint	object	3917-4
object	based	action	the context	3917-4
the context	and	conjunctive	alternative notions	3917-4
alternative notions		sequential	semide	3917-4
semide		sequential	queries	3917-4
queries	are discussed	action	<B>	3917-4
A tractable construct	yielding	action	determinate	3917-5
determinate		sequential	a language	3917-5
a language	in	constraint	DV93	3917-5
a language	is exhibited	action	DV93	3917-5
<B>		sequential	the construct	3917-6
the construct	proposed	action	there	3917-6
there	in	constraint	nature	3917-6
there	is	attribute	global	3917-6
nature	and	conjunctive	<B>	3917-6
nature	is	attribute	involved	3917-6
The search	for	constraint	local constructs	3917-7
The search	and	conjunctive	local constructs	3917-7
local constructs	continues	action	<B>	3917-7
<B>	In	constraint	Section 21.3	3918-1
<B>	as	constraint	Section 21.3	3918-1
<B>	in	constraint	Section 21.3	3918-1
<B>	indicated	action	Section 21.3	3918-1
Section 21.3		sequential	O2SQL	3918-1
O2SQL		sequential	BCD89	3918-1
BCD89	retains	action	the flavor	3918-1
the flavor	of	constraint	SQL	3918-1
SQL	but	conjunctive	object orientation	3918-1
SQL	incorporates	action	object orientation	3918-1
object orientation	by	constraint	an elegant functional programming style	3918-1
object orientation	adopting	action	an elegant functional programming style	3918-1
This approach	as	constraint	a standard	3918-2
This approach	has been advanced	action	a standard	3918-2
a standard	in	constraint	Cat94	3918-2
Functional approaches	to	constraint	databases	3919-1
databases	but	conjunctive	only modest interest	3919-1
databases	have been considered rather early	action	only modest interest	3919-1
databases	attracted	action	only modest interest	3919-1
only modest interest	in	constraint	the past	3919-1
the past		sequential	BFN82	3919-1
BFN82		sequential	Shi81	3919-1
The functional approach	because of	constraint	the success	3919-2
The functional approach	both	conjunctive	the success	3919-2
The functional approach	has become	attribute	more popular recently	3919-2
the success	of	constraint	object	3919-2
object	oriented	action	databases	3919-2
databases	due to	constraint	recent results	3919-2
databases	and	conjunctive	recent results	3919-2
recent results	of	constraint	complex objects	3919-2
complex objects	and	conjunctive	types	3919-2
types	emphasizing	action	the functional models	3919-2
the functional models		sequential	BTBN92	3919-2
BTBN92		sequential	BTBW92	3919-2
The use	of	constraint	a typed functional language	3919-3
a typed functional language	to	constraint	λ calculus	3919-3
λ calculus	as	constraint	a formalism	3919-3
a formalism	to	constraint	queries	3919-3
a formalism	express	action	queries	3919-3
queries	from	constraint	HKM93	3919-3
queries	is adapted	action	HKM93	3919-3
Characterizations	of	constraint	qptime	3919-4
qptime	in	constraint	functional terms	3919-4
functional terms	from	constraint	HKM93	3919-4
functional terms	are	attribute	HKM93	3919-4
HKM93		sequential	LM93	3919-4
The work	in	constraint	AKRW92	3919-5
AKRW92		sequential	HKM93	3919-5
HKM93		sequential	HKR93	3919-5
HKR93	provides	action	interesting bridges	3919-5
interesting bridges	between	constraint	databases	3919-5
interesting bridges	object oriented	action	databases	3919-5
databases	and	conjunctive	themes	3919-5
databases	well developed	action	themes	3919-5
themes	in	constraint	computer science	3919-5
computer science		sequential	applicative program schemas	3919-5
applicative program schemas		sequential	Cou90	3919-5
Cou90		sequential	Gre75	3919-5
Gre75	and	conjunctive	typed λ calculi	3919-5
typed λ calculi		sequential	Chu41	3919-5
Chu41		sequential	Bar84	3919-5
Bar84		sequential	Bar63	3919-5
This chapter	both	conjunctive	perspectives	3920-1
This chapter	and	conjunctive	perspectives	3920-1
This chapter	presented	attribute	imperative	3920-1
perspectives	on	constraint	OODB methods	3920-1
A different approach	on	constraint	rules	3920-2
A different approach	based	action	rules	3920-2
rules	and	conjunctive	datalog	3920-2
datalog	with	constraint	negation	3920-2
negation	in	constraint	<B>	3920-2
negation	has been used	action	<B>	3920-2
Views	for	constraint	OODBs	3921-1
OODBs	in	constraint	AB91	3921-1
OODBs	are considered	action	AB91	3921-1
AB91		sequential	Day89	3921-1
Day89		sequential	HY90	3921-1
HY90		sequential	KKS92	3921-1
KKS92		sequential	KLW93	3921-1
The merging	of	constraint	OODBs	3921-2
OODBs	in	constraint	WHW90	3921-2
OODBs	is considered	action	WHW90	3921-2
Incremental maintenance	of	constraint	object	3921-3
object	oriented	action	materialized views	3921-3
materialized views	in	constraint	Cha94	3921-3
materialized views	is considered	action	Cha94	3921-3
The notion	of	constraint	object roles	3921-4
object roles	or	conjunctive	objects	3921-4
object roles	sharing	action	objects	3921-4
objects	between	constraint	classes	3921-4
classes	in	constraint	some semantic data models	3921-4
classes	is found	action	some semantic data models	3921-4
some semantic data models		sequential	AH87	3921-4
AH87		sequential	HK87	3921-4
HK87	in	constraint	recent research	3921-4
HK87	and	conjunctive	recent research	3921-4
recent research	on	constraint	OODBs	3921-4
OODBs		sequential	ABGO93	3921-4
ABGO93		sequential	RS91	3921-4
A query language		sequential	that	3921-5
that	incorporates	action	access	3921-5
access	to	constraint	an OODB schema	3921-5
an OODB schema	in	constraint	KKS92	3921-5
an OODB schema	is presented	action	KKS92	3921-5
Classification	to	constraint	the field	3921-6
Classification	been	attribute	has central	3921-6
the field	of	constraint	knowledge representation	3921-6
knowledge representation	in	constraint	artificial intelligence	3921-6
artificial intelligence	on	constraint	the central notion	3921-6
artificial intelligence	based	action	the central notion	3921-6
the central notion	of	constraint	taxonomic reasoning	3921-6
taxonomic reasoning	see	action	BGL85	3921-6
BGL85		sequential	MB92	3921-6
MB92		sequential	which	3921-6
which	from	constraint	KL ONE	3921-6
which	stem	action	KL ONE	3921-6
KL ONE		sequential	the framework of	3921-6
Exercises Exercises Exercise 21.1	Construct	action	an instance	3922-1
an instance	for	constraint	the schema	3922-1
the schema	of	constraint	Fig	3922-1
21.1		sequential	that	3922-2
that	to	constraint	the CINEMA instance	3922-2
that	corresponds	action	the CINEMA instance	3922-2
the CINEMA instance	of	constraint	Chapter 3	3922-2
Exercise		sequential	21.2	3923-1
21.1		sequential	21.1	3923-2
<B>	that	constraint	this case	3923-3
<B>	in	constraint	this case	3923-3
<B>	Verify	action	this case	3923-3
this case		sequential	there	3923-3
there	is	attribute	no OID assignment	3923-3
no OID assignment	for	constraint	the schema	3923-3
the schema		sequential	there	3923-3
there	is	attribute	an actor	3923-3
an actor		sequential	who	3923-3
who	is	attribute	also a director	3923-3
<B>	Exercise	action	21.3 Design	3924-1
21.3 Design		sequential	an OODB schema	3924-1
an OODB schema	for	constraint	a bibliography database	3924-1
a bibliography database	with	constraint	articles	3924-1
articles		sequential	book chapters	3924-1
book chapters		sequential	<B>	3924-1
<B>	Use	action	inheritance	3924-2
inheritance		sequential	<B>	3924-2
Exercise		sequential	21.4	3925-1
Exercise		sequential	21.5	3926-1
Exercise		sequential	21.6	3927-1
Exercise		sequential	21.7	3928-1
What	is	attribute	the data complexity	3928-2
the data complexity	of	constraint	your algorithm	3928-2
Exercise		sequential	21.8	3929-1
Value equality	as	constraint	the text	3929-2
Value equality	in	constraint	the text	3929-2
Value equality	discussed	action	the text	3929-2
the text	is denoted	action	=1	3929-2
Two objects	o	constraint	o′	3929-3
o′	are	attribute	2 value	3929-3
2 value	o	constraint	=2 o′	3929-3
2 value	denoted	action	=2 o′	3929-3
=2 o′	if	constraint	each object	3929-3
=2 o′	replacing	action	each object	3929-3
each object	in	constraint	ν	3929-3
ν		sequential	o	3929-3
o	and	conjunctive	ν	3929-3
ν	by	constraint	its value	3929-3
its value	o′ yields	action	values	3929-3
values		sequential	that	3929-3
that	are	attribute	equal	3929-3
The relations =i	for	constraint	i	3929-4
i	are defined similarly	action	<B>	3929-4
<B>	that	constraint	i	3929-5
<B>	for	constraint	i	3929-5
<B>	Show	attribute	each	3929-5
i		sequential	=i+1	3929-5
=i+1	refines	action	=i	3929-5
<B>	Let	action	n	3929-6
n	be	attribute	a positive integer	3929-6
<B>	Give	action	a schema	3930-1
a schema	and	conjunctive	an instance	3930-1
an instance	over	constraint	this schema	3930-1
this schema	that	constraint	i	3930-1
this schema	for	constraint	i	3930-1
i	in	constraint	1	3930-1
1		sequential	n	3930-1
n		sequential	=i	3930-1
=i	and	conjunctive	<B>	3930-1
=i	=i+1	sequential	<B>	3930-1
=i	are	attribute	different	3930-1
<B>	Exercise	action	21.9 Design	3931-1
21.9 Design		sequential	a database schema	3931-1
a database schema	to	constraint	information	3931-1
a database schema	represent	action	information	3931-1
information	about	constraint	persons	3931-1
persons	including	action	males	3931-1
males	and	conjunctive	females	3931-1
females	with	constraint	names	3931-1
names	and	conjunctive	husbands	3931-1
husbands	and	conjunctive	wives	3931-1
<B>	Exhibit	action	a cyclic instance	3931-2
a cyclic instance	of	constraint	the schema	3931-2
the schema	and	conjunctive	an object	3931-2
an object	o	constraint	that	3931-2
that	has	action	an infinite expansion	3931-2
<B>	Describe	action	the infinite tree	3931-3
the infinite tree	representing	action	the expansion	3931-3
the expansion	of	constraint	<B>	3931-3
Exercise		sequential	21.11	3932-1
Exhibit		sequential	an instance	3932-2
an instance		sequential	I	3932-2
I	over	constraint	S	3932-2
S	and	conjunctive	two distinct objects	3932-2
two distinct objects	in	constraint	I	3932-2
I		sequential	that	3932-2
that	have	action	the same expansion	3932-2
Exhibit		sequential	two distinct instances	3932-3
two distinct instances	over	constraint	S	3932-3
S	with	constraint	the same set	3932-3
the same set	of	constraint	object expansions	3932-3
Exercise		sequential	21.12	3933-1
<B>	Give	action	algebraic versions	3933-2
algebraic versions	of	constraint	the queries	3933-2
the queries	of	constraint	that section	3933-2
T		sequential	f1	3934-1
f1		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	T	3934-1
T		sequential	f3	3934-1
f3		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	T	3934-1
T		sequential	f2	3934-1
f2		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	T	3934-1
T		sequential	f3	3934-1
f3		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	x	3934-1
x		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	T	3934-1
T		sequential	f1	3934-1
f1		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	y	3934-1
y		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	S	3934-1
S		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	T	3934-1
T		sequential	f4	3934-1
f4		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	S	3934-1
S		sequential	x	3934-1
x		sequential	y	3934-1
y		sequential	S	3934-1
S		sequential	y	3934-1
y		sequential	x	3934-1
x		sequential	P Q Object Databases P2	3934-1
P Q Object Databases P2		sequential	J	3934-1
<B>	that	constraint	P	3934-2
<B>	Show	action	P	3934-2
P	∼	sequential	exp Q	3934-2
exp Q	does not hold	action	<B>	3934-2
<B>	that	constraint	P ∼ obs Q	3935-1
<B>	Show	action	P ∼ obs Q	3935-1
invention	if	constraint	each target relation	3936-1
invention	in	constraint	each target relation	3936-1
each target relation	at	constraint	most one column	3936-1
most one column	can include	action	nonatomic Skolem terms	3936-1
nonatomic Skolem terms		sequential	OID	3936-1
<B>	Give	action	a decision procedure	3936-2
a decision procedure	for	constraint	two such programs	3936-2
a decision procedure	whether	constraint	two such programs	3936-2
a decision procedure	testing	action	two such programs	3936-2
two such programs	are obscured	attribute	equivalent	3936-2
Decidability	of	constraint	obscured equivalence	3936-3
obscured equivalence	of	constraint	arbitrary nonrecursive datalog programs	3936-3
arbitrary nonrecursive datalog programs	with	constraint	Skolem terms	3936-3
Skolem terms	in	constraint	rule heads	3936-3
rule heads	remains	attribute	open	3936-3
Exercise		sequential	21.15	3937-1
Hint		sequential	Hint	3938-1
<B>	.	sequential	<B>	3938-2
<B>	.	sequential	<B>	3938-3
<B>	and	conjunctive	c′	3938-4
<B>	let	action	c′	3938-4
c′		sequential	c.	3938-4
c.	Construct	action	the implementation	3938-4
the implementation	of	constraint	method m	3938-4
method m	on	constraint	c	3938-4
c	so that	constraint	input	3938-4
c	on	constraint	input	3938-4
input	o	constraint	the loop	3938-4
input	if	constraint	the loop	3938-4
the loop	to	constraint	it	3938-4
the loop	is	attribute	it	3938-4
the loop	continue	action	it	3938-4
it	creates	action	a new object	3938-4
a new object		sequential	o′	3938-4
o′	in	constraint	c	3938-4
c		sequential	sets	3938-4
sets		sequential	o.a	3938-4
o.a	=	sequential	o′	3938-4
o′	and	conjunctive	m	3938-4
o′	calls	action	m	3938-4
m	on	constraint	o′	3938-4
<B>	To	constraint	the loop	3938-5
<B>	terminate	action	the loop	3938-5
the loop	create	action	o′	3938-5
o′	in	constraint	c′	3938-5
c′	and	conjunctive	m	3938-5
c′	define on appropriately	action	m	3938-5
m		sequential	<B>	3938-5
Exercise Prove Proposition 21.4.1		sequential	21.16	3939-1
Hint		sequential	Hint	3939-2
The effect	of	constraint	conditionals	3939-3
conditionals	by	constraint	objects	3939-3
conditionals	can be simulated	action	objects	3939-3
conditionals	putting	action	objects	3939-3
objects	in	constraint	different classes	3939-3
different classes	and	conjunctive	dynamic binding	3939-3
different classes	using	action	dynamic binding	3939-3
Exercise		sequential	21.17	3940-1
Exercise		sequential	21.18	3941-1
Exercises		sequential	Exercises	3942-1
Exercise		sequential	21.19	3943-1
Exercise		sequential	21.20	3944-1
Exercise		sequential	21.22	3945-1
<B>	is simulated	action	<B>	3946-1
Exercise		sequential	21.23	3947-1
Exercise		sequential	21.24	3948-1
k		sequential	k	3949-1
<B>	How come	action	we	3950-1
we	to	constraint	something so important	3950-1
we	about	constraint	something so important	3950-1
we	’ ve waited so long	action	something so important	3950-1
we	talk	action	something so important	3950-1
Riccardo		sequential	Riccardo	3951-1
Sergio		sequential	Sergio	3952-1
Vittorio		sequential	Vittorio	3953-1
the persistence		sequential	size	3954-1
size	and	conjunctive	long life cycle	3954-1
long life cycle	of	constraint	a database	3954-1
a database	to	constraint	perspectives	3954-1
a database	However lead	action	perspectives	3954-1
perspectives	from	constraint	programming languages	3954-1
perspectives	in	constraint	programming languages	3954-1
perspectives	found	action	programming languages	3954-1
<B>	In	constraint	this chapter	3954-2
this chapter		sequential	we	3954-2
we	of	constraint	these differences	3954-2
we	briefly examine	attribute	some	3954-2
these differences	of	constraint	the directions	3954-2
these differences	and	conjunctive	the directions	3954-2
these differences	sketch	attribute	some	3954-2
the directions		sequential	that	3954-2
that	in	constraint	this area	3954-2
that	have been explored	action	this area	3954-2
<B>	Although	constraint	it	3954-3
it	to	constraint	databases	3954-3
it	is	attribute	central	3954-3
databases		sequential	this area	3954-3
this area	has received	action	far less attention	3954-3
far less attention	from	constraint	the theoretical research community	3954-3
the theoretical research community	than	constraint	other topics	3954-3
other topics	in	constraint	this book	3954-3
other topics	addressed	action	this book	3954-3
The discussion	in	constraint	this chapter	3955-1
this chapter	to	constraint	an overview	3955-1
this chapter	is intended	action	an overview	3955-1
this chapter	primarily give	action	an overview	3955-1
an overview	of	constraint	the important issues	3955-1
the important issues	raised	action	the dynamic aspects	3955-1
the important issues	concerning	action	the dynamic aspects	3955-1
the dynamic aspects	of	constraint	databases	3955-1
It	therefore emphasizes	action	examples	3955-2
examples	and	conjunctive	intuitions	3955-2
intuitions	than	constraint	results	3955-2
results	and	conjunctive	proofs	3955-2
This chapter	by	constraint	database update languages	3956-1
This chapter	begins	action	database update languages	3956-1
This chapter	examining	action	database update languages	3956-1
database update languages	including	action	a simple language	3956-1
a simple language		sequential	that	3956-1
that	to	constraint	the update capabilities	3956-1
that	corresponds	action	the update capabilities	3956-1
the update capabilities	of	constraint	practical languages	3956-1
practical languages		sequential	SQL	3956-1
SQL	and	conjunctive	more complex ones	3956-1
more complex ones	within	constraint	logic	3956-1
more complex ones	expressed	action	logic	3956-1
logic	based	action	a framework	3956-1
Next optimization	and	conjunctive	semantic properties	3956-2
semantic properties	of	constraint	transactions	3956-2
transactions	from	constraint	simple update commands	3956-2
transactions	built	action	simple update commands	3956-2
simple update commands	are considered	action	a discussion	3956-2
simple update commands	including	action	a discussion	3956-2
a discussion	of	constraint	the interaction	3956-2
the interaction	of	constraint	transactions	3956-2
transactions	and	conjunctive	static integrity constraints	3956-2
The impact	of	constraint	updates	3957-1
updates	in	constraint	richer contexts	3957-1
richer contexts	is considered	action	<B>	3957-1
<B>	In	constraint	connection	3957-2
connection	with	constraint	views	3957-2
views		sequential	we	3957-2
we	examine	action	the issue	3957-2
the issue	of	constraint	updates	3957-2
the issue	to	constraint	updates	3957-2
the issue	propagate incrementally	action	updates	3957-2
updates	from	constraint	base data	3957-2
base data	to	constraint	views	3957-2
views	and	conjunctive	the much more challenging issue	3957-2
the much more challenging issue	of	constraint	an update	3957-2
the much more challenging issue	propagating	action	an update	3957-2
an update	on	constraint	a view	3957-2
a view	to	constraint	the base data	3957-2
Next updates	for	constraint	incomplete information databases	3957-3
incomplete information databases	are considered	action	<B>	3957-3
<B>	both	conjunctive	the conditional tables	3957-4
<B>	includes	action	the conditional tables	3957-4
the conditional tables	in	constraint	Chapter 19	3957-4
the conditional tables	studied	action	Chapter 19	3957-4
Chapter 19	and	conjunctive	more general frameworks	3957-4
more general frameworks	in	constraint	which	3957-4
which		sequential	databases	3957-4
databases	are represented	action	logical theories	3957-4
databases	using	action	logical theories	3957-4
The emerging field	of	constraint	active databases	3958-1
active databases	is briefly presented	action	<B>	3958-1
<B>	incorporate	action	mechanisms	3958-2
mechanisms	for	constraint	changes	3958-2
mechanisms	to	constraint	changes	3958-2
mechanisms	automatically responding	action	changes	3958-2
changes	in	constraint	the environment	3958-2
the environment	or	conjunctive	the database	3958-2
the database	and	conjunctive	they	3958-2
they	often use	action	a paradigm	3958-2
they	rule based	action	a paradigm	3958-2
a paradigm	of	constraint	the responses	3958-2
a paradigm	specifying	action	the responses	3958-2
This chapter	with	constraint	a brief discussion	3959-1
This chapter	concludes	action	a brief discussion	3959-1
a brief discussion	of	constraint	temporal databases	3959-1
temporal databases		sequential	which	3959-1
which	support	action	the explicit representation	3959-1
the explicit representation	of	constraint	the time dimension	3959-1
the time dimension	and	conjunctive	thus historical information	3959-1
Dynamic Aspects Update Languages		sequential	Dynamic Aspects Update Languages	3960-1
we	Could not use	action	query languages	3960-2
query languages	to	constraint	updates	3960-2
query languages	specify	action	updates	3960-2
The difference	between	constraint	query	3961-1
query	and	conjunctive	update	3961-1
update		sequential	languages	3961-1
languages	but	conjunctive	<B>	3961-1
languages	is	attribute	subtle	3961-1
<B>	To	constraint	an update	3961-2
<B>	specify	action	an update	3961-2
an update		sequential	we	3961-2
we	could indeed define	action	the new database	3961-2
the new database	as	constraint	the answer	3961-2
the answer	to	constraint	a query	3961-2
a query	against	constraint	the old database	3961-2
a query	posed	action	the old database	3961-2
<B>	However misses	action	an essential characteristic	3961-3
an essential characteristic	of	constraint	updates	3961-3
Query languages	to	constraint	change	3961-4
Query languages	about	constraint	change	3961-4
Query languages	are	attribute	not naturally suited	3961-4
Query languages	speak explicitly	action	change	3961-4
<B>	In	constraint	contrast	3961-5
contrast		sequential	update languages	3961-5
update languages	as	constraint	building blocks	3961-5
update languages	use	action	building blocks	3961-5
building blocks		sequential	statements	3961-5
statements	expressing	action	change	3961-5
change		sequential	insertions	3961-5
insertions		sequential	deletions	3961-5
deletions	and	conjunctive	modifications	3961-5
modifications	of	constraint	tuples	3961-5
tuples	in	constraint	the database	3961-5
<B>	In	constraint	this section	3962-1
this section		sequential	we	3962-1
we	outline	action	several formal update languages	3962-1
several formal update languages	to	constraint	some theoretical issues	3962-1
several formal update languages	and	conjunctive	some theoretical issues	3962-1
several formal update languages	point	action	some theoretical issues	3962-1
some theoretical issues		sequential	that	3962-1
that	in	constraint	this context	3962-1
that	arise	action	this context	3962-1
Insert		sequential	Delete Modify	3963-1
Delete Modify		sequential	Transactions	3963-1
Most commercial relational systems	at	constraint	these update capabilities	3963-2
Most commercial relational systems	provide	attribute	least	3963-2
<B>	To	constraint	the presentation	3964-1
<B>	simplify	action	the presentation	3964-1
the presentation		sequential	we	3964-1
we	that	constraint	the database	3964-1
we	suppose	action	the database	3964-1
the database	of	constraint	a single relation schema R.	3964-1
the database	consists	action	a single relation schema R.	3964-1
a single relation schema R.		sequential	Everything	3964-1
Everything	to	constraint	the multirelational case	3964-1
Everything	can be extended	action	the multirelational case	3964-1
An insertion	is	attribute	an expression ins	3964-2
an expression ins		sequential	t	3964-2
t		sequential	t	3964-2
t	is	attribute	where a tuple	3964-2
where a tuple	over	constraint	att	3964-2
att		sequential	R	3964-2
<B>	inserts	action	the tuple t	3964-3
the tuple t	into	constraint	R.	3964-3
a condition	in	constraint	More precisely an equality	3964-4
a condition	is	attribute	More precisely an equality	3964-4
More precisely an equality	of	constraint	the form	3964-4
the form		sequential	A c	3964-4
A c	or	conjunctive	A	3964-4
A		sequential	c	3964-4
c		sequential	A ∈ att	3964-4
A ∈ att		sequential	R	3964-4
R	and	conjunctive	c	3964-4
c	is	attribute	where a constant	3964-4
A deletion	is	attribute	an expression del	3964-5
an expression del		sequential	C	3964-5
C		sequential	C	3964-5
C	is	attribute	where a finite set	3964-5
where a finite set	of	constraint	conditions	3964-5
<B>	from	constraint	R	3965-1
<B>	removes	action	R	3965-1
R		sequential	all tuples	3965-1
all tuples	satisfying Finally	action	each condition	3965-1
each condition	in	constraint	C.	3965-1
C.		sequential	a modification	3965-1
a modification	is	attribute	an expression mod	3965-1
an expression mod		sequential	C	3965-1
C	→	sequential	C′	3965-1
C′		sequential	C	3965-1
C		sequential	C′	3965-1
C′	are	attribute	where sets	3965-1
where sets	of	constraint	conditions	3965-1
conditions	with	constraint	C′	3965-1
C′	containing	action	only equalities	3965-1
only equalities		sequential	A	3965-1
A	=	sequential	c	3965-1
Example		sequential	22.1.1	3966-1
We	can define	action	criteria	3967-1
criteria	for	constraint	the optimization	3967-1
the optimization	of	constraint	IDM transactions	3967-1
IDM transactions	along	constraint	two main lines Syntactic	3967-1
<B>		sequential	<B>	3968-1
Various definitions	on	constraint	the preceeding criteria	3969-1
Various definitions	are	attribute	possible	3969-1
Various definitions	based	action	the preceeding criteria	3969-1
It	that	constraint	there	3969-2
It	can be shown	action	there	3969-2
there	exists	attribute	polynomial	3969-2
time		sequential	a algorithm	3969-2
a algorithm		sequential	that	3969-2
that	optimizes	action	IDM transactions	3969-2
IDM transactions	with	constraint	respect	3969-2
respect	to	constraint	a reasonable definition	3969-2
a reasonable definition	on	constraint	criteria	3969-2
a reasonable definition	and	conjunctive	criteria	3969-2
a reasonable definition	based	attribute	syntactic	3969-2
The syntactic criteria	involve	action	the number	3969-3
the number	of	constraint	insertions	3969-3
insertions		sequential	deletions	3969-3
deletions	and	conjunctive	modifications	3969-3
The semantic criteria	on	constraint	the number	3969-4
The semantic criteria	are based	action	the number	3969-4
the number	of	constraint	tuples	3969-4
tuples	at	constraint	runtime	3969-4
tuples	touched	action	runtime	3969-4
runtime	by	constraint	the transaction	3969-4
We	omit here	action	the details	3969-5
Example		sequential	22.1.2	3970-1
Dynamic Aspects del		sequential	A	3971-1
A	=	sequential	0	3971-1
0		sequential	B	3971-1
B	=	sequential	1 }	3971-1
1 }		sequential	del	3971-1
del		sequential	A	3971-1
A	=	sequential	0	3971-1
0		sequential	B	3971-1
B	=	sequential	2 }	3971-1
2 }		sequential	mod	3971-1
mod	{	sequential	A	3971-1
A	=	sequential	0	3971-1
0		sequential	B	3971-1
B	=	sequential	1	3971-1
1		sequential	}	3971-1
}	→	sequential	B	3971-1
}	{	sequential	B	3971-1
B	=	sequential	2 }	3971-1
2 }		sequential	mod	3971-1
mod	{	sequential	B	3971-1
B	=	sequential	0 }	3971-1
0 }	→	sequential	B	3971-1
0 }	{	sequential	B	3971-1
B	=	sequential	1 }	3971-1
1 }		sequential	mod	3971-1
mod	{	sequential	A	3971-1
A	=	sequential	0	3971-1
0		sequential	B	3971-1
B	=	sequential	2	3971-1
2		sequential	}	3971-1
}	→	sequential	B	3971-1
}	{	sequential	B	3971-1
B	=	sequential	0 }	3971-1
0 }		sequential	ins	3971-1
ins		sequential	0	3971-1
0		sequential	0	3971-1
the six modifications		sequential	one deletion	3972-1
one deletion	and	conjunctive	two insertions	3972-1
two insertions	of	constraint	the original transaction	3972-1
the original transaction	by	constraint	three modifications	3972-1
the original transaction	Thus were replaced	action	three modifications	3972-1
three modifications		sequential	two deletions	3972-1
two deletions	and	conjunctive	one insertion	3972-1
mod		sequential	C C′	3973-1
C C′	→	sequential	del	3973-1
del		sequential	C′	3973-1
C′		sequential	⇒ del	3973-1
⇒ del		sequential	C	3973-1
C		sequential	del	3973-1
del		sequential	C′	3973-1
It	that	constraint	such a set	3974-1
It	can be shown	action	such a set	3974-1
such a set	of	constraint	simplification rules	3974-1
simplification rules	to	constraint	a restricted set	3974-1
simplification rules	can be used	action	a restricted set	3974-1
simplification rules	optimize	action	a restricted set	3974-1
a restricted set	of	constraint	IDM transactions	3974-1
IDM transactions		sequential	that	3974-1
that	satisfy	action	a syntactic acyclicity condition	3974-1
<B>	For	constraint	the other transactions	3974-2
the other transactions		sequential	applications	3974-2
applications	of	constraint	the simplification rules	3974-2
the simplification rules	but	conjunctive	a transaction	3974-2
the simplification rules	yield	attribute	simpler	3974-2
The simplification rules	have	action	the advantage	3974-3
the advantage	that	constraint	they	3974-3
they	whereas	constraint	the complete optimization algorithm	3974-3
they	and	conjunctive	the complete optimization algorithm	3974-3
they	are	attribute	local	3974-3
they	can be easily applied even online	action	the complete optimization algorithm	3974-3
the complete optimization algorithm	to	constraint	the entire transaction	3974-3
the complete optimization algorithm	and	conjunctive	the entire transaction	3974-3
the complete optimization algorithm	is	attribute	global	3974-3
the complete optimization algorithm	has	action	the entire transaction	3974-3
the complete optimization algorithm	know	action	the entire transaction	3974-3
the entire transaction	in	constraint	advance	3974-3
Rule	Based	action	Update Languages	3975-1
<B>	in	constraint	many ways	3975-2
<B>	can be extended	action	many ways	3975-2
One possibility	to	constraint	another procedural language	3975-3
One possibility	is	attribute	another procedural language	3975-3
One possibility	build	action	another procedural language	3975-3
another procedural language	on	constraint	tuple insertions	3975-3
another procedural language	based	action	tuple insertions	3975-3
tuple insertions		sequential	deletions	3975-3
deletions	and	conjunctive	modifications	3975-3
modifications		sequential	which	3975-3
which	includes	action	relation variables	3975-3
relation variables	and	conjunctive	an iterative construct	3975-3
<B>		sequential	which	3975-4
which		sequential	we	3975-4
we	to	constraint	a approach	3975-4
we	is	attribute	a approach	3975-4
we	illustrate next	action	a approach	3975-4
we	use	action	a approach	3975-4
we	rule based	action	a approach	3975-4
<B>	For	constraint	example	3976-1
example	consider	action	the language datalog¬¬	3976-1
the language datalog¬¬	in	constraint	Chapter 17	3976-1
the language datalog¬¬	described	action	Chapter 17	3976-1
Chapter 17	with	constraint	its fixpoint semantics	3976-1
<B>	that	constraint	rules	3976-2
<B>	Recall	action	rules	3976-2
rules	for	constraint	atoms	3976-2
rules	both	conjunctive	atoms	3976-2
rules	and	conjunctive	atoms	3976-2
rules	allow	attribute	positive	3976-2
atoms	in	constraint	heads	3976-2
heads	of	constraint	rules	3976-2
rules	with	constraint	the fixpoint semantics	3976-2
the fixpoint semantics		sequential	the positive atoms	3976-2
the positive atoms	as	constraint	insertions	3976-2
the positive atoms	consistently can be viewed	action	insertions	3976-2
insertions	of	constraint	facts	3976-2
facts	and	conjunctive	the negative atoms	3976-2
the negative atoms	as	constraint	deletions	3976-2
deletions	of	constraint	facts	3976-2
<B>	For	constraint	example	3976-3
example		sequential	the following program	3976-3
the following program	removes	action	all cycles	3976-3
all cycles	of	constraint	length one	3976-3
length one	or	conjunctive	two	3976-3
two	from	constraint	the graph G	3976-3
<B>	In	constraint	the usual fixpoint semantics	3977-1
the usual fixpoint semantics		sequential	rules	3977-1
rules	in	constraint	all possible instantiations	3977-1
rules	with	constraint	all possible instantiations	3977-1
rules	are fired	attribute	parallel	3977-1
all possible instantiations	for	constraint	the variables	3977-1
<B>	yields	action	a deterministic semantics	3977-2
rule	based	action	Some practical update languages	3977-3
Some practical update languages	take	action	an alternative approach	3977-3
an alternative approach		sequential	which	3977-3
which	yields	action	a nondeterministic semantics	3977-3
<B>	With	constraint	this semantics	3977-4
this semantics		sequential	the preceeding program	3977-4
the preceeding program	provides	action	some orientation	3977-4
some orientation	of	constraint	the graph G. Note	3977-4
the graph G. Note	that	constraint	there	3977-4
there	generally is	action	no way	3977-4
no way	to	constraint	an orientation	3977-4
no way	obtain deterministically	action	an orientation	3977-4
an orientation	of	constraint	a graph	3977-4
a graph	because	constraint	a nondeterministic choice	3977-4
a nondeterministic choice	of	constraint	edges	3977-4
edges	to	constraint	<B>	3977-4
edges	be removed	action	<B>	3977-4
edges	may be needed	action	<B>	3977-4
<B>	in	constraint	Chapter 18	3978-1
<B>	in	constraint	the manner	3978-2
<B>	can be done	action	the manner	3978-2
the manner	in	constraint	Exercise 18.22	3978-2
the manner	described	action	Exercise 18.22	3978-2
The same language	with	constraint	nondeterministic semantics	3978-3
nondeterministic semantics	to	constraint	all nondeterministic updates	3978-3
nondeterministic semantics	can be shown	action	all nondeterministic updates	3978-3
nondeterministic semantics	express	action	all nondeterministic updates	3978-3
The aforementioned languages	yield	action	bottom	3979-1
bottom	up	constraint	a evaluation procedure	3979-1
The body	of	constraint	the rule	3979-2
the rule	and	conjunctive	the actions	3979-2
the rule	is first checked	action	the actions	3979-2
the actions	in	constraint	the head	3979-2
the head	are executed	action	<B>	3979-2
Another possibility	to	constraint	a approach	3979-3
Another possibility	is	attribute	top down	3979-3
Another possibility	adopt	attribute	top down	3979-3
a approach	in	constraint	the spirit	3979-3
the spirit	of	constraint	the assert	3979-3
the assert	in	constraint	Prolog	3979-3
the actions	to	constraint	rule bodies	3979-4
the actions	in	constraint	rule bodies	3979-4
the actions	be taken	action	rule bodies	3979-4
the actions	Here are specified	action	rule bodies	3979-4
A good example	of	constraint	this approach	3979-5
this approach	by	constraint	Dynamic Logic Programming	3979-5
this approach	is provided	action	Dynamic Logic Programming	3979-5
Dynamic Logic Programming		sequential	DLP	3979-5
this language	Interestingly allows	action	us	3979-6
us	to	constraint	hypothetical conditions	3979-6
us	test	action	hypothetical conditions	3979-6
hypothetical conditions	of	constraint	the form	3979-6
the form		sequential	ϕ	3979-6
ϕ	if	constraint	t	3979-6
ϕ	Would hold	action	t	3979-6
t	and	conjunctive	the connection	3979-6
t	was inserted	attribute	This	3979-6
the connection	of	constraint	DLP	3979-6
DLP	with	constraint	Prolog	3979-6
Prolog	is illustrated next	action	<B>	3979-6
Example		sequential	22.1.3	3980-1
<B>	that	constraint	an update	3981-1
<B>	Suppose	action	an update	3981-1
an update	to	constraint	John	3981-1
an update	is intended	action	John	3981-1
an update	hire	action	John	3981-1
John	in	constraint	the toys department	3981-1
the toys department	with	constraint	a salary	3981-1
a salary	of	constraint	200K	3981-1
200K	under	constraint	the condition	3981-1
the condition	that	constraint	the average salary	3981-1
the average salary	of	constraint	the department	3981-1
the department	below	constraint	50 K	3981-1
the department	stays	action	50 K	3981-1
<B>	In	constraint	the language	3981-2
the language		sequential	DLP	3981-2
DLP		sequential	this update	3981-2
this update	by	constraint	hire	3981-2
this update	is expressed	action	hire	3981-2
hire		sequential	emp	3981-2
emp		sequential	1	3981-2
1		sequential	sal	3981-2
sal		sequential	1	3981-2
1		sequential	dep	3981-2
dep		sequential	1	3981-2
<B>	Testing	action	a condition	3982-1
a condition	under	constraint	the assumption	3982-1
the assumption	of	constraint	an update	3982-1
an update	is	attribute	a form	3982-1
a form	of	constraint	hypothetical reasoning	3982-1
It	to	constraint	the semantics	3983-1
It	is	attribute	interesting	3983-1
It	contrast	action	the semantics	3983-1
the semantics	of	constraint	DLP	3983-1
DLP	with	constraint	Prolog	3983-1
DLP	of	constraint	Prolog	3983-1
<B>	Consider	action	the following Prolog program	3983-2
<B>	In	constraint	this program	3984-1
this program		sequential	the insertions	3984-1
the insertions	into	constraint	ES	3984-1
ES	and	conjunctive	ED	3984-1
ED	if	constraint	the conditions	3984-1
ED	will be performed	action	the conditions	3984-1
the conditions	are	attribute	even not satisfied afterward	3984-1
The reader	with	constraint	Prolog	3984-2
Prolog	to	constraint	a program	3984-2
Prolog	is encouraged	action	a program	3984-2
Prolog	write	action	a program	3984-2
a program		sequential	that	3984-2
that	has	action	the desired semantics	3984-2
Updates	concern	action	not only instances	3985-1
not only instances	of	constraint	a fixed schema	3985-1
the schema itself	to	constraint	an attribute	3985-2
the schema itself	by	constraint	an attribute	3985-2
the schema itself	Sometimes needs	action	an attribute	3985-2
the schema itself	be changed	action	an attribute	3985-2
the schema itself	e.g. adding	action	an attribute	3985-2
Some practical update languages	include	action	constructs	3985-3
constructs	for	constraint	schema change	3985-3
The main problem	to	constraint	the existing data	3985-4
The main problem	is	attribute	the existing data	3985-4
The main problem	be resolved	action	the existing data	3985-4
the existing data	to	constraint	the new schema	3985-4
the existing data	how can be fit	action	the new schema	3985-4
<B>	In	constraint	deductive databases	3986-1
deductive databases		sequential	some relations	3986-1
some relations	are defined	action	rules	3986-1
some relations	using	action	rules	3986-1
these definitions	to	constraint	updates	3986-2
these definitions	to	constraint	updates	3986-2
these definitions	Occasionally may have	action	updates	3986-2
these definitions	be changed	action	updates	3986-2
these definitions	leading	action	updates	3986-2
updates	of	constraint	the rule base	3986-2
the rule base		sequential	There	3986-2
There	are	attribute	languages	3986-2
languages		sequential	that	3986-2
that	to	constraint	such updates	3986-2
that	can be used	action	such updates	3986-2
that	specify	action	such updates	3986-2
Dynamic Aspects Transactional Schemas Typically		sequential	database systems	3987-1
database systems	restrict	action	the kinds	3987-1
the kinds	of	constraint	updates	3987-1
updates		sequential	that	3987-1
that		sequential	users	3987-1
users	can perform	action	<B>	3987-1
There	are	attribute	three main ways	3987-2
three main ways	of	constraint	<B>	3987-2
three main ways	doing	attribute	this	3987-2
Object	oriented	action	databases	3988-1
databases	essentially embrace b	action	option	3988-1
option		sequential	updates	3988-1
updates	by	constraint	only methods	3988-1
updates	are performed	action	only methods	3988-1
only methods	at	constraint	the schema level	3988-1
only methods	specified	action	the schema level	3988-1
the schema level	and	conjunctive	it	3988-1
it	that	constraint	the constraints	3988-1
it	is assumed	attribute	these	3988-1
it	will not violate	action	the constraints	3988-1
the constraints	see	action	Chapter 21	3988-1
Both options	in	constraint	the relational model	3988-2
Both options	and	conjunctive	the relational model	3988-2
Both options	are	attribute	a b present	3988-2
Several commercial systems	on	constraint	violation	3989-1
Several commercial systems	and	conjunctive	violation	3989-1
Several commercial systems	can recognize	action	violation	3989-1
Several commercial systems	abort	action	violation	3989-1
violation	of	constraint	simple constraints	3989-1
simple constraints	and	conjunctive	typically inclusion dependencies	3989-1
maintenance	of	constraint	more complex constraints	3989-2
more complex constraints	to	constraint	the application software	3989-2
more complex constraints	However is left	action	the application software	3989-2
Option		sequential	c	3989-3
c	by	constraint	the emerging field	3989-3
c	is supported	action	the emerging field	3989-3
the emerging field	of	constraint	active databases	3989-3
active databases		sequential	which	3989-3
which	in	constraint	the following section	3989-3
which	is discussed	action	the following section	3989-3
We	now briefly explore b	action	some issues	3990-1
some issues	to	constraint	approach	3990-1
approach	in	constraint	connection	3990-1
connection	with	constraint	the relational model	3990-1
<B>	To	constraint	the issues	3990-2
<B>	illustrate	action	the issues	3990-2
the issues		sequential	we	3990-2
we	use	action	simple procedures	3990-2
simple procedures	on	constraint	IDM transactions	3990-2
simple procedures	based	action	IDM transactions	3990-2
The procedures		sequential	we	3990-3
we	are	attribute	parameterized IDM transactions	3990-3
we	use	action	parameterized IDM transactions	3990-3
parameterized IDM transactions	by	constraint	variables	3990-3
parameterized IDM transactions	obtained	action	variables	3990-3
parameterized IDM transactions	allowing	action	variables	3990-3
variables	in	constraint	addition	3990-3
addition	to	constraint	constants	3990-3
constants	in	constraint	conditions	3990-3
conditions	of	constraint	IDM transactions	3990-3
The variables	as	constraint	parameters	3990-4
The variables	are used	action	parameters	3990-4
A database schema R together	with	constraint	a finite set	3990-5
a finite set	of	constraint	parameterized IDM transactions	3990-5
parameterized IDM transactions	over	constraint	R	3990-5
R	is called	action	an IDM transactional schema	3990-5
Example		sequential	22.2.1	3991-1
IDM	parameterized	action	The following transactions	3991-2
The following transactions	allow	action	the hiring	3991-2
the hiring	and	conjunctive	firing	3991-2
firing	of	constraint	TAs	3991-2
TAs		sequential	subscripts	3991-2
subscripts	indicate	action	the relation	3991-2
the relation	to	constraint	which	3991-2
which		sequential	each update	3991-2
each update	applies	action	x	3991-2
each update	hire	action	x	3991-2
x		sequential	y	3991-2
y		sequential	z	3991-2
z	=	sequential	delTA	3991-2
delTA		sequential	Name	3991-2
Name	=	sequential	x	3991-2
x		sequential	insTA	3991-2
insTA		sequential	x y	3991-2
x y		sequential	delPHD	3991-2
delPHD		sequential	Name	3991-2
Name	=	sequential	x	3991-2
x		sequential	insPHD	3991-2
insPHD		sequential	x	3991-2
x		sequential	z	3991-2
z		sequential	fire	3991-2
fire		sequential	x	3991-2
<B>	in	constraint	this simple example	3991-3
<B>	Note	action	this simple example	3991-3
this simple example	that	constraint	a name	3991-3
this simple example	once	constraint	a name	3991-3
a name	into	constraint	the PHD relation	3991-3
a name	n	conjunctive	the PHD relation	3991-3
a name	is incorporated	action	the PHD relation	3991-3
the PHD relation		sequential	it	3991-3
it	can never be removed	action	<B>	3991-3
we	Clearly could similarly define	action	transactional schemas	3992-1
transactional schemas	in	constraint	conjunction	3992-1
conjunction	with	constraint	any update language	3992-1
<B>	Suppose	action	T	3993-1
T	is	attribute	an IDM transactional schema	3993-1
<B>	To	constraint	the parameterized transactions	3993-2
<B>	apply	action	the parameterized transactions	3993-2
the parameterized transactions		sequential	values	3993-2
values	to	constraint	the variables	3993-2
values	must be supplied	action	the variables	3993-2
A transaction	by	constraint	the variables	3993-3
A transaction	obtained	action	the variables	3993-3
A transaction	replacing	action	the variables	3993-3
the variables	of	constraint	a parameterized transaction t	3993-3
a parameterized transaction t	in	constraint	T	3993-3
T	by	constraint	constants	3993-3
constants	is	attribute	a call	3993-3
a call	to	constraint	t	3993-3
The set	of	constraint	instances	3994-1
instances		sequential	that	3994-1
that	by	constraint	such calls	3994-1
that	can be generated	action	such calls	3994-1
such calls	from	constraint	the empty instance	3994-1
such calls	starting	action	the empty instance	3994-1
the empty instance	is denoted	action	Gen	3994-1
Gen		sequential	T	3994-1
Transactional schemas	offer	action	an approach	3995-1
an approach	for	constraint	constraint enforcement	3995-1
constraint enforcement	by	constraint	updates	3995-1
constraint enforcement	essentially preventing	action	updates	3995-1
updates		sequential	that	3995-1
that	violate	action	them	3995-1
it	to	constraint	what extent	3995-2
it	to	constraint	what extent	3995-2
it	is	attribute	So important	3995-2
it	understand	action	what extent	3995-2
what extent		sequential	they	3995-2
they	can do so	action	<B>	3995-2
we	to	constraint	the issue	3995-3
we	First need	action	the issue	3995-3
we	clarify	action	the issue	3995-3
<B>	Suppose	action	T	3995-4
T	is	attribute	an IDM transactional schema	3995-4
an IDM transactional schema	and	conjunctive	a set	3995-4
an IDM transactional schema	is	attribute	a set	3995-4
a set	of	constraint	constraints	3995-4
constraints	over	constraint	a database schema R	3995-4
a database schema R		sequential	Sat	3995-4
Sat	denotes	action	all instances	3995-4
all instances	over	constraint	R	3995-4
R		sequential	<B>	3995-4
<B>	If	constraint	T	3995-5
T	to	constraint	we	3995-5
T	is replace	action	we	3995-5
we	would expect	action	the following properties	3995-5
the following properties	to	constraint	<B>	3995-5
the following properties	hold	action	<B>	3995-5
T	with	constraint	respect	3996-1
T	and	conjunctive	respect	3996-1
T	is	attribute	Thus sound	3996-1
respect	to	constraint	iff	3996-1
iff		sequential	it	3996-1
it	generates	action	precisely the instances satisfying	3996-1
Example		sequential	22.2.2	3997-1
22.2.2	Consider again	action	the IDM transactional schema T	3997-1
the IDM transactional schema T	in	constraint	Example 22.2.1	3997-1
<B>	be	attribute	the following constraints TA	3997-2
<B>	Let	action	the following constraints TA	3997-2
the following constraints TA		sequential	Name PHD	3997-2
Name PHD		sequential	Name → Address TA	3997-2
Name → Address TA		sequential	Name	3997-2
<B>	is	attribute	Gen	3997-3
Gen		sequential	T	3997-3
T	=	sequential	Sat	3997-3
Sat		sequential	Exercise	3997-3
Exercise		sequential	22.7	3997-3
This example	also highlights	action	a limitation	3998-1
a limitation	in	constraint	the notion	3998-1
the notion	of	constraint	completeness	3998-1
Such forbidden transitions	are	attribute	also a means	3998-2
also a means	of	constraint	the model	3998-2
also a means	enriching	action	the model	3998-2
the model	because	constraint	we	3998-2
we	can view	action	them	3998-2
them	as	constraint	temporal constraints	3998-2
temporal constraints	on	constraint	the database evolution	3998-2
We	to	constraint	temporal constraints	3998-3
We	will return later	action	temporal constraints	3998-3
temporal constraints	in	constraint	this chapter	3998-3
the ability	of	constraint	transaction schemas	3999-1
transaction schemas	to	constraint	constraints	3999-1
transaction schemas	replace	action	constraints	3999-1
constraints	on	constraint	the update language	3999-1
constraints	Of course depends	action	the update language	3999-1
the update language	used	action	<B>	3999-1
<B>	For	constraint	IDM transactional schemas	3999-2
IDM transactional schemas		sequential	we	3999-2
we	can show	attribute	the	3999-2
we	following	action	Exercise 22.8	3999-2
Exercise 22.8		sequential	Theorem 22.2.3	3999-2
IDM transactional schemas	of	constraint	a significant set	4000-1
IDM transactional schemas	are	attribute	Thus capable	4000-1
IDM transactional schemas	replacing	action	a significant set	4000-1
a significant set	of	constraint	constraints	4000-1
The kind	of	constraint	difficulty	4000-2
difficulty		sequential	that	4000-2
that	with	constraint	more general constraints	4000-2
that	arises	action	more general constraints	4000-2
more general constraints	is illustrated next	action	<B>	4000-2
Example		sequential	22.2.4	4001-1
It	to	constraint	each relation	4002-1
It	that	constraint	each relation	4002-1
It	for	constraint	each relation	4002-1
It	is	attribute	easy	4002-1
It	check	action	each relation	4002-1
each relation	satisfying	action	the constraints	4002-1
the constraints		sequential	the number	4002-1
the number	of	constraint	constants	4002-1
constants	in	constraint	the relation	4002-1
the relation	is	attribute	a perfect square	4002-1
a perfect square		sequential	n2	4002-1
n2	n	conjunctive	0	4002-1
n2	≥	sequential	0	4002-1
there	Thus are	action	unbounded gaps	4002-2
unbounded gaps	between	constraint	instances	4002-2
instances	in	constraint	Sat	4002-2
There	is	attribute	no IDM transactional schema T such	4002-3
no IDM transactional schema T such	that	constraint	Sat	4002-3
Sat	=	sequential	Gen	4002-3
Gen		sequential	T	4002-3
T	because	constraint	the gaps	4002-3
the gaps	can not be crossed	action	calls	4002-3
the gaps	using	action	calls	4002-3
calls	to	constraint	parameterized transactions	4002-3
parameterized transactions	with	constraint	a bounded number	4002-3
a bounded number	of	constraint	parameters	4002-3
this problem	to	constraint	IDM transactional schemas	4002-4
this problem	is	attribute	Moreover not specific	4002-4
IDM transactional schemas		sequential	it	4002-4
it	with	constraint	any language	4002-4
it	arises	action	any language	4002-4
any language	in	constraint	which	4002-4
which		sequential	procedures	4002-4
procedures	can only introduce	action	a bounded number	4002-4
a bounded number	of	constraint	new constants	4002-4
new constants	into	constraint	the database	4002-4
the database	at	constraint	each call	4002-4
<B>	Updating	action	Views	4003-1
Views	and	conjunctive	Deductive Databases	4003-1
Views	are	attribute	an important aspect	4003-2
an important aspect	of	constraint	databases	4003-2
The interplay	between	constraint	views	4004-1
views	and	conjunctive	updates	4004-1
updates	is	attribute	intricate	4004-1
We	in	constraint	two important issues	4004-2
We	can mention	attribute	particular	4004-2
One	is	attribute	the view maintenance problem	4004-3
An important variation	of	constraint	the context	4004-4
An important variation	in	constraint	the context	4004-4
An important variation	is	attribute	the context	4004-4
the context	of	constraint	deductive databases	4004-4
deductive databases		sequential	the view	4004-4
the view	of	constraint	idb relations	4004-4
the view	when consists	action	idb relations	4004-4
<B>	as	constraint	the view update problem	4004-5
<B>	is known	action	the view update problem	4004-5
the view update problem	Given	action	a view	4004-5
a view	and	conjunctive	an update	4004-5
an update	against	constraint	a view	4004-5
a view		sequential	the problem	4004-5
the problem	to	constraint	the update	4004-5
the problem	is	attribute	the update	4004-5
the problem	translate	action	the update	4004-5
the update	into	constraint	a corresponding update	4004-5
a corresponding update	against	constraint	the base data	4004-5
This section	considers	action	these two issues	4004-6
these two issues	in	constraint	turn	4004-6
<B>	View	action	Maintenance	4005-1
<B>	that	constraint	a materialized view	4005-2
<B>	Suppose further	action	a materialized view	4005-2
a materialized view	to	constraint	<B>	4005-2
a materialized view	is be maintained	action	<B>	4005-2
<B>	For	constraint	this discussion	4006-1
this discussion		sequential	an update	4006-1
an update	for	constraint	a schema R	4006-1
a schema R	to	constraint	a mapping	4006-1
a schema R	be	attribute	a mapping	4006-1
a schema R	is considered	action	a mapping	4006-1
a mapping	from	constraint	Inst	4006-1
Inst		sequential	R	4006-1
R	to	constraint	Inst	4006-1
Inst		sequential	R	4006-1
<B>	If	constraint	constraints	4006-2
constraints	are	attribute	present	4006-2
it	that	constraint	an update	4006-2
it	is assumed	action	an update	4006-2
an update	to	constraint	instances	4006-2
an update	can not map	action	instances	4006-2
instances	violating	action	the constraints	4006-2
The updates	on	constraint	IDM transactions	4006-3
The updates	considered here	action	IDM transactions	4006-3
The updates	might be based	action	IDM transactions	4006-3
IDM transactions	or	conjunctive	<B>	4006-3
IDM transactions	be	attribute	might more general	4006-3
We	of	constraint	update that maps v	4006-4
We	shall often speak	attribute	the	4006-4
update that maps v		sequential	µ	4006-4
µ		sequential	I	4006-4
I		sequential	V I′ V f	4006-4
V I′ V f		sequential	I	4006-4
I		sequential	B	4006-4
B		sequential	I′ B	4006-4
I′ B		sequential	Figure	4006-4
Figure		sequential	22.1	4006-4
22.1		sequential	Relationship	4006-4
Relationship	of	constraint	views	4006-4
views	and	conjunctive	updates instance	4006-4
updates instance		sequential	I	4006-4
I	to	constraint	I′	4006-4
I	instance	action	I′	4006-4
I′	by	constraint	we	4006-4
I′	and	conjunctive	we	4006-4
we	shall mean	action	the set	4006-4
the set	of	constraint	insertions	4006-4
insertions	and	conjunctive	deletions	4006-4
deletions		sequential	that	4006-4
that	to	constraint	I	4006-4
that	to	constraint	I	4006-4
that	need	action	I	4006-4
that	be made	action	I	4006-4
I	to	constraint	I′	4006-4
I	obtain	action	I′	4006-4
<B>	that	constraint	the base database	4007-1
<B>	Suppose	action	the base database	4007-1
the base database		sequential	B	4007-1
B	is holding	action	IB	4007-1
IB	and	conjunctive	that update	4007-1
that update		sequential	µ	4007-1
µ	to	constraint	I′	4007-1
µ	maps	attribute	this	4007-1
I′	see	action	B Fig	4007-1
22.1		sequential	22.1	4007-2
A naive way	to	constraint	the view	4007-3
A naive way	keep up	action	the view	4007-3
the view	to	constraint	date	4007-3
date	to	constraint	f	4007-3
date	is	attribute	f	4007-3
date	simply compute	action	f	4007-3
f		sequential	I′	4007-3
However B		sequential	However B	4007-4
<B>	is	attribute	the view maintenance problem	4007-5
There	are generally	action	two main components	4008-1
two main components	to	constraint	solutions	4008-1
solutions	of	constraint	the view maintenance problem	4008-1
<B>	involves	action	algorithms	4008-2
<B>	developing	action	algorithms	4008-2
algorithms	to	constraint	an update	4008-2
algorithms	whether	constraint	an update	4008-2
algorithms	test	action	an update	4008-2
an update	to	constraint	the base data	4008-2
the base data	can affect	action	the view	4008-2
<B>	Given	action	such an algorithm	4008-3
such an algorithm		sequential	an update	4008-3
an update	to	constraint	the algorithm	4008-3
an update	if	constraint	the algorithm	4008-3
an update	is said	attribute	irrelevant	4008-3
an update	be	attribute	irrelevant	4008-3
the algorithm	that	constraint	the update	4008-3
the algorithm	certifies	action	the update	4008-3
the update	can not affect	action	the view	4008-3
the view	and	conjunctive	it	4008-3
it	to	constraint	<B>	4008-3
it	is said	attribute	relevant otherwise	4008-3
it	be	attribute	relevant otherwise	4008-3
Example		sequential	22.3.1	4009-1
<B>	Inserting	action	b	4010-1
b		sequential	20	4010-1
20	into	constraint	S	4010-1
S	can not affect	action	views V1	4010-1
views V1	or	conjunctive	V2	4010-1
<B>	On	constraint	the other hand	4010-2
the other hand	whether or not	constraint	this insertion	4010-2
this insertion	affects	action	V3	4010-2
V3	or	conjunctive	V4	4010-2
V4	on	constraint	the data	4010-2
V4	depends	action	the data	4010-2
the data	in	constraint	the database	4010-2
Various algorithms	for	constraint	relevance	4011-1
Various algorithms	have been developed	action	relevance	4011-1
Various algorithms	determining	action	relevance	4011-1
relevance	with	constraint	varying degrees	4011-1
varying degrees	of	constraint	precision	4011-1
A useful technique	involves	action	auxiliary information	4011-2
A useful technique	maintaining	action	auxiliary information	4011-2
auxiliary information	as	constraint	<B>	4011-2
auxiliary information	illustrated next	action	<B>	4011-2
Example		sequential	22.3.2	4012-1
One way	to	constraint	a count	4012-2
One way	to	constraint	a count	4012-2
One way	monitor	attribute	this	4012-2
One way	is	attribute	a count	4012-2
One way	maintain	action	a count	4012-2
a count	on	constraint	the number	4012-2
the number	of	constraint	distinct ways	4012-2
distinct ways		sequential	that	4012-2
that		sequential	a value	4012-2
a value	if	constraint	this count	4012-2
a value	can arise	action	this count	4012-2
this count	ever reaches	action	0	4012-2
0		sequential	the value	4012-2
the value	from	constraint	the view	4012-2
the value	should be deleted	action	the view	4012-2
The other main component	of	constraint	solutions	4013-1
solutions	to	constraint	the view maintenance problem	4013-1
the view maintenance problem	concerns	action	the development	4013-1
the development	of	constraint	incremental evaluation algorithms	4013-1
<B>	to	constraint	the seminaive algorithm	4013-2
<B>	is	attribute	closely related	4013-2
the seminaive algorithm	for	constraint	datalog programs	4013-2
the seminaive algorithm	evaluating	action	datalog programs	4013-2
datalog programs	see	action	Chapter 13	4013-2
Example 22.3.3 Recall view V3	from	constraint	Example 22.3.1	4014-1
Example 22.3.1	and	conjunctive	I	4014-1
Example 22.3.1	let	action	I	4014-1
I	and	conjunctive	I+	4014-1
I	+	sequential	I+	4014-1
I+	denote	action	sets	4014-1
sets		sequential	R S	4014-1
R S	of	constraint	tuples	4014-1
tuples		sequential	that	4014-1
that	to	constraint	R	4014-1
that	into	constraint	R	4014-1
that	are be inserted	action	R	4014-1
R	and	conjunctive	S	4014-1
S		sequential	<B>	4014-1
It	that	constraint	R ∪ I+	4014-2
It	is easily verified	action	R ∪ I+	4014-2
R ∪ I+		sequential	S	4014-2
S		sequential	∪ I+	4014-2
∪ I+	=	sequential	R	4014-2
R	⊲⊳	sequential	S	4014-2
S		sequential	∪	4014-2
∪		sequential	R	4014-2
R	⊲⊳	sequential	I+	4014-2
I+		sequential	∪	4014-2
∪		sequential	I+	4014-2
I+		sequential	⊲⊳ S	4014-2
⊲⊳ S		sequential	∪	4014-2
∪	I+	sequential	I+	4014-2
∪	⊲⊳	sequential	I+	4014-2
R S S R R S		sequential	R S S R R S	4015-1
It	to	constraint	incremental evaluation expressions	4016-1
It	is	attribute	relatively straightforward	4016-1
It	develop	action	incremental evaluation expressions	4016-1
incremental evaluation expressions	in	constraint	the preceeding example	4016-1
the preceeding example	for	constraint	the relational algebra operators	4016-1
the preceeding example	of	constraint	the relational algebra operators	4016-1
the relational algebra operators	see	action	Exercise 22.13	4016-1
<B>	In	constraint	some cases	4017-1
some cases		sequential	these expressions	4017-1
these expressions	by	constraint	information	4017-1
these expressions	can be refined	action	information	4017-1
these expressions	using	action	information	4017-1
information	about	constraint	constraints	4017-1
constraints	and	conjunctive	dependencies	4017-1
dependencies	on	constraint	the base data	4017-1
Incremental Update	of	constraint	Deductive Views	4018-1
<B>	In	constraint	the techniques	4018-2
the techniques	to	constraint	recursion	4018-2
the techniques	to	constraint	recursion	4018-2
the techniques	but	conjunctive	recursion	4018-2
the techniques	used	attribute	analogous	4018-2
the techniques	are	attribute	analogous	4018-2
the techniques	discussed earlier	action	recursion	4018-2
the techniques	are generalized	action	recursion	4018-2
the techniques	incorporate	action	recursion	4018-2
<B>	In	constraint	the context	4018-3
the context	of	constraint	stratified datalog¬	4018-3
stratified datalog¬		sequential	various heuristics	4018-3
various heuristics	from	constraint	the field	4018-3
various heuristics	have been adapted	action	the field	4018-3
the field	of	constraint	belief revision	4018-3
belief revision	for	constraint	supports	4018-3
belief revision	incrementally maintaining	action	supports	4018-3
supports		sequential	auxiliary information	4018-3
auxiliary information		sequential	that	4018-3
that	holds	action	the justifications	4018-3
the justifications	for	constraint	the presence	4018-3
the presence	of	constraint	a fact	4018-3
a fact	in	constraint	the materialized output	4018-3
the materialized output	of	constraint	the program	4018-3
Example		sequential	22.3.4	4019-1
<B>	that	constraint	I	4019-2
<B>	Suppose	action	I	4019-2
I	is	attribute	an instance	4019-2
an instance	of	constraint	G	4019-2
G	and	conjunctive	J	4019-2
J	is	attribute	P	4019-2
P		sequential	I	4019-2
<B>	that	constraint	tuple a	4019-3
<B>	Suppose	action	tuple a	4019-3
tuple a		sequential	b	4019-3
b	into	constraint	I	4019-3
b	is inserted	action	I	4019-3
Then a tuple a′	into	constraint	J	4019-4
Then a tuple a′	b′ will be inserted	action	J	4019-4
J	iff	constraint	one following	4019-4
one following	of	constraint	<B>	4019-4
one following	occurs	action	<B>	4019-4
The preceeding conditions	by	constraint	first order	4020-1
The preceeding conditions	can clearly be specified	action	first order	4020-1
first order		sequential	a query	4020-1
It	that	constraint	P	4020-2
It	easily follows	action	P	4020-2
P	is	attribute	FOID	4020-2
FOID	see	action	Exercise 22.21	4020-2
Several variations	of	constraint	FOIDs	4021-1
FOIDs	have been studied	action	<B>	4021-1
<B>	include	action	FOIDs	4021-2
FOIDs	with	constraint	auxiliary relations	4021-2
auxiliary relations		sequential	that	4021-2
that	permit	action	the maintenance	4021-2
the maintenance	of	constraint	derived relations	4021-2
derived relations	in	constraint	not the original datalog program	4021-2
not the original datalog program	and	conjunctive	FOIDs	4021-2
FOIDs		sequential	that	4021-2
that	support	action	incremental updates	4021-2
incremental updates	for	constraint	sets	4021-2
sets	of	constraint	insertions	4021-2
insertions	and	conjunctive	deletions	4021-2
insertions	or	conjunctive	deletions	4021-2
FOIDs	for	constraint	a number	4021-3
FOIDs	have been found	action	a number	4021-3
a number	of	constraint	restricted classes	4021-3
restricted classes	of	constraint	datalog programs	4021-3
it	whether	constraint	there	4022-1
it	However remains	attribute	open	4022-1
there	is	attribute	a datalog program	4022-1
a datalog program		sequential	that	4022-1
that	is	attribute	not FOID	4022-1
not FOID	with	constraint	auxiliary relations	4022-1
Basic Issues	in	constraint	View Update	4023-1
<B>	to	constraint	Fig	4024-1
<B>	Referring again	action	Fig	4024-1
the problem now	is	attribute	IB	4024-2
the problem now	Given	action	IB	4024-2
IB		sequential	IV	4024-2
IV	and	conjunctive	ν	4024-2
IV	update	action	ν	4024-2
ν	on	constraint	IV	4024-2
IV	22.1 find	action	an update	4024-2
an update		sequential	µ	4024-2
µ	so that	constraint	the diagram	4024-2
the diagram	commutes	action	<B>	4024-2
The first obvious problem here	is	attribute	the potential	4025-1
the potential	for	constraint	ambiguity	4025-1
Example		sequential	22.3.5	4026-1
22.3.5	Recall	action	the view V2	4026-1
the view V2	of	constraint	Example 22.3.1	4026-1
<B>	that	constraint	the base value	4026-2
<B>	Suppose	action	the base value	4026-2
the base value	of	constraint	R	4026-2
R	is	attribute	a b	4026-2
a b		sequential	}	4026-2
}	and	conjunctive	the base value	4026-2
the base value	of	constraint	S	4026-2
S	∅	sequential	<B>	4026-2
S	is	attribute	<B>	4026-2
the view	Thus holds	action	a }	4026-3
<B>	Now consider	action	an update ν	4026-4
an update ν	to	constraint	the view	4026-4
the view	that	constraint	inserts	4026-4
inserts	a′	action	<B>	4026-4
Some possible choices	for	constraint	µ	4026-5
µ	include	action	a Insert a′	4026-5
a Insert a′	into	constraint	R	4026-5
a Insert a′	b	action	R	4026-5
Possibility		sequential	d	4027-1
d	because	constraint	it	4027-1
d	seems	attribute	undesirable	4027-1
it	affects	action	a tuple	4027-1
a tuple	in	constraint	a base relation	4027-1
a base relation		sequential	that	4027-1
that	of	constraint	the view update	4027-1
that	is	attribute	independent	4027-1
that	intuitively speaking	attribute	independent	4027-1
Possibilities	than	constraint	c	4027-2
Possibilities	and	conjunctive	c	4027-2
Possibilities	a b seem	attribute	more appealing	4027-2
c	but	conjunctive	c	4027-2
c	can not be ruled out	action	<B>	4027-2
<B>	In	constraint	any case	4027-3
any case		sequential	it	4027-3
it	that	constraint	there	4027-3
it	is	attribute	clear	4027-3
there	are	attribute	a large number	4027-3
a large number	of	constraint	updates µ	4027-3
updates µ		sequential	that	4027-3
that	to	constraint	ν	4027-3
that	correspond	action	ν	4027-3
The fundamental problem	to	constraint	one update µ	4028-1
The fundamental problem	is	attribute	one update µ	4028-1
The fundamental problem	how select	action	one update µ	4028-1
one update µ	to	constraint	the base data	4028-1
the base data	that	constraint	many possibilities	4028-1
the base data	given	action	many possibilities	4028-1
many possibilities	may exist	action	<B>	4028-1
One approach	to	constraint	the ambiguity	4028-2
One approach	resolving	action	the ambiguity	4028-2
the ambiguity	involves	action	the intended semantics	4028-2
the ambiguity	examining	action	the intended semantics	4028-2
the intended semantics	of	constraint	the database	4028-2
the database	and	conjunctive	the view	4028-2
Dynamic Aspects Example 22.3.6	Consider	action	a schema Employee	4029-1
a schema Employee		sequential	Name	4029-1
Name		sequential	Department	4029-1
Department		sequential	Team_position	4029-1
Team_position		sequential	which	4029-1
which	records	action	an employee	4029-1
an employee		sequential	department	4029-1
department	and	conjunctive	the position	4029-1
the position		sequential	he	4029-1
he	or	conjunctive	she	4029-1
she	in	constraint	the corporate baseball league	4029-1
she	plays	action	the corporate baseball league	4029-1
It	that	constraint	Name	4029-2
It	is assumed	action	Name	4029-2
Name	is	attribute	a key	4029-2
The value	that	constraint	the employee	4029-3
The value	indicates	action	the employee	4029-3
the employee	in	constraint	the league	4029-3
the employee	does not play	action	the league	4029-3
It	that	constraint	Name	4029-4
It	is assumed	action	Name	4029-4
Name	is	attribute	a key	4029-4
<B>	Consider	action	the views	4029-5
the views	by	constraint	Sales Baseball	4029-5
the views	defined	action	Sales Baseball	4029-5
Sales Baseball		sequential	π Employee	4029-5
π Employee		sequential	Team	4029-5
Team	_	sequential	position	4029-5
position		sequential	σ Team position	4029-5
σ Team position	_	sequential	Employee	4029-5
σ Team position	=	sequential	Employee	4029-5
<B>	In	constraint	contrast	4029-6
contrast	if	constraint	tuple	4029-6
tuple		sequential	Joe	4029-6
Joe		sequential	shortstop	4029-6
shortstop	from	constraint	the Baseball view	4029-6
shortstop	is deleted	action	the Baseball view	4029-6
the Baseball view		sequential	it	4029-6
it	to	constraint	the underlying tuple	4029-6
it	is	attribute	typically most natural	4029-6
it	replace	action	the underlying tuple	4029-6
the underlying tuple		sequential	Joe	4029-6
Joe		sequential	d	4029-6
d		sequential	shortstop	4029-6
shortstop	in	constraint	Employee	4029-6
Employee	by	constraint	Joe	4029-6
Joe		sequential	d	4029-6
d	to	constraint	Joe	4029-6
d	remove	action	Joe	4029-6
Joe	from	constraint	the baseball league	4029-6
the baseball league	forcing	action	him	4029-6
him	out	constraint	the company	4029-6
him	of	constraint	the company	4029-6
Example		sequential	22.3.7	4030-1
<B>	that	constraint	the user	4031-1
<B>	Suppose	action	the user	4031-1
the user	that	constraint	a c	4031-1
the user	requests	action	a c	4031-1
a c	be deleted	action	<B>	4031-1
this deletion	into	constraint	one deletions	4031-2
this deletion	or	conjunctive	one deletions	4031-2
this deletion	Typically is mapped	attribute	more	4031-2
one deletions	against	constraint	the base data	4031-2
<B>	deleting	action	R	4031-3
R		sequential	20	4031-3
20	in	constraint	a side effect	4031-3
20	results	action	a side effect	4031-3
a side effect		sequential	the deletion	4031-3
the deletion	of	constraint	a c′	4031-3
a c′	from	constraint	the view	4031-3
Deletion	of	constraint	S	4031-4
S		sequential	20	4031-4
20		sequential	c	4031-4
c	also yields	action	a side effect	4031-4
Formal issues	surrounding	action	such side effects	4032-1
such side effects	of	constraint	view updates	4032-1
view updates	are	attribute	largely unexplored	4032-1
Complements	of	constraint	Views	4033-1
<B>	Although	constraint	it	4033-2
it	is	attribute	relatively narrow	4033-2
it	provides	action	an interesting perspective	4033-2
<B>	In	constraint	this framework	4034-1
this framework		sequential	a view	4034-1
a view	over	constraint	a base schema B	4034-1
a base schema B	to	constraint	a function	4034-1
a base schema B	is defined	attribute	total	4034-1
a base schema B	be	attribute	total	4034-1
a function		sequential	f	4034-1
f	from	constraint	Inst	4034-1
Inst		sequential	B	4034-1
B	into	constraint	some set	4034-1
<B>	In	constraint	practice	4034-2
practice		sequential	this set	4034-2
this set	is	attribute	typically Inst	4034-2
typically Inst		sequential	V	4034-2
V	for	constraint	some view schema V	4034-2
some view schema V	for	constraint	this development	4034-2
some view schema V	is not required	action	this development	4034-2
The proof	of	constraint	Theorem	4034-3
Theorem		sequential	22.3.10	4034-3
22.3.10		sequential	which	4034-3
which	presents	action	a completeness result	4034-3
a completeness result	uses	action	a view	4034-3
a view		sequential	whose range	4034-3
whose range	is	attribute	not Inst	4034-3
not Inst		sequential	V	4034-3
V	for	constraint	any schema V	4034-3
Two views f		sequential	g	4035-1
g	are	attribute	equivalent	4035-1
g	denoted	action	f	4035-1
f		sequential	g	4035-1
g	if	constraint	f	4035-1
f		sequential	≤ g	4035-1
≤ g	and	conjunctive	g	4035-1
g		sequential	≤	4035-1
≤		sequential	f	4035-1
<B>	is	attribute	an equivalence relation	4035-2
an equivalence relation	on	constraint	views	4035-2
<B>	In	constraint	the focus	4035-3
the focus	on	constraint	following primarily the equivalence classes	4035-3
the focus	is	attribute	following primarily the equivalence classes	4035-3
following primarily the equivalence classes	under	constraint	≡	4035-3
<B>	Let	action	⊤	4035-4
⊤	denote	action	the view	4035-4
the view	is	attribute	simply the identity	4035-4
simply the identity	and	conjunctive	⊥	4035-4
simply the identity	let	action	⊥	4035-4
⊥	denote	action	a view	4035-4
a view		sequential	that	4035-4
that	maps	action	every base instance	4035-4
every base instance	to	constraint	<B>	4035-4
every base instance	∅	sequential	<B>	4035-4
It	that	constraint	the equivalence classes	4035-5
It	is	attribute	clear	4035-5
the equivalence classes	by	constraint	<B>	4035-5
the equivalence classes	represented	action	<B>	4035-5
Example		sequential	22.3.8	4036-1
It	that	constraint	there	4037-1
It	turns out	action	there	4037-1
there	are	attribute	other complements	4037-1
other complements	of	constraint	f	4037-1
f	but	conjunctive	they	4037-1
they	can not be expressed	action	the relational algebra	4037-1
they	using	action	the relational algebra	4037-1
the relational algebra	see	action	Exercise 22.25	4037-1
g2	=	sequential	π Name	4038-1
π Name	_	sequential	pay	4038-1
pay		sequential	Employee	4038-1
Both g1	and	conjunctive	g2	4039-1
g2	are	attribute	complements	4039-1
complements	of	constraint	f	4039-1
each view	at	constraint	one complement	4040-1
each view	Thus has	attribute	least	4040-1
one complement	and	conjunctive	more than one minimal complement	4040-1
one complement	namely ⊤ may have	action	more than one minimal complement	4040-1
<B>	In	constraint	some cases	4041-1
some cases		sequential	complements	4041-1
complements	to	constraint	ambiguity	4041-1
complements	can be used	action	ambiguity	4041-1
complements	resolve	action	ambiguity	4041-1
ambiguity	in	constraint	the view update problem	4041-1
the view update problem	in	constraint	the following way	4041-1
<B>	Suppose	action	that view f	4041-2
that view f	has complement	action	g	4041-2
g	that	constraint	IV	4041-2
g	and	conjunctive	IV	4041-2
g	suppose	action	IV	4041-2
IV	=	sequential	f	4041-2
f		sequential	IB	4041-2
IB	and	conjunctive	update ν	4041-2
update ν	on	constraint	IV	4041-2
IV	are given	action	<B>	4041-2
An update µ	is	attribute	a g- translation	4041-3
a g- translation	of	constraint	ν	4041-3
ν	if	constraint	f	4041-3
f		sequential	µ	4041-3
µ		sequential	IB	4041-3
IB	=	sequential	ν	4041-3
ν		sequential	f	4041-3
f		sequential	IB	4041-3
IB	and	conjunctive	g	4041-3
g		sequential	µ	4041-3
µ		sequential	IB	4041-3
IB	=	sequential	g	4041-3
g		sequential	IB	4041-3
IB	see	action	Fig	4041-3
22.2		sequential	22.2	4041-4
<B>		sequential	a g- translation Dynamic Aspects v I B Figure 22.2	4041-5
a g- translation Dynamic Aspects v I B Figure 22.2		sequential	I′ B	4041-5
I′ B		sequential	Properties	4041-5
Properties	of	constraint	a g- translation µ	4041-5
a g- translation µ	of	constraint	view update ν	4041-5
view update ν	on	constraint	view f	4041-5
Example		sequential	22.3.9	4042-1
22.3.9	to	constraint	the view	4042-1
the view		sequential	there	4042-1
there	is	attribute	no g-translation	4042-1
no g-translation	of	constraint	ν	4042-1
µ1	is	attribute	Then the g1 translation	4043-1
Then the g1 translation	of	constraint	ν	4043-1
ν	and	conjunctive	µ 2	4043-1
µ 2	is	attribute	the g2 translation	4043-1
the g2 translation	of	constraint	ν	4043-1
we	Finally state	action	a result	4044-1
a result	that	constraint	a restricted class	4044-1
a result	showing	action	a restricted class	4044-1
a restricted class	of	constraint	view updates	4044-1
view updates	into	constraint	base updates	4044-1
view updates	can be translated	action	base updates	4044-1
base updates	using	action	complementary views	4044-1
<B>	To	constraint	this end	4044-2
this end		sequential	we	4044-2
we	on	constraint	updates	4044-2
we	focus	action	updates	4044-2
updates	of	constraint	a schema R	4044-2
a schema R		sequential	that	4044-2
that	are	attribute	total functions	4044-2
total functions	from	constraint	Inst	4044-2
Inst		sequential	R	4044-2
R	to	constraint	Inst	4044-2
Inst		sequential	R	4044-2
A family U	of	constraint	updates	4044-3
updates	on	constraint	R	4044-3
R	to	constraint	such that µ′	4044-3
R	if	constraint	such that µ′	4044-3
R	is said	attribute	complete	4044-3
R	be	attribute	complete	4044-3
such that µ′		sequential	µ	4044-3
µ		sequential	I	4044-3
I	=	sequential	I	4044-3
condition	that	constraint	a user	4045-1
condition	Intuitively b says	action	a user	4045-1
a user	can always undo	action	an update	4045-1
an update	just made	action	<B>	4045-1
It	to	constraint	complete sets	4045-2
It	on	constraint	complete sets	4045-2
It	is	attribute	certainly natural	4045-2
It	focus	action	complete sets	4045-2
complete sets	of	constraint	updates	4045-2
<B>	Let	action	schema B	4046-1
<B>	base	action	schema B	4046-1
schema B	f	constraint	Uf	4046-1
schema B	and	conjunctive	Uf	4046-1
schema B	and	conjunctive	Uf	4046-1
schema B	view	action	Uf	4046-1
schema B	be given	action	Uf	4046-1
schema B	let	action	Uf	4046-1
Uf	be	attribute	a family	4046-1
a family	of	constraint	updates	4046-1
updates	on	constraint	the view	4046-1
<B>	Let	action	UB	4046-2
UB	denote	action	the family	4046-2
the family	of	constraint	all updates	4046-2
all updates	on	constraint	the base schema	4046-2
A translator	for	constraint	Uf	4046-3
Uf	is	attribute	a mapping t Uf	4046-3
a mapping t Uf	→	sequential	UB	4046-3
UB	for	constraint	each base instance	4046-3
each base instance		sequential	IB	4046-3
IB	and	conjunctive	update ν ∈	4046-3
<B>	solving	action	the view update problem	4046-4
the view update problem	of	constraint	a translator	4046-4
the view update problem	with	constraint	a translator	4046-4
the view update problem	Clearly consists	action	a translator	4046-4
the view update problem	coming up	action	a translator	4046-4
<B>	If	constraint	g	4047-1
g	is	attribute	a complement	4047-1
a complement	for	constraint	f	4047-1
f		sequential	a translator t	4047-1
a translator t	is	attribute	a g- translator	4047-1
a g- translator	if	constraint	t	4047-1
t		sequential	ν	4047-1
ν	is	attribute	a g- translation	4047-1
a g- translation	of	constraint	ν	4047-1
ν	for	constraint	each ν ∈	4047-1
We	can now state	attribute	the	4048-1
We	following	action	Exercise 22.26	4048-1
We	see	action	Exercise 22.26	4048-1
Exercise 22.26		sequential	Theorem 22.3.10	4048-1
<B>	that	constraint	t	4048-2
<B>	Suppose	action	t	4048-2
t	is	attribute	a translator	4048-2
a translator	for	constraint	Uf	4048-2
there	Then is	action	a complement g	4048-3
a complement g	of	constraint	that	4048-3
a complement g	f	constraint	that	4048-3
that		sequential	t	4048-3
t	is	attribute	a g translator	4048-3
a g translator	for	constraint	Uf	4048-3
<B>	to	constraint	a translator	4049-1
<B>	find	action	a translator	4049-1
a translator	for	constraint	a complete set	4049-1
a complete set	of	constraint	view updates	4049-1
view updates		sequential	it	4049-1
it	to	constraint	an appropriate complementary view g	4049-1
it	is	attribute	Thus sufficient	4049-1
it	specify	action	an appropriate complementary view g	4049-1
an appropriate complementary view g	and	conjunctive	the corresponding g- translator	4049-1
an appropriate complementary view g	take	action	the corresponding g- translator	4049-1
The theorem	that	constraint	one	4049-2
The theorem	says	action	one	4049-2
one	can find	action	such g	4049-2
such g	if	constraint	a translator	4049-2
a translator	at	constraint	<B>	4049-2
a translator	exists	attribute	all	4049-2
The preceeding framework	provides	action	an abstract elegant perspective	4050-1
an abstract elegant perspective	on	constraint	the view update problem	4050-1
<B>	Forming	action	bridges	4050-2
bridges	to	constraint	the more concrete frameworks	4050-2
the more concrete frameworks	in	constraint	which	4050-2
which		sequential	views	4050-2
views	by	constraint	specific languages	4050-2
views	are defined	action	specific languages	4050-2
specific languages		sequential	relational algebra	4050-2
relational algebra	remains	attribute	largely unexplored	4050-2
<B>	Updating	action	Incomplete Information	4051-1
<B>	In	constraint	this section	4051-2
this section		sequential	we	4051-2
we	consider	action	more general settings	4051-2
more general settings	for	constraint	updates	4051-2
more general settings	studying	action	updates	4051-2
updates	and	conjunctive	incomplete information	4051-2
we	to	constraint	the conditional tables	4052-1
we	First return	action	the conditional tables	4052-1
the conditional tables	of	constraint	Chapter 19	4052-1
Chapter 19	and	conjunctive	a system	4052-1
Chapter 19	show	action	a system	4052-1
a system	for	constraint	such databases	4052-1
a system	updating	action	such databases	4052-1
We	introduce	action	formulations	4052-2
formulations	of	constraint	incomplete information	4052-2
incomplete information		sequential	that	4052-2
that	use	action	theories	4052-2
theories		sequential	sets	4052-2
sets	of	constraint	first order	4052-2
sets	or	conjunctive	first order	4052-2
first order		sequential	sentences	4052-2
sentences	to	constraint	the partial knowledge	4052-2
sentences	represent	action	the partial knowledge	4052-2
the partial knowledge	about	constraint	the world	4052-2
<B>	Among	constraint	other benefits	4052-3
other benefits		sequential	this approach	4052-3
this approach	offers	action	an interesting alternative	4052-3
an interesting alternative	to	constraint	the view update problem	4052-3
an interesting alternative	resolving	action	the view update problem	4052-3
This section	by	constraint	these approaches	4052-4
This section	concludes	action	these approaches	4052-4
This section	comparing	action	these approaches	4052-4
these approaches	to	constraint	belief revision	4052-4
<B>	Updating	action	Conditional Tables	4053-1
A representation T	specifies	action	a set	4053-2
a set	of	constraint	possible worlds rep	4053-2
possible worlds rep		sequential	T	4053-2
<B>	Given	action	an update u	4053-3
an update u		sequential	the possible outcomes	4053-3
the possible outcomes	of	constraint	the update	4053-3
the update	are	attribute	u	4053-3
u		sequential	rep	4053-3
rep		sequential	T	4053-3
T	=	sequential	u	4053-3
u		sequential	I	4053-3
I		sequential	I	4053-3
I		sequential	∈ rep	4053-3
∈ rep		sequential	T	4053-3
<B>	Let	action	us	4054-1
us	consider	action	c-tables	4054-1
c-tables	and	conjunctive	simple insertions	4054-1
simple insertions		sequential	deletions	4054-1
deletions	and	conjunctive	modifications	4054-1
modifications	as	constraint	the language	4054-1
modifications	in	constraint	the language	4054-1
the language	of	constraint	IDM transactions	4054-1
We	from	constraint	Chapter 19	4054-2
We	know	action	Chapter 19	4054-2
Chapter 19	that	constraint	c-tables	4054-2
c-tables	form	action	a strong representation system	4054-2
a strong representation system	for	constraint	relational algebra	4054-2
relational algebra	and	conjunctive	it	4054-2
it	that	constraint	IDM transactions	4054-2
it	is easily seen	action	IDM transactions	4054-2
IDM transactions	in	constraint	the algebra	4054-2
IDM transactions	can be expressed	action	the algebra	4054-2
the algebra	see	action	Exercise 22.3	4054-2
It	that	constraint	c-tables	4054-3
It	follows	action	c-tables	4054-3
c-tables	are	attribute	a strong representation system	4054-3
a strong representation system	for	constraint	IDM transactions	4054-3
<B>	In	constraint	other words	4054-4
other words	for	constraint	T	4054-4
T	and	conjunctive	IDM	4054-4
IDM		sequential	each c- table transaction t	4054-4
each c- table transaction t		sequential	there	4054-4
there	exists	action	a c- table t	4054-4
a c- table t		sequential	T	4054-4
T		sequential	such that rep	4054-4
such that rep		sequential	t	4054-4
t		sequential	T	4054-4
T	=	sequential	t	4054-4
t		sequential	rep	4054-4
rep		sequential	T	4054-4
Dynamic Aspects Example 22.4.1		sequential	Dynamic Aspects Example 22.4.1	4055-1
Insertions ins		sequential	t	4055-2
t	are	attribute	straightforward	4055-2
t	in	constraint	the table	4055-2
t	is simply inserted	action	the table	4055-2
<B>	Consider	action	the deletion d	4055-3
the deletion d		sequential	del	4055-3
del		sequential	Student	4055-3
Student		sequential	Sally	4055-3
Sally		sequential	Course	4055-3
Course	=	sequential	Physics	4055-3
Physics		sequential	}	4055-3
The c- table t		sequential	T	4055-4
T	representing	action	the result	4055-4
the result	of	constraint	the deletion	4055-4
the deletion	is	attribute	Student Course Sally Math Sally CS	4055-4
Student Course Sally Math Sally CS		sequential	Sally x Biology Math Physics	4055-4
Sally x Biology Math Physics	Consider again	action	the original c-table T	4055-4
the original c-table T	in	constraint	Example 19.3.1	4055-4
Example 19.3.1	and	conjunctive	the modification m	4055-4
the modification m	=	sequential	mod	4055-4
mod		sequential	Student	4055-4
Student	=	sequential	Sally	4055-4
Sally		sequential	Course	4055-4
Course	=	sequential	Music	4055-4
Music		sequential	}	4055-4
}	→	sequential	Course	4055-4
Course	=	sequential	Physics	4055-4
Physics		sequential	}	4055-4
The c-table m		sequential	T	4056-1
T	representing	action	the result	4056-1
the result	of	constraint	the modification	4056-1
the modification	is	attribute	Student Course Sally Math Sally CS Sally Physics Sally x Biology Math Physics	4056-1
<B>	For	constraint	c-tables	4056-2
c-tables		sequential	it	4056-2
it	to	constraint	updates	4056-2
it	seems	attribute	appropriate	4056-2
it	define	action	updates	4056-2
updates	with	constraint	the same kind	4056-2
the same kind	of	constraint	incomplete information	4056-2
incomplete information	using	action	tuples	4056-2
tuples	with	constraint	variables	4056-2
variables	to	constraint	conditions	4056-2
We	can define	action	extensions	4057-1
extensions	of	constraint	insertions	4057-1
insertions		sequential	deletions	4057-1
deletions	and	conjunctive	modifications	4057-1
modifications	in	constraint	this manner	4057-1
It	that	constraint	c-tables	4057-2
It	can be shown	action	c-tables	4057-2
c-tables	remain	action	a strong representation system	4057-2
a strong representation system	for	constraint	such updates	4057-2
<B>	Representing	action	Databases	4058-1
Databases	Using	action	Logical Theories Conditional tables	4058-1
Logical Theories Conditional tables	provide	action	a stylized restricted framework	4058-1
a stylized restricted framework	for	constraint	incomplete information	4058-1
a stylized restricted framework	representing	action	incomplete information	4058-1
incomplete information	under	constraint	a certain class	4058-1
incomplete information	and	conjunctive	a certain class	4058-1
incomplete information	are closed	action	a certain class	4058-1
a certain class	of	constraint	updates	4058-1
We	to	constraint	more general frameworks	4058-2
We	now turn	action	more general frameworks	4058-2
more general frameworks	for	constraint	incomplete information	4058-2
more general frameworks	and	conjunctive	incomplete information	4058-2
more general frameworks	representing	action	incomplete information	4058-2
more general frameworks	updating	action	incomplete information	4058-2
<B>	on	constraint	databases	4058-3
<B>	are based	action	databases	4058-3
<B>	representing	action	databases	4058-3
databases	as	constraint	logical theories	4058-3
<B>	Given	action	a logical theory	4059-1
a logical theory		sequential	T	4059-1
T	of	constraint	sentences	4059-1
T	set	action	sentences	4059-1
sentences		sequential	the set	4059-1
the set	of	constraint	models	4059-1
models	of	constraint	T	4059-1
T	by	constraint	Mod	4059-1
T	is denoted	action	Mod	4059-1
Mod		sequential	T	4059-1
<B>	In	constraint	our context	4059-2
our context		sequential	each model	4059-2
each model	to	constraint	a different possible instance	4059-2
each model	corresponds	action	a different possible instance	4059-2
<B>	If	constraint	<B>	4059-3
<B>	In	constraint	these approaches	4060-1
these approaches	use	action	the open world assumption	4060-1
the open world assumption		sequential	OWA	4060-1
<B>	from	constraint	Chapter 2	4060-2
<B>	Recall	action	Chapter 2	4060-2
Chapter 2	that	constraint	the closed world assumption	4060-2
Chapter 2	under	constraint	the closed world assumption	4060-2
the closed world assumption		sequential	CWA	4060-2
CWA		sequential	a fact	4060-2
a fact	as	constraint	it	4060-2
a fact	unless	constraint	it	4060-2
a fact	is viewed	attribute	false	4060-2
it	from	constraint	explicitly stated facts	4060-2
it	can be proved	action	explicitly stated facts	4060-2
explicitly stated facts	or	conjunctive	sentences	4060-2
<B>	In	constraint	contrast	4060-3
contrast	under	constraint	the OWA	4060-3
the OWA	if	constraint	a fact	4060-3
a fact	by	constraint	the underlying theory	4060-3
a fact	or	conjunctive	the underlying theory	4060-3
a fact	is not implied	action	the underlying theory	4060-3
a fact	contradicted	action	the underlying theory	4060-3
the underlying theory		sequential	the fact	4060-3
the fact	or	conjunctive	<B>	4060-3
the fact	be	attribute	may true	4060-3
Model	Based	action	Approaches	4061-1
Approaches	to	constraint	Updating Theories	4061-1
<B>	Given	action	an update	4061-2
an update		sequential	u	4061-2
u	and	conjunctive	instance	4061-2
instance		sequential	I	4061-2
I	let	action	u	4061-2
u		sequential	I	4061-2
I	denote	action	the set	4061-2
the set	of	constraint	possible instances	4061-2
possible instances		sequential	that	4061-2
that	from	constraint	u	4061-2
that	could result	action	u	4061-2
that	applying	action	u	4061-2
u	to	constraint	I	4061-2
We	use	action	a set	4061-3
a set	for	constraint	the result	4061-3
the result	to	constraint	the case	4061-3
the result	accommodate	action	the case	4061-3
the case	in	constraint	which	4061-3
which		sequential	u itself	4061-3
u itself	involves	action	incomplete information	4061-3
<B>	Now let	action	T	4062-1
T	be	attribute	a theory	4062-1
a theory	and	conjunctive	u	4062-1
u		sequential	an update	4062-1
<B>	Under	constraint	model	4062-2
model	based	action	the approach	4062-2
the approach		sequential	the result	4062-2
the result		sequential	u	4062-2
u		sequential	T	4062-2
T	of	constraint	u	4062-2
T	applying	action	u	4062-2
u	to	constraint	T	4062-2
T	be	attribute	should a theory	4062-2
should a theory	T′	constraint	Mod	4062-2
should a theory	that	constraint	Mod	4062-2
Mod		sequential	T′	4062-2
T′	=	sequential	∪	4062-2
∪		sequential	u	4062-2
u		sequential	I	4062-2
I		sequential	I	4062-2
I	∈	action	Mod	4062-2
Mod		sequential	T	4062-2
T		sequential	}	4062-2
Example		sequential	22.4.2	4063-1
22.4.2	updating	action	this model	4063-1
this model	yields	action	the single model	4063-1
the single model		sequential	q	4063-1
q		sequential	}	4063-1
Thus the result	of	constraint	applying	4063-2
the result	of	constraint	the update	4064-1
the result	applying	action	the update	4064-1
the update	to	constraint	T′	4064-1
T′	is	attribute	Thus ¬p }	4064-1
The approach	to	constraint	c-tables	4065-1
The approach	updating	action	c-tables	4065-1
c-tables	within	constraint	the paradigm	4065-1
c-tables	presented earlier	action	the paradigm	4065-1
c-tables	falls	action	the paradigm	4065-1
c-tables	model based	action	the paradigm	4065-1
the paradigm	see	action	Exercise 22.14	4065-1
A family	of	constraint	richer frameworks	4065-2
A family	model based	action	richer frameworks	4065-2
richer frameworks		sequential	that	4065-2
that	supports	action	null values	4065-2
null values	and	conjunctive	disjunctive updates	4065-2
disjunctive updates	has also been developed	action	<B>	4065-2
An interesting dimension	of	constraint	variation	4065-3
variation	in	constraint	this approach	4065-3
this approach	or	conjunctive	a given update semantics	4065-3
this approach	concerns	attribute	how permissive	4065-3
a given update semantics	is	attribute	<B>	4065-3
<B>	to	constraint	models	4066-1
<B>	essentially amounts	attribute	many	4066-1
<B>	considering	attribute	many	4066-1
models	with	constraint	u	4066-1
models	are associated	action	u	4066-1
u		sequential	I	4066-1
I	for	constraint	given update	4066-1
given update		sequential	u	4066-1
u	and	conjunctive	instance	4066-1
instance		sequential	I	4066-1
<B>	As	constraint	a simple example	4066-2
a simple example	with	constraint	an empty database I∅	4066-2
a simple example	consider	action	an empty database I∅	4066-2
a simple example	starting	action	an empty database I∅	4066-2
an empty database I∅	and	conjunctive	the update	4066-2
the update		sequential	insert	4066-2
insert		sequential	p ∨ q	4066-2
<B>	Under	constraint	a restrictive semantics	4066-3
a restrictive semantics		sequential	only p	4066-3
only p	and	conjunctive	q	4066-3
q		sequential	Dynamic Aspects	4066-3
Formula	Based	action	Approaches	4067-1
Approaches	to	constraint	Updating Theories	4067-1
We	consider	action	two forms	4068-1
two forms	of	constraint	update	4068-1
update		sequential	insert	4068-1
insert	and	conjunctive	ϕ	4068-1
insert	delete	action	ϕ	4068-1
ϕ	is	attribute	a sentence	4068-1
a sentence		sequential	no free variables	4068-1
<B>	Given	action	theory T	4068-2
theory T		sequential	a theory	4068-2
a theory		sequential	T′	4068-2
T′	accomplishes	action	the update	4068-2
the update	for	constraint	T	4068-2
the update	insert	action	T	4068-2
T	if	constraint	∈	4068-2
T	ϕ	sequential	∈	4068-2
<B>	that	constraint	there	4068-3
<B>	Observe	action	there	4068-3
there	is	attribute	a difference	4068-3
a difference	between	constraint	insert	4068-3
insert		sequential	¬ϕ	4068-3
¬ϕ	and	conjunctive	ϕ	4068-3
¬ϕ	delete	action	ϕ	4068-3
<B>	In	constraint	we	4069-1
we	in	constraint	an update	4069-1
we	are	attribute	interested	4069-1
we	accomplishing	action	an update	4069-1
an update	for	constraint	T	4069-1
T	with	constraint	minimal impact	4069-1
minimal impact	on	constraint	T	4069-1
we	in	constraint	theories	4070-1
we	are	attribute	Intuitively interested	4070-1
We	that	constraint	such theories	4070-2
We	say	action	such theories	4070-2
<B>	characterizes	action	such theories	4070-3
such theories	see	action	Exercise 22.15	4070-3
Exercise 22.15		sequential	Proposition 22.4.3	4070-3
Proposition 22.4.3	Let	action	T	4070-3
T		sequential	T′	4070-3
T′	be	attribute	theories	4070-3
theories	and	conjunctive	a sentence	4070-3
<B>		sequential	<B>	4070-4
<B>	with	constraint	<B>	4071-1
<B>	ϕ	sequential	<B>	4071-1
<B>	is	attribute	consistent	4071-1
T′	Thus accomplishes	action	ϕ	4072-1
T′	delete	action	ϕ	4072-1
ϕ	for	constraint	T	4072-1
T		sequential	minimally iff	4072-1
The following example	that	constraint	theories	4073-1
The following example	but	conjunctive	theories	4073-1
The following example	shows	attribute	equivalent	4073-1
theories	by	constraint	updates	4073-1
theories	can be affected differently	action	updates	4073-1
Example		sequential	22.4.4	4074-1
It	that	constraint	Mod	4075-1
It	is easily verified	action	Mod	4075-1
Mod		sequential	Ti	4075-1
Ti		sequential	i	4075-1
i		sequential	∈	4075-1
∈		sequential	1	4075-1
1		sequential	n	4075-1
n		sequential	}	4075-1
}	=	sequential	∪	4075-1
∪		sequential	Mod	4075-1
Mod		sequential	Ti	4075-1
Ti		sequential	i	4075-1
i		sequential	∈	4075-1
∈		sequential	1	4075-1
1	n	conjunctive	<B>	4075-1
there	Of course is	action	a great likelihood	4075-2
a great likelihood	of	constraint	a combinatorial explosion	4075-2
a combinatorial explosion	if	constraint	the disjunction operator	4075-2
the disjunction operator	is applied repeatedly	action	<B>	4075-2
We	now explore	action	a mechanism	4076-1
a mechanism	for	constraint	priority	4076-1
a mechanism	giving	action	priority	4076-1
priority	to	constraint	some sentences	4076-1
some sentences	in	constraint	a theory	4076-1
a theory	over	constraint	other sentences	4076-1
<B>	Let	action	n	4076-2
n		sequential	≥ 0	4076-2
≥ 0	be fixed	action	<B>	4076-2
A tagged sentence	is	attribute	a pair	4076-3
a pair		sequential	i	4076-3
i		sequential	i	4076-3
i	where ∈	action	0	4076-3
0	n	conjunctive	ϕ a sentence	4076-3
0	and	conjunctive	ϕ a sentence	4076-3
0	is	attribute	ϕ a sentence	4076-3
A tagged theory	is	attribute	a set	4076-4
a set	of	constraint	tagged sentences	4076-4
<B>	Given	action	tagged theory T	4076-5
tagged theory T	and	conjunctive	i ∈	4076-5
i ∈		sequential	1	4076-5
1		sequential	n	4076-5
n		sequential	Ti	4076-5
Ti	denotes	action	ϕ	4076-5
ϕ		sequential	i ∈ T	4076-5
The partial order	for	constraint	theories	4077-1
The partial order	comparing	action	theories	4077-1
theories	in	constraint	the following natural fashion	4077-1
theories	is extended	action	the following natural fashion	4077-1
<B>	Given	action	tagged theories T	4078-1
tagged theories T		sequential	T′	4078-1
T′	and	conjunctive	T′′	4078-1
T′′	define	action	T′ ≤T T′′	4078-1
T′ ≤T T′′	if	constraint	i	4078-1
T′ ≤T T′′	for	constraint	i	4078-1
i		sequential	∈	4078-1
∈		sequential	1	4078-1
1	n	conjunctive	we	4078-1
we	have	action	Tj	4078-1
Intuitively T′		sequential	Intuitively T′	4079-1
<B>	In	constraint	this manner	4079-2
this manner		sequential	higher priority	4079-2
higher priority	to	constraint	the sentences	4079-2
higher priority	is given	action	the sentences	4079-2
the sentences	having	action	lower numbers	4079-2
Dynamic Aspects Example 22.4.5	Consider	action	a relation	4080-1
a relation		sequential	R	4080-1
R		sequential	ABC	4080-1
ABC		sequential	that	4080-1
that	satisfies	action	the functional dependency	4080-1
the functional dependency	→	sequential	A B	4080-1
A B	and	conjunctive	the instance R B C b c b c′ b′ c′′ b′ c′′	4080-1
A B	consider	action	the instance R B C b c b c′ b′ c′′ b′ c′′	4080-1
We	assume	action	three tag values	4081-1
three tag values	and	conjunctive	the contents	4081-1
three tag values	describe	action	the contents	4081-1
the contents	of	constraint	T0	4081-1
T0		sequential	T1	4081-1
T1	and	conjunctive	T2	4081-1
T2	in	constraint	turn	4081-1
T0	holds	action	the functional dependency	4081-2
the functional dependency	and	conjunctive	the unique name axiom	4081-2
the unique name axiom	see	action	Chapter 2	4081-2
<B>	is	attribute	0	4081-3
0		sequential	∀x	4081-3
∀x		sequential	y	4081-3
y		sequential	z	4081-3
z		sequential	z′	4081-3
z′		sequential	R	4081-3
R		sequential	x	4081-3
x		sequential	y	4081-3
y		sequential	z	4081-3
z	∧	sequential	R	4081-3
R		sequential	x	4081-3
x		sequential	y′	4081-3
y′		sequential	z′	4081-3
z′	→	sequential	y	4081-3
y	=	sequential	y′	4081-3
y′		sequential	T2	4081-3
T2	holds	action	the update	4081-3
T2	Consider now	action	the update	4081-3
the update		sequential	u	4081-3
u	=	sequential	insert	4081-3
insert		sequential	ϕ	4081-3
ϕ	=	sequential	∃yR	4081-3
∃yR		sequential	b′′	4081-3
b′′		sequential	y	4081-3
this insertion	Intuitively should replace	action	all a b pairs	4081-4
all a b pairs	in	constraint	πABR	4081-4
all a b pairs	occurring	action	πABR	4081-4
πABR	by	constraint	a b′′	4081-4
it	to	constraint	the unique tagged theory	4081-5
it	that	constraint	the unique tagged theory	4081-5
it	is	attribute	More formally easy	4081-5
it	verify	action	the unique tagged theory	4081-5
the unique tagged theory	up to	constraint	choice	4081-5
choice	of	constraint	i	4081-5
i		sequential	that	4081-5
that	accomplishes	action	u	4081-5
u	is	attribute	Exercise 22.17	4081-5
u	see	action	Exercise 22.17	4081-5
The approach	of	constraint	tagged theories	4082-1
tagged theories	to	constraint	a framework	4082-1
tagged theories	can also be used	action	a framework	4082-1
tagged theories	develop	action	a framework	4082-1
a framework	for	constraint	view updates	4082-1
a framework	accomplishing	action	view updates	4082-1
The underlying database	and	conjunctive	the view	4082-2
the view	are represented	action	a tagged theory	4082-2
the view	using	action	a tagged theory	4082-2
a tagged theory	and	conjunctive	highest priority	4082-2
highest priority	to	constraint	the complement	4082-2
highest priority	that	constraint	the complement	4082-2
highest priority	is given	action	the complement	4082-2
highest priority	ensuring	action	the complement	4082-2
the complement	of	constraint	the view	4082-2
the view	remains	action	<B>	4082-2
the view	fixed	action	<B>	4082-2
Exercise 22.18	explores	action	a simple example	4082-3
a simple example	of	constraint	this approach	4082-3
<B>	In	constraint	the approach	4083-1
the approach	described here	action	a set	4083-1
a set	of	constraint	theories	4083-1
theories	is combined	action	the disjunction operator	4083-1
theories	using	action	the disjunction operator	4083-1
<B>	In	constraint	this case	4083-2
this case		sequential	multiple deletions	4083-2
multiple deletions	to	constraint	an exponential blowup	4083-2
multiple deletions	can lead	action	an exponential blowup	4083-2
an exponential blowup	in	constraint	the size	4083-2
the size	of	constraint	the underlying theory	4083-2
the underlying theory	and	conjunctive	insertions	4083-2
the underlying theory	performing	action	insertions	4083-2
insertions	is	attribute	np- hard	4083-2
insertions	see	action	Exercise 22.19	4083-2
<B>	provided	action	one motivation	4083-3
one motivation	for	constraint	a generalization	4083-3
one motivation	developing	action	a generalization	4083-3
a generalization	of	constraint	the approach	4083-3
the approach	in	constraint	which	4083-3
which		sequential	families	4083-3
families	of	constraint	theories	4083-3
theories	called	action	flocks	4083-3
flocks	to	constraint	a database	4083-3
flocks	are used	action	a database	4083-3
flocks	represent	action	a database	4083-3
a database	with	constraint	incomplete information	4083-3
Update	versus	constraint	Revision	4084-1
The field	of	constraint	belief revision	4085-1
belief revision	takes	action	this approach	4085-1
this approach	and	conjunctive	the issue	4085-1
this approach	considers	action	the issue	4085-1
the issue	of	constraint	a knowledge base	4085-1
the issue	revising	action	a knowledge base	4085-1
we	Here briefly compare	action	the approaches	4085-2
the approaches	to	constraint	database theories	4085-2
the approaches	updating	action	database theories	4085-2
database theories	with	constraint	belief revision	4085-2
database theories	in	constraint	belief revision	4085-2
database theories	described earlier	attribute	those	4085-2
database theories	found	action	belief revision	4085-2
It	from	constraint	postulate	4086-1
It	is	attribute	clear	4086-1
postulate		sequential	R3	4086-1
R3	that	constraint	the approaches	4086-1
R3	formula based	action	the approaches	4086-1
the approaches	to	constraint	database theories	4086-1
the approaches	updating	action	database theories	4086-1
database theories	as	constraint	belief revision systems	4086-1
database theories	do not qualify	action	belief revision systems	4086-1
The relationship	of	constraint	the approaches	4086-2
The relationship	formula based	action	the approaches	4086-2
the approaches	and	conjunctive	belief revision	4086-2
belief revision	is	attribute	largely unexplored	4086-2
<B>	If	constraint	a new fact	4087-1
a new fact	to	constraint	a modification	4087-1
a new fact	ϕ	sequential	a modification	4087-1
a new fact	is	attribute	this	4087-1
a new fact	be inserted	attribute	this	4087-1
a new fact	is	attribute	a modification	4087-1
a modification	and	conjunctive	it	4087-1
it	is hoped	action	improvement	4087-1
improvement	of	constraint	our knowledge	4087-1
our knowledge	about	constraint	the state	4087-1
the state	of	constraint	the world	4087-1
the world	but	conjunctive	the world itself	4087-1
the world itself	to	constraint	<B>	4087-1
the world itself	is considered	attribute	unchanged	4087-1
the world itself	remain	attribute	unchanged	4087-1
<B>	In	constraint	contrast	4087-2
contrast	in	constraint	the approaches	4087-2
contrast	model based	action	the approaches	4087-2
the approaches		sequential	the theory T	4087-2
the theory T	to	constraint	a set	4087-2
the theory T	is used	action	a set	4087-2
the theory T	identify	action	a set	4087-2
a set	of	constraint	worlds	4087-2
worlds		sequential	that	4087-2
that	are	attribute	possible	4087-2
that	given	action	the limited information currently available	4087-2
<B>	If	constraint	a fact	4087-3
a fact	to	constraint	the world itself	4087-3
a fact	that	constraint	the world itself	4087-3
a fact	is inserted	attribute	this	4087-3
a fact	is understood	action	the world itself	4087-3
a fact	mean	action	the world itself	4087-3
the world itself	has been modified	action	<B>	4087-3
T	to	constraint	a different set	4087-4
T	Thus is modified	action	a different set	4087-4
T	identify	action	a different set	4087-4
a different set	of	constraint	possible worlds	4087-4
Example		sequential	22.4.6	4088-1
There	is	attribute	an abacus	4088-2
an abacus	and	conjunctive	a calculator	4088-2
an abacus	hand held	attribute	electronic	4088-2
a calculator	in	constraint	the room	4088-2
<B>	Let	action	proposition	4088-3
proposition		sequential	a mean	4088-3
a mean		sequential	that	4088-3
that		sequential	Dynamic Aspects	4088-3
Dynamic Aspects		sequential	the abacus	4088-3
the abacus	on	constraint	the table	4088-3
the abacus	is	attribute	the table	4088-3
the table	and	conjunctive	proposition	4088-3
the table	let	action	proposition	4088-3
proposition		sequential	c	4088-3
c	that	constraint	the calculator	4088-3
c	mean	action	the calculator	4088-3
the calculator	on	constraint	the table	4088-3
the calculator	is	attribute	the table	4088-3
<B>	Finally let	action	T	4089-1
T	be	attribute	a ∧ ¬c	4089-1
a ∧ ¬c		sequential	∨	4089-1
∨		sequential	¬a	4089-1
¬a		sequential	∧ c	4089-1
<B>	From	constraint	the perspective	4090-1
the perspective	of	constraint	belief revision	4090-1
belief revision		sequential	T	4090-1
T	that	constraint	our current knowledge	4090-1
T	indicates	action	our current knowledge	4090-1
T	according to	action	our current knowledge	4090-1
our current knowledge	either	conjunctive	the abacus	4090-1
the abacus	or	conjunctive	the calculator	4090-1
the calculator	on	constraint	the table	4090-1
the calculator	is	attribute	the table	4090-1
the table	but	conjunctive	<B>	4090-1
<B>	that	constraint	we	4090-2
<B>	Suppose	action	we	4090-2
we	that	constraint	the calculator	4090-2
we	are informed	action	the calculator	4090-2
the calculator	on	constraint	the table	4090-2
the calculator	is	attribute	the table	4090-2
the table		sequential	insert	4090-2
insert		sequential	c	4090-2
<B>	as	constraint	additional knowledge	4090-3
<B>	is viewed	action	additional knowledge	4090-3
additional knowledge	about	constraint	the unchanging world	4090-3
<B>	Combining	action	T	4090-4
T	with	constraint	c	4090-4
c		sequential	we	4090-4
we	obtain	action	the new theory	4090-4
the new theory		sequential	T1	4090-4
T1	=	sequential	a ∧ ¬c	4090-4
a ∧ ¬c		sequential	∨	4090-4
∨		sequential	¬a	4090-4
¬a		sequential	∧ c	4090-4
∧ c		sequential	∧	4090-4
∧		sequential	c ≡	4090-4
c ≡		sequential	¬a	4090-4
¬a		sequential	∧	4090-4
∧		sequential	c	4090-4
<B>	that	constraint	this outcome	4090-5
<B>	Note	action	this outcome	4090-5
this outcome	by	constraint	postulate	4090-5
this outcome	is required	action	postulate	4090-5
postulate		sequential	R2	4090-5
<B>	From	constraint	the perspective	4090-6
<B>	model based	action	the perspective	4090-6
the perspective		sequential	T	4090-6
T	that	constraint	the world	4090-6
T	either	conjunctive	the world	4090-6
T	indicates	action	the world	4090-6
the world	is	attribute	a }	4090-6
a }	or	conjunctive	it	4090-6
it	is	attribute	c }	4090-6
The request		sequential	insert c	4091-1
insert c	to	constraint	the world	4091-1
insert c	that	constraint	the world	4091-1
insert c	is understood	action	the world	4091-1
insert c	mean	action	the world	4091-1
the world	so that	constraint	c	4091-1
the world	has been modified	action	c	4091-1
c	has become	attribute	true	4091-1
<B>	in	constraint	terms	4091-2
<B>	can be envisioned	action	terms	4091-2
terms	of	constraint	a robot	4091-2
terms	having	action	a robot	4091-2
a robot	enter	action	the room	4091-2
the room	and	conjunctive	the calculator	4091-2
the room	place	action	the calculator	4091-2
the calculator	on	constraint	the table	4091-2
the table	if	constraint	it	4091-2
it	isn	attribute	’	4091-2
t already there	without	constraint	the status	4091-2
t already there	on	constraint	the status	4091-2
t already there	reporting	action	the status	4091-2
the status	of	constraint	anything	4091-2
anything	except	constraint	the robot	4091-2
anything	that	constraint	the robot	4091-2
the robot	been	attribute	has successful	4091-2
<B>	As	constraint	a result	4091-3
a result		sequential	the world a }	4091-3
the world a }	by	constraint	a c	4091-3
the world a }	is replaced	action	a c	4091-3
a c	and	conjunctive	the world	4091-3
the world		sequential	c	4091-3
c	by	constraint	itself	4091-3
c	is replaced	action	itself	4091-3
The resulting theory	is	attribute	T2	4091-4
T2	=	sequential	c	4091-4
c		sequential	which	4091-4
which	under	constraint	the OWA	4091-4
which	is interpreted	action	the OWA	4091-4
<B>	than	constraint	R2	4092-1
<B>	is	attribute	strictly weaker	4092-1
Other postulates	enforce	action	the intuition	4092-2
the intuition		sequential	that	4092-2
that		sequential	the effect	4092-2
the effect	of	constraint	an update	4092-2
an update	on	constraint	a possible model	4092-2
a possible model	of	constraint	the other possible models	4092-2
a possible model	is	attribute	independent	4092-2
the other possible models	of	constraint	a theory	4092-2
a theory	maintaining	action	satisfiability	4092-2
satisfiability	and	conjunctive	relationships	4092-2
relationships	between	constraint	the effects	4092-2
the effects	of	constraint	different updates	4092-2
Suppliers Sname Prices Part Sname Price		sequential	Suppliers Sname Prices Part Sname Price	4093-1
Rules	and	conjunctive	Rule Application	4094-1
Rules	typically have	action	the following ECA form	4095-1
Rules	so called	action	the following ECA form	4095-1
the following ECA form	on	constraint	event	4095-1
event	if	constraint	condition action	4095-1
<B>	Depending on	action	the system	4096-1
the system	and	conjunctive	application	4096-1
application		sequential	the event	4096-1
the event	over	constraint	external phenomena	4096-1
the event	may range	action	external phenomena	4096-1
external phenomena	over	constraint	internal events	4096-1
external phenomena	and	conjunctive	internal events	4096-1
external phenomena	or	conjunctive	internal events	4096-1
internal events		sequential	a method call	4096-1
a method call	or	conjunctive	a tuple	4096-1
a method call	inserting	action	a tuple	4096-1
a tuple	to	constraint	a relation	4096-1
Events	from	constraint	atomic events	4096-2
Events	or	conjunctive	atomic events	4096-2
Events	be	attribute	may atomic	4096-2
Events	where are built up	action	atomic events	4096-2
atomic events	using	action	regular expressions	4096-2
atomic events	say	action	regular expressions	4096-2
regular expressions	or	conjunctive	a process algebra	4096-2
Events	be	attribute	may essentially Boolean	4096-3
may essentially Boolean	or	conjunctive	a tuple	4096-3
may essentially Boolean	may return	action	a tuple	4096-3
a tuple	of	constraint	values	4096-3
values		sequential	that	4096-3
that	indicate	action	what	4096-3
what	triggered	action	the event	4096-3
Conditions	typically involve	action	parameters	4097-1
parameters	by	constraint	the events	4097-1
parameters	passed in	action	the events	4097-1
the events	and	conjunctive	the contents	4097-1
the contents	of	constraint	the database	4097-1
<B>	As	constraint	several systems	4097-2
<B>	will be described shortly	action	several systems	4097-2
several systems	permit	action	conditions	4097-2
conditions	to	constraint	more than one version	4097-2
conditions	at	constraint	more than one version	4097-2
conditions	look	action	more than one version	4097-2
more than one version	of	constraint	the database state	4097-2
the database state	to	constraint	the state	4097-2
the database state	e.g. corresponding	action	the state	4097-2
the state	before	constraint	the event	4097-2
the event	and	conjunctive	the state	4097-2
the state	after	constraint	the event	4097-2
<B>	In	constraint	some systems	4097-3
some systems		sequential	events	4097-3
events	are not explicitly specified	action	any change	4097-3
any change	to	constraint	the database	4097-3
the database	essentially makes	action	the event	4097-3
the event	to	constraint	testing	4097-3
the event	and	conjunctive	testing	4097-3
the event	leads	action	testing	4097-3
testing	of	constraint	all rule conditions	4097-3
<B>	In	constraint	principle	4098-1
principle		sequential	the action	4098-1
the action	be	attribute	may a call	4098-1
may a call	to	constraint	an arbitrary routine	4098-1
<B>	In	constraint	many cases	4098-2
many cases	in	constraint	relational systems	4098-2
relational systems		sequential	the action	4098-2
the action	will involve	action	a sequence	4098-2
a sequence	of	constraint	insertions	4098-2
insertions		sequential	deletions	4098-2
deletions	and	conjunctive	modifications	4098-2
modifications	in	constraint	object	4098-2
modifications	and	conjunctive	object	4098-2
object	oriented	action	systems	4098-2
systems		sequential	it	4098-2
it	or	conjunctive	one method calls	4098-2
it	will involve	attribute	more	4098-2
<B>	that	constraint	turn	4098-3
<B>	in	constraint	turn	4098-3
<B>	Note	attribute	this	4098-3
turn	may trigger	action	other rules	4098-3
The remainder	of	constraint	this discussion	4099-1
this discussion	on	constraint	the relational model	4099-1
this discussion	focuses	action	the relational model	4099-1
A short example	by	constraint	a brief discussion	4099-2
A short example	is given	action	a brief discussion	4099-2
A short example	followed	action	a brief discussion	4099-2
a brief discussion	of	constraint	execution models	4099-2
Example		sequential	22.5.1	4100-1
It	that	constraint	Sname	4100-2
It	is assumed	action	Sname	4100-2
Sname	is	attribute	a key	4100-2
a key	of	constraint	Suppliers	4100-2
Suppliers	and	conjunctive	Part	4100-2
Part		sequential	Sname	4100-2
Sname	is	attribute	a key	4100-2
a key	of	constraint	Prices	4100-2
An example instance	in	constraint	Fig	4100-3
An example instance	is shown	action	Fig	4100-3
22.3		sequential	22.3	4100-4
We	now list	action	some example rules	4101-1
These rules	in	constraint	a pidgin language	4101-2
These rules	are written	action	a pidgin language	4101-2
a pidgin language		sequential	that	4101-2
that	uses	action	tuple variables	4101-2
The variable T	over	constraint	sets	4101-3
The variable T	ranges	action	sets	4101-3
sets	of	constraint	tuples	4101-3
tuples	to	constraint	them	4101-3
tuples	and	conjunctive	them	4101-3
tuples	is used	action	them	4101-3
tuples	pass	action	them	4101-3
them	from	constraint	the condition	4101-3
the condition	to	constraint	the action	4101-3
<B>	As	constraint	r1	4101-4
r1	in	constraint	isolation	4101-4
r1	considered	action	isolation	4101-4
isolation	and	conjunctive	the set	4101-4
the set		sequential	r2.a	4101-4
<B>	.	sequential	<B>	4101-5
<B>	.	sequential	<B>	4101-6
r2.d	to	constraint	the inclusion dependency Prices	4101-7
r2.d	taken together	action	the inclusion dependency Prices	4101-7
r2.d	can be used	action	the inclusion dependency Prices	4101-7
r2.d	enforce	action	the inclusion dependency Prices	4101-7
the inclusion dependency Prices		sequential	Sname	4101-7
Sname		sequential	⊆ Suppliers	4101-7
⊆ Suppliers		sequential	Sname	4101-7
<B>	on	constraint	Prices	4102-1
<B>	if	constraint	Prices	4102-1
Prices		sequential	p	4102-1
p	and	conjunctive	p. Sname ∈ π Sname	4102-1
p. Sname ∈ π Sname		sequential	Suppliers	4102-1
Suppliers		sequential	Prices	4102-1
Prices	=	sequential	Prices	4102-1
Prices	−	sequential	p }	4102-1
Prices	{	sequential	p }	4102-1
p }	on	constraint	delete Sname s	4102-1
delete Sname s	if	constraint	T	4102-1
T	=	sequential	σ Sname= s. Sname	4102-1
σ Sname= s. Sname		sequential	Prices	4102-1
Prices	is	attribute	not empty Prices	4102-1
not empty Prices	=	sequential	Prices	4102-1
Prices		sequential	T	4102-1
T	on	constraint	Sname s	4102-1
T	modify	action	Sname s	4102-1
Sname s	if	constraint	<B>	4102-1
Sname	=	sequential	<B>	4102-2
Sname	and	conjunctive	T	4102-3
T	=	sequential	σ	4102-3
σ		sequential	<B>	4102-3
Sname		sequential	Prices	4102-4
Prices		sequential	set	4102-4
set		sequential	p.	4102-4
p.		sequential	Sname	4102-4
Sname	=	sequential	<B>	4102-4
<B>	for	constraint	each p	4102-5
<B>	Sname	action	each p	4102-5
each p	in	constraint	Prices	4102-5
Prices		sequential	where p ∈ T	4102-5
where p ∈ T	on	constraint	insert Prices	4102-5
insert Prices		sequential	p	4102-5
p	if	constraint	Sname ∈ π Sname	4102-5
Sname ∈ π Sname		sequential	Suppliers	4102-5
Suppliers		sequential	p. issue supplier_warning	4102-5
p. issue supplier_warning		sequential	p	4102-5
p	on	constraint	Prices	4102-5
p	modify	action	Prices	4102-5
Prices		sequential	p	4102-5
p	if	constraint	p	4102-5
Sname ∈ π Sname		sequential	Suppliers	4102-6
Suppliers		sequential	issue supplier_warning	4102-6
issue supplier_warning		sequential	p	4102-6
<B>	If	constraint	a state	4102-7
a state	ever arises	action	that	4102-7
that	violates	action	the inclusion dependency	4102-7
the inclusion dependency		sequential	the rule	4102-7
the rule	deletes	action	tuples	4102-7
the rule	violating	action	tuples	4102-7
tuples	from	constraint	the Prices relation	4102-7
The event	of	constraint	r1	4102-8
r1	in	constraint	principle	4102-8
r1	is	attribute	always true	4102-8
principle		sequential	the database	4102-8
the database	must check	action	the condition	4102-8
the condition		sequential	an update	4102-8
an update	whenever is made	action	<B>	4102-8
It	to	constraint	this case	4102-9
It	in	constraint	this case	4102-9
It	is	attribute	easy	4102-9
It	see	action	this case	4102-9
this case	that	constraint	such checking	4102-9
such checking	if	constraint	the relations Supplies	4102-9
such checking	need only be done	action	the relations Supplies	4102-9
the relations Supplies	or	conjunctive	Prices	4102-9
Prices	and	conjunctive	the event	4102-9
Prices	are updated	action	the event	4102-9
the event	on	constraint	Supplies	4102-9
Supplies	or	conjunctive	Prices	4102-9
Prices	into	constraint	r	4102-9
Prices	is updated	action	r	4102-9
Prices	so could be incorporated	action	r	4102-9
r		sequential	1	4102-9
<B>	Although	constraint	the effect	4102-10
<B>	does not change	action	the effect	4102-10
the effect	of	constraint	the rule	4102-10
the rule		sequential	it	4102-10
it	provides	action	a hint	4102-10
a hint	to	constraint	the system	4102-10
the system	about	constraint	it	4102-10
the system	to	constraint	it	4102-10
the system	how implement efficiently	action	it	4102-10
Rules		sequential	r2.a	4103-1
<B>	.	sequential	<B>	4103-2
<B>	.	sequential	<B>	4103-3
r2.d	form	action	an alternative mechanism	4103-4
an alternative mechanism	for	constraint	the inclusion dependency	4103-4
an alternative mechanism	enforcing	action	the inclusion dependency	4103-4
<B>	In	constraint	this case	4103-5
this case		sequential	the cause	4103-5
the cause	of	constraint	the dependency violation	4103-5
the dependency violation	determines	action	the reaction	4103-5
the reaction	of	constraint	the system	4103-5
a deletion	from	constraint	r2.a	4103-6
r2.a	or	conjunctive	modification	4103-6
modification		sequential	r2.b	4103-6
r2.b	to	constraint	Suppliers	4103-6
Suppliers	in	constraint	deletions	4103-6
Suppliers	Here will result	action	deletions	4103-6
deletions	from	constraint	modifications	4103-6
deletions	or	conjunctive	modifications	4103-6
modifications	to	constraint	Prices	4103-6
<B>	In	constraint	r2.b	4103-7
r2.b	over	constraint	tuples	4103-7
r2.b	ranges	action	tuples	4103-7
tuples		sequential	that	4103-7
that	to	constraint	the original value	4103-7
that	have been modified	attribute	old s	4103-7
that	refers	action	the original value	4103-7
the original value	of	constraint	the tuple	4103-7
the tuple	to	constraint	the modified value	4103-7
the tuple	and	conjunctive	the modified value	4103-7
the tuple	refers	action	the modified value	4103-7
<B>	On	constraint	the other hand	4103-8
the other hand		sequential	changes	4103-8
changes	to	constraint	Prices	4103-8
Prices		sequential	that	4103-8
that	cause	action	a violation	4103-8
a violation		sequential	rules	4103-8
rules		sequential	r2.c	4103-8
r2.c	and	conjunctive	<B>	4103-8
Execution Models	Until	constraint	we	4104-1
we	have considered	action	rules	4104-1
rules	in	constraint	essentially isolation	4104-1
essentially isolation	from	constraint	<B>	4104-1
A fundamental issue	concerns	action	the choice	4104-2
the choice	of	constraint	an execution model	4104-2
an execution model		sequential	which	4104-2
which	and	conjunctive	rules	4104-2
which	specifies	action	rules	4104-2
rules	will be applied	action	<B>	4104-2
<B>	As	constraint	a wide variety	4104-3
<B>	will be seen	action	a wide variety	4104-3
a wide variety	of	constraint	execution models	4104-3
execution models	are	attribute	possible	4104-3
The true semantics	of	constraint	a rule base	4104-4
a rule base	from	constraint	the rules themselves	4104-4
a rule base	both	conjunctive	the rules themselves	4104-4
a rule base	stems	action	the rules themselves	4104-4
the rules themselves	from	constraint	the execution model	4104-4
the rules themselves	and	conjunctive	the execution model	4104-4
the execution model	for	constraint	them	4104-4
the execution model	applying	action	them	4104-4
We	for	constraint	this discussion	4105-1
We	assume	action	this discussion	4105-1
this discussion	that	constraint	there	4105-1
there	is	attribute	only one user	4105-1
only one user	of	constraint	the system	4105-1
the system	that	constraint	a concurrency control protocol	4105-1
the system	or	conjunctive	a concurrency control protocol	4105-1
a concurrency control protocol	is enforced	action	that	4105-1
that	hides	action	the effect	4105-1
the effect	of	constraint	other users	4105-1
<B>	that	constraint	a user transaction t	4106-1
<B>	Suppose	action	a user transaction t	4106-1
a user transaction t	=	sequential	c1	4106-1
<B>	.	sequential	<B>	4106-2
<B>	.	sequential	<B>	4106-3
cn	of	constraint	the ci	4106-4
cn	is issued	attribute	each	4106-4
the ci	is	attribute	where an atomic command	4106-4
<B>	In	constraint	the absence	4106-5
the absence	of	constraint	active database rules	4106-5
active database rules		sequential	application	4106-5
application	of	constraint	t	4106-5
t	will yield	action	a sequence	4106-5
a sequence		sequential	I0 I1	4106-5
<B>	.	sequential	<B>	4106-6
<B>	.	sequential	<B>	4106-7
<B>	In	constraint	database states	4106-8
<B>	of	constraint	database states	4106-8
database states	with	constraint	the original state I0	4106-8
database states	starting	action	the original state I0	4106-8
the original state I0	and	conjunctive	each state Ii+1	4106-8
each state Ii+1	is	attribute	where the result	4106-8
where the result	of	constraint	ci+1	4106-8
where the result	applying	action	ci+1	4106-8
ci+1	to	constraint	state Ii	4106-8
<B>	If	constraint	rules	4106-9
rules	are	attribute	present	4106-9
a different sequence	of	constraint	states	4106-9
states	might arise	action	<B>	4106-9
One dimension	of	constraint	variation	4107-1
variation	between	constraint	execution models	4107-1
execution models	concerns	action	rules	4107-1
rules	when are fired	action	<B>	4107-1
<B>	Under	constraint	immediate firing	4108-1
immediate firing		sequential	a rule	4108-1
a rule	as	constraint	its event	4108-1
a rule	is essentially fired	action	its event	4108-1
its event	and	conjunctive	condition	4108-1
condition	under	constraint	deferred firing	4108-1
condition	become	attribute	true	4108-1
deferred firing		sequential	rule application	4108-1
rule application	until	constraint	the state	4108-1
rule application	after	constraint	the state	4108-1
rule application	is delayed	action	the state	4108-1
<B>	In	constraint	the most general execution models	4108-2
the most general execution models		sequential	each rule	4108-2
each rule	is assigned	action	its own coupling mode	4108-2
its own coupling mode	or	conjunctive	which	4108-2
its own coupling mode	deferred	attribute	concurrent	4108-2
which	by	constraint	a coupling mode	4108-2
which	may be further refined	action	a coupling mode	4108-2
which	associating	action	a coupling mode	4108-2
a coupling mode	between	constraint	event	4108-2
event	and	conjunctive	condition	4108-2
condition		sequential	testing	4108-2
testing	between	constraint	condition testing	4108-2
testing	and	conjunctive	condition testing	4108-2
condition testing	and	conjunctive	action execution	4108-2
We	now examine	action	the semantics	4109-1
the semantics	of	constraint	firing	4109-1
the semantics	and	conjunctive	firing	4109-1
the semantics	deferred	action	firing	4109-1
firing	in	constraint	more detail	4109-1
We	for	constraint	this discussion	4109-2
We	assume	action	this discussion	4109-2
this discussion	that	constraint	the event	4109-2
the event	of	constraint	each rule	4109-2
each rule	is	attribute	simply true	4109-2
<B>	To	constraint	immediate firing	4110-1
<B>	illustrate	action	immediate firing	4110-1
immediate firing	that	constraint	a rule	4110-1
immediate firing	suppose	action	a rule	4110-1
a rule	with	constraint	action d1	4110-1
a rule	r	action	action d1	4110-1
<B>	.	sequential	<B>	4110-2
<B>	.	sequential	<B>	4110-3
dm	is triggered	action	its condition	4110-4
its condition	in	constraint	state I1	4110-4
its condition	has become	attribute	true	4110-4
state I1	of	constraint	the preceeding sequence	4110-4
the preceeding sequence	of	constraint	states	4110-4
the sequence	of	constraint	databases	4110-5
databases		sequential	states	4110-5
states	with	constraint	I0	4110-5
states	Then might start	action	I0	4110-5
I0		sequential	I1	4110-5
I1		sequential	I	4110-5
I		sequential	I	4110-5
I		sequential	<B>	4110-5
<B>	.	sequential	<B>	4110-6
<B>	.	sequential	<B>	4110-7
I′m		sequential	I′m	4110-8
<B>	.	sequential	<B>	4110-9
<B>	.	sequential	<B>	4110-10
<B>		sequential	<B>	4110-11
j		sequential	+1	4111-1
+1	to	constraint	I′j m	4111-1
I′j m		sequential	c2	4111-1
c2	would be applied	action	<B>	4111-1
The semantics	of	constraint	intermediate rule firing	4111-2
intermediate rule firing	in	constraint	fact	4111-2
intermediate rule firing	is	attribute	fact	4111-2
fact	for	constraint	two reasons	4111-2
another rule	during	constraint	the execution	4111-3
another rule	First might be triggered	action	the execution	4111-3
the execution	of	constraint	the action	4111-3
the action	of	constraint	the first triggered rule	4111-3
<B>	In	constraint	a recursive style	4111-4
<B>	for	constraint	a recursive style	4111-4
<B>	calls	action	a recursive style	4111-4
a recursive style	of	constraint	rule application	4111-4
rule application		sequential	the command sequences	4111-4
the command sequences	of	constraint	each triggered rule	4111-4
each triggered rule	onto	constraint	a stack	4111-4
each triggered rule	where are placed	action	a stack	4111-4
several rules	at	constraint	the same time	4111-5
several rules	Second might be triggered	action	the same time	4111-5
One approach	in	constraint	Dynamic Aspects	4111-6
Dynamic Aspects		sequential	this case	4111-6
this case	to	constraint	the rules	4111-6
this case	that	constraint	the rules	4111-6
this case	is	attribute	the rules	4111-6
this case	assume	action	the rules	4111-6
the rules	that	constraint	rules	4111-6
the rules	and	conjunctive	rules	4111-6
the rules	are ordered	action	rules	4111-6
rules	in	constraint	that order	4111-6
rules	triggered simultaneously	action	that order	4111-6
rules	are considered	action	that order	4111-6
Another approach	to	constraint	rules	4111-7
Another approach	is	attribute	rules	4111-7
Another approach	fire concurrently	action	rules	4111-7
Another approach	simultaneously triggered	action	rules	4111-7
rules	essentially has	action	the effect	4111-7
the effect	of	constraint	them	4111-7
the effect	firing	action	them	4111-7
them	in	constraint	a nondeterministic order	4111-7
<B>	In	constraint	the case	4112-1
the case	of	constraint	deferred firing	4112-1
deferred firing		sequential	the full user transaction	4112-1
the full user transaction	before	constraint	any rules	4112-1
the full user transaction	is completed	action	any rules	4112-1
any rules	and	conjunctive	each rule action	4112-1
any rules	are fired	action	each rule action	4112-1
each rule action	in	constraint	its entirety	4112-1
each rule action	is executed	action	its entirety	4112-1
its entirety	before	constraint	another rule action	4112-1
another rule action	is initiated	action	<B>	4112-1
<B>	gives	action	rise	4113-1
rise	to	constraint	a sequence	4113-1
a sequence	of	constraint	states	4113-1
states	having	action	the form	4113-1
the form		sequential	I	4113-1
I	orig	action	I user	4113-1
I user		sequential	I2	4113-1
I2		sequential	I3	4113-1
<B>	.	sequential	<B>	4113-2
<B>	.	sequential	<B>	4113-3
I	curr	action	I	4113-4
I	is	attribute	where now the original state	4113-4
I	orig	action	where now the original state	4113-4
where now the original state		sequential	I user	4113-4
I user	is	attribute	the result	4113-4
the result	of	constraint	user	4113-4
the result	applying	action	user	4113-4
user	requested	action	the transaction	4113-4
the transaction	and	conjunctive	the states	4113-4
the states		sequential	I2	4113-4
I2		sequential	I3	4113-4
<B>	.	sequential	<B>	4113-5
<B>	.	sequential	<B>	4113-6
I	are	attribute	the results	4113-7
I	curr	action	the results	4113-7
the results	of	constraint	the actions	4113-7
the results	applying	action	the actions	4113-7
the actions	of	constraint	fired rules	4113-7
The sequence	if	constraint	additional rules	4113-8
The sequence	shown here	action	additional rules	4113-8
The sequence	might be extended	action	additional rules	4113-8
additional rules	to	constraint	<B>	4113-8
additional rules	are be fired	action	<B>	4113-8
Several intricacies	arise	action	<B>	4114-1
the order	of	constraint	rule firing	4114-2
rule firing	if	constraint	multiple rules	4114-2
rule firing	As before must be considered	action	multiple rules	4114-2
multiple rules	at	constraint	a given state	4114-2
multiple rules	are triggered	action	a given state	4114-2
<B>	Recall	action	r2	4114-3
r2		sequential	the rules	4114-3
the rules	of	constraint	Example 22.5.1	4114-3
Example 22.5.1		sequential	whose events	4114-3
whose events	on	constraint	transitions	4114-3
whose events	where based	action	transitions	4114-3
transitions	between	constraint	some former state	4114-3
some former state	and	conjunctive	some latter state	4114-3
What states	should be used	action	<B>	4114-4
It	to	constraint	I	4114-5
It	is	attribute	natural	4114-5
It	use	action	I	4114-5
I	as	constraint	the latter state	4114-5
I	curr	action	the latter state	4114-5
<B>	With	constraint	regard	4114-6
regard	to	constraint	the former state	4114-6
the former state		sequential	some systems	4114-6
some systems	advocate	action	I orig	4114-6
some systems	using	action	I orig	4114-6
I orig	whereas	constraint	other systems	4114-6
other systems	support	action	the use	4114-6
the use	of	constraint	one	4114-6
one	of	constraint	the intermediate states	4114-6
the intermediate states		sequential	the choice	4114-6
the choice	on	constraint	a complex condition	4114-6
the choice	where may depend	action	a complex condition	4114-6
<B>	that	constraint	two rules	4115-1
<B>	Suppose	action	two rules	4115-1
two rules	and	conjunctive	r′	4115-1
r′	at	constraint	some state	4115-1
r′	r are triggered	action	some state	4115-1
some state		sequential	I	4115-1
I	=	sequential	<B>	4115-1
I	curr	action	<B>	4115-1
The event	and	conjunctive	condition	4115-2
The event	or	conjunctive	condition	4115-2
condition	of	constraint	r′	4115-2
r′	be	attribute	may no longer true	4115-2
<B>	raises	action	the question	4115-3
the question		sequential	r′	4115-3
r′	Should be fired	action	<B>	4115-3
A consensus	in	constraint	the literature	4115-4
A consensus	has not emerged	action	the literature	4115-4
<B>	while	constraint	The languages	4116-1
The languages	in	constraint	Part E	4116-1
The languages	studied	action	Part E	4116-1
Part E	as	constraint	the kernel	4116-1
Part E	can serve	action	the kernel	4116-1
the kernel	of	constraint	an active database	4116-1
These languages	do not use	action	events	4117-1
events	restrict	action	rule actions	4117-1
rule actions	to	constraint	insertions	4117-1
insertions		sequential	deletions	4117-1
deletions	and	conjunctive	value creation	4117-1
value creation	and	conjunctive	only the current state	4117-1
value creation	examine	action	only the current state	4117-1
only the current state	in	constraint	a rule firing sequence	4117-1
<B>	If	constraint	value creation	4117-2
value creation	is supported	action	these languages	4117-2
these languages	for	constraint	database mappings	4117-2
these languages	are	attribute	complete	4117-2
database mappings	in	constraint	some sense	4117-2
database mappings	and	conjunctive	some sense	4117-2
some sense	so can simulate	action	all active databases	4117-2
richer rules	and	conjunctive	execution models	4117-3
execution models	However permit	action	the possibility	4117-3
the possibility	of	constraint	rule bases	4117-3
the possibility	developing	action	rule bases	4117-3
rule bases		sequential	that	4117-3
that	enforce	action	a desired set	4117-3
a desired set	of	constraint	policies	4117-3
policies	in	constraint	a more intuitive fashion	4117-3
a more intuitive fashion	than	constraint	a while program	4117-3
It	that	constraint	whatever execution model	4118-1
It	be	attribute	should clear	4118-1
whatever execution model	and	conjunctive	form	4118-1
form	for	constraint	rules	4118-1
rules	is selected	action	most questions	4118-1
most questions	about	constraint	the behavior	4118-1
the behavior	of	constraint	an active database	4118-1
an active database	are	attribute	undecidable	4118-1
It	to	constraint	more restricted execution models	4118-2
It	is	attribute	thus interesting	4118-2
It	consider	action	more restricted execution models	4118-2
more restricted execution models		sequential	that	4118-2
that	in	constraint	predictable ways	4118-2
that	behave	action	predictable ways	4118-2
We	now present	action	one such execution model	4118-3
one such execution model	called	action	the accumulating model	4118-3
the accumulating model	forms	action	a portion	4118-3
a portion	of	constraint	the execution model	4118-3
the execution model	of	constraint	AP5	4118-3
AP5		sequential	main memory	4118-3
main memory		sequential	active database system	4118-3
active database system		sequential	that	4118-3
that	in	constraint	research	4118-3
that	has been used	action	research	4118-3
research	for	constraint	a decade	4118-3
<B>	To	constraint	the accumulating execution model	4119-1
<B>	describe	action	the accumulating execution model	4119-1
the accumulating execution model		sequential	we	4119-1
we	first introduce	action	the notion	4119-1
the notion	of	constraint	a delta	4119-1
<B>	Let	action	R	4120-1
R	{	sequential	R1	4120-1
<B>	.	sequential	<B>	4120-2
<B>	.	sequential	<B>	4120-3
Rn		sequential	}	4120-4
}	be	attribute	a database schema	4120-4
An atomic update	over	constraint	R	4120-5
R	is	attribute	an expression	4120-5
an expression	of	constraint	the form	4120-5
the form	+	sequential	Ri	4120-5
Ri		sequential	t	4120-5
t	or	conjunctive	Ri	4120-5
Ri		sequential	t	4120-5
t		sequential	i	4120-5
i	where ∈	action	1	4120-5
1	n	conjunctive	t	4120-5
1	and	conjunctive	t	4120-5
t	is	attribute	a tuple	4120-5
a tuple	having	action	the arity	4120-5
the arity	of	constraint	Ri	4120-5
A delta	over	constraint	R	4120-6
R	is	attribute	a finite set	4120-6
a finite set	of	constraint	atomic updates	4120-6
atomic updates	over	constraint	R	4120-6
R		sequential	that	4120-6
that	both	conjunctive	+R	4120-6
that	does not contain	action	+R	4120-6
+R		sequential	t	4120-6
t	and	conjunctive	−R	4120-6
−R		sequential	t	4120-6
t	for	constraint	any R	4120-6
any R	and	conjunctive	t	4120-6
t	or	conjunctive	the special value fail	4120-6
Modifies	into	constraint	deltas	4120-7
Modifies	could also be incorporated	action	deltas	4120-7
deltas	but	conjunctive	we	4120-7
we	do not consider here	attribute	that	4120-7
A delta	not containing	action	the value fail	4120-8
the value fail	is	attribute	consistent	4120-8
<B>	For	constraint	delta	4120-9
delta		sequential	we	4120-9
we	define	action	<B>	4120-9
<B>	Given	action	instance	4121-1
instance		sequential	I	4121-1
I	and	conjunctive	consistent delta	4121-1
consistent delta	over	constraint	R	4121-1
R		sequential	the result	4121-1
the result	of	constraint	I	4121-1
the result	to	constraint	I	4121-1
the result	applying	action	I	4121-1
I	is	attribute	I	4121-1
I	apply	action	I	4121-1
I	=	sequential	I	4121-1
I		sequential	∪	4121-1
∪	=	sequential	I	4121-1
I		sequential	−	4121-1
−		sequential	∪	4121-1
<B>		sequential	the merge	4122-1
the merge	of	constraint	two consistent deltas 2	4122-1
two consistent deltas 2		sequential	1	4122-1
1	by	constraint	1 2	4122-1
1	is defined	action	1 2	4122-1
1 2	if	constraint	<B>	4122-1
1 2	∪	sequential	<B>	4122-1
1 2	is	attribute	consistent	4122-1
1 2	fail otherwise	action	<B>	4122-1
The accumulating execution model	uses	action	deferred rule firing	4123-1
Each rule action	as	constraint	a consistent delta	4123-2
Each rule action	is viewed	action	a consistent delta	4123-2
Each rule action	producing	action	a consistent delta	4123-2
user	requested	action	The transaction	4123-3
The transaction	to	constraint	the delta 0	4123-3
The transaction	be	attribute	the delta 0	4123-3
The transaction	is also considered	action	the delta 0	4123-3
Thus a sequence	of	constraint	states	4123-4
states		sequential	I	4123-4
I	=	sequential	I0	4123-4
I	orig	action	I0	4123-4
I0		sequential	I user	4123-4
I user	=	sequential	I1	4123-4
I1		sequential	I2	4123-4
I2		sequential	I3	4123-4
<B>	.	sequential	<B>	4123-5
<B>	.	sequential	<B>	4123-6
I	curr	action	I	4123-7
I	is produced	action	I	4123-7
I	where =	sequential	I	4123-7
I	user	action	I	4123-7
I	apply	action	I	4123-7
I	orig	action	0	4123-7
0	and	conjunctive	Ii+1	4123-7
Ii+1	=	sequential	i	4123-7
Ii+1	apply Ii	action	i	4123-7
i	for	constraint	i	4123-7
i	by	constraint	a rule firing	4123-7
i	produced	action	a rule firing	4123-7
i		sequential	i	4124-1
<B>	that	constraint	we	4125-1
<B>	Suppose	action	we	4125-1
we	in	constraint	now state	4125-1
we	are	attribute	now state	4125-1
now state		sequential	I	4125-1
I	with	constraint	delta curr	4125-1
I	curr	action	delta curr	4125-1
We	that	constraint	rule conditions	4125-2
We	assume	action	rule conditions	4125-2
rule conditions	can access	action	only I orig	4125-2
only I orig	and	conjunctive	curr	4125-2
<B>	If	constraint	the rule conditions	4125-3
the rule conditions	have	action	the power	4125-3
the power	of	constraint	example	4125-3
the power	for	constraint	example	4125-3
example		sequential	the relational calculus	4125-3
the relational calculus	means	action	they	4125-3
they	in	constraint	effect	4125-3
effect	can access	action	I	4125-3
I	curr	action	<B>	4125-3
<B>	Given	action	rule	4125-4
rule		sequential	r	4125-4
r		sequential	state I	4125-4
state I	and	conjunctive	delta	4125-4
delta		sequential	the effect	4125-4
the effect	of	constraint	I effect	4125-4
the effect	on	constraint	I effect	4125-4
the effect	and	conjunctive	I effect	4125-4
the effect	r	action	I effect	4125-4
the effect	denoted	action	I effect	4125-4
I effect		sequential	I	4125-4
I	is	attribute	the delta	4125-4
the delta	to	constraint	the firing	4125-4
the delta	corresponding	action	the firing	4125-4
the firing	of	constraint	r	4125-4
r	on	constraint	I	4125-4
I	if	constraint	the condition	4125-4
I	and	conjunctive	the condition	4125-4
the condition	of	constraint	r	4125-4
r	and	conjunctive	<B>	4125-4
r	is	attribute	satisfied	4125-4
r	is otherwise	action	<B>	4125-4
Execution	as	constraint	<B>	4126-1
Execution	proceeds	action	<B>	4126-1
Execution	follows	action	<B>	4126-1
The sequence		sequential	′	4126-2
<B>	.	sequential	<B>	4126-3
<B>	.	sequential	<B>	4126-4
<B>	is constructed sequentially	action	<B>	4126-5
<B>	terminates successfully	action	<B>	4127-1
a rule	with	constraint	Otherwise condition	4127-2
a rule	r	action	Otherwise condition	4127-2
Otherwise condition	by	constraint	I	4127-2
I	and	conjunctive	′	4127-2
′	is	attribute	i	4127-2
i		sequential	Dynamic Aspects	4127-2
Dynamic Aspects	selected nondeterministically	action	<B>	4127-2
<B>	If	constraint	′	4127-3
′	&	conjunctive	effect	4127-3
effect	r	action	I	4127-3
I	orig	attribute	′ fail	4127-3
I	is	attribute	′ fail	4127-3
execution	terminates	action	i	4127-3
i		sequential	i	4127-3
i	with	constraint	an abort	4127-3
an abort	otherwise set	action	<B>	4127-3
i+1		sequential	i	4128-1
i		sequential	i	4128-1
It	to	constraint	the order	4129-1
It	is	attribute	also natural	4129-1
It	ask	action	the order	4129-1
the order	of	constraint	rule	4129-1
rule	firing	action	the outcome	4129-1
rule	Does affect	action	the outcome	4129-1
<B>	In	constraint	the answer	4129-2
the answer	is	attribute	<B>	4129-2
We	now develop	action	a semantic condition	4129-3
a semantic condition	on	constraint	rules	4129-3
rules		sequential	that	4129-3
that	ensures	action	independence	4129-3
independence	of	constraint	rule firing order	4129-3
A rule r	if	constraint	each instance	4129-4
A rule r	for	constraint	each instance	4129-4
A rule r	is	attribute	monotonic	4129-4
each instance		sequential	I	4129-4
I	and	conjunctive	pair	4129-4
pair		sequential	1 ⊆ 2	4129-4
1 ⊆ 2	of	constraint	deltas	4129-4
deltas		sequential	effect	4129-4
effect		sequential	r	4129-4
r		sequential	I	4129-4
I		sequential	1	4129-4
1		sequential	⊆ effect	4129-4
⊆ effect		sequential	r	4129-4
r		sequential	I	4129-4
I		sequential	2	4129-4
<B>	can now be shown	action	Exercise 22.23	4129-5
<B>	see	action	Exercise 22.23	4129-5
Exercise 22.23		sequential	Theorem 22.5.2	4129-5
Monitoring Events	and	conjunctive	Conditions	4130-1
There	has been	action	recent interest	4130-2
recent interest	in	constraint	languages	4130-2
recent interest	developing	action	languages	4130-2
languages	for	constraint	composite events	4130-2
languages	and	conjunctive	composite events	4130-2
languages	specifying	action	composite events	4130-2
languages	recognizing	action	composite events	4130-2
composite events		sequential	which	4130-2
which	might involve	action	the occurrence	4130-2
the occurrence	of	constraint	several primitive events	4130-2
<B>	For	constraint	example	4130-3
example		sequential	composite event specification	4130-3
composite event specification	by	constraint	the ODE system	4130-3
composite event specification	is supported	action	the ODE system	4130-3
the ODE system		sequential	object	4130-3
object	oriented	action	a recently released prototype active database system	4130-3
The ODE system	supports	action	a rich language	4130-4
a rich language	for	constraint	composite events	4130-4
a rich language	specifying	action	composite events	4130-4
composite events		sequential	which	4130-4
which	has essentially	action	the power	4130-4
the power	of	constraint	regular expressions	4130-4
regular expressions	see also	action	Section 22.6	4130-4
Section 22.6	for	constraint	examples	4130-4
examples	of	constraint	composite events	4130-4
composite events	by	constraint	regular expressions	4130-4
composite events	specified	action	regular expressions	4130-4
An implementation technique	on	constraint	finite state automata	4130-5
An implementation technique	based	action	finite state automata	4130-5
finite state automata	for	constraint	composite events	4130-5
finite state automata	has been developed	action	composite events	4130-5
finite state automata	recognizing	action	composite events	4130-5
composite events	in	constraint	this language	4130-5
composite events	specified	action	this language	4130-5
Other formalisms	for	constraint	composite events	4131-1
Other formalisms	can also be used	action	composite events	4131-1
Other formalisms	specifying	action	composite events	4131-1
composite events	e.g. using	action	Petri nets	4131-1
Petri nets	or	conjunctive	temporal logics	4131-1
There	to	constraint	a trade off	4131-2
There	be	attribute	a trade off	4131-2
There	appears	action	a trade off	4131-2
a trade off	between	constraint	the expressiveness	4131-2
the expressiveness	of	constraint	triggers	4131-2
triggers	in	constraint	rules	4131-2
rules	and	conjunctive	conditions	4131-2
<B>	For	constraint	example	4131-3
example		sequential	net	4131-3
net	Petri based	action	some languages	4131-3
some languages	for	constraint	composite events	4131-3
composite events	can be simulated	action	additional relations	4131-3
composite events	using	action	additional relations	4131-3
additional relations	and	conjunctive	rules	4131-3
rules	on	constraint	simple events	4131-3
rules	based	action	simple events	4131-3
The details	of	constraint	trade	4131-4
trade		sequential	such offs	4131-4
such offs	are	attribute	largely unexplored	4131-4
Databases	and	conjunctive	Constraints	4132-1
Constraints		sequential	Temporal Classical databases	4132-1
Temporal Classical databases	model	action	static aspects	4132-1
static aspects	of	constraint	data	4132-1
the information	in	constraint	the database	4132-2
the database	of	constraint	data	4132-2
the database	Thus consists	action	data	4132-2
data	in	constraint	the world	4132-2
<B>	in	constraint	many applications	4132-3
many applications		sequential	information	4132-3
information	about	constraint	the history	4132-3
the history	of	constraint	data	4132-3
data	as	constraint	static information	4132-3
data	is	attribute	However just as important	4132-3
history	into	constraint	account	4132-4
history	When is taken	action	account	4132-4
account		sequential	queries	4132-4
queries	about	constraint	the evolution	4132-4
queries	can ask	action	the evolution	4132-4
the evolution	of	constraint	data	4132-4
data	through	constraint	time	4132-4
time	and	conjunctive	constraints	4132-4
constraints	may restrict	action	the way	4132-4
the way		sequential	changes	4132-4
changes	occur	action	<B>	4132-4
We	briefly discuss	action	these two aspects	4132-5
Temporal Databases		sequential	Temporal Databases	4133-1
we	to	constraint	each time	4133-2
we	Conceptually can associate	action	each time	4133-2
each time		sequential	t the state	4133-2
Two basic questions	come up immediately	action	<B>	4133-3
<B>	using	action	valid time	4134-1
valid time	Clearly requires	action	time	4134-1
valid time	including	action	time	4134-1
time	as	constraint	first class	4134-1
first class		sequential	a citizen	4134-1
a citizen	in	constraint	the data model	4134-1
<B>	In	constraint	many applications	4134-2
many applications		sequential	transaction time	4134-2
transaction time	with	constraint	the system	4134-2
transaction time	by	constraint	the system	4134-2
transaction time	and	conjunctive	the system	4134-2
transaction time	might be hidden	action	the system	4134-2
transaction time	dealt	action	the system	4134-2
the system	in	constraint	time	4134-2
time		sequential	applications	4134-2
applications		sequential	air	4134-2
air		sequential	traffic	4134-2
traffic		sequential	control	4134-2
control	or	conjunctive	a power plant	4134-2
control	monitoring	action	a power plant	4134-2
a power plant		sequential	transaction time	4134-2
transaction time	and	conjunctive	<B>	4134-2
transaction time	be	attribute	may important	4134-2
transaction time	made	attribute	explicit	4134-2
A particular database	may use	action	valid time	4134-3
valid time		sequential	transaction time	4134-3
transaction time	or	conjunctive	<B>	4134-3
<B>	In	constraint	our discussion	4134-4
our discussion		sequential	we	4134-4
we	will consider only	action	valid time	4134-4
<B>	In	constraint	databases	4135-1
databases		sequential	time	4135-1
time	to	constraint	some fixed granularity	4135-1
time	with	constraint	some fixed granularity	4135-1
time	is usually taken	attribute	discrete	4135-1
time	be	attribute	discrete	4135-1
some fixed granularity	for	constraint	the time unit	4135-1
several distinct time domains	with	constraint	different granularities	4135-2
different granularities	However are often used	action	years	4135-2
years		sequential	months	4135-2
months		sequential	days	4135-2
days		sequential	hours	4135-2
hours		sequential	<B>	4135-2
The time domain	with	constraint	a total order	4135-3
The time domain	is usually equipped	action	a total order	4135-3
a total order	with	constraint	sometimes arithmetic operations	4135-3
a total order	and	conjunctive	sometimes arithmetic operations	4135-3
A temporal variable	to	constraint	the present time	4135-4
A temporal variable	to	constraint	the present time	4135-4
A temporal variable	now may be used	action	the present time	4135-4
A temporal variable	refer	action	the present time	4135-4
<B>	To	constraint	a temporal database	4136-1
<B>	query	action	a temporal database	4136-1
a temporal database		sequential	relational languages	4136-1
relational languages	to	constraint	account	4136-1
relational languages	into	constraint	account	4136-1
relational languages	must be extended	action	account	4136-1
relational languages	take	action	account	4136-1
account		sequential	the time coordinate	4136-1
<B>	To	constraint	a tuple	4136-2
<B>	that	constraint	a tuple	4136-2
<B>	say	action	a tuple	4136-2
a tuple		sequential	u	4136-2
u	in	constraint	relation	4136-2
u	is	attribute	relation	4136-2
relation		sequential	R	4136-2
R	at	constraint	time t	4136-2
time t		sequential	we	4136-2
we	could simply extend	action	R	4136-2
R	with	constraint	one temporal coordinate	4136-2
one temporal coordinate	and	conjunctive	R	4136-2
one temporal coordinate	write	action	R	4136-2
R		sequential	u	4136-2
u		sequential	t	4136-2
we	Then could use	action	CALC	4136-3
CALC	or	conjunctive	ALG	4136-3
ALG	on	constraint	the extended relations	4136-3
<B>	is illustrated next	action	<B>	4136-4
Example		sequential	22.6.1	4137-1
The query	in	constraint	CALC	4137-2
The query	is expressed	action	CALC	4137-2
CALC	by	constraint	<B>	4137-2
The query	by	constraint	t	4138-1
The query	since	constraint	t	4138-1
The query	is expressed	action	t	4138-1
t		sequential	m	4138-1
m	∀t	constraint	t ′′	4138-1
m	since	constraint	t ′′	4138-1
t ′′		sequential	m	4138-1
m	→	sequential	t	4138-1
t		sequential	≤	4138-1
≤		sequential	t ′′	4138-1
t ′′		sequential	Dynamic Aspects	4138-1
Dynamic Aspects	since	constraint	t	4138-1
t		sequential	m	4138-1
m	=	sequential	∀t	4138-1
∀t		sequential	t ≤	4138-1
t ≤		sequential	t′	4138-1
t′	→	sequential	now ∃s′	4138-1
now ∃s′		sequential	Pariscope	4138-1
Pariscope		sequential	La Pagode	4138-1
La Pagode		sequential	m	4138-1
m		sequential	s′	4138-1
s′		sequential	t′	4138-1
Classical logics	with	constraint	a temporal coordinate	4139-1
Classical logics	augmented	action	a temporal coordinate	4139-1
a temporal coordinate	toward	constraint	specification	4139-1
a temporal coordinate	have been studied extensively	action	specification	4139-1
a temporal coordinate	mostly geared	action	specification	4139-1
specification	and	conjunctive	verification	4139-1
verification	of	constraint	concurrent programs	4139-1
Such logics	to	constraint	temporal logics	4139-2
Such logics	as	constraint	temporal logics	4139-2
Such logics	are usually referred	action	temporal logics	4139-2
There	is	attribute	a wealth	4139-3
a wealth	of	constraint	mathematical machinery	4139-3
mathematical machinery	around	constraint	temporal logics	4139-3
mathematical machinery	developed	action	temporal logics	4139-3
temporal logics	of	constraint	it	4139-3
it	to	constraint	databases	4139-3
it	to	constraint	databases	4139-3
it	seems	action	databases	4139-3
it	apply directly	action	databases	4139-3
Example		sequential	22.6.2	4140-1
It	to	constraint	a model	4140-2
It	or	conjunctive	a model	4140-2
It	be	attribute	would also natural	4140-2
It	represent	attribute	this	4140-2
It	using	attribute	semantic	4140-2
It	object oriented	action	a model	4140-2
The same information	by	constraint	timestamping	4141-1
The same information	can be represented	action	timestamping	4141-1
timestamping	at	constraint	the tuple level	4141-1
the tuple level	as	constraint	Pariscope Theater Title Schedule La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Psycho La Pagode Psycho La Pagode Psycho Kinopanorama Sleeper Kinopanorama Sleeper	4141-1
the tuple level	follows	action	Pariscope Theater Title Schedule La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Psycho La Pagode Psycho La Pagode Psycho Kinopanorama Sleeper Kinopanorama Sleeper	4141-1
<B>	may have	action	some drawbacks	4141-2
<B>	For	constraint	example	4141-3
example	retrieving	action	the information	4141-3
the information	about	constraint	Sleeper	4141-3
Sleeper	at	constraint	La Pagode	4141-3
Sleeper	when was playing	action	La Pagode	4141-3
La Pagode	using	action	a selection	4141-3
a selection	and	conjunctive	projection	4141-3
projection	yields	action	time intervals	4141-3
time intervals		sequential	that	4141-3
that	than	constraint	<B>	4141-3
that	are	attribute	more fragmented	4141-3
that	needed	action	<B>	4141-3
<B>	To	constraint	a more concise representation	4141-4
<B>	obtain	action	a more concise representation	4141-4
a more concise representation	of	constraint	the answer	4141-4
the answer		sequential	we	4141-4
we	of	constraint	these intervals	4141-4
we	must merge	attribute	some	4141-4
<B>	Note also	action	the difference	4142-1
the difference	between	constraint	the timestamps	4142-1
the timestamps	and	conjunctive	the attribute Schedule	4142-1
the attribute Schedule		sequential	which	4142-1
which	also conveys	action	some temporal information	4142-1
The value	of	constraint	Schedule	4142-2
Schedule		sequential	user	4142-2
user	and	conjunctive	the database	4142-2
user	is defined	action	the database	4142-2
the database	that	constraint	temporal information	4142-2
the database	may not know	attribute	this	4142-2
the database	is	attribute	temporal information	4142-2
<B>	from	constraint	the point	4142-3
the point	of	constraint	view	4142-3
view	of	constraint	Pariscope Theater Title Schedule	4142-3
Pariscope Theater Title Schedule		sequential	Sleeper La Pagode Psycho Kinopanorama Sleeper Figure	4142-3
Sleeper La Pagode Psycho Kinopanorama Sleeper Figure		sequential	22.4	4142-3
22.4		sequential	the temporal database	4142-3
the temporal database		sequential	the value	4142-3
the value	of	constraint	Schedule	4142-3
Schedule	like	constraint	just any other nontemporal value	4142-3
Schedule	Thus is treated	action	just any other nontemporal value	4142-3
just any other nontemporal value	in	constraint	the database	4142-3
<B>	of	constraint	the research	4143-1
the research	in	constraint	temporal databases	4143-1
temporal databases	to	constraint	extensions	4143-1
temporal databases	has been devoted	action	extensions	4143-1
temporal databases	finding	action	extensions	4143-1
extensions	of	constraint	SQL	4143-1
SQL	and	conjunctive	other relational languages	4143-1
other relational languages	for	constraint	temporal queries	4143-1
Most proposals	assume	action	some representation	4143-2
some representation	on	constraint	tuple timestamping	4143-2
some representation	based	action	tuple timestamping	4143-2
tuple timestamping	by	constraint	intervals	4143-2
intervals	and	conjunctive	intuitive linguistic constructs	4143-2
intervals	introduce	action	intuitive linguistic constructs	4143-2
intuitive linguistic constructs	to	constraint	these temporal intervals	4143-2
intuitive linguistic constructs	and	conjunctive	these temporal intervals	4143-2
intuitive linguistic constructs	compare	action	these temporal intervals	4143-2
intuitive linguistic constructs	manipulate	action	these temporal intervals	4143-2
<B>	without	constraint	explicit reference	4143-3
<B>	Sometimes is done	action	explicit reference	4143-3
explicit reference	to	constraint	time	4143-3
time	in	constraint	the spirit	4143-3
the spirit	of	constraint	modal operators	4143-3
modal operators	in	constraint	temporal logic	4143-3
One such operator	is illustrated next	action	<B>	4144-1
Example		sequential	22.6.3	4145-1
<B>	For	constraint	example	4145-2
example	consider	action	the query	4145-2
the query	on	constraint	the CINEMA database	4145-2
theater		sequential	t2	4145-3
theater where t1	from	constraint	Pariscope t1 t2	4145-4
title	=	sequential	t2	4145-5
title	and	conjunctive	t1	4145-6
schedule	=	sequential	t2	4145-7
schedule		sequential	when t1	4145-8
interval	overlaps	action	t2	4145-9
interval		sequential	interval	4145-10
Other Boolean tests	on	constraint	intervals	4145-11
intervals	during	constraint	the obvious semantics	4145-11
intervals	with	constraint	the obvious semantics	4145-11
intervals	include	action	the obvious semantics	4145-11
intervals	follows	action	the obvious semantics	4145-11
intervals	precedes	action	the obvious semantics	4145-11
The expressive power	of	constraint	such constructs	4145-12
such constructs	in	constraint	the literature	4145-12
such constructs	is not always well elucidated	action	the literature	4145-12
the literature	beyond	constraint	the fact	4145-12
the fact	that	constraint	they	4145-12
they	in	constraint	CALC	4145-12
they	can clearly be expressed	action	CALC	4145-12
A review	of	constraint	the many constructs	4145-13
the many constructs	in	constraint	the literature	4145-13
the many constructs	proposed	action	the literature	4145-13
the literature	on	constraint	temporal databases	4145-13
temporal databases	beyond	constraint	the scope	4145-13
temporal databases	is	attribute	the scope	4145-13
the scope	of	constraint	this book	4145-13
<B>	For	constraint	the time being	4145-14
the time being		sequential	it	4145-14
it	that	constraint	a single temporal language	4145-14
it	appears	action	a single temporal language	4145-14
it	well accepted	action	a single temporal language	4145-14
a single temporal language	from	constraint	there	4145-14
a single temporal language	although	constraint	there	4145-14
a single temporal language	is	attribute	there	4145-14
a single temporal language	emerging	action	there	4145-14
there	are	attribute	several major prototypes	4145-14
Temporal Deductive Databases		sequential	Temporal Deductive Databases	4146-1
Example		sequential	22.6.4	4147-1
The database	holds	action	information	4147-2
information	on	constraint	a professor	4147-2
a professor		sequential	schedule	4147-2
schedule		sequential	the times	4147-2
the times		sequential	she	4147-2
she	meets	action	her two Ph.D. students	4147-2
The facts	meets	action	Emma	4147-3
Emma		sequential	0	4147-3
0	follows	action	Emma	4147-3
Emma		sequential	John	4147-3
John	follows	action	John	4147-3
John		sequential	Emma	4147-3
Emma	that	constraint	the professor	4147-3
Emma	say	action	the professor	4147-3
the professor		sequential	first meeting	4147-3
first meeting	with	constraint	Emma	4147-3
first meeting	is	attribute	Emma	4147-3
Emma	and	conjunctive	John	4147-3
John	and	conjunctive	Emma	4147-3
Emma	take	action	turns	4147-3
<B>	Consider	action	the rules	4148-1
the rules	meets	action	x	4148-1
x		sequential	t	4148-1
t	meets	action	y	4148-1
y		sequential	t	4148-1
t	+	sequential	1	4148-1
1	meets	action	x	4148-1
x		sequential	t	4148-1
t	follows	action	x	4148-1
x		sequential	y	4148-1
The answer	in	constraint	the unary relation until	4149-1
The answer	given	action	the unary relation until	4149-1
the unary relation until	by	constraint	the following stratified program	4149-1
the unary relation until	is defined	action	the following stratified program	4149-1
the following stratified program		sequential	date	4149-1
date		sequential	x	4149-1
x		sequential	y	4149-1
y		sequential	t	4149-1
t		sequential	Pariscope	4149-1
Pariscope		sequential	x	4149-1
x		sequential	y	4149-1
y		sequential	s	4149-1
s		sequential	t	4149-1
t	until	constraint	t	4149-1
t		sequential	date	4149-1
date		sequential	La Pagode	4149-1
La Pagode		sequential	Sleeper	4149-1
Sleeper		sequential	t	4149-1
t	until	constraint	t	4149-1
Temporal Constraints Classical constraints	in	constraint	relational databases	4150-1
relational databases	are	attribute	static	4150-1
<B>	does not allow	action	the behavior	4150-2
<B>	modeling	action	the behavior	4150-2
the behavior	of	constraint	data	4150-2
<B>	or	conjunctive	constraints	4151-1
constraints	place	action	restrictions	4151-1
restrictions	on	constraint	the data	4151-1
the data	in	constraint	time	4151-1
the data	changes	action	time	4151-1
They	in	constraint	the context	4151-2
They	can arise	action	the context	4151-2
the context	of	constraint	classical databases	4151-2
classical databases	in	constraint	temporal databases	4151-2
<B>	In	constraint	temporal databases	4151-3
temporal databases		sequential	we	4151-3
we	can specify	action	restrictions	4151-3
restrictions	on	constraint	the sequence	4151-3
the sequence	of	constraint	time	4151-3
time	indexed	action	instances	4151-3
instances	using	action	temporal logics	4151-3
temporal logics		sequential	extensions	4151-3
extensions	of	constraint	CALC	4151-3
CALC	or	conjunctive	modal logics	4151-3
<B>	are	attribute	Boolean	4151-4
Boolean	/	sequential	essentially temporal queries	4151-4
<B>	For	constraint	example	4151-5
example		sequential	we	4151-5
we	that	constraint	La Pagode	4151-5
we	might require	action	La Pagode	4151-5
La Pagode	be	attribute	first run	4151-5
first run		sequential	not a theater	4151-5
not a theater		sequential	every movie	4151-5
every movie	in	constraint	some other theater	4151-5
every movie	shown	action	some other theater	4151-5
every movie	must have been shown	action	some other theater	4151-5
some other theater	at	constraint	some earlier time	4151-5
An important question	to	constraint	such constraints	4151-6
An important question	is	attribute	such constraints	4151-6
An important question	how enforce efficiently	action	such constraints	4151-6
A step	in	constraint	this direction	4151-7
this direction	by	constraint	the following example	4151-7
this direction	is suggested	action	the following example	4151-7
Example		sequential	22.6.5	4152-1
The constraint		sequential	that	4152-2
that		sequential	La Pagode	4152-2
La Pagode	is	attribute	first	4152-2
run		sequential	not a theater	4152-2
not a theater	in	constraint	CALC	4152-2
not a theater	can be expressed	action	CALC	4152-2
CALC	as	constraint	Title	4152-2
CALC	Before	constraint	Title	4152-2
Title		sequential	which	4152-2
which	holds	action	all movie titles	4152-2
all movie titles		sequential	that	4152-2
that	in	constraint	the past	4152-2
that	have been shown	action	the past	4152-2
the past	at	constraint	a theater	4152-2
a theater	than	constraint	La Pagode	4152-2
La Pagode	that	constraint	the size	4152-2
La Pagode	Note	action	the size	4152-2
the size	of	constraint	Shown_Before	4152-2
Shown_Before	by	constraint	the number	4152-2
Shown_Before	is bounded	action	the number	4152-2
the number	of	constraint	titles	4152-2
titles		sequential	that	4152-2
that	through	constraint	the history	4152-2
that	have occurred	action	the history	4152-2
the history	of	constraint	the database	4152-2
the database	of	constraint	the database	4152-2
the database	but	conjunctive	the database	4152-2
the database	is	attribute	independent	4152-2
the database	in	constraint	has existence	4152-2
the database	been	action	has existence	4152-2
<B>	if	constraint	a new title	4152-3
a new title	is introduced	action	each day	4152-3
each day		sequential	Shown_Before	4152-3
Shown_Before	Of course will have	action	size	4152-3
size	to	constraint	the full history	4152-3
Dynamic Aspects		sequential	Dynamic Aspects	4153-1
<B>	For	constraint	classical databases	4154-1
classical databases	in	constraint	which	4154-1
which		sequential	no history	4154-1
no history	is kept	action	temporal constraints	4154-1
temporal constraints	can only involve	action	transitions	4154-1
transitions	from	constraint	the current instance	4154-1
the current instance	to	constraint	rise	4154-1
the current instance	gives	action	rise	4154-1
rise	to	constraint	a subset	4154-1
a subset	of	constraint	temporal constraints	4154-1
temporal constraints	called	action	transition constraints	4154-1
<B>	Besides	constraint	CALC	4155-1
CALC		sequential	transition constraints	4155-1
transition constraints	in	constraint	various other ways	4155-1
transition constraints	may be stated	action	various other ways	4155-1
various other ways	including	action	<B>	4155-1
Restrictions	on	constraint	updates	4156-1
updates	by	constraint	transactional schemas	4156-1
updates	say	action	transactional schemas	4156-1
transactional schemas	also induce	action	temporal constraints	4156-1
<B>	For	constraint	instance	4156-2
instance	consider again	action	the transactional schema	4156-2
the transactional schema	in	constraint	Example 22.2.1	4156-2
It	that	constraint	all possible sequences	4156-3
It	can be verified	action	all possible sequences	4156-3
all possible sequences	of	constraint	instances	4156-3
instances	by	constraint	calls	4156-3
instances	obtained	action	calls	4156-3
calls	to	constraint	the transactions	4156-3
the transactions	of	constraint	that schema	4156-3
that schema	satisfy	action	the temporal constraint	4156-3
<B>	hire	action	transfer	4157-1
transfer	+	sequential	promote	4157-1
promote	+	sequential	ǫ	4157-1
ǫ		sequential	raise	4157-1
raise		sequential	∗	4157-1
∗	+	sequential	fire	4157-1
∗	retire	action	fire	4157-1
Everybody		sequential	who	4157-2
who	is promoted	action	Bibliographic Notes	4157-2
Bibliographic Notes	must also receive	action	a raise	4157-2
a raise	but	conjunctive	raises	4157-2
raises	without	constraint	even promotion	4157-2
raises	may be received	action	even promotion	4157-2
Such constraints	to	constraint	object	4157-3
Such constraints	to	constraint	object	4157-3
Such constraints	appear	action	object	4157-3
Such constraints	be particularly well suited	action	object	4157-3
object	oriented	action	databases	4157-3
databases	in	constraint	which	4157-3
which		sequential	events	4157-3
events	with	constraint	method invocations	4157-3
events	can naturally be associated	action	method invocations	4157-3
Some active databases		sequential	Section 22.5	4157-4
Section 22.5	can also enforce	action	constraints	4157-4
constraints	on	constraint	sequences	4157-4
sequences	of	constraint	events	4157-4
Bibliographic Notes		sequential	Bibliographic Notes	4158-1
sound	and	conjunctive	The axiomatization	4158-2
The axiomatization	for	constraint	IDM transactions	4158-2
IDM transactions	in	constraint	KV91	4158-2
IDM transactions	is provided	action	KV91	4158-2
The results	on	constraint	simplification rules	4158-3
simplification rules	are also presented	action	<B>	4158-3
The language datalog¬¬	and	conjunctive	other update languages	4158-4
The language datalog¬¬	and	conjunctive	other update languages	4158-4
The language datalog¬¬	rule based	attribute	imperative	4158-4
other update languages	in	constraint	AV88 c	4158-4
other update languages	are studied	action	AV88 c	4158-4
Dynamic Logic Programming	in	constraint	MW88 b	4158-5
Dynamic Logic Programming	is discussed	action	MW88 b	4158-5
<B>	In	constraint	Example 22.1.3	4158-6
Example 22.1.3	from	constraint	<B>	4158-6
Example 22.1.3	is	attribute	<B>	4158-6
The language		sequential	LDL	4158-7
LDL	including	action	its update capabilities	4158-7
its update capabilities	in	constraint	NT89	4158-7
its update capabilities	is presented	action	NT89	4158-7
IDM transactional schemas	in	constraint	AV89	4159-1
IDM transactional schemas	are investigated	action	AV89	4159-1
Transactional schemas	on	constraint	more powerful languages	4159-2
Transactional schemas	based	action	more powerful languages	4159-2
more powerful languages	in	constraint	AV87	4159-2
more powerful languages	are discussed	action	AV87	4159-2
AV87		sequential	AV88a	4159-2
Patterns	of	constraint	object migration	4159-3
object migration	in	constraint	object	4159-3
object	oriented	action	databases	4159-3
databases	in	constraint	Su92	4159-3
databases	are studied	action	Su92	4159-3
Su92	using	action	results	4159-3
results	on	constraint	IDM transactional schemas	4159-3
A simple update language	to	constraint	the family	4159-4
A simple update language	is shown	action	the family	4159-4
A simple update language	express	action	the family	4159-4
the family	of	constraint	migration patterns	4159-4
migration patterns	by	constraint	regular languages	4159-4
migration patterns	characterized	action	regular languages	4159-4
regular languages		sequential	richer families	4159-4
richer families	of	constraint	patterns	4159-4
patterns	by	constraint	conditionals	4159-4
patterns	are obtained	action	conditionals	4159-4
patterns	permitting	action	conditionals	4159-4
conditionals	in	constraint	this language	4159-4
One	of	constraint	the earliest works	4160-1
the earliest works	on	constraint	the view maintenance problem	4160-1
the view maintenance problem	is	attribute	BC79	4160-1
BC79		sequential	which	4160-1
which	on	constraint	an update	4160-1
which	whether	constraint	an update	4160-1
which	focuses	action	an update	4160-1
which	determining	action	an update	4160-1
an update	or	conjunctive	<B>	4160-1
an update	is	attribute	relevant	4160-1
References		sequential	KP81	4160-2
KP81		sequential	HK89	4160-2
HK89	study	action	the maintenance	4160-2
the maintenance	of	constraint	derived data	4160-2
derived data	in	constraint	the context	4160-2
the context	of	constraint	semantic data models	4160-2
semantic data models	and	conjunctive	SI84	4160-2
SI84	studies	action	the maintenance	4160-2
the maintenance	of	constraint	a universal relation	4160-2
a universal relation	from	constraint	an acyclic database family	4160-2
a universal relation	formed	action	an acyclic database family	4160-2
Additional works		sequential	that	4160-3
that	use	action	the approach	4160-3
the approach	of	constraint	incremental evaluation	4160-3
incremental evaluation	include	action	BLT86	4160-3
BLT86		sequential	GKM92	4160-3
GKM92		sequential	Pai84	4160-3
Pai84		sequential	QW91	4160-3
Heuristics	for	constraint	the materialized output	4160-4
Heuristics	maintaining	action	the materialized output	4160-4
the materialized output	of	constraint	a stratified datalog¬ program	4160-4
a stratified datalog¬ program	in	constraint	AP87 b	4160-4
a stratified datalog¬ program	are developed	action	AP87 b	4160-4
AP87 b		sequential	Küc91	4160-4
A comprehensive approach		sequential	which	4160-5
which	handles	action	views	4160-5
views	defined	action	the stratified datalog	4160-5
views	using	action	the stratified datalog	4160-5
the stratified datalog	and	conjunctive	aggregate operators	4160-5
aggregate operators	in	constraint	GMS93	4160-5
aggregate operators	is developed	action	GMS93	4160-5
Reference		sequential	Cha94	4161-1
Cha94	addresses	action	the issue	4161-1
the issue	of	constraint	incremental update	4161-1
incremental update	to	constraint	materialized views	4161-1
materialized views	in	constraint	the presence	4161-1
the presence	of	constraint	OIDs	4161-1
Testing	for	constraint	relevance	4162-1
relevance	of	constraint	updates	4162-1
updates	in	constraint	connection	4162-1
connection	with	constraint	view maintenance	4162-1
view maintenance	to	constraint	the problem	4162-1
view maintenance	is	attribute	related	4162-1
the problem	of	constraint	incremental maintenance	4162-1
incremental maintenance	of	constraint	integrity constraints	4162-1
References		sequential	BBC80	4162-2
BBC80		sequential	HMN84	4162-2
HMN84	develop	action	general techniques	4162-2
general techniques	for	constraint	this problem	4162-2
this problem	and	conjunctive	approaches	4162-2
approaches	for	constraint	deductive databases	4162-2
deductive databases	include	action	BDM88	4162-2
BDM88		sequential	LST87	4162-2
LST87		sequential	Nic82	4162-2
The issue	of	constraint	first order	4163-1
first order		sequential	incremental definability	4163-1
incremental definability	of	constraint	datalog programs	4163-1
datalog programs	in	constraint	DS92	4163-1
datalog programs	was first raised	action	DS92	4163-1
DS92	and	conjunctive	DS93	4163-1
Additional research	in	constraint	this area	4163-2
this area	includes	action	DT92	4163-2
DT92		sequential	DST94	4163-2
A more general perspective	on	constraint	these kinds	4163-3
these kinds	of	constraint	problems	4163-3
problems	in	constraint	PI94	4163-3
problems	is presented	action	PI94	4163-3
The other practical approach	to	constraint	a careful analysis	4164-1
The other practical approach	is	attribute	a careful analysis	4164-1
The other practical approach	perform	action	a careful analysis	4164-1
a careful analysis	of	constraint	the syntax	4164-1
the syntax	and	conjunctive	semantics	4164-1
semantics	of	constraint	a view definition	4164-1
a view definition	to	constraint	a set	4164-1
a view definition	or	conjunctive	a set	4164-1
a view definition	determine	attribute	unique	4164-1
a set	of	constraint	update translation s	4164-1
update translation s		sequential	that	4164-1
that	satisfy	action	a family	4164-1
a family	of	constraint	natural properties	4164-1
This approach	in	constraint	DB82	4164-2
This approach	is pioneered	action	DB82	4164-2
DB82	in	constraint	Kel85	4164-2
DB82	and	conjunctive	Kel85	4164-2
DB82	further developed	action	Kel85	4164-2
Kel85		sequential	Kel86	4164-2
Example		sequential	22.3.6	4164-3
22.3.6	by	constraint	Kel86	4164-3
22.3.6	is inspired	action	Kel86	4164-3
Reference		sequential	Kel82	4164-4
Kel82	considers	action	the issue	4164-4
the issue	of	constraint	unavoidable side effects	4164-4
unavoidable side effects	from	constraint	view updates	4164-4
The discussion	of	constraint	view complements	4165-1
view complements	and	conjunctive	Theorem 22.3.10	4165-1
Theorem 22.3.10	from	constraint	BS81	4165-1
Theorem 22.3.10	is	attribute	BS81	4165-1
Reference Dynamic Aspects		sequential	Reference Dynamic Aspects	4165-2
The semantics	of	constraint	updates	4166-1
updates	on	constraint	incomplete databases	4166-1
incomplete databases	in	constraint	AG85	4166-1
incomplete databases	is investigated	action	AG85	4166-1
AG85	and	conjunctive	<B>	4166-1
The idea	of	constraint	a database	4167-1
The idea	representing	action	a database	4167-1
a database	as	constraint	a logical theory	4167-1
a logical theory	as to	constraint	a set	4167-1
a logical theory	opposed	action	a set	4167-1
a set	of	constraint	atomic facts	4167-1
atomic facts	has	action	roots	4167-1
roots	in	constraint	Kow81	4167-1
Kow81		sequential	NG78	4167-1
NG78		sequential	Rei84	4167-1
A survey	of	constraint	approaches	4167-2
approaches	to	constraint	logical theories	4167-2
approaches	updating	action	logical theories	4167-2
logical theories		sequential	which	4167-2
which	articulates	action	the distinction	4167-2
the distinction	between	constraint	model	4167-2
model	and	conjunctive	formula	4167-2
model	based	action	formula	4167-2
formula	based	action	approaches	4167-2
approaches	is	attribute	Win88	4167-2
Reference		sequential	Win86	4167-3
Win86	develops	action	a approach	4167-3
Win86	model based	action	a approach	4167-3
a approach	for	constraint	theories	4167-3
a approach	updating	action	theories	4167-3
theories		sequential	that	4167-3
that	extends	action	the framework	4167-3
the framework	of	constraint	Rei84	4167-3
Complexity	and	conjunctive	expressiveness	4167-4
expressiveness		sequential	issues	4167-4
issues	to	constraint	this approach	4167-4
this approach	in	constraint	GMR92	4167-4
this approach	are studied	action	GMR92	4167-4
GMR92		sequential	Win86	4167-4
model	based	action	A approach	4167-5
A approach	in	constraint	connection	4167-5
A approach	has recently been applied	action	connection	4167-5
connection	with	constraint	object migration	4167-5
connection	supporting	action	object migration	4167-5
object migration	in	constraint	object	4167-5
object	oriented	action	databases	4167-5
databases	in	constraint	MMW94	4167-5
References	on	constraint	belief revision	4168-1
belief revision	include	action	AGM85	4168-1
AGM85		sequential	the AGM	4168-1
the AGM	and	conjunctive	Gär88	4168-1
the AGM	postulates	action	Gär88	4168-1
the AGM	where are developed	action	Gär88	4168-1
Gär88		sequential	Mak85	4168-1
The contrast	between	constraint	belief revision	4168-2
belief revision	and	conjunctive	knowledge update	4168-2
knowledge update	in	constraint	KW85	4168-2
knowledge update	was articulated informally	action	KW85	4168-2
KW85	in	constraint	formally KM91a	4168-2
KW85	and	conjunctive	formally KM91a	4168-2
formally KM91a		sequential	postulates	4168-2
postulates	for	constraint	theories	4168-2
postulates	updating	action	theories	4168-2
theories	under	constraint	model	4168-2
model	based	action	the perspective	4168-2
the perspective	were developed	action	GMR92	4168-2
the perspective	see also	action	GMR92	4168-2
GMR92		sequential	KM91	4168-2
KM91		sequential	b	4168-2
The discussion	in	constraint	this chapter	4169-1
this chapter	by	constraint	KM91a	4169-1
this chapter	is inspired	action	KM91a	4169-1
Exercises		sequential	Exercises	4170-1
Theorem 22.5.2	from	constraint	ZH90	4170-2
Theorem 22.5.2	is	attribute	ZH90	4170-2
ZH90		sequential	which	4170-2
which	to	constraint	syntactic conditions	4170-2
which	goes on	action	syntactic conditions	4170-2
which	present	action	syntactic conditions	4170-2
syntactic conditions	on	constraint	rules	4170-2
rules		sequential	that	4170-2
that	ensure	action	Church	4170-2
Church		sequential	Rosser	4170-2
Rosser		sequential	the property	4170-2
the property	for	constraint	rule bases	4170-2
rule bases		sequential	that	4170-2
that	are	attribute	not necessarily monotonic	4170-2
There	is	attribute	a vast amount	4171-1
a vast amount	of	constraint	literature	4171-1
literature	on	constraint	temporal databases	4171-1
The volume		sequential	TCG+93	4171-2
TCG+93	provides	action	a survey	4171-2
a survey	of	constraint	current research	4171-2
current research	in	constraint	the area	4171-2
<B>	In	constraint	several temporal extensions	4171-3
several temporal extensions	of	constraint	SQL	4171-3
SQL	can be found	action	<B>	4171-3
Bibliographies	on	constraint	temporal databases	4171-4
temporal databases	in	constraint	<B>	4171-4
temporal databases	are provided	action	<B>	4171-4
Specification	of	constraint	transition constraints	4172-1
transition constraints	by	constraint	pre-	4172-1
pre-	and	conjunctive	postconditions	4172-1
postconditions	in	constraint	CCF82	4172-1
postconditions	is studied	action	CCF82	4172-1
CCF82		sequential	CF84	4172-1
Transition constraints	on	constraint	a dynamic version	4172-2
Transition constraints	based	action	a dynamic version	4172-2
a dynamic version	of	constraint	functional dependencies	4172-2
functional dependencies	in	constraint	Via87	4172-2
functional dependencies	are investigated	action	Via87	4172-2
Via87		sequential	the interaction	4172-2
the interaction	between	constraint	fd	4172-2
the interaction	and	conjunctive	fd	4172-2
fd	where is discussed	action	<B>	4172-2
Constraints	of	constraint	a computational flavor	4173-1
a computational flavor	on	constraint	sequences	4173-1
sequences	of	constraint	objects	4173-1
objects		sequential	object histories	4173-1
object histories	in	constraint	Gin93	4173-1
object histories	are considered	action	Gin93	4173-1
Temporal constraints	by	constraint	regular languages	4173-2
Temporal constraints	specified	action	regular languages	4173-2
regular languages	of	constraint	events	4173-2
events		sequential	the events	4173-2
the events	to	constraint	object migration	4173-2
the events	where refer	action	object migration	4173-2
object migration	in	constraint	object	4173-2
object	oriented	action	databases	4173-2
databases	in	constraint	Su92	4173-2
databases	are studied	action	Su92	4173-2
References		sequential	Cho92a	4174-1
Cho92a		sequential	LS87	4174-1
LS87	develop	action	the approach	4174-1
the approach	of	constraint	checking	4174-1
checking	of	constraint	temporal constraints	4174-1
temporal constraints	as	constraint	Example 22.6.5	4174-1
temporal constraints	in	constraint	Example 22.6.5	4174-1
temporal constraints	illustrated	action	Example 22.6.5	4174-1
This technique	to	constraint	real time	4174-2
This technique	is applied	action	real time	4174-2
This technique	testing	action	real time	4174-2
real time		sequential	temporal constraints	4174-2
temporal constraints	in	constraint	Cho92	4174-2
Cho92		sequential	b	4174-2
b	providing	action	one approach	4174-2
one approach	to	constraint	complex events	4174-2
one approach	monitoring	action	complex events	4174-2
complex events	in	constraint	an active database system	4174-2
Temporal databases	to	constraint	temporal logic	4175-1
Temporal databases	are	attribute	intimately related	4175-1
Informative overviews	of	constraint	temporal logic	4175-2
temporal logic	in	constraint	Eme91	4175-2
temporal logic	can be found	action	Eme91	4175-2
Eme91		sequential	Gal87	4175-2
Exercises Exercise 22.1		sequential	Exercises Exercise 22.1	4176-1
Exercise		sequential	22.2	4177-1
Exercise		sequential	22.3	4178-1
<B>	Characterize	action	the portion	4178-2
the portion	of	constraint	CALC	4178-2
CALC	or	conjunctive	ALG	4178-2
ALG	by	constraint	IDM transactions	4178-2
Exercise		sequential	22.4 transaction	4179-1
22.4 transaction	of	constraint	the form td	4179-1
the form td		sequential	tm	4179-1
tm		sequential	ti	4179-1
ti		sequential	td	4179-1
td	is	attribute	where a sequence	4179-1
where a sequence	of	constraint	deletions	4179-1
deletions		sequential	tm	4179-1
tm	is	attribute	a sequence	4179-1
a sequence	of	constraint	modifications	4179-1
modifications	and	conjunctive	ti	4179-1
ti	is	attribute	a sequence	4179-1
a sequence	of	constraint	insertions	4179-1
Exercise		sequential	22.7	4180-1
Exercises		sequential	Exercises	4181-1
<B>	completely empties	action	the database	4182-1
the database	to	constraint	a change	4182-1
the database	make	action	a change	4182-1
a change	involving	action	only one student	4182-1
Exercise		sequential	22.8	4182-2
Exercise		sequential	22.9	4183-1
22.9	Prove	action	the statements	4183-1
the statements	in	constraint	Example 22.2.4	4183-1
Exercise		sequential	22.13	4184-1
Exercise		sequential	22.14	4185-1
<B>	that	constraint	the approach	4185-2
<B>	Observe	action	the approach	4185-2
the approach	to	constraint	c-tables	4185-2
the approach	updating	action	c-tables	4185-2
c-tables		sequential	model	4185-2
model	is based	action	<B>	4185-2
<B>	Given	action	a theory T	4185-3
a theory T	to	constraint	a c-table	4185-3
a theory T	corresponding	action	a c-table	4185-3
a c-table	and	conjunctive	an update	4185-3
an update	to	constraint	T	4185-3
an update	describe	action	T	4185-3
an update	change	action	T	4185-3
T	in	constraint	accordance	4185-3
accordance	with	constraint	the update	4185-3
Hint		sequential	Hint	4185-4
Exercise Prove Proposition 22.4.3		sequential	22.15	4186-1
Exercise		sequential	22.16	4187-1
T	like	constraint	Thus ≤T	4187-2
T	is	attribute	Thus ≤T	4187-2
Thus ≤T	except	constraint	insertions	4187-2
Thus ≤T	that	constraint	insertions	4187-2
insertions	are given	action	priority	4187-2
priority	over	constraint	deletions	4187-2
<B>	Let	action	T	4188-1
T	be	attribute	a closed theory	4188-1
a closed theory		sequential	a sentence	4188-1
a sentence	in	constraint	not T	4188-1
not T	and	conjunctive	a closed theory	4188-1
a closed theory		sequential	that	4188-1
that	accomplishes	action	<B>	4188-1
Exercise		sequential	22.17	4189-1
<B>	Exercise	action	22.18 B	4190-1
22.18 B	and	conjunctive	I	4190-1
22.18 B	let	action	I	4190-1
I	be	attribute	the instance	4190-1
the instance	of	constraint	Example 22.4.5	4190-1
Dynamic Aspects	Consider	action	the view	4191-1
the view		sequential	f	4191-1
f	over	constraint	S	4191-1
S		sequential	AB	4191-1
AB	by	constraint	πAB	4191-1
AB	defined	action	πAB	4191-1
πAB		sequential	R	4191-1
A complement	of	constraint	this view	4191-2
this view	is	attribute	πAC	4191-2
πAC		sequential	R	4191-2
The idea	of	constraint	this complement	4191-3
The idea	keeping	action	this complement	4191-3
this complement	while	constraint	the view	4191-3
this complement	updating	action	the view	4191-3
the view	by	constraint	the sentences	4191-3
the view	is captured	action	the sentences	4191-3
the sentences	Let	action	T0	4191-3
T0	be	attribute	that set	4191-3
that set	of	constraint	sentences	4191-3
<B>	Let	action	T1	4191-4
T1	include	action	the functional dependency	4191-4
the functional dependency	and	conjunctive	the unique name axioms	4191-4
<B>	Finally let	action	T2	4191-5
T2	include	action	the four atoms	4191-5
the four atoms	of	constraint	I	4191-5
Exercise		sequential	22.19	4192-1
Exercise		sequential	22.20	4193-1
R		sequential	z	4194-1
z		sequential	R	4194-1
R		sequential	x	4194-1
x		sequential	S	4194-1
S		sequential	x	4194-1
x		sequential	y	4194-1
y		sequential	z	4194-1
z		sequential	R	4194-1
R		sequential	z	4194-1
z		sequential	R	4194-1
R		sequential	y	4194-1
y		sequential	S	4194-1
S		sequential	x	4194-1
x		sequential	y	4194-1
y		sequential	z	4194-1
z		sequential	R	4194-1
R		sequential	x	4194-1
x		sequential	T	4194-1
T		sequential	x	4194-1
<B>	that	constraint	there	4195-1
<B>	Prove	action	there	4195-1
there	is	attribute	a FOID	4195-1
a FOID	with	constraint	auxiliary relations	4195-1
auxiliary relations	for	constraint	R. Hint	4195-1
the only idb predicate	in	constraint	the body	4196-1
the only idb predicate	occurring	action	the body	4196-1
the body	if	constraint	where Rn	4196-1
the body	is	attribute	where Rn	4196-1
<B>	that	constraint	each regular chain program	4196-2
<B>	Show	action	each regular chain program	4196-2
each regular chain program	is	attribute	FOID	4196-2
FOID	with	constraint	auxiliary relations	4196-2
<B>	In	constraint	an algorithm	4196-3
<B>	describe	action	an algorithm	4196-3
an algorithm		sequential	that	4196-3
that	for	constraint	each regular chain program	4196-3
that	produces	action	each regular chain program	4196-3
each regular chain program	defining	action	a predicate R	4196-3
a predicate R		sequential	order	4196-3
order		sequential	query	4196-3
query	with	constraint	auxiliary relations	4196-3
auxiliary relations		sequential	that	4196-3
that	incrementally evaluates	action	the program	4196-3
Exercise		sequential	22.22	4197-1
Exercise		sequential	22.23	4198-1
Exercises		sequential	Exercises	4199-1
R	that	constraint	the accumulating semantics	4200-1
the accumulating semantics	than	constraint	the alternative semantics	4200-1
the accumulating semantics	is	attribute	more expressive	4200-1
Hint		sequential	Hint	4200-2
Such redundant elements	to	constraint	the alternative semantics	4201-1
Such redundant elements	are	attribute	not accessible	4201-1
<B>	Exercise	action	22.25	4202-1
22.25	Consider	action	a base schema B	4202-1
a base schema B	=	sequential	R	4202-1
a base schema B	{	sequential	R	4202-1
R		sequential	AB	4202-1
AB		sequential	}	4202-1
}	and	conjunctive	a view f	4202-1
a view f	=	sequential	πAR	4202-1
πAR	as	constraint	Example 22.3.8	4202-1
πAR	in	constraint	Example 22.3.8	4202-1
Example 22.3.8		sequential	<B>	4202-1
Exercise		sequential	22.26	4203-1
Bibliography		sequential	Bibliography	4204-1
<B>		sequential	<B>	4205-1
<B>	on	constraint	Principles	4205-2
Principles	of	constraint	Database Systems	4205-2
Database Systems		sequential	pages 79 1987	4205-2
pages 79 1987	–	sequential	86	4205-2
Technical Report		sequential	INRIA	4206-1
INRIA		sequential	1983	4206-1
Bibliography		sequential	Bibliography	4207-1
Trans		sequential	Trans	4208-1
<B>	on	constraint	Database Systems	4208-2
Database Systems		sequential	4	4208-2
4		sequential	3	4208-2
3		sequential	:297–314	4208-2
:297–314		sequential	1979	4208-2
Morgan		sequential	Kaufmann Inc.	4209-1
Kaufmann Inc.		sequential	Los Altos	4209-1
Los Altos		sequential	CA	4209-1
CA		sequential	1988	4209-1
Journal	of	constraint	Symbolic Logic	4210-1
Symbolic Logic		sequential	55	4210-1
55		sequential	1	4210-1
1		sequential	:113–150	4210-1
:113–150		sequential	1990	4210-1
Conf		sequential	Conf	4211-1
<B>	on	constraint	Very Large Data Bases	4211-2
Very Large Data Bases		sequential	pages 1	4211-2
pages 1	–	sequential	12	4211-2
12		sequential	1985	4211-2
<B>	on	constraint	Database Systems	4212-1
Database Systems		sequential	16	4212-1
16		sequential	1	4212-1
1		sequential	:1–30	4212-1
:1–30		sequential	1991	4212-1
<B>		sequential	<B>	4213-1
<B>	on	constraint	the Management	4213-2
the Management	of	constraint	Data	4213-2
Data		sequential	pages 143–153 1988	4213-2
IEEE Conf		sequential	IEEE Conf	4214-1
<B>	on	constraint	Logic	4214-2
Logic	in	constraint	Computer Science	4214-2
Computer Science		sequential	1991	4214-2
Bibliography		sequential	SIGMOD Symp	4215-1
<B>	on	constraint	the Management	4215-2
the Management	of	constraint	Data	4215-2
Data		sequential	pages 32 1993	4215-2
pages 32 1993	–	sequential	41	4215-2
<B>	on	constraint	Principles	4216-1
Principles	of	constraint	Database Systems	4216-1
Database Systems		sequential	pages 1 –9	4216-1
pages 1 –9		sequential	1982	4216-1
Workshop		sequential	WG 91 pages	4217-1
WG 91 pages		sequential	63	4217-1
63	–	sequential	74	4217-1
Springer		sequential	Verlag	4217-2
Verlag		sequential	Berlin	4217-2
Berlin		sequential	1992	4217-2
Convergence	of	constraint	sideways query evaluation	4218-1
<B>	In	constraint	Proc	4218-2
ACM Symp		sequential	ACM Symp	4218-3
<B>	on	constraint	Principles	4218-4
Principles	of	constraint	Database Systems	4218-4
Database Systems		sequential	pages 24–30 1986	4218-4
Congress		sequential	pages 580 –583	4219-1
North Holland		sequential	Amsterdam	4219-2
Amsterdam		sequential	1974	4219-2
<B>	on	constraint	Principles	4220-1
Principles	of	constraint	Programming Languages	4220-1
Programming Languages		sequential	pages 110	4220-1
pages 110	–	sequential	117	4220-1
117		sequential	1979	4220-1
J.		sequential	ACM	4221-1
ACM		sequential	36	4221-1
36		sequential	4	4221-1
4		sequential	:758–789	4221-1
:758–789		sequential	October 1989	4221-1
Bibliography		sequential	Bibliography	4222-1
<B>		sequential	<B>	4223-1
<B>	on	constraint	the Theory	4223-2
the Theory	of	constraint	Computing	4223-2
Computing		sequential	pages 209–219 1991	4223-2
Springer		sequential	Verlag	4224-1
Verlag		sequential	Berlin	4224-1
Berlin		sequential	LNCS 64 1978	4224-1
Mylopoulos		sequential	editors	4225-1
editors	On	constraint	Knowledge Base Management Systems	4225-1
Knowledge Base Management Systems		sequential	Integrating Database	4225-1
Integrating Database	and	conjunctive	AI Systems	4225-1
AI Systems		sequential	pages 165 –178	4225-1
Springer		sequential	Verlag	4225-2
Verlag		sequential	Berlin	4225-2
Berlin		sequential	1986	4225-2
Bibliography		sequential	Bibliography	4226-1
<B>	on	constraint	Database Systems September 1979	4227-1
Database Systems September 1979		sequential	4	4227-1
4		sequential	3	4227-1
3		sequential	:368–382	4227-1
Benjamin Cummings Publishing Co. 1993		sequential	Menlo Park CA	4228-1
Information	and	conjunctive	Computation	4229-1
Properties	of	constraint	acyclic database schemes	4230-1
<B>	In	constraint	Proc	4230-2
ACM SIGACT Symp		sequential	ACM SIGACT Symp	4230-3
<B>	on	constraint	the Theory	4230-4
the Theory	of	constraint	Computing	4230-4
Computing		sequential	pages 355–362 1981	4230-4
Bibliography		sequential	Bibliography	4231-1
Information	and	conjunctive	Control	4232-1
Control		sequential	67:70–90	4232-1
67:70–90		sequential	1985	4232-1
Theoretical Computer Science		sequential	10:93–105	4233-1
10:93–105		sequential	1980	4233-1
<B>	on	constraint	Very Large Data Bases	4234-1
Very Large Data Bases		sequential	pages 337–349 1991	4234-1
query optimizer		sequential	query optimizer	4235-1
<B>	In	constraint	Proc	4235-2
ACM SIGMOD Symp		sequential	ACM SIGMOD Symp	4235-3
<B>	on	constraint	the Management	4235-4
the Management	of	constraint	Data	4235-4
Data		sequential	pages 287–296 1993	4235-4
Bibliography		sequential	Bibliography	4236-1
<B>	on	constraint	Database Systems	4237-1
Database Systems		sequential	17:385–422 1993	4237-1
Bibliography		sequential	Bibliography	4238-1
<B>	In	constraint	Proc	4239-1
<B>	of	constraint	Intl	4239-2
Workshop	on	constraint	Database Programming Languages	4239-3
Database Programming Languages		sequential	pages 9 –19	4239-3
Morgan		sequential	Kaufmann Inc.	4239-4
Kaufmann Inc.		sequential	Los Altos	4239-4
Los Altos		sequential	CA	4239-4
CA		sequential	1992	4239-4
Technical Report		sequential	Department	4240-1
Department	of	constraint	Computer Science	4240-1
Computer Science		sequential	Hebrew University	4240-1
Hebrew University	of	constraint	Jerusalem	4240-1
Jerusalem		sequential	1980	4240-1
Technical Report		sequential	Department	4241-1
Department	of	constraint	Computer Science	4241-1
Computer Science		sequential	Hebrew University	4241-1
Hebrew University	of	constraint	Jerusalem	4241-1
Jerusalem		sequential	August 1980	4241-1
Conf		sequential	Conf	4242-1
<B>	on	constraint	Algorithms	4242-2
Algorithms		sequential	Languages	4242-2
Languages	and	conjunctive	Programming	4242-2
Programming		sequential	pages 73	4242-2
pages 73	–	sequential	85	4242-2
85		sequential	1981	4242-2
Springer		sequential	Verlag	4242-3
Verlag		sequential	Berlin	4242-3
Berlin		sequential	LNCS 115	4242-3
SIAM J.	on	constraint	Computing	4243-1
Computing		sequential	13	4243-1
13		sequential	1	4243-1
1		sequential	:76–98	4243-1
:76–98		sequential	1984	4243-1
<B>		sequential	<B>	4244-1
<B>	on	constraint	the Management	4244-2
the Management	of	constraint	Data	4244-2
Data		sequential	pages 225–236 1990	4244-2
<B>	Bibliography	action	their interaction	4245-1
their interaction	with	constraint	functional dependencies	4245-1
Journal	of	constraint	Computer	4245-2
Computer	and	conjunctive	System	4245-2
System		sequential	Sciences	4245-2
Sciences		sequential	28	4245-2
28		sequential	1	4245-2
1		sequential	:29–59	4245-2
:29–59		sequential	1984	4245-2
<B>	on	constraint	Foundations	4246-1
Foundations	of	constraint	Computer Science	4246-1
Computer Science		sequential	pages 333–347 1980	4246-1
<B>	In	constraint	H. Gallaire	4247-1
H. Gallaire		sequential	J. Minker	4247-1
J. Minker	and	conjunctive	J.-M. Nicolas	4247-1
J.-M. Nicolas		sequential	editors	4247-1
editors		sequential	Advances	4247-1
Advances	in	constraint	Database Theory	4247-1
Database Theory		sequential	vol	4247-1
1 pages 235 –260		sequential	1 pages 235 –260	4247-2
Plenum Press New York 1981		sequential	Plenum Press New York 1981	4247-3
Ph.D. thesis		sequential	University	4248-1
University	of	constraint	Southern California	4248-1
Southern California		sequential	Los Angeles	4248-1
Los Angeles		sequential	1994	4248-1
Conf		sequential	Conf	4249-1
<B>	on	constraint	Data Engineering	4249-2
Data Engineering		sequential	1992	4249-2
Bibliography Research		sequential	<B>	4250-1
3 The Theory pages 164–185	of	constraint	Databases	4250-2
JAI Press Inc. 1986		sequential	Greenwich CT	4250-3
Journal	of	constraint	Computer	4251-1
Computer	and	conjunctive	System	4251-1
System		sequential	Sciences	4251-1
Sciences		sequential	32	4251-1
32		sequential	2	4251-1
2		sequential	:203–233	4251-1
:203–233		sequential	1986	4251-1
SIGMOD		sequential	<B>	4252-1
<B>	on	constraint	the Management	4252-2
the Management	of	constraint	Data	4252-2
Data		sequential	1993	4252-2
Theoretical Computer Science		sequential	116	4253-1
116		sequential	1	4253-1
1		sequential	:95	4253-1
:95		sequential	–116	4253-1
–116		sequential	1993	4253-1
A preliminary version	in	constraint	the Proceedings	4253-2
A preliminary version	was published	action	the Proceedings	4253-2
the Proceedings	of	constraint	the Third International Conference	4253-2
the Third International Conference	on	constraint	Database Theory	4253-2
Database Theory		sequential	Springer	4253-2
Springer		sequential	Verlag	4253-2
Verlag		sequential	Berlin	4253-2
Berlin		sequential	LNCS 470	4253-2
LNCS 470		sequential	1990	4253-2
<B>	on	constraint	Database Systems	4254-1
Database Systems		sequential	4	4254-1
4		sequential	4	4254-1
4		sequential	:397–434	4254-1
:397–434		sequential	1979	4254-1
Bibliography		sequential	Bibliography	4255-1
<B>	on	constraint	the Management	4256-1
the Management	of	constraint	Data	4256-1
Data		sequential	pages 225 –234	4256-1
pages 225 –234		sequential	1989	4256-1
The algres project		sequential	The algres project	4257-1
<B>	In	constraint	Proc	4257-2
<B>	of	constraint	Intl	4257-3
Conf		sequential	Conf	4257-4
<B>	on	constraint	Data Base Technology	4257-5
<B>	Extending	action	Data Base Technology	4257-5
Springer		sequential	Verlag	4257-6
Verlag		sequential	Berlin	4257-6
Berlin		sequential	1988	4257-6
Conf		sequential	Conf	4258-1
<B>	on	constraint	Theory June 1981	4258-2
Theory June 1981	of	constraint	Relational Databases	4258-2
Relational Databases		sequential	Pennsylvania State University	4258-2
<B>		sequential	<B>	4259-1
<B>	on	constraint	Principles	4259-2
Principles	of	constraint	Database Systems	4259-2
Database Systems		sequential	pages 55 1992	4259-2
pages 55 1992	–	sequential	66	4259-2
<B>		sequential	<B>	4260-1
<B>	on	constraint	Principles	4260-2
Principles	of	constraint	Database Systems	4260-2
Database Systems		sequential	pages 59 1993	4260-2
pages 59 1993	–	sequential	70	4260-2
Bibliography		sequential	Bibliography	4261-1
<B>	In	constraint	Proc	4262-1
<B>	of	constraint	the Joint Intl	4262-2
Conf		sequential	Conf	4262-3
<B>	and	conjunctive	<B>	4262-4
<B>	on	constraint	Logic Programming	4262-5
Logic Programming		sequential	pages 589–606 1992	4262-5
Trans		sequential	Trans	4263-1
<B>	on	constraint	Database Systems	4263-2
Database Systems		sequential	3	4263-2
3		sequential	3	4263-2
3		sequential	:201–222	4263-2
:201–222		sequential	1978	4263-2
Technical Report ONERA–CERT		sequential	Toulouse	4264-1
Toulouse		sequential	1982	4264-1
<B>	of	constraint	Intl	4265-1
Conf		sequential	Conf	4265-2
<B>	on	constraint	Very Large Data Bases	4265-3
Very Large Data Bases		sequential	pages 113 –122	4265-3
pages 113 –122		sequential	1991	4265-3
Bibliography		sequential	Bibliography	4266-1
<B>	In	constraint	Proc	4267-1
ACM Symp		sequential	ACM Symp	4267-2
<B>	on	constraint	Principles	4267-3
Principles	of	constraint	Database Systems	4267-3
Database Systems		sequential	pages 81–90 1992	4267-3
Math		sequential	Math	4268-1
Logik und Grundlagen d. Math		sequential	Logik und Grundlagen d. Math	4268-2
33:47–63 1987		sequential	33:47–63 1987	4268-3
<B>	In	constraint	Proc	4269-1
<B>	of	constraint	Intl	4269-2
Workshop	on	constraint	Database Programming Languages	4269-3
Database Programming Languages		sequential	1993	4269-3
Technical Report 1993		sequential	Department	4270-1
Department	of	constraint	Computer Science	4270-1
Computer Science		sequential	University	4270-1
University	of	constraint	Melbourne	4270-1
Melbourne		sequential	Australia	4270-1
<B>	To	constraint	Annals	4271-1
<B>	in	constraint	Annals	4271-1
<B>	appear	action	Annals	4271-1
Annals	of	constraint	Mathematics	4271-1
Mathematics	and	conjunctive	Artificial Intelligence	4271-1
<B>		sequential	<B>	4272-1
<B>	on	constraint	Principles	4272-2
Principles	of	constraint	Database Systems	4272-2
Database Systems		sequential	pages 265–275 1993	4272-2
<B>	In	constraint	Proc	4273-1
<B>	of	constraint	the Symposium	4273-2
the Symposium	on	constraint	Logic Programming 1987	4273-2
<B>		sequential	<B>	4274-1
<B>	on	constraint	Principles	4274-2
Principles	of	constraint	Database Systems	4274-2
Database Systems		sequential	pages 267–278 1994	4274-2
Bibliography		sequential	Bibliography	4275-1
Trans		sequential	Trans	4276-1
<B>	on	constraint	Database Systems	4276-2
Database Systems		sequential	2:262–278	4276-2
2:262–278		sequential	1977	4276-2
<B>	on	constraint	the Management	4277-1
the Management	of	constraint	Data	4277-1
Data		sequential	pages 153 –160	4277-1
pages 153 –160		sequential	1979	4277-1
Trans		sequential	Trans	4278-1
<B>	on	constraint	Database Systems	4278-2
Database Systems		sequential	6	4278-2
6		sequential	3	4278-2
3		sequential	:387–415	4278-2
:387–415		sequential	1981	4278-2
Press 1995		sequential	Cambridge MA	4279-1
Bibliography		sequential	Bibliography	4280-1
JAI Press Inc. 1986		sequential	Greenwich CT	4281-1
SIAM J.	on	constraint	Computing	4282-1
Computing		sequential	12	4282-1
12		sequential	1	4282-1
1		sequential	:36–59	4282-1
:36–59		sequential	1983	4282-1
<B>		sequential	<B>	4283-1
<B>	on	constraint	the Management	4283-2
the Management	of	constraint	Data	4283-2
Data		sequential	pages 160	4283-2
pages 160	–	sequential	172	4283-2
172		sequential	1987	4283-2
Bibliography	to	constraint	the nested relational algebra	4284-1
Bibliography	constructs	action	the nested relational algebra	4284-1
<B>	In	constraint	Proc	4284-2
ACM SIGMOD Symp		sequential	ACM SIGMOD Symp	4284-3
<B>	on	constraint	the Management	4284-4
the Management	of	constraint	Data	4284-4
Data		sequential	pages 225 –232	4284-4
pages 225 –232		sequential	1988	4284-4
Workshop	on	constraint	Deductive Databases	4285-1
Deductive Databases		sequential	1992	4285-1
<B>	on	constraint	Logic Programming	4286-1
Logic Programming		sequential	pages 1070	4286-1
pages 1070	–	sequential	1080	4286-1
1080		sequential	1988	4286-1
Bibliography problems	for	constraint	database logic programs	4287-1
<B>	In	constraint	Proc	4287-2
IEEE Conf		sequential	IEEE Conf	4287-3
<B>	on	constraint	Logic	4287-4
Logic	in	constraint	Computer Science	4287-4
Computer Science		sequential	pages 106–115 1987	4287-4
J.		sequential	ACM	4288-1
ACM		sequential	33	4288-1
33		sequential	1	4288-1
1		sequential	:105–129	4288-1
:105–129		sequential	1986	4288-1
<B>	on	constraint	Principles	4289-1
Principles	of	constraint	Database Systems	4289-1
Database Systems		sequential	pages 58–69 1987	4289-1
Journal	of	constraint	Computer	4290-1
Computer	and	conjunctive	System	4290-1
System		sequential	Sciences	4290-1
Sciences		sequential	28	4290-1
28		sequential	1	4290-1
1		sequential	:60–79	4290-1
:60–79		sequential	1984	4290-1
Technique		sequential	et	4291-1
et		sequential	Science Informatiques	4291-1
Science Informatiques		sequential	6	4291-1
6		sequential	5	4291-1
5		sequential	1987	4291-1
Bibliography		sequential	Bibliography	4292-1
<B>	on	constraint	the Management	4293-1
the Management	of	constraint	Data	4293-1
Data		sequential	pages 358–366 1989	4293-1
Williams		sequential	editors	4294-1
editors		sequential	Encyclopedia	4294-1
Encyclopedia	of	constraint	Computer Science	4294-1
Computer Science	and	conjunctive	Technology	4294-1
Technology		sequential	Vol	4294-1
27		sequential	Supplement	4294-2
Supplement		sequential	12	4294-2
Marcel Dekker		sequential	New York 1993	4295-1
Bibliography		sequential	Bibliography	4296-1
February 24 1992		sequential	February 24 1992	4297-1
<B>	on	constraint	Principles	4298-1
Principles	of	constraint	Database Systems	4298-1
Database Systems		sequential	pages 244–252 1993	4298-1
Springer		sequential	Verlag	4299-1
Verlag		sequential	Berlin	4299-1
Berlin		sequential	LNCS	4299-1
LNCS		sequential	504	4299-1
504		sequential	1991	4299-1
<B>		sequential	<B>	4300-1
Proc		sequential	Proc	4300-2
Letters		sequential	10	4300-3
10		sequential	1	4300-3
1		sequential	:14–19	4300-3
:14–19		sequential	1980	4300-3
<B>	on	constraint	Principles	4301-1
Principles	of	constraint	Database Systems	4301-1
Database Systems		sequential	pages 347–359	4301-1
pages 347–359		sequential	March 1989	4301-1
Bibliography		sequential	Bibliography	4302-1
Technical Report		sequential	RJ 9023	4303-1
RJ 9023		sequential	80483	4303-1
80483		sequential	IBM Almaden Research October 1992	4303-1
Bibliography		sequential	Bibliography	4304-1
Workshop	on	constraint	Database Programming Languages	4305-1
Database Programming Languages		sequential	pages 416–428 1991	4305-1
Bibliography		sequential	Bibliography	4306-1
<B>	To	constraint	Springer	4307-1
<B>	in	constraint	Springer	4307-1
<B>	appear	action	Springer	4307-1
Springer		sequential	Verlag	4307-1
Verlag		sequential	Berlin	4307-1
Berlin		sequential	editor	4307-1
editor		sequential	Proc	4307-1
2nd Conference	on	constraint	Theoretical Aspects	4307-2
Theoretical Aspects	of	constraint	Computer Software	4307-2
Computer Software		sequential	TACS	4307-2
TACS		sequential	1994	4307-2
<B>		sequential	<B>	4308-1
<B>	on	constraint	Principles	4308-2
Principles	of	constraint	Database Systems	4308-2
Database Systems		sequential	pages 299–313	4308-2
pages 299–313		sequential	Nashville	4308-2
Nashville		sequential	1990	4308-2
SIGMOD		sequential	<B>	4309-1
<B>	on	constraint	the Management	4309-2
the Management	of	constraint	Data	4309-2
Data		sequential	pages 393–402 1992	4309-2
Conf		sequential	Conf	4310-1
<B>	on	constraint	Database Theory	4310-2
Database Theory		sequential	1986	4310-2
<B>	on	constraint	Data	4311-1
Data	and	conjunctive	Knowledge	4311-1
Knowledge		sequential	Bases	4311-1
Bases		sequential	pages 416–424	4311-1
Morgan		sequential	Kaufmann Inc.	4311-2
Kaufmann Inc.		sequential	Los Altos	4311-2
Los Altos		sequential	CA	4311-2
CA		sequential	1988	4311-2
Bibliography		sequential	Bibliography	4312-1
<B>	on	constraint	Principles	4313-1
Principles	of	constraint	Database Systems	4313-1
Database Systems		sequential	pages 231–239 1988	4313-1
SIGMOD		sequential	<B>	4314-1
<B>	on	constraint	the Management	4314-2
the Management	of	constraint	Data	4314-2
Data		sequential	pages 143–148 1984	4314-2
Bibliography		sequential	Bibliography	4315-1
<B>	In	constraint	Proc	4316-1
ACM Symp		sequential	ACM Symp	4316-2
<B>	on	constraint	Principles	4316-3
Principles	of	constraint	Database Systems	4316-3
Database Systems		sequential	pages 61 –71	4316-3
pages 61 –71		sequential	1990	4316-3
Theoretical Computer Science 116:33 –58 1993		sequential	Theoretical Computer Science 116:33 –58 1993	4317-1
Technical Report CMU-CS-89-212		sequential	Mellon	4318-1
Mellon		sequential	Carnegie University	4318-1
Carnegie University		sequential	1989	4318-1
Springer		sequential	Verlag	4319-1
Verlag		sequential	Berlin	4319-1
Berlin		sequential	1984	4319-1
Springer		sequential	Verlag	4320-1
Verlag		sequential	Berlin	4320-1
Berlin		sequential	1991	4320-1
Bibliography		sequential	Bibliography	4321-1
Trans		sequential	Trans	4322-1
<B>	on	constraint	Database Systems	4322-2
Database Systems		sequential	4	4322-2
4		sequential	3	4322-2
3		sequential	:262–296	4322-2
:262–296		sequential	1979	4322-2
Joint Conf		sequential	Joint Conf	4323-1
<B>	on	constraint	Artificial Intelligence	4323-2
Artificial Intelligence		sequential	pages 173–177 1985	4323-2
MIT Press 1992		sequential	Cambridge MA	4324-1
SIGMOD		sequential	<B>	4325-1
<B>	on	constraint	the Management	4325-2
the Management	of	constraint	Data	4325-2
Data		sequential	pages 424–434 1988	4325-2
Bibliography		sequential	Bibliography	4326-1
Workshop	on	constraint	Database Programming Languages	4327-1
Database Programming Languages		sequential	pages 97–114 1993	4327-1
<B>	of	constraint	Intl	4328-1
Conf		sequential	Conf	4328-2
<B>	on	constraint	Database Theory	4328-3
Database Theory		sequential	1986	4328-3
Natl		sequential	Natl	4329-1
Conf		sequential	Conf	4329-2
<B>	on	constraint	Artificial Intelligence	4329-3
Artificial Intelligence		sequential	1992	4329-3
Information	and	conjunctive	Control	4330-1
Control		sequential	56:154–173	4330-1
56:154–173		sequential	1983	4330-1
<B>		sequential	<B>	4331-1
<B>	on	constraint	Principles	4331-2
Principles	of	constraint	Database Systems	4331-2
Database Systems		sequential	pages 58–69 1983	4331-2
Bibliography		sequential	Bibliography	4332-1
<B>	In	constraint	Proc	4333-1
<B>	of	constraint	Intl	4333-2
Conf		sequential	Conf	4333-3
<B>	on	constraint	Very Large Data Bases	4333-4
Very Large Data Bases		sequential	pages 34 1983	4333-4
pages 34 1983	–	sequential	42	4333-4
<B>		sequential	<B>	4334-1
<B>	on	constraint	Principles	4334-2
Principles	of	constraint	Database Systems	4334-2
Database Systems		sequential	pages 245–250 1985	4334-2
Logic Programming 1990		sequential	Logic Programming 1990	4335-1
Bibliography		sequential	Bibliography	4336-1
Benjamin Cummings Publishing Co. 1988		sequential	Menlo Park CA	4337-1
<B>	on	constraint	Principles	4338-1
Principles	of	constraint	Database Systems	4338-1
Database Systems		sequential	pages 267–279 1986	4338-1
<B>		sequential	<B>	4339-1
<B>	on	constraint	Principles	4339-2
Principles	of	constraint	Database Systems	4339-2
Database Systems		sequential	1988	4339-2
<B>	on	constraint	Principles	4340-1
Principles	of	constraint	Database Systems	4340-1
Database Systems		sequential	pages 227–236 1987	4340-1
<B>	on	constraint	Database Systems	4341-1
Database Systems		sequential	12	4341-1
12		sequential	1	4341-1
1		sequential	111–136	4341-1
111–136		sequential	1987	4341-1
Bibliography		sequential	Bibliography	4342-1
Information Sciences		sequential	47:339–372	4343-1
47:339–372		sequential	1989	4343-1
<B>		sequential	<B>	4344-1
<B>	on	constraint	Principles	4344-2
Principles	of	constraint	Database Systems	4344-2
Database Systems		sequential	1994	4344-2
Fundamenta Informaticae		sequential	XIII :445–463 1990	4345-1
Bibliography		sequential	Bibliography	4346-1
IEEE Trans		sequential	IEEE Trans	4347-1
<B>	on	constraint	Knowledge	4347-2
Knowledge	and	conjunctive	Data	4347-2
Data		sequential	Engineering	4347-2
Engineering		sequential	3:337–341	4347-2
3:337–341		sequential	1991	4347-2
Logic Programming		sequential	11:189–216	4348-1
11:189–216		sequential	1991	4348-1
<B>	See also	action	Proc	4348-2
Joint Symp		sequential	Joint Symp	4348-3
<B>	and	conjunctive	<B>	4348-4
Conf		sequential	Conf	4348-5
<B>	on	constraint	Logic Programming	4348-6
Logic Programming		sequential	1988	4348-6
Technical Report RJ1220		sequential	IBM Res	4349-1
Lab		sequential	San Jose	4349-2
San Jose		sequential	CA	4349-2
CA		sequential	1975	4349-2
Springer		sequential	Verlag	4350-1
Verlag		sequential	Berlin	4350-1
Berlin		sequential	1984	4350-1
Bibliography		sequential	Bibliography	4351-1
SIGMOD		sequential	<B>	4352-1
<B>	on	constraint	the Management	4352-2
the Management	of	constraint	Data	4352-2
Data		sequential	pages 71	4352-2
pages 71	–	sequential	81	4352-2
81		sequential	1979	4352-2
<B>	In	constraint	Proc	4353-1
<B>	of	constraint	Intl	4353-2
Conf		sequential	Conf	4353-3
<B>	on	constraint	Very Large Data Bases	4353-4
Very Large Data Bases		sequential	1992	4353-4
<B>		sequential	<B>	4354-1
<B>	on	constraint	the Management	4354-2
the Management	of	constraint	Data	4354-2
Data		sequential	pages 108 –120	4354-2
pages 108 –120		sequential	1981	4354-2
Bibliography		sequential	Bibliography	4355-1
Conf		sequential	Conf	4356-1
<B>	on	constraint	Management	4356-2
Management	of	constraint	Data	4356-2
Data		sequential	ICMOD	4356-2
ICMOD		sequential	Milan	4356-2
Milan		sequential	Italy	4356-2
Italy		sequential	1978	4356-2
<B>	on	constraint	Principles	4357-1
Principles	of	constraint	Database Systems	4357-1
Database Systems		sequential	pages 237–249 1987	4357-1
Bibliography		sequential	Bibliography	4358-1
<B>	In	constraint	Proc	4359-1
ACM Symp		sequential	ACM Symp	4359-2
<B>	on	constraint	Principles	4359-3
Principles	of	constraint	Database Systems	4359-3
Database Systems		sequential	pages 160	4359-3
pages 160	–	sequential	172	4359-3
172		sequential	1986	4359-3
<B>		sequential	<B>	4360-1
<B>	on	constraint	Principles	4360-2
Principles	of	constraint	Database Systems	4360-2
Database Systems		sequential	pages 160	4360-2
pages 160	–	sequential	172	4360-2
172		sequential	1989	4360-2
Theoretical Computer Science		sequential	62:187–220	4361-1
62:187–220		sequential	1988	4361-1
Technical Report		sequential	CS	4362-1
CS	-	sequential	89	4362-1
89	-	sequential	42	4362-1
42		sequential	Computer Science Department	4362-1
Computer Science Department		sequential	Brown University	4362-1
Brown University		sequential	1989	4362-1
Bibliography		sequential	Bibliography	4363-1
SIGMOD		sequential	<B>	4364-1
<B>	on	constraint	the Management	4364-2
the Management	of	constraint	Data	4364-2
Data		sequential	pages 155 –165	4364-2
pages 155 –165		sequential	1986	4364-2
Bibliography completeness	of	constraint	object	4365-1
object	creating	action	query languages	4365-1
<B>	In	constraint	IEEE Conf	4365-2
<B>	on	constraint	Foundations	4365-3
Foundations	of	constraint	Computer Science	4365-3
Computer Science		sequential	pages 372–379 1992	4365-3
<B>		sequential	<B>	4366-1
<B>	on	constraint	Principles	4366-2
Principles	of	constraint	Database Systems	4366-2
Database Systems		sequential	pages 1	4366-2
pages 1	–	sequential	11	4366-2
11		sequential	1989	4366-2
Trans		sequential	Trans	4367-1
<B>	on	constraint	Database Systems	4367-2
Database Systems		sequential	16:235–278	4367-2
16:235–278		sequential	1991	4367-2
<B>	on	constraint	the Theory	4368-1
the Theory	of	constraint	Computing	4368-1
Computing		sequential	pages 137–146 1982	4368-1
<B>		sequential	<B>	4369-1
<B>	on	constraint	Principles	4369-2
Principles	of	constraint	Database Systems	4369-2
Database Systems		sequential	pages 252–266 1986	4369-2
thesis		sequential	University	4370-1
University	of	constraint	Toronto	4370-1
Toronto		sequential	1980	4370-1
Bibliography		sequential	Bibliography	4371-1
<B>	In	constraint	Proc	4372-1
ACM SIGMOD Symp		sequential	ACM SIGMOD Symp	4372-2
<B>	on	constraint	the Management	4372-3
the Management	of	constraint	Data	4372-3
Data		sequential	pages 259 –264	4372-3
pages 259 –264		sequential	1990	4372-3
Computer		sequential	25	4373-1
25		sequential	3	4373-1
3		sequential	:38–49	4373-1
:38–49		sequential	March 1992	4373-1
<B>		sequential	<B>	4374-1
<B>	on	constraint	Principles	4374-2
Principles	of	constraint	Database Systems	4374-2
Database Systems		sequential	pages 224–234 1986	4374-2
<B>		sequential	<B>	4375-1
<B>	and	conjunctive	<B>	4375-2
<B>	Develop	action	<B>	4375-2
19:71–77 1975		sequential	19:71–77 1975	4375-3
Bibliography		sequential	Bibliography	4376-1
<B>	on	constraint	Database Systems	4377-1
Database Systems		sequential	1	4377-1
1		sequential	3	4377-1
3		sequential	:223–241	4377-1
:223–241		sequential	1976	4377-1
thesis		sequential	University	4378-1
University	of	constraint	California	4378-1
California	at	constraint	Los Angeles	4378-1
Los Angeles		sequential	1976	4378-1
Technical Report		sequential	UCLA	4378-2
UCLA		sequential	Eng -7669	4378-2
Eng -7669		sequential	Department	4378-2
Department	of	constraint	Computer Science	4378-2
<B>	on	constraint	Database Systems	4379-1
Database Systems		sequential	7:489–499	4379-1
7:489–499		sequential	1982	4379-1
Morgan		sequential	Kaufmann Inc.	4380-1
Kaufmann Inc.		sequential	Los Altos	4380-1
Los Altos		sequential	CA	4380-1
CA		sequential	1990	4380-1
Index Page numbers	in	constraint	italics	4381-1
italics	indicate	action	the location	4381-1
the location	of	constraint	definitions	4381-1
definitions	of	constraint	terms	4381-1
composite event		sequential	606 condition	4382-1
606 condition		sequential	601	4382-1
601	in	constraint	query language	4382-1
query language		sequential	155 coupling mode	4382-1
155 coupling mode		sequential	603 ECA	4382-1
603 ECA		sequential	601 event	4382-1
601 event		sequential	601 execution model	4382-1
601 execution model		sequential	601	4382-1
601		sequential	603–606 concurrent firing	4382-1
603–606 concurrent firing		sequential	603 deferred firing	4382-1
603 deferred firing		sequential	603	4382-1
603		sequential	604 complex value	4382-1
604 complex value		sequential	514	4382-1
514		sequential	519 immediate firing	4382-1
519 immediate firing		sequential	603–604 conjunctive	4382-1
603–604 conjunctive		sequential	52–61 rule	4382-1
52–61 rule		sequential	96	4382-1
96		sequential	103 rule base	4382-1
103 rule base		sequential	601	4382-1
601	named	attribute	conjunctive	4382-1
56	–	sequential	59	4382-1
59		sequential	57	4382-1
57	vs.	constraint	expert system	4382-1
expert system		sequential	600 nested relation	4382-1
600 nested relation		sequential	519	4382-1
519		sequential	28	4382-1
28		sequential	35	4382-1
35		sequential	36	4382-1
36		sequential	64	4382-1
64		sequential	70	4382-1
70		sequential	71	4382-1
71		sequential	interpretation	4382-1
interpretation		sequential	79 preservation	4382-1
79 preservation		sequential	249	4382-1
249	named	attribute	71 unnamed	4382-1
71	of	constraint	relational calculus	4382-1
relational calculus		sequential	74	4382-1
74		sequential	79 translation	4382-1
79 translation	into	constraint	calculus	4382-1
calculus		sequential	80	4382-1
80	vs.	constraint	domain independence	4382-1
domain independence		sequential	79 SPC	4382-1
79 SPC		sequential	52–56	4382-1
52–56		sequential	54 SPCU	4382-1
54 SPCU		sequential	62	4382-1
62		sequential	222	4382-1
222	vs.	constraint	dependencies	4382-1
dependencies		sequential	137 SPJR	4382-1
137 SPJR		sequential	56–59	4382-1
56–59		sequential	57 distributed databases	4382-1
57 distributed databases		sequential	136 SPJRU	4382-1
136 SPJRU		sequential	62 hypergraph	4382-1
62 hypergraph		sequential	36	4382-1
36		sequential	132 SPJU	4382-1
132 SPJU		sequential	492 inclusion dependencies	4382-1
492 inclusion dependencies		sequential	208–210	4382-1
208–210		sequential	211 typed restricted SPJ	4382-1
211 typed restricted SPJ		sequential	64	4382-1
64		sequential	67	4382-1
67		sequential	join	4382-1
join		sequential	105	4382-1
105		sequential	126	4382-1
126		sequential	128–135	4382-1
128–135		sequential	52 –56	4382-1
52 –56		sequential	52 join dependency	4382-1
52 join dependency		sequential	169	4382-1
169		sequential	182–183	4382-1
182–183		sequential	103 Index	4382-1
103 Index	for	constraint	full typed dependencies	4382-1
full typed dependencies		sequential	227–228	4382-1
227–228		sequential	Gentzen	4382-1
Gentzen		sequential	style	4382-1
style	for	constraint	jd	4382-1
jd		sequential	s	4382-1
s		sequential	186 IDM transaction	4382-1
186 IDM transaction	for	constraint	581	4382-1
581	for	constraint	inds	4382-1
inds		sequential	193–195	4382-1
193–195		sequential	211 k-ary	4382-1
211 k-ary		sequential	202	4382-1
202		sequential	204 proof	4382-1
204 proof	using	action	167 nonlinear version	4382-1
167 nonlinear version	using	action	167 sound	4382-1
167 sound		sequential	167 deletion	4382-1
167 deletion		sequential	162	4382-1
162		sequential	254	4382-1
254	for	constraint	typed embedded dependencies	4382-1
typed embedded dependencies		sequential	226	4382-1
226		sequential	235 insertion	4382-1
235 insertion		sequential	162	4382-1
162	for	constraint	uinds	4382-1
uinds		sequential	210	4382-1
210		sequential	215 modification	4382-1
215 modification		sequential	162	4382-1
162	for	constraint	uinds	4382-1
uinds	and	conjunctive	fds	4382-1
fds		sequential	210 update	4382-1
210 update		sequential	162	4382-1
162	vs.	constraint	fds	4382-1
fds	and	conjunctive	inds	4382-1
inds		sequential	192	4382-1
192		sequential	202–207	4382-1
202–207		sequential	211	4382-1
211	vs.	constraint	fds	4382-1
fds	and	conjunctive	sort set dependencies	4382-1
sort set dependencies		sequential	213	4382-1
213	vs.	constraint	finite implication	4382-1
finite implication		sequential	226	4382-1
226	vs.	constraint	jd	4382-1
jd		sequential	s	4382-1
s		sequential	169	4382-1
169		sequential	171	4382-1
171		sequential	186 B	4382-1
186 B		sequential	P	4382-1
P		sequential	I	4382-1
I		sequential	280 B	4382-1
280 B		sequential	PI	4382-1
PI		sequential	387 B	4382-1
387 B		sequential	tree	4382-1
tree		sequential	107 bag	4382-1
107 bag		sequential	92	4382-1
92		sequential	136	4382-1
136	of	constraint	instance	4382-1
instance		sequential	32	4382-1
32	in	constraint	SQL	4382-1
SQL		sequential	145	4382-1
145		sequential	155	4382-1
155	of	constraint	relation name	4382-1
relation name		sequential	31	4382-1
31		sequential	BCNF	4382-1
BCNF		sequential	250	4382-1
250		sequential	251	4382-1
251	–	sequential	252	4382-1
252	of	constraint	tuple	4382-1
tuple		sequential	32 belief revision	4382-1
32 belief revision		sequential	588	4382-1
588		sequential	599	4382-1
599	for	constraint	typed dependencies	4382-1
typed dependencies		sequential	131	4382-1
131		sequential	Schönfinkel	4382-1
Schönfinkel		sequential	137 Bernays class	4382-1
137 Bernays class		sequential	219 Binary Data Model	4382-1
219 Binary Data Model		sequential	264 binary relation	4382-1
264 binary relation		sequential	10 body	4382-1
10 body	of	constraint	rule	4382-1
rule		sequential	39	4382-1
39		sequential	41	4382-1
41		sequential	276 constraint	4382-1
276 constraint		sequential	112 bottom	4382-1
112 bottom	up	constraint	datalog evaluation	4382-1
datalog evaluation		sequential	324–335 equality	4382-1
324–335 equality		sequential	217	4382-1
217	vs.	constraint	top-	4382-1
top-		sequential	311	4382-1
311		sequential	327	4382-1
327		sequential	336 ground	4382-1
336 ground		sequential	34 bound coordinate	4382-1
34 bound coordinate	in	constraint	datalog evaluation	4382-1
datalog evaluation		sequential	318 relation	4382-1
318 relation		sequential	112	4382-1
112		sequential	217 bound variable occurrence	4382-1
217 bound variable occurrence		sequential	23	4382-1
23		sequential	45	4382-1
45		sequential	75 boundedness	4382-1
75 boundedness		sequential	285	4382-1
285		sequential	304 Boyce	4382-1
304 Boyce		sequential	Codd normal form	4382-1
Codd normal form		sequential	BCNF	4382-1
BCNF		sequential	250	4382-1
250		sequential	251–252	4382-1
251–252	in	constraint	relational model	4382-1
relational model		sequential	30 BP	4382-1
30 BP		sequential	completeness	4382-1
completeness		sequential	428	4382-1
428		sequential	560	4382-1
560	in	constraint	semantic data model	4382-1
semantic data model		sequential	243 buffering	4382-1
243 buffering	of	constraint	main memory	4382-1
main memory		sequential	106	4382-1
106		sequential	107	4382-1
107		sequential	C	4382-1
C		sequential	genericity	4382-1
genericity		sequential	419 –420 C+SQL	4382-1
419 –420 C+SQL		sequential	466 c-table	4382-1
466 c-table		sequential	493	4382-1
493	vs.	constraint	inference rule	4382-1
inference rule		sequential	167 update	4382-1
167 update		sequential	593–594 CALC adom	4382-1
593–594 CALC adom		sequential	79	4382-1
79		sequential	80	4382-1
80		sequential	100 CALCdi	4382-1
100 CALCdi		sequential	79	4382-1
79		sequential	80 CALCsr	4382-1
80 CALCsr		sequential	81	4382-1
81		sequential	86	4382-1
86		sequential	100	4382-1
100	for	constraint	algebraic dependencies	4382-1
algebraic dependencies		sequential	231	4382-1
231		sequential	235 CALC +µ	4382-1
235 CALC +µ		sequential	348–352 349	4382-1
348–352 349		sequential	167 normal form	4382-1
167 normal form		sequential	368	4382-1
368	for	constraint	fd	4382-1
fd		sequential	s	4382-1
s		sequential	166	4382-1
166		sequential	168	4382-1
168		sequential	186 simultaneous induction	4382-1
186 simultaneous induction		sequential	351	4382-1
351	for	constraint	fd	4382-1
fd		sequential	s	4382-1
s	and	conjunctive	mvd s	4382-1
mvd s		sequential	172–173	4382-1
172–173		sequential	186	4382-1
186		sequential	CALC +µ+	4382-1
CALC +µ+		sequential	352–354	4382-1
352–354		sequential	353	4382-1
353		sequential	202 normal form	4382-1
202 normal form		sequential	368 Index CALC +µ	4382-1
368 Index CALC +µ	+	sequential	<B>	4382-1
<B>	See	action	datalog¬	4382-2
datalog¬		sequential	negation	4382-2
negation	as of	constraint	query languages	4382-2
query languages		sequential	136 failure	4382-2
composition	of	constraint	tableaux	4383-1
tableaux		sequential	226–227 class	4383-1
226–227 class		sequential	543	4383-1
543		sequential	545	4383-1
545		sequential	547 composition	4383-1
547 composition	of	constraint	queries	4383-1
queries		sequential	37	4383-1
37		sequential	48 –52	4383-1
48 –52	in	constraint	semantic data model	4383-1
semantic data model		sequential	243 conjunctive queries	4383-1
243 conjunctive queries		sequential	64 class extension	4383-1
64 class extension		sequential	556 conjunctive queries	4383-1
556 conjunctive queries	with	constraint	union	4383-1
union		sequential	64 class hierarchy	4383-1
64 class hierarchy		sequential	549 conjunctive query program	4383-1
549 conjunctive query program		sequential	49 Index composition	4383-1
49 Index composition	of	constraint	queries	4383-1
queries	with	constraint	union	4383-1
queries	continued	action	union	4383-1
union		sequential	36	4383-1
36		sequential	37	4383-1
37		sequential	38	4383-1
38	–	sequential	64	4383-1
64		sequential	61 functional paradigm	4383-1
61 functional paradigm		sequential	50 unnamed algebra	4383-1
50 unnamed algebra		sequential	52	4383-1
52	–	sequential	56	4383-1
56		sequential	52 imperative paradigm	4383-1
52 imperative paradigm		sequential	50	4383-1
50	vs.	constraint	expert systems	4383-1
expert systems		sequential	135 relational algebra queries	4383-1
135 relational algebra queries		sequential	71 yes	4383-1
71 yes		sequential	42 connectivity query	4383-1
42 connectivity query		sequential	not order	4383-1
not order		sequential	436	4383-1
436		sequential	460 computability	4383-1
460 computability	–	sequential	20	4383-1
20		sequential	13 conseq P	4383-1
13 conseq P		sequential	389 condensation	4383-1
389 condensation		sequential	136 consistent condition box	4383-1
136 consistent condition box	in	constraint	QBE	4383-1
QBE		sequential	128 136 conditional table	4383-1
<B>	See	action	c-table	4383-2
pairwise		sequential	128	4384-1
128		sequential	136	4384-1
136		sequential	conjunction	4384-1
conjunction		sequential	44	4384-1
44	in	constraint	relational model	4384-1
relational model		sequential	30 flatten	4384-1
30 flatten		sequential	83 constraint	4384-1
83 constraint		sequential	186 inequalities	4384-1
186 inequalities	over	constraint	rationals	4384-1
rationals		sequential	96	4384-1
96		sequential	98 polyadic	4384-1
98 polyadic		sequential	46 integrity	4384-1
46 integrity		sequential	28	4384-1
28		sequential	185	4384-1
185		sequential	236 conjunctive calculus	4384-1
236 conjunctive calculus		sequential	64	4384-1
64	vs.	constraint	dependency	4384-1
dependency		sequential	157	4384-1
157	with	constraint	disjunction	4384-1
disjunction		sequential	91 polynomial inequalities	4384-1
91 polynomial inequalities		sequential	96	4384-1
96	with	constraint	equality	4384-1
equality		sequential	611–613 equivalence	4384-1
611–613 equivalence	of	constraint	formulas	4384-1
formulas		sequential	46 transition	4384-1
46 transition		sequential	612 normal form	4384-1
612 normal form		sequential	46	4384-1
46	–	sequential	47	4384-1
47	vs.	constraint	first order	4384-1
first order		sequential	logic	4384-1
logic		sequential	186	4384-1
186		sequential	234 rewrite rule	4384-1
234 rewrite rule		sequential	46 constraint atom	4384-1
46 constraint atom		sequential	112 semantics	4384-1
112 semantics		sequential	45 constraint database	4384-1
45 constraint database		sequential	36	4384-1
36		sequential	71	4384-1
71		sequential	94–96	4384-1
94–96		sequential	97–98	4384-1
97–98	with	constraint	union	4384-1
union		sequential	81 constraint programming	4384-1
81 constraint programming		sequential	97 conjunctive normal form	4384-1
97 conjunctive normal form		sequential	CNF	4384-1
CNF		sequential	21	4384-1
21		sequential	83 constraint query language	4384-1
83 constraint query language		sequential	94–96	4384-1
94–96		sequential	97–98 conjunctive query	4384-1
97–98 conjunctive query		sequential	36	4384-1
36	–	sequential	64	4384-1
64		sequential	37 containment conjunctive queries	4384-1
37 containment conjunctive queries		sequential	105	4384-1
105		sequential	118	4384-1
118	with	constraint	arithmetic	4384-1
arithmetic		sequential	105 decidability	4384-1
105 decidability		sequential	117 calculus	4384-1
117 calculus		sequential	44 –47	4384-1
44 –47		sequential	45	4384-1
45		sequential	64 differences	4384-1
64 differences	of	constraint	SPCU queries	4384-1
SPCU queries		sequential	140 normal form	4384-1
140 normal form		sequential	46	4384-1
46	–	sequential	47	4384-1
47		sequential	order	4384-1
order		sequential	queries composition	4384-1
queries composition		sequential	48	4384-1
48	–	sequential	52	4384-1
52		sequential	50 undecidability	4384-1
50 undecidability		sequential	125 containment	4384-1
125 containment		sequential	105 queries	4384-1
105 queries		sequential	115 complexity	4384-1
115 complexity		sequential	121 –122 tableau queries	4384-1
121 –122 tableau queries		sequential	complexity	4384-1
complexity	of	constraint	121 –122 containment	4384-1
121 –122 containment	of	constraint	queries	4384-1
queries	with	constraint	disjunction	4384-1
disjunction		sequential	61	4384-1
61	–	sequential	64	4384-1
64	to	constraint	dependencies	4384-1
dependencies		sequential	175	4384-1
175		sequential	177 equality	4384-1
177 equality		sequential	47	4384-1
47	–	sequential	48	4384-1
48		sequential	50	4384-1
50	to	constraint	family	4384-1
family	of	constraint	instances	4384-1
instances		sequential	174 equivalence	4384-1
174 equivalence		sequential	47	4384-1
47		sequential	82	4384-1
82		sequential	context	4384-1
context		sequential	105 free grammar	4384-1
105 free grammar		sequential	19 Equivalence Theorem	4384-1
19 Equivalence Theorem		sequential	60 context language	4384-1
60 context language		sequential	20 evaluation	4384-1
20 evaluation		sequential	56 continuous operator	4384-1
56 continuous operator		sequential	286 Homomorphism Theorem	4384-1
286 Homomorphism Theorem		sequential	105	4384-1
105		sequential	115	4384-1
115		sequential	–118	4384-1
–118		sequential	117	4384-1
117		sequential	conventional perspective	4384-1
conventional perspective	on	constraint	relations	4384-1
relations		sequential	32	4384-1
32		sequential	33 CORAL	4384-1
33 CORAL		sequential	logic	4384-1
logic	based	action	337 perspectives	4384-1
337 perspectives	–	sequential	48	4384-1
48		sequential	40 cost model	4384-1
40 cost model	for	constraint	query evaluation	4384-1
query evaluation		sequential	106	4384-1
106		sequential	108–110 count	4384-1
108–110 count		sequential	91	4384-1
91		sequential	92	4384-1
92		sequential	42 counter machine	4384-1
42 counter machine		sequential	15 named algebra	4384-1
15 named algebra		sequential	56	4384-1
56	–	sequential	59	4384-1
59		sequential	57 counting	4384-1
57 counting	vs.	constraint	relational calculus	4384-1
relational calculus		sequential	154 optimization	4384-1
154 optimization		sequential	36	4384-1
36		sequential	56	4384-1
56		sequential	105 counting technique	4384-1
105 counting technique		sequential	327	4384-1
327		sequential	331–335	4384-1
331–335		sequential	336	4384-1
336		sequential	341	4384-1
341	in	constraint	practical systems	4384-1
practical systems		sequential	105 –115 covariance	4384-1
105 –115 covariance		sequential	553	4384-1
553	using	action	chase	4384-1
chase		sequential	163 cover	4384-1
163 cover		sequential	254 using dependencies	4384-1
254 using dependencies		sequential	257 program	4384-1
257 program		sequential	49	4384-1
49	in	constraint	SQL	4384-1
49	create	action	SQL	4384-1
SQL		sequential	145 range	4384-1
145 range	with	constraint	equality	4384-1
145 range	restricted	action	equality	4384-1
equality		sequential	41	4384-1
41		sequential	48	4384-1
48		sequential	65 cross product	4384-1
65 cross product		sequential	52	4384-1
52		sequential	54 rule	4384-1
54 rule	based	action	39	4384-1
39		sequential	40	4384-1
40	–	sequential	42	4384-1
42		sequential	41 physical implementation	4384-1
41 physical implementation		sequential	108	4384-1
108		sequential	42	4384-1
42	in	constraint	SQL	4384-1
SQL		sequential	144	4384-1
144	vs.	constraint	equi-join	4384-1
equi-join		sequential	108 static analysis	4384-1
108 static analysis		sequential	105	4384-1
105		sequential	115	4384-1
115		sequential	–122	4384-1
–122	vs.	constraint	join	4384-1
join		sequential	58 tableau	4384-1
58 tableau		sequential	43	4384-1
43	–	sequential	44	4384-1
44		sequential	43 cumulative assignment	4384-1
43 cumulative assignment		sequential	346 Index CWA	4384-1
<B>	See	action	Closed World Assumption	4384-2
cylindric algebra	vs.	constraint	relational algebra	4385-1
relational algebra		sequential	96	4385-1
96		sequential	103 dangling reference	4385-1
103 dangling reference		sequential	999	4385-1
999		sequential	572 data complexity	4385-1
572 data complexity		sequential	122	4385-1
122		sequential	422–423	4385-1
422–423		sequential	bottom-up	4385-1
bottom-up		sequential	312–316	4385-1
312–316		sequential	324–335 data definition language	4385-1
324–335 data definition language		sequential	DDL	4385-1
DDL		sequential	4	4385-1
4		sequential	28 bound coordinate	4385-1
28 bound coordinate		sequential	318 data function	4385-1
318 data function		sequential	306 connected atom	4385-1
306 connected atom		sequential	338 data independence principle	4385-1
338 data independence principle		sequential	4	4385-1
4		sequential	9 counting	4385-1
9 counting		sequential	327	4385-1
327		sequential	331–335	4385-1
331–335		sequential	336	4385-1
336		sequential	341 data integrity	4385-1
341 data integrity		sequential	162 direct evaluation	4385-1
162 direct evaluation	vs.	constraint	pre-compilation	4385-1
pre-compilation		sequential	317 data manipulation language	4385-1
317 data manipulation language		sequential	DML	4385-1
DML		sequential	4	4385-1
4		sequential	28 Earley Deduction	4385-1
28 Earley Deduction		sequential	335 data model	4385-1
<B>	See	action	database model	4385-2
extension tables		sequential	335 data storage	4386-1
335 data storage		sequential	106 factoring	4386-1
106 factoring		sequential	337 database access functional paradigm	4386-1
337 database access functional paradigm		sequential	571 free coordinate	4386-1
571 free coordinate		sequential	318 database instance	4386-1
318 database instance		sequential	29 generalizations	4386-1
29 generalizations	to	constraint	logic programming	4386-1
logic programming		sequential	336 conventional perspective	4386-1
336 conventional perspective		sequential	32 generalized supplementary magic set rewriting	4386-1
32 generalized supplementary magic set rewriting		sequential	logic	4386-1
logic		sequential	programming	4386-1
programming		sequential	perspective	4386-1
perspective		sequential	32 database logic	4386-1
32 database logic		sequential	97 incremental 337 database management system	4386-1
97 incremental 337 database management system		sequential	3 Iterative Query	4386-1
3 Iterative Query		sequential	Subquery	4386-1
Subquery		sequential	QSQI	4386-1
QSQI		sequential	339 database model	4386-1
339 database model		sequential	4	4386-1
4		sequential	7	4386-1
7	to	constraint	318 complex value	4386-1
7	28 left	attribute	right	4386-1
318 complex value	–	sequential	541	4386-1
541		sequential	508 magic set rewriting	4386-1
508 magic set rewriting	vs.	constraint	QSQ	4386-1
QSQ		sequential	311	4386-1
311		sequential	324–335	4386-1
324–335		sequential	directory	4386-1
directory		sequential	97 Entity Relationship	4386-1
97 Entity Relationship		sequential	ER	4386-1
ER		sequential	242 memo-ing	4386-1
242 memo-ing		sequential	312 Functional Data Model	4386-1
312 Functional Data Model		sequential	264 original magic set rewriting	4386-1
264 original magic set rewriting		sequential	340 generic semantic model	4386-1
340 generic semantic model		sequential	GSM	4386-1
GSM		sequential	242	4386-1
242		sequential	337 hierarchy	4386-1
337 hierarchy		sequential	28	4386-1
28		sequential	97 pre-compilation	4386-1
97 pre-compilation	vs.	constraint	direct evaluation	4386-1
direct evaluation		sequential	317 IFO	4386-1
317 IFO		sequential	242	4386-1
242		sequential	Query	4386-1
Query		sequential	Subquery	4386-1
Subquery		sequential	QSQ	4386-1
QSQ		sequential	311	4386-1
311		sequential	317–324	4386-1
317–324		sequential	335	4386-1
335		sequential	Logical Data Model	4386-1
Logical Data Model		sequential	LDM	4386-1
LDM		sequential	97 network	4386-1
97 network		sequential	28	4386-1
28		sequential	97 rectified subgoal	4386-1
97 rectified subgoal		sequential	328	4386-1
328		sequential	330–331	4386-1
330–331	336 object oriented	action	28	4386-1
28	See	action	object	4386-1
object	oriented	action	database	4386-1
Recursive Query		sequential	Subquery	4387-1
Subquery		sequential	QSQR	4387-1
QSQR		sequential	323–324	4387-1
323–324		sequential	28	4387-1
28		sequential	–34	4387-1
–34		sequential	28	4387-1
28		sequential	207	4387-1
207		sequential	242–250 relevant fact	4387-1
242–250 relevant fact		sequential	317 database schema	4387-1
317 database schema		sequential	29	4387-1
29		sequential	31 rule	4387-1
31 rule		sequential	goal graph	4387-1
goal graph		sequential	335	4387-1
335	with	constraint	dependencies	4387-1
dependencies		sequential	241	4387-1
241		sequential	251 seminaive	4387-1
251 seminaive		sequential	basic algorithm	4387-1
basic algorithm		sequential	improved datalog	4387-1
improved datalog		sequential	39	4387-1
39		sequential	273–310 bottom	4387-1
273–310 bottom		sequential	up	4387-1
up		sequential	312–316	4387-1
312–316		sequential	324–335	4387-1
324–335		sequential	sideways information passing	4387-1
sideways information passing		sequential	318	4387-1
318		sequential	336	4387-1
336	vs.	constraint	top-down	4387-1
top-down		sequential	311	4387-1
311		sequential	327	4387-1
327		sequential	336 boundedness	4387-1
336 boundedness		sequential	285	4387-1
285		sequential	304	4387-1
304		sequential	309 sip graph	4387-1
309 sip graph		sequential	340	4387-1
340	vs.	constraint	first order	4387-1
first order		sequential	306 SLD	4387-1
306 SLD		sequential	AL	4387-1
AL		sequential	335 chain program	4387-1
335 chain program		sequential	303	4387-1
303		sequential	305	4387-1
305		sequential	309 stratification	4387-1
309 stratification		sequential	337 clause	4387-1
337 clause		sequential	288 supplementary relation	4387-1
288 supplementary relation		sequential	319–320	4387-1
319–320		sequential	288 extensional database	4387-1
288 extensional database		sequential	ebb	4387-1
ebb		sequential	279 goal	4387-1
279 goal		sequential	288 extensional relation	4387-1
288 extensional relation		sequential	277 ground	4387-1
277 ground		sequential	288 extensional schema	4387-1
288 extensional schema		sequential	277 unit	4387-1
277 unit		sequential	288 immediate consequence operator	4387-1
288 immediate consequence operator		sequential	282	4387-1
282		sequential	375 complex value	4387-1
375 complex value		sequential	532	4387-1
532		sequential	533 intensional database	4387-1
533 intensional database		sequential	idb	4387-1
idb		sequential	279 containment	4387-1
279 containment		sequential	301–304 intensional relation	4387-1
301–304 intensional relation		sequential	277 uniform	4387-1
277 uniform		sequential	304	4387-1
304		sequential	305	4387-1
305		sequential	309 intensional schema	4387-1
309 intensional schema		sequential	277 least fixpoint semantics	4387-1
277 least fixpoint semantics		sequential	276	4387-1
276		sequential	282–286 evaluation	4387-1
282–286 evaluation		sequential	112	4387-1
112		sequential	311–337	4387-1
311–337		sequential	Knaster	4387-1
Knaster		sequential	Tarski	4387-1
Tarski		sequential	’	4387-1
’		sequential	Theorem	4387-1
Theorem		sequential	286 Index datalog	4387-1
286 Index datalog	continued	action	syntax	4387-1
syntax		sequential	276 linear program	4387-1
276 linear program		sequential	305	4387-1
305		sequential	316	4387-1
316		sequential	top	4387-1
top	vs.	constraint	bottom up	4387-1
bottom up		sequential	311	4387-1
311		sequential	327	4387-1
327		sequential	336 linear rule	4387-1
336 linear rule		sequential	316 magic set rewriting	4387-1
316 magic set rewriting		sequential	311	4387-1
311		sequential	324–335	4387-1
324–335		sequential	336	4387-1
336	vs.	constraint	logic programming	4387-1
logic programming		sequential	35	4387-1
35		sequential	278	4387-1
278		sequential	325	4387-1
325		sequential	336 datalog¬	4387-1
336 datalog¬		sequential	308	4387-1
308		sequential	309	4387-1
309		sequential	355–360	4387-1
355–360		sequential	357	4387-1
357		sequential	374–414	4387-1
374–414		sequential	original	4387-1
original		sequential	340 default model semantics	4387-1
340 default model semantics		sequential	408	4387-1
408	vs.	constraint	QSQ	4387-1
QSQ		sequential	324 inflationary semantics	4387-1
324 inflationary semantics		sequential	356 minimum model semantics	4387-1
356 minimum model semantics		sequential	275	4387-1
275		sequential	278	4387-1
278		sequential	–282	4387-1
–282	locally stratified	action	411 Herbrand interpretation	4387-1
411 Herbrand interpretation		sequential	282 negation	4387-1
282 negation	as	constraint	failure	4387-1
failure		sequential	406–408 Herbrand model	4387-1
406–408 Herbrand model		sequential	282 Clark	4387-1
282 Clark		sequential	completion	4387-1
completion		sequential	406 monadic programs	4387-1
406 monadic programs		sequential	305 finite failure	4387-1
305 finite failure		sequential	288 SLDNF resolution	4387-1
288 SLDNF resolution		sequential	406 nonrecursive noninflationary semantics	4387-1
406 nonrecursive noninflationary semantics		sequential	357	4387-1
357	with	constraint	negation	4387-1
negation		sequential	70	4387-1
70		sequential	72–73	4387-1
72–73		sequential	70	4387-1
70		sequential	72–73 normal form	4387-1
72–73 normal form		sequential	68 range	4387-1
68 range	restricted	action	nr	4387-1
nr		sequential	372 nonrecursive program	4387-1
372 nonrecursive program		sequential	62 rule algebra	4387-1
62 rule algebra		sequential	359	4387-1
359		sequential	373 optimization	4387-1
373 optimization		sequential	36	4387-1
36		sequential	112	4387-1
112		sequential	311–337 semipositive program	4387-1
311–337 semipositive program		sequential	377 parallel evaluation	4387-1
377 parallel evaluation		sequential	337	4387-1
337	on	constraint	ordered databases	4387-1
ordered databases		sequential	288	4387-1
288	vs.	constraint	fixpoint	4387-1
fixpoint		sequential	405 precedence graph	4387-1
405 precedence graph		sequential	315 SLB	4387-1
315 SLB		sequential	resolution	4387-1
resolution		sequential	400 program	4387-1
400 program		sequential	276 stable model semantics	4387-1
276 stable model semantics		sequential	408	4387-1
408		sequential	413 proof tree	4387-1
413 proof tree		sequential	286	4387-1
286	vs.	constraint	choice	4387-1
choice		sequential	409 proof	4387-1
409 proof		sequential	semantics	4387-1
semantics		sequential	275	4387-1
275		sequential	286–300	4387-1
286–300	stratified	action	374 prototype systems	4387-1
374 prototype systems		sequential	337 stratified semantics	4387-1
337 stratified semantics		sequential	377–385 query	4387-1
377–385 query		sequential	317 independence	4387-1
317 independence	of	constraint	stratification	4387-1
stratification		sequential	382	4387-1
382		sequential	Query	4387-1
Query		sequential	Subquery	4387-1
Subquery		sequential	QSQ	4387-1
QSQ		sequential	311	4387-1
311		sequential	317–324	4387-1
317–324		sequential	335	4387-1
335	on	constraint	infinite databases	4387-1
infinite databases		sequential	411	4387-1
411	on	constraint	ordered databases	4387-1
ordered databases		sequential	406 completion	4387-1
406 completion		sequential	318 precedence graph	4387-1
318 precedence graph		sequential	379 Iterative	4387-1
379 Iterative		sequential	QSQI	4387-1
QSQI		sequential	339 SLS resolution	4387-1
339 SLS resolution		sequential	409 Recursive	4387-1
409 Recursive		sequential	QSQR	4387-1
QSQR		sequential	323–324	4387-1
323–324		sequential	stratifiable program	4387-1
stratifiable program		sequential	379 template	4387-1
379 template		sequential	319–320 stratification	4387-1
319–320 stratification		sequential	378	4387-1
378	vs.	constraint	magic set rewriting	4387-1
magic set rewriting		sequential	324 stratification mapping	4387-1
324 stratification mapping		sequential	378 rule	4387-1
378 rule		sequential	276	4387-1
276	vs.	constraint	Fermat	4387-1
Fermat		sequential	’	4387-1
’		sequential	Last Theorem	4387-1
Last Theorem		sequential	411 body	4387-1
411 body		sequential	276	4387-1
276	vs.	constraint	fixpoint queries	4387-1
fixpoint queries		sequential	400 head	4387-1
400 head		sequential	276 supported model	4387-1
276 supported model		sequential	384	4387-1
384		sequential	411 instantiation	4387-1
411 instantiation		sequential	tie	4387-1
tie		sequential	breaking	4387-1
breaking		sequential	277 semantics	4387-1
277 semantics		sequential	409 satisfiability	4387-1
409 satisfiability		sequential	300–301 update language	4387-1
300–301 update language		sequential	379 valid model semantics	4387-1
379 valid model semantics		sequential	409 sirup	4387-1
409 sirup		sequential	305	4387-1
305		sequential	309	4387-1
309	founded	action	SLD	4387-1
SLD		sequential	374 resolution 289–298	4387-1
374 resolution 289–298	founded	action	semantics	4387-1
semantics		sequential	385–397	4387-1
385–397		sequential	413 completeness	4387-1
413 completeness		sequential	297 datalog¬	4387-1
297 datalog¬		sequential	400 derivation	4387-1
400 derivation		sequential	290 most general unifier	4387-1
290 most general unifier		sequential	mgu	4387-1
mgu		sequential	293 refutation	4387-1
293 refutation		sequential	290 global SLS resolution	4387-1
290 global SLS resolution		sequential	409 resolvent	4387-1
409 resolvent		sequential	289	4387-1
289		sequential	295 greatest unfounded set	4387-1
295 greatest unfounded set		sequential	413 selection rule	4387-1
413 selection rule		sequential	298	4387-1
298	on	constraint	ordered databases	4387-1
ordered databases		sequential	SLD	4387-1
SLD		sequential	406 derivation	4387-1
406 derivation		sequential	295 total instance	4387-1
295 total instance		sequential	SLD	4387-1
SLD		sequential	387 refutation	4387-1
387 refutation		sequential	295 total program	4387-1
295 total program		sequential	395 soundness	4387-1
395 soundness		sequential	296 unfounded set	4387-1
296 unfounded set		sequential	413 unifier	4387-1
413 unifier		sequential	293	4387-1
293	vs.	constraint	default	4387-1
default		sequential	412 SLD	4387-1
412 SLD		sequential	tree	4387-1
tree		sequential	298	4387-1
298		sequential	317	4387-1
317	vs.	constraint	fixpoint queries	4387-1
fixpoint queries		sequential	400	4387-1
400		sequential	401 stratified evaluation	4387-1
401 stratified evaluation		sequential	337	4387-1
337	vs.	constraint	412 Index datalog¬¬	4387-1
412 Index datalog¬¬		sequential	234 new DB2	4387-1
234 new DB2		sequential	155 generalized dependency constraints	4387-1
155 generalized dependency constraints		sequential	234 DBASE IV	4387-1
234 DBASE IV		sequential	152	4387-1
152		sequential	234 dbms	4387-1
3 implication		sequential	DDL	4387-2
DDL		sequential	28	4387-2
28	See	action	data definition language	4387-2
<B>	in	constraint	view	4388-1
view		sequential	221 decidability	4388-1
221 decidability		sequential	16 implication	4388-1
16 implication	of	constraint	160	4388-1
160		sequential	164	4388-1
164		sequential	193	4388-1
193		sequential	197	4388-1
197	of	constraint	implication	4388-1
implication	for	constraint	full dependencies	4388-1
full dependencies		sequential	220	4388-1
220		sequential	id	4388-1
id		sequential	233	4388-1
233	vs.	constraint	35	4388-1
35		sequential	53	4388-1
53	implied	action	234 decomposition	4388-1
234 decomposition		sequential	162	4388-1
162		sequential	251–259	4388-1
251–259		sequential	252	4388-1
252		sequential	265 –266 inclusion	4388-1
265 –266 inclusion		sequential	ind	4388-1
ind		sequential	161	4388-1
161		sequential	192–211	4388-1
192–211		sequential	193	4388-1
193		sequential	218	4388-1
218		sequential	250 dependency	4388-1
250 dependency	preserving	action	254 key	4388-1
254 key	based	action	250	4388-1
250	260 typed	action	213 lossless join	4388-1
213 lossless join		sequential	253 unary	4388-1
253 unary		sequential	uind	4388-1
uind		sequential	210 –211 mapping	4388-1
210 –211 mapping		sequential	253 inference rule	4388-1
253 inference rule		sequential	166	4388-1
166		sequential	172	4388-1
172		sequential	193	4388-1
193		sequential	227	4388-1
227		sequential	231 multi-way join	4388-1
231 multi-way join		sequential	106	4388-1
106		sequential	114–115 ground	4388-1
114–115 ground		sequential	203 reconstruction mapping	4388-1
203 reconstruction mapping		sequential	254 join	4388-1
254 join		sequential	jd	4388-1
jd		sequential	161	4388-1
161		sequential	169–173	4388-1
169–173		sequential	170	4388-1
170		sequential	218	4388-1
218	vs.	constraint	synthesis	4388-1
synthesis		sequential	258	4388-1
258		sequential	265 key	4388-1
265 key		sequential	157	4388-1
157		sequential	163–169	4388-1
163–169		sequential	163	4388-1
163		sequential	267 DedGin	4388-1
267 DedGin		sequential	337 logical implication	4388-1
337 logical implication	of	constraint	160	4388-1
160		sequential	164 deductive database	4388-1
164 deductive database		sequential	object	4388-1
object	oriented	action	197 deductive database	4388-1
197 deductive database		sequential	572	4388-1
572		sequential	574	4388-1
574		sequential	575	4388-1
575		sequential	mvd	4388-1
mvd		sequential	161	4388-1
161		sequential	169–173	4388-1
169–173		sequential	170	4388-1
170		sequential	186	4388-1
186		sequential	218 deductive temporal query language	4388-1
218 deductive temporal query language		sequential	233 deep equality	4388-1
233 deep equality		sequential	557	4388-1
557		sequential	575	4388-1
575	vs.	constraint	unnamed perspectives	4388-1
575	named	action	unnamed perspectives	4388-1
unnamed perspectives		sequential	159 default logic	4388-1
159 default logic		sequential	408 order	4388-1
408 order		sequential	234 definite clause	4388-1
234 definite clause		sequential	288 partition	4388-1
288 partition		sequential	234 definite query	4388-1
234 definite query		sequential	97 projected join	4388-1
97 projected join		sequential	233 delete	4388-1
233 delete	in	constraint	SQL	4388-1
SQL		sequential	149 deletion	4388-1
149 deletion		sequential	580 satisfaction	4388-1
580 satisfaction		sequential	556 satisfaction	4388-1
556 satisfaction	by	constraint	tableau	4388-1
tableau		sequential	175 deletion anomaly	4388-1
175 deletion anomaly		sequential	162	4388-1
162		sequential	254 satisfaction family	4388-1
254 satisfaction family		sequential	174 dense linear order	4388-1
174 dense linear order		sequential	96	4388-1
96		sequential	98 dependency	4388-1
98 dependency		sequential	157 head	4388-1
157 head	vs.	constraint	multi-head	4388-1
multi-head		sequential	217 sort set	4388-1
217 sort set		sequential	191	4388-1
191		sequential	213	4388-1
213		sequential	234 subset	4388-1
234 subset		sequential	233	4388-1
233	tagged	action	164	4388-1
164		sequential	221	4388-1
221		sequential	241	4388-1
241	capturing	action	semantics	4388-1
semantics		sequential	159 –163 template	4388-1
159 –163 template		sequential	233	4388-1
233		sequential	236 classification	4388-1
236 classification		sequential	234 conditional table	4388-1
234 conditional table		sequential	220 tuple	4388-1
220 tuple		sequential	generating	4388-1
generating		sequential	tgd	4388-1
tgd		sequential	217–228	4388-1
217–228	typed	attribute	159 dynamic	4388-1
234	vs.	constraint	192	4388-1
192	217 embedded	action	192	4388-1
192		sequential	217	4388-1
217		sequential	eid	4388-1
eid		sequential	233 embedded join	4388-1
233 embedded join		sequential	ejd	4388-1
ejd		sequential	218	4388-1
218		sequential	emvd	4388-1
emvd		sequential	218	4388-1
218		sequential	220	4388-1
220		sequential	233	4388-1
233	vs.	constraint	order	4388-1
order		sequential	logic	4388-1
logic		sequential	159	4388-1
159		sequential	234 equality	4388-1
234 equality		sequential	generating	4388-1
generating		sequential	egd	4388-1
egd		sequential	217–228	4388-1
217–228	vs.	constraint	integrity constraint	4388-1
integrity constraint		sequential	157	4388-1
157		sequential	234	4388-1
234	vs.	constraint	tableaux	4388-1
tableaux		sequential	218	4388-1
218		sequential	232	4388-1
232		sequential	233	4388-1
233		sequential	239 dependency basis	4388-1
239 dependency basis		sequential	172 finiteness	4388-1
172 finiteness		sequential	306 dependency preserving decomposition	4388-1
306 dependency preserving decomposition		sequential	217 dependent class	4388-1
217 dependent class		sequential	fd	4388-1
fd		sequential	28	4388-1
28		sequential	159	4388-1
159		sequential	163–169	4388-1
163–169		sequential	163	4388-1
163		sequential	186	4388-1
186		sequential	218	4388-1
218		sequential	dereferencing	4388-1
dereferencing		sequential	557	4388-1
557		sequential	558 derivation	4388-1
558 derivation		sequential	290 Index derived data	4388-1
290 Index derived data		sequential	246 DOOD	4388-1
<B>	See	action	deductive database	4388-2
<B>	object oriented	action	deductive database	4388-2
<B>		sequential	completeness	4389-1
completeness		sequential	474	4389-1
474		sequential	561	4389-1
561		sequential	574 duplicate elimination	4389-1
574 duplicate elimination		sequential	107 determinate query	4389-1
107 determinate query		sequential	474	4389-1
474		sequential	107 diameter	4389-1
107 diameter		sequential	12 duplicate tuples	4389-1
12 duplicate tuples		sequential	144 diff	4389-1
144 diff		sequential	88 dynamic aspect	4389-1
88 dynamic aspect	of	constraint	object	4389-1
object	oriented	action	database	4389-1
database		sequential	572 difference	4389-1
572 difference		sequential	33	4389-1
33		sequential	36	4389-1
36		sequential	68 dynamic binding	4389-1
68 dynamic binding		sequential	543	4389-1
543		sequential	546	4389-1
546		sequential	552	4389-1
552	in	constraint	relational algebra	4389-1
relational algebra		sequential	71 dynamic choice operator	4389-1
71 dynamic choice operator		sequential	464 Dynamic Logic Programming	4389-1
464 Dynamic Logic Programming		sequential	DLP	4389-1
DLP		sequential	583	4389-1
583		sequential	613	4389-1
613	in	constraint	SQL	4389-1
SQL		sequential	146	4389-1
146	vs.	constraint	negation	4389-1
negation		sequential	70 direct product	4389-1
70 direct product		sequential	232	4389-1
232		sequential	238 ear	4389-1
238 ear	of	constraint	hypergraph	4389-1
hypergraph		sequential	130 directory model	4389-1
130 directory model		sequential	97 Earley Deduction	4389-1
97 Earley Deduction		sequential	335 disjunction	4389-1
335 disjunction		sequential	38 edb	4389-1
38 edb		sequential	42	4389-1
42		sequential	49	4389-1
49		sequential	277	4389-1
277	in	constraint	conjunctive queries	4389-1
conjunctive queries		sequential	37	4389-1
37		sequential	38	4389-1
38		sequential	61	4389-1
61		sequential	64 edge	4389-1
64 edge	of	constraint	hypergraph	4389-1
hypergraph		sequential	130 flatten	4389-1
130 flatten		sequential	83 egd	4389-1
83 egd		sequential	217–228	4389-1
217–228	in	constraint	selection formulas	4389-1
selection formulas		sequential	62	4389-1
62		sequential	Ehrenfeucht	4389-1
Ehrenfeucht		sequential	Fraissé	4389-1
Fraissé		sequential	games	4389-1
games		sequential	433–437	4389-1
433–437		sequential	460 disjunctive deductive database	4389-1
460 disjunctive deductive database		sequential	502 eid	4389-1
502 eid		sequential	233 disjunctive normal form	4389-1
233 disjunctive normal form		sequential	DNF	4389-1
DNF		sequential	21	4389-1
21		sequential	83 ejd	4389-1
83 ejd		sequential	218 disk	4389-1
218 disk		sequential	106 EKS	4389-1
106 EKS		sequential	410	4389-1
410	in	constraint	SQL	4389-1
SQL		sequential	107	4389-1
107		sequential	145	4389-1
145		sequential	154 elementary functions	4389-1
154 elementary functions		sequential	18 distributed database elementary query	4389-1
18 distributed database elementary query		sequential	534 query optimization	4389-1
534 query optimization		sequential	128 embedded dependency	4389-1
128 embedded dependency		sequential	192	4389-1
192		sequential	217 division	4389-1
217 division	in	constraint	relational algebra	4389-1
relational algebra		sequential	99 embedded implicational dependency	4389-1
99 embedded implicational dependency		sequential	eid	4389-1
eid		sequential	233 DML	4389-1
233 DML		sequential	4	4389-1
4		sequential	28 embedded join dependency	4389-1
28 embedded join dependency		sequential	ejd	4389-1
ejd		sequential	218 DNF	4389-1
218 DNF		sequential	83 embedded multivalued dependency	4389-1
83 embedded multivalued dependency		sequential	emvd	4389-1
emvd		sequential	218	4389-1
218		sequential	dom	4389-1
dom		sequential	30	4389-1
30		sequential	72 Dom	4389-1
72 Dom		sequential	·	4389-1
·		sequential	30 embedding	4389-1
30 embedding	of	constraint	tableau	4389-1
tableau		sequential	43 domain empty clause	4389-1
43 domain empty clause		sequential	288 emvd	4389-1
288 emvd		sequential	218	4389-1
218		sequential	220	4389-1
220		sequential	233	4389-1
233	in	constraint	relational model	4389-1
relational model		sequential	29	4389-1
29		sequential	30 enc α	4389-1
30 enc α		sequential	418 scalar	4389-1
418 scalar		sequential	153 encapsulation	4389-1
153 encapsulation		sequential	543	4389-1
543		sequential	546	4389-1
546		sequential	553 time	4389-1
553 time		sequential	607 entity	4389-1
607 entity		sequential	Entity	4389-1
Entity		sequential	74 Relationship	4389-1
74 Relationship		sequential	ER	4389-1
ER		sequential	model	4389-1
model		sequential	242	4389-1
242		sequential	264 domain calculus	4389-1
264 domain calculus		sequential	74 equality atom	4389-1
74 equality atom		sequential	217	4389-1
217	vs.	constraint	tuple calculus	4389-1
tuple calculus		sequential	39 equality	4389-1
39 equality		sequential	generating dependency	4389-1
generating dependency		sequential	egd	4389-1
egd		sequential	217–228	4389-1
217–228		sequential	Domain Closure axiom	4389-1
Domain Closure axiom		sequential	26 domain independence	4389-1
26 domain independence		sequential	70	4389-1
70		sequential	74	4389-1
74		sequential	75	4389-1
75		sequential	–77	4389-1
–77		sequential	79	4389-1
79		sequential	81–97 equi-join	4389-1
81–97 equi-join		sequential	55	4389-1
55		sequential	108 physical implementation	4389-1
108 physical implementation		sequential	107–108 complex value	4389-1
107–108 complex value		sequential	526	4389-1
526	in	constraint	SQL	4389-1
SQL		sequential	144	4389-1
144	vs.	constraint	natural join	4389-1
natural join		sequential	57 equivalence	4389-1
57 equivalence	with	constraint	functions	4389-1
functions		sequential	97 calculus formulas	4389-1
97 calculus formulas		sequential	82	4389-1
82	with	constraint	order	4389-1
order		sequential	97 conjunctive calculus formulas	4389-1
97 conjunctive calculus formulas		sequential	46 practical query languages	4389-1
46 practical query languages		sequential	153 conjunctive queries	4389-1
153 conjunctive queries		sequential	47	4389-1
47		sequential	60	4389-1
60		sequential	64	4389-1
64		sequential	82	4389-1
82		sequential	105 relational calculus	4389-1
105 relational calculus		sequential	81 decidability	4389-1
81 decidability		sequential	118 syntactic restrictions	4389-1
118 syntactic restrictions		sequential	81–91 conjunctive queries	4389-1
81–91 conjunctive queries	with	constraint	union	4389-1
union		sequential	63 undecidability	4389-1
63 undecidability		sequential	97	4389-1
97		sequential	125 differences	4389-1
125 differences	of	constraint	SPCU queries	4389-1
SPCU queries		sequential	140	4389-1
140	vs.	constraint	active domain semantics	4389-1
active domain semantics	and	conjunctive	79 implicaton	4389-1
79 implicaton	for	constraint	domain inclusion	4389-1
domain inclusion		sequential	full semantics	4389-1
full semantics		sequential	551 dependencies	4389-1
551 dependencies		sequential	220	4389-1
220		sequential	domain	4389-1
domain		sequential	234 normal form	4389-1
234 normal form		sequential	order	4389-1
order		sequential	265 languages	4389-1
265 languages		sequential	36	4389-1
36		sequential	80	4389-1
80		sequential	96 dominance	4389-1
96 dominance	of	constraint	query languages	4389-1
query languages		sequential	⊑	4389-1
⊑		sequential	order	4389-1
order		sequential	47 queries	4389-1
47 queries		sequential	74 Index undecidability	4389-1
74 Index undecidability		sequential	125 fd rule	4389-1
125 fd rule	in	constraint	chasing	4389-1
chasing		sequential	175	4389-1
175	of	constraint	full dependencies	4389-1
175	and	conjunctive	full dependencies	4389-1
175	typed	attribute	algebraic	4389-1
full dependencies		sequential	231 fd- schema	4389-1
231 fd- schema		sequential	251	4389-1
251	of	constraint	hypergraph properties	4389-1
hypergraph properties		sequential	132 field	4389-1
132 field	and	conjunctive	algebras	4389-1
132 field	real closed	attribute	97 nr-datalog¬	4389-1
algebras		sequential	73 file systems	4389-1
73 file systems		sequential	3 queries	4389-1
3 queries		sequential	37 filter	4389-1
37 filter		sequential	518	4389-1
518	to	constraint	dependencies	4389-1
dependencies		sequential	176	4389-1
176		sequential	177 finitary power set	4389-1
177 finitary power set		sequential	10 query languages	4389-1
10 query languages		sequential	47 finite interpretation	4389-1
47 finite interpretation		sequential	26 relational algebras	4389-1
26 relational algebras		sequential	71 finite logical implication	4389-1
71 finite logical implication		sequential	197–202	4389-1
197–202		sequential	219 SPC	4389-1
219 SPC	and	conjunctive	SPJR algebras	4389-1
SPJR algebras		sequential	60	4389-1
60	vs.	constraint	197 equivalence	4389-1
197 equivalence		sequential	class	4389-1
class		sequential	10 finite model theory	4389-1
10 finite model theory		sequential	123	4389-1
123		sequential	197 equivalence relation	4389-1
197 equivalence relation		sequential	10 finite representation	4389-1
10 finite representation	of	constraint	infinite database	4389-1
infinite database		sequential	93–96	4389-1
93–96		sequential	97 Equivalence	4389-1
<B>	See	action	flatten	4389-2
flatten		sequential	524 functional dependency FOID	4389-2
524 functional dependency FOID		sequential	588 fd closure format model	4389-2
588 fd closure format model		sequential	539 formula	4389-2
539 formula		sequential	22	4389-2
22	of	constraint	set	4389-2
set	of	constraint	attributes	4389-2
attributes		sequential	165 conjunctive calculus	4389-2
165 conjunctive calculus		sequential	45	4389-2
45	of	constraint	set	4389-2
set	of	constraint	fd	4389-2
fd		sequential	s	4389-2
s		sequential	165 conjunctive normal form	4389-2
165 conjunctive normal form		sequential	CNF	4389-2
CNF		sequential	83 Index formula	4389-2
83 Index formula	continued	action	GP	4389-2
GP		sequential	379 disjunctive normal form	4389-2
379 disjunctive normal form		sequential	DNF	4389-2
DNF		sequential	83	4389-2
83		sequential	Galileo	4389-2
Galileo		sequential	77 game	4389-2
77 game	of	constraint	life	4389-2
life		sequential	343 matrix	4389-2
343 matrix	of	constraint	82 garbage collection	4389-2
82 garbage collection		sequential	556 prenex normal form	4389-2
556 prenex normal form		sequential	PNF	4389-2
PNF		sequential	82	4389-2
82		sequential	Gauss	4389-2
Gauss		sequential	Seidel	4389-2
Seidel		sequential	algorithm	4389-2
algorithm		sequential	335 relational calculus	4389-2
335 relational calculus		sequential	74–75 generalized instance	4389-2
74–75 generalized instance		sequential	95 generalized SPC algebra	4389-2
95 generalized SPC algebra		sequential	55 fourth normal form	4389-2
55 fourth normal form		sequential	4NF	4389-2
4NF		sequential	252	4389-2
252		sequential	252	4389-2
252		sequential	259 generalized SPJR algebra	4389-2
259 generalized SPJR algebra		sequential	59 Foxpro	4389-2
59 Foxpro		sequential	152 generalized tuple	4389-2
152 generalized tuple		sequential	94	4389-2
94		sequential	95 FQL	4389-2
95 FQL		sequential	264 generic OODB model	4389-2
264 generic OODB model		sequential	547–556	4389-2
547–556		sequential	·	4389-2
·		sequential	45	4389-2
45		sequential	75 generic semantic model	4389-2
75 generic semantic model		sequential	GSM	4389-2
GSM		sequential	242–250	4389-2
242–250		sequential	free coordinate genericity	4389-2
free coordinate genericity		sequential	103	4389-2
103		sequential	419–421	4389-2
419–421		sequential	419	4389-2
419		sequential	425	4389-2
425	in	constraint	datalog evaluation	4389-2
datalog evaluation		sequential	318	4389-2
318		sequential	globally consistent join	4389-2
globally consistent join		sequential	128	4389-2
128		sequential	136	4389-2
136		sequential	261 free tuple	4389-2
261 free tuple		sequential	33 GLUE	4389-2
33 GLUE		sequential	NAIL	4389-2
NAIL		sequential	337 free variable occurrence	4389-2
337 free variable occurrence		sequential	23	4389-2
23		sequential	45	4389-2
45		sequential	75 goal clause	4389-2
75 goal clause		sequential	288 fsa	4389-2
<B>	See	attribute	finite	4389-3
state		sequential	automata	4389-3
Gödel Completeness		sequential	Theorem	4390-1
Theorem		sequential	123	4390-1
123		sequential	136 full dependency	4390-1
136 full dependency		sequential	217 graph	4390-1
217 graph		sequential	11 full reducer	4390-1
11 full reducer		sequential	129	4390-1
129		sequential	136 graphical query language	4390-1
136 graphical query language	–	sequential	153	4390-1
153		sequential	150 full tuple generating dependency	4390-1
150 full tuple generating dependency		sequential	218 Graphlog	4390-1
218 Graphlog		sequential	369	4390-1
369		sequential	370 full typed dependencies ground	4390-1
370 full typed dependencies ground		sequential	22 ground atom	4390-1
22 ground atom		sequential	function	4390-1
function	based	action	34 perspective	4390-1
34 perspective	on	constraint	tuples	4390-1
tuples		sequential	32 ground clause	4390-1
32 ground clause		sequential	288 Functional Data Model	4390-1
288 Functional Data Model		sequential	264 ground inference rule	4390-1
264 ground inference rule		sequential	203 functional dependency	4390-1
203 functional dependency		sequential	fd	4390-1
fd		sequential	28	4390-1
28		sequential	163–169	4390-1
163–169		sequential	163	4390-1
163		sequential	186	4390-1
186		sequential	group	4390-1
group	by	constraint	SQL	4390-1
group	in	constraint	SQL	4390-1
SQL		sequential	154 grouping	4390-1
154 grouping		sequential	533 GSM	4390-1
533 GSM		sequential	242–250 GYO algorithm	4390-1
242–250 GYO algorithm		sequential	130	4390-1
130		sequential	136	4390-1
136	with	constraint	mvd	4390-1
mvd		sequential	s	4390-1
s		sequential	172–173 GYO reduction	4390-1
172–173 GYO reduction		sequential	141	4390-1
141	vs.	constraint	ind	4390-1
ind		sequential	’ s	4390-1
’ s		sequential	192	4390-1
192		sequential	202–207	4390-1
202–207		sequential	211 closure	4390-1
211 closure		sequential	165 hash index	4390-1
165 hash index		sequential	107 cover	4390-1
107 cover		sequential	254 head	4390-1
254 head	of	constraint	rule	4390-1
rule		sequential	39	4390-1
39		sequential	41	4390-1
41		sequential	276	4390-1
276		sequential	Heraclitus	4390-1
Heraclitus		sequential	615 Herbrand interpretations	4390-1
615 Herbrand interpretations		sequential	23	4390-1
23	of	constraint	ind s	4390-1
ind s		sequential	250 Herbrand model logical implication datalog	4390-1
250 Herbrand model logical implication datalog		sequential	282	4390-1
282	with	constraint	ind	4390-1
ind		sequential	s	4390-1
s		sequential	192	4390-1
192		sequential	199 –202 hierarchy model	4390-1
199 –202 hierarchy model		sequential	28	4390-1
28		sequential	97 linear time	4390-1
97 linear time		sequential	165 homomorphism	4390-1
165 homomorphism		sequential	12 satisfies	4390-1
12 satisfies		sequential	163	4390-1
163	of	constraint	tableau queries	4390-1
tableau queries		sequential	117	4390-1
117		sequential	127	4390-1
127		sequential	136 saturated set	4390-1
136 saturated set		sequential	188 Homomorphism Theorem	4390-1
188 Homomorphism Theorem		sequential	37	4390-1
37		sequential	105	4390-1
105		sequential	115–118	4390-1
115–118		sequential	117	4390-1
117		sequential	Horn clause	4390-1
Horn clause		sequential	279	4390-1
279	vs.	constraint	decomposition	4390-1
decomposition		sequential	164	4390-1
164		sequential	171 hyp	4390-1
171 hyp		sequential	18	4390-1
18	vs.	constraint	join dependency	4390-1
join dependency		sequential	171	4390-1
171		sequential	178 hyperedge	4390-1
178 hyperedge		sequential	130	4390-1
130	vs.	constraint	multivalued dependency	4390-1
multivalued dependency		sequential	171 hypergraph	4390-1
171 hypergraph		sequential	130	4390-1
130	vs.	constraint	propositional logic	4390-1
propositional logic		sequential	186	4390-1
186		sequential	189	4390-1
189	vs.	constraint	semantic data model	4390-1
semantic data model		sequential	249–253	4390-1
249–253	vs.	constraint	unrestricted implication	4390-1
unrestricted implication	199 connected	action	132	4390-1
132	vs.	constraint	propositional logic	4390-1
propositional logic		sequential	132 functional paradigm	4390-1
132 functional paradigm		sequential	569	4390-1
569	of	constraint	database schema	4390-1
database schema		sequential	130 functional query language	4390-1
130 functional query language		sequential	569 ear	4390-1
569 ear		sequential	130 edge	4390-1
130 edge		sequential	130 GYO algorithm	4390-1
130 GYO algorithm		sequential	130 Index path	4390-1
130 Index path		sequential	132 implicational dependency	4390-1
132 implicational dependency		sequential	id	4390-1
id		sequential	233	4390-1
233	reduced	action	130 implies	4390-1
<B>	See	action	implication	4390-2
hyperplane finitely		sequential	438	4391-1
438		sequential	198	4391-1
198	without	constraint	restriction	4391-1
restriction		sequential	198 inclusion dependency	4391-1
198 inclusion dependency		sequential	ind	4391-1
ind		sequential	161	4391-1
161		sequential	192–211	4391-1
192–211		sequential	193	4391-1
193		sequential	218	4391-1
218		sequential	I1	4391-1
I1		sequential	I1/2	4391-1
I1/2		sequential	I0	4391-1
I0		sequential	387	4391-1
387		sequential	I∗	4391-1
I∗		sequential	I∗	4391-1
I∗		sequential	I∗	4391-1
I∗		sequential	391 idb	4391-1
391 idb		sequential	42	4391-1
42		sequential	49	4391-1
49		sequential	277	4391-1
277	vs.	constraint	implication	4391-1
implication		sequential	210 IDM transaction	4391-1
210 IDM transaction		sequential	580 –582	4391-1
580 –582		sequential	613	4391-1
613		sequential	615–617	4391-1
615–617	vs.	constraint	fd	4391-1
fd		sequential	s	4391-1
s		sequential	192	4391-1
192		sequential	202–207	4391-1
202–207		sequential	211 condition	4391-1
211 condition		sequential	580 deletion	4391-1
580 deletion		sequential	615	4391-1
615	of	constraint	fd	4391-1
fd		sequential	s	4391-1
s		sequential	250 insertion	4391-1
250 insertion		sequential	615 key	4391-1
615 key	based	action	250	4391-1
250		sequential	260 modification	4391-1
260 modification		sequential	615 logical implication	4391-1
615 logical implication		sequential	192	4391-1
192		sequential	195 –197 optimization	4391-1
195 –197 optimization		sequential	581	4391-1
581	with	constraint	fd	4391-1
fd		sequential	s	4391-1
s		sequential	192	4391-1
192		sequential	199 –202 parallelization	4391-1
199 –202 parallelization		sequential	616 repeats	4391-1
616 repeats	permitted	action	212 schedule	4391-1
212 schedule		sequential	616 restricted classes	4391-1
616 restricted classes		sequential	192 serializability	4391-1
192 serializability		sequential	616 satisfies	4391-1
616 satisfies		sequential	193 simplification rules	4391-1
193 simplification rules		sequential	582	4391-1
582	typed	action	211 IDM transactional schema	4391-1
211 IDM transactional schema		sequential	584	4391-1
584		sequential	613	4391-1
613		sequential	617	4391-1
617	vs.	constraint	referential integrity	4391-1
referential integrity		sequential	211	4391-1
211	vs.	constraint	constraints	4391-1
constraints		sequential	585	4391-1
585		sequential	–586	4391-1
–586	vs.	constraint	semantic data model	4391-1
semantic data model		sequential	207 completeness	4391-1
207 completeness		sequential	617	4391-1
617	vs.	constraint	unrestricted implication	4391-1
unrestricted implication		sequential	199 soundness	4391-1
199 soundness		sequential	617 incomplete database	4391-1
617 incomplete database		sequential	487–507	4391-1
487–507	vs.	constraint	fd	4391-1
fd		sequential	s	4391-1
s		sequential	585 c-table	4391-1
585 c-table		sequential	493	4391-1
493	vs.	constraint	inclusion dependencies	4391-1
inclusion dependencies		sequential	585	4391-1
585		sequential	617 update	4391-1
617 update		sequential	593–594	4391-1
593–594	vs.	constraint	jd	4391-1
jd		sequential	s	4391-1
s		sequential	617 complexity	4391-1
617 complexity		sequential	499 IFO	4391-1
499 IFO		sequential	242	4391-1
242		sequential	264 fixpoint	4391-1
264 fixpoint		sequential	495 ILOG	4391-1
495 ILOG		sequential	576 logical theory	4391-1
576 logical theory		sequential	594–600	4391-1
594–600		sequential	image	4391-1
image	of	constraint	calculus query	4391-1
calculus query		sequential	78 immediate consequence operator	4391-1
78 immediate consequence operator		sequential	282 table	4391-1
282 table		sequential	488 imperative method	4391-1
488 imperative method		sequential	564–566	4391-1
564–566		sequential	573 incomplete information implementation	4391-1
573 incomplete information implementation		sequential	cross product	4391-1
cross product		sequential	108 incremental update	4391-1
<B>	See	action	first order	4391-2
first order		sequential	incremental equi-join	4391-2
incremental equi-join		sequential	107–108 definability	4391-2
multi-way	join	action	111–115 ind	4392-1
111–115 ind		sequential	161	4392-1
161	See	action	inclusion dependency	4392-1
<B>		sequential	106–108	4393-1
106–108		sequential	ind-rule	4393-1
ind-rule	in	constraint	chasing	4393-1
chasing		sequential	208 projection	4393-1
208 projection		sequential	107 independent component	4393-1
107 independent component		sequential	265 relational algebra	4393-1
265 relational algebra		sequential	107–108 indexing	4393-1
107–108 indexing		sequential	106	4393-1
106		sequential	107 selection	4393-1
107 selection		sequential	107 inequality atom implication	4393-1
107 inequality atom implication	in	constraint	selections	4393-1
selections		sequential	69 inequality	4393-1
69 inequality	in	constraint	constraint databases	4393-1
constraint databases		sequential	96	4393-1
96	under	constraint	204 inference rule	4393-1
96	closed	action	204 inference rule	4393-1
204 inference rule		sequential	24	4393-1
24		sequential	158	4393-1
158	under	constraint	k-ary	4393-1
158	closed	action	k-ary	4393-1
k-ary		sequential	204 ground	4393-1
204 ground		sequential	202	4393-1
202		sequential	203	4393-1
203	of	constraint	dependencies	4393-1
dependencies		sequential	158	4393-1
158		sequential	160	4393-1
160		sequential	164	4393-1
164		sequential	195 schema	4393-1
195 schema		sequential	202	4393-1
202	in	constraint	view	4393-1
view		sequential	221 substitution	4393-1
221 substitution		sequential	167	4393-1
167	of	constraint	fd	4393-1
fd		sequential	s	4393-1
s	and	conjunctive	ind	4393-1
ind		sequential	s	4393-1
s		sequential	192 inference rules	4393-1
192 inference rules		sequential	197–199	4393-1
197–199		sequential	226	4393-1
226	for	constraint	fd	4393-1
fd		sequential	s	4393-1
s	and	conjunctive	mvd	4393-1
mvd		sequential	s	4393-1
s		sequential	172–173	4393-1
172–173		sequential	186 finite	4393-1
186 finite	vs.	constraint	202	4393-1
202		sequential	219	4393-1
219		sequential	234	4393-1
234	for	constraint	functional dependency	4393-1
functional dependency		sequential	166–168	4393-1
166–168		sequential	186	4393-1
186	of	constraint	functional dependencies	4393-1
functional dependencies		sequential	186	4393-1
186	for	constraint	inclusion dependency	4393-1
inclusion dependency		sequential	193–195	4393-1
193–195	of	constraint	ind	4393-1
ind		sequential	s	4393-1
s		sequential	192	4393-1
192		sequential	195	4393-1
195		sequential	–197	4393-1
–197		sequential	proof	4393-1
proof	using	action	167	4393-1
167	for	constraint	two element	4393-1
two element		sequential	instances	4393-1
instances		sequential	189	4393-1
189	using	attribute	167 unrestricted	4393-1
197–199	for	constraint	unary inds	4393-1
unary inds		sequential	210	4393-1
210		sequential	215	4393-1
215	vs.	constraint	fd	4393-1
fd		sequential	s	4393-1
s	and	conjunctive	ind	4393-1
ind		sequential	s	4393-1
s		sequential	199	4393-1
199	–	sequential	202	4393-1
202	vs.	constraint	algorithm	4393-1
algorithm	for	constraint	testing implication	4393-1
testing implication		sequential	166 Index inference rules	4393-1
166 Index inference rules	continued	action	IQL	4393-1
IQL		sequential	573	4393-1
573	vs.	constraint	axiom	4393-1
axiom		sequential	11 infinitary logic	4393-1
11 infinitary logic		sequential	458	4393-1
458		sequential	459	4393-1
459		sequential	462 ISA	4393-1
462 ISA		sequential	543	4393-1
543		sequential	545 infinite database	4393-1
545 infinite database		sequential	97 semantic data model	4393-1
97 semantic data model		sequential	245 finite representation	4393-1
245 finite representation		sequential	36	4393-1
36		sequential	93–96	4393-1
93–96		sequential	97 isomorphic tableau queries	4393-1
97 isomorphic tableau queries		sequential	120 infinite tree	4393-1
120 infinite tree		sequential	575 isomorphism	4393-1
575 isomorphism		sequential	12 inflationary datalog¬	4393-1
12 inflationary datalog¬		sequential	356 OID	4393-1
356 OID		sequential	555 inflationary fixpoint logic	4393-1
555 inflationary fixpoint logic		sequential	CALC	4393-1
CALC		sequential	+µ+	4393-1
+µ+		sequential	352	4393-1
352		sequential	iterate	4393-1
iterate		sequential	518 Iterative QSQ	4393-1
518 Iterative QSQ		sequential	QSQI	4393-1
QSQI		sequential	339 inflationary fixpoint operator	4393-1
339 inflationary fixpoint operator		sequential	µ+	4393-1
µ+		sequential	353 information capacity relative	4393-1
353 information capacity relative		sequential	265	4393-1
265		sequential	268–269	4393-1
268–269		sequential	Jacobi algorithm	4393-1
Jacobi algorithm		sequential	335	4393-1
335		sequential	INGRES	4393-1
INGRES		sequential	34	4393-1
34		sequential	111	4393-1
111		sequential	155 jd	4393-1
155 jd		sequential	161	4393-1
161		sequential	169–173	4393-1
169–173		sequential	218	4393-1
<B>	See	action	dependency	4393-2
<B>	join	action	dependency	4393-2
dependency	distributed	action	135 jd rule	4393-2
135 jd rule	in	constraint	chasing	4393-2
chasing		sequential	175 query optimizer	4393-2
175 query optimizer		sequential	114–115	4393-2
114–115		sequential	127	4393-2
127		sequential	135	4393-2
135		sequential	137 join	4393-2
137 join		sequential	55,57 inheritance	4393-2
55,57 inheritance		sequential	546	4393-2
546		sequential	552	4393-2
552		sequential	553	4393-2
553		sequential	567	4393-2
567		sequential	573–575	4393-2
573–575		sequential	577 semantic data model	4393-2
577 semantic data model		sequential	245 input schema	4393-2
245 input schema	of	constraint	query	4393-2
query		sequential	37 complex value	4393-2
37 complex value		sequential	517 insert	4393-2
517 insert	in	constraint	SQL	4393-2
SQL		sequential	149 decomposition	4393-2
149 decomposition		sequential	106	4393-2
106		sequential	114 insertion	4393-2
114 insertion		sequential	580 equi-join	4393-2
580 equi-join		sequential	55	4393-2
55		sequential	57	4393-2
57		sequential	108 insertion anomaly	4393-2
108 insertion anomaly		sequential	162 implementation	4393-2
162 implementation		sequential	111–115 instance	4393-2
111–115 instance	to	constraint	evaluation	4393-2
111–115 instance	left	attribute	right	4393-2
evaluation		sequential	112 complex value	4393-2
112 complex value		sequential	164	4393-2
164		sequential	253 database	4393-2
253 database		sequential	29 multi-way	4393-2
29 multi-way		sequential	106	4393-2
106		sequential	108	4393-2
108		sequential	135 conventional perspective	4393-2
135 conventional perspective		sequential	32	4393-2
32		sequential	56	4393-2
56		sequential	57	4393-2
57		sequential	logic	4393-2
logic		sequential	programming	4393-2
programming		sequential	169 perspective	4393-2
169 perspective		sequential	32	4393-2
32	vs.	constraint	equi-join	4393-2
equi-join	57 generalized	attribute	95 pairwise consistent	4393-2
128		sequential	136 GSM	4393-2
136 GSM		sequential	245 physical implementation	4393-2
245 physical implementation		sequential	object	4393-2
object	oriented	action	107–108 database	4393-2
107–108 database		sequential	554	4393-2
554		sequential	555 semi-join	4393-2
555 semi-join		sequential	128	4393-2
128		sequential	135 relation	4393-2
135 relation	in	constraint	SQL	4393-2
SQL		sequential	144 conventional perspective	4393-2
144 conventional perspective		sequential	32 tuple substitution	4393-2
32 tuple substitution		sequential	115	4393-2
115		sequential	logic	4393-2
logic		sequential	programming	4393-2
programming		sequential	135 perspective	4393-2
135 perspective		sequential	32	4393-2
32	vs.	constraint	cross product	4393-2
cross product		sequential	58	4393-2
58	relativized	action	77	4393-2
77	vs.	constraint	intersection	4393-2
intersection		sequential	58 semantic data model	4393-2
58 semantic data model		sequential	245	4393-2
245	vs.	constraint	tableau	4393-2
tableau		sequential	197 join decomposition	4393-2
197 join decomposition		sequential	114–115 instantiation	4393-2
114–115 instantiation		sequential	277 join dependency	4393-2
277 join dependency		sequential	jd	4393-2
jd		sequential	161	4393-2
161		sequential	169–173	4393-2
169–173		sequential	170	4393-2
170		sequential	218 integrity constraint	4393-2
218 integrity constraint		sequential	6	4393-2
6		sequential	28	4393-2
28		sequential	157	4393-2
157		sequential	186	4393-2
186	vs.	constraint	order	4393-2
order		sequential	logic	4393-2
logic		sequential	186	4393-2
186		sequential	234 intended model	4393-2
234 intended model		sequential	279 intensional database	4393-2
279 intensional database		sequential	id6	4393-2
id6		sequential	42	4393-2
42		sequential	49	4393-2
49		sequential	279 complexity	4393-2
279 complexity	of	constraint	implication	4393-2
implication		sequential	169 intensional relation	4393-2
169 intensional relation		sequential	42	4393-2
42		sequential	48	4393-2
48		sequential	277 interpretable formula	4393-2
277 interpretable formula	77 embedded	action	233 interpretation	4393-2
233 interpretation		sequential	Gentzen	4393-2
Gentzen		sequential	style	4393-2
style		sequential	23 axiomatization	4393-2
23 axiomatization		sequential	186 n- ary	4393-2
186 n- ary	78 projected	action	74	4393-2
186 n- ary	233 relativized	action	74	4393-2
74		sequential	77–78 satisfies	4393-2
77–78 satisfies		sequential	78	4393-2
78	vs.	constraint	axiomatization	4393-2
axiomatization		sequential	171	4393-2
171		sequential	186 intersection	4393-2
186 intersection		sequential	33	4393-2
33	vs.	constraint	functional dependency	4393-2
functional dependency		sequential	169	4393-2
169		sequential	171	4393-2
171		sequential	178	4393-2
178	in	constraint	relational algebra	4393-2
relational algebra		sequential	71	4393-2
71	vs.	constraint	multi-valued dependency	4393-2
multi-valued dependency		sequential	170	4393-2
170		sequential	182	4393-2
182	vs.	constraint	natural join	4393-2
natural join		sequential	169	4393-2
169	in	constraint	SQL	4393-2
SQL		sequential	146	4393-2
146	vs.	constraint	SPJR algebra	4393-2
SPJR algebra		sequential	181	4393-2
181	vs.	constraint	join	4393-2
join		sequential	58	4393-2
58	vs.	constraint	unrestricted implication	4393-2
unrestricted implication		sequential	199 invented value	4393-2
199 invented value		sequential	469 Index join detachment	4393-2
469 Index join detachment		sequential	114	4393-2
114		sequential	135	4393-2
135	of	constraint	ind	4393-2
ind		sequential	s	4393-2
s		sequential	192	4393-2
192		sequential	195 –197 join tree	4393-2
195 –197 join tree		sequential	130	4393-2
130		sequential	136	4393-2
136	of	constraint	mvd	4393-2
mvd		sequential	logical level	4393-2
logical level	of	constraint	three level	4393-2
three level		sequential	architecture	4393-2
architecture		sequential	106 k- ary axiomatization	4393-2
106 k- ary axiomatization		sequential	202	4393-2
202		sequential	204 logical theory	4393-2
204 logical theory	and	conjunctive	updates	4393-2
updates		sequential	594 key	4393-2
594 key		sequential	257	4393-2
257		sequential	543 logspace complexity	4393-2
543 logspace complexity	of	constraint	order	4393-2
order		sequential	queries	4393-2
queries		sequential	430	4393-2
430		sequential	–431	4393-2
–431	in	constraint	semantic data model	4393-2
semantic data model		sequential	247 lossless join	4393-2
247 lossless join		sequential	164	4393-2
164		sequential	253 key dependency	4393-2
253 key dependency		sequential	163	4393-2
163		sequential	Löwenheim	4393-2
Löwenheim		sequential	Skolem	4393-2
Skolem		sequential	theorem	4393-2
theorem		sequential	267	4393-2
267	vs.	constraint	functional dependency	4393-2
functional dependency		sequential	key	4393-2
key	based	action	161 inclusion dependency	4393-2
161 inclusion dependency		sequential	250	4393-2
250		sequential	260 magic set rewriting	4393-2
260 magic set rewriting		sequential	311	4393-2
311		sequential	324–335	4393-2
324–335		sequential	KL	4393-2
KL		sequential	325	4393-2
325		sequential	336 Knaster	4393-2
336 Knaster		sequential	Tarski	4393-2
Tarski		sequential	Theorem	4393-2
Theorem		sequential	286 original	4393-2
286 original		sequential	340	4393-2
340	vs.	constraint	QSQ	4393-2
QSQ		sequential	324	4393-2
324		sequential	memory	4393-2
memory		sequential	327 buffering	4393-2
327 buffering		sequential	106	4393-2
106		sequential	107 lambda	4393-2
107 lambda		sequential	calculus	4393-2
calculus	sorted	action	574 query language	4393-2
574 query language	–	sequential	154	4393-2
154		sequential	153 language	4393-2
153 language		sequential	13 –20 map	4393-2
13 –20 map		sequential	540 late binding	4393-2
540 late binding		sequential	552 map filter	4393-2
552 map filter		sequential	518 LDL	4393-2
518 LDL		sequential	337	4393-2
337		sequential	409	4393-2
409		sequential	533	4393-2
533		sequential	538	4393-2
538		sequential	613 materizialized view	4393-2
613 materizialized view		sequential	51 update language	4393-2
51 update language		sequential	583 mathematical logic	4393-2
583 mathematical logic		sequential	20	4393-2
20	–	sequential	27	4393-2
27	to	constraint	evaluation matrix	4393-2
evaluation matrix	of	constraint	formula	4393-2
formula		sequential	82 datalog	4393-2
82 datalog		sequential	318 maximum	4393-2
318 maximum	in	constraint	SQL	4393-2
SQL		sequential	154 join	4393-2
154 join		sequential	112 memo-ing	4393-2
112 memo-ing		sequential	335 linear bounded Turing machine	4393-2
335 linear bounded Turing machine		sequential	196 message	4393-2
196 message		sequential	552 linear datalog	4393-2
552 linear datalog		sequential	305	4393-2
305		sequential	316 method	4393-2
316 method		sequential	543	4393-2
543		sequential	551 linear programming	4393-2
551 linear programming		sequential	97 languages	4393-2
97 languages		sequential	563–571 Lisp	4393-2
563–571 Lisp		sequential	573 method resolution	4393-2
573 method resolution		sequential	546	4393-2
546		sequential	21 method schema	4393-2
21 method schema		sequential	563	4393-2
563		sequential	566–571	4393-2
566–571	in	constraint	nr-datalog¬ rule	4393-2
nr-datalog¬ rule		sequential	72 monadic	4393-2
72 monadic		sequential	543	4393-2
543		sequential	563	4393-2
563		sequential	565	4393-2
565		sequential	567	4393-2
567		sequential	568	4393-2
568		sequential	577 local stratification	4393-2
577 local stratification		sequential	411 polyadic	4393-2
411 polyadic		sequential	567	4393-2
567		sequential	568	4393-2
568		sequential	577 logic	4393-2
<B>	See	action	mathematical logic	4393-3
mgu		sequential	612	4394-1
612		sequential	619 Microsoft Access	4394-1
619 Microsoft Access		sequential	36	4394-1
36		sequential	143	4394-1
143		sequential	150	4394-1
150		sequential	152–153	4394-1
152–153		sequential	155 three	4394-1
155 three	valued	action	389–391 minimal cover	4394-1
389–391 minimal cover		sequential	257 logic programming	4394-1
257 logic programming		sequential	97 minimal tableau query	4394-1
97 minimal tableau query		sequential	118 constraints	4394-1
118 constraints		sequential	97 minimization	4394-1
97 minimization	of	constraint	tableau queries	4394-1
tableau queries		sequential	105	4394-1
105		sequential	119	4394-1
119		sequential	object	4394-1
object	oriented	action	136 database	4394-1
136 database		sequential	572 minimum	4394-1
572 minimum	in	constraint	SQL	4394-1
SQL		sequential	154	4394-1
154	vs.	constraint	datalog	4394-1
datalog		sequential	35 minimum model	4394-1
35 minimum model		sequential	logic	4394-1
logic		sequential	programming	4394-1
programming		sequential	275 perspective	4394-1
275 perspective	on	constraint	relations	4394-1
relations		sequential	32	4394-1
32		sequential	33 modal operator	4394-1
33 modal operator		sequential	503 Logical Data Model	4394-1
503 Logical Data Model		sequential	LDM	4394-1
LDM		sequential	97 model	4394-1
97 model		sequential	24 logical database	4394-1
24 logical database		sequential	503 database	4394-1
503 database		sequential	28 logical implication	4394-1
28 logical implication		sequential	21 datalog	4394-1
21 datalog		sequential	28	4394-1
28	–	sequential	34	4394-1
34	under	constraint	204 semantic data	4394-1
34	closed	action	204 semantic data	4394-1
204 semantic data		sequential	243	4394-1
243		sequential	245–253	4394-1
245–253		sequential	267	4394-1
267	under	constraint	k-ary	4394-1
267	closed	action	k-ary	4394-1
k-ary		sequential	204 modification	4394-1
204 modification		sequential	580	4394-1
580	of	constraint	dependencies	4394-1
dependencies		sequential	160	4394-1
160		sequential	164	4394-1
164		sequential	193 modification anomaly	4394-1
193 modification anomaly		sequential	162	4394-1
162	in	constraint	view	4394-1
view		sequential	221	4394-1
221		sequential	modified RANF	4394-1
modified RANF		sequential	88	4394-1
88	of	constraint	fd	4394-1
fd		sequential	s	4394-1
s		sequential	165	4394-1
165		sequential	186 modus ponens	4394-1
186 modus ponens		sequential	24	4394-1
24	of	constraint	fd	4394-1
fd		sequential	s	4394-1
s	and	conjunctive	ind	4394-1
ind		sequential	s	4394-1
s		sequential	192 monadic datalog program	4394-1
192 monadic datalog program		sequential	197–199 monadic method	4394-1
197–199 monadic method		sequential	schema	4394-1
schema		sequential	543	4394-1
543		sequential	563	4394-1
563		sequential	565	4394-1
565		sequential	567	4394-1
567		sequential	568	4394-1
568	vs.	constraint	202	4394-1
202		sequential	219	4394-1
219		sequential	234 full dependencies monoid	4394-1
234 full dependencies monoid		sequential	199 complexity	4394-1
199 complexity		sequential	221 monotone operator	4394-1
221 monotone operator		sequential	283 Index monotonic query	4394-1
283 Index monotonic query		sequential	42 negation	4394-1
42 negation		sequential	36 monotonicity	4394-1
36 monotonicity	in	constraint	Microsoft Access	4394-1
Microsoft Access		sequential	153 pushing	4394-1
153 pushing		sequential	83	4394-1
83	in	constraint	QBE	4394-1
QBE		sequential	150 most general unifier	4394-1
150 most general unifier		sequential	mgu	4394-1
mgu		sequential	293	4394-1
293	in	constraint	selections	4394-1
selections		sequential	68 multi-head dependency	4394-1
68 multi-head dependency		sequential	217	4394-1
217	in	constraint	SQL	4394-1
SQL		sequential	143 multi-way	4394-1
143 multi-way	join stratified	action	49 decomposition	4394-1
49 decomposition		sequential	114–115	4394-1
114–115	vs.	constraint	set difference	4394-1
set difference		sequential	70 detachment	4394-1
70 detachment		sequential	114	4394-1
114		sequential	135 Negation	4394-1
135 Negation	as	constraint	Failure	4394-1
Failure		sequential	27	4394-1
27		sequential	406 implementation	4394-1
406 implementation		sequential	106	4394-1
106		sequential	108	4394-1
108		sequential	111–115	4394-1
111–115	to	constraint	evaluation	4394-1
111–115	288 left	attribute	right	4394-1
evaluation		sequential	112 nest	4394-1
112 nest		sequential	518 tuple substitution	4394-1
518 tuple substitution		sequential	115	4394-1
115		sequential	135 nested loop implementation	4394-1
135 nested loop implementation	of	constraint	join	4394-1
join		sequential	107	4394-1
107		sequential	108 multiset	4394-1
108 multiset		sequential	92	4394-1
92		sequential	136	4394-1
136		sequential	145 nested relation	4394-1
145 nested relation		sequential	512 multivalued dependency	4394-1
512 multivalued dependency		sequential	mvd	4394-1
mvd		sequential	161	4394-1
161		sequential	169–173	4394-1
169–173		sequential	170	4394-1
170		sequential	nested SQL query	4394-1
nested SQL query		sequential	143	4394-1
143		sequential	146–147 network model	4394-1
146–147 network model		sequential	28	4394-1
28		sequential	559 dependency basis	4394-1
559 dependency basis		sequential	172 NF2	4394-1
<B>	See	action	nested relation	4394-2
<B>	embedded	action	218	4395-1
218		sequential	220	4395-1
220		sequential	233 no-information null	4395-1
233 no-information null		sequential	502 original definition	4395-1
502 original definition		sequential	189 non-existing null	4395-1
189 non-existing null		sequential	502 satisfies	4395-1
502 satisfies		sequential	170 nondeterminism	4395-1
170 nondeterminism		sequential	15 semantics	4395-1
15 semantics	of	constraint	negation	4395-1
negation		sequential	409	4395-1
409	vs.	constraint	functional dependency	4395-1
functional dependency		sequential	171 nondeterministic query	4395-1
<B>	See	action	query	4395-2
query		sequential	<B>	4395-2
<B>	vs.	constraint	dependency	4396-1
<B>	join	action	dependency	4396-1
dependency		sequential	170 noninflationary datalog¬ 357	4396-1
170 noninflationary datalog¬ 357	vs.	constraint	propositional logic	4396-1
propositional logic		sequential	nr	4396-1
nr		sequential	datalog mutual recursion	4396-1
datalog mutual recursion		sequential	315	4396-1
315	with	constraint	negation	4396-1
negation		sequential	70	4396-1
70		sequential	72–73 mvd	4396-1
72–73 mvd	See	action	multivalued dependency	4396-1
program		sequential	72 nonrecursive datalog program	4397-1
72 nonrecursive datalog program		sequential	62 normal form	4397-1
62 normal form		sequential	N	4397-1
N		sequential	158 datalog¬	4397-1
158 datalog¬		sequential	¬	4397-1
¬		sequential	463 Boyce	4397-1
463 Boyce		sequential	Codd	4397-1
Codd		sequential	BCNF	4397-1
BCNF		sequential	250	4397-1
250		sequential	251 N1NF	4397-1
<B>	See	action	nested relation	4397-2
decomposition algorithm		sequential	255 NAIL	4398-1
255 NAIL		sequential	337	4398-1
337		sequential	409	4398-1
409		sequential	CNF	4398-1
CNF		sequential	83 naive evaluation conjunctive calculus	4398-1
83 naive evaluation conjunctive calculus		sequential	46	4398-1
46	–	sequential	47	4398-1
47	of	constraint	datalog	4398-1
datalog		sequential	312	4398-1
312		sequential	DNF	4398-1
DNF		sequential	83	4398-1
83	of	constraint	SPC query	4398-1
SPC query		sequential	109 domain	4398-1
109 domain		sequential	265 naive table	4398-1
265 naive table		sequential	492	4398-1
492		sequential	265 named perspective	4398-1
265 named perspective		sequential	31	4398-1
31		sequential	32 fourth	4398-1
32 fourth		sequential	4NF	4398-1
4NF		sequential	252	4398-1
252		sequential	252	4398-1
252		sequential	259 nr-datalog	4398-1
259 nr-datalog		sequential	68 projection	4398-1
68 projection		sequential	57 prenex	4398-1
57 prenex		sequential	PNF	4398-1
PNF		sequential	82 relational algebra	4398-1
82 relational algebra		sequential	project	4398-1
project		sequential	71 join	4398-1
71 join		sequential	PJ/NF	4398-1
PJ/NF		sequential	265	4398-1
265		sequential	267 selection	4398-1
267 selection		sequential	57 relational algebra	4398-1
57 relational algebra		sequential	RANF	4398-1
RANF		sequential	86	4398-1
86		sequential	97 SPJR algebra	4398-1
97 SPJR algebra		sequential	56	4398-1
56		sequential	–59	4398-1
–59		sequential	57 relational schema	4398-1
57 relational schema		sequential	251–259	4398-1
251–259		sequential	265 tuple	4398-1
265 tuple		sequential	32 safe range	4398-1
32 safe range		sequential	SRNF	4398-1
SRNF		sequential	83	4398-1
83	vs.	constraint	unnamed perspective	4398-1
unnamed perspective		sequential	32 SPC algebra	4398-1
32 SPC algebra		sequential	55 named value	4398-1
55 named value		sequential	554	4398-1
554		sequential	556 SPCU algebra	4398-1
556 SPCU algebra		sequential	62 root	4398-1
62 root	of	constraint	persistence	4398-1
persistence		sequential	556 SPJR algebra	4398-1
556 SPJR algebra		sequential	59 natural interpretation	4398-1
59 natural interpretation		sequential	78 SPJRU algebra	4398-1
78 SPJRU algebra		sequential	62 natural join	4398-1
62 natural join		sequential	56	4398-1
56		sequential	57	4398-1
57		sequential	3NF	4398-1
3NF		sequential	257 polyadic	4398-1
257 polyadic		sequential	58 decomposition algorithm	4398-1
58 decomposition algorithm		sequential	257	4398-1
257	vs.	constraint	equi-join	4398-1
equi-join		sequential	57 synthesis algorithm	4398-1
57 synthesis algorithm		sequential	257	4398-1
257	vs.	constraint	join dependency	4398-1
join dependency		sequential	169 now	4398-1
169 now		sequential	607 natural semantics	4398-1
607 natural semantics	of	constraint	relational calculus	4398-1
relational calculus		sequential	78	4398-1
78		sequential	79 np	4398-1
79 np		sequential	18 nc	4398-1
18 nc		sequential	96	4398-1
96		sequential	431	4398-1
431		sequential	np-	4398-1
np-		sequential	105	4398-1
105		sequential	121	4398-1
121		sequential	122	4398-1
122		sequential	127 Index np	4398-1
127 Index np		sequential	121 dynamic binding	4398-1
121 dynamic binding		sequential	543	4398-1
543		sequential	546	4398-1
546		sequential	552 npspace	4398-1
552 npspace		sequential	18 encapsulation	4398-1
18 encapsulation		sequential	543	4398-1
543		sequential	546	4398-1
546		sequential	553 nr-datalog	4398-1
553 nr-datalog		sequential	62 expansion	4398-1
62 expansion	of	constraint	value	4398-1
value		sequential	558 normal form	4398-1
558 normal form		sequential	68 formal definition	4398-1
68 formal definition		sequential	547–555 nr-datalog¬	4398-1
547–555 nr-datalog¬		sequential	70	4398-1
70		sequential	72–73 generic OODB model	4398-1
72–73 generic OODB model		sequential	547–556	4398-1
547–556		sequential	ILDG	4398-1
ILDG		sequential	580	4398-1
580	with	constraint	equality	4398-1
equality		sequential	72	4398-1
72		sequential	73 imperative methods	4398-1
73 imperative methods		sequential	564–566	4398-1
564–566		sequential	573 equivalence	4398-1
573 equivalence	to	constraint	order	4398-1
order		sequential	languages	4398-1
languages		sequential	80 expressive power	4398-1
80 expressive power		sequential	565	4398-1
565		sequential	–566	4398-1
–566		sequential	72 inheritance	4398-1
72 inheritance		sequential	546	4398-1
546		sequential	552	4398-1
552		sequential	553	4398-1
553		sequential	567	4398-1
567		sequential	573–575	4398-1
573–575		sequential	577 program	4398-1
577 program		sequential	72 instance	4398-1
72 instance		sequential	554	4398-1
554		sequential	555 query	4398-1
555 query		sequential	73 IQL	4398-1
73 IQL		sequential	573 range	4398-1
573 range	restricted	action	72 ISA	4398-1
72 ISA		sequential	543	4398-1
543		sequential	545	4398-1
545	with	constraint	equality	4398-1
equality		sequential	72 languages	4398-1
72 languages	for	constraint	methods	4398-1
methods		sequential	563 –571 rule	4398-1
563 –571 rule		sequential	72 late binding	4398-1
72 late binding		sequential	552 semantics	4398-1
552 semantics		sequential	72 logic programming	4398-1
72 logic programming		sequential	572	4398-1
572		sequential	574 translation	4398-1
574 translation	into	constraint	SQL	4398-1
SQL		sequential	147–149 message	4398-1
147–149 message		sequential	552 method	4398-1
552 method		sequential	551 NU	4398-1
551 NU		sequential	Prolog	4398-1
Prolog		sequential	337 signature	4398-1
337 signature		sequential	551 null value	4398-1
551 null value		sequential	488	4398-1
488	well formed	action	553 method resolution	4398-1
553 method resolution		sequential	546	4398-1
546		sequential	552 method	4398-1
552 method		sequential	schema	4398-1
schema		sequential	563	4398-1
563		sequential	566–571	4398-1
566–571		sequential	O2	4398-1
O2		sequential	562	4398-1
562		sequential	573 expressive power	4398-1
573 expressive power		sequential	569–571	4398-1
569–571		sequential	O2SQL	4398-1
O2SQL		sequential	510	4398-1
510		sequential	536–537	4398-1
536–537		sequential	562 monadic	4398-1
562 monadic		sequential	543	4398-1
543		sequential	563	4398-1
563		sequential	565	4398-1
565		sequential	567	4398-1
567		sequential	568	4398-1
568		sequential	577 obj	4398-1
577 obj		sequential	547 polyadic	4398-1
547 polyadic		sequential	56	4398-1
56		sequential	7	4398-1
7		sequential	568	4398-1
568		sequential	577 object	4398-1
577 object		sequential	246	4398-1
246		sequential	543	4398-1
543		sequential	545	4398-1
545		sequential	547	4398-1
547		sequential	573	4398-1
573		sequential	named value	4398-1
named value		sequential	554	4398-1
554		sequential	556 object creation	4398-1
556 object creation		sequential	573	4398-1
573	See	action	object	4398-1
object	oriented	action	database	4398-1
database		sequential	object	4398-1
object		sequential	543	4398-1
543		sequential	545	4398-1
545		sequential	547	4398-1
547		sequential	573 object creation	4398-1
object creation		sequential	558 –562	4399-1
558 –562		sequential	573	4399-1
573		sequential	574 object equality	4399-1
574 object equality		sequential	557 object equality	4399-1
557 object equality		sequential	557 object history	4399-1
557 object history		sequential	615 object identifier	4399-1
615 object identifier		sequential	543	4399-1
543		sequential	545	4399-1
545		sequential	547 object identifier	4399-1
547 object identifier		sequential	OID	4399-1
OID		sequential	473	4399-1
473		sequential	543	4399-1
543		sequential	545 –547 object migration	4399-1
545 –547 object migration		sequential	572 semantic data model	4399-1
572 semantic data model		sequential	243 OID assignment	4399-1
243 OID assignment		sequential	550 object migration	4399-1
550 object migration		sequential	572	4399-1
572		sequential	613	4399-1
613		sequential	615 OID isomorphism	4399-1
615 OID isomorphism		sequential	555	4399-1
555		sequential	object	4399-1
object	oriented	action	560 data model	4399-1
560 data model		sequential	28	4399-1
28		sequential	245	4399-1
245		sequential	477	4399-1
477		sequential	546 overriding	4399-1
546 overriding		sequential	object	4399-1
object	oriented	action	546 database	4399-1
546 database		sequential	8	4399-1
8		sequential	242	4399-1
242		sequential	473	4399-1
473		sequential	542–578 parallelism	4399-1
542–578 parallelism		sequential	573 calculus	4399-1
573 calculus		sequential	574 class	4399-1
574 class		sequential	545 query language	4399-1
545 query language		sequential	556 –563 class hierarchy	4399-1
556 –563 class hierarchy		sequential	549 querying schema	4399-1
549 querying schema	572 well formed	action	549 reachability	4399-1
549 reachability		sequential	565 classification	4399-1
565 classification		sequential	572	4399-1
572		sequential	575 receiver	4399-1
575 receiver		sequential	552 completeness	4399-1
552 completeness		sequential	560	4399-1
560		sequential	–561	4399-1
–561		sequential	560	4399-1
560		sequential	574 role	4399-1
574 role		sequential	571 complex value	4399-1
571 complex value		sequential	545 schema	4399-1
545 schema		sequential	554 consistency	4399-1
554 consistency		sequential	See	4399-1
See		sequential	object	4399-1
object	oriented	action	database	4399-1
database		sequential	type schema design	4399-1
type schema design		sequential	571 safety specialization	4399-1
571 safety specialization		sequential	context	4399-1
context		sequential	545 binding	4399-1
545 binding		sequential	552 static binding	4399-1
552 static binding		sequential	552 covariance	4399-1
552 covariance		sequential	553 subtyping relationship	4399-1
553 subtyping relationship		sequential	549 dangling reference	4399-1
549 dangling reference		sequential	999	4399-1
999		sequential	572 type	4399-1
572 type		sequential	548 dba mode	4399-1
548 dba mode		sequential	546 disjoint interpretation	4399-1
546 disjoint interpretation		sequential	575 semantics	4399-1
575 semantics		sequential	550 deep equality	4399-1
550 deep equality		sequential	557	4399-1
557		sequential	575 type safety	4399-1
575 type safety		sequential	563	4399-1
563		sequential	565	4399-1
565		sequential	567	4399-1
567		sequential	573 dereferencing	4399-1
573 dereferencing		sequential	557	4399-1
557		sequential	558	4399-1
558		sequential	559 user mode	4399-1
559 user mode		sequential	546 determinate query	4399-1
546 determinate query		sequential	559 value	4399-1
559 value		sequential	547 domain	4399-1
547 domain		sequential	inclusion semantics	4399-1
inclusion semantics		sequential	551 value equality	4399-1
551 value equality		sequential	557 dynamic aspect 572	4399-1
557 dynamic aspect 572		sequential	value	4399-1
value		sequential	binding	4399-1
binding		sequential	552 Index object	4399-1
552 Index object	oriented	action	database	4399-1
database	in	constraint	not 437 view	4399-1
database	while	constraint	not 437 view	4399-1
database	continued	action	not 437 view	4399-1
not 437 view		sequential	571 partial fixpoint logic	4399-1
571 partial fixpoint logic		sequential	CALC	4399-1
CALC		sequential	+µ	4399-1
+µ		sequential	348	4399-1
348		sequential	349–352	4399-1
349–352		sequential	object	4399-1
object	oriented	action	programming languages	4399-1
programming languages		sequential	573 partial fixpoint operator	4399-1
573 partial fixpoint operator		sequential	µ	4399-1
µ		sequential	orienteddatabase	4399-1
orienteddatabase		sequential	349 object partial order	4399-1
349 object partial order		sequential	11 consistency	4399-1
<B>	See	action	database type partially ordered set	4399-2
<B>	object oriented	action	database type partially ordered set	4399-2
database type partially ordered set		sequential	11 safety	4399-2
path	in	constraint	hypergraph	4400-1
hypergraph		sequential	132 ODE	4400-1
132 ODE		sequential	615 PCP	4400-1
615 PCP		sequential	16 OID permutation	4400-1
16 OID permutation		sequential	13 physical implementation	4400-1
13 physical implementation		sequential	106–108 cross product	4400-1
106–108 cross product		sequential	108 semantic data model	4400-1
108 semantic data model		sequential	243 equi-join	4400-1
243 equi-join		sequential	107–108 OODB	4400-1
107–108 OODB		sequential	242	4400-1
242	See	action	object	4400-1
object	oriented	action	database	4400-1
projection		sequential	107 Open World Assumption	4401-1
107 Open World Assumption		sequential	OWA	4401-1
OWA		sequential	489	4401-1
489		sequential	497	4401-1
497		sequential	595 relational algebra	4401-1
595 relational algebra		sequential	107–108 operator selection	4401-1
107–108 operator selection		sequential	286 physical level monotone	4401-1
286 physical level monotone		sequential	283	4401-1
283	of	constraint	three level	4401-1
three level		sequential	architecture	4401-1
architecture		sequential	106 OPS5	4401-1
106 OPS5		sequential	369	4401-1
369		sequential	370 physical model	4401-1
370 physical model	of	constraint	relational database	4401-1
relational database		sequential	106–107 optimization PNF	4401-1
106–107 optimization PNF		sequential	82 conjunctive queries	4401-1
82 conjunctive queries		sequential	36	4401-1
36		sequential	105 polyadic	4401-1
105 polyadic	using	action	chase	4401-1
chase		sequential	163 conjunction	4401-1
163 conjunction		sequential	46	4401-1
46		sequential	75	4401-1
75		sequential	83	4401-1
83	using	action	dependencies	4401-1
dependencies		sequential	163 disjunction	4401-1
163 disjunction		sequential	75	4401-1
75		sequential	83 datalog	4401-1
83 datalog		sequential	36	4401-1
36		sequential	112	4401-1
112		sequential	311–337 existential quantification	4401-1
311–337 existential quantification		sequential	83 natural join	4401-1
83 natural join		sequential	58	4401-1
58	in	constraint	practical systems	4401-1
practical systems		sequential	105	4401-1
105		sequential	106–115 polyadic method schema	4401-1
106–115 polyadic method schema		sequential	567	4401-1
567		sequential	568	4401-1
568		sequential	577 relational algebra	4401-1
577 relational algebra		sequential	106 polynomial inequalities constraint	4401-1
106 polynomial inequalities constraint		sequential	96	4401-1
96		sequential	97 transaction	4401-1
97 transaction		sequential	581 positive existential calculus	4401-1
581 positive existential calculus		sequential	91	4401-1
91		sequential	97	4401-1
97	using	action	chase	4401-1
chase		sequential	177–180 decidability	4401-1
177–180 decidability		sequential	99	4401-1
99	or	conjunctive	sets	4401-1
sets		sequential	288 ORACLE	4401-1
288 ORACLE		sequential	34	4401-1
34		sequential	155 positive selection formula	4401-1
155 positive selection formula		sequential	67 ordered database	4401-1
67 ordered database		sequential	397	4401-1
397		sequential	447 poss	4401-1
447 poss		sequential	T	4401-1
T		sequential	490 output schema	4401-1
490 output schema	of	constraint	query	4401-1
query		sequential	37 Post Correspondence Problem	4401-1
37 Post Correspondence Problem		sequential	PCP	4401-1
PCP		sequential	16	4401-1
16		sequential	overriding	4401-1
overriding		sequential	546 OWA	4401-1
546 OWA		sequential	489	4401-1
489		sequential	497	4401-1
497		sequential	595	4401-1
595		sequential	POSTGRES	4401-1
POSTGRES		sequential	153	4401-1
153		sequential	600 powerset	4401-1
600 powerset		sequential	514 precedence graph P	4401-1
514 precedence graph P		sequential	I	4401-1
I		sequential	280	4401-1
280		sequential	378	4401-1
378		sequential	383	4401-1
383		sequential	387	4401-1
387	in	constraint	datalog evaluation	4401-1
datalog evaluation		sequential	315 pg	4401-1
315 pg		sequential	P	4401-1
P		sequential	I	4401-1
I		sequential	389	4401-1
389	in	constraint	datalog¬	4401-1
datalog¬		sequential	379 P wf	4401-1
379 P wf		sequential	390 negative edge	4401-1
390 negative edge		sequential	380 page fetch	4401-1
380 page fetch		sequential	107 positive edge	4401-1
107 positive edge		sequential	380 page size	4401-1
380 page size		sequential	106 predicate	4401-1
106 predicate		sequential	277 paging protocol	4401-1
277 paging protocol		sequential	106 prenex normal form	4401-1
106 prenex normal form		sequential	PNF	4401-1
PNF		sequential	82	4401-1
82		sequential	pairwise consistent join	4401-1
pairwise consistent join		sequential	128	4401-1
128		sequential	136	4401-1
136	vs.	constraint	35	4401-1
35		sequential	53 Paradox	4401-1
53 Paradox		sequential	152	4401-1
152		sequential	155 product parallel complexity Cartesian	4401-1
155 product parallel complexity Cartesian		sequential	52 classes	4401-1
52 classes	of	constraint	circuits	4401-1
circuits		sequential	431 cross	4401-1
431 cross		sequential	52	4401-1
52		sequential	54	4401-1
54		sequential	58	4401-1
58		sequential	108	4401-1
108		sequential	144	4401-1
144	of	constraint	order	4401-1
order		sequential	queries	4401-1
queries		sequential	431–433 direct	4401-1
431–433 direct		sequential	235	4401-1
235		sequential	240 parameterized IDM transaction	4401-1
240 parameterized IDM transaction		sequential	584 production rule system	4401-1
584 production rule system		sequential	369 call	4401-1
369 call		sequential	584 program schema	4401-1
584 program schema		sequential	574 parametrized query	4401-1
574 parametrized query		sequential	522 project	4401-1
522 project		sequential	join	4401-1
join		sequential	expression paramodulation	4401-1
expression paramodulation	vs.	constraint	chase	4401-1
chase	186 extended	action	229 parity query project	4401-1
229 parity query project	join	action	normal form	4401-1
normal form		sequential	PJ	4401-1
PJ	/	sequential	NF	4401-1
NF		sequential	267	4401-1
267		sequential	not order	4401-1
not order		sequential	project	4401-1
project	join	action	460 query	4401-1
460 query		sequential	126 Index projection	4401-1
126 Index projection		sequential	52 conjunctive	4401-1
52 conjunctive		sequential	36	4401-1
36	–	sequential	64	4401-1
64		sequential	37 conjunctive calculus	4401-1
37 conjunctive calculus	–	sequential	47	4401-1
47		sequential	44 named perspective	4401-1
44 named perspective		sequential	57 containment	4401-1
57 containment	to	constraint	dependencies	4401-1
dependencies		sequential	37	4401-1
37		sequential	177 physical implementation	4401-1
177 physical implementation		sequential	107	4401-1
107		sequential	97 pushing	4401-1
97 pushing		sequential	474	4401-1
474	in	constraint	SQL	4401-1
SQL		sequential	144 equivalence	4401-1
144 equivalence		sequential	37 unnamed perspective	4401-1
37 unnamed perspective		sequential	54	4401-1
54	to	constraint	dependencies	4401-1
dependencies		sequential	176	4401-1
176		sequential	177 proof	4401-1
177 proof		sequential	24 order	4401-1
24 order		sequential	70	4401-1
70	using	action	inference rules	4401-1
inference rules		sequential	167 genericity	4401-1
167 genericity		sequential	419–421	4401-1
419–421		sequential	419	4401-1
419		sequential	425 proof tree	4401-1
425 proof tree		sequential	286 C	4401-1
286 C		sequential	genericity	4401-1
genericity		sequential	419–420 propositional calculus	4401-1
419–420 propositional calculus		sequential	21 input schema	4401-1
21 input schema		sequential	37 propositional logic	4401-1
37 propositional logic		sequential	21	4401-1
21	with	constraint	invented values	4401-1
invented values		sequential	469	4401-1
469	vs.	constraint	fd	4401-1
fd		sequential	s	4401-1
s	and	conjunctive	mvd	4401-1
mvd		sequential	s	4401-1
s		sequential	186	4401-1
186		sequential	42 pspace	4401-1
42 pspace		sequential	453–457 pspace complexity CALC	4401-1
453–457 pspace complexity CALC		sequential	+µ	4401-1
+µ	+	sequential	<B>	4401-1
<B>		sequential	143–155	4402-1
143–155		sequential	Rado graph	4402-1
Rado graph		sequential	442	4402-1
442		sequential	461 relational algebra	4402-1
461 relational algebra		sequential	28	4402-1
28		sequential	35	4402-1
35		sequential	36 RANF	4402-1
36 RANF		sequential	86	4402-1
86		sequential	97 relational calculus	4402-1
97 relational calculus		sequential	28	4402-1
28		sequential	35	4402-1
35		sequential	36 set	4402-1
36 set	at	constraint	a-	4402-1
a-		sequential	time	4402-1
time	35 modified	action	88 static analysis	4402-1
88 static analysis		sequential	36	4402-1
36		sequential	105	4402-1
105		sequential	122–126	4402-1
122–126		sequential	606–613 three paradigms	4402-1
606–613 three paradigms		sequential	35 –36 calculus query	4402-1
35 –36 calculus query		sequential	97 Query Management Facility	4402-1
97 Query Management Facility		sequential	QMF	4402-1
QMF		sequential	83	4402-1
83		sequential	84 query mapping	4402-1
84 query mapping	vs.	constraint	query	4402-1
query		sequential	37 conjunctive query	4402-1
37 conjunctive query	with	constraint	equality	4402-1
equality		sequential	41	4402-1
41		sequential	48 query optimization	4402-1
48 query optimization		sequential	36	4402-1
36		sequential	105 formula	4402-1
105 formula		sequential	102 cost model	4402-1
102 cost model		sequential	106	4402-1
106		sequential	108 –110 nr-datalog¬	4402-1
108 –110 nr-datalog¬		sequential	72 distributed database	4402-1
72 distributed database		sequential	128	4402-1
128	with	constraint	equality	4402-1
equality		sequential	65	4402-1
65		sequential	72 evaluation plan	4402-1
72 evaluation plan		sequential	107	4402-1
107		sequential	108	4402-1
108		sequential	110 –111	4402-1
110 –111		sequential	135 rule	4402-1
135 rule		sequential	41 range separable query	4402-1
41 range separable query		sequential	97	4402-1
97	in	constraint	INGRES	4402-1
INGRES		sequential	114–115 rank	4402-1
114–115 rank		sequential	402 join detachment	4402-1
402 join detachment		sequential	114	4402-1
114		sequential	135 RDL	4402-1
135 RDL		sequential	369	4402-1
369	vs.	constraint	115	4402-1
115		sequential	117 real closed field	4402-1
117 real closed field		sequential	96	4402-1
96		sequential	97 receiver	4402-1
97 receiver		sequential	552	4402-1
552	in	constraint	practical systems	4402-1
practical systems		sequential	106–115 reconstruction mapping	4402-1
106–115 reconstruction mapping		sequential	254 program transformation	4402-1
254 program transformation		sequential	108 rectangle	4402-1
108 rectangle		sequential	representation	4402-1
representation		sequential	95 query rewriting	4402-1
95 query rewriting		sequential	108 –110 rectified subgoal	4402-1
108 –110 rectified subgoal	in	constraint	datalog evaluation	4402-1
datalog evaluation		sequential	328	4402-1
328		sequential	query	4402-1
query		sequential	108 –110	4402-1
108 –110		sequential	108 recursive language	4402-1
108 recursive language		sequential	16 rewrite rule	4402-1
16 rewrite rule		sequential	110 Recursive QSQ	4402-1
110 Recursive QSQ		sequential	QSQR	4402-1
QSQR		sequential	323–324	4402-1
323–324	in	constraint	System R	4402-1
System R		sequential	112–114	4402-1
112–114		sequential	recursively enumerable	4402-1
recursively enumerable		sequential	16	4402-1
16	by	constraint	tableau	4402-1
tableau		sequential	minimization	4402-1
minimization		sequential	118 –120 reduced hypergraph	4402-1
118 –120 reduced hypergraph		sequential	130 tuple substitution	4402-1
130 tuple substitution		sequential	115	4402-1
115		sequential	135 redundancy	4402-1
135 redundancy	and	conjunctive	update	4402-1
update		sequential	anomalies	4402-1
anomalies		sequential	162	4402-1
162	using	action	chase	4402-1
chase		sequential	163	4402-1
163		sequential	177–180 referential integrity constraint	4402-1
177–180 referential integrity constraint	vs.	constraint	inclusion	4402-1
inclusion	using	action	dependencies	4402-1
dependencies		sequential	163 dependency	4402-1
163 dependency		sequential	161	4402-1
161		sequential	213 query rewriting	4402-1
213 query rewriting		sequential	108 –110 reflexive relation	4402-1
108 –110 reflexive relation		sequential	10 Index refutation	4402-1
10 Index refutation		sequential	290 regular language	4402-1
290 regular language		sequential	14 base formula	4402-1
14 base formula		sequential	74 regular tree	4402-1
74 regular tree		sequential	558	4402-1
558		sequential	45 relation conjunctive normal form	4402-1
45 relation conjunctive normal form		sequential	CNF	4402-1
CNF		sequential	83 complex value	4402-1
83 complex value	512 extended	action	229 disjunctive normal form	4402-1
229 disjunctive normal form		sequential	DNF	4402-1
DNF		sequential	83	4402-1
83		sequential	42	4402-1
42		sequential	48 domain calculus	4402-1
48 domain calculus		sequential	39	4402-1
39		sequential	42	4402-1
42		sequential	48 domain independence	4402-1
48 domain independence		sequential	70	4402-1
70		sequential	74	4402-1
74		sequential	75	4402-1
75		sequential	–77	4402-1
–77		sequential	79	4402-1
79		sequential	81–97 relation	4402-1
81–97 relation		sequential	instance	4402-1
instance		sequential	29 equivalence	4402-1
29 equivalence	to	constraint	first order	4402-1
first order		sequential	languages	4402-1
languages		sequential	80 conventional perspective	4402-1
80 conventional perspective		sequential	32 evaluable query	4402-1
32 evaluable query		sequential	logic	4402-1
logic		sequential	programming	4402-1
programming		sequential	97 perspective	4402-1
97 perspective		sequential	32	4402-1
32		sequential	33 formula	4402-1
33 formula		sequential	74	4402-1
74		sequential	–75	4402-1
–75	over	constraint	empty attribute set	4402-1
empty attribute set		sequential	32 equivalence	4402-1
32 equivalence		sequential	197 parse tree	4402-1
197 parse tree		sequential	83 relation atom	4402-1
83 relation atom		sequential	112	4402-1
112		sequential	217 image	4402-1
217 image	of	constraint	query	4402-1
query		sequential	78 relation schema	4402-1
78 relation schema		sequential	31 inequalities constraint	4402-1
31 inequalities constraint		sequential	96	4402-1
96		sequential	97	4402-1
97	with	constraint	dependencies	4402-1
dependencies		sequential	241 natural semantics	4402-1
241 natural semantics		sequential	78	4402-1
78		sequential	79 relational algebra	4402-1
79 relational algebra		sequential	28	4402-1
28		sequential	35	4402-1
35		sequential	36	4402-1
36		sequential	70	4402-1
70		sequential	71	4402-1
71		sequential	81 negation	4402-1
81 negation	–	sequential	71	4402-1
71		sequential	70 polynomial inequalities constraint	4402-1
70 polynomial inequalities constraint		sequential	96	4402-1
96	with	constraint	bags	4402-1
bags		sequential	68	4402-1
68		sequential	91	4402-1
91		sequential	97 complement operator	4402-1
97 complement operator		sequential	103	4402-1
103		sequential	104 prenex normal form	4402-1
104 prenex normal form		sequential	PNF	4402-1
PNF		sequential	82 composition	4402-1
82 composition		sequential	71 query	4402-1
71 query		sequential	52 –61 division	4402-1
52 –61 division		sequential	99 range restricted range separable query	4402-1
99 range restricted range separable query		sequential	97 equivalence	4402-1
97 equivalence	to	constraint	order	4402-1
order		sequential	languages	4402-1
languages		sequential	80 equivalences	4402-1
80 equivalences		sequential	106 formula	4402-1
106 formula		sequential	102 implementation	4402-1
102 implementation		sequential	106	4402-1
106		sequential	107–108 query	4402-1
107–108 query		sequential	97	4402-1
97		sequential	83	4402-1
83		sequential	84	4402-1
84	named	action	64	4402-1
64		sequential	71 relational algebra normal form	4402-1
71 relational algebra normal form		sequential	RANF	4402-1
RANF		sequential	86	4402-1
86		sequential	97	4402-1
97	named	attribute	conjunctive	4402-1
56	–	sequential	59	4402-1
59		sequential	relativized interpretation	4402-1
relativized interpretation		sequential	74	4402-1
74		sequential	77–78 optimization	4402-1
77–78 optimization		sequential	106	4402-1
106		sequential	126 rewrite rule	4402-1
126 rewrite rule		sequential	82	4402-1
82	in	constraint	practical systems	4402-1
practical systems		sequential	105	4402-1
105		sequential	106–115	4402-1
106–115	for	constraint	RANF	4402-1
RANF		sequential	86	4402-1
86	–	sequential	87	4402-1
87		sequential	physical implementation	4402-1
physical implementation		sequential	106–115	4402-1
106–115	for	constraint	SRNF	4402-1
SRNF		sequential	83	4402-1
83		sequential	safe DRC query	4402-1
safe DRC query		sequential	97 semi-join	4402-1
97 semi-join		sequential	128	4402-1
128		sequential	135 safe query	4402-1
135 safe query		sequential	64	4402-1
64		sequential	97 SPC	4402-1
97 SPC		sequential	52–56	4402-1
52–56		sequential	108	4402-1
108		sequential	118	4402-1
118		sequential	range	4402-1
range		sequential	81	4402-1
81		sequential	85	4402-1
85		sequential	83–85	4402-1
83–85		sequential	97 SPCU	4402-1
97 SPCU		sequential	62	4402-1
62		sequential	97	4402-1
97		sequential	136 normal form	4402-1
136 normal form		sequential	SRNF	4402-1
SRNF		sequential	83	4402-1
83		sequential	SPJR	4402-1
SPJR		sequential	56	4402-1
56	–	sequential	59	4402-1
59		sequential	118 safety	4402-1
118 safety		sequential	70	4402-1
70		sequential	75	4402-1
75		sequential	–77	4402-1
–77	vs.	constraint	join dependency	4402-1
join dependency		sequential	181 SPJRU	4402-1
181 SPJRU		sequential	62 semantics	4402-1
62 semantics	relativized	action	77 translation	4402-1
77 translation	into	constraint	calculus	4402-1
calculus		sequential	80 simulation	4402-1
80 simulation	of	constraint	PCP	4402-1
PCP		sequential	123 typed restricted SPJ	4402-1
123 typed restricted SPJ		sequential	156 static analysis	4402-1
156 static analysis		sequential	105	4402-1
105		sequential	122–126 syntax	4402-1
122–126 syntax		sequential	71 translation	4402-1
71 translation	into	constraint	algebra	4402-1
algebra	–	sequential	56	4402-1
56		sequential	range	4402-1
range		sequential	103 case	4402-1
103 case		sequential	81	4402-1
81		sequential	86–91 untyped algebra	4402-1
86–91 untyped algebra		sequential	475 tuple calculus	4402-1
475 tuple calculus		sequential	39	4402-1
39		sequential	74	4402-1
74		sequential	101 relational algebra normal form	4402-1
101 relational algebra normal form		sequential	RANF	4402-1
RANF		sequential	86	4402-1
86		sequential	97 unrestricted semantics	4402-1
97 unrestricted semantics		sequential	78	4402-1
78	modified	attribute	88 unsafe	4402-1
75 relational calculus		sequential	28	4402-1
28		sequential	35	4402-1
35		sequential	36	4402-1
36		sequential	64	4402-1
64		sequential	70	4402-1
70		sequential	73–91	4402-1
73–91		sequential	85	4402-1
85	vs.	constraint	first order	4402-1
first order		sequential	logic	4402-1
logic		sequential	77	4402-1
77		sequential	105	4402-1
105		sequential	123	4402-1
123		sequential	136	4402-1
136	vs.	constraint	clause	4402-1
136	from	constraint	clause	4402-1
clause		sequential	145 relational completeness	4402-1
145 relational completeness		sequential	96 Index relational completeness	4402-1
96 Index relational completeness	continued	action	update language	4402-1
update language		sequential	582 QBE	4402-1
582 QBE		sequential	rule	4402-1
rule	based	action	151 conjunctive query	4402-1
151 conjunctive query		sequential	39	4402-1
39		sequential	40	4402-1
40	–	sequential	42	4402-1
42		sequential	41 SQL	4402-1
41 SQL		sequential	147	4402-1
147	with	constraint	equality	4402-1
equality		sequential	48	4402-1
48	vs.	constraint	Turing computability	4402-1
Turing computability		sequential	96 semantics	4402-1
96 semantics		sequential	41 relational model	4402-1
41 relational model		sequential	28	4402-1
28		sequential	–34	4402-1
–34	with	constraint	union	4402-1
union		sequential	62 relative information capacity	4402-1
62 relative information capacity		sequential	265	4402-1
265		sequential	268–269	4402-1
268–269		sequential	539 rule	4402-1
539 rule		sequential	goal graph	4402-1
goal graph		sequential	335 relativized instance	4402-1
335 relativized instance		sequential	77 running intersection property	4402-1
77 running intersection property		sequential	141 relativized interpretation	4402-1
141 relativized interpretation		sequential	74	4402-1
74		sequential	77–78 relevant fact	4402-1
77–78 relevant fact		sequential	317 relname	4402-1
317 relname		sequential	31	4402-1
31		sequential	64 renaming DRC query	4402-1
64 renaming DRC query		sequential	97 query	4402-1
97 query		sequential	97 complex value	4402-1
97 complex value		sequential	517	4402-1
517		sequential	524 range	4402-1
524 range		sequential	85 operator	4402-1
85 operator		sequential	57	4402-1
57		sequential	58 SPJR algebra	4402-1
58 SPJR algebra		sequential	57 complex value	4402-1
57 complex value		sequential	528 rep	4402-1
528 rep		sequential	T	4402-1
T		sequential	489 normal form	4402-1
489 normal form		sequential	SRNF	4402-1
SRNF		sequential	83 repeat restricted tableau query	4402-1
83 repeat restricted tableau query		sequential	67 query	4402-1
67 query		sequential	97 representation system relational calculus	4402-1
97 representation system relational calculus		sequential	81	4402-1
81		sequential	83	4402-1
83		sequential	–85	4402-1
–85		sequential	490 safety	4402-1
490 safety		sequential	70	4402-1
70		sequential	75	4402-1
75		sequential	–77 representative instance	4402-1
–77 representative instance		sequential	263	4402-1
263	in	constraint	SQL	4402-1
SQL		sequential	153 resolution	4402-1
153 resolution		sequential	186	4402-1
186		sequential	Same	4402-1
Same		sequential	552 Generation	4402-1
552 Generation		sequential	SG	4402-1
SG	vs.	constraint	chase	4402-1
chase		sequential	186 program	4402-1
186 program		sequential	331 resolution theorem proving	4402-1
331 resolution theorem proving		sequential	136 query	4402-1
136 query		sequential	331 resolvent	4402-1
331 resolvent		sequential	289	4402-1
289		sequential	294 Variant	4402-1
294 Variant		sequential	SGV	4402-1
SGV		sequential	339	4402-1
339		sequential	RETE	4402-1
RETE		sequential	600 sampling	4402-1
600 sampling	in	constraint	query optimization	4402-1
query optimization		sequential	Reverse	4402-1
Reverse		sequential	Same	4402-1
Same		sequential	Generation	4402-1
Generation		sequential	RSG	4402-1
RSG	111 sat	action	R	4402-1
R	sat	action	174 program	4402-1
174 program		sequential	312 satisfaction	4402-1
312 satisfaction		sequential	24 query	4402-1
24 query		sequential	317 conjunctive calculus formula	4402-1
317 conjunctive calculus formula		sequential	46 revision	4402-1
46 revision	vs.	constraint	update	4402-1
update		sequential	59	4402-1
59		sequential	9–600	4402-1
9–600	to	constraint	a domain	4402-1
a domain		sequential	77 rewrite rule satisfaction family	4402-1
77 rewrite rule satisfaction family		sequential	174	4402-1
174		sequential	186	4402-1
186		sequential	222 conjunctive calculus	4402-1
222 conjunctive calculus		sequential	46 satisfiability normal form	4402-1
46 satisfiability normal form	vs.	constraint	query optimization	4402-1
query optimization		sequential	110	4402-1
110	for	constraint	optimization	4402-1
optimization		sequential	108	4402-1
108		sequential	110 datalog	4402-1
110 datalog		sequential	300 relational calculus	4402-1
300 relational calculus		sequential	82 SRNF	4402-1
82 SRNF		sequential	83 sound	4402-1
83 sound		sequential	56 SPC algebra	4402-1
56 SPC algebra		sequential	55	4402-1
55	–	sequential	56	4402-1
56		sequential	110 satisfiable formula	4402-1
110 satisfiable formula		sequential	21 SPJR algebra	4402-1
21 SPJR algebra		sequential	110 satisfiable query	4402-1
110 satisfiable query		sequential	42 SRNF	4402-1
42 SRNF	to	constraint	RANF	4402-1
RANF		sequential	86	4402-1
86	–	sequential	87	4402-1
87		sequential	satisfiable SPC algebra	4402-1
satisfiable SPC algebra		sequential	56 rewriting	4402-1
56 rewriting		sequential	query	4402-1
query		sequential	108 –110 satisfiable SPJR algebra	4402-1
108 –110 satisfiable SPJR algebra		sequential	59 role	4402-1
59 role		sequential	571	4402-1
571	satisfy	action	root	4402-1
root	of	constraint	persistence	4402-1
persistence		sequential	556 dependency	4402-1
556 dependency		sequential	160 rule	4402-1
160 rule		sequential	41	4402-1
41	by	constraint	tableau	4402-1
tableau		sequential	175 functional dependency	4402-1
175 functional dependency		sequential	163 inclusion dependency	4402-1
163 inclusion dependency		sequential	193 body	4402-1
193 body		sequential	39	4402-1
39		sequential	41 join dependency	4402-1
41 join dependency		sequential	170 head	4402-1
170 head		sequential	39	4402-1
39		sequential	41 multivalued dependency	4402-1
41 multivalued dependency		sequential	170 nr- datalog¬	4402-1
170 nr- datalog¬		sequential	72 saturated set	4402-1
72 saturated set	188 range restricted	action	72 scalar domain	4402-1
72 scalar domain		sequential	153 semantics	4402-1
153 semantics		sequential	72 schema range	4402-1
72 schema range	restricted	action	41 complex value	4402-1
41 complex value		sequential	512 semantics	4402-1
512 semantics		sequential	41 database	4402-1
41 database		sequential	29	4402-1
29		sequential	object	4402-1
object	oriented	action	31 Index database	4402-1
31 Index database		sequential	554 nr-datalog¬ rule	4402-1
554 nr-datalog¬ rule		sequential	72 query	4402-1
72 query		sequential	572 relational calculus relation	4402-1
572 relational calculus relation		sequential	78	4402-1
78		sequential	79 decomposition	4402-1
79 decomposition		sequential	162	4402-1
162		sequential	251–259	4402-1
251–259		sequential	object	4402-1
object	oriented	action	78 database	4402-1
78 database		sequential	rule	4402-1
rule	based	action	571 conjunctive query	4402-1
571 conjunctive query		sequential	41 synthesis	4402-1
41 synthesis		sequential	257–258 SPC algebra	4402-1
257–258 SPC algebra		sequential	54 SDD	4402-1
54 SDD	-	sequential	1	4402-1
1		sequential	135 SPJR algebra	4402-1
135 SPJR algebra		sequential	58 select	4402-1
58 select	from	constraint	clause	4402-1
clause		sequential	112	4402-1
112		sequential	144 tableau query	4402-1
144 tableau query		sequential	43	4402-1
43	vs.	constraint	projection	4402-1
projection		sequential	144 semi- deterministic query	4402-1
144 semi- deterministic query		sequential	574	4402-1
574	vs.	constraint	relational calculus	4402-1
relational calculus		sequential	145 semi-join	4402-1
145 semi-join		sequential	128	4402-1
128		sequential	135 selection	4402-1
135 selection		sequential	52	4402-1
52		sequential	57 program	4402-1
57 program	129 constant based	action	66 seminaive datalog evaluation	4402-1
66 seminaive datalog evaluation		sequential	312–316	4402-1
312–316		sequential	335 named perspective	4402-1
335 named perspective		sequential	57 basic algorithm	4402-1
57 basic algorithm		sequential	315 physical implementation	4402-1
315 physical implementation		sequential	107 improved algorithm	4402-1
107 improved algorithm		sequential	55	4402-1
55		sequential	58 semipositive datalog	4402-1
58 semipositive datalog		sequential	377 pushing	4402-1
377 pushing		sequential	109	4402-1
109		sequential	335 sentence	4402-1
335 sentence		sequential	23	4402-1
23	in	constraint	SQL	4402-1
SQL		sequential	144 Sequel	4402-1
144 Sequel		sequential	144 unnamed perspective	4402-1
144 unnamed perspective		sequential	53 set comprehension	4402-1
53 set comprehension		sequential	538 selection formula set constructor	4402-1
538 selection formula set constructor		sequential	508	4402-1
508		sequential	509 set difference	4402-1
509 set difference		sequential	68 disjunction	4402-1
68 disjunction		sequential	62	4402-1
62	in	constraint	relational algebra	4402-1
relational algebra		sequential	71 inequality atom	4402-1
71 inequality atom		sequential	69	4402-1
69	with	constraint	negation	4402-1
negation		sequential	68	4402-1
68	vs.	constraint	negation	4402-1
negation		sequential	67 set membership	4402-1
67 set membership		sequential	514 positive conjunctive	4402-1
514 positive conjunctive		sequential	55	4402-1
55		sequential	58	4402-1
58		sequential	108 set	4402-1
108 set	at	constraint	a-	4402-1
a-		sequential	time	4402-1
time		sequential	35 selection rule	4402-1
35 selection rule		sequential	298 set	4402-1
298 set		sequential	create	4402-1
create		sequential	515 Semantic Binary Data Model	4402-1
515 Semantic Binary Data Model		sequential	264 set	4402-1
264 set		sequential	destroy	4402-1
destroy		sequential	515 semantic data model	4402-1
515 semantic data model		sequential	28	4402-1
28		sequential	157	4402-1
157		sequential	192	4402-1
192		sequential	240	4402-1
240		sequential	242–250	4402-1
242–250		sequential	sideways information passing	4402-1
sideways information passing		sequential	111	4402-1
111		sequential	112–114	4402-1
112–114	in	constraint	datalog evaluation	4402-1
datalog evaluation		sequential	318	4402-1
318		sequential	336	4402-1
336		sequential	340 graph	4402-1
340 graph		sequential	113	4402-1
113		sequential	340 strategy	4402-1
340 strategy		sequential	243 signature	4402-1
243 signature		sequential	method	4402-1
method	551 valued	action	243 simple key dependency	4402-1
243 simple key dependency		sequential	267 class	4402-1
267 class		sequential	243 simple tableau query	4402-1
243 simple tableau query		sequential	140 complex value	4402-1
140 complex value		sequential	243 simultaneous induction	4402-1
243 simultaneous induction		sequential	351 derived data	4402-1
351 derived data		sequential	246 single rule programs	4402-1
246 single rule programs		sequential	sirups	4402-1
sirups		sequential	305	4402-1
305		sequential	309 Entity	4402-1
309 Entity		sequential	Relationship	4402-1
Relationship		sequential	ER	4402-1
ER		sequential	242	4402-1
242		sequential	head	4402-1
head		sequential	dependency	4402-1
dependency		sequential	217 singleton	4402-1
217 singleton		sequential	GSM	4402-1
GSM		sequential	242 sip graph	4402-1
242 sip graph		sequential	113	4402-1
113		sequential	340 inheritance	4402-1
340 inheritance		sequential	245 sip strategy	4402-1
245 sip strategy		sequential	113 instance	4402-1
113 instance		sequential	245 sirup	4402-1
245 sirup		sequential	305–309 ISA	4402-1
305–309 ISA		sequential	245 SLD datalog evaluation	4402-1
245 SLD datalog evaluation		sequential	289–298 object identifier	4402-1
289–298 object identifier		sequential	OID	4402-1
OID		sequential	243 SLD	4402-1
243 SLD		sequential	AL	4402-1
AL		sequential	335 printable class	4402-1
335 printable class		sequential	243 SLD resolution	4402-1
243 SLD resolution		sequential	295	4402-1
295	See	action	datalog	4402-1
datalog		sequential	SLD resolution	4402-1
datalog¬		sequential	406 SLD	4403-1
406 SLD		sequential	tree	4403-1
tree		sequential	298	4403-1
298		sequential	317 subclass	4403-1
317 subclass		sequential	243 SLDNF resolution	4403-1
243 SLDNF resolution		sequential	406	4403-1
406	vs.	constraint	inclusion	4403-1
inclusion		sequential	dependencies	4403-1
dependencies		sequential	207	4403-1
207		sequential	251–253 SLS resolution	4403-1
251–253 SLS resolution		sequential	409 semantics sort conjunctive calculus	4403-1
409 semantics sort conjunctive calculus		sequential	45 complex value	4403-1
45 complex value		sequential	511 conjunctive query	4403-1
511 conjunctive query		sequential	41	4403-1
41	of	constraint	instance	4403-1
instance		sequential	32 nr-datalog¬ program	4403-1
32 nr-datalog¬ program		sequential	72	4403-1
72	of	constraint	relation name	4403-1
relation name	continued	action	31 Index sort group	4403-1
31 Index sort group	by	constraint	154	4403-1
154	of	constraint	tuple	4403-1
tuple		sequential	32 insert	4403-1
32 insert		sequential	149 sort	4403-1
149 sort		sequential	·	4403-1
·		sequential	31 sort set dependency	4403-1
31 sort set dependency		sequential	191 nested query	4403-1
191 nested query		sequential	143	4403-1
143	–	sequential	147	4403-1
147	vs.	constraint	axiomatization	4403-1
axiomatization	with	constraint	fds	4403-1
fds		sequential	213	4403-1
213	in	constraint	personal computer DBMSs	4403-1
personal computer DBMSs		sequential	sort	4403-1
sort	merge	action	152 implementation	4403-1
152 implementation	of	constraint	join	4403-1
join		sequential	108	4403-1
108		sequential	147	4403-1
147		sequential	150 sound axiomatization	4403-1
150 sound axiomatization		sequential	167 safety	4403-1
167 safety		sequential	153 spatial database	4403-1
153 spatial database		sequential	95 scalar types	4403-1
95 scalar types		sequential	145 SPC algebra	4403-1
145 SPC algebra		sequential	52 –56	4403-1
52 –56		sequential	54	4403-1
54		sequential	108 select	4403-1
108 select		sequential	144 base query	4403-1
144 base query		sequential	54 set operators	4403-1
54 set operators	146 generalized	action	55 simulation	4403-1
55 simulation	of	constraint	nr-datalog¬	4403-1
nr-datalog¬		sequential	147–149 intersection	4403-1
147–149 intersection		sequential	55	4403-1
55		sequential	69 translation	4403-1
69 translation	to	constraint	algebra	4403-1
algebra		sequential	112 normal form	4403-1
112 normal form		sequential	55 update	4403-1
55 update		sequential	149 rewrite rule	4403-1
149 rewrite rule		sequential	55	4403-1
55	–	sequential	56	4403-1
56		sequential	110 update language	4403-1
110 update language		sequential	56 views	4403-1
56 views		sequential	54	4403-1
54	vs.	constraint	cross product	4403-1
cross product		sequential	144	4403-1
144	with	constraint	union	4403-1
union		sequential	62	4403-1
62	vs.	constraint	first order	4403-1
first order		sequential	queries	4403-1
queries		sequential	147–149	4403-1
147–149		sequential	155	4403-1
155	vs.	constraint	SPJR algebra	4403-1
SPJR algebra	vs.	constraint	60 calculus	4403-1
60 calculus		sequential	145	4403-1
145	vs.	constraint	tableau	4403-1
tableau		sequential	queries	4403-1
queries		sequential	118	4403-1
118	vs.	constraint	Sequel	4403-1
Sequel		sequential	144 SPCU algebra	4403-1
144 SPCU algebra		sequential	62	4403-1
62		sequential	97	4403-1
97		sequential	where 144 SRNF	4403-1
where 144 SRNF		sequential	83 stable model	4403-1
83 stable model		sequential	408	4403-1
408		sequential	413 normal form	4403-1
413 normal form		sequential	62 stage	4403-1
62 stage		sequential	P	4403-1
P		sequential	I	4403-1
I		sequential	285 specialization	4403-1
285 specialization		sequential	545 Starburst	4403-1
545 Starburst		sequential	368	4403-1
368		sequential	370 SPJ algebra	4403-1
370 SPJ algebra		sequential	static analysis restricted	4403-1
static analysis restricted	typed	action	64	4403-1
64		sequential	67 conjunctive queries	4403-1
67 conjunctive queries		sequential	105	4403-1
105		sequential	115 –122 SPJR algebra	4403-1
115 –122 SPJR algebra		sequential	56	4403-1
56		sequential	–59	4403-1
–59		sequential	57 datalog queries	4403-1
57 datalog queries		sequential	306–311 base query	4403-1
306–311 base query		sequential	order	4403-1
order		sequential	58 queries	4403-1
58 queries		sequential	105	4403-1
105		sequential	122–126	4403-1
122–126	generalized	action	59	4403-1
59	of	constraint	queries	4403-1
queries		sequential	36 natural join	4403-1
36 natural join		sequential	56 relational calculus	4403-1
56 relational calculus		sequential	105	4403-1
105		sequential	122–126 normal form	4403-1
122–126 normal form		sequential	59 static binding	4403-1
59 static binding		sequential	552 renaming	4403-1
552 renaming		sequential	57 stored data	4403-1
57 stored data		sequential	statistical properties	4403-1
statistical properties		sequential	106 rewrite rule	4403-1
106 rewrite rule		sequential	110 stratified datalog¬	4403-1
110 stratified datalog¬		sequential	59 stratified negation	4403-1
59 stratified negation		sequential	58 stratified semantics	4403-1
58 stratified semantics		sequential	377–385	4403-1
<B>	See	action	datalog¬	4403-2
datalog¬	with	constraint	union	4403-2
union		sequential	62 stratified semantics	4403-2
62 stratified semantics	vs.	constraint	join dependency	4403-2
join dependency		sequential	181 stream	4403-2
181 stream	of	constraint	tuples	4403-2
tuples		sequential	106	4403-2
106		sequential	135	4403-2
135	vs.	constraint	SPC algebra	4403-2
SPC algebra		sequential	60 safe range	4403-2
60 safe range	vs.	constraint	tableau queries	4403-2
tableau queries		sequential	118 complex value	4403-2
118 complex value		sequential	530 SPJRU algebra	4403-2
530 SPJRU algebra		sequential	62 structured object	4403-2
<B>	See	action	complex value	4403-3
normal form		sequential	62 Structured Query Language	4404-1
62 Structured Query Language		sequential	SQL	4404-1
SQL		sequential	143	4404-1
<B>	See	action	SQL SQL	4404-2
SQL SQL		sequential	2	4404-2
2		sequential	–3	4404-2
–3		sequential	36	4404-2
36		sequential	70	4404-2
70		sequential	74	4404-2
74		sequential	112	4404-2
112		sequential	143–150	4404-2
143–150		sequential	155	4404-2
155		sequential	336	4404-2
336		sequential	370	4404-2
370		sequential	subclass	4404-2
subclass		sequential	545 semantic data model	4404-2
545 semantic data model		sequential	243 bags	4404-2
243 bags		sequential	145	4404-2
145		sequential	155 subquery	4404-2
155 subquery	in	constraint	datalog evaluation	4404-2
datalog evaluation		sequential	318	4404-2
318	contains	action	146 substitution	4404-2
146 substitution		sequential	24	4404-2
24		sequential	116 count	4404-2
116 count		sequential	154	4404-2
154	vs.	constraint	valuation	4404-2
valuation		sequential	116	4404-2
116	create	action	145 subsumption	4404-2
145 subsumption		sequential	136 delete	4404-2
136 delete		sequential	149 subtyping relationship	4404-2
149 subtyping relationship		sequential	145	4404-2
145		sequential	154 succ	4404-2
154 succ		sequential	397 sum	4404-2
397 sum		sequential	91	4404-2
91		sequential	92 duplicate tuples	4404-2
92 duplicate tuples		sequential	144	4404-2
144	in	constraint	SQL	4404-2
SQL		sequential	154	4404-2
154		sequential	from 144 summary	4404-2
from 144 summary	of	constraint	tableau query	4404-2
tableau query		sequential	43 Index superkey	4404-2
43 Index superkey		sequential	257 Tarski	4404-2
257 Tarski		sequential	Algebraization Theorem	4404-2
Algebraization Theorem		sequential	96 supplementary relation	4404-2
96 supplementary relation		sequential	319–320 Taxis	4404-2
319–320 Taxis		sequential	264 supported model	4404-2
264 supported model		sequential	384	4404-2
384		sequential	411 taxonomic reasoning	4404-2
411 taxonomic reasoning		sequential	572	4404-2
572		sequential	T	4404-2
T		sequential	490 template dependency	4404-2
490 template dependency		sequential	233	4404-2
233		sequential	236 surrogate	4404-2
236 surrogate		sequential	247	4404-2
247		sequential	573 temporal constraint	4404-2
573 temporal constraint		sequential	611–613	4404-2
611–613		sequential	Sybase	4404-2
Sybase		sequential	155 history	4404-2
155 history		sequential	less checking	4404-2
less checking		sequential	10 temporal database	4404-2
10 temporal database		sequential	95	4404-2
95		sequential	606–613 synthesis	4404-2
606–613 synthesis		sequential	257–258 query language	4404-2
257–258 query language		sequential	607–611	4404-2
607–611	vs.	constraint	decomposition	4404-2
decomposition		sequential	258	4404-2
258		sequential	610 System R	4404-2
610 System R		sequential	111 TSQL	4404-2
111 TSQL		sequential	609 query optimizer	4404-2
609 query optimizer		sequential	112	4404-2
112		sequential	113–114	4404-2
113–114		sequential	122	4404-2
122		sequential	127	4404-2
127		sequential	135	4404-2
135		sequential	representation	4404-2
representation		sequential	608–609	4404-2
608–609		sequential	temporal CALC	4404-2
temporal CALC		sequential	607 temporal constraint	4404-2
607 temporal constraint		sequential	611–613	4404-2
611–613	on	constraint	events	4404-2
events		sequential	612	4404-2
612		sequential	615 TP	4404-2
615 TP		sequential	375 object histories	4404-2
375 object histories		sequential	615 table	4404-2
615 table		sequential	488–500	4404-2
488–500	See	action	Codd table	4404-2
Codd table		sequential	naive table	4404-2
naive table		sequential	c-table	4404-2
object migration now		sequential	613 tableau	4405-1
613 tableau		sequential	43	4405-1
43	vs.	constraint	transactional schemas	4405-1
transactional schemas		sequential	612 complexity	4405-1
612 complexity		sequential	121 –122 time domain	4405-1
121 –122 time domain		sequential	607 composition	4405-1
607 composition		sequential	226–227	4405-1
226–227		sequential	607 embedding	4405-1
607 embedding		sequential	43 transaction time	4405-1
43 transaction time	607 typed	action	44 transition constraint	4405-1
44 transition constraint		sequential	612	4405-1
612	vs.	constraint	dependencies	4405-1
dependencies		sequential	218	4405-1
218		sequential	234 dynamic fd	4405-1
234 dynamic fd		sequential	s	4405-1
s		sequential	615	4405-1
615	vs.	constraint	join	4405-1
join		sequential	64 pre/post conditions	4405-1
64 pre/post conditions		sequential	615 tableau minimization	4405-1
615 tableau minimization		sequential	105	4405-1
105		sequential	118–120	4405-1
118–120		sequential	136 valid time	4405-1
136 valid time		sequential	607 temporal logic	4405-1
607 temporal logic		sequential	608	4405-1
608		sequential	615	4405-1
615	vs.	constraint	condensation	4405-1
condensation		sequential	136 temporal query language	4405-1
136 temporal query language		sequential	607–611	4405-1
607–611	vs.	constraint	local optimization	4405-1
local optimization		sequential	117 term	4405-1
117 term		sequential	22	4405-1
22		sequential	34	4405-1
34	vs.	constraint	number	4405-1
number	of	constraint	joins	4405-1
joins		sequential	118 complex value	4405-1
118 complex value		sequential	519	4405-1
519	vs.	constraint	resolution	4405-1
resolution		sequential	theorem proving	4405-1
theorem proving		sequential	136 tgd	4405-1
136 tgd		sequential	217–228 tableau query	4405-1
217–228 tableau query		sequential	43	4405-1
43	–	sequential	44	4405-1
44		sequential	43 tgd	4405-1
43 tgd		sequential	rule	4405-1
rule	in	constraint	chasing	4405-1
chasing		sequential	223 chasing	4405-1
223 chasing		sequential	173	4405-1
173		sequential	186 third normal form	4405-1
186 third normal form		sequential	3NF	4405-1
3NF		sequential	257 complexity	4405-1
257 complexity		sequential	111 –122 composition	4405-1
111 –122 composition		sequential	226 containment	4405-1
226 containment		sequential	121–122 difference	4405-1
121–122 difference		sequential	64	4405-1
64	with	constraint	equality	4405-1
equality		sequential	48	4405-1
48	of	constraint	an fd	4405-1
an fd		sequential	three level	4405-1
three level		sequential	181 architecture	4405-1
181 architecture		sequential	3 homomorphism	4405-1
3 homomorphism		sequential	117	4405-1
117		sequential	127	4405-1
127		sequential	136 logical level	4405-1
136 logical level		sequential	120 physical level	4405-1
120 physical level		sequential	106	4405-1
106	of	constraint	a jd	4405-1
a jd		sequential	Object	4405-1
Object	Oriented	action	118 TI Open Data Base	4405-1
118 TI Open Data Base		sequential	135 minimization	4405-1
135 minimization		sequential	119 timestamp	4405-1
119 timestamp		sequential	401 repeat restricted	4405-1
401 repeat restricted		sequential	top	4405-1
top		sequential	down	4405-1
down		sequential	67 datalog evaluation	4405-1
67 datalog evaluation		sequential	316–324 semantics	4405-1
316–324 semantics		sequential	43	4405-1
43	vs.	constraint	bottom up	4405-1
bottom up		sequential	311	4405-1
311		sequential	327	4405-1
327		sequential	140 topological sort	4405-1
140 topological sort		sequential	11 summary	4405-1
11 summary		sequential	43 total instance	4405-1
43 total instance		sequential	387	4405-1
387	typed	action	64	4405-1
64		sequential	121	4405-1
121		sequential	136 total order	4405-1
136 total order		sequential	11 union	4405-1
11 union	of	constraint	tableaux	4405-1
tableaux		sequential	query	4405-1
query		sequential	63	4405-1
63		sequential	64	4405-1
64		sequential	139 total program	4405-1
139 total program		sequential	395	4405-1
395	vs.	constraint	dependencies	4405-1
dependencies		sequential	64 TP	4405-1
64 TP		sequential	283	4405-1
283	vs.	constraint	QBE	4405-1
QBE		sequential	150 transaction time	4405-1
150 transaction time		sequential	607	4405-1
607	vs.	constraint	SPC algebra	4405-1
SPC algebra		sequential	118 transactional schema	4405-1
118 transactional schema		sequential	584–586	4405-1
584–586		sequential	584	4405-1
584		sequential	617	4405-1
617	vs.	constraint	SPJR algebra	4405-1
SPJR algebra		sequential	118 Gen	4405-1
118 Gen		sequential	T	4405-1
T		sequential	585 tagged dependency	4405-1
585 tagged dependency		sequential	164	4405-1
164		sequential	221	4405-1
221		sequential	241 IDM transactional schema	4405-1
241 IDM transactional schema		sequential	584	4405-1
584		sequential	613	4405-1
613		sequential	617 Index transactional schema	4405-1
617 Index transactional schema	of	constraint	implication	4405-1
617 Index transactional schema	continued	action	implication	4405-1
implication	for	constraint	embedded dependencies	4405-1
embedded dependencies		sequential	220	4405-1
220		sequential	parameterized IDM transaction	4405-1
parameterized IDM transaction		sequential	584	4405-1
584	vs.	constraint	constraints	4405-1
constraints		sequential	585	4405-1
585		sequential	–586	4405-1
–586	of	constraint	implication	4405-1
implication	for	constraint	emvds	4405-1
emvds		sequential	220 completeness	4405-1
220 completeness		sequential	585	4405-1
585	of	constraint	implication	4405-1
implication	of	constraint	fds	4405-1
fds	and	conjunctive	inds	4405-1
inds		sequential	199	4405-1
199		sequential	211 soundness	4405-1
211 soundness		sequential	585 underlying domain	4405-1
585 underlying domain		sequential	74	4405-1
74	vs.	constraint	methods	4405-1
methods		sequential	584 unfounded set	4405-1
584 unfounded set		sequential	413	4405-1
413	vs.	constraint	temporal constraints	4405-1
temporal constraints		sequential	612 unification	4405-1
612 unification		sequential	293 transformation rule	4405-1
uniform containment		sequential	304 transition constraint	4406-1
304 transition constraint		sequential	612 union	4406-1
612 union		sequential	33	4406-1
33		sequential	37	4406-1
37	in	constraint	10 queries	4406-1
10 queries	–	sequential	64	4406-1
64		sequential	61 transitive closure query	4406-1
61 transitive closure query	in	constraint	Microsoft Access	4406-1
Microsoft Access	153 generalized	action	310	4406-1
310	in	constraint	relational algebra	4406-1
relational algebra		sequential	71 not order	4406-1
71 not order		sequential	436	4406-1
436	in	constraint	conjunctive queries	4406-1
436	rule based	action	conjunctive queries	4406-1
conjunctive queries		sequential	62 tree	4406-1
62 tree		sequential	12	4406-1
12	in	constraint	SQL	4406-1
SQL		sequential	146 truth assignment	4406-1
146 truth assignment		sequential	21 union	4406-1
21 union	of	constraint	tableaux	4406-1
tableaux		sequential	query	4406-1
query		sequential	63	4406-1
63		sequential	64	4406-1
64		sequential	139 TSQL	4406-1
139 TSQL		sequential	609 unique name axioms	4406-1
609 unique name axioms		sequential	26 tup	4406-1
26 tup		sequential	create	4406-1
create		sequential	514 unique role assumption	4406-1
514 unique role assumption		sequential	261 tup	4406-1
261 tup	_	sequential	destroy	4406-1
destroy		sequential	515 unirelational dependency	4406-1
515 unirelational dependency		sequential	217 tuple	4406-1
217 tuple		sequential	29 unit clause	4406-1
29 unit clause		sequential	33 universal quantification	4406-1
33 universal quantification	generalized	action	94	4406-1
94		sequential	95	4406-1
95	removing	action	83 named perspective	4406-1
83 named perspective		sequential	32	4406-1
32	with	constraint	placeholders	4406-1
placeholders		sequential	94	4406-1
94	vs.	constraint	existential quantification	4406-1
existential quantification		sequential	74 unnamed perspective	4406-1
74 unnamed perspective		sequential	32 universal relation tuple calculus	4406-1
32 universal relation tuple calculus		sequential	74	4406-1
74		sequential	101	4406-1
101	vs.	constraint	domain calculus	4406-1
domain calculus		sequential	126	4406-1
126		sequential	130	4406-1
130		sequential	242	4406-1
242		sequential	252 tuple generating dependency	4406-1
252 tuple generating dependency		sequential	tgd	4406-1
tgd		sequential	261	4406-1
261		sequential	–264	4406-1
–264		sequential	218 interface	4406-1
218 interface		sequential	266 tuple rewriting	4406-1
266 tuple rewriting		sequential	107 scheme assumption	4406-1
107 scheme assumption		sequential	URSA	4406-1
URSA		sequential	260 tuple substitution	4406-1
260 tuple substitution		sequential	115	4406-1
115		sequential	135 unique role assumption	4406-1
135 unique role assumption		sequential	tuple	4406-1
tuple	generating	action	261 dependency	4406-1
261 dependency		sequential	tgd	4406-1
tgd		sequential	217–228 universe	4406-1
217–228 universe		sequential	23 Turing machine	4406-1
23 Turing machine		sequential	15 universe	4406-1
15 universe	of	constraint	discourse	4406-1
discourse	77 linear bounded	action	196 Unix	4406-1
196 Unix		sequential	155 two element	4406-1
155 two element		sequential	instances	4406-1
instances		sequential	unknown value	4406-1
unknown value		sequential	488	4406-1
488	vs.	constraint	fd	4406-1
fd		sequential	s	4406-1
s	and	conjunctive	mvd	4406-1
mvd		sequential	s	4406-1
s		sequential	189 unnamed perspective	4406-1
189 unnamed perspective		sequential	two way	4406-1
two way		sequential	automata	4406-1
automata		sequential	15	4406-1
15	on	constraint	relations	4406-1
relations		sequential	32 type	4406-1
32 type	in	constraint	object	4406-1
object	oriented	action	database	4406-1
database		sequential	548 projection	4406-1
548 projection		sequential	54 type safety	4406-1
54 type safety		sequential	563	4406-1
563		sequential	565	4406-1
565		sequential	567	4406-1
567		sequential	573 relational algebra	4406-1
573 relational algebra		sequential	71 typed dependency	4406-1
71 typed dependency		sequential	159 selection	4406-1
159 selection		sequential	53	4406-1
53	vs.	constraint	233 SPC algebra	4406-1
233 SPC algebra		sequential	52	4406-1
52		sequential	–56	4406-1
–56		sequential	54	4406-1
54	vs.	constraint	217 tuple	4406-1
217 tuple		sequential	32 typed inclusion dependency	4406-1
32 typed inclusion dependency		sequential	211	4406-1
211	vs.	constraint	named perspective	4406-1
named perspective		sequential	32 typed restricted SPJ algebra	4406-1
32 typed restricted SPJ algebra		sequential	64	4406-1
64		sequential	67	4406-1
67		sequential	518 typed tableau	4406-1
518 typed tableau		sequential	44 unrestricted instance	4406-1
44 unrestricted instance		sequential	197 query	4406-1
197 query		sequential	64	4406-1
64		sequential	121	4406-1
121		sequential	136 unrestricted interpretation	4406-1
136 unrestricted interpretation		sequential	78 types	4406-1
78 types		sequential	C	4406-1
C		sequential	548 unrestricted logical implication	4406-1
548 unrestricted logical implication		sequential	197–202	4406-1
197–202		sequential	219	4406-1
219	vs.	constraint	197	4406-1
197	vs.	constraint	functional dependency	4406-1
functional dependency		sequential	199 unary inclusion dependency	4406-1
199 unary inclusion dependency		sequential	uind	4406-1
uind		sequential	207	4406-1
207		sequential	210	4406-1
210		sequential	–211	4406-1
–211	vs.	constraint	inclusion dependency	4406-1
inclusion dependency		sequential	199 undecidability	4406-1
199 undecidability	vs.	constraint	join dependency	4406-1
join dependency		sequential	199	4406-1
199	of	constraint	properties	4406-1
properties	of	constraint	datalog queries	4406-1
datalog queries		sequential	306	4406-1
306		sequential	308 unrestricted relational algebra	4406-1
308 unrestricted relational algebra		sequential	103	4406-1
103	of	constraint	properties	4406-1
properties	of	constraint	order	4406-1
order		sequential	queries	4406-1
queries		sequential	105	4406-1
105		sequential	122–126 unrestricted semantics	4406-1
122–126 unrestricted semantics	of	constraint	relational calculus	4406-1
relational calculus		sequential	78 untyped dependency	4406-1
78 untyped dependency		sequential	192 Index	4406-1
192 Index	vs.	constraint	217	4406-1
192 Index	typed	action	217	4406-1
217	in	constraint	QBE	4406-1
QBE		sequential	151 untyped relational algebra	4406-1
151 untyped relational algebra		sequential	475 update	4406-1
475 update	in	constraint	SQL	4406-1
SQL		sequential	149	4406-1
149	in	constraint	SQL	4406-1
SQL		sequential	149–150	4406-1
149–150		sequential	update	4406-1
update		sequential	586	4406-1
586		sequential	589–593 statistical properties	4406-1
589–593 statistical properties		sequential	106 complement	4406-1
106 complement	of	constraint	views	4406-1
views		sequential	591–593	4406-1
591–593	vs.	constraint	revision	4406-1
revision		sequential	599–600	4406-1
599–600		sequential	51	4406-1
51	vs.	constraint	query	4406-1
query		sequential	28 update	4406-1
28 update	in	constraint	SQL	4406-1
SQL		sequential	149 update anomalies	4406-1
149 update anomalies		sequential	162	4406-1
162		sequential	241 weak instance	4406-1
241 weak instance		sequential	262 weak universal model	4406-1
262 weak universal model		sequential	502 weak universal relation assumption	4406-1
502 weak universal relation assumption		sequential	URA	4406-1
URA		sequential	261– update language	4406-1
261– update language		sequential	580 –583 completeness	4406-1
580 –583 completeness	formed	action	583 formula IDM transaction	4406-1
583 formula IDM transaction		sequential	580	4406-1
580		sequential	–582	4406-1
–582		sequential	615–617 conjunctive calculus	4406-1
615–617 conjunctive calculus		sequential	45 deletion	4406-1
45 deletion		sequential	615 relational calculus	4406-1
615 relational calculus		sequential	74–75 insertion	4406-1
74–75 insertion	founded	action	615 semantics	4406-1
615 semantics		sequential	385–397	4406-1
385–397		sequential	modification	4406-1
modification		sequential	615	4406-1
615	in	constraint	SQL	4406-1
SQL	vs.	constraint	selection	4406-1
selection		sequential	144 rule	4406-1
144 rule	based	action	582–583	4406-1
582–583	while	constraint	344–346	4406-1
344–346		sequential	345 datalog¬¬	4406-1
345 datalog¬¬		sequential	582	4406-1
582	while	constraint	queries	4406-1
queries		sequential	342	4406-1
342		sequential	367 Dynamic Logic Programming	4406-1
367 Dynamic Logic Programming		sequential	DLP	4406-1
DLP		sequential	583	4406-1
583		sequential	613 normal form	4406-1
613 normal form		sequential	452–453	4406-1
452–453		sequential	LDL	4406-1
LDL		sequential	583	4406-1
583	on	constraint	ordered databases	4406-1
ordered databases		sequential	447	4406-1
447		sequential	SQL	4406-1
SQL		sequential	580 pspace complexity	4406-1
580 pspace complexity		sequential	437 URA	4406-1
437 URA		sequential	126	4406-1
126		sequential	130	4406-1
130		sequential	137	4406-1
137	vs.	constraint	fixpoint queries	4406-1
fixpoint queries		sequential	453	4406-1
453		sequential	242	4406-1
242		sequential	252	4406-1
252		sequential	while	4406-1
while	+	sequential	346	4406-1
346		sequential	346–347	4406-1
346–347		sequential	261–264	4406-1
261–264		sequential	262 while	4406-1
262 while	+	sequential	<B>	4406-1
<B>	See	action	view	4406-2
whileN		sequential	467 completeness	4407-1
467 completeness	on	constraint	ordered databases	4407-1
ordered databases		sequential	468 whilenew	4407-1
468 whilenew		sequential	469 V- relation	4407-1
469 V- relation		sequential	513 completeness	4407-1
513 completeness		sequential	470 –473 val	4407-1
470 –473 val		sequential	O	4407-1
O		sequential	547	4407-1
547	21 behaved	action	470 valid model semantics	4407-1
470 valid model semantics		sequential	409	4407-1
409	while	constraint	obj	4407-1
obj		sequential	559 valid time	4407-1
559 valid time		sequential	607 whileuty	4407-1
607 whileuty		sequential	475 valuation	4407-1
475 valuation		sequential	41 completeness	4407-1
41 completeness	478 behaved	action	477	4407-1
477	of	constraint	tableau	4407-1
tableau		sequential	43 witness operator	4407-1
43 witness operator		sequential	454–456	4407-1
454–456	vs.	constraint	substitution	4407-1
substitution		sequential	116 word problem	4407-1
116 word problem	for	constraint	monoids	4407-1
monoids		sequential	199 value equality	4407-1
199 value equality		sequential	557 var	4407-1
557 var		sequential	33	4407-1
33		sequential	33 yes	4407-1
33 yes		sequential	no query	4407-1
no query		sequential	42 bound occurrence	4407-1
42 bound occurrence		sequential	45	4407-1
45		sequential	75 free occurrence	4407-1
75 free occurrence		sequential	45	4407-1
45		sequential	75 variable assignment	4407-1
75 variable assignment		sequential	24	4407-1
24	for	constraint	CALC	4407-1
CALC		sequential	441–444	4407-1
441–444		sequential	variable substitution	4407-1
variable substitution	for	constraint	444–446	4407-1
variable substitution	while	constraint	444–446	4407-1
444–446		sequential	rewrite rule	4407-1
rewrite rule		sequential	46	4407-1
46		sequential	83 view	4407-1
83 view		sequential	4 complement	4407-1
4 complement		sequential	583 maintenance	4407-1
583 maintenance		sequential	586–588	4407-1
586–588		sequential	586	4407-1
586	materialized	action	object	4407-1
object	oriented	action	51 database	4407-1
51 database		sequential	571	4407-1
Document Outline		sequential	Document Outline	4408-1
The Main Principles Functionalities Complexity	and	conjunctive	Diversity Past	4409-1
Diversity Past	and	conjunctive	Future Ties	4409-1
Future Ties	with	constraint	This Book Bibliographic Notes	4409-1
This Book Bibliographic Notes		sequential	Some Basics Languages	4409-1
Some Basics Languages		sequential	Computability	4409-1
Computability	and	conjunctive	Complexity Basics	4409-1
Complexity Basics	from	constraint	Logic	4409-1
Logic		sequential	The Structure	4409-1
The Structure	of	constraint	the Relational Model	4409-1
the Relational Model	versus	constraint	Unnamed Perspectives Conventional	4409-1
the Relational Model	Named	action	Unnamed Perspectives Conventional	4409-1
Unnamed Perspectives Conventional	versus	constraint	Logic Programming Perspectives Notation Bibliographic Notes	4409-1
Logic Programming Perspectives Notation Bibliographic Notes	Getting	action	Started Perspectives	4409-1
Logic Programming Perspectives Notation Bibliographic Notes	Logic Based	action	Started Perspectives	4409-1
Started Perspectives		sequential	Query Composition	4409-1
Query Composition	and	conjunctive	Views	4409-1
Views		sequential	Bibliographic Notes	4409-1
