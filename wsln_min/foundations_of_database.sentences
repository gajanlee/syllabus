Contents Preface vii PART A Database Systems The Main Principles Functionalities Complexity and Diversity Past and Future Ties with This Book Bibliographic Notes Theoretical Background Some Basics Languages, Computability, and Complexity Basics from Logic The Relational Model The Structure of the Relational Model Named versus Unnamed Perspectives Conventional versus Logic Programming Perspectives Notation Bibliographic Notes xiii	x-1-1
xiv Contents PART B BASICS: RELATIONAL QUERY LANGUAGES Conjunctive Queries Getting Started Logic-Based Perspectives Query Composition and Views Bibliographic Notes Exercises The Relational Algebras Nonrecursive Datalog with Negation The Relational Calculus Syntactic Restrictions for Domain Independence Digression: Finite Representations of Infinite Databases Bibliographic Notes Exercises Static Analysis and Optimization Issues in Practical Query Optimization Global Optimization Static Analysis of the Relational Calculus Computing with Acyclic Joins Bibliographic Notes Exercises Notes on Practical Languages SQL: The Structured Query Language Query-by-Example and Microsoft Access Confronting the Real World Bibliographic Notes Exercises PART C CONSTRAINTS Functional and Join Dependency Motivation Functional and Key Dependencies Join and Multivalued Dependencies	x-2-1
Contents xv The Chase Bibliographic Notes Exercises Inclusion Dependency Inclusion Dependency in Isolation Finite versus Infinite Implication Nonaxiomatizability of fd’s + ind’s Restricted Kinds of Inclusion Dependency Bibliographic Notes Exercises The Chase Revisited Bibliographic Notes Exercises Design and Dependencies Semantic Data Models Normal Forms Universal Relation Assumption Bibliographic Notes Exercises PART D DATALOG AND RECURSION Datalog Syntax of Datalog Model-Theoretic Semantics Fixpoint Semantics Proof-Theoretic Approach Static Program Analysis Bibliographic Notes Exercises Evaluation of Datalog Seminaive Evaluation Top-Down Techniques Magic	x-3-1
xvi Contents Two Improvements Bibliographic Notes Exercises Recursion and Negation Calculus + Fixpoint Datalog with Negation Equivalence Recursion in Practical Languages Bibliographic Notes Exercises Negation in Datalog The Basic Problem Stratified Semantics Well-Founded Semantics Expressive Power Negation as Failure in Brief Bibliographic Notes Exercises PART E EXPRESSIVENESS AND COMPLEXITY Sizing Up Languages Queries Complexity of Queries Languages and Complexity Bibliographic Notes Exercises First Order, Fixpoint, and While Complexity of First-Order Queries Expressiveness of First-Order Queries Fixpoint and While Queries The Impact of Order Bibliographic Notes Exercises Highly Expressive Languages WhileN— while with Arithmetic Whilenew — while with New Values	x-4-1
Contents xvii Whileuty—An Untyped Extension of while Bibliographic Notes Exercises PART F FINALE Incomplete Information Warm-Up Weak Representation Systems Conditional Tables The Complexity of Nulls Other Approaches Bibliographic Notes Exercises Complex Values Complex Value Databases The Algebra The Calculus Examples Equivalence Theorems Fixpoint and Deduction Expressive Power and Complexity Bibliographic Notes Exercises Object Databases Informal Presentation Formal Definition of an OODB Model Languages for OODB Queries Languages for Methods Further Issues for OODBs Bibliographic Notes Exercises Dynamic Aspects Update Languages Transactional Schemas Updating Views and Deductive Databases Updating Incomplete Information	x-5-1
xviii Contents Temporal Databases and Constraints Bibliographic Notes Exercises Bibliography Symbol Index Index	x-6-1
I thought this was a theory book.	x-7-1
Vittorio: Yes, but good theory needs the big picture.	x-8-1
Sergio: Besides, what will you tell your grandfather when he asks what you study?	x-9-1
Riccardo: You can’t tell him that you’re studying the fundamental implications of genericity in database queries.	x-10-1
Computers are now used in almost all aspects of human activity.	x-11-1
One of their main uses is to manage information, which in some cases involves simply holding data for future retrieval and in other cases serving as the backbone for managing the life cycle of complex financial or engineering processes.	x-11-2
A large amount of data stored in a computer is called a database.	x-11-3
The basic software that supports the management of this data is called a database management system (dbms).	x-11-4
The dbms is typically accompanied by a large and evergrowing body of application software that accesses and modifies the stored information.	x-11-5
The primary focus in this book is to present part of the theory underlying the design and use of these systems.	x-11-6
This preliminary chapter briefly reviews the field of database systems to indicate the larger context that has led to this theory.	x-11-7
The Main Principles Database systems can be viewed as mediators between human beings who want to use data and physical devices that hold it (see Fig.	x-12-1
1.1).	x-12-2
Early database management was based on explicit usage of file systems and customized application software.	x-12-3
Gradually, principles and mechanisms were developed that insulated database users from the details of the physical implementation.	x-12-4
In the late 1960s, the first major step in this direction was the development of three-level architecture.	x-12-5
This architecture separated database functionalities into physical, logical, and external levels.	x-12-6
(See Fig.	x-12-7
1.2.	x-12-8
The three views represent various ways of looking at the database: multirelations, universal relation interface, and graphical interface.)	x-12-9
The separation of the logical definition of data from its physical implementation is central to the field of databases.	x-13-1
One of the major research directions in the field has been the development and study of abstract, human-oriented models and interfaces for specifying the structure of stored data and for manipulating it.	x-13-2
These models permit the user to concentrate on a logical representation of data that resembles his or her vision of the reality modeled by the data much more closely than the physical representation.	x-13-3
Database Systems DBMS Figure 1.1: Database as mediator between humans and data Several logical data models have been developed, including the hierarchical, network, relational, and object oriented.	x-14-1
These include primarily a data definition language (DDL) for specifying the structural aspects of the data and a data manipulation language (DML) for accessing and updating it.	x-14-2
The separation of the logical from the physical has resulted in an extraordinary increase in database usability and programmer productivity.	x-14-3
The separation of the logical and physical levels of a database system is usually called the data independence principle.	x-15-1
This is arguably the most important distinction between file systems and database systems.	x-15-2
The second separation in the architecture, between external and logical levels, is also important.	x-16-1
It permits different perspectives, or views, on the database that are tailored to specific needs.	x-16-2
Views hide irrelevant information and restructure data that is retained.	x-16-3
Such views may be simple, as in the case of automatic teller machines, or highly intricate, as in the case of computer-aided design systems.	x-16-4
External Level View 1 View 2 View 3 Logical Level Physical Level Figure 1.2: Three-level architecture of database systems Functionalities Modern dbms’s include a broad array of functionalities, ranging from the very physical to the relatively abstract.	x-17-1
Some functionalities, such as database recovery, can largely be ignored by almost all users.	x-17-2
Others (even among the most physical ones, such as indexing) are presented to application programmers in abstracted ways.	x-17-3
The primary functionalities of dbms’s are as follows: Secondary storage management: The goal of dbms’s is the management of large amounts of shared data.	x-18-1
By large we mean that the data is too big to fit in main memory.	x-18-2
Thus an essential task of these systems is the management of secondary storage, which involves an array of techniques such as indexing, clustering, and resource allocation.	x-18-3
Persistence: Data should be persistent (i.e., it should survive the termination of a particular database application so that it may be reused later).	x-19-1
This is a clear divergence from standard programming, in which a data structure must be coded in a file to live beyond the execution of an application.	x-19-2
Persistent programming languages (e.g., persistent C++) are now emerging to overcome this limitation of programming languages.	x-19-3
Database Systems Concurrency control: Data is shared.	x-20-1
The system must support simultaneous access to shared information in a harmonious environment that controls access conflicts and presents a coherent database state to each user.	x-20-2
This has led to important notions such as transaction and serializability and to techniques such as two-phase locking that ensure serializability.	x-20-3
Data protection: The database is an invaluable source of information that must be protected against human and application program errors, computer failures, and human mis-use.	x-21-1
Integrity checking mechanisms focus on preventing inconsistencies in the stored data resulting, for example, from faulty update requests.	x-21-2
Database recovery and back-up protocols guard against hardware failures, primarily by maintaining snapshots of previous database states and logs of transactions in progress.	x-21-3
Finally, security control mechanisms prevent classes of users from accessing and/or changing sensitive information.	x-21-4
Human-machine interface: This involves a wide variety of features, generally revolving around the logical representation of data.	x-22-1
Most concretely, this encompasses DDLs and DMLs, including both those having a traditional linear format and the emerging visual interfaces incorporated in so-called fourth-generation languages.	x-22-2
Graphically based tools for database installation and design are popular.	x-22-3
Distribution: In many applications, information resides in distinct locations.	x-23-1
Even within a local enterprise, it is common to find interrelated information spread across several databases, either for historical reasons or to keep each database within manageable size.	x-23-2
These databases may be supported by different systems (interoperability) and based on distinct models (heterogeneity).	x-23-3
The task of providing transparent access to multiple systems is a major research topic of the 1990s.	x-23-4
Compilation and optimization: A major task of database systems is the translation of the requests against the external and logical levels into executable programs.	x-24-1
This usually involves one or more compilation steps and intensive optimization so that performance is not degraded by the convenience of using more friendly interfaces.	x-24-2
Some of these features concern primarily the physical data level: concurrency control, recovery, and secondary storage management.	x-25-1
Others, such as optimization, are spread across the three levels.	x-25-2
Database theory and more generally, database models have focused primarily on the description of data and on querying facilities.	x-26-1
The support for designing application software, which often constitutes a large component of databases in the field, has generally been overlooked by the database research community.	x-26-2
In relational systems applications can be written in C and extended with embedded SQL (the standard relational query language) commands for accessing the database.	x-26-3
Unfortunately there is a significant distance between the paradigms of C and SQL.	x-26-4
The same can be said to a certain extent about fourth-generation languages.	x-26-5
Modern approaches to improving application programmer productivity, such as object-oriented or active databases, are being investigated.	x-26-6
Complexity and Diversity In addition to supporting diverse functionalities, the field of databases must address a broad variety of uses, styles, and physical platforms.	x-27-1
Examples of this variety include the following:	x-27-2
Users: Application programmers and software, customer service representatives, secre-taries, database administrators (dba’s), computer gurus, other databases, expert systems, etc.	x-28-1
Logical models: The most prominent of these are the network, hierarchical, relational, and object-oriented models; and there are variations in each model as implemented by various vendors.	x-29-1
Platforms: Variations in host programming languages, computing hardware and operating systems, secondary storage devices (including conventional disks, optical disks, tape), networks, etc.	x-30-1
Both the quality and quantity of variety compounds the complexity of modern dbms’s, which attempt to support as much diversity as possible.	x-31-1
Past and Future	x-32-1
Both provide some logical organization of data (in graphs and trees), but these representations closely mirror the physical storage of the data.	x-33-1
Furthermore, the DMLs for these are primitive because they focus primarily on navigation through the physically stored data.	x-33-2
In the 1970s, Codd’s relational model revolutionized the field.	x-34-1
In this model, humans view the data as organized in relations (tables), and more “declarative” languages are provided for data access.	x-34-2
Indexes and other mechanisms for maintaining the interconnection between data are largely hidden from users.	x-34-3
The approach became increasingly accepted as implementation and optimization techniques could provide reasonable response times in spite of the distance between logical and physical data organization.	x-34-4
The relational model also provided the initial basis for the development of a mathematical investigation of databases, largely because it bridges the gap between data modeling and mathematical logic.	x-34-5
Database Systems Historically dbms’s were biased toward business applications, and the relational model best fitted the needs.	x-35-1
However, the requirements for the management of large, shared amounts of data were also felt in a variety of fields, such as computer-aided design and expert systems.	x-35-2
These new applications require more in terms of structures (more complex than relations), control (more dynamic environments), and intelligence (incorporation of knowledge).	x-35-3
They have generated research and developments at the border of other fields.	x-35-4
Perhaps the most important developments are the following: Object-oriented databases: These have come from the merging of database technology, object-oriented languages (e.g., C++), and artificial intelligence (via semantic models).	x-36-1
In addition to providing richer logical data structures, they permit the incorporation of behavioral information into the database schema.	x-37-1
This leads to better interfaces and a more modular perspective on application software; and, in particular, it improves the programmer’s productivity.	x-37-2
Deductive and active databases: These originated from the fusion of database technology and, respectively, logic programming (e.g., Prolog) and production-rule systems (e.g., OPS5).	x-38-1
The hope is to provide mechanisms that support an abstract view of some aspects of information processing analogous to the abstract view of data provided by logical data models.	x-38-2
This processing is generally represented in the form of rules and separated from the control mechanism used for applying the rules.	x-38-3
These two directions are catalysts for significant new developments in the database field.	x-39-1
Ties with This Book Over the past two decades, database theory has pursued primarily two directions.	x-40-1
The principal one, which is the focus of this book, concerns those topics that can meaningfully be discussed within the logical and external layers.	x-40-2
The other, which has a different flavor and is not discussed in this book, is the elegant theory of concurrency control.	x-40-3
The majority of this book is devoted to the study of the relational model.	x-41-1
In particular, relational query languages and language primitives such as recursion are studied in depth.	x-41-2
The theory of dependencies, which provides the formal foundation of integrity constraints, is also covered.	x-42-1
In the last part of the book, we consider more recent topics whose theory is generally less well developed, including object-oriented databases and behavioral aspects of databases.	x-42-2
By its nature, theoretical investigation requires the careful articulation of all assumptions.	x-43-1
This leads to a focus on abstract, simplified models of much more complex practical situations.	x-43-2
For example, one focus in the early part of this book is on conjunctive queries.	x-43-3
These form the core of the select-from-where clause of the standard language in database systems, SQL, and are perhaps the most important class of queries from a practical standpoint.	x-44-1
However, the conjunctive queries ignore important practical components of SQL, such as arithmetic operations.	x-44-2
Speaking more generally, database theory has focused rather narrowly on specific areas that are amenable to theoretical investigation.	x-45-1
Considerable effort has been directed toward the expressive power and complexity of both query languages and dependencies, in which close ties with mathematical logic and complexity theory could be exploited.	x-45-2
On the Bibliographic Notes other hand, little theory has emerged in connection with physical query optimization, in which it is much more difficult to isolate a small handful of crucial features upon which a meaningful theoretical investigation can be based.	x-45-3
Other fundamental topics are only now receiving attention in database theory (e.g., the behavioral aspects of databases).	x-45-4
Theoretical research in computer science is driven both by the practical phenomena that it is modeling and by aesthetic and mathematical rigor.	x-46-1
Although practical motivations are touched on, this text dwells primarily on the mathematical view of databases and presents many concepts and techniques that have not yet found their place in practical systems.	x-46-2
For instance, in connection with query optimization, little is said about the heuristics that play such an important role in current database systems.	x-46-3
However, the homomorphism theorem for conjunctive queries is presented in detail; this elegant result highlights the essential nature of conjunctive queries.	x-46-4
The text also provides a framework for analyzing a broad range of abstract query languages, many of which are either motivated by, or have influenced, the development of practical languages.	x-46-5
With respect to the larger field of database systems, we hope this book will serve a dual purpose: (1) to explain to database system practitioners some of the underlying principles and characteristics of the systems they use or build, and (2) to arouse the curiosity of theoreticians reading this book to learn how database systems are actually created.	x-47-1
Bibliographic Notes There are many books on database systems, including [Dat86, EN89, KS91, Sto88, Ull88, Ull89b, DA83, Vos91].	x-48-1
A (now old) bibliography on databases is given in [Kam81].	x-48-2
A good introduction to the field may be found in [KS91], whereas [Ull88, Ull89b] provides a more in-depth presentation.	x-48-3
The relational model is introduced in [Cod70].	x-49-1
The first text on the logical level of database theory is [Mai83].	x-49-2
More recent texts on the subject include [PBGG89], which focuses on aspects of relational database theory; [Tha91], which covers portions of dependency theory; and [Ull88, Ull89b], which covers both practical and theoretical aspects of the field.	x-49-3
The reader is also referred to the excellent survey of relational database theory in [Kan88], which forms a chapter of the Handbook of Theoretical Computer Science	x-49-4
Database concurrency control is presented in [Pap86, BHG87].	x-50-1
Deductive databases are covered in [Bid91a, CGT90].	x-50-2
Collections of papers on this topic can be found in	x-50-3
Will we ever get to the real stuff?	x-51-1
Vittorio: Cine nu cunoa¸ste lema, nu cunoa¸ste teorema.	x-52-1
Riccardo: What is Vittorio talking about?	x-53-1
Sergio: This is an old Romanian saying that means, “He who doesn’t know the lemma doesn’t know the teorema .” I see.	x-54-1
Thischaptergivesabriefreviewofthemaintheoreticaltoolsandresultsthatareusedin this volume.	x-55-1
It is assumed that the reader has a degree of maturity and familiarity with mathematics and theoretical computer science.	x-55-2
The review begins with some basics from set theory, including graphs, trees, and lattices.	x-55-3
Then, several topics from automata and complexity theory are discussed, including finite state automata, Turing machines, computability and complexity theories, and context-free languages.	x-55-4
Finally basic mathematical logic is surveyed, and some remarks are made concerning the specializing assumptions typically made in database theory.	x-55-5
Some Basics This section discusses notions concerning binary relations, partially ordered sets, graphs and trees, isomorphisms and automorphisms, permutations, and some elements of lattice theory.	x-56-1
For example, if Z is a set, then inclusion (⊆) is a binary relation over the power set P(Z) of Z and also over the finitary power set Pfin(Z) of Z (i.e., the set of all finite subsets of Z).	x-57-1
Viewed as sets, the binary relation ≤ on the set N of nonnegative integers properly contains the relation < on N.	x-57-2
We also have occasion to study n-ary relations over a set S; these are subsets of Sn, the cross-product of S with itself n times.	x-58-1
Indeed, these provide one of the starting points of the relational model.	x-58-2
Let E and E′ be equivalence relations on a nonempty set S. E is a refinement of E′ if E ⊆ E′.	x-59-1
In this case, for each x ∈ S we have [x]E ⊆ [x]E′, and, more precisely, each equivalence class of E′ is a disjoint union of one or more equivalence classes of E.	x-59-2
For any set Z, the relation ⊆ over P(Z) is a partially ordered set.	x-60-1
If the cardinality |Z| of Z is greater than 1, then this is not a total order.	x-60-2
≤ on N is a total order.	x-60-3
If (S, R) is a partially ordered set, then a topological sort of S (relative to R) is a binary relation R′ on S that is a total order such that R′ ⊇ R. Intuitively, R′ is compatible with R in the sense that xRy implies xR′y.	x-61-1
Let R be a binary relation over S, and P be a set of properties of binary relations.	x-62-1
The P- closure of R is the smallest binary relation R′ such that R′ ⊇ R and R′ satisfies all of the properties in P (if a unique binary relation having this specification exists).	x-62-2
For example, it is common to form the transitive closure of a binary relation or the reflexive and transitive closure of a binary relation.	x-62-3
In many cases, a closure can be constructed using a recursive procedure.	x-62-4
For example, given binary relation R, the transitive closure R+ of R can be obtained as follows:	x-62-5
For an arbitrary binary relation R, the reflexive, symmetric, and transitive closure of R exists and is an equivalence relation.	x-63-1
There is a close relationship between binary relations and graphs.	x-64-1
The definitions and notation for graphs presented here have been targeted for their application in this book.	x-64-2
A ( directed) graph is a pair G = (V , E), where V is a finite set of vertexes and E ⊆ V × V .	x-64-3
In some cases, we define a graph by presenting a set E of edges; in this case, it is understood that the vertex set is the set of endpoints of elements of E.	x-64-4
Theoretical Background path and n > 2.	x-65-1
If G has a cycle from v, then G has a proper cycle from v. A graph G = (V , E) is acyclic if it has no cycles or, equivalently, if the transitive closure of E is irreflexive.	x-65-2
Let G = (V , E) be a graph.	x-66-1
Two vertexes u, v are connected if there is an undirected path in G from u to v, and they are strongly connected if there are directed paths from u to v and from v to u. Connectedness and strong connectedness are equivalence relations on V .	x-66-2
A ( strongly) connected component of G is an equivalence class of V under (strong) connectedness.	x-66-3
A graph is (strongly) connected if it has exactly one (strongly) connected component.	x-66-4
The graph (M, L) of Parisian metro stations and nonstop links between them is strongly connected.	x-67-1
The graph ({a, b, c, d, e}, {(a, b), (b, a), (b, c), (c, d), (d, e), (e, c)}) is connected but not strongly connected.	x-67-2
The distance d(a, b) of two nodes a, b in a graph is the length of the shortest path connecting a to b [d(a, b) = ∞ if a is not connected to b].	x-68-1
The diameter of a graph G is the maximum finite distance between two nodes in G.	x-68-2
Given a forest, removal of one edge increases the number of connected components by exactly one.	x-69-1
In general, we shall focus on directed graphs, but there will be occasions to use undirected graphs.	x-70-1
An undirected graph is a pair G = (V , E), where V is a finite set of vertexes and E is a set of two-element subsets of V , again called edges.	x-70-2
The notions of path and connected generalize to undirected graphs in the natural fashion.	x-70-3
We shall have occasions to label the vertexes or edges of a (directed or undirected) graph.	x-71-1
For example, a labeling of the vertexes of a graph G = (V , E) with label set L is a function λ : V → L.	x-71-2
Let G = (V , E) and G′ = (V ′, E′) be two directed graphs.	x-72-1
A function h : V → V ′ is a homomorphism from G to G′ if for each pair u, v ∈ V , (u, v) ∈ E implies (h(u), h(v)) ∈ E′.	x-72-2
The function h is an isomorphism from G to G′ if h is a one-one onto mapping from V to V ′, h is a homomorphism from G to G′, and h−1 is a homomorphism from G′ to G.	x-72-3
Consider the graph G = ({a, b, c, d, e}, {(a, b), (b, a), (b, c), (b, d), (b, e), (c, d), (d, e), (e, c)}).	x-73-1
There are three automorphisms on G: (1) the identity; (2) the function that maps c to d, d to e, e to c and leaves a, b fixed; and (3) the function that maps c to e, d to c, e to d and leaves a, b fixed.	x-73-2
Let S be a set.	x-74-1
A permutation of S is a one-one onto function ρ : S → S. Suppose that x1, .	x-74-2
.	x-74-3
.	x-74-4
, xn is an arbitrary, fixed listing of the elements of S (without repeats).	x-74-5
Then there is a natural one-one correspondence between permutations ρ on S and listings xi , .	x-74-6
.	x-74-7
.	x-74-8
, x 1 in of elements of S without repeats.	x-74-9
A permutation ρ′ is derived from permutation ρ by an exchange if the listings corresponding to ρ and ρ′ agree everywhere except at some positions i and i + 1, where the values are exchanged.	x-74-10
Given two permutations ρ and ρ′, ρ′ can be derived from ρ using a finite sequence of exchanges.	x-74-11
Languages, Computability, and Complexity This area provides one of the foundations of theoretical computer science.	x-75-1
A general reference for this area is [LP81].	x-75-2
References on automata theory and languages include, for instance, the chapters [BB91, Per91] of [Lee91] and the books [Gin66, Har78].	x-75-3
References on complexity include the chapter [Joh91] of [Lee91] and the books [GJ79, Pap94].	x-75-4
Let # be a finite set called an alphabet.	x-76-1
A word over alphabet # is a finite sequence a1 .	x-76-2
.	x-76-3
.	x-76-4
an, where ai ∈ #, 1 ≤ i ≤ n, n ≥ 0.	x-76-5
The length of w = a1 .	x-76-6
.	x-76-7
.	x-76-8
an, denoted |w|, is n.	x-76-9
The empty word (n = 0) is denoted by ǫ.	x-77-1
The concatenation of two words u = a1 .	x-77-2
.	x-77-3
.	x-77-4
an and v = b1 .	x-77-5
.	x-77-6
.	x-77-7
bk is the word a1 .	x-77-8
.	x-77-9
.	x-77-10
anb1 .	x-77-11
.	x-77-12
.	x-77-13
bk, denoted uv.	x-77-14
The concatenation of u with itself n times is denoted un.	x-77-15
The set of all words over # is denoted by #∗.	x-77-16
A language over # is a subset of #∗.	x-77-17
For example, if # = {a, b}, then {anbn | n ≥ 0} is a language over #.	x-77-18
The concatenation of two languages L and K is LK = {uv | u ∈ L, v ∈ K}.	x-77-19
L concatenated with itself n times is denoted Ln, and L∗ = n≥0 Ln.	x-77-20
Finite Automata In databases, one can model various phenomena using words over some finite alphabet.	x-78-1
For example, sequences of database events form words over some alphabet of events.	x-79-1
More generally, everything is mapped internally to a sequence of bits, which is nothing but a word over alphabet {0, 1}.	x-79-2
The notion of computable query is also formalized using a low-level representation of a database as a word.	x-79-3
is a 5-tuple S, #, δ, s0, F , where Theoretical Background	x-80-1
For example, let M be the fsa with even even odd odd odd even The language accepted by M is L(M) = {w | w has an even number of occurrences of 1}.	x-81-1
This property is formalized by the so-called pumping lemma for regular languages.	x-82-1
Throughout his or her career, an employee is first hired, can be transferred any number of times, and eventually quits, retires, or is fired.	x-83-1
The language whose words are allowable sequences of such events can be specified by a regular expression as hire (transfer)∗ (quit	x-83-2
There are several important variations of fsa that do not change their accepting power.	x-84-1
The first allows scanning the input back and forth any number of times, yielding two-way	x-85-1
Nondeterministic fsa (nfsa) accept the same set of languages as fsa.	x-86-1
However, the number of states in the equivalent deterministic fsa may be exponential in the number of states of the nondeterministic one.	x-86-2
Thus nondeterminism can be viewed as a convenience allowing much more succinct specification of some regular languages.	x-86-3
Turing Machines and Computability Turing machines (TMs) provide the classical formalization of computation.	x-87-1
They are also used to develop classical complexity theory.	x-87-2
Turing machines are like fsa, except that symbols can also be overwritten rather than just read, the head can move in either direction, and the amount of tape available is infinite.	x-87-3
Thus a move of a TM consists of reading the current tape symbol, overwriting the symbol with a new one from a specified finite tape alphabet, moving the head left or right, and changing state.	x-87-4
Like an fsa, a TM can be viewed as an acceptor.	x-87-5
The language accepted by a TM M, denoted L(M), consists of the words w such that, on input w, M halts in an accepting state.	x-87-6
Alternatively, one can view TM as a generator of words.	x-87-7
The TM starts on empty input.	x-87-8
To indicate that some word of interest has been generated, the TM goes into some specified state and then continues.	x-87-9
Typically, this is a nonterminating computation generating an infinite language.	x-87-10
The set of words so generated by some TM M is denoted G(M).	x-88-1
Finally, TMs can also be viewed as computing a function from input to output.	x-88-2
A TM M computes a partial mapping f from #∗ to #∗ if for each w ∈ #∗: (1) if w is in the domain of f , then M halts on input w with the tape containing the word f (w); (2) otherwise M does not halt on input w.	x-88-3
Church’s thesis states that any function computable by some reasonable computing device is also computable in the aforementioned sense.	x-89-1
So the definition of computability by TMs is robust.	x-89-2
In particular, it is insensitive to many variations in the definition of TM, such as allowing multiple tapes.	x-89-3
A particularly important variation allows for nondeterminism, similar to nondeterministic fsa.	x-89-4
In a nondeterministic TM (NTM), there can be a choice of moves at each step.	x-89-5
Thus an NTM has several possible computations on a given input (of which some may be terminating and others not).	x-89-6
A word w is accepted by an NTM M if there exists at least one computation of M on w halting in an accepting state.	x-89-7
The machine can only test for emptiness of each stack.	x-90-1
Counter machines can also define all computable functions.	x-90-2
An essentially equivalent and useful formulation of this fact is that the language with integer variables i, j, .	x-90-3
.	x-90-4
.	x-90-5
, two instructions increment(i) and decrement(i), and a looping construct while i > 0 do, can define all computable functions on the integers.	x-90-6
Of course, we are often interested in functions on domains other than words—integers are one example.	x-91-1
To talk about the computability of such functions on other domains, one goes through an encoding in which each element d of the domain is represented as a word Theoretical Background enc(d) on some fixed, finite alphabet.	x-91-2
Given that encoding, it is said that f is computable if the function enc(f ) mapping enc(d) to enc(f (d)) is computable.	x-91-3
This often works without problems, but occasionally it raises tricky issues that are discussed in a few places of this book (particularly in Part E).	x-91-4
It can be shown that a language is L(M) for some acceptor TM M iff it is G(M) for some generator TM M. A language is recursively enumerable (r.e.)	x-92-1
iff it is L(M) [or G(M)] for some TM M. L being r.e.	x-92-2
means that there is an algorithm that is guaranteed to say eventually yes on input w if w ∈ L but may run forever if w ∈ L (if it stops, it says no).	x-92-3
Thus one can never know for sure if a word is not in L.	x-93-1
Informally, saying that L is recursive means that there is an algorithm that always decides in finite time whether a given word is in L. If L = L(M) and M always halts, L is recursive.	x-94-1
A language whose complement is r.e.	x-94-2
is called co-r.e.	x-94-3
The following useful facts can be shown:	x-94-4
Formally, thing-a-ma-jigs are encoded as words over some finite alphabet.	x-95-1
The property of being a widget is decidable iff the language of words encoding widgets is recursive.	x-95-2
We mention a few classical undecidable problems.	x-96-1
The halting problem asks if a given TM M halts on a specified input w. This problem is undecidable (i.e., there is no algorithm that, given the description of M and the input w, decides in finite time if M halts on w).	x-96-2
More generally it can be shown that, in some precise sense, all nontrivial questions about TMs are undecidable (this is formalized by Rice’s theorem).	x-97-1
A more concrete undecidable problem, which is useful in proofs, is the Post correspondence problem (PCP).	x-97-2
The input to the PCP consists of two lists u1, .	x-97-3
.	x-97-4
.	x-97-5
, un; v1, .	x-97-6
.	x-97-7
.	x-97-8
, vn; of words over some alphabet # with at least two symbols.	x-97-9
A solution to the PCP is a sequence of indexes i1, .	x-97-10
.	x-97-11
.	x-97-12
, ik, 1 ≤ ij ≤ n, such that ui .	x-97-13
.	x-97-14
.	x-97-15
u = v .	x-97-16
.	x-97-17
.	x-97-18
v .	x-97-19
ik i1 ik	x-98-1
The question of interest is whether there is a solution to the PCP.	x-99-1
For example, consider the input to the PCP problem: u1 u2 u3 u4 v1 v2 v3 v4 bbb bb babba.	x-99-2
For this input, the PCP has the solution 1, 4, 3, 1; because u1u4u3u1 = ababbaababa = v1v4v3v1.	x-100-1
Now consider the input consisting of just u1, u2, u3 and v1, v2, v3.	x-101-1
An easy case analysis shows that there is no solution to the PCP for this input.	x-101-2
In general, it has been shown that it is undecidable whether, for a given input, there exists a solution to the PCP.	x-101-3
The PCP is particularly useful for proving the undecidability of other problems.	x-102-1
The proof technique consists of reducing the PCP to the problem of interest.	x-102-2
For example, suppose we are interested in the question of whether a given thing-a-ma-jig is a widget.	x-102-3
The reduction of the PCP to the widget problem consists of finding a computable mapping f that, given an input i to the PCP, produces a thing-a-ma-jig f (i) such that f (i) is a widget iff the PCP has a solution for i.	x-103-1
If one can find such a reduction, this shows that it is undecidable if a given thing-a-ma-jig is a widget.	x-103-2
Indeed, if this were decidable then one could find an algorithm for the PCP: Given an input i to the PCP, first construct the thing-a-ma-jig f (i), and then apply the algorithm deciding if f (i) is a widget.	x-103-3
Because we know that the PCP is undecidable, the property of being a widget cannot be decidable.	x-103-4
Of course, any other known undecidable problem can be used in place of the PCP.	x-103-5
Complexity Suppose a particular problem is solvable.	x-104-1
Of course, this does not mean the problem has a practical solution, because it may be prohibitively expensive to solve it.	x-104-2
Complexity theory studies the difficulty of problems.	x-104-3
Difficulty is measured relative to some resources of interest, usually time and space.	x-104-4
Again the usual model of reference is the TM.	x-104-5
Suppose L is a recursive language, accepted by a TM M that always halts.	x-104-6
Let f be a function on positive integers.	x-104-7
M is said to use time bounded by f if on every input w, M halts in at most f (|w|) steps.	x-104-8
M uses space bounded by f if the amount of tape used by M on every input w is at most f (|w|).	x-104-9
The set of recursive languages accepted by TMs using time (space) bounded by f is denoted TIME(f ) (SPACE(f )).	x-104-10
Let F be a set of functions on positive integers.	x-104-11
Then TIME(F ) = TIME(f ), and SPACE(F ) = SPACE(f ).	x-105-1
A particularly f ∈F f ∈F important class of bounding functions is the polynomials Poly.	x-105-2
For this class, the following notation has emerged: TIME( Poly) is denoted ptime, and SPACE( Poly) is denoted pspace.	x-105-3
Membership in the class ptime is often regarded as synonymous to tractability (although, of course, this is not reasonable in all situations, and a case-by-case judgment should be made).	x-106-1
Besides the polynomials, it is of interest to consider lower bounds, like logarithmic space.	x-106-2
However, because the input itself takes more than logarithmic space to write down, a Theoretical Background separation of the input tape from the tape used throughout the computation must be made.	x-106-3
Thus the input is given on a read-only tape, and a separate worktape is added.	x-107-1
Now let logspace consist of the recursive languages L that are accepted by some such TM using on input w an amount of worktape bounded by c × log(|w|) for some constant c.	x-107-2
hyp 0(n) = n Hyp = { hyp | i i ≥ 0}, where hyp i+1(n) = 2 hyp i(n).	x-108-1
The elementary languages are those in TIME( Hyp).	x-109-1
Nondeterministic TMs can be used to define complexity classes as well.	x-110-1
An NTM uses time bounded by f if all computations on input w halt after at most f (|w|) steps.	x-110-2
It uses space bounded by f if all computations on input w use at most f (|w|) space (note that termination is not required).	x-110-3
The set of recursive languages accepted by some NTM using time bounded by a polynomial is denoted np, and space bounded by a polynomial is denoted by npspace.	x-110-4
Are nondeterministic classes different from their deterministic counterparts?	x-110-5
For polynomial space, Savitch’s theorem settles the question by showing that pspace = npspace (the theorem actually applies to a much more general class of space bounds).	x-110-6
For time, things are more complicated.	x-110-7
Indeed, the question of whether ptime equals np is the most famous open problem in complexity theory.	x-110-8
It is generally conjectured that the two classes are distinct.	x-110-9
The following inclusions hold among the complexity classes described: logspace ⊆ ptime ⊆ np ⊆ pspace ⊂ TIME( Hyp) = SPACE( Hyp).	x-111-1
Complexity classes of languages can be extended, in the same spirit, to complexity classes of computable functions.	x-112-1
Here we look at the resources needed to compute the function rather than just accepting or rejecting the input word.	x-112-2
Consider some complexity class, say C = TIME(F ).	x-113-1
Such a class contains all problems that can be solved in time bounded by some function in F .	x-113-2
This is an upper bound, so C clearly contains some easy and some hard problems.	x-113-3
How can the hard problems be distinguished from the easy ones?	x-113-4
This is captured by the notion of completeness of a problem in a complexity class.	x-113-5
The idea is as follows: A language K in C is complete in C if solving it allows solving all other problems in C, also within C. This is formalized by the notion of reduction.	x-113-6
Let L and K be languages in C. L is reducible to K if there is a computable mapping f such that for each w, w ∈ L iff f (w) ∈ K. The definition of reducibility so far guarantees that solving K allows solving L. How about the complexity?	x-113-7
Clearly, if the reduction f is hard then we do not have an acceptance algorithm in C.	x-114-1
Therefore the complexity of f must be bounded.	x-115-1
It might be tempting to use C as the bound.	x-115-2
However, this allows all the work of solving L within the reduction, which really makes K irrelevant.	x-115-3
Therefore the definition of completeness in a class C requires that the complexity of the reduction function be lower than that for C. More formally, a recursive language is complete in C by C′ reductions if for each L ∈ C there is a function f in C′ reducing L to K. The class C′ is often understood for some of the main classes C. The conventions we will use are summarized in the following table: Type of Completeness Type of Reduction p completeness logspace reductions np completeness ptime reductions pspace completeness ptime reductions Note that to prove that a problem L is complete in C by C′ reductions, it is sufficient to exhibit another problem K that is known to be complete in C by C′ reductions, and a C′ reduction from K to L. Because the C′-reducibility relation is transitive for all customarily used C′, it then follows that L is itself C complete by C′ reductions.	x-115-4
We mention next a few problems that are complete in various classes.	x-115-5
One of the best-known np-complete problems is the so-called 3-satisfiability (3-SAT) problem.	x-116-1
The input is a propositional formula in conjunctive normal form, in which each conjunct has at most three literals.	x-116-2
For example, such an input might be (¬x1 ∨ ¬x4 ∨ ¬x2) ∧ (x1 ∨ x2 ∨ x4) ∧ (¬x4 ∨ x3 ∨ ¬x1).	x-116-3
The question is whether the formula is satisfiable.	x-117-1
For example, the preceding formula is satisfied with the truth assignment ξ(x1) = ξ(x2) = false, ξ(x3) = ξ(x4) = true.	x-117-2
(See Section 2.3 for the definitions of propositional formula and related notions.)	x-117-3
A useful pspace-complete problem is the following.	x-117-4
The input is a quantified propositional formula (all variables are quantified).	x-117-5
The question is whether the formula is true.	x-117-6
For example, an input to the problem is	x-118-1
For ptime completeness, one can use a natural problem related to context-free grammars (defined next).	x-119-1
The input is a context-free grammar G and the question is whether L(G) is empty.	x-119-2
Context-Free Grammars We have discussed specification of languages using two kinds of acceptors: fsa and TM.	x-120-1
Context-free grammars (CFGs) provide different approach to specifying a language that emphasizes the generation of the words in the language rather than acceptance.	x-121-1
(Nonetheless, this can be turned into an accepting mechanism by parsing.)	x-121-2
A CFG is a 4-tuple N, #, S, P , where Theoretical Background	x-121-3
is called context free if it is L(G) for some CFG G. For example, consider the grammar S → ǫ, S → aSb.	x-122-1
Then L(G) is the language {anbn | n ≥ 0}.	x-123-1
For example the following is a derivation of a2b2: S ⇒ aSb ⇒ a2Sb2 ⇒ a2b2.	x-123-2
The specification power of CFGs lies between that of fsa’s and that of TMs.	x-124-1
First, all regular languages are context free and all context-free languages are recursive.	x-124-2
The language {anbn | n ≥ 0} is context free but not regular.	x-124-3
An example of a recursive language that is not context free is {anbncn | n ≥ 0}.	x-124-4
The proof uses an extension to context-free languages of the pumping lemma for regular languages.	x-124-5
We also use a similar technique in some of the proofs.	x-124-6
The most common use of CFGs in the area of databases is to view certain objects as CFGs and use known (un)decidability properties about CFGs.	x-125-1
Some questions about CFGs known to be decidable are (1) emptiness [is L(G) empty?]	x-125-2
and (2) finiteness [is L(G) finite?].	x-125-3
Some undecidable questions are (3) containment [is it true that L(G1) ⊆ L(G2)?]	x-125-4
Basics from Logic The field of mathematical logic is a main foundation for database theory.	x-126-1
It serves as the basis for languages for queries, deductive databases, and constraints.	x-126-2
We briefly review the basic notions and notations of mathematical logic and then mention some key differences between this logic in general and the specializations usually considered in database theory.	x-126-3
The reader is referred to [EFT84, End72] for comprehensive introductions to mathematical logic, and to the chapter [Apt91] in [Lee91] and [Llo87] for treatments of Herbrand models and logic programming.	x-127-1
Propositional Logic We begin with the propositional calculus.	x-128-1
For this we assume an infinite set of propositional variables, typically denoted p, q, r, .	x-128-2
.	x-128-3
.	x-128-4
, possibly with subscripts.	x-128-5
We also permit the special propositional constants true and false.	x-128-6
( Well-formed) propositional formulas are constructed from the propositional variables and constants, using the unary connective negation (¬) and the binary connectives disjunction (∨), conjunction (∧), implication (→), and equivalence (↔).	x-128-7
For example, p, (p ∧ (¬q)) and ((p ∨ q) → p) are well-formed propositional formulas.	x-128-8
We generally omit parentheses if not needed for understanding a formula.	x-128-9
for the variables occurring in ϕ is defined by induction on the structure of ϕ in the natural manner.	x-129-1
For example,	x-129-2
If ϕ[ξ ] = true we say that ϕ[ξ ] is true and that ϕ is true under ξ (and similarly for false).	x-130-1
makes it true.	x-131-1
The formula (p ∨ q) is satisfiable but not valid; the formula (p ∧ (¬p)) is unsatisfiable; and the formula (p ∨ (¬p)) is valid.	x-131-2
For example, (p ∧ (p → q)) |= q.	x-132-1
Many equivalences for propositional formulas are well known.	x-132-2
For example,	x-132-3
Observe that the last equivalence permits us to view ∨ as a polyadic connective.	x-133-1
(The same holds for ∧.)	x-133-2
Theoretical Background First-Order Logic We now turn to first-order predicate calculus.	x-134-1
We indicate the main intuitions and concepts underlying first-order logic and describe the primary specializations typically made for database theory.	x-134-2
Precise definitions of needed portions of first-order logic are included in Chapters 4 and 5.	x-134-3
First-order logic generalizes propositional logic in several ways.	x-135-1
Intuitively, propositional variables are replaced by predicate symbols that range over n-ary relations over an underlying set.	x-135-2
Variables are used in first-order logic to range over elements of an abstract set, called the universe of discourse.	x-135-3
This is realized using the quantifiers ∃ and ∀.	x-135-4
In addition, function symbols are incorporated into the model.	x-135-5
The most important definitions used to formalize first-order logic are first-order language, interpretation, logical implication, and provability.	x-135-6
Each first-order language L includes a set of variables, the propositional connectives, the quantifiers ∃ and ∀, and punctuation symbols “)”, “(”, and “,”.	x-136-1
The variation in first-order languages stems from the symbols they include to represent constants, predicates, and functions.	x-136-2
More formally, a first-order language includes	x-136-3
In some cases, we also include	x-137-1
Let L be a first-order language.	x-138-1
Terms of L are built in the natural fashion from constants, variables, and the function symbols.	x-138-2
An atom is either true, false, or an expression of the form R(t1, .	x-138-3
.	x-138-4
.	x-138-5
, tn), where R is an n-ary predicate symbol and t1, .	x-138-6
.	x-138-7
.	x-138-8
, tn are terms.	x-138-9
Atoms correspond to the propositional variables of propositional logic.	x-138-10
If the equality symbol is included, then atoms include expressions of the form t1 ≈ t2.	x-138-11
The family of ( well-formed predicate calculus) formulas over L is defined recursively starting with atoms, using the Boolean connectives, and using the quantifiers as follows: If ϕ is a formula and x a variable, then (∃xϕ) and (∀xϕ) are formulas.	x-138-12
As with the propositional case, parentheses are omitted when understood from the context.	x-138-13
In addition, ∨ and ∧ are viewed as polyadic connectives.	x-138-14
A term or formula is ground if it involves no variables.	x-138-15
Some examples of formulas in LN are as follows:	x-139-1
The notion of the scope of quantifiers and of free and bound occurrences of variables in formulas is now defined using recursion on the structure.	x-140-1
Each variable occurrence in an atom is free.	x-140-2
If ϕ is (ψ1 ∨ ψ2), then an occurrence of variable x in ϕ is free if it is free as an occurrence of ψ1 or ψ2; and this is extended to the other propositional connectives.	x-140-3
If ϕ is ∃yψ, then an occurrence of variable x = y is free in ϕ if the corresponding occurrence is free in ψ.	x-140-4
Each occurrence of y is bound in ϕ.	x-140-5
In addition, each occurrence of y in ϕ that is free in ψ is said to be in the scope of ∃y at the beginning of ϕ.	x-140-6
A sentence is a well-formed formula that has no free variable occurrences.	x-140-7
Until now we have not given a meaning to the symbols of a first-order language and thereby to first-order formulas.	x-141-1
This is accomplished with the notion of interpretation, which corresponds to the truth assignments of the propositional case.	x-141-2
Each interpretation is just one of the many possible ways to give meaning to a language.	x-141-3
is a nonempty set of abstract elements called the universe ( of discourse), and C, P, and F give meanings to the sets of constant symbols, predicate symbols, and function symbols.	x-142-1
For example, C is a function from the constant symbols into U , and P maps each n-ary predicate symbol p into an n-ary relation over U (i.e., a subset of U n).	x-143-1
It is possible for two distinct constant symbols to map to the same element of U .	x-143-2
When the equality symbol denoted ≈ is included, the meaning associated with it is restricted so that it enjoys properties usually associated with equality.	x-144-1
Two equivalent mechanisms for accomplishing this are described next.	x-144-2
Let I be an interpretation for language L. As a notational shorthand, if c is a constant symbol in L, we use cI to denote the element of the universe associated with c by I.	x-145-1
This is extended in the natural way to ground terms and atoms.	x-145-2
The usual interpretation for the language LN is IN, where the universe is N; 0 is mapped to the number 0; ≤ is mapped to the usual less than or equal relation; S is mapped to successor; and + and × are mapped to addition and multiplication.	x-146-1
In such cases, we have, for example, [S(S(0) + 0))]IN ≈ 2.	x-146-2
from this using the function symbols of the language.	x-147-1
This is a little confusing because the terms now play a dual role—as terms constructed from components of the language L, and as elements of the universe UL .	x-147-2
The mapping C maps the constant symbol 0 to 0 (consid-N ered as an element of UL ).	x-147-3
Given a term t in U , the function F(S) maps t to the term S(t).	x-147-4
N Given terms t1 and t2, the function F(+) maps the pair (t1, t2) to the term +(t1, t2), and the function F (×) is defined analogously.	x-148-1
The set of ground atoms of LN (i.e., the set of atoms that do not contain variables) is sometimes called the Herbrand base of LN.	x-149-1
There is a natural one-one correspondence	x-149-2
Theoretical Background between interpretations of LN that extend the Herbrand preinterpretation and subsets of the Herbrand base of LN.	x-150-1
One Herbrand interpretation of particular interest is the one that mimics the usual interpretation.	x-150-2
In particular, this interpretation maps ≤ to the set I I N N	x-150-3
We now turn to the notion of satisfaction of a formula by an interpretation.	x-151-1
The definition is recursive on the structure of formulas; as a result we need the notion of variable assignment to accommodate variables occurring free in formulas.	x-151-2
Let L be a language and I an interpretation of L with universe U .	x-151-3
A variable assignment for formula ϕ is a partial function µ : variables of L → U whose domain includes all variables free in ϕ.	x-151-4
For terms t, t I,µ denotes the meaning given to t by I, using µ to interpret the free variables.	x-151-5
In addition, if µ is a variable assignment, x is a variable, and u ∈ U , then µ[x/u] denotes the variable assignment that is identical to µ, except that it maps x to u.	x-151-6
We write I |= ϕ[µ] to indicate that I satisfies ϕ under µ.	x-151-7
This is defined recursively on the structure of formulas in the natural fashion.	x-151-8
To indicate the flavor of the definition, we note that I |= p(t1, .	x-151-9
.	x-151-10
.	x-151-11
, tn)[µ] if I,µ I,µ n	x-151-12
For example, IN |= ∀x∃y(¬(x ≈ y) ∨ x ≤ y); IN |= S(0) ≤ 0; and IN |= ∀y∀z(x ≈ y × z → (y ≈ S(0) ∨ z ≈ S(0)))[µ] iff µ(x) is 1 or a prime number.	x-152-1
The set 7 is satisfiable if it has a model.	x-153-1
Logical implication and equivalence are now defined analogously to the propositional case.	x-154-1
Sentence ϕ logically implies sentence ψ, denoted ϕ |= ψ, if each interpretation that satisfies ϕ also satisfies ψ.	x-154-2
There are many straightforward equivalences [e.g., ¬(¬ϕ) ≡ ϕ	x-154-3
It is known that logical implication, considered as a decision problem, is not recursive.	x-155-1
One of the fundamental results of mathematical logic is the development of effective procedures for determining logical equivalence.	x-156-1
These are based on the notion of proofs, and they provide one way to show that logical implication is r.e.	x-156-2
One style of proof, attributed to Hilbert, identifies a family of inference rules and a family of axioms.	x-156-3
An example of an inference rule is modus ponens, which states that from formulas ϕ and ϕ → ψ we may conclude ψ.	x-156-4
Examples of axioms are all tautologies of propositional logic denotes the formula obtained by simultaneously t t is an arbitrary term and ϕxt replacing all occurrences of x free in ϕ by t).	x-156-5
Given a family of inference rules and axioms, a proof that set 7 of sentences implies sentence ϕ is a finite sequence ψ0, ψ1, .	x-156-6
.	x-156-7
.	x-156-8
, ψn = ϕ, where for each i, either ψi is an axiom, or a member of 7, or it follows from one or more of the previous ψj ’s using an inference rule.	x-156-9
In this case we write 7 ⊢ ϕ.	x-156-10
The soundness and completeness theorem of Gödel shows that (using modus ponens and a specific set of axioms) 7 |= ϕ iff 7 ⊢ ϕ.	x-157-1
This important link between |= and ⊢ permits the transfer of results obtained in model theory, which focuses primarily on in- terpretations and models, and proof theory, which focuses primarily on proofs.	x-157-2
Notably, a central issue in the study of relational database dependencies (see Part C) has been the search for sound and complete proof systems for subsets of first-order logic that correspond to natural families of constraints.	x-157-3
The model-theoretic and proof-theoretic perspectives lead to two equivalent ways of incorporating equality into first-order languages.	x-158-1
Under the model-theoretic approach, the equality predicate ≈ is given the meaning {(u, u) | u ∈ U } (i.e., normal equality).	x-158-2
Under the proof-theoretic approach, a set of equality axioms EQL is constructed that express the intended meaning of ≈.	x-158-3
For example, EQL includes the sentences ∀x, y, z(x ≈ y ∧ y ≈	x-158-4
Note that although the compactness theorem guarantees that the 7 in the preceding paragraph has a model, that model is not necessarily finite.	x-159-1
Indeed, 7 may only have infinite models.	x-159-2
It is of some solace that, among those infinite models, there is surely at least one that is countable (i.e., whose elements can be enumerated: a1, a2, .	x-159-3
.	x-159-4
.	x-159-5
).	x-159-6
This technically useful result is the Löwenheim-Skolem theorem.	x-159-7
To illustrate the compactness theorem, we show that there is no set 9 of sentences defining the notion of connectedness in directed graphs.	x-160-1
For this we use the language L with two constant symbols, a and b, and one binary relation symbol R, which corresponds to the edges of a directed graph.	x-160-2
In addition, because we are working with general first-order logic, both finite and infinite graphs may arise.	x-160-3
Suppose now that 9 is a set of sentences that states that a and b are connected (i.e., that there is a directed path from a to b in R).	x-160-4
Let # = {σi | i > 0}, where σi states “a and b are at least i edges apart from each other.” For example, σ3 might be expressed as	x-160-5
It is clear that each finite subset of 9 ∪ # is satisfiable.	x-161-1
By the compactness theorem (second statement), this implies that 9 ∪ # is satisfiable, so it has a model (say, I).	x-161-2
In I, there is no directed path between (the elements of the universe identified by) a and b, and so I |= 9.	x-161-3
This is a contradiction.	x-161-4
Specializations to Database Theory We close by mentioning the primary differences between the general field of mathematical logic and the specializations made in the study of database theory.	x-162-1
The most obvious specialization is that database theory has not generally focused on the use of functions on data values, and as a result it generally omits function symbols from the first-order languages used.	x-162-2
The two other fundamental specializations are the focus on finite models and the special use of constant symbols.	x-162-3
Theoretical Background	x-163-1
The notion of logical implication for finite interpretations, usually denoted |=fin, is not equivalent to the usual logical implication |=.	x-164-1
This is most easily seen by considering the compactness theorem.	x-164-2
Let 7 = {σi | i > 0}, where σi states that there are at least i distinct elements in the universe of discourse.	x-164-3
Then by compactness, 7 |= false, but by the definition of finite interpretation, 7 |=fin false.	x-164-4
The final specialization of database theory concerns assumptions made about the universe of discourse and the use of constant symbols.	x-165-1
Indeed, throughout most of this book we use a fixed, countably infinite set of constants, denoted dom (for domain elements).	x-165-2
Furthermore, the focus is almost exclusively on finite Herbrand interpretations over dom.	x-166-1
In particular, for distinct constants c and c′, all interpretations that are considered satisfy	x-167-1
Most proofs in database theory involving the first-order predicate calculus are based on model theory, primarily because of the emphasis on finite models and because the link between |=fin and ⊢ does not hold.	x-168-1
It is thus informative to identify a mechanism for using traditional proof-theoretic techniques within the context of database theory.	x-168-2
For this discussion, consider a first-order language with set dom of constant symbols and predicate symbols R1, .	x-168-3
.	x-168-4
.	x-168-5
, Rn.	x-168-6
As will be seen in Chapter 3, a database instance is a finite Herbrand interpretation I of this language.	x-168-7
Following [Rei84], a family #I of sentences is associated with I.	x-168-8
This family includes the axioms of equality (mentioned earlier) and Atoms: Ri($	x-168-9
i Extension axioms: ∀$ x(Ri($ x) ↔ ($ x ≈ $ x ≈ $ terms.	x-169-1
Unique Name axioms: ¬c ≈ c′ for each distinct pair c, c′ of constants occurring in I.	x-170-1
Domain Closure axiom: ∀x(x ≈ c1 ∨ · · · ∨ x ≈ cn), where c1, .	x-171-1
.	x-171-2
.	x-171-3
, cn is a listing of all constants occurring in I.	x-171-4
The first two sets of sentences of an extended relational theory express the specific contents of the relations (predicate symbols) of I.	x-172-1
Importantly, the Extension sentences ensure that for any (not necessarily Herbrand) interpretation J satisfying #I, an n-tuple is in RJ iff it equals one of the n-tuples in RI.	x-172-2
The Unique Name axiom ensures that no pair of i i distinct constants is mapped to the same element in the universe of J , and the Domain Closure axiom ensures that each element of the universe of J equals some constant occurring in I.	x-172-3
For all intents and purposes, then, any interpretation J that models #I is isomorphic to I, modulo condensing under equivalence classes induced by ≈J .	x-172-4
Importantly, the following link with conventional logical implication now holds: For any set Ŵ of sentences, I |= Ŵ iff #I ∪ Ŵ is satisfiable.	x-172-5
The perspective obtained through this connection with clas- sical logic is useful when attempting to extend the conventional relational model (e.g., to incorporate so-called incomplete information, as discussed in Chapter 19).	x-172-6
The Extension axioms correspond to the intuition that a tuple $ if it is explicitly included in R by the database instance.	x-173-1
A more general formulation of this intuition is given by the closed world assumption (CWA) [Rei78].	x-173-2
In its most general formulation, the CWA is an inference rule that is used in proof-theoretic contexts.	x-173-3
Given a set # of sentences describing a (possibly nonconventional) database instance, the CWA states that one can infer a negated atom R($ from # using conventional first-order logic].	x-173-4
In the case where # is an extended relational theory this gives no added information, but in other contexts (such as deductive databases) it does.	x-173-5
The CWA is related in spirit to the negation as failure rule of [Cla78].	x-173-6
What is a relation?	x-174-1
Vittorio: You studied that in math a long time ago.	x-175-1
Sergio: It is just a table.	x-176-1
Riccardo: But we have several ways of viewing it.	x-177-1
The specification of structure and constraints is done using a data definition language (DDL), and the specification of manipulation is done using a data manipulation language (DML).	x-178-1
The most prominent structures that have been used for databases to date are graphs in the network, semantic, and object-oriented models; trees in the hierarchical model; and relations in the relational model.	x-178-2
DMLs provide two fundamental capabilities: querying to support the extraction of data from the current database; and updating to support the modification of the database state.	x-179-1
There is a rich theory on the topic of querying relational databases that includes several languages based on widely different paradigms.	x-180-1
This theory is the focus of Parts B, D, and E, and portions of Part F of this book.	x-180-2
The theory of database updates has received considerably less attention and is touched on in Part F.	x-180-3
The term relational model is actually rather vague.	x-181-1
As introduced in Codd’s seminal article, this term refers to a specific data model with relations as data structures, an algebra for specifying queries, and no mechanisms for expressing updates or constraints.	x-181-2
Subsequent articles by Codd introduced a second query language based on the predicate calculus of first-order logic, showed this to be equivalent to the algebra, and introduced the first integrity constraints for the relational model—namely, functional dependencies.	x-182-1
Soon thereafter, researchers in database systems implemented languages based on the algebra and calculus, extended to include update operators and to include practically motivated features such as arithmetic operators, aggregate operators, and sorting capabilities.	x-182-2
Researchers in database theory developed a number of variations on the algebra and calculus with varying expressive power and adapted the paradigm of logic programming to provide a third approach to querying relational databases.	x-182-3
The story of integrity constraints for the relational model is similar: A rich theory of constraints has emerged, and two distinct but equivalent perspectives have been developed that encompass almost all of the constraints that have been investigated formally.	x-182-4
The term relational model has thus come to refer to the broad class of database models that have relations as the data structure and that incorporate some or all of the query capabilities, update capabilities, and integrity constraints 28 mentioned earlier.	x-182-5
In this book we are concerned primarily with the relational model in this broad sense.	x-182-6
Relations are simple data structures.	x-183-1
As a result, it is easy to understand the conceptual underpinnings of the relational model, thus making relational databases accessible to a broad audience of end users.	x-183-2
A second advantage of this simplicity is that clean yet powerful declarative languages can be used to manipulate relations.	x-183-3
By declarative, we mean that a query/program is specified in a high-level manner and that an efficient execution of the program does not have to follow exactly its specification.	x-183-4
Thus the important practical issues of compilation and optimization of queries had to be overcome to make relational databases a reality.	x-183-5
Because of its simplicity, the relational model has provided an excellent framework for the first generation of theoretical research into the properties of databases.	x-184-1
Fundamental aspects of data manipulation and integrity constraints have been exposed and studied in a context in which the peculiarities of the data model itself have relatively little impact.	x-184-2
This research provides a strong foundation for the study of other database models, first because many theoretical issues pertinent to other models can be addressed effectively within the relational model, and second because it provides a variety of tools, techniques, and research directions that can be used to understand the other models more deeply.	x-184-3
In this short chapter, we present formal definitions for the data structure of the relational model.	x-185-1
Theoretical research on the model has grown out of three different perspectives, one corresponding most closely to the natural usage of relations in databases, another stemming from mathematical logic, and the third stemming from logic programming.	x-185-2
Because each of these provides important intuitive and notational benefits, we introduce notation that encompasses the different but equivalent formulations reflecting each of them.	x-185-3
The Structure of the Relational Model	x-186-1
We introduce now some informal terminology to provide the intuition behind the formal definitions that follow.	x-187-1
Each table is called a relation and it has a name (e.g., Movies).	x-187-2
The columns also have names, called attributes (e.g, Title).	x-187-3
Each line in a table is a tuple (or record).	x-187-4
The entries of tuples are taken from sets of constants, called domains, that include, for example, the sets of integers, strings, and Boolean values.	x-187-5
Finally we distinguish between the database schema, which specifies the structure of the database; and the database instance, which specifies its actual content.	x-187-6
This is analogous to the standard distinction between type and value found in programming languages (e.g., an 1 Pariscope is a weekly publication that lists the cultural events occurring in Paris and environs.	x-187-7
The Relational Model Movies Title Director The Trouble with Harry Hitchcock Gwenn The Trouble with Harry Hitchcock Forsythe The Trouble with Harry Hitchcock MacLaine The Trouble with Harry Hitchcock Hitchcock Cries and Whispers Bergman Cries and Whispers Bergman Sylwan Cries and Whispers Bergman Thulin Cries and Whispers Bergman Ullman Location Theater Phone Number Gaumont Opéra Saint André des Arts Le Champo Georges V Les 7 Montparnassiens Pariscope Theater Title Schedule Gaumont Opéra Cries and Whispers Saint André des Arts The Trouble with Harry Georges V Cries and Whispers Les 7 Montparnassiens Cries and Whispers Figure 3.1: The CINEMA database identifier X might have type record A : int, B : bool endrecord and value record A : 5, B : true endrecord).	x-188-1
We now embark on the formal definitions.	x-189-1
We assume that a countably infinite set att of attributes is fixed.	x-189-2
For a technical reason that shall become apparent shortly, we assume that there is a total order ≤att on att.	x-189-3
When a set U of attributes is listed, it is assumed that the elements of U are written according to ≤att unless otherwise specified.	x-189-4
For most of the theoretical development, it suffices to use the same domain of values for all of the attributes.	x-190-1
Thus we now fix a countably infinite set dom (disjoint from att), called the underlying domain.	x-190-2
A constant is an element of dom.	x-190-3
When different attributes should have distinct domains, we assume a mapping Dom on att, where Dom(A) is a set called the domain of A.	x-190-4
We assume a countably infinite set relname of relation names disjoint from the previous sets.	x-191-1
In practice, the structure of a table is given by a relation name and a set of attributes.	x-191-2
To simplify the notation in the theoretical treatment, we now associate a sort (i.e., finite set of attributes) to each relation name.	x-191-3
(An analogous approach is usually taken in logic.)	x-191-4
In particular, we assume that there is a function sort from relname to Pfin(att) (the finitary powerset of att; i.e., the family of finite subsets of att).	x-191-5
It is assumed that sort has the property that for each (possibly empty) finite set U of attributes, sort−1(U ) is infinite.	x-191-6
This allows us to use as many relation names of a given sort as desired.	x-191-7
The sort of a relation name is simply sort(R).	x-191-8
The arity of a relation name R is arity(R) = | sort(R)|.	x-191-9
to indicate that sort(R) = U , or R[n], to indicate that arity(R) = n. A database schema is a nonempty finite set R of relation names.	x-192-1
This might be written R = {R1[U1], .	x-192-2
.	x-192-3
.	x-192-4
, Rn[Un]} to indicate the relation schemas in R.	x-192-5
For example, the database schema CINEMA for the database shown in Fig.	x-193-1
3.1 is defined by CINEMA = { Movies, Location, Pariscope} where relation names Movies, Location, and Pariscope have the following sorts: sort( Movies) sort( Location) = { Theater, Address, Phone Number} sort( Pariscope) = { Theater, Title, Schedule}.	x-193-2
We often omit commas and set brackets in sets of attributes.	x-194-1
For example, we may write sort( Pariscope) = Theater Title Schedule.	x-194-2
The formalism that has emerged for the relational model is somewhat eclectic, because it is intimately connected with several other areas that have their own terminology, such as logic and logic programming.	x-195-1
Because the slightly different formalisms are well entrenched, we do not attempt to replace them with a single, unified notation.	x-195-2
Instead we will allow the coexistence of the different notations; the reader should have no difficulty dealing with the minor variations.	x-195-3
Thus there will be two forks in the road that lead to different but largely equivalent formulations of the relational model.	x-196-1
The first fork in the road to defining the relational model is of a philosophical nature.	x-196-2
Are the attribute names associated with different relation columns important?	x-196-3
Named versus Unnamed Perspectives Under the named perspective, these attributes are viewed as an explicit part of a database schema and may be used (e.g., by query languages and dependencies).	x-197-1
Under the unnamed The Relational Model perspective, the specific attributes in the sort of a relation name are ignored, and only the arity of a relation schema is available (e.g., to query languages).	x-197-2
In the named perspective, it is natural to view tuples as functions.	x-198-1
More precisely, a tuple over a (possibly empty) finite set U of attributes (or over a relation schema R[U ]) is a total mapping u from U to dom.	x-198-2
In this case, the sort of u is U , and it has arity |U |.	x-198-3
Tuples may be written in a linear syntax using angle brackets—for example, A : 5, B : 3.	x-199-1
Suppose that u is a tuple over U .	x-200-1
As usual in mathematics, the value of u on an attribute A in U is denoted u(A).	x-200-2
This is extended so that for V ⊆ U , u[V ] denotes the tuple v over V such that v(A) = u(A) for each A ∈ V (i.e., u[V ] = u|V , the restriction of the function u to V ).	x-200-3
With the unnamed perspective, it is more natural to view a tuple as an element of a Cartesian product.	x-201-1
More precisely, a tuple is an ordered n-tuple (n ≥ 0) of constants (i.e., an element of the Cartesian product domn).	x-201-2
The arity of a tuple is the number of coordinates that it has.	x-201-3
Tuples in this context are also written with angle brackets (e.g., 5, 3).	x-201-4
The ith coordinate of a tuple u is denoted u(i).	x-201-5
If relation name R has arity n, then a tuple over R is a tuple with arity arity(R).	x-201-6
Because of the total order ≤att, there is a natural correspondence between the named and unnamed perspectives.	x-202-1
A tuple A1 : a1, A2 : a2 (defined as a function) can be viewed (assuming A1 ≤att A2) as an ordered tuple with (A1 : a1) as a first component and (A2 : a2) as a second one.	x-202-2
Ignoring the names, this tuple may simply be viewed as the ordered tuple a1, a2.	x-202-3
Conversely, the ordered tuple t = a1, a2 may be interpreted as a function over the set {1, 2} of integers with t (i) = ai for each i.	x-202-4
This correspondence will allow us to blur the distinction between the two perspectives and move freely from one to the other when convenient.	x-202-5
Conventional versus Logic Programming Perspectives We now come to the second fork in the road to defining the relational model.	x-203-1
This fork concerns how relation and database instances are viewed, and it is essentially independent of the perspective taken on tuples.	x-203-2
Under the conventional perspective, a relation or relation instance of (or over) a relation schema R[U ] (or over a finite set U of attributes) is a (possibly empty) finite set I of tuples with sort U .	x-203-3
In this case, I has sort U and arity	x-203-4
Continuing with the conventional perspective, a database instance of database schema R is a mapping I with domain R, such that I(R) is a relation over R for each R ∈ R.	x-204-1
The other perspective for defining instances stems from logic programming.	x-205-1
This perspective is used primarily with the ordered-tuple perspective on tuples, and so we focus on that here.	x-205-2
Let R be a relation with arity n. A fact over R is an expression of the form R(a1, .	x-205-3
.	x-205-4
.	x-205-5
, an), where ai ∈ dom for i ∈ [1, n].	x-205-6
If u = a1, .	x-205-7
.	x-205-8
.	x-205-9
, an, we sometimes write R(u) for R(a1, .	x-205-10
.	x-205-11
.	x-205-12
, an).	x-205-13
Under the logic-programming perspective, a relation ( instance) over R is a finite set of facts over R. For a database schema R, a database instance is a finite set I that is the union of relation instances over R, for R ∈ R. This perspective on instances is convenient when working with languages stemming from logic programming, and it permits us to write database instances in a convenient linear form.	x-205-14
The two perspectives provide alternative ways of describing essentially the same data.	x-206-1
For instance, assuming that sort(R) = AB and sort(S) = A, we have the following four representations of the same database: Named and Conventional I (R) = {f1, f2, f3} f1(A) = a f1(B) = b f2(A) = c f2(B) = b f3(A) = a f3(A) = a I (S) = {g} g(A) = d Unnamed and Conventional I (R) = {a, b, c, b, a, a} I (S) = {d} Named and Logic Programming Unnamed and Logic Programming	x-207-1
Because relations can be viewed as sets, it is natural to consider, given relations of the same sort, the standard set operations union (∪), intersection (∩), and difference (−) and the standard set comparators ⊂, ⊆, =, and =.	x-208-1
With the logic-programming perspective on instances, we may also use these operations and comparators on database instances.	x-208-2
Essentially all topics in the theory of relational database can be studied using a fixed choice for the two forks.	x-209-1
However, there are some cases in which one perspective is much more natural than the other or is technically much more convenient.	x-209-2
For example, in a context in which there is more than one relation, the named perspective permits easy and natural specification of correspondences between columns of different relations whereas the unnamed perspective does not.	x-209-3
As will be seen in Chapter 4, this leads to different but equivalent sets of natural primitive algebra operators for the two perspectives.	x-209-4
A related example concerns those topics that involve the association of distinct domains to different relation columns; again the named perspective is more convenient.	x-209-5
In addition, although relational dependency theory can be developed for the unnamed perspective, the motivation is much more natural when presented in the named perspective.	x-209-6
Thus during the course of this book the choice of perspective during a particular discussion will be motivated primarily by the intuitive or technical convenience offered by one or the other.	x-209-7
In this book, we will need an infinite set var of variables that will be used to range over elements of dom.	x-210-1
We generalize the notion of tuple to permit variables in coordinate positions: a free tuple over U or R[U ] is (under the named perspective) a function u from U to var ∪ dom.	x-210-2
An atom over R is an expression R(e1, .	x-210-3
.	x-210-4
.	x-210-5
, en), where n = arity(R) and The Relational Model ei is term (i.e., ei ∈ var ∪ dom for each i ∈ [1, n]).	x-210-6
Following the terminology of logic and logic programming, we sometimes refer to a fact as a ground atom.	x-210-7
Notation We generally use the following symbols, possibly with subscripts: Constants Variables x, y Sets of variables X, Y Terms e Sets of attributes U, V , W Relation names (schemas) R, S; R[U ], S[V ] Database schemas R, S Tuples t, s Free tuples u, v, w Facts R(a1, .	x-211-1
.	x-211-2
.	x-211-3
, an), R(t) R(e1, .	x-211-4
.	x-211-5
.	x-211-6
, en), R(u) Relation instances I, J Database instances I, J Bibliographic Notes The relational model is founded on mathematical logic (in particular, predicate calculus).	x-211-7
It is one of the rare cases in which substantial theoretical development preceded the implementation of systems.	x-211-8
The first proposal to use predicate calculus as a query language can be traced back to Kuhns [Kuh67].	x-211-9
The relational model itself was introduced by Codd [Cod70].	x-211-10
There are numerous commercial database systems based on the relational model.	x-211-11
They include IBM’s DBZ, [A+76], INGRES [SWKH76], and ORACLE [Ora89], Informix, and Sybase.	x-211-12
Other data models have been proposed and implemented besides the relational model.	x-212-1
The most prominent ones preceding the relational model are the hierarchical and network models.	x-213-1
These and other models are described in the books [Nij76, TL82].	x-213-2
More recently, various models extending the relational model have been proposed.	x-213-3
They include semantic models (see the survey [HK87]) and object-oriented models (see the position paper	x-213-4
Shall we start asking queries?	x-214-1
Sergio: Very simple ones for the time being.	x-215-1
Riccardo: But the system will answer them fast.	x-216-1
Vittorio:	x-217-1
In this chapter we embark on the study of queries for relational databases, a rich topic that spans a good part of this book.	x-218-1
This chapter focuses on a limited but extremely natural and commonly arising class of queries called conjunctive queries.	x-218-2
Five equivalent versions of this query family are presented here: one from each of the calculus and datalog paradigms, two from the algebra paradigm, and a final one that has a more visual form.	x-218-3
In the context of conjunctive queries, the three nonalgebraic versions can be viewed as minor syntactic variants of each other; but these similarities diminish as the languages are generalized to incorporate negation and/or recursion.	x-219-1
This chapter also discusses query composition and its interaction with user views, and it extends conjunctive queries in a straightforward manner to incorporate union (or disjunction).	x-219-2
The conjunctive queries enjoy several desirable properties, including, for example, decidability of equivalence and containment.	x-220-1
These results will be presented in Chapter 6, in which a basic tool, the Homomorphism Theorem, is developed.	x-220-2
Most of these results extend to conjunctive queries with union.	x-220-3
In the formal framework that we have developed in this book, we distinguish between a query, which is a syntactic object, and a query mapping, which is the function defined by a query interpreted under a specified semantics.	x-221-1
However, we often blur these two concepts when the meaning is clear from the context.	x-221-2
In the relational model, query mappings generally have as domain the family of all instances of a specified relation or database schema, called the input schema; and they have as range the family of instances of an output schema, which might be a database schema or a relation schema.	x-221-3
In the latter case, the relation name may be specified as part of the syntax of the query or by the context, or it may be irrelevant to the discussion and thus not specified at all.	x-221-4
We generally say that a query (mapping) is from (or over) its input schema to its output schema.	x-221-5
Finally, two queries q1 and q2 over R are equivalent, denoted q1 ≡ q2, if they have the same output schema and q1(I) = q2(I) for each instance I over R.	x-221-6
This chapter begins with an informal discussion that introduces a family of simple queries and illustrates one approach to expressing them formally.	x-222-1
Three versions of conjunctive queries are then introduced, and all of them have a basis in logic.	x-222-2
Then a brief 37 Conjunctive Queries Who is the director of “Cries and Whispers”?	x-222-3
Which theaters feature “Cries and Whispers”?	x-223-1
What are the address and phone number of the Le Champo?	x-224-1
List the names and addresses of theaters featuring a Bergman film.	x-225-1
Is a film directed by Bergman playing in Paris?	x-226-1
List the pairs of persons such that the first directed the second in a movie, and vice versa.	x-227-1
List the names of directors who have acted in a movie they directed.	x-228-1
List pairs of actors that acted in the same movie.	x-229-1
On any input produce “Apocalypse Now”, “Coppola” as the answer.	x-230-1
Where can I see “Annie Hall” or “Manhattan”?	x-231-1
What are the films with Allen as actor or director?	x-232-1
What films with Allen as actor or director are currently featured at the Concorde?	x-233-1
List all movies that were directed by Hitchcock or that are currently playing at the Rex.	x-234-1
List all actors and director of the movie “Apocalypse Now.” Figure 4.1: Examples of conjunctive queries, some of which require union digression is made to consider query composition and database views.	x-235-1
The algebraic perspectives on conjunctive queries are then given, along with the theorem showing the equivalence of all five approaches to conjunctive queries.	x-235-2
Finally, various forms of union and disjunction are added to the conjunctive queries.	x-235-3
Getting Started To present the intuition of conjunctive queries, consider again the CINEMA database of Chapter 3.	x-236-1
The following correspond to conjunctive queries: Who is the director of “Cries and Whispers”?	x-236-2
Which theaters feature “Cries and Whispers”?	x-237-1
What are the address and phone number of the Le Champo?	x-238-1
These and other queries used in this section are gathered in Fig.	x-239-1
4.1.	x-239-2
Each of the queries just given calls for extracting information from a single relation.	x-239-3
In contrast, queries (4.4) through (4.7) involve more than one relation.	x-239-4
In queries (4.1–4.4 and 4.6–4.9), the database is asked to find values or tuples of values for which a certain pattern of data holds in the database, and in query (4.5) the database is asked whether a certain pattern of data holds.	x-240-1
We shall see that the patterns can be described simply in terms of the existence of tuples that are connected to each other by equality of some of their coordinates.	x-240-2
On the other hand, queries (4.10) through (4.14) cannot be expressed in this manner unless some form of disjunction or union is incorporated.	x-240-3
Example 4.1.1 Consider query (4.4).	x-241-1
Intuitively, we express this query by stating that if there are tuples r1, r2, r3 respectively in relations Movies, Pariscope, Location such that the Director in r1 is “Bergman” then we want the Theater and Address coordinates from tuple r3.	x-241-2
In this formulation we essentially use variables that range over tuples.	x-242-1
Although this is the basis of the so-called ( relational) tuple calculus (see Exercise 5.23 in the next chapter), the focus of most theoretical investigations has been on the domain calculus, which uses variables that range over constants rather than tuples.	x-242-2
This also reflects the convention followed in the predicate calculus of first-order logic.	x-242-3
Thus we reformulate the preceding query as if there are tuples xti, “Bergman”, xac, xth, xti, xs, and xth, xad, xp, respectively, in relations Movies, Pariscope, and Location then include the tuple Theater : xth, Address : xad in the answer, where xti, xac, .	x-242-4
.	x-242-5
.	x-242-6
are variables.	x-242-7
Note that the equalities specified in the first formulation are achieved implicitly in the second formulation through multiple occurrences of variables.	x-242-8
The translation of this into the syntax of rule-based conjunctive queries is now obtained by where ans (for “answer”) is a relation over { Theater, Address}.	x-243-1
The atom to the left of the	x-243-2
The preceding rule may be abbreviated as where _ is used to replace all variables that occur exactly once in the rule.	x-244-1
Such variables are sometimes called anonymous.	x-244-2
In general, a rule-based conjunctive query is a single rule that has the form illustrated in the preceding example.	x-245-1
The semantics associated with rule-based conjunctive queries ensures that their interpretation corresponds to the more informal expressions given in the preceding example.	x-245-2
Rule-based conjunctive queries can be viewed as the basic building block for datalog, a query language based on logic programming that provides an elegant syntax for expressing recursion.	x-245-3
Conjunctive Queries Movies Title Director Bergman Pariscope Theater Title Schedule Location Theater Phone number P._Rex P._1 bd.	x-246-1
Poissonnière Figure 4.2: paradigm later in this chapter, we illustrate it in Fig.	x-246-2
4.2 with a query presented in the syntax of the language Query-By-Example (QBE) (see also Chapter 7).	x-246-3
The identifiers starting with a _ designate variables, and P. indicates what to output.	x-246-4
Following the convention established for QBE, variable names are chosen to reflect typical values that they might take.	x-246-5
Note that the coordinate entries left blank correspond, in terms of the rule given previously, to distinct variables that occur exactly once in the body and do not occur in the head (i.e., to anonymous variables).	x-246-6
The third version of conjunctive queries studied in this chapter is a restriction of the predicate calculus; as will be seen, the term conjunctive query stems from this version.	x-247-1
The fourth and fifth versions are algebraic in nature, one for the unnamed perspective and the other for the named perspective.	x-247-2
Logic-Based Perspectives In this section we introduce and study three versions of the conjunctive queries, all stemming from mathematical logic.	x-248-1
After showing the equivalence of the three resulting query languages, we extend them by incorporating a capability to express equality explicity, thereby yielding a slightly more powerful family of languages.	x-248-2
Rule-Based Conjunctive Queries The rule-based version of conjunctive queries is now presented formally.	x-249-1
As will be seen later, the rule-based paradigm is well suited for specifying queries from database schemas to database schemas.	x-249-2
However, to facilitate the comparison between the different variants of the conjunctive queries, we focus first on rule-based queries whose targets are relation schemas.	x-249-3
We adopt the convention of using the name ans to refer to the name of the target relation if the name itself is unimportant (as is often the case with relational queries).	x-249-4
Definition 4.2.1 Let R be a database schema.	x-250-1
A rule-based conjunctive query over R is an expression of the form where n ≥ 0, R1, .	x-250-2
.	x-250-3
.	x-250-4
, Rn are relation names in R; ans is a relation name not in R; and u, u1, .	x-250-5
.	x-250-6
.	x-250-7
, un are free tuples (i.e., may use either variables or constants).	x-250-8
Recall that if v = x1, .	x-250-9
.	x-250-10
.	x-250-11
, xm, then ‘R(v)’ is a shorthand for ‘R(x1, .	x-250-12
.	x-250-13
.	x-250-14
, xm)’.	x-250-15
In addition, the tuples u, u1, .	x-250-16
.	x-250-17
.	x-250-18
, un must have the appropriate arities (i.e., u must have arity of ans, and ui must have the arity of Ri for each i ∈ [1, n]).	x-250-19
Finally, each variable occurring in u must also occur at least once in u1, .	x-250-20
.	x-250-21
.	x-250-22
, un.	x-250-23
The set of variables occurring in q is denoted var(q).	x-250-24
Rule-based conjunctive queries are often more simply called rules.	x-251-1
In the preceding rule, the subexpression R1(u1), .	x-251-2
.	x-251-3
.	x-251-4
, Rn(un) is the body of the rule, and ‘ ans(u)’ is the head.	x-251-5
The rule here is required by the definition to be range restricted (i.e., each variable occurring in the head must also occur in the body).	x-251-6
Although this restriction is followed in most of the languages based on the use of rules, it will be relaxed in Chapter 18.	x-251-7
Intuitively, a rule may be thought of as a tool for deducing new facts.	x-252-1
If one can find values for the variables of the rule such that the body holds, then one may deduce the head fact.	x-252-2
This concept of “values for the variables in the rules” is captured by the notion of “valuation.” Formally, given a finite subset V of var, a valuation ν over V is a total function ν from V to the set dom of constants.	x-252-3
This is extended to be identity on dom and then extended to map free tuples to tuples in the natural fashion.	x-252-4
We now define the semantics for rule-based conjunctive queries.	x-253-1
Let q be the query given earlier, and let I be an instance of R. The image of I under q is q(I) = {ν(u) | ν is a valuation over var(q) and ν(ui) ∈ I(Ri), for each i ∈ [1, n]}.	x-253-2
The active domain of a database instance I, denoted adom(I), is the set of all constants occurring in I, and the active domain adom(I ) of relation instance I is defined analogously.	x-254-1
In addition, the set of constants occurring in a query q is denoted adom(q).	x-255-1
We use adom(q, I) as an abbreviation for adom(q) ∪ adom(I).	x-255-2
Let q be a rule and I an input instance for q.	x-256-1
Because q is range restricted, it is easily verified that adom(q(I)) ⊆ adom(q, I) (see Exercise 4.2).	x-256-2
In other words, q(I) contains only constants occurring in q or in I.	x-256-3
In particular, q(I) is finite, and so it is an instance.	x-256-4
Such improvements are considered in Chapter 6.	x-257-1
Returning to the intuition, under the usual perspective a fundamental difference between the head and body of a rule R0 ← R1, .	x-258-1
.	x-258-2
.	x-258-3
, Rn is that body relations are viewed as being stored, whereas the head relation is not.	x-258-4
Thus, referring to the rule given earlier, the values of relations R1, .	x-258-5
.	x-258-6
.	x-258-7
, Rn are known because they are provided by the input instance Conjunctive Queries I.	x-258-8
In other words, we are given the extension of R1, .	x-258-9
.	x-258-10
.	x-258-11
, Rn; for this reason they are called extensional relations.	x-258-12
In contrast, relation R0 is not stored and its value is computed on request by the query; the rule gives only the “intension” or definition of R0.	x-258-13
For this reason we refer to R0 as an intensional relation.	x-258-14
In some cases, the database instance associated with R1, .	x-258-15
.	x-258-16
.	x-258-17
, Rn is called the extensional database (edb), and the rule itself is referred to as the intensional database (idb).	x-258-18
Also, the defined relation is sometimes referred to as an idb relation.	x-258-19
We now present the first theoretical property of conjunctive queries.	x-259-1
A query q over R is monotonic if for each I, J over R, I ⊆ J implies that q(I) ⊆ q(J).	x-259-2
A query q is satisfiable if there is some input I such that q(I) is nonempty.	x-259-3
Proposition 4.2.2 Conjunctive queries are monotonic and satisfiable.	x-260-1
Proof Let q be the rule-based conjunctive query	x-261-1
For monotonicity, let I ⊆ J, and suppose that t ∈ q(I).	x-262-1
Then for some valuation ν over var(q), ν(ui) ∈ I(Ri) for each i ∈ [1, n], and t = ν(u).	x-262-2
Because I ⊆ J, ν(ui) ∈ J(Ri) for each i, and so t ∈ q(J).	x-262-3
For satisfiability, let d be the set of constants occurring in q, and let a ∈ dom be new.	x-263-1
Define I over the relation schemas R of the rule body so that I(R) = (d ∪ {a}) arity(R)	x-264-1
The monotonicity of the conjunctive queries points to limitations in their expressive power.	x-265-1
Indeed, one can easily exhibit queries that are nonmonotonic and therefore not conjunctive queries.	x-265-2
For instance, the query “Which theaters in New York show only Woody Allen films?” is nonmonotonic.	x-265-3
We close this subsection by indicating how rule-based conjunctive queries can be used to express yes-no queries.	x-266-1
For example, consider the query Is there a film directed by Bergman playing in Paris?	x-266-2
To provide an answer, we assume that relation name ans has arity 0.	x-267-1
Then applying the rule ans() ← Movies(x, “Bergman”, y), Pariscope(z, x, w) returns the relation {} if the answer is yes, and returns {} if the answer is no.	x-267-2
Tableau Queries If we blur the difference between a variable and a constant, the body of a conjunctive query can be seen as an instance.	x-268-1
This leads to a formulation of conjunctive queries called	x-268-2
Definition 4.2.3 The notion of tableau over a schema R (R) is defined exactly as was the notion of instance over R (R), except that both variables and constants may occur.	x-269-1
A tableau query is simply a pair (T, u) [or (T , u)] where T is a tableau and each variable in u also occurs in T. The free tuple u is called the summary of the tableau query.	x-269-2
The summary tuple u in a tableau query (T, u) represents the tuples included in the answer to the query.	x-270-1
Thus the answer consists of all tuples u for which the pattern described by T is found in the database.	x-270-2
Example 4.2.4 Let T be the tableau Movies Title Director xti xac Pariscope Theater Title Schedule xth xti xs Location Theater Phone Number xth xad xp The tableau query (T, Theater : xth, Address : xad) expresses query (4.4).	x-271-1
If the unnamed perspective on tuples is used, then the names of the attributes are not included in u.	x-271-2
The notion of valuation is extended in the natural fashion to map tableaux1 to instances.	x-272-1
An embedding of tableau T into instance I is a valuation ν for the variables occurring in T such that ν(T) ⊆ I.	x-272-2
The semantics for tableau queries is essentially the same as for rule-based conjunctive queries: The output of (T, u) on input I consists of all tuples ν(u) where ν is an embedding of T into I.	x-272-3
Conjunctive Queries Chapter 8), which provides an elegant characterization of two conjunctive queries yielding identical results when the inputs satisfy certain dependencies.	x-273-1
Conjunctive Calculus The third formalism for expressing conjunctive queries stems from predicate calculus.	x-274-1
(A review of predicate calculus is provided in Chapter 2, but the presentation of the calculus in this and the following chapter is self-contained.)	x-274-2
We begin by presenting conjunctive calculus queries that can be viewed as syntactic variants of rule-based conjunctive queries.	x-275-1
They involve simple use of conjunction and existential quantification.	x-275-2
As will be seen, the full conjunctive calculus, defined later, allows unrestricted use of conjunction and existential quantification.	x-275-3
This provides more flexibility in the syntax but, as will be seen, does not increase expressive power.	x-275-4
Consider the conjunctive query	x-276-1
where x1, .	x-277-1
.	x-277-2
.	x-277-3
, xk are all the variables occurring in the body and not the head.	x-277-4
The symbol ∧ denotes conjunction (i.e., “and”), and ∃ denotes existential quantification (intuitively,	x-277-5
Example 4.2.5 In the calculus paradigm, query (4.4) can be expressed as follows: Pariscope(xth, xti, xs) Location(xth, xad, xp))}.	x-278-1
Note that some but not all of the existentially quantified variables play the role of anonymous variables, in the sense mentioned in Example 4.1.1.	x-279-1
The syntax used here can be viewed as a hybrid of the usual set-theoretic notation, used to indicate the form of the query output, and predicate calculus, used to indicate what should be included in the output.	x-280-1
As discussed in Chapter 2, the semantics associated with calculus formulas is a restricted version of the conventional semantics found in first-order logic.	x-280-2
We now turn to the formal definition of the syntax and semantics of the (full) conjunctive calculus.	x-281-1
Definition 4.2.6 Let R be a database schema.	x-282-1
A ( well-formed) formula over R for the conjunctive calculus is an expression having one of the following forms: (a) an atom over R;	x-282-2
In formulas we permit the abbreviation of ∃x1 .	x-283-1
.	x-283-2
.	x-283-3
∃xn by ∃x1, .	x-283-4
.	x-283-5
.	x-283-6
, xn.	x-283-7
The usual notion of “free” and “bound” occurrences of variables is now defined.	x-284-1
An occurrence of variable x in formula ϕ is free if	x-284-2
Definition 4.2.7 where ϕ is a conjunctive calculus formula, e1, .	x-285-1
.	x-285-2
.	x-285-3
, em is a free tuple, and the set of variables occurring in e1, .	x-285-4
.	x-285-5
.	x-285-6
, em is exactly free(ϕ).	x-285-7
If the named perspective is being used, then attributes can be associated with output tuples by specifying a relation name R of arity m. The notation can be used to indicate the sort of the output explicitly.	x-285-8
To define the semantics of conjunctive calculus queries, it is convenient to introduce some notation.	x-286-1
Recall that for finite set V ⊂ var, a valuation over V is a total function ν from V to dom.	x-286-2
This valuation will sometimes be viewed as a syntactic expression of the form Conjunctive Queries where x1, .	x-286-3
.	x-286-4
.	x-286-5
, xn is a listing of V and ai = ν(xi) for each i ∈ [1, n].	x-286-6
This may also be interpreted as a set.	x-286-7
For example, if x is not in the domain of ν and c ∈ dom, then ν ∪ {x/c} denotes the valuation with domain V ∪ {x} that is identical to ν on V and maps x to c.	x-286-8
Now let R be a database schema, ϕ a conjunctive calculus formula over R, and ν a valuation over free(ϕ).	x-287-1
Then I satisfies ϕ under ν, denoted I |= ϕ[ν], if (a) ϕ = R(u) is an atom and ν(u) ∈ I(R); or	x-287-2
Finally, let q = {e1, .	x-288-1
.	x-288-2
.	x-288-3
, em | ϕ} be a conjunctive calculus query over R. For an instance I over R, the image of I under q is q(I) = {ν(e1, .	x-288-4
.	x-288-5
.	x-288-6
, en) | I |= ϕ[ν] and ν is a valuation over free(ϕ)}.	x-288-7
The active domain of a formula ϕ, denoted adom(ϕ), is the set of constants occurring in ϕ; and as with queries q, we use adom(ϕ, I) to abbreviate adom(ϕ) ∪ adom(I).	x-289-1
An easy induction on conjunctive calculus formulas shows that if I |= ϕ[ν], then the range of ν is contained in adom(I) (see Exercise 4.3).	x-289-2
This implies, in turn, that to evaluate a conjunctive calculus query, one need only consider valuations with range contained in adom(ϕ, I) and, hence, only a finite number of them.	x-289-3
This pleasant state of affairs will no longer hold when disjunction or negation is incorporated into the calculus (see Section 4.5 and Chapter 5).	x-289-4
Conjunctive calculus formulas ϕ and ψ over R are equivalent if they have the same free variables and, for each I over R and valuation ν over free(ϕ) = free(ψ), I |= ϕ[ν] iff I |= ψ[ν].	x-290-1
It is easily verified that if ϕ and ψ are equivalent, and if 9′ is the result of replacing an occurrence of ϕ by ψ in conjunctive calculus formula 9, then 9 and 9′ are equivalent (see Exercise 4.4).	x-290-2
It is easily verified that for all conjunctive calculus formulas ϕ, ψ, and ξ , (ϕ ∧ ψ) is equivalent to (ψ ∧ ϕ), and (ϕ ∧ (ψ ∧ ξ )) is equivalent to ((ϕ ∧ ψ) ∧ ξ ).	x-291-1
For this reason, we may view conjunction as a polyadic connective rather than just binary.	x-291-2
We next show that conjunctive calculus queries, which allow unrestricted nesting of ∃ and ∧, are no more powerful than the simple conjunctive queries first exhibited, which correspond straightforwardly to rules.	x-292-1
Thus the simpler conjunctive queries provide a normal form for the full conjunctive calculus.	x-292-2
Formally, a conjunctive calculus query q = {u | ϕ} is in normal form if ϕ has the form	x-292-3
Consider now the two rewrite (or transformation) rules for conjunctive calculus queries: Variable substitution: replace subformula	x-293-1
if y does not occur in ψ, where ψx denotes the formula obtained by replacing all free y occurrences of x by y in ψ.	x-294-1
Merge-exists: replace subformula	x-295-1
It is easily verified (see Exercise 4.4) that (1) application of these transformation rules to a conjunctive calculus formula yields an equivalent formula, and (2) these rules can be used to transform any conjunctive calculus formula into an equivalent formula in normal form.	x-296-1
It follows that: Lemma 4.2.8 Each conjunctive calculus query is equivalent to a conjunctive calculus query in normal form.	x-297-1
We now introduce formal notation for comparing the expressive power of query languages.	x-298-1
Let Q1 and Q2 be two query languages (with associated semantics).	x-298-2
Then Q1 is dominated by Q2 (or, Q1 is weaker than Q2), denoted Q1 ⊑ Q2, if for each query q1 in Q1 there is a query q2 in Q2 such that q1 ≡ q2.	x-298-3
Q1 and Q2 are equivalent, denoted Q1 ≡ Q2, if Q1 ⊑ Q2 and Q2 ⊑ Q1.	x-298-4
Because of the close correspondence between rule-based conjunctive queries, tableau queries, and conjunctive calculus queries in normal form, the following is easily verified (see Exercise 4.15).	x-299-1
Proposition 4.2.9 The rule-based conjunctive queries, the tableau queries, and the conjunctive calculus are equivalent.	x-300-1
Some of these results will be surprising because of the high contrast between the languages.	x-301-1
Incorporating Equality We close this section by considering a simple variation of the conjunctive queries presented earlier, obtained by adding the capability of explicitly expressing equality between variables and/or constants.	x-302-1
For example, query (4.4) can be expressed as ans(xth, xad) ← Movies(xti, xd, xac), xd = “Bergman”, Pariscope(xth, xti, xs), Location(xth, xad, xp)	x-302-2
Conjunctive Queries It would appear that explicit equalities like the foregoing can be expressed by conjunctive queries without equalities by using multiple occurrences of the same variable or constant.	x-303-1
Although this is basically true, two problems arise.	x-303-2
First, unrestricted rules with equality may yield infinite answers.	x-303-3
For example, in the rule y and z are not tied to relation R, and there are infinitely many valuations satisfying the body of the rule.	x-303-4
To ensure finite answers, it is necessary to introduce an appropriate notion of range restriction.	x-303-5
Informally, an unrestricted rule with equality is range restricted if the equalities require that each variable in the body be equal to some constant or some variable occurring in an atom R(ui); Exercise 4.5 explores the notion of range restriction in more detail.	x-303-6
A rule-based conjunctive query with equality is a range-restricted rule with equality.	x-303-7
The equalities present in this query require that a = b, which is impossible.	x-304-1
Thus there is no valuation satisfying the body of the rule, and the query yields the empty relation on all inputs.	x-304-2
We use q∅:R,R (or q∅ if R and R are understood) to denote the query that maps all inputs over R to the empty relation over R. Finally, note that one can easily check if the equalities in a conjunctive query with equality are unsatisfiable (and hence if the query is equivalent to q∅).	x-304-3
This is done by computing the transitive closure of the equalities in the query and checking that no two distinct constants are required to be equal.	x-304-4
Each satisfiable rule with equality is equivalent to a rule without equality (see Exercise 4.5c).	x-304-5
One can incorporate equality into tableau queries in a similar manner by adding separately a set of required equalities.	x-305-1
Once again, no expressive power is gained if the query is satisfiable.	x-305-2
Incorporating equality into the conjunctive calculus is considered in Exercise 4.6.	x-305-3
Query Composition and Views We now present a digression that introduces the important notion of query composition and describe its relationship to database views.	x-306-1
A main result here is that the rule-based conjunctive queries with equality are closed under composition.	x-306-2
Consider a database R = {R1, .	x-307-1
.	x-307-2
.	x-307-3
, Rn}.	x-307-4
Suppose that we have a query q (in any of the preceding formalisms).	x-307-5
Conceptually, this can be used to define a relation with new relation name S1, which can be used in subsequent queries as any ordinary relation from R. In particular, we can use S1 in the definition of a new relation S2, and so on.	x-307-6
In this context, we could call each of S1, S2, .	x-307-7
.	x-307-8
.	x-307-9
intensional (in contrast with the extensional relations of R).	x-307-10
This perspective on query composition is expressed most conveniently within the rule- based paradigm.	x-308-1
Specifically, a conjunctive query program (with or without equality) is a sequence P of rules having the form S1(u1) ← body 1 S2(u2) ← body 2	x-308-2
Sm(um) ← body m, where each Si is distinct and not in R; and for each i ∈ [1, m], the only relation names that may occur in body i are R1, .	x-309-1
.	x-309-2
.	x-309-3
, Rn and S1, .	x-309-4
.	x-309-5
.	x-309-6
, Si−1.	x-309-7
An instance I over R and the program P can be viewed as defining values for all of S1, .	x-309-8
.	x-309-9
.	x-309-10
, Sm in the following way: For each i ∈ [1, m], [P (I)](Si) = qi([P (I)]), where qi is the ith rule and defines relation Si in terms of I and the previous Sj ’s.	x-309-11
If P is viewed as defining a single output relation, then this output is [P (I)](Sm).	x-309-12
Analogous to rule-based conjunctive queries, the relations in R	x-309-13
Example 4.3.1 Let R = {Q, R} and consider the conjunctive query program S1(x, z) ← Q(x, y), R(y, z, w) S2(x, y, z) ← S1(x, w), R(w, y, v), S1(v, z) S3(x, z) ← S2(x, u, v), Q(v, z).	x-310-1
Figure 4.3 shows an example instance I for R and the values that are associated to S1, S2, S3 by P (I).	x-311-1
It is easily verified that the effect of the first two rules of P on S2 is equivalent to the effect of the rule S2(x, y, z) ← Q(x1, y1), R(y1, z1, w1), x = x1, w = z1, R(w, y, v), Q(x2, y2), R(y2, z2, w2), v = x2, z = z2.	x-312-1
S2(x, y, z) ← Q(x, y1), R(y1, w, w1), R(w, y, v), Q(v, y2), R(y2, z, w2).	x-313-1
Note how variables are renamed to prevent undesired “cross-talk” between the different rule bodies that are combined to form this rule.	x-314-1
The effect of P on S3 can also be expressed using a single rule without equality (see Exercise 4.7).	x-314-2
It is straightforward to verify that if a permutation P ′ of P (i.e., a listing of the elements of P in a possibly different order) satisfies the restriction that relation names in a rule body must be in a previous rule head, then P ′ will define the same mapping as P .	x-315-1
This kind of consideration will arise in a richer context when stratified negation is considered in Chapter 15.	x-315-2
Conjunctive Queries Q R S1 S2 S3 Figure 4.3: Example 4.3.2 Consider the following program P : T (a, x) ← R(x) S(x) ← T (b, x).	x-316-1
Clearly, P always defines the empty relation S, so it is not equivalent to any rule-based conjunctive query without equality.	x-317-1
Intuitively, the use of the constants a and b in P masks the use of equalities, which in this case are contradictory and yield an unsatisfiable query.	x-317-2
Based on the previous examples, the following is easily verified (see Exercise 4.7).	x-318-1
Theorem 4.3.3 (Closure under Composition) If conjunctive query program P defines final relation S, then there is a conjunctive query q, possibly with equality, such that on all input instances I, q(I) = [P (I)](S).	x-319-1
Furthermore, if P is satisfiable, then q can be expressed without equality.	x-319-2
The notion of programs is based on the rule-based formalism of the conjunctive queries.	x-320-1
In the other versions introduced previously and later in this chapter, the notation does not conveniently include a mechanism for specifying names for the output of intermediate queries.	x-320-2
For the other formalisms we use a slightly more elaborate notation that permits the specification of these names.	x-320-3
In particular, all of the formalisms are compatible with a functional, purely expression-based paradigm: let S1 = q1 in let S2 = q2 in	x-320-4
let Sm−1 = qm−1 in qm S1 := q1; S2 := q2;	x-321-1
Sm−1 := qm−1; Sm := qm.	x-322-1
It is clear from Proposition 4.2.9 and Theorem 4.3.3 that the conjunctive calculus and tableau queries with equality are both closed under composition.	x-323-1
Composition and User Views Recall that the top level of the three-level architecture for databases (see Chapter 1) consists of user views (i.e., versions of the data that are restructured and possibly restricted images of the database as represented at the middle level).	x-324-1
In many cases these views are specified as queries (or query programs).	x-324-2
These may be materialized (i.e., a physical copy of the view is stored and maintained) or virtual (i.e., relevant information about the view is computed as needed).	x-324-3
In the latter case, queries against the view generate composed queries against the underlying database, as illustrated by the following example.	x-324-4
Example 4.3.4 Consider the view over schema { Marilyn, Champo-info} defined by the following two rules: Marilyn(xt) ← Movies(xt, xd, “Monroe”) Champo- info(xt, xs, xp) ← Pariscope(“Le Champo”, xt, xs), Location(“Le Champo”, xa, xp).	x-325-1
The conjunctive query “What titles in Marilyn are featured at the Le Champo at 21:00?” can be expressed against the view as	x-326-1
Pariscope(“Le Champo”, xt, “21:00”) Location(“Le Champo”, xa, xp).	x-327-1
Conjunctive Queries Marilyn := {xt | ∃xd( Movies(xt, xd, “Monroe”))}; Champo- info := {xt, xs, xp | ∃xa( Location(“Le Champo”, xt, xs)	x-328-1
This example illustrates the case in which a query is evaluated over a single view; evaluation of the query involves a two-layer composition of queries.	x-329-1
If a series of nested views is defined, then query evaluation can involve query compositions having two or more layers.	x-329-2
The use of algebra operators provides a distinctly different perspective on the conjunctive queries.	x-330-1
There are two distinct algebras associated with the conjunctive queries, and they stem, respectively, from the named, ordered-tuple perspective and the unnamed, function-based perspective.	x-330-2
After presenting the two algebras, their equivalence with the conjunctive queries is discussed.	x-330-3
The Unnamed Perspective: The SPC Algebra The algebraic paradigm for relational queries is based on a family of unary and binary operators on relation instances.	x-331-1
Although their application must satisfy some typing constraints, they are polymorphic in the sense that each of these operators can be applied to instances of an infinite number of arities or sorts.	x-331-2
For example, as suggested in Chapter 3, the union operator can take as input any two relation instances having the same sort.	x-331-3
Three primitive algebra operators form the unnamed conjunctive algebra: selection, projection, and cross-product (or Cartesian product).	x-332-1
This algebra is more often referred to as the SPC algebra, based on the first letters of the three operators that form it.	x-332-2
(This convention will be used to specify other algebras as well.)	x-332-3
An example is given before the formal definition of these operators.	x-332-4
Example 4.4.1 We show how query (4.4) can be built up using the three primitive operators.	x-333-1
First we use selection to extract the tuples of Movies that have Bergman as director.	x-333-2
I1 := σ2=“Bergman”( Movies) Next a family of “wide” (six columns wide, in fact) tuples is created by taking the cross-product of I1 and Pariscope.	x-334-1
I2 := I1 × Pariscope	x-335-1
I3 := σ1=5(I2) In effect, the cross-product followed by this selection finds a matching of tuples from I1	x-336-1
I4 := π4(I3) Finally, this is paired with Location and projected on the Theater and Address columns to yield the answer.	x-337-1
I5 := π2,3(σ1=2(I4 × Location)) The development just given uses SPC expressions in the context of a simple imperative language with assignment.	x-338-1
In the pure SPC algebra, this query is expressed as π2,3(σ1=2(π4(σ1=5(σ2=“Bergman”( Movies) × Pariscope)) × Location)).	x-338-2
This corresponds closely to the conjunctive calculus query of Example 4.2.5.	x-339-1
Their actual implementation is usually quite different from the original form of the query, as will be discussed in Section 6.1.	x-340-1
We now formally define the three operators forming the SPC algebra.	x-341-1
Selection: This can be viewed as a “horizontal” operator.	x-342-1
The two primitive forms are σj=a and σj=k, where j, k are positive integers and a ∈ dom.	x-342-2
[In practice, we usually surround constants with quotes (“ ”).]	x-342-3
The operator σj=a takes as input any relation instance I with arity ≥ j and returns as output an instance of the same arity.	x-342-4
In particular,	x-342-5
The operator σj=k for positive integers j, k is defined analogously for inputs with arity	x-343-1
Conjunctive Queries Projection: This “vertical” operator can be used to delete and/or permute columns of a relation.	x-344-1
The general form of this operator is πj empty sequence of positive integers (the empty sequence is written [ ]), possibly with repeats.	x-344-2
This operator takes as input any relation instance with arity ≥ max{j1, .	x-344-3
.	x-344-4
.	x-344-5
, jn}	x-344-6
Cross-product ( or Cartesian product) : This operator provides the capability for combining relations.	x-345-1
It takes as inputs a pair of relations having arbitrary arities n and m and returns a relation with arity n + m. In particular, if arity(I ) = n and arity(J ) = m, then I × J = {t (1), .	x-345-2
.	x-345-3
.	x-345-4
, t (n), s(1), .	x-345-5
.	x-345-6
.	x-345-7
, s(m) | t ∈ I and s ∈ J }.	x-345-8
Cross-product is associative and noncommutative and has the nonempty 0-ary relation	x-346-1
We extend the cross-product operator to tuples in the natural fashion—that is u × v is a tuple with arity = arity(u) + arity(v).	x-347-1
The SPC algebra is the family of well-formed expressions containing relation names and one-element unary constants and closed under the application of the selection, projection, and cross-product operators just defined.	x-348-1
Each expression is considered to be defined over a given database schema and has an associated output arity.	x-348-2
We now give the formal, inductive definition.	x-348-3
Let R be a database schema.	x-349-1
The base SPC ( algebra) queries and output arities are Input relation: Expression R; with arity equal to arity(R).	x-349-2
Unary singleton constant: Expression {a}, where a ∈ dom; with arity equal to 1.	x-350-1
The family of SPC ( algebra) queries contains all base SPC queries and, for SPC queries q1, q2 with arities α1, α2, respectively, Selection: σj=a(q1) and σj=k(q1) whenever j, k ≤ α1 and a ∈ dom; these have arity α1.	x-351-1
Projection: πj	x-352-1
Cross product: q1 × q2; this has arity α1 + α2.	x-353-1
In practice, we sometimes use brackets to surround algebraic queries, such as [R×	x-354-1
The semantics of these queries is defined in the natural manner (see Exercise 4.8).	x-355-1
The SPC algebra includes unsatisfiable queries, such as σ1=a(σ1=b(R)), where arity(R) ≥ 1 and a = b.	x-356-1
This is equivalent to q∅.	x-356-2
Before leaving SPC algebra, we mention three operators that can be simulated by the primitive ones.	x-357-1
The first is intersection (∩), which is easily simulated (see Exercise 4.28).	x-357-2
The other two operators involve generalizations of the selection and cross-product operators.	x-358-1
The resulting algebra is called the generalized SPC algebra.	x-358-2
We shall introduce a normal form for generalized SPC algebra expressions.	x-358-3
The first operator is a generalization of selection to permit the specification of multiple conditions.	x-359-1
A positive conjunctive selection formula is a conjunction F = γ1 ∧ · · · ∧ γn (n ≥ 1), where each conjunct γi has the form j = a or j = k for positive integers j, k and a ∈ dom; and a positive conjunctive selection operator is an expression of the form σF , where F is a positive conjunctive selection formula.	x-359-2
The intended typing and semantics for these operators is clear, as is the fact that they can be simulated by a composition of selections as defined earlier.	x-359-3
The second operator, called equi-join, is a binary operator that combines cross-product and selection.	x-360-1
A (well-formed) equi-join operator is an expression of the form ⊲⊳F where F = γ1 ∧ · · · ∧ γn (n ≥ 1) is a conjunction such that each conjunct γi has the form j = k.	x-360-2
Given an equi-join expression I ⊲⊳F J , let F ′ be the result of replacing each condition j = k in F by j = arity(I ) + k. Then the semantics of I ⊲⊳F J is given by σF ′(I × J ).	x-361-1
As with cross-product, equi-join is also defined for pairs of tuples, with an undefined output if the tuples do not satisfy the conditions specified.	x-361-2
We now develop a normal form for SPC algebra.	x-362-1
We stress that this normal form is useful for theoretical purposes and, in general, represents a costly way to compute the answer of a given query (see Chapter 6).	x-362-2
where n ≥ 0; m ≥ 0; a1, .	x-363-1
.	x-363-2
.	x-363-3
, am ∈ dom; {1, .	x-363-4
.	x-363-5
.	x-363-6
, m} ⊆ {j1, .	x-363-7
.	x-363-8
.	x-363-9
, jn}; R1, .	x-363-10
.	x-363-11
.	x-363-12
, Rk are relation names (repeats permitted); and F is a positive conjunctive selection formula.	x-363-13
Proposition 4.4.2 For each (generalized) SPC query q there is a generalized SPC query q′ in normal form such that q ≡ q′.	x-364-1
The proof of this proposition (see Exercise 4.12) is based on repeated application of the following eight equivalence-preserving SPC algebra rewrite rules (or transformations).	x-365-1
Merge-select: replace σF (σF ′(q)) by σF ∧F ′(q).	x-366-1
Merge-project: replace π$(π (q)) by π (q), where l for each term l j i = kji i in $ l.	x-367-1
Push-select-through-project: replace σF (π$(q)) by π (σ j F ′(q )), where F ′ is obtained from F by replacing all coordinate values i by ji.	x-368-1
Conjunctive Queries Push-select-through-singleton: replace σ1=j (a × q) by a × σ(j−1)=a(q).	x-369-1
Commute-cross: replace (q × q′) by π$j $j′(q′ × q), where $j = arity(q′) + 1, .	x-370-1
.	x-370-2
.	x-370-3
, arity(q′) + j ′ = 1, .	x-370-4
.	x-370-5
.	x-370-6
, arity(q′).	x-370-7
Push-cross-through-select: replace (σF (q) × q′) by σF (q × q′), and replace (q × σF (q′)) by σF′(q × q′), where F ′ is obtained from F by replacing all coordinate values i by i + arity(q).	x-371-1
Push-cross-through-project: replace (π$(q) × q′) by π (q × q′), and replace (q × π (q′)) j by π $j′(q × q′), where $j′ is obtained from $j by replacing all coordinate values i by i + arity(q).	x-372-1
For a set S of rewrite rules and algebra expressions q, q′, write q →S q′, or simply q → q′ if S is understood from the context, if q′ is the result of replacing a subexpression of q according to one of the rules in S. Let ∗ of →S.	x-373-1
It is easily verified that the foregoing set of rewrite rules is sound and that for each SPC query q there is a normal form SPC query q′ such that q′ is in normal form, and q ∗	x-374-1
In Section 6.1, we describe an approach to optimizing the evaluation of conjunctive queries using rewrite rules.	x-375-1
For example, in that context, the merge-select and merge-project transformations are helpful, as are the inverses of the push-cross-through-select and push-cross-through-project.	x-375-2
Finally, note that an SPC query may require, as the result of transitivity, the equality of two distinct constants.	x-376-1
Thus there are unsatisfiable SPC queries equivalent to q∅.	x-376-2
This is analogous to the logic-based conjunctive queries with equality.	x-376-3
It is clear, using the normal form, that one can check whether an SPC query is q∅ by examining the selection formula F .	x-376-4
The set of SPC queries that are not equivalent to q∅ forms the satisfiable SPC algebra.	x-376-5
The Named Perspective: The SPJR Algebra In Example 4.4.1, the relation I3 was constructed using selection and cross-product by the expression σ1=5(I1 × Pariscope).	x-377-1
As is often the case, the columns used in this selection are labeled by the same attribute.	x-377-2
In the context of the named perspective on tuples, this suggests a natural variant of the cross-product operator (and of the equi-join operator) that is called natural join and is denoted by ⊲⊳.	x-377-3
Informally, the natural join requires the tuples that are concatenated to agree on the common attributes.	x-377-4
Example 4.4.3 The natural join of Movies and Pariscope is Movies ⊲⊳ Pariscope for some v ∈ Movies and w ∈ Pariscope, u[ Title Director Actor] = v and u[ Theater Title Schedule] = w}	x-378-1
List pairs of actors that acted in the same movie.	x-379-1
To answer this, one would like to join the Movies relation with itself but matching only on the Title column.	x-380-1
This will be achieved by first creating a copy Movies′ of Movies in which the attribute Director has been renamed to Director′ and Actor to Actor′; joining this with Movies; and finally projecting onto the Actor and Actor′ columns.	x-380-2
Renaming is also needed for query (4.6) (see Exercise 4.11).	x-380-3
The named conjunctive algebra has four primitive operators: selection, essentially as before; projection, now with repeats not permitted; ( natural) join; and renaming.	x-381-1
It is thus referred to as the SPJR algebra.	x-381-2
As with the SPC algebra, we define the individual operators and then indicate how they are combined to form a typed, polymorphic algebra.	x-381-3
In each case, we indicate the sorts of input and output.	x-381-4
If a relation name is needed for the output, then it is assumed to be chosen to have the correct sort.	x-381-5
Selection: The selection operators have the form σA=a and σA=B, where A, B ∈ att and a ∈ dom.	x-382-1
These operators apply to any instance I with A ∈ sort(I ) [respectively, A, B ∈ sort(I )] and are defined in analogy to the unnamed selection, yielding an output with the same sort as the input.	x-382-2
Projection: The projection operator has the form πA	x-383-1
Conjunctive Queries W , respectively, and produces an output with sort equal to V ∪ W .	x-384-1
In particular, I ⊲⊳ J = {t over V ∪ W | for some v ∈ I and w ∈ J, t [V ] = v and t[W ] = w}.	x-384-2
When sort(I ) = sort(J ), then I ⊲⊳ J = I ∩ J , and when sort(I ) ∩ sort(J ) = ∅, then I ⊲⊳ J is the cross-product of I and J .	x-385-1
The join operator is associative, commutative, and has the nonempty 0-ary relation {} as left and right identity.	x-385-2
Because it is associative, we sometimes view join as a polyadic operator and write, for example, I1 ⊲⊳ · · · ⊲⊳ In.	x-385-3
Renaming: An attribute renaming for a finite set U of attributes is a one-one mapping from U to att.	x-386-1
An attribute renaming f for U can be described by specifying the set of pairs (A, f (A)), where f (A) = A; this is usually written as A1A2 .	x-386-2
.	x-386-3
.	x-386-4
An → B1B2 .	x-386-5
.	x-386-6
.	x-386-7
Bn to indicate that f (Ai) = Bi for each i ∈ [1, n] (n ≥ 0).	x-386-8
A renaming operator for inputs over U is an expression δf , where f is an attribute renaming for U ; this maps to outputs over f [U ].	x-386-9
In particular, for I over U ,	x-386-10
Example 4.4.4 Let I, J be the two relations, respectively over R, S, given in Fig.	x-387-1
4.4.	x-387-2
Then I ⊲⊳ J , σA=1(I ), δBC→B′A(J ), and πA(I ) are also shown there.	x-388-1
Let K be the one-tuple relation A : 1, C : 9.	x-388-2
Then πA,B(I ⊲⊳ K) coincides with σA=1(I ) and J ⊲⊳ K =	x-388-3
The base SPJR algebra queries are: Input relation: Expression R; with sort equal to sort(R).	x-389-1
Unary singleton constant: Expression {A : a}, where a ∈ dom; with sort A.	x-390-1
The remainder of the syntax and semantics of the SPJR algebra is now defined in analogy to those of the SPC algebra (see Exercise 4.8).	x-391-1
Example 4.4.5 Consider again Fig.	x-392-1
4.4.	x-392-2
Let I be the instance over {R, S} such that I(R) = I and I(S) = J .	x-392-3
Then [R] is a query and the answer to that query, denoted R(I), is just I .	x-392-4
Figure 4.4 also gives the values of S(I), [R ⊲⊳ S](I), [σA=1(R)](I),	x-392-5
R B S B C B C B B′ Figure 4.4: Examples of SPJR operators	x-393-1
k))), where n ≥ 0; m ≥ 0; a1, .	x-394-1
.	x-394-2
.	x-394-3
, am ∈ dom; each of A1, .	x-394-4
.	x-394-5
.	x-394-6
, Am occurs in B1, .	x-394-7
.	x-394-8
.	x-394-9
, Bn; the Ai’s are distinct; R1, .	x-394-10
.	x-394-11
.	x-394-12
, Rk are relation names (repeats permitted); δf is a renaming j operator for sort(Rj ) for each j ∈ [1, k] and no Ai’s occur in any δf (R j j ); the sorts of δf (R k) are pairwise disjoint; and F is a positive conjunctive selection formula.	x-394-13
The following is easily verified (see Exercise 4.12).	x-394-14
Proposition 4.4.6 For each (generalized) SPJR query q, there is a generalized SPJR query q′ in normal form such that q ≡ q′.	x-395-1
The set of SPJR queries not equivalent to q∅ forms the satisfiable SPJR algebra.	x-396-1
Equivalence Theorem We now turn to the main result of the chapter, showing the equivalence of the various formalisms introduced so far for expressing conjunctive queries.	x-397-1
As shown earlier, the three logic-based versions of the conjunctive queries are equivalent.	x-397-2
We now show that the SPC	x-397-3
Conjunctive Queries Lemma 4.4.7 The SPC and SPJR algebras are equivalent.	x-398-1
Crux We prove the inclusion SPC algebra ⊑ SPJR algebra; the converse is similar (see Exercise 4.14).	x-399-1
Let q be the following normal form SPC query:	x-399-2
We now describe an SPJR query q′ that is equivalent to q; q′ has the following form: πA j ,...,A k))).	x-400-1
jn k We use the renaming functions so that the attributes of δf (R t t ) are As , .	x-401-1
.	x-401-2
.	x-401-3
, As′, where s, .	x-401-4
.	x-401-5
.	x-401-6
, s′ are the coordinate positions of Rt in the expression R1 × · · · × Rk and modify F into G accordingly.	x-401-7
In a little more detail, for each r ∈ [1, k] let β(t) = m + #t arity(R s=0 s ), the ith attribute of Rt to the attribute Aβ(t−1)+i.	x-401-8
To define G, first define the function γ from coordinate positions to attribute names so that γ (j ) = Am+j , extend γ to be the identity on constants, and extend it further in the natural manner to map unnamed selection formulas to named selection formulas.	x-401-9
Finally, set G = γ (F ).	x-401-10
It is now straightforward to verify that q′ ≡ q.	x-401-11
It follows immediately from the preceding lemma that the satisfiable SPC algebra and the satisfiable SPJR algebra are equivalent.	x-402-1
The equivalence between the two algebraic languages and the three logic-based languages holds with a minor caveat involving the empty query q∅.	x-403-1
As noted earlier, the SPC	x-403-2
Theorem 4.3.3 (i.e., the closure of the rule-based conjunctive queries under composition) is used in the proof of this result.	x-404-1
The closures of the SPC and SPJR algebras under composition are, of course, immediate.	x-404-2
Theorem 4.4.8	x-405-1
Proof The proof can be accomplished using the following steps:	x-406-1
We briefly consider how steps (i) and (ii) might be demonstrated; the details are left to the reader (Exercise 4.15).	x-407-1
For (i), it is sufficient to show that each of the SPC algebra operations can be simulated by a rule.	x-407-2
Indeed, then the inclusion follows from the fact that rule-based conjunctive queries are closed under composition by Theorem 4.3.3 and that satisfiable rules with equality can be expressed as rules without equality.	x-407-3
The simulation of algebra operations by rules is as follows: x, $ y) ← P ($ x), Q($ y), where $ x and $ y contain no repeating variables; in the case when P x ($ y) are the corresponding constant tuples.	x-407-4
y) denotes the vector of variables and constants obtained by merging variables of $ y with other variables or with constants according to the (satisfiable) selection formula F , and $ x consists of the distinct variables in σF ($ y).	x-408-1
j1 jn distinct variables.	x-409-1
Next consider step (ii).	x-410-1
Let ans($ x) ← R1($ x1), .	x-410-2
.	x-410-3
.	x-410-4
, Rn($ xn) be a rule.	x-410-5
There is an equiv- x1, .	x-410-6
.	x-410-7
.	x-410-8
, $ xn, a fur- ther cross-product with constant relations corresponding to the constants in $ x, and finally x.	x-410-9
We begin with some examples.	x-411-1
Example 4.5.1 Consider the following query: Where can I see “Annie Hall” or “Manhattan”?	x-412-1
Conjunctive Queries	x-413-1
The rule-based formalism can accommodate this query by permitting more than one rule with the same relation name in the head and taking the union of their outputs as the answer: ans(xt) ← Pariscope(xt, “Annie Hall”, xs)	x-414-1
Consider now the following query: What are the films with Allen as actor or director?	x-415-1
This query can be expressed using any of the preceding formalisms, except for the SPJR	x-416-1
Let I1, I2 be two relations with the same arity.	x-417-1
As standard in mathematics, I1 ∪ I2 is the relation having this arity and containing the union of the two sets of tuples.	x-417-2
The definition of the SPCU algebra is obtained by extending the definition of the SPC algebra to include the union operator.	x-417-3
The SPJRU algebra is obtained in the same fashion, except that union can only be applied to expressions having the same sort.	x-417-4
The SPCU and SPJRU algebras can be generalized by extending the selection operator (and join, in the case of SPC) as before.	x-418-1
We can then define normal forms for both algebras, which are expressions consisting of one or more normal form SPC (SPJR) expressions combined using a polyadic union operator (see Exercise 4.23).	x-418-2
As suggested by the previous example, disjunction can also be incorporated into selection formulas with no increase in expressive power (see Exercise 4.22).	x-418-3
Turning now to rule-based conjunctive queries, the simplest way to incorporate the capability of union is to consider sets of rules all having the same relation name in the head.	x-419-1
These queries are evaluated by taking the union of the output of the individual rules.	x-419-2
This can be generalized without increasing the expressive power by incorporating something analogous to query composition.	x-420-1
A nonrecursive datalog program ( nr-datalog program) over schema R is a set of rules S1 ← body 1 S2 ← body 2	x-420-2
Sm ← body m, where no relation name in R occurs in a rule head; the same relation name may appear in more than one rule head; and there is some ordering r1, .	x-421-1
.	x-421-2
.	x-421-3
, rm of the rules so that the relation name in the head of ri does not occur in the body of a rule rj whenever j ≤ i.	x-421-4
The term ‘nonrecursive’ is used because recursion is not permitted.	x-422-1
A simple example of a recursive rule is	x-422-2
In general, a nonrecursive datalog program P over R is viewed as having a database schema as target.	x-423-1
Program P can also be viewed as mapping from R to a single relation (see Exercise 4.24).	x-423-2
Turning to tableau queries, a union of tableaux query over schema R (or R) is an expression of the form ({T1, .	x-424-1
.	x-424-2
.	x-424-3
, Tn}, u), where n ≥ 1 and (Ti, u) is a tableau query over R for each i ∈ [1, n].	x-424-4
The semantics of these queries is obtained by evaluating the queries (Ti, u) independently and then taking the union of their results.	x-424-5
Equality is incorporated into these queries by permitting each of the queries (Ti, u) to have equality.	x-424-6
We can now state (see Exercise 4.25) the following: Theorem 4.5.2 The following have equivalent expressive power:	x-425-1
The union of tableau queries is weaker than the aforementioned languages with union.	x-426-1
This is essentially because the definition of union of tableau queries does not allow separate summary rows for each tableau in the union.	x-427-1
With just one summary row, the nonrecursive datalog query cannot be expressed as a union of tableaux query.	x-427-2
Conjunctive Queries	x-428-1
Union and the Conjunctive Calculus	x-429-1
Example 4.5.3 Consider the following “query”: q = {x, y, z | R(x, y) ∨ R(y, z)}.	x-430-1
Speaking intuitively, the “answer” of q on nonempty instance I will be (using a slight abuse of notation) q(I ) = (I × dom) ∪ (dom × I ).	x-431-1
This is an infinite set of tuples and thus not an instance according to the formal definition.	x-432-1
Informally, the query q of the previous example is not “safe.” This notion is one of the central topics that needs to be resolved when using the first-order predicate calculus as a relational query language, and it is studied in Chapter 5.	x-433-1
We return there to the issue of adding union to the conjunctive calculus (see also Exercise 4.26).	x-433-2
Bibliographic Notes Codd’s pioneering article [Cod70] on the relational model introduces the first relational query language, a named algebra.	x-434-1
The predicate calculus was adapted to the relational model in [Cod72b], where it was shown to be essentially equivalent to the algebra.	x-434-2
The conjunctive queries, in the calculus paradigm, were first introduced in [CM77].	x-434-3
Their equivalence with the SPC algebra is also shown there.	x-434-4
Typed tableau queries appeared as a two-dimensional representation of a subset of the conjunctive queries in [ASU79b] along with a proof that all typed restricted SPJ algebra expressions over one relation can be expressed using them.	x-435-1
A precursor to the typed tableau queries is found in [ABU79], which uses a technique related to tableaux to analyze the join operator.	x-435-2
[ASU79a, ASSU81, CV81] continued the investigation of typed tableau queries;	x-435-3
Many of the results in this chapter (including, for example, the equivalence of the SPC	x-436-1
Exercises Exercises Exercise 4.1 Express queries (4.1–4.3) and (4.5–4.9) as (a) rule-based conjunctive queries, (b) conjunctive calculus queries, (c) tableau queries, (d) SPC expressions, and (e) SPJR expressions.	x-437-1
Exercise 4.2 Let R be a database schema and q a rule.	x-438-1
Exercise 4.3 Let R be a database schema and I an instance of R.	x-439-1
Exercise 4.4	x-440-1
Exercise 4.5	x-441-1
Exercise 4.6 Extend the syntax of the conjunctive calculus to include equality.	x-442-1
Give a syntactic condition that ensures that the answer to a query q on I involves only constants from adom(q, I) and such that the answer can be obtained by considering only valuations whose range is contained in adom(q, I).	x-442-2
Exercise 4.7 Give a proof of Theorem 4.3.3.	x-443-1
Conjunctive Queries Exercise 4.8	x-444-1
Exercise 4.9 Consider the algebra consisting of all SPJR queries in which constants do not occur.	x-445-1
Exercise 4.10 Under the named perspective, a selection operator is constant based if it has the form σA=a, where A ∈ att and a ∈ dom.	x-446-1
Prove or disprove: Each SPJR algebra expression is equivalent to an SPJR algebra expression all of whose selection operators are constant based.	x-446-2
Exercise 4.11 Prove that queries (4.6 and 4.8) cannot be expressed using the SPJ algebra (i.e., that renaming is needed).	x-447-1
Exercise 4.12	x-448-1
Exercise 4.13	x-449-1
Exercise 4.14 Complete the proof of Lemma 4.4.7 by showing the inclusion SPJR algebra ⊑ SPC algebra.	x-450-1
Exercise 4.15	x-451-1
Exercise 4.16 Consider the problem of defining restricted versions of the SPC and SPJR	x-452-1
Exercise 4.17 Let q be a tableau query and q′ the SPC query corresponding to it via the translation sketched in Theorem 4.4.8.	x-453-1
If q has r rows and q′ has j joins of database (nonconstant) relations, show that j = r − 1.	x-453-2
Exercises	x-454-1
Exercise 4.20	x-455-1
Prove that if q = (T , u) is a typed repeat-restricted tableau query over R, then there is a typed restricted SPJ query q′ such that the image of q′ under the algorithm of Exercise 4.19 part (a) is q.	x-456-1
Exercise 4.21 Extend Proposition 4.2.2 to include disjunction (i.e., union).	x-457-1
Exercise 4.22 The following query is used in this exercise: Produce a binary relation that includes all tuples t, “excellent” where t is a movie directed by Allen, and all tuples t, “superb” where t is a movie directed by Hitchcock.	x-458-1
Define the SPC-1* algebra to be the SPC algebra, except that nonsingleton unary constant relations can be used as base queries; and define the SPC-n* algebra to be the SPC algebra, Conjunctive Queries except that nonsingleton constant relations of arbitrary arity can be used as base queries.	x-459-1
Define the SPJR-1∗ and SPJR- n∗ algebras analogously.	x-459-2
Exercise 4.23 Give precise definitions for normal forms for the SPCU and SPJRU algebras, and prove that all expressions from these algebras have an equivalent in normal form.	x-460-1
Exercise 4.24	x-461-1
Exercise 4.25 Prove Theorem 4.5.2.	x-462-1
Let I be an instance over {R, S}.	x-463-1
Using the natural extension of the notion of satisfies to disjunction, show for each subformula of ϕ with form ∃ωψ, and each valuation ν over free(∃ωψ) with range contained in adom(I) that: there exists c ∈ dom such that I |= ψ[ν ∪ {w/c}] iff there exists c ∈ adom(I) such that I |= ψ[ν ∪ {w/c}].	x-463-2
Conclude that this query can be evaluated by considering only valuations whose range is contained in adom(I).	x-463-3
Exercise 4.27	x-464-1
Exercises Exercise 4.28 Show that intersection can be expressed in the SPC algebra.	x-465-1
Exercise 4.30	x-466-1
Conjunctive queries are great.	x-467-1
But what if I want to see a movie that doesn’t feature Woody Allen?	x-467-2
Vittorio: We have to introduce negation.	x-468-1
Sergio: It is basically easy.	x-469-1
Riccardo: But the calculus is a little feisty.	x-470-1
What are the Hitchcock movies in which Hitchcock did not play?	x-471-1
What movies are featured at the Gaumont Opera but not at the Gaumont les Halles?	x-472-1
List those movies for which all actors of the movie have acted under Hitchcock’s direction.	x-473-1
This chapter explores how negation can be added to all forms of the conjunctive queries (except for the tableau queries) to provide the power needed to express such queries.	x-474-1
This yields languages in the various paradigms that have the same expressive power.	x-474-2
They include relational algebra, relational calculus, and nonrecursive datalog with negation.	x-474-3
The class of queries they express is often referred to as the first-order queries because relational calculus is essentially first-order predicate calculus without function symbols.	x-474-4
These languages are of fundamental importance in database systems.	x-474-5
They provide adequate power for many applications and at the same time can be implemented with reasonable efficiency.	x-474-6
They constitute the basis for the standard commercial relational languages, such as SQL.	x-475-1
In the case of the algebras, negation is added using the set difference operator, yielding the language(s) generally referred to as relational algebra (Section 5.1).	x-476-1
In the case of the rule-based paradigm, we consider negative literals in the bodies of rules, which are interpreted as the absence of the corresponding facts; this yields nonrecursive datalog¬	x-476-2
The chapter concludes with brief digressions concerning how aggregate functions can be incorporated into the algebra and calculus (Section 5.5), and concerning the emerging area of constraint databases, which provide a natural mechanism for representing and manipulating infinite databases in a finite manner (Section 5.6).	x-477-1
From the theoretical perspective, the most important aspects of this chapter include the demonstration of the equivalence of the algebra and calculus (including a relatively direct transformation of calculus queries into equivalent algebra ones) and the application of the classical proof technique of structural induction used on both calculus formulas and algebra expressions.	x-478-1
The Relational Algebras Incorporating the difference operator, denoted ‘−’, into the algebras is straightforward.	x-479-1
As with union and intersection, this can only be applied to expressions that have the same sort, in the named case, or arity, in the unnamed case.	x-479-2
Example 5.1.1 In the named algebra, query (5.1) is expressed by	x-480-1
The unnamed relational algebra is obtained by adding the difference operator to the SPCU algebra.	x-481-1
It is conventional also to permit the intersection operator, denoted ‘∩’ in this algebra, because it is simulated easily using cross-product, select, and project or using difference (see Exercise 5.4).	x-481-2
Because union is present, nonsingleton constant relations may be used in this algebra.	x-481-3
Finally, the selection operator can be extended to permit negation (see Exercise 5.4).	x-481-4
The named relational algebra is obtained in an analogous fashion, and similar generalizations can be developed.	x-482-1
The unnamed and named relational algebras have equivalent expressive power.	x-483-1
The notion of composition of relational algebra queries can be defined in analogy to the composition of conjunctive queries described in the previous chapter.	x-484-1
It is easily verified that the relational algebras, and hence the other equivalent languages presented in this chapter, are closed under composition.	x-484-2
Nonrecursive Datalog with Negation To obtain a rule-based language with expressive power equivalent to the relational algebra, we extend nonrecursive datalog programs by permitting negative literals in rule bodies.	x-485-1
This yields the nonrecursive datalog with negation also denoted nonrecursive datalog¬	x-486-1
S(u) ← L1, .	x-487-1
.	x-487-2
.	x-487-3
, Ln, where S is a relation name, u is a free tuple of appropriate arity, and each Li is a literal [i.e., an expression of the form R(v) or ¬R(v), where R is a relation name and v is a free tuple of appropriate arity and where S does not occur in the body].	x-487-4
This rule is range restricted if each variable x occurring in the rule occurs in at least one literal of the form R(v) in the rule body.	x-487-5
Unless otherwise specified, all datalog¬ rules considered are assumed to be range restricted.	x-487-6
To give the semantics of the foregoing rule q, let R be a relation schema that includes all of the relation names occurring in the body of the rule q, and let I be an instance of R.	x-488-1
Then the image of I under q is q(I) = {ν(u) | ν is a valuation and for each i ∈ [1, n],	x-489-1
In general, this image can be expressed as a difference q1 − q2, where q1 is an SPC query and q2 is an SPCU query (see Exercise 5.9).	x-490-1
Equality may be incorporated by permitting literals of the form s = t and s = t for terms s and t. The notion of range restriction in this context is defined as it was for rule-based conjunctive queries with equality.	x-491-1
The semantics are defined in the natural manner.	x-491-2
To obtain the full expressive power of the relational algebras, we must consider sets of nr-datalog¬ rules; these are analogous to the nr-datalog programs introduced in the previous chapter.	x-492-1
A nonrecursive datalog¬ program (with or without equality) over schema R is a sequence S1 ← body1 S2 ← body2	x-492-2
Sm ← bodym of nr-datalog¬ rules, where no relation name in R occurs in a rule head; the same relation name may appear in more than one rule head; and there is some ordering r1, .	x-493-1
.	x-493-2
.	x-493-3
, rm of the rules so that the relation name in the head of a rule ri does not occur in the body of a rule rj whenever j ≤ i.	x-493-4
The semantics of these programs are entirely analogous to the semantics of nr-datalog programs.	x-493-5
An nr-datalog¬ query is a query defined by some nr-datalog¬ program with a specified target relation.	x-493-6
Example 5.2.1	x-494-1
Query (5.3) is answered by Hitch- actor(z) ← Movies(x, “Hitchcock”, z) not- ans(x) ← Movies(x, y, z), ¬ Hitch- actor(z) ans(x) ← Movies(x, y, z), ¬ not- ans(x).	x-495-1
Care must be taken when forming nr-datalog¬ programs.	x-496-1
Consider, for example, the following program, which forms a kind of merging of the first two rules of the previous program.	x-496-2
(Intuitively, the first rule is a combination of the first two rules of the preceding program, using variable renaming in the spirit of Example 4.3.1.)	x-496-3
bad-not-ans(x) ← Movies(x, y, z), ¬ Movies(x′, “Hitchcock”, z), Movies(x′, “Hitchcock”, z′), Rather than expressing query (5.3), it expresses the following:	x-497-1
It is easily verified that each nr-datalog¬ program with equality can be simulated by an nr-datalog¬ program not using equality (see Exercise 5.10).	x-498-1
Furthermore (see Exercise 5.11), the following holds: Proposition 5.2.2 The relational algebras and the family of nr-datalog¬ programs that have single relation output have equivalent expressive power.	x-498-2
The Relational Calculus	x-499-1
However, this flexibility brings with it a nontrivial cost: If used without restriction, the calculus can easily express queries whose “answers” are infinite.	x-500-1
Much of the theoretical development in this and the following section is focused on different approaches to make the calculus “safe” (i.e., to prevent this and related problems).	x-500-2
Although considerable effort is required, it is a relatively small price to pay for the flexibility obtained.	x-500-3
This section first extends the syntax of the conjunctive calculus to the full calculus.	x-501-1
Then some intuitive examples are presented that illustrate how some calculus queries can violate the principle of “domain independence.” A variety of approaches have been developed to resolve this problem based on the use of both semantic and syntactic restrictions.	x-502-1
This section focuses on semantic restrictions.	x-503-1
The first step in understanding these is a somewhat technical definition based on “relativized interpretation” for the semantics of (arbitrary) calculus queries; the semantics are defined relative to different “underlying domains” (i.e., subsets of dom).	x-503-2
This permits us to give a formal definition of domain independence and leads to a family of different semantics for a given query.	x-503-3
The section closes by presenting the equivalence of the calculus under two of the semantics with the algebra.	x-504-1
This effectively closes the issue of expressive power of the calculus, at least from a semantic point of view.	x-504-2
One of the semantics for the calculus presented here is the “active domain” semantics; this is particularly convenient in the development of theoretical results concerning the expressive power of a variety of languages presented in Parts D and E.	x-504-3
Well-Formed Formulas, Revisited We obtain the relational calculus from the conjunctive calculus with equality by adding negation (¬), disjunction (∨), and universal quantification (∀).	x-505-1
(Explicit equality is needed to obtain the full expressive power of the algebras; see Exercise 5.12.)	x-505-2
As will be seen, both disjunction and universal quantification can be viewed as consequences of adding negation, because ϕ ∨ ψ ≡ ¬(¬ϕ ∧ ¬ψ) and ∀xϕ ≡¬∃x¬ϕ.	x-505-3
The formal definition of the syntax of the relational calculus is a straightforward extension of that for the conjunctive calculus given in the previous chapter.	x-506-1
We include the full definition here for the reader’s convenience.	x-506-2
A term is a constant or a variable.	x-506-3
For a given input schema R, the base formulas include, as before, atoms over R and equality (inequality) atoms of the form e = e′ (e = e′) for terms e, e′.	x-506-4
The ( well-formed) formulas of the relational calculus over R include the base formulas and formulas of the form (a) (ϕ ∧ ψ), where ϕ and ψ are formulas over R;	x-506-5
It is sometimes convenient to view the binary connectives ∧ and ∨ as polyadic connectives.	x-507-1
In some contexts, e = e′ is viewed as an abbreviation of ¬(e = e′).	x-508-1
It is often convenient to include two additional logical connectives, implies (→) and is equivalent to (↔).	x-509-1
We view these as syntactic abbreviations as follows: ϕ → ψ ≡ ¬ϕ ∨ ψ	x-509-2
The notions of free and bound occurrences of variables in a formula, and of free(ϕ) for formula ϕ, are defined analogously to their definition for the conjunctive calculus.	x-510-1
In addition, the notion of relational calculus query is defined, in analogy to the notion of conjunctive calculus query, to be an expression of the form or if the sort is understood from the context, where e1, .	x-510-2
.	x-510-3
.	x-510-4
, em are terms, repeats permitted, and where the set of variables occurring in e1, .	x-510-5
.	x-510-6
.	x-510-7
, em is exactly free(ϕ).	x-510-8
Example 5.3.1 Suppose that each movie has just one director.	x-511-1
Query (5.1) can be expressed in the relational calculus as	x-511-2
Query (5.3) is expressed by	x-512-1
The first conjunct ensures that the variable xt ranges over titles in the current value of Movies, and the second conjunct enforces the condition on actors of the movie identified by xt.	x-513-1
Before presenting the alternative semantics for the relational calculus, we present an intuitive indication of the kinds of problems that arise if the conventional definitions from predicate calculus are adapted directly to the current context.	x-514-1
The fundamental problems of using the calculus are illustrated by the following expressions:	x-515-1
If the usual semantics of predicate calculus are adapted directly to this context, then the query ( unsafe-1) produces all tuples a where a ∈ dom and “Cries and Whispers”,	x-516-1
Even if the underlying domain is finite, users will typically not know the exact contents of the domains used for each variable.	x-517-1
In this case it would be disturbing to have the result of a user query depend on information not directly under the user’s control.	x-517-2
This is another argument for permitting only domain-independent queries.	x-517-3
The answer to this query is necessarily finite because it is a subset of π1(R).	x-518-1
However, the query is not domain independent.	x-518-2
To see why, note that if y is assumed to range over all of dom, then the answer is always the empty relation.	x-518-3
On the other hand, if the underlying domain of interpretation is finite, it is possible that the answer will be nonempty.	x-518-4
(This occurs, for example, if the domain is {1, .	x-518-5
.	x-518-6
.	x-518-7
, 5}, and the input for R is {3, 1, .	x-518-8
.	x-518-9
.	x-518-10
3, 5}.)	x-518-11
So again, this query depends on the underlying domain(s) being used (for the different variables) and is not under the user’s control.	x-518-12
There is a further difficulty of a more practical nature raised by query ( unsafe-3).	x-519-1
Specifically, if the intuitively appealing semantics of the predicate calculus are used, then the naive approach to evaluating quantifiers leads to the execution of potentially infinite procedures.	x-520-1
Although the proper answer to such queries can be computed in a finite manner (see Theorem 5.6.1), this is technically intricate.	x-520-2
The following example indicates how easy it is to form an unsafe query mistakenly in practice.	x-521-1
Example 5.3.2 Recall the calculus query answering query (5.3) in Example 5.3.1.	x-522-1
Suppose that the first conjunct of that query is omitted to obtain the following:	x-522-2
This query returns all titles of movies that have the specified property and also all elements of dom not occurring in π Title( Movies).	x-523-1
Even if xt were restricted to range over the set of actual and potential movie titles, it would not be domain independent.	x-523-2
Relativized Interpretations We now return to the formal development.	x-524-1
As the first step, we present a definition that will permit us to talk about calculus queries in connection with different underlying domains.	x-524-2
Under the conventional semantics associated with predicate calculus, quantified variables range over all elements of the underlying domain, in our case, dom.	x-525-1
For our purposes, however, we generalize this notion to permit explicit specification of the underlying domain to use (i.e., over which variables may range).	x-525-2
relative to d, denoted I |=d ϕ[ν], if (a) ϕ = R(u) is an atom and ν(u) ∈ I(R);	x-526-1
The notion of “satisfies .	x-527-1
.	x-527-2
.	x-527-3
relative to” just presented is equivalent to the usual notion of satisfaction found in first-order logic, where the set d plays the role of the universe of discourse in first-order logic.	x-527-4
In practical database settings it is most natural to assume that the underlying universe is dom; for this reason we use specialized terminology here.	x-527-5
Recall that for a query q and input instance I, we denote adom(q) ∪ adom(I) by adom(q, I), and the notation adom(ϕ, I) for formula ϕ is defined analogously.	x-528-1
We can now define the relativized semantics for the calculus.	x-529-1
Let R be a schema, q = {e1, .	x-529-2
.	x-529-3
.	x-529-4
, en | ϕ} a calculus query over R, and (d, I) a relativized instance over R. Then 1 ν|V for variable set V denotes the restriction of ν to V .	x-529-5
the image of I under q relative to d is qd(I) = {ν(e1, .	x-530-1
.	x-530-2
.	x-530-3
, en) | I |=d ϕ[ν], ν is a valuation over free(ϕ) with range ⊆ d}.	x-530-4
Note that if d is infinite, then this image may be an infinite set of tuples.	x-531-1
qd(I) = qd∪ adom(q, I)(I).	x-532-1
Example 5.3.3 Consider the query q = {x | R(x) ∧ ∃y(¬R(y) ∧ ∀z(R(z) ∨ z = y))} Then qdom(I ) = {} for any instance I over R q{1,2,3,4}(J1) = {} for J1 = {1, 2} over R q{1,2,3,4}(J2) = J2 for J2 = {1, 2, 3} over R q{1,2,3,4}(J3) = {} for J3 = {1, 2, 3, 4} over R q{1,2,3,4}(J4) = J4 for J4 = {1, 2, 3, 5} over R.	x-533-1
This illustrates that under an interpretation relative to a set d, a calculus query q on input I may be affected by |d − adom(q, I)|.	x-534-1
It is important to note that the semantics of algebra and datalog¬ queries q evaluated on instance I are independent of whether dom or some subset d satisfying adom(q, I) ⊆ d ⊆ dom is used as the underlying domain.	x-535-1
The Natural and Active Domain Semantics for Calculus Queries The relativized semantics for calculus formulas immediately yields two important semantics for calculus queries.	x-536-1
The first of these corresponds most closely to the conventional interpretation of predicate calculus and is thus perhaps the intuitively most natural semantics for the calculus.	x-536-2
Definition 5.3.4 For calculus query q and input instance I, the natural (or unrestricted) interpretation of q on I, denoted qnat(I), is qdom(I) if this is finite and is undefined otherwise.	x-537-1
The second interpretation is based on restricting quantified variables to range over the active domain of the query and the input.	x-538-1
Although this interpretation is unnatural from the practical perspective, it has the advantage that the output is always defined (i.e., finite).	x-538-2
It is also a convenient semantics for certain theoretical developments.	x-538-3
Definition 5.3.5 For calculus query q and input instance I, the active domain interpretation of q on I, denoted q adom(I), is q adom(q, I)(I).	x-539-1
The family of mappings obtained from calculus queries under the active domain interpretation is denoted CALC adom.	x-539-2
Example 5.3.6 Recall query ( unsafe-2).	x-540-1
Under the natural interpretation on input the instance I shown in Chapter 3, this query yields the undefined result.	x-540-2
On the other hand, under the active domain interpretation this yields as output (written informally) ({actors in “Cries and Whispers”} × adom(I)) ∪ ( adom(I) × {movies by Bergman featuring Ullman}), which is finite and defined.	x-540-3
Domain Independence	x-541-1
Definition 5.3.7	x-542-1
In particular, if q is domain independent, then the output according to the natural interpretation can be obtained by computing the active domain interpretation.	x-543-1
Thus, Lemma 5.3.8 CALCdi ⊑ CALC adom.	x-543-2
Example 5.3.9 The two calculus queries of Example 5.3.1 are domain independent, and the query of Example 5.3.2 is not (see Exercise 5.15).	x-544-1
Equivalence of Algebra and Calculus We now demonstrate the equivalence of the various languages introduced so far in this chapter.	x-545-1
Theorem 5.3.10 (Equivalence Theorem) The domain-independent calculus, the calcu- lus under active domain semantics, the relational algebras, and the family of nr-datalog¬ programs that have single-relation output have equivalent expressive power.	x-546-1
Proposition 5.2.2 shows that nr-datalog¬ and the algebras have equivalent expressive power.	x-547-1
In addition, Lemma 5.3.8 shows that CALCdi ⊑ CALC adom.	x-547-2
To complete the proof, we demonstrate that	x-547-3
Lemma 5.3.11 For each unnamed algebra query, there is an equivalent domain-independent calculus query.	x-548-1
Proof Let q be an unnamed algebra query with arity n. We construct a domain-independent query q′ = {x1, .	x-549-1
.	x-549-2
.	x-549-3
, xn | ϕq} that is equivalent to q.	x-549-4
The formula ϕq is constructed using an induction on subexpressions of q.	x-549-5
In particular, for subexpression E of q, we define ϕE according to the following cases:	x-549-6
F , where ψF is the formula obtained from F by replacing each coordinate identifier i by variable xi.	x-550-1
in n = yin j1 jl E1 where j1, .	x-551-1
.	x-551-2
.	x-551-3
, jl is a listing of [1, arity(E1)] − {i1, .	x-551-4
.	x-551-5
.	x-551-6
, in}.	x-551-7
E2	x-552-1
E2	x-553-1
E2 We leave verification of this construction and the properties of q′ to the reader (see Exercise 5.13a).	x-554-1
Lemma 5.3.12 For each calculus query q, there is a query in the unnamed algebra that is equivalent to q under the active domain interpretation.	x-555-1
Crux Let q = {x1, .	x-556-1
.	x-556-2
.	x-556-3
, xn | ϕ} be a calculus query over R. It is straightforward to develop a unary algebra query E adom such that for each input instance I, E adom(I) = {a | a ∈ adom(q, I)}.	x-556-4
Next an inductive construction is performed.	x-557-1
To each subformula ψ(y1, .	x-557-2
.	x-557-3
.	x-557-4
, ym) of ϕ this associates an algebra expression Eψ with the property that (abusing notation slightly)	x-557-5
We now illustrate a few cases of the construction of expressions Eψ and leave the rest for the reader (see Exercise 5.13b).	x-558-1
Suppose that ψ is a subformula of ϕ.	x-558-2
Then Eψ is constructed in the following manner: k F (R)), where $ k and F are chosen in accordance with $ y and $t.	x-558-3
Syntactic Restrictions for Domain Independence	x-559-1
Several criteria affect the development of these conditions, including their generality, their simplicity, and the ease with which queries satisfying the conditions can be translated into the relational algebra or other lower-level representations.	x-560-1
We present one such condition here, called “safe range,” that is relatively simple but that illustrates the flavor and theoretical properties of many of these conditions.	x-560-2
It will serve as a vehicle to illustrate one approach to translating these restricted queries into the algebra.	x-560-3
Other examples are explored in Exercises 5.25 and 5.26; translations of these into the algebra are considerably more involved.	x-560-4
This section begins with a brief digression concerning equivalence preserving rewrite rules for the calculus.	x-561-1
Next the family CALCsr of safe-range queries is introduced.	x-561-2
It is shown easily that the algebra ⊑ CALCsr.	x-561-3
A rather involved construction is then presented for transforming safe-range queries into the algebra.	x-561-4
The section concludes by defining a variant of the calculus that is equivalent to the conjunctive queries with union.	x-561-5
y y not free in ϕ) y y not free in ϕ) Figure 5.1: Equivalence-preserving rewrite rules for calculus formulas Equivalence-Preserving Rewrite Rules We now digress for a moment to present a family of rewrite rules for the calculus.	x-562-1
These preserve equivalence regardless of the underlying domain used to evaluate calculus queries.	x-562-2
Several of these rules will be used in the transformation of safe-range queries into the algebra.	x-563-1
Calculus formulas ϕ, ψ over schema R are equivalent, denoted ϕ ≡ ψ, if for each I over R, d ⊆ dom, and valuation ν with range ⊆ d I |=d∪ adom(ϕ, I) ϕ[ν] if and only if I |=d∪ adom(ψ, I) ψ[ν].	x-564-1
Figure 5.1 shows a number of equivalence-preserving rewrite rules for calculus formulas.	x-565-1
It is straightforward to verify that if ψ transforms to ψ′ by a rewrite rule and if ϕ′ is the result of replacing an occurrence of subformula ψ of ϕ by formula ψ′, then ϕ′ ≡ ϕ	x-565-2
Note that, assuming x ∈ free(ψ) and y ∈ free(ϕ),	x-566-1
Example 5.4.1 Recall from Chapter 2 that a formula ϕ is in prenex normal form (PNF) if it has the form %1x1 .	x-567-1
.	x-567-2
.	x-567-3
%nxnψ, where each %i is either ∀ or ∃, and no quantifiers occur in ψ.	x-567-4
In this case, ψ is called the matrix of formula ϕ.	x-567-5
It is easily verified (see Exercise 5.14) that the rewrite rules can be used to transform an arbitrary calculus formula into an equivalent formula that is in PNF with a CNF matrix, and into an equivalent formula that is in PNF with a DNF matrix.	x-568-1
Safe-Range Queries The notion of safe range is presented now in three stages, involving (1) a normal form called SRNF, (2) a mechanism for determining how variables are “range restricted” by subformulas, and (3) specification of a required global property of the formula.	x-569-1
During this development, it is sometimes useful to speak of calculus formulas in terms of their parse trees.	x-570-1
For example, we will say that the formula (R(x) ∧ ∃y(S(y, z)) ∧	x-570-2
The normalization of formulas puts them into a form more easily analyzed for safety without substantially changing their syntactic structure.	x-571-1
The following equivalence-preserving rewrite rules are used to place a formula into safe-range normal form (SRNF): Variable substitution: This is from Section 4.2.	x-571-2
It is applied until no distinct pair of quantifiers binds the same variable and no variable occurs both free and bound.	x-571-3
Remove universal quantifiers: Replace subformula ∀$ xψ by ¬∃$ x¬ψ .	x-572-1
(This and the next condition can be relaxed; see Example 5.4.5.)	x-572-2
Remove implications: Replace ψ → ξ by ¬ψ ∨ ξ , and similarly for ↔.	x-573-1
Push negations: Replace so that the child of each negation is either an atom or an existentially quantified formula.	x-574-1
Flatten ‘and’s, ‘or’s, and existential quantifiers: This is done so that no child of an ‘and’ is an ‘and,’ and similarly for ‘or’ and existential quantifiers.	x-575-1
The SRNF formula resulting from applying these rules to ϕ is denoted SRNF(ϕ).	x-576-1
A formula ϕ (query {$ e | ϕ}) is in SRNF if SRNF(ϕ) = ϕ.	x-576-2
Example 5.4.2 The first calculus query of Example 5.3.1 is in SRNF.	x-577-1
The second calculus query is not in SRNF; the corresponding SRNF query is	x-577-2
Transforming the query of Example 5.3.2 into SRNF yields	x-578-1
We now present a syntactic condition on SRNF formulas that ensures that each variable is “range restricted,” in the sense that its possible values all lie within the active domain of the formula or the input.	x-579-1
If a quantified variable is not range restricted, or if one of the free variables is not range restricted, then the associated query is rejected.	x-579-2
To make the definition, we first define the set of range-restricted variables of an SRNF formula using the following procedure, which returns either the symbol ⊥, indicating that some quantified variable is not range restricted, or the set of free variables that is range restricted.	x-579-3
Input: a calculus formula ϕ in SRNF Output: a subset of the free variables of ϕ or3 ⊥ begin case ϕ of R(e1, .	x-580-1
.	x-580-2
.	x-580-3
, en) : rr(ϕ) = the set of variables in {e1, .	x-580-4
.	x-580-5
.	x-580-6
, en}; x = a or a = x : rr(ϕ) = {x}; rr(ψ) if {x, y} ∩ rr(ψ) = ∅, rr(ψ ) ∪ {x, y} otherwise; xϕ1 : if $ x ⊆ rr(ϕ1) then rr(ϕ) = rr(ϕ1) − $x else return ⊥ end case end x’ to denote the set of variables occurring in $ x.	x-580-7
Intuitively, the occurrence of a variable x in a base relation or in an atom of the form x = a restricts that variable.	x-581-1
This restriction is propagated through ∧, possibly lost in ∨, and always lost in ¬.	x-581-2
In addition, each quantified variable must be restricted by the subformula it occurs in.	x-581-3
Example 5.4.4 Recall Examples 5.3.1 and 5.4.2.	x-582-1
The first query of Example 5.3.1 is safe range.	x-582-2
The first query of Example 5.4.2 is also safe range.	x-582-3
However, the second query of Example 5.4.2 is not because the free variable xt is not range restricted by the formula.	x-582-4
Before continuing, we explore a generalization of the notion of safe range to permit universal quantification.	x-583-1
Example 5.4.5 Suppose that formula ϕ has a subformula of the form x(ψ1($ x) → ψ2($ y)), where $ x and $ y might overlap.	x-584-1
Transforming into SRNF (and assuming that the parent of ψ is not ¬), we obtain x(ψ1($ x) ∧ ¬ψ2($ y)).	x-584-2
Now rr(ψ′) is defined iff	x-585-1
In this case, rr(ψ′) = ∅.	x-586-1
This is illustrated by the second query of Example 5.3.1, that was transformed into SRNF in Example 5.4.2.	x-586-2
Thus SRNF can be extended to permit subformulas that have the form of ψ without materially affecting the development.	x-587-1
The calculus query constructed in the proof of Lemma 5.3.11 is in fact safe range.	x-588-1
It thus follows that the algebra ⊑ CALCsr.	x-588-2
The development here implies that all of CALCsr, CALCdi, and CALC adom are equivalent.	x-589-1
When the particular choice is irrelevant to the discussion, we use the term relational calculus to refer to any of these three equivalent query languages.	x-589-2
From Safe Range to the Algebra We now present the main result of this section (namely, the translation of safe-range queries into the named algebra).	x-590-1
Speaking loosely, this translation is relatively direct in the sense that the algebra query E constructed for calculus query q largely follows the structure of q.	x-590-2
As a result, evaluation of E will in most cases be more efficient than using the algebra query that is constructed for q by the proof of Lemma 5.3.12.	x-590-3
Examples of the construction used are presented after the formal argument.	x-591-1
Theorem 5.4.6 CALCsr ≡ the relational algebra.	x-592-1
Furthermore, each safe-range query is domain independent.	x-592-2
The proof of this theorem involves several steps.	x-593-1
As seen earlier, the algebra ⊑ CALCsr.	x-593-2
To prove the other direction, we develop a translation from safe-range queries into the named algebra.	x-593-3
Because the algebra is domain independent, this will also imply the second sentence of the theorem.	x-593-4
To begin, let ϕ be a safe-range formula in SRNF.	x-594-1
An occurrence of a subformula ψ in ϕ is self-contained if its root is ∧ or if xψ1 and rr(ψ) = free(ψ1); or	x-594-2
Intuitively, if ψ is a self-contained subformula of ϕ that does not have ∧ as a root, then all free variables in ψ are range restricted within ψ.	x-595-1
As we shall see, if ϕ is in RANF, this permits construction of an equivalent relational algebra query Eϕ using an induction from leaf to root.	x-595-2
We now develop an algorithm RANF-ALG that transforms safe-range SRNF formulas into RANF.	x-596-1
It is based on the following rewrite rules: where	x-596-2
Suppose that rr(ψ) = free(ψ), but rr(ξ1 ∨ · · · ∨ ξm) = free(ξ1 ∨ · · · ∨ ξm).	x-597-1
Nondeterministically choose a subset i1, .	x-597-2
.	x-597-3
.	x-597-4
, ik of 1, .	x-597-5
.	x-597-6
.	x-597-7
, n such that ξ ′ = (ξ1 ∧ ψi ∧ · · · ∧ ψ ) ∨ · · · ∨ (ξ ik m ∧ ψi1 ik	x-597-8
satisfies rr(ξ ′) = free(ξ ′).	x-598-1
(One choice of i1, .	x-598-2
.	x-598-3
.	x-598-4
, ik is to use all of 1, .	x-598-5
.	x-598-6
.	x-598-7
, n; this necessarily yields a formula ξ ′ with this property.)	x-598-8
Letting {j1, .	x-598-9
.	x-598-10
.	x-598-11
, jl} = {1, .	x-598-12
.	x-598-13
.	x-598-14
, n} −	x-598-15
jl The application of SRNF to ξ ′ only has the effect of possibly renaming quantified variables5 and of flattening the roots of subformulas ξp ∧ ψi ∧ · · · ∧ ψ , where ξ ik p has root ∧; analogous remarks apply.	x-599-1
The rewrite rule is to replace subformula ψ by ψ ′ and possibly apply SRNF to flatten an ∨, if both l = 0 and the parent of ψ is ∨.	x-599-2
xξ, where rr(ψ) = free(ψ), but rr(ξ ) = free(ξ ).	x-600-1
Then replace ψ by ψ ′ = SRNF(ψj ∧ · · · ∧ ψ ∧ ∃$ xξ ′), jl where ik	x-600-2
xξ, where rr(ψ) = free(ψ), but rr(ξ ) = free(ξ ).	x-601-1
Then replace ψ by ψ ′ = SRNF(ψ1 ∧ · · · ∧ ψn ∧ ¬∃$ xξ ′), where ik follows from the observation that the propositional formulas p ∧ q ∧ ¬r and p ∧ q ∧	x-601-2
The algorithm RANF-ALG for applying these rewrite rules is essentially top-down and recursive.	x-602-1
We sketch the algorithm now (see Exercise 5.19).	x-602-2
Output: a RANF formula ϕ′ = RANF(ϕ) equivalent to ϕ begin while some subformula ψ (with its conjuncts possibly reordered) of ϕ satisfies the premise of R1, R2, or R3 do case R1: (left as exercise) R2: (left as exercise) R3: Let ψ = ψ1 ∧ · · · ∧ ψn ∧ ¬∃$xξ ik ik xβ; end case end while end The proof that these rewrite rules can be used to transform a safe-range SRNF formula into a RANF formula has two steps (see Exercise 5.19).	x-603-1
First, a case analysis can be used to show that if safe-range ϕ in SRNF is not in RANF, then one of the rewrite rules (R1, R2, R3) can be applied.	x-603-2
Second, it is shown that Algorithm 5.4.7 terminates.	x-603-3
This is accomplished by showing that (1) each successfully completed call to RANF-ALG reduces the number of non-self-contained subformulas, and (2) if a call to RANF-ALG on ψ invokes other calls to RANF-ALG, the input to these recursive calls has fewer non-self-contained subformulas than does ψ.	x-604-1
We now turn to the transformation of RANF formulas into equivalent relational algebra queries.	x-605-1
We abuse notation somewhat and assume that each variable is also an attribute.	x-605-2
Let RANF formula ϕ be fixed.	x-606-1
The construction of Eϕ is inductive, from leaf to root, and is sketched in the following algorithm.	x-606-2
The special operator diff, on inputs R and S where att(S) ⊂ att(R), is defined by R diff S = R − (R ⊲⊳ S).	x-606-3
k, and selection formula F in the first entry of the case statement, are left to the reader; see Example 5.4.9 and Exercise 5.19.)	x-607-1
Input: a formula ϕ in modified RANF Output: an algebra query Eϕ equivalent to ϕ begin case ϕ of R($ e) k F (R))) x = a if ξ is x = x, then Eψ if ξ is x = y (with x, y distinct), then if ξ is x = y, then σx=y(Eψ) if ξ = ¬ξ ′, then Eψ diff Eξ′, if free(ξ ′) ⊂ free(ψ) Eψ − Eξ′, if free(ξ ′) = free(ψ) otherwise, Eψ ⊲⊳ Eξ Eψ ∪ · · · ∪ E end case end Finally, let q = {x1, .	x-608-1
.	x-608-2
.	x-608-3
, xn | ϕ} be safe range.	x-608-4
Because the transformations used for SRNF and RANF are equivalence preserving, without loss of generality we can assume that ϕ is in modified RANF.	x-608-5
To conclude the proof of Theorem 5.4.6, it must be shown that q and Eϕ are equivalent.	x-608-6
In fact, it can be shown that for each instance I and each d satisfying adom(q, I) ⊆ d ⊆ dom, qd(I) = Eϕ(I).	x-608-7
This will also yield that q is domain independent.	x-609-1
Let I and d be fixed.	x-610-1
A straightforward induction can be used to show that for each subformula ψ(y1, .	x-610-2
.	x-610-3
.	x-610-4
, ym) of ϕ and each variable assignment ν with range d, I |=d ψ[ν] ⇔ ν(y1), .	x-610-5
.	x-610-6
.	x-610-7
, ν(ym) ∈ Eψ(I)	x-610-8
Example 5.4.9 q1 = {a, x, y : A1A2A3 | ∃z(P (x, y, z) ∨ [R(x, y)∧	x-611-1
The formula of q1 is in SRNF.	x-612-1
Transformation into RANF yields	x-612-2
E = πx,y(δB1B2B3→xyz(P )	x-613-1
Finally, an algebra query equivalent to q1 is	x-614-1
q2 = {x | ∃y[R(x, y) ∧ ∀z(S(z, a) → T (y, z))	x-615-1
Transforming to SRNF, we have	x-616-1
Transforming to RANF and reordering the conjunctions, we obtain	x-617-1
E1 := (δA1A2→xy(R) ⊲⊳ {w : b}); E2 := (σv=x(E1 ⊲⊳ δx→v(E1))) diff δC1C2→vw(T ); E3 := πx,y(E2); E4 := πx,y(δA B2=a(S))) diff δC1C2→yz(T )); E5 := πx(E3 − E4).	x-618-1
The Positive Existential Calculus In Chapter 4, disjunction was incorporated into the rule-based conjunctive queries, and union was incorporated into the tableau, SPC, and SPJR queries.	x-619-1
Incorporating disjunction into the conjunctive calculus was more troublesome because of the possibility of infinite “answers.” We now apply the tools developed earlier in this chapter to remedy this situation.	x-619-2
Theorem 5.4.10 The positive existential calculus is equivalent to the family of conjunctive queries with union.	x-620-1
In practical query languages, the underlying domain is many-sorted, with sorts such as boolean, string, integer, or real.	x-621-1
These languages allow the use of comparators such as ≤ between database entries in an ordered sort and “aggregate” functions such as sum, count, or average on numeric sorts.	x-621-2
In this section, aggregate operators are briefly considered.	x-621-3
In the next section, a novel approach for incorporating arithmetic constraints into the relational model will be addressed.	x-622-1
Example 5.5.1 Consider a relation Sales[ Theater, Title, Date, Attendance], where a tuple th, ti, d, a indicates that on date d a total of a people attended showings of movie ti at theater th.	x-623-1
We assume that { Theater, Title, Date} is a key, i.e., that two distinct tuples cannot share the same values on these three attributes.	x-623-2
Two queries involving aggregate functions are For each theater, list the total number of movies that have been shown there.	x-623-3
For each theater and movie, list the total attendance.	x-624-1
Informally, the first query might be expressed in a pidgin language as since a value a has to be counted as many times as it occurs in the selection.	x-625-1
This suggests that a more natural setting for studying aggregate functions would explicitly include bags (or multisets, i.e., collections in which duplicates are permitted) and not just sets, a somewhat radical departure from the model we have used so far.	x-625-2
The two queries can be expressed as follows using aggregate functions in an algebraic language:	x-626-1
We now briefly present a more formal development.	x-627-1
To simplify, the formalism is based on the unnamed perspective, and we assume that dom = N, i.e., the set of nonnegative integers.	x-627-2
We stay within the relational model although as noted in the preceding example, a richer data model with bags would be more natural.	x-627-3
Indeed, the complex value model that will be studied in Chapter 20 provides a more appropriate context for considering aggregate functions.	x-627-4
We shall adopt a somewhat abstract view of aggregate operators.	x-628-1
An aggregate function f is defined to be a family of functions f1, f2, .	x-628-2
.	x-628-3
.	x-628-4
such that for each j ≥ 1 and each relation schema S with arity(S) ≥ j , fj : Inst(S) → N. For instance, for the sum aggregate function, we will have sum1 to sum the first column and, in general, sumi to sum the ith one.	x-628-5
As in the case of sum, we want the fi to depend only on the content of the column to which they are applied, where the “content” includes not only the set of elements in the column, but also the number of their occurrences (so, columns are viewed as bags).	x-628-6
This requirement is captured by the following uniformity property imposed on each aggregate function f : Suppose that the ith column of I and the j th of J are identical, i.e., for each a, there are as many occurrences of a in the ith column of I and in the j th column of J .	x-628-7
Then fi(I ) = fj (J ).	x-628-8
We next illustrate how aggregate functions can be incorporated into the algebra and calculus (we do not discuss how this is done for nr-datalog¬, since it is similar to the algebra.)	x-629-1
Aggregate functions are added to the algebra using an extended projection operation.	x-629-2
Specifically, the projection function for aggregate function f on relation instance I is defined as follows: jm k(σj1=aj ∧···∧j	x-630-1
m=ajm Note that the aggregate function fk is applied separately to each group of tuples in I corresponding to a different possible value for the columns j1, .	x-631-1
.	x-631-2
.	x-631-3
, jm.	x-631-4
Turning to the calculus, we begin with an example.	x-632-1
Query (5.5) can be expressed in the extended calculus as where sum2 is the aggregate function summing the second column of a relation.	x-632-2
Note that the subexpression {d2, a2 | Sales( th, ti, d2, a2)} has free variables th and ti that do not occur in the target of the subexpression.	x-632-3
Intuitively, different assignments for these variables will yield different values for the subexpression.	x-632-4
More formally, aggregate functions are incorporated into the calculus by permitting aggregate terms that have the form fj {$ x | ψ }, where f is an aggregate function, j ≤ x) and ψ is a calculus formula (possibly with aggregate terms).	x-633-1
When defining the extended calculus, care must be taken to guarantee that aggregate terms do not recursively depend on each other.	x-633-2
This can be accomplished with a suitable generalization of safe range.	x-633-3
This generalization will also ensure that free variables occurring in an aggregate term are range restricted by a subformula containing it.	x-633-4
It is straightforward to define the semantics of the generalized safe-range calculus with aggregate functions.	x-633-5
One can then show that the extensions of the algebra and safe-range calculus with the same set of aggregate functions have the same expressive power.	x-633-6
Digression: Finite Representations of Infinite Databases Until now we have considered only finite instances of relational databases.	x-634-1
As we have seen, this introduced significant difficulty in connection with domain independence of calculus queries.	x-634-2
It is also restrictive in connection with some application areas that involve temporal or geometric data.	x-634-3
For example, it would be convenient to think of a rectangle in the real plane as an infinite set of points, even if it can be represented easily in some finite manner.	x-634-4
In this short section we briefly describe some recent and advanced material that uses logic to permit the finite representation of infinite databases.	x-635-1
We begin by presenting an alternative approach to resolving the problem of safety, that permits queries to have answers that are infinite but finitely representable.	x-635-2
We then introduce a promising generalization of the relational model that uses constraints to represent infinite databases, and we describe how query processing can be performed against these in an efficient manner.	x-635-3
For this result, we shall use a finite set d ⊂ dom, which corresponds intuitively to the active domain of a query and input database; and a set C = {c1, .	x-636-1
.	x-636-2
.	x-636-3
, cm} of m distinct “new” symbols, which will serve as placeholders for elements of dom − d. Speaking intuitively, the elements of C sometimes act as elements of dom, and so it is not appropriate to view them as simple variables.	x-636-4
semd(t) = {ρ(t) | ρ is a one-one mapping from d ∪ C that leaves d fixed and maps C into dom − d}.	x-637-1
The following theorem, stated without proof, characterizes the result of applying an arbitrary calculus query using the natural semantics.	x-638-1
Theorem 5.6.1 Let q = {e1, .	x-639-1
.	x-639-2
.	x-639-3
, en | ϕ} be an arbitrary calculus query, such that each quantifier in ϕ quantifies a distinct variable that is not free in ϕ.	x-639-4
Let C = {c1, .	x-639-5
.	x-639-6
.	x-639-7
, cm} be a set of m distinct “new” symbols not occurring in dom, but viewed as domain elements, where m is the number of distinct variables in ϕ.	x-639-8
Then for each input instance I, qdom(I) = ∪{ semadom(q, I)(t) | t ∈ q adom(q, I)∪C(I)}.	x-639-9
This shows that if we apply a calculus query (under the natural semantics) to a finite database, then the result is recursive, even if infinite.	x-640-1
But is the set of infinite databases described in this manner closed under the application of calculus queries?	x-640-2
The affirmative answer is provided by an elegant generalization of the relational model presented next (see Exercise 5.31).	x-640-3
Constraint Query Languages The following generalization of the relational model seems useful to a variety of new applications.	x-641-1
The starting point is to consider infinite databases with finite representations based on the use of constraints.	x-641-2
To begin we define a generalized n-tuple as a conjunction of constraints over n variables.	x-641-3
The constraints typically include =, =, ≤, etc.	x-641-4
In some sense, such a constraint can be viewed as a finite representation of a (possibly infinite) set of (normal) n-tuples (i.e., the valuations of the variables that satisfy the constraint).	x-641-5
Example 5.6.2 Consider the representation of rectangles in the plane.	x-642-1
Suppose first that rectangles are given using 5-tuples (n, x1, y1, x2, y2), where n is the name of the rectangle, (x1, y1) are the coordinates of the lower left corner, and (x2, y2) are the coordinates of the upper right.	x-642-2
The set of points u, v in such a rectangle delimited by x1, y1, x2, y2 is given by the constraint x1 ≤ u ≤ x2 ∧ y1 ≤ v ≤ y2.	x-642-3
Now the names of intersecting rectangles from a relation R are given by R(n2, x′ u ≤ x′2 y′1 v ≤ y′2))}.	x-643-1
This is essentially within the framework of the relational model presented so far, except that we are using an infinite base relation ≤.	x-644-1
There is a level of indirection between the representation of a rectangle (a, x1, y1, x2, y2) and the actual set of points that it contains.	x-644-2
In the following constraint formalism, a named rectangle can be represented by a	x-645-1
This should be viewed as a finite syntactic representation of an infinite set of triples.	x-646-1
A triple z1, z2, z3 satisfying this constraint indicates that the point of coordinates (z2, z3) is in a rectangle with name z1.	x-646-2
One can see a number of uses in allowing constraints in the language.	x-647-1
First, constraints arise naturally for domains concerning measures (price, distance, time, etc.).	x-647-2
The introduction of time has already been studied in the active area of temporal databases (see Section 22.6).	x-647-3
In other applications such as spatial databases, geometry plays an essential role and fits nicely in the realm of constraint query languages.	x-647-4
One can clearly obtain different languages by considering various domains and various forms of constraints.	x-648-1
Relational calculus, relational algebra, or some other relational languages can be extended with, for instance, the theory of real closed fields or the theory of dense orders without endpoints.	x-648-2
Of course, a requirement is the decidability of the resulting language.	x-648-3
Definition 5.6.3	x-649-1
Suppose that I is a generalized instance.	x-650-1
We refer to I as a syntactic database and to the set of conventional tuples represented by I as the semantic database.	x-650-2
We now present two applications of this approach, one in connection with the reals and the other with the rationals.	x-651-1
We assume now that the constants are interpreted over a real closed field (e.g., the reals).	x-652-1
The constraints are polynomial inequality constraints [i.e., inequalities of the form p(x1, .	x-652-2
.	x-652-3
.	x-652-4
, xn) ≥ 0, where p is a polynomial].	x-652-5
Two 3-tuples in this context are (3.56 × x2 +	x-652-6
One can evaluate queries algebraically bottom-up (i.e., at each step of the computation, the result is still a generalized instance).	x-653-1
This is a straightforward consequence of Tarski’s decision procedure for the theory of real closed fields.	x-653-2
A difficulty resides in projection (i.e., quantifier elimination).	x-653-3
The procedure for projection is extremely costly in the size of the query.	x-653-4
However, for a fixed query, the complexity in the size of the syntactic database is reasonable (in nc).	x-653-5
We assume now that the constants are interpreted over a countably infinite set with a binary relation ≤ that is a dense order (e.g., the rationals).	x-654-1
The constraints are of the form xθy or xθ c, where x, y are variables, c is a constant, and θ is among ≤, <, =.	x-654-2
An example of a 3-tuple is	x-654-3
Here again, a bottom-up algebraic evaluation is feasible.	x-655-1
Indeed, evaluation is in ac0 in the size of the syntactic database (for a fixed query).	x-655-2
In the remainder of this book, we consider standard databases and not generalized ones.	x-656-1
Bibliographic Notes One of the first investigations of using predicate calculus to query relational database structures is [Kuh67], although the work by Codd [Cod70, Cod72b] played a tremendous role in bringing attention to the relational model and to the relational algebra and calculus.	x-657-1
In particular, [Cod72b] introduced the equivalence of the calculus and algebra to the database community.	x-657-2
That paper coined the phrase relational completeness to describe the expressive power of relational query languages: Any language able to simulate the algebra is called relationally complete.	x-657-3
We have not emphasized that phrase here because subsequent research has suggested that a more natural notion of completeness can be described in terms of Turing computability (see Chapter 16).	x-657-4
One such result presented in this chapter is the equivalence of the positive existential cal- Bibliographic Notes culus and the SPCU algebra [CH82]; analogous results have also been developed for the relational calculus extended with aggregate operators [Klu82], the complex value model	x-658-1
Notions related to domain independence are found as early as [Low15] in the logic community; in the database community the first paper on this topic appears to be [Kuh67], which introduced the notion of definite queries.	x-659-1
The notion of domain independence used here is from [Fag82b, Mak81]; the notions of definite and domain independent were proved equivalent in [ND82].	x-659-2
A large number of classes of domain-independent formulas have been investigated.	x-659-3
These include the safe [Ull82b], safe DRC [Ull88], range separable	x-659-4
Domain independence also arises in the context of dependencies [Fag82b, Mak81] and datalog [Dec86, Top87, RBS87, TS88].	x-660-1
The issue of extending domain independence to incorporate functions (e.g., arithmetic functions, or user-defined functions) is considered in [AB88, Top91, EHJ93].	x-660-2
The issue of extending domain independence to incorporate freely interpreted functions (such as arise in logic programming) is addressed in [Kif88].	x-660-3
Syntactic conditions on (recursive) datalog programs with arithmetic that ensure safety are developed in [RBS87, KRS88a, KRS88b, SV89].	x-661-1
Issues of safety in the presence of function or order symbols are also considered in [AH91].	x-661-2
Aggregate functions were first incorporated into the relational algebra and calculus in [Klu82]; see also [AB88].	x-661-3
The notion of safe range presented here is richer than safe, safe DRC, and range separable and weaker than allowed, evaluable, and range restricted.	x-662-1
It follows the spirit of the definition of allowed presented in [VanGT91] and safe range in [AB88].	x-662-2
The transformations of the safe-range calculus to the algebra presented here follows the more general transformations in [VanGT91, EHJ93].	x-662-3
The notion of “relational algebra normal form” used in those works is more general than the notion by that name used here.	x-662-4
Query languages have mostly been considered for finite databases.	x-663-1
An exception is	x-663-2
Programming with constraints has been studied for some time in topic areas ranging from linear programming to AI to logic programming.	x-664-1
Although the declarative spirit of both constraint programming and database query languages leads to a natural marriage, it is only recently that the combination of the two paradigms has been studied seriously for constraint databases with dense order and inequalities is featured there).	x-664-2
Recent works on constraint database languages can be found in [Kup93, GS94].	x-664-3
Exercises Exercise 5.1 Express queries (5.2 and 5.3) in (1) the relational algebras, (2) nonrecursive datalog¬, and (3) domain-independent relational calculus.	x-665-1
Exercise 5.2 Express the following queries against the CINEMA database in (1) the relational algebras, (2) nonrecursive datalog¬, and (3) domain-independent relational calculus.	x-666-1
Exercise 5.3 Prove or disprove (assuming X ⊆ sort(P ) = sort(Q)): (a) πX(P ∪ Q) = πX(P ) ∪ πX(Q);	x-667-1
Exercise 5.4	x-668-1
Show that these selection operators can be simulated using atomic selection operators, union, intersect, and difference.	x-669-1
Exercise 5.5	x-670-1
Exercise 5.6	x-671-1
Exercises Exercise 5.7 Prove Proposition 5.1.2 (i.e., that the unnamed and named relational algebras have equivalent expressive power).	x-672-1
Exercise 5.8	x-673-1
Exercise 5.9 Show that the semantics of each nr-datalog¬ rule can be described as a difference q1 − q2, where q1 is an SPJR query and q2 is an SPJRU query.	x-674-1
Exercise 5.10 Verify that each nr-datalog¬ program with equality can be simulated by one without equality.	x-675-1
Exercise 5.11 Prove Proposition 5.2.2.	x-676-1
Hint: Use the proof of Theorem 4.4.8 and the fact that the relational algebra is closed under composition.	x-676-2
Exercise 5.13	x-677-1
Exercise 5.14	x-678-1
Exercise 5.15 Verify the claims of Example 5.3.9.	x-679-1
Exercise 5.16	x-680-1
Exercise 5.17 Use the construction of the proof of Theorem 5.4.6 to transform the following into the algebra.	x-681-1
Exercise 5.18 For each of the following queries, indicate whether it is domain independent and/or safe range.	x-682-1
If it is not domain independent, give examples of different domains yielding different answers on the same input; and if it is safe range, translate it into the algebra.	x-682-2
Exercise 5.20 Consider the proof of Theorem 5.4.6.	x-683-1
Exercise 5.21 Develop a direct proof that CALC adom ⊑ CALCsr.	x-684-1
Hint: Given calculus query q, first build a formula ξ adom(x) such that I |= ξ adom(x)[ν] iff ν(x) ∈ adom(q, I).	x-684-2
Now perform an induction on subformulas.	x-684-3
j1,...,jl i1=a1∧···∧ik=ak where {j1, .	x-685-1
.	x-685-2
.	x-685-3
, jl} is a listing in order of (some or all) indexes in {1, .	x-685-4
.	x-685-5
.	x-685-6
, n} − {i1, .	x-685-7
.	x-685-8
.	x-685-9
, ik}.	x-685-10
Note that the special case of gen 1:b Exercises is a test of whether I is nonempty.	x-685-11
In some research in AI, the primitive mechanism for accessing relations is based on generators that are viewed as producing a stream of tuples as output.	x-685-12
For example, the query {x, y, z | R(x, y) ∧ S(y, z)} can be computed using the algorithm for each tuple x, y generated by gen 1:x,2:y(R) for each value z generated by gen 1:y(S) output x, y, z end for each end for each Develop an algorithm for translating calculus queries into programs using generators.	x-685-13
Describe syntactic restrictions on the calculus that ensure that your algorithm succeeds.	x-686-1
Give a formal definition for the syntax of the tuple calculus and for the relativized interpretation, active domain, and domain-independent semantics.	x-687-1
Develop an analog of safe range.	x-687-2
Prove the equivalence of conventional calculus and tuple calculus under all of these semantics.	x-687-3
Exercise 5.24 Prove that the relational calculus and the family of nr-datalog¬ programs with single-relation output have equivalent expressive power by using direct simulations between the two families.	x-688-1
gen(x, ϕ) if ϕ = R(u) for some R ∈ R and x ∈ free(ϕ) gen(x, ¬ϕ) if gen(x, pushnot(¬ϕ)) gen(x, ∃yϕ) if x, y are distinct and gen(x, ϕ) gen(x, ∀yϕ) if x, y are distinct and gen(x, ϕ) gen(x, ϕ ∨ ψ) if gen(x, ϕ) and gen(x, ψ) gen(x, ϕ ∧ ψ) if gen(x, ϕ) or gen(x, ψ), where pushnot(¬ϕ) is defined in the natural manner to be the result of pushing the negation into the next highest level logical connective (with consecutive negations cancelling each other) unless ϕ is an atom (using the rewrite rules 5, 6, 7, 10, and 11 from Fig.	x-689-1
5.1).	x-689-2
A formula ϕ is allowed	x-689-3
In [VanGT91, EHJ93] a translation of allowed formulas into the algebra is presented.)	x-690-1
x | ϕ} be with DNF matrix using the rewrite rules of Fig.	x-691-1
5.1; and similarly let ϕ CNF = be the result of transforming ϕ into PNF with CNF matrix.	x-691-2
The query q is range restricted if (i) each free variable x in ϕ occurs in a positive literal (other than x = y) in every Di; (ii) each existentially quantified variable x in ϕ DNF occurs in a positive literal (other than x = y) in every Di where x occurs; and	x-691-3
Prove that range-restricted queries are domain independent.	x-692-1
(In [VanGT91] a translation of the range-restricted queries into the algebra is presented.)	x-692-2
Exercise 5.27 q1 = {x | ∀y(R(100, y) → S(x, y))} q2 = { | ∃x∀y(R(100, y) → S(x, y))}	x-693-1
Exercise 5.28	x-694-1
Write algebra and calculus queries that express this query.	x-695-1
Exercise 5.29 We consider constraint databases involving polynomial inequalities over the reals.	x-696-1
Let I1 = {(9x2 + 4x	x-696-2
Exercises whose semantics are equal to semd(t).	x-697-1
Exercise 5.32 domn − I .	x-698-1
(The analogous operator is defined for the named algebra.)	x-698-2
Prove that the calculus under the natural interpretation is equivalent to the algebra with operators {σ, π, ×, ∪,c }.	x-698-3
The query even is defined over R as follows: even(I ) = {} (i.e., yes) if |I | is even; and even(I ) = {} (i.e., no) otherwise.	x-699-1
Exercise 5.35	x-700-1
For a Boolean algebra, define x ≤ y to mean x ∧ y = x.	x-701-1
Let the diagonals dij be defined by the statement, “for each i, j , dij = σA (Cn)”; and let the i =Aj ith cylinder Ci be defined for each I by the statement, “CiI is the relation over RC defined by CiI = {t | πA i ) ∈ C}.”	x-702-1
h(R2) and (2) if A1 ∈ sort(R), then h(πA (R)) = C	x-703-1
Optimization Do you guys mean real optimization?	x-704-1
Riccardo: Well, most of the time it’s local maneuvering.	x-705-1
Vittorio: But sometimes we go beyond incremental reform .	x-706-1
.	x-706-2
.	x-706-3
Sergio:	x-707-1
This chapter examines the conjunctive and first-order queries from the perspective of static analysis (in the sense of programming languages).	x-708-1
It is shown that many properties of conjunctive queries (e.g., equivalence, containment) are decidable although they are not decidable for first-order queries.	x-708-2
Static analysis techniques are also applied here in connection with query optimization (i.e., transforming queries expressed in a high-level, largely declarative language into equivalent queries or machine instruction programs that are arguably more efficient than a naive execution of the initial query).	x-708-3
To provide background, this chapter begins with a survey of practical optimization techniques for the conjunctive queries.	x-709-1
The majority of practically oriented research and development on query optimization has been focused on variants of the conjunctive queries, possibly extended with arithmetic operators and comparators.	x-709-2
Because of the myriad factors that play a role in query evaluation, most practically successful techniques rely heavily on heuristics.	x-709-3
Next the chapter presents the elegant and important Homomorphism Theorem, which characterizes containment and equivalence between conjunctive queries.	x-710-1
This leads to the notion of tableau “minimization”: For each tableau query there is a unique (up to isomorphism) equivalent tableau query with the smallest number of rows.	x-710-2
This provides a theoretical notion of true optimality for conjunctive queries.	x-710-3
It is also shown that deciding these properties and minimizing conjunctive queries is np-complete in the size of the input queries.	x-710-4
Undecidability results are then presented for the first-order queries.	x-711-1
Although related to undecidability results for conventional first-order logic, the proof techniques used here are necessarily different because all instances considered are finite by definition.	x-711-2
The undecidability results imply that there is no hope of developing an algorithm that performs optimization of first-order queries that is complete.	x-711-3
Only limited optimization of first-order queries involving difference is provided in most systems.	x-711-4
The chapter closes by returning to a specialized subset of the conjunctive queries based on acyclic joins.	x-712-1
These have been shown to enjoy several interesting properties, some yielding insight into more efficient query processing.	x-712-2
Chapter 13 in Part D examines techniques for optimizing datalog queries.	x-713-1
Static Analysis and Optimization Issues in Practical Query Optimization Query optimization is one of the central topics of database systems.	x-714-1
A myriad of factors play a role in this area, including storage and indexing techniques, page sizes and paging protocols, the underlying operating system, statistical properties of the stored data, statistical properties of anticipated queries and updates, implementations of specific operators, and the expressive power of the query languages used, to name a few.	x-714-2
Query optimization can be performed at all levels of the three-level database architecture.	x-714-3
At the physical level, this work focuses on, for example, access techniques, statistical properties of stored data, and buffer management.	x-714-4
At a more logical level, algebraic equivalences are used to rewrite queries into forms that can be implemented more efficiently.	x-714-5
We begin now with a discussion of rudimentary considerations that affect query processing (including the usual cost measurements) and basic methods for accessing relations and implementing algebraic operators.	x-715-1
Next an optimization approach based on algebraic equivalences is described; this is used to replace a given algebraic expression by an equivalent one that can typically be computed more quickly.	x-715-2
This leads to the important notion of query evaluation plans and how they are used in modern systems to represent and choose among many alternative implementations of a query.	x-715-3
We then examine intricate techniques for implementing multiway joins based on different orderings of binary joins and on join decomposition.	x-715-4
The discussion presented in this section only scratches the surface of the rich body of systems-oriented research and development on query optimizers, indicating only a handful of the most important factors that are involved.	x-716-1
Nothing will be said about several factors, such as the impact of negation in queries, main-memory buffering strategies, and the implications of different environments (such as distributed, object oriented, real time, large main memory, and secondary memories other than conventional disks).	x-716-2
In part due to the intricacy and number of interrelated factors involved, little of the fundamental theoretical research on query optimization has found its way into practice.	x-716-3
As the field is maturing, salient aspects of query optimization are becoming isolated; this may provide some of the foothold needed for significant theoretical work to emerge and be applied.	x-716-4
The Physical Model The usual assumption of relational databases is that the current database state is so large that it must be stored in secondary memory (e.g., on disk).	x-717-1
Manipulation of the stored data, including the application of algebraic operators, requires making copies in primary memory of portions of the stored data and storing intermediate and final results again in secondary memory.	x-717-2
By far the major time expense in query processing, for a single-processor system, is the number of disk pages that must be swapped in and out of primary memory.	x-717-3
In the case of distributed systems, the communication costs typically dominate all others and become an important focus of optimization.	x-717-4
Viewed a little more abstractly, the physical level of relational query implementation involves three basic activities: (1) generating streams of tuples, (2) manipulating streams of tuples (e.g., to perform projections), and (3) combining streams of tuples (e.g., to perform joins, unions, and intersections).	x-718-1
Indexing methods, including primarily B-trees and hash indexes, can be used to reduce significantly the size of some streams.	x-718-2
Although not discussed here, it is important to consider the cost of maintaining indexes and clusterings as updates to the database occur.	x-718-3
Main-memory buffering techniques (including the partitioning of main memory into segments and paging policies such as deleting pages based on policies of least recent use and most recent use) can significantly impact the number of page I/Os used.	x-719-1
Speaking broadly, an evaluation plan (or access plan) for a query, a stored database state, and a collection of existing indexes and other data structures is a specification of a sequence of operations that will compute the answer to the query.	x-720-1
The term evaluation plan is used most often to refer to specifications that are at a low physical level but may sometimes be used for higher-level specifications.	x-720-2
As we shall see, query optimizers typically develop several evaluation plans and then choose one for execution.	x-720-3
Implementation of Algebraic Operators To illustrate the basic building blocks from which evaluation plans are constructed, we now describe basic implementation techniques for some of the relational operators.	x-721-1
Selection can be realized in a straightforward manner by a scan of the argument relation and can thus be achieved in linear time.	x-722-1
Access structures such as B-tree indexes or hash tables can be used to reduce the search time needed to find the selected tuples.	x-722-2
In the case of selections with single tuple output, this permits evaluation within essentially constant time (e.g., two or three page fetches).	x-722-3
For larger outputs, the selection may take two or three page fetches per output tuple; this can be improved significantly if the input relation is clustered (i.e., stored so that all tuples with a given attribute value are on the same or contiguous disk pages).	x-722-4
Projection is a bit more complex because it actually calls for two essentially different operations: tuple rewriting and duplicate elimination.	x-723-1
The tuple rewriting is typically accomplished by bringing tuples into primary memory and then rewriting them with coordinate values permuted and removed as called for.	x-723-2
This may yield a listing of tuples that contains duplicates.	x-723-3
If a pure relational algebra projection is to be implemented, then these duplicates must be removed.	x-723-4
One strategy for this involves sorting the list of tuples and then removing duplicates; this takes time on the order of n log n. Another approach that is faster in some cases uses a hash function that incorporates all coordinate values of a tuple.	x-723-5
Because of the potential expense incurred by duplicate elimination, most practical relational languages permit duplicates in intermediate and final results.	x-724-1
An explicit command (e.g., distinct) that calls for duplicate elimination is typically provided.	x-724-2
Even in languages that support a pure algebra, it may be more efficient to leave duplicates in intermediate results and perform duplicate elimination once as a final step.	x-724-3
The equi-join is typically much more expensive than selection or projection because two relations are involved.	x-725-1
The following naive nested loop implementation of ⊲⊳F will take time on the order of the product n1 × n2 of the sizes of the input relations I1, I2: Static Analysis and Optimization J := ∅; for each u in I1 for each v in I2 if u and v are joinable then J := J ∪ {u ⊲⊳F v}.	x-725-2
Typically this can be improved by using the sort-merge algorithm, which independently sorts both inputs according to the join attributes and then performs a simultaneous scan of both relations, outputting join tuples as discovered.	x-726-1
This reduces the running time to the order of max(n1 log n1 + n2 log n2, size of output).	x-726-2
In many cases a more efficient implementation of join can be accomplished by a variant of the foregoing nested loop algorithm that uses indexes.	x-727-1
In particular, replace the inner loop by indexed retrievals to tuples of I2 that match the tuple of I1 under consideration.	x-727-2
Cross-product in isolation is perhaps the most expensive algebra operation: The output necessarily has size the product of the sizes of the two inputs.	x-728-1
In practice this arises only rarely; it is much more common that selection conditions on the cross-product can be used to transform it into some form of join.	x-728-2
Query Trees and Query Rewriting	x-729-1
We present shortly a family of rewriting rules that illustrates the general flavor of this component of query optimizers (see Fig.	x-730-1
6.2).	x-730-2
Unlike true optimizers, however, the rules presented here focus exclusively on the algebra.	x-730-3
Later we examine the larger issue of how rules such as these are used to find optimal and near-optimal evaluation plans.	x-730-4
We shall use the SPC algebra, generalized by permitting positive conjunctive selection and equi-join.	x-731-1
A central concept used is that of query tree, which is essentially the parse tree of an algebraic expression.	x-731-2
Consider again Query (4.4), expressed here as a rule: ans(xth, xad) ← Movies(xti, “Bergman”, xac), Pariscope(xth, xti, xs), Location(xth, xad, xp).	x-731-3
q1 = π4,8σ2=“Bergman”(( Movies ⊲⊳1=2 Pariscope) ⊲⊳4=1 Location).	x-732-1
Location Location Pariscope Movies Pariscope Movies Figure 6.1: Two query trees for Query (4.4) from Chapter 4 The query tree of this expression is shown in Fig.	x-733-1
6.1(a).	x-733-2
To provide a rough idea of how evaluation costs might be estimated, suppose now that Movies has 10,000 tuples, with about 5 tuples per movie; Pariscope has about 200 tuples, and Location has about 100 tuples.	x-734-1
Suppose further that in each relation there are about 50 tuples per page and that no indexes are available.	x-734-2
Under a naive evaluation of q1, an intermediate result would be produced for each internal node of q1’s query tree.	x-735-1
In this example, then, the join of Movies and Pariscope would produce about 200 × 5 = 1000 tuples, which (being about twice as wide as the input tuples) will occupy about 40 pages.	x-735-2
The second equi-join will yield about 1000 tuples that fit 18 to a page, thus occupying about 55 pages.	x-735-3
Assuming that there are four Bergman films playing in one or two theaters each, the final answer will contain about six tuples.	x-735-4
The total number of page fetches performed here is about 206 for reading the input relations (assuming that no indexes are available) and 95 for working with the intermediate relations.	x-736-1
Consider now the query q2 whose query tree is illustrated in Fig.	x-737-1
6.1(b).	x-737-2
It is easily verified that this is equivalent to q1.	x-737-3
Intuitively, q2 was formed from q1 by “pushing” selections and projections as far “down” the tree as possible; this generally reduces the size of intermediate results and thus of computing with them.	x-737-4
Static Analysis and Optimization In this example, assuming that all (i.e., about 20) of Bergman’s films are in Movies, the selection on Movies will yield about 100 tuples; when projected these will fit onto a single page.	x-738-1
Joining with Pariscope will yield about six tuples, and the final join with Location will again yield six tuples.	x-738-2
Thus only one page is needed to hold the intermediate results constructed during this evaluation, a considerable savings over the 95 pages needed by the previous one.	x-738-3
It is often beneficial to combine several algebraic operators into a single implemented operation.	x-739-1
As a general rule of thumb, it is typical to materialize the inputs of each equi-join.	x-739-2
The equi-join itself and all unary operations directly above it in the query tree are performed before output.	x-739-3
The dashed ovals of Fig.	x-739-4
6.1(b) illustrate a natural grouping that can be used for this tree.	x-739-5
In practical systems, the implementation and grouping of operators is typically considered in much finer detail.	x-739-6
The use of different query trees and, more generally, different evaluation plans can yield dramatically different costs in the evaluation of equivalent queries.	x-740-1
Does this mean that the user will have to be extremely careful in expressing queries?	x-740-2
The beauty of query optimization is that the answer is a resounding no.	x-740-3
The user may choose any representation of a query, and the system will be responsible for generating several equivalent evaluation plans and choosing the least expensive one.	x-740-4
For this reason, even though the relational algebra is conceptually procedural, it is implemented as an essentially declarative language.	x-740-5
In the case of the algebra, the generation of evaluation plans is typically based on the existence of rules for transforming algebraic expressions into equivalent ones.	x-741-1
We have already seen rewrite rules in the context of transforming SPC and SPJR expressions into normal form (see Propositions 4.4.2 and 4.4.6).	x-741-2
A different set of rules is useful in the present context due to the focus on optimizing the execution time and space requirements.	x-741-3
In Fig.	x-742-1
6.2 we present a family of representative rewrite rules (three with inverses) that can be used for performing the transformations needed for optimization at the logical level.	x-742-2
In these rules we view cross-product as a special case of equi-join in which the selection formula is empty.	x-743-1
Because of their similarity to the rules used for the normal form results, several of the rules are shown only in abstract form; detailed formulation of these, as well as verification of their soundness, is left for the reader (see Exercise 6.1).	x-743-2
We also include the following rule: Simplify-identities: replace π1,..., arity(q)q by q; replace σi=iq by q; replace q × {} by q; replace q × {} by {}; and replace q ⊲⊳1=1∧···∧ arity(q)= arity( q)q by q.	x-743-3
Generating and Choosing between Evaluation Plans j k l l l F ′(q)) q1 ⊲⊳ q2 q2 ⊲⊳ q1 q1 ⊲⊳G σF ′(q2) q1 ⊲⊳G′ q2 l l q1 ⊲⊳G′ πk 2) Figure 6.2: Rewriting rules for SPC algebra them; and (3) select the one of lowest cost.	x-744-1
The database system then executes the selected evaluation plan.	x-744-2
In early work, the transformation rules used and the method for evaluation plan generation were essentially intermixed.	x-745-1
Motivated in part by the desire to make database systems extensible, more recent proposals have isolated the transformation rules from the algorithms for generating evaluation plans.	x-745-2
This has the advantages of exposing the semantics of evaluation plan generation and making it easier to incorporate new kinds of information into the framework.	x-745-3
Early work on estimating the cost of evaluation plans was based essentially on	x-746-1
Sideways Information Passing We close this section by considering two practical approaches to implementing multiway joins as they arise in practical query languages.	x-747-1
Much of the early research on practical query optimization was performed in connection with the System R and INGRES systems.	x-748-1
The basic building block of the query Static Analysis and Optimization languages used in these systems (SQL and Quel, respectively) takes the form of “select-from-where” clauses or blocks.	x-748-2
For example, as detailed further in Chapter 7, Query (4.4) can be expressed in SQL as select Theater, Address from Movies, Location, Pariscope where Director = “Bergman”	x-748-3
This can be translated into the algebra as a join between the three relations of the from part, using join condition given by the where and projecting onto the columns mentioned in the select.	x-749-1
Thus a typical select-from-where block can be expressed by an SPC query as π(σ j F (R1 × · · · × Rn)).	x-749-2
With such expressions, the System R query optimizer pushes selections that affect a single relation into the join and then considers evaluation plans based on left-to-right joins that have the form i2 in using different orderings Ri , .	x-750-1
.	x-750-2
.	x-750-3
, R .	x-750-4
We now present a heuristic based on “sideways in-1 in formation passing,” which is used in the System R optimizer for eliminating some possible orderings from consideration.	x-750-5
Interestingly, this heuristic has also played an important role in developing evaluation techniques for recursive datalog queries, as discussed in Chapter 13.	x-750-6
To describe the heuristic, we rewrite the preceding SPC query as a (generalized) rule that has the form where all equalities of the selection condition F are incorporated by using constants and equating variables in the free tuples u1, .	x-751-1
.	x-751-2
.	x-751-3
, un, and the expressions C1, .	x-751-4
.	x-751-5
.	x-751-6
, Cm are conditions in the selection condition F not captured in that way.	x-751-7
(This might include, e.g., inequalities and conditions based on order.)	x-751-8
We shall call the Ri(ui)’s relation atoms and the Cj ’s constraint atoms.	x-751-9
Example 6.1.1 Consider the rule	x-752-1
R( v, w, y) P( a, v) Q( b, w, x) S( x, y, z) Figure 6.3: More generally, the sideways information passing graph, or sip graph, of a rule ρ that has the form (∗) just shown has vertexes the set of relation atoms of a rule, and includes an undirected edge between atoms Ri(ui), Rj (uj ) if ui and uj have at least one variable in common.	x-753-1
Furthermore, each node with a constant appearing is specially marked.	x-753-2
The sip graph for the rule of Example 6.1.1 is shown in Fig.	x-753-3
6.3.	x-753-4
Let us assume that the sip graph for a rule ρ is connected.	x-754-1
In this case, a sideways information passing strategy ( sip strategy) for ρ is an ordering A1, .	x-754-2
.	x-754-3
.	x-754-4
, An of the atoms in the rule, such that for each j > 1, either	x-754-5
Example 6.1.2 P (a, v), Q(b, w, x), v ≤ x, R(v, w, y), S(x, y, z) P (a, v), R(v, w, y), S(x, y, z), v ≤ x, Q(b, w, x) Q(b, w, x), R(v, w, y), P (a, v), S(x, y, z), v ≤ x.	x-755-1
Static Analysis and Optimization	x-756-1
Example 6.1.3 Let us consider again the rule	x-757-1
Suppose that a left-to-right join is performed according to the sip strategy shown.	x-758-1
At different intermediate stages certain variables can be “forgotten,” because they are not used in the answer, nor are they used in subsequent joins.	x-758-2
In particular, after the third atom the variable y can be projected out, after the fourth atom v can be projected out, and after the fifth atom w and x can be projected out.	x-758-3
It is straightforward to formulate a general policy for when to project out unneeded variables (see Exercise 6.4).	x-758-4
Query Decomposition: Join Detachment and Tuple Substitution We now briefly discuss the two main techniques used in the original INGRES system for evaluating join expressions.	x-759-1
Both are based on decomposing multiway joins into smaller ones.	x-759-2
While again focusing on SPC queries of the form j F (R1 × · · · × Rn)) for this discussion, we use a slightly different notation.	x-760-1
In particular, tuple variables rather than domain variables are used.	x-760-2
We consider expressions of the form (∗∗) where s, s1, .	x-760-3
.	x-760-4
.	x-760-5
, sn are tuple variables; C1, .	x-760-6
.	x-760-7
.	x-760-8
, Cn are Boolean conditions referring to coordinates of the variables s1, .	x-760-9
.	x-760-10
.	x-760-11
, sn (e.g., s1.3 = s4.1 ∨ s2.4 = a); and T is a target condition that gives a value for each coordinate of the target variable s. It is generally assumed that none of C1, .	x-760-12
.	x-760-13
.	x-760-14
, Cn has ∧ as its parent connective.	x-760-15
i i .	x-761-1
In the INGRES optimizer, this is typically combined with other steps.	x-762-1
Join detachment is useful for separating a query into two separate queries, where the second refers to the first.	x-763-1
Consider a query that has the specialized form ans(t ) ← P1(p1), .	x-763-2
.	x-763-3
.	x-763-4
, Pm(pm), C1, .	x-763-5
.	x-763-6
.	x-763-7
, Ck, T , Q(q), R1(r1), .	x-763-8
.	x-763-9
.	x-763-10
, Rn(rn), D1, .	x-763-11
.	x-763-12
.	x-763-13
, Dl, where conditions C1, .	x-763-14
.	x-763-15
.	x-763-16
, Ck, T refer only to variables t, p1, .	x-763-17
.	x-763-18
.	x-763-19
, pm, q and D1, .	x-763-20
.	x-763-21
.	x-763-22
, Dl refer only to q, r1, .	x-763-23
.	x-763-24
.	x-763-25
, rn.	x-763-26
It is easily verified that this is equivalent to the sequence temp(q) ← Q(q), R1(r1), .	x-763-27
.	x-763-28
.	x-763-29
, Rn(rn), D1, .	x-763-30
.	x-763-31
.	x-763-32
, Dl	x-763-33
In this example, variable q acts as a “pivot” around which the detachment is performed.	x-764-1
More general forms of join detachment can be developed in which a set of variables serves as the pivot (see Exercise 6.6).	x-765-1
Tuple substitution chooses one of the underlying relations Rj and breaks the n-variable join into a set of (n − 1)-variable joins, one for each tuple in Rj .	x-766-1
Consider again a query of form (∗∗) just shown.	x-766-2
The tuple substitution of this on Ri is given by the “program” for each r inRi do	x-766-3
Here we use +← to indicate that ans is to accumulate the values stemming from all tuples r in (the value of) Ri; furthermore, r is substituted for si in all of the conditions.	x-767-1
There is an obvious trade-off here between reducing the number of variables in the join and the number of tuples in Ri.	x-768-1
In the INGRES optimizer, each of the Ri’s is considered as a candidate for forming the tuple substitution.	x-768-2
During this process single-variable conditions may be applied to the Ri’s to decrease their size.	x-768-3
Global Optimization The techniques for creating evaluation plans presented in the previous section are essentially local in their operation: They focus on clusters of contiguous nodes in a query tree.	x-769-1
In this section we develop an approach to the global optimization of conjunctive queries.	x-769-2
This allows a transformation of an algebra query that removes several joins in a single step, a capability not provided by the techniques of the previous section.	x-769-3
The global optimization technique is based on an elegant Homomorphism Theorem.	x-769-4
The Homomorphism Theorem For two queries q1, q2 over the same schema R, q1 is contained in q2, denoted q1 ⊆ q2, if for each I over R, q1(I) ⊆ q2(I).	x-770-1
Clearly, q1 ≡ q2 iff q1 ⊆ q2 and q2 ⊆ q1.	x-770-2
The Homomorphism Theorem provides a characterization for containment and equivalence of conjunctive queries.	x-770-3
We focus here on the tableau formalism for conjunctive queries, although the rule-based formalism could be used equally well.	x-771-1
In addition, although the results hold for tableau queries over database schemas involving more than one relation, the examples presented focus on queries over a single relation.	x-771-2
Recall the notion of valuation—a mapping from variables to constants extended to be the identity on constants and generalized to free tuples and tableaux in the natural fashion.	x-772-1
Static Analysis and Optimization R B R B R B R B x y x y x y x y 1 x x x y y 1 y 1 x 1 y x y x y x y x y x y x y x y q 0 = ( T 0, 〈 x, y〉) q 1 = ( T 1, 〈 x, y〉) q 2 = ( T 2, 〈 x, y〉) q ω = ( T ω, 〈 x, y〉) Figure 6.4: Tableau queries used to illustrate the Homomorphism Theorem Valuations are used in the definition of the semantics of tableau queries.	x-773-1
More generally, a substitution is a mapping from variables to variables and constants, which is extended to be the identity on constants and generalized to free tuples and tableaux in the natural fashion.	x-773-2
We begin the discussion with two examples.	x-774-1
The first presents several simple examples of the Homomorphism Theorem in action.	x-774-2
Example 6.2.1 Consider the four tableau queries shown in Fig.	x-775-1
6.4.	x-775-2
By using the Homomorphism Theorem, it can be shown that q0 ⊆ q1 ⊆ q2 ⊆ qω.	x-775-3
To illustrate the flavor of the proof of the Homomorphism Theorem, we argue informally that q1 ⊆ q2.	x-776-1
Note that there is substitution θ such that θ(T2) ⊆ T1 and θ(x, y) = x, y [e.g., let θ(x1) = θ(x2) = x1 and θ(y1) = θ(y2) = y1].	x-776-2
Now suppose that I is an instance over AB and that t ∈ q1(I ).	x-776-3
Then there is a valuation ν such that ν(T1) ⊆ I and ν(x, y) = t .	x-776-4
It follows that θ ◦ ν is a valuation that embeds T2 into I with θ ◦ ν(x, y) = t , whence t ∈ q2(I ).	x-776-5
Intuitively, the existence of a substitution embedding the tableau of q2 into the tableau of q1 and mapping the summary of q2 to the summary of q1 implies that q1 is more restrictive than q2 (or more correctly, no less restrictive than q2.)	x-777-1
Surprisingly, the Homomorphism Theorem states that this is also a necessary condition for containment (i.e., if q ⊆ q′, then q is more restrictive than q′ in this sense).	x-777-2
The second example illustrates a limitation of the techniques discussed in the previous section.	x-778-1
Example 6.2.2 Consider the two tableau queries shown in Fig.	x-779-1
6.5.	x-779-2
It can be shown that q ≡ q′ but that q′ cannot be obtained from q using the rewrite rules of the previous section (see Exercise 6.3) or the other optimization techniques presented there.	x-779-3
R B R B x x x x x y 1 x y 1 y 2 y y n–1 n y x n x q = ( T, u) q′ = ( T′ , u) Figure 6.5: Pair of equivalent tableau queries Let q = (T, u) and q′ = (T′, u′) be two tableau queries over the same schema R. A homomorphism from q′ to q is a substitution θ such that θ (T′) ⊆ T and θ (u′) = u.	x-780-1
Theorem 6.2.3 (Homomorphism Theorem) Let q = (T, u) and q′ = (T′, u′) be tab- leau queries over the same schema R. Then q ⊆ q′ iff there exists a homomorphism from (T′, u′) to (T, u).	x-781-1
Proof Suppose first that there exists a homomorphism θ from q′ to q.	x-782-1
Let I be an instance over R. To see that q(I) ⊆ q′(I), suppose that w ∈ q(I).	x-782-2
Then there is a valuation ν that embeds T into I such that ν(u) = w. It is clear that θ ◦ ν embeds T′ into I and θ ◦ ν(u′) = w, whence w ∈ q′(I) as desired.	x-782-3
For the opposite inclusion, suppose that q ⊆ q′ [i.e., that (T, u) ⊆ (T′, u′)].	x-783-1
Speaking intuitively, we complete the proof by applying both q and q′ to the “instance” T. Because q will yield the free tuple u, q′ also yields u (i.e., there is an embedding θ of T′ into T that maps u′ to u).	x-783-2
To make this argument formal, we construct an instance IT that is isomorphic to T.	x-783-3
Let V be the set of variables occurring in T. For each x ∈ V , let ax be a new distinct constant not occurring in T or T′.	x-784-1
Let µ be the valuation mapping each x to ax, and let IT = µ(T).	x-784-2
Because µ is a bijection from V to µ(V ), and because µ(V ) has empty intersection with the constants occurring in T, the inverse µ−1 of µ is well defined on adom(IT).	x-784-3
It is clear that µ(u) ∈ q(IT), and so by assumption, µ(u) ∈ q′(IT).	x-785-1
Thus there is a valuation ν that embeds T′ into IT such that ν(u′) = µ(u).	x-785-2
It is now easily verified that ν ◦ µ−1 is a homomorphism from q′ to q.	x-785-3
Permitting a slight abuse of notation, we have the following (see Exercise 6.8).	x-786-1
Corollary 6.2.4 For tableau queries q = (T, u) and q′ = (T′, u′), q ⊆ q′ iff u ∈ q′(T).	x-787-1
Static Analysis and Optimization We also have Corollary 6.2.5 Tableau queries q, q′ over schema R are equivalent iff there are homomorphisms from q to q′ and from q′ to q.	x-788-1
In particular, if q = (T, u) and q′ = (T′, u′) are equivalent, then u and u′ are identical up to one-one renaming of variables.	x-789-1
Only one direction of the preceding characterization holds if the underlying domain is finite (see Exercise 6.12).	x-790-1
In addition, the direct generalization of the theorem to tableau queries with equality does not hold (see Exercise 6.9).	x-790-2
Query Optimization by Tableau Minimization	x-791-1
We note first that there are simple algorithms for translating tableau queries into (satisfiable) SPC queries and vice versa.	x-792-1
More specifically, given a tableau query, the corresponding generalized SPC query has the form π(σ j F (R1 × · · · × Rk)), where each component Ri corresponds to a distinct row of the tableau.	x-792-2
For the opposite direction, one algorithm for translating SPC queries into tableau queries is first to translate into the normal form for generalized SPC queries and then into a tableau query.	x-792-3
A more direct approach that inductively builds tableau queries corresponding to subexpressions of an SPC query can also be developed (see Exercise 4.18).	x-792-4
Analogous remarks apply to SPJR queries.	x-792-5
The goal of the optimization presented here is to minimize the number of rows in the tableau.	x-793-1
Because the number of rows in a tableau query is one more than the number of joins in the SPC (SPJR) query corresponding to that tableau (see Exercise 4.18c), the tableau minimization procedure provides a way to minimize the number of joins in SPC	x-793-2
Surprisingly, we show that an optimal tableau query equivalent to tableau query q can be obtained simply by eliminating some rows from the tableau of q.	x-794-1
We say that a tableau query (T, u) is minimal if there is no query (S, v) equivalent to (T, u) with |S| < |T| (i.e., where S has strictly fewer rows than T).	x-795-1
We can now demonstrate the following.	x-796-1
Theorem 6.2.6 Let q = (T, u) be a tableau query.	x-797-1
Then there is a subset T′ of T such that q′ = (T′, u) is a minimal tableau query and q′ ≡ q.	x-797-2
Proof Let (S, v) be a minimal tableau that is equivalent to q.	x-798-1
By Corollary 6.2.5, there are homomorphisms θ from q to (S, v) and λ from (S, v) to q.	x-798-2
Let T′ = θ ◦ λ(S).	x-798-3
It is straightforward to verify that (T′, u) ≡ q and |T′| ≤ |S|.	x-798-4
By minimality of (S, v), it follows that |T′| = |S|, and (T′, u) is minimal.	x-798-5
Example 6.2.7 illustrates how one might minimize a tableau by hand.	x-799-1
R B C u1 x2 y1 u2 x y1 u3 x1 y u4 x y2 u5 x2 y2 u x y Figure 6.6: The tableau (T , u) Example 6.2.7 Let R be a relation schema of sort ABC and (T , u) the tableau over R in Fig.	x-800-1
6.6.	x-800-2
To minimize (T , u), we wish to detect which rows of T can be eliminated.	x-800-3
Consider u1.	x-801-1
Suppose there is a homomorphism θ from (T , u) onto itself that eliminates u1 [i.e., u1 ∈ θ (T )].	x-801-2
Because any homomorphism on (T , u) is the identity on u, θ (z) = z.	x-801-3
Thus θ (u1) must be u5.	x-802-1
But then θ(y1) = y2, and θ(u2) ∈ {u4, u5}.	x-802-2
In particular, θ(z1) ∈	x-802-3
The preceding theorem suggests an improvement over the optimization strategies described in Section 6.1.	x-803-1
Specifically, given a (satisfiable) conjunctive query q, the following steps can be used:	x-803-2
Example 6.2.8 Consider the relation schema R of sort ABC and the SPJR query q over R:	x-804-1
Static Analysis and Optimization R B C x x1 x1 u x Figure 6.7: Tableau equivalent to q The tableau (T , u) corresponding to it is that of Fig.	x-805-1
6.7.	x-805-2
To minimize (T , u), we wish to find a homomorphism that ”folds” T onto a subtableau with minimal number of rows.	x-805-3
(If desired, this can be done in several stages, each of which eliminates one or more rows.)	x-805-4
Note that the first row cannot be eliminated because every homomorphism is the identity on u and therefore on x.	x-805-5
A similar observation holds for the third row.	x-805-6
However, the second row can be eliminated using the homomorphism that maps z2 to z and is the identity everywhere else.	x-805-7
Thus the minimal tableau equivalent to (T , u) consists of the first and third rows of T .	x-805-8
An SPJR query equivalent to the minimized tableau is πAB(σB=5(R)) ⊲⊳ πBC(σB=5(R)).	x-805-9
Thus the optimization procedure resulted in saving one join operation.	x-806-1
Before leaving minimal tableau queries, we present a result that describes a strong correspondence between equivalent minimal tableau queries.	x-807-1
Two tableau queries (T, u), (T′, u′) are isomorphic if there is a one-one substitution θ that maps variables to variables such that θ ((T, u)) = (T′, u′).	x-807-2
In other words, (T , u) and (T ′, u′) are the same up to renaming of variables.	x-807-3
The proof of this result is left to the reader (see Exercise 6.11).	x-807-4
Proposition 6.2.9 Let q = (T, u) and q′ = (T′, u′) be minimal and equivalent.	x-808-1
Then q and q′ are isomorphic.	x-808-2
Complexity of Tableau Decision Problems The following theorem shows that determining containment and equivalence between tableau queries is np-complete and tableau query minimization is np-hard.	x-809-1
Theorem 6.2.10 The following problems, given tableau queries q, q′, are np-complete: (a) Is q ⊆ q′?	x-810-1
These results remain true if q, q′ are restricted to be single-relation typed tableau queries that have no constants.	x-811-1
Proof The proof is based on a reduction from the “exact cover” problem to the different tableau problems.	x-812-1
The exact cover problem is to decide, given a set X = {x1, .	x-812-2
.	x-812-3
.	x-812-4
, xn} and a collection S = {S1, .	x-812-5
.	x-812-6
.	x-812-7
, Sm} of subsets of X such that ∪S = X, whether there is an exact cover of X by S (i.e., a subset S′ of S such that each member of X occurs in exactly one member of S′).	x-812-8
The exact cover problem is known to be np-complete.	x-812-9
We now sketch a polynomial transformation from instances E = (X, S) of the exact cover problem to pairs qE, q′ of typed tableau queries.	x-813-1
This construction is then applied E in various ways to obtain the np-completeness results.	x-813-2
The construction is illustrated in Fig.	x-813-3
6.8.	x-813-4
Let E = (X, S) be an instance of the exact cover problem, where X = {x1, .	x-814-1
.	x-814-2
.	x-814-3
, xn} and S = {S1, .	x-814-4
.	x-814-5
.	x-814-6
, Sm}.	x-814-7
Let A1, .	x-814-8
.	x-814-9
.	x-814-10
, An, B1, .	x-814-11
.	x-814-12
.	x-814-13
, Bm be a listing of distinct attributes, and let R be chosen to have this set as its sort.	x-814-14
Both qE and q′ are over relation R, and both queries E have as summary t = A1 : a1, .	x-814-15
.	x-814-16
.	x-814-17
, An : an, where a1, .	x-814-18
.	x-814-19
.	x-814-20
, an are distinct variables.	x-814-21
Let b1, .	x-815-1
.	x-815-2
.	x-815-3
, bm be an additional set of m distinct variables.	x-815-4
The tableau TE of qE has n tuples, each corresponding to a different element of X.	x-815-5
The tuple for xi has ai for attribute Ai; bj for attribute Bj for each j such that xi ∈ Sj ; and a new, distinct variable for all other attributes.	x-815-6
Let c1, .	x-816-1
.	x-816-2
.	x-816-3
, cm be an additional set of m distinct variables.	x-816-4
The tableau T ′ of q′ has m E E tuples, each corresponding to a different element of S. The tuple for Sj has ai for attribute Ai for each i such that xi ∈ Sj ; cj′ for attribute Bj′ for each j ′ such that j ′ = j ; and a new, distinct variable for all other attributes.	x-816-5
To illustrate the construction, let E = (X, S) be an instance of the exact cover problem, where X = {x1, x2, x3, x4} and S = {S1, S2, S3} where S1 = {x1, x3} S2 = {x2, x3, x4} S3 = {x2, x4}.	x-817-1
The tableau queries qξ and q′ corresponding to (X, S) are shown in Fig.	x-818-1
6.8.	x-818-2
(Here the ξ blank entries indicate distinct, new variables.)	x-818-3
Note that ξ = (X, S) is satisfiable, and q′ ⊆ q	x-818-4
More generally, it is straightforward to verify that for a given instance ξ = (X, S) of the exact cover problem, X has an exact cover in S iff q′ ⊆ q parts (b) and (c) of the theorem, is left for Exercise 6.16.	x-819-1
Static Analysis and Optimization R R b 1 c c 3 b 2 b 3 c c 3 b 1 b 2 c c 2 b 2 b 3 q ξ q′ξ Figure 6.8: Tableau queries corresponding to an exact cover data.	x-820-1
Given an n-way join, the System R optimizer may potentially consider n!	x-820-2
evaluation strategies based on different orderings of the n relations; this may be exponential in the size of the query.	x-820-3
In many cases, the search for a minimal tableau (or optimal left-to-right join) may be justified because the data is so much larger than the initial query.	x-820-4
More generally, in Part D we shall examine both “data complexity” and “expression complexity,” where the former focuses on complexity relative to the size of the data and the latter relative to the size of queries.	x-820-5
Static Analysis of the Relational Calculus We now demonstrate that the decidability results for conjunctive queries demonstrated in the previous section do not hold when negation is incorporated (i.e., do not hold for the first-order queries).	x-821-1
In particular, we present a general technique for proving the undecidability of problems involving static analysis of first-order queries and demonstrate the undecidability of three such problems.	x-821-2
We begin by focusing on the basic property of satisfiability.	x-822-1
Recall that a query q is satisfiable if there is some input I such that q(I) is nonempty.	x-822-2
All conjunctive queries are satisfiable (Proposition 4.2.2), and if equality is incorporated then satisfiability is not guaranteed but it is decidable (Exercise 4.5).	x-822-3
This no longer holds for the calculus.	x-822-4
To prove this result, we use a reduction of the Post Correspondence Problem (PCP) (see Chapter 2) to the satisfiability problem.	x-823-1
The reduction is most easily described in terms of the calculus; of course, it can also be established using the algebras or nr-datalog¬.	x-823-2
There is, however, an important difference.	x-824-1
In conventional first-order logic (see Chapter 2), both finite and infinite interpretations are considered.	x-824-2
Satisfiability of first-order sentences is co-recursively enumerable (co-r.e.)	x-824-3
but not recursive.	x-824-4
This follows from Gödel’s Completeness Theorem.	x-824-5
In contrast, in the context of first-order queries, only finite instances are considered legal.	x-824-6
This brings us into the realm of finite model theory.	x-824-7
As will be shown, satisfiability of first-order queries is recursively enumerable (r.e.)	x-824-8
but not recursive.	x-824-9
(We shall revisit the contrast between conventional first-order logic and the database perspective, i.e., finite model theory, in Chapters 9 and 10.)	x-824-10
Theorem 6.3.1 Satisfiability of relational calculus queries is r.e.	x-825-1
but not recursive.	x-825-2
Proof To see that the problem is r.e., imagine a procedure that, when given query q over R as input, generates all instances I over R and tests q(I) = ∅ until a nonempty answer is found.	x-826-1
To show that satisfiability is not recursive, we reduce the PCP to the satisfiability problem.	x-827-1
In particular, we show that if there were an algorithm for solving satisfiability, then it could be used to construct an algorithm that solves the PCP.	x-827-2
Let P = (u1, .	x-828-1
.	x-828-2
.	x-828-3
, un; v1, .	x-828-4
.	x-828-5
.	x-828-6
, vn) be an instance of the PCP (i.e., a pair of sequences of nonempty words over alphabet {0,1}).	x-828-7
We describe now a (domain independent) calculus query qP = { | ϕP} with the property that qP is satisfiable iff P has a solution.	x-828-8
We shall use a relation schema R having relations ENC(ODING) with sort [A, B, C, D, E] and SYNCH(RONIZATION) with sort [F, G].	x-829-1
The query qP shall use constants	x-829-2
To illustrate the construction of the algorithm, consider the following instance of the PCP: u1 = 011, u2 = 011, u3 = 0; v1 = 0, v2 = 11, v3 = 01100.	x-830-1
Note that s = (1, 2, 3, 2) is a solution of this instance.	x-831-1
That is, u1u2u3u2 = 0110110011 = v1v2v3v2.	x-831-2
Figure 6.9 shows an input instance Is over R which encodes this solution and satisfies the query qP constructed shortly.	x-832-1
In the relation ENC of this figure, the first two columns form a cycle, so that the 10 tuples can be viewed as a sequence rather than a set.	x-833-1
The third column holds a listing of the word w = 0110110011 that witnesses the solution to P ; the fourth column describes which words of sequence (u1, .	x-833-2
.	x-833-3
.	x-833-4
, un) are used to obtain w; and the fifth column describes which words of sequence (v1, .	x-833-5
.	x-833-6
.	x-833-7
, vn) are used.	x-833-8
The relation SYNCH is used to synchronize the two representations of w by listing the pairs corresponding to the beginnings of new u-words and v-words.	x-833-9
The formula ϕP constructed now includes subformulas to test whether the various conditions just enumerated hold on an input instance.	x-834-1
In particular, ϕ = ϕ ENC- key ∧ ϕ cycle ∧ ϕ SYNCH- keys ∧ ϕu- encode ∧ ϕv- encode ∧ ϕu-v- synch, where, speaking informally, Static Analysis and Optimization ENC B C D E SYNCH F G c1 d1 c1 d2 c1 d2 c2 d3 c2 d3 c2 d3 c3 d3 c2 d3 c2 d2 c2 d2 Figure 6.9: Encoding of a solution to PCP	x-834-2
i | − 1 additional tuples in ENC	x-835-1
k, yk, zk, ci , djk then z1 .	x-836-1
.	x-836-2
.	x-836-3
zk = ui; none of x2, .	x-836-4
.	x-836-5
.	x-836-6
, xk occurs in the first column of SYNCH; and if yk = $, then the A value “after” xk occurs in the first column of SYNCH.	x-836-7
x and y is done as in ϕu-encode.	x-837-1
The constructions of these formulas are relatively straightforward; we give two of them here and leave the others for the reader (see Exercise 6.19).	x-838-1
In particular, we let ψ (x, y) = ∃p, q, r ENC(x, y, p, q, r)	x-838-2
If ENC satisfies ϕENC−key ∧ ϕcycle, then the first two coordinates of ENC hold one or more disjoint cycles, exactly one of which contains the value $.	x-839-1
Parts (1) and (2) of ϕu-v-synch are realized by the formula SYNCH($, $)∧	x-840-1
Verifying that the query qP is satisfiable if and only if P has a solution is left to the reader (see Exercise 6.19).	x-841-1
The preceding theorem can be applied to derive other important undecidability results.	x-842-1
Corollary 6.3.2	x-843-1
Proof It is easily verified that the two problems of part (a) and the problem of part (b) are co-r.e.	x-844-1
(see Exercise 6.20).	x-844-2
The proofs of undecidability are by reduction from the satisfiability problem.	x-844-3
For equivalence, suppose that there were an algorithm for deciding equivalence between relational calculus queries.	x-844-4
Then the satisfiability problem can be solved as follows: For each query q = {x1, .	x-844-5
.	x-844-6
.	x-844-7
, xn | ϕ}, this is unsatisfiable if and only if it is equivalent to the empty query q∅.	x-844-8
This demonstrates that equivalence is not decidable.	x-844-9
The undecidability of containment also follows from this.	x-845-1
For domain independence, let ψ be a sentence whose truth value depends on the underlying domain.	x-846-1
Then {x1, .	x-846-2
.	x-846-3
.	x-846-4
, xn | ϕ ∧ ψ} is domain independent if and only if ϕ is unsatisfiable.	x-846-5
The preceding techniques can also be used to show that “true” optimization cannot be performed for the first-order queries (see Exercise 6.20d).	x-847-1
Static Analysis and Optimization Computing with Acyclic Joins We now present a family of interesting theoretical results on the problem of computing the projection of a join.	x-848-1
In the general case, if both the data set and the join expression are allowed to vary, then the time needed to evaluate such expressions appears to be exponential.	x-848-2
The measure of complexity here is a combination of both “data” and “expression” complexity, and is somewhat non-standard; see Part D. Interestingly, there is a special class of joins, called acyclic, for which this evaluation is polynomial.	x-849-1
A number of interesting properties of acyclic joins are also presented.	x-849-2
For this section we use the named perspective and focus exclusively on flat project-join queries of the form q = πX(R1 ⊲⊳ · · · ⊲⊳ Rn) involving projection and natural join.	x-850-1
For this discussion we assume that R = R1, .	x-850-2
.	x-850-3
.	x-850-4
, Rn is a fixed database schema, and we use I = (I1, .	x-850-5
.	x-850-6
.	x-850-7
, In) to refer to instances over it.	x-850-8
One of the historical motivations for studying this problem stems from the pure universal relation assumption ( pure URA).	x-851-1
An instance I = (I1, .	x-851-2
.	x-851-3
.	x-851-4
, In) over schema R satisfies the pure URA if I = (πR (I ), .	x-851-5
.	x-851-6
.	x-851-7
, π (I )) for some “universal” instance I over ∪n R Rn j =1 j .	x-851-8
If I satisfies the pure URA, then I can be stored, and queries against the corresponding instance I can be answered using joins of components in I.	x-852-1
The URA will be considered in more depth in Chapter 11.	x-852-2
Worst-Case Results We begin with an example.	x-853-1
Example 6.4.1 Let n > 0 and consider the relations Ri[AiAi+1], i ∈ [1, n − 1], as shown in Fig.	x-854-1
6.10(a).	x-854-2
It is easily seen that the natural join of R1, .	x-854-3
.	x-854-4
.	x-854-5
, Rn−1 is exponential in n and thus exponential in the size of the input query and data.	x-854-6
Now suppose that n is odd.	x-855-1
Let Rn be as in Fig.	x-855-2
6.10(b), and consider the natural join of R1, .	x-855-3
.	x-855-4
.	x-855-5
, Rn.	x-855-6
This is empty.	x-855-7
On the other hand, the join of any i of these for i < n has size exponential in i.	x-855-8
It follows that the algorithms of the System R and INGRES optimizers take time exponential in the size of the input and output to evaluate this query.	x-855-9
The following result implies that it is unlikely that there is an algorithm for computing projections of joins in time polynomial in the size of the query and the data.	x-856-1
Theorem 6.4.2 It is np-complete to decide, given project-join expression q0 over R, instance I of R, and tuple t, whether t ∈ q0(I).	x-857-1
This remains true if q0 and I are restricted so that |q0(I)| ≤ 1.	x-857-2
Proof The problem is easily seen to be in np.	x-858-1
For the converse, recall from Theorem 6.2.10(a) that the problem of tableau containment is np-complete, even for single- Ri Rn b b b b b b b b Figure 6.10: Relations to illustrate join sizes relation typed tableaux having no constants.	x-858-2
We reduce this to the current problem.	x-858-3
Let q = (T , u) and q′ = (T ′, u′) be two typed constant-free tableau queries over the same relation schema.	x-858-4
Recall from the Homomorphism Theorem that q ⊆ q′ iff there is a homomorphism of q′ to q, which holds iff u ∈ q′(T ).	x-858-5
be a copy of T , where the ith attribute is renamed to A .	x-859-1
Letting xn xi u′ = u′ , .	x-859-2
.	x-859-3
.	x-859-4
, u′ , it is straightforward to verify that m q′(T ) = πA ,...,A (⊲⊳{Iv | v ∈ T ′}).	x-859-5
u′ u′ m In particular, u ∈ q′(T ) iff u is in this projected join.	x-860-1
To see the last sentence of the theorem, let u = u1, .	x-861-1
.	x-861-2
.	x-861-3
, um and use the query πA ,...,A (⊲⊳{Iv | v ∈ T ′} ⊲⊳ {A : u1, .	x-861-4
.	x-861-5
.	x-861-6
, A	x-861-7
u′ u′ u′ u′m m Theorem 6.2.10(a) considers complexity relative to the size of queries.	x-862-1
As applied in the foregoing result, however, the queries of Theorem 6.2.10(a) form the basis for constructing a database instance {Iv | v ∈ T ′}.	x-862-2
In contrast with the earlier theorem, the preceding result suggests that computing projections of joins is intractable relative to the size of the query, the stored data, and the output.	x-862-3
In Example 6.4.1, we may ask what is the fundamental difference between R1 ⊲⊳ · · · ⊲⊳ Rn−1 and R1 ⊲⊳ · · · ⊲⊳ Rn?	x-863-1
One answer is that the relation schemas of the latter join form a cycle, whereas the relation schemas of the former do not.	x-863-2
We now develop a formal notion of acyclicity for joins and four properties equivalent Static Analysis and Optimization to it.	x-864-1
All of these are expressed most naturally in the context of the named perspective for the relational model.	x-864-2
In addition, the notion of acyclicity is sometimes applied to database schemas R= {R1, .	x-864-3
.	x-864-4
.	x-864-5
, Rn} because of the natural correspondence between the schema R	x-864-6
We begin by describing four interesting properties that are equivalent to acyclicity.	x-865-1
Let R = {R1, .	x-866-1
.	x-866-2
.	x-866-3
, Rn} be a database schema, where each relation schema has a different sort.	x-866-4
An instance I of R is said to be pairwise consistent if for each pair j, k ∈ [1, n], πR (I j j ⊲⊳ Ik) = Ij .	x-866-5
Intuitively, this means that no tuple of Ij is “dangling” or “lost” after joining with Ik.	x-866-6
Instance I is globally consistent if for each j ∈ [1, n], πR (⊲⊳I) = I j j (i.e., no tuple of Ij is dangling relative to the full join).	x-866-7
Pairwise consistency can be checked in ptime, but checking global consistency is np-complete (Exercise 6.25).	x-866-8
The first property that is equivalent to acyclicity is: Property (1): Each instance I that is pairwise consistent is globally consistent.	x-866-9
Note that the instance for schema {R1, .	x-867-1
.	x-867-2
.	x-867-3
, Rn−1} of Example 6.4.1 is both pairwise and globally consistent, whereas the instance for {R1, .	x-867-4
.	x-867-5
.	x-867-6
, Rn} is pairwise but not globally consistent.	x-867-7
The second property we consider is motivated by query processing in a distributed environment.	x-868-1
Suppose that each relation of I is stored at a different site, that the join ⊲⊳I is to be computed, and that communication costs are to be minimized.	x-868-2
A very naive algorithm to compute the join is to send each of the Ij to a specific site and then form the join.	x-868-3
In the general case this may cause the shipment of many unneeded tuples because they are dangling in the full join.	x-868-4
The semi-join operator can be used to alleviate this problem.	x-869-1
Given instances I, J over R, S, then semi-join of I and J is I ⊲< J = πR(I ⊲⊳ J ).	x-869-2
It is easily verified that I ⊲⊳ J = (I ⊲< J ) ⊲⊳ J = (J ⊲< I ) ⊲⊳ I .	x-870-1
Furthermore there are many cases in which computing the join in one of these ways can reduce data transmission costs if I and J are at different nodes of a distributed database (see Exercise 6.24).	x-870-2
Suppose now that R satisfies Property (1).	x-871-1
Given an instance I distributed across the network, one can imagine replacing each relation Ij by its semi-join with other relations of I.	x-871-2
If done cleverly, this might be done with communication cost polynomial in the size of I, with the result of the replacements satisfying pairwise consistency.	x-871-3
Given Property (1), all relations can now be shipped to a common site, safe in the knowledge that no dangling tuples have been shipped.	x-871-4
More generally, a semi-join program for R is a sequence of commands Ri := R ⊲< R ; i1 j1 Ri := R ⊲< R ; i2 j2	x-872-1
Ri := R ⊲< R ; p ip jp R1 B C R2 B C D E R3 B C D G R4 C D E F Figure 6.11: Instance for Example 6.4.3 would be made.)	x-873-1
This is a full reducer for R if for each instance I over R, applying this program yields an instance I′ that is globally consistent.	x-873-2
Example 6.4.3 Let R = {ABC, BCDE, BCDG, CDEF } = {R1, R2, R3, R4} and con- sider the instance I of R shown in Fig.	x-874-1
6.11.	x-874-2
I is not globally consistent; nor is it pairwise consistent.	x-874-3
R2 := R2 ⊲< R1; R2 := R2 ⊲< R4; R3 := R3 ⊲< R2; R2 := R2 ⊲< R3; R4 := R4 ⊲< R2; R1 := R1 ⊲< R2; Note that application of this program to I has the effect of removing the first tuple from each relation.	x-875-1
We can now state the second property: Property (2): R has a full reducer.	x-876-1
It can be shown that the schema {R1, .	x-877-1
.	x-877-2
.	x-877-3
, Rn−1} of Example 6.4.1 has a full reducer, but {R1, .	x-877-4
.	x-877-5
.	x-877-6
, Rn} does not (see Exercise 6.26).	x-877-7
The next property provides a way to view a schema as a tree with certain properties.	x-878-1
Property (3): R has a join tree.	x-879-1
For example, two join trees of the schema R of Figure 6.11 are T1 = (R, {(R1, R2), (R2, R3), (R2, R4)}) and T2 = (R, {(R1, R3), (R3, R2), (R2, R4)}).	x-880-1
(The edge labels are not shown.)	x-880-2
Static Analysis and Optimization B F B C C D E R 1[ AB], R 2[ BC], R 3[ AC] S 1[ ABC], S 2[ CDE], S 3[ AFE], S 4[ ACE] B D C T 1[ ABC], T 2[ BCD], T 3[ ABD], T 4[ ACD] Figure 6.12: Three schemas and their hypergraphs The fourth property we consider focuses entirely on the database schema R and is based on a simple algorithm, called the GYO algorithm.1 This is most easily described in terms of the hypergraph corresponding to R. A hypergraph is a pair F = (V , F ), where V is a set of vertexes and F is family of distinct nonempty subsets of V , called edges (or hyperedges).	x-881-1
The hypergraph of schema R is the pair (U, R), where U = ∪R.	x-881-2
In what follows, we often refer to a database schema R as a hypergraph.	x-881-3
Three schemas and their hypergraphs are shown in Fig.	x-881-4
6.12.	x-881-5
Suppose that R is a schema and I over R satisfies the pure URA.	x-882-1
If Rj ⊂ Rk, then Ij =	x-882-2
j k), and thus Ij holds redundant information.	x-883-1
It is thus natural in this context to assume that R, viewed as a hypergraph, is reduced.	x-883-2
In this case, f ′ is called a witness that f is an ear.	x-884-1
As a special case, if there is an edge f of F that intersects no other edge, then f is also considered an ear.	x-884-2
For example, in the hypergraph of Fig.	x-885-1
6.12(b), edge ABC is an ear, with witness ACE.	x-885-2
On the other hand, the hypergraph of Fig.	x-886-1
6.12(a) has no ears.	x-886-2
We now have Input: Hypergraph F = (V , F ) Output: A hypergraph involving a subset of edges of F Do until F has no ears:	x-887-1
The output of the GYO algorithm is always reduced.	x-888-1
We now state the following: Property (4): The output of the GYO algorithm on R is empty.	x-889-1
Speaking informally, Example 6.4.1 suggests that an absence of cycles yields Properties (1) to (4), whereas the presence of a cycle makes these properties fail.	x-890-1
This led researchers in the late 1970s to search for a notion of acyclicity for hypergraphs that both generalized the usual notion of acyclicity for conventional undirected graphs and was equivalent to one or more of the aforementioned properties.	x-890-2
For example, the conventional notion of hypergraph acyclicity from graph theory is due to C. Berge; but it turns out that this condition is necessary but not sufficient for the four properties (see Exercise 6.32).	x-890-3
We now define the notion of acyclicity that was found to be equivalent to the four aforementioned properties.	x-891-1
Let F = (V , F ) be a hypergraph.	x-891-2
A path in F from vertex v to vertex v′ is a sequence of k ≥ 1 edges f1, .	x-891-3
.	x-891-4
.	x-891-5
, fk such that	x-891-6
Two vertexes are connected in F if there is a path between them.	x-892-1
The notions of connected pair of edges, connected component, and connected hypergraph are now defined in the usual manner.	x-892-2
Now let F = (V , F ) be a hypergraph, and U ⊆ V .	x-893-1
The restriction of F to U , denoted F |U , is the result of forming the reduction of (U, {f ∩ U | f ∈ F } − {∅}).	x-893-2
Static Analysis and Optimization Let F = (V , F ) be a reduced hypergraph, let f, f ′ be distinct edges, and let g = f ∩ f ′.	x-894-1
Then g is an articulation set of F if the number of connected components of F |V −g is greater than the number of connected components of F .	x-894-2
(This generalizes the notion of articulation point for ordinary graphs.)	x-894-3
Finally, a reduced hypergraph F = (V , F ) is acyclic if for each U ⊆ V , if F |U is connected and has more than one edge then it has an articulation set; it is cyclic otherwise.	x-895-1
Note that if F = (V , F ) is an acyclic hypergraph, then so is F |U for each U ⊆ V .	x-896-1
Property (5): The hypergraph corresponding to R is acyclic.	x-897-1
We now present the theorem stating the equivalence of these five properties.	x-898-1
Additional equivalent properties are presented in Exercise 6.31 and in Chapter 8, where the relationship of acyclicity with dependencies is explored.	x-898-2
Theorem 6.4.5 Properties (1) through (5) are equivalent.	x-899-1
Proof We sketch here arguments that (4) ⇒ (2) ⇒ (1) ⇒ (5) ⇒ (4).	x-900-1
The equivalence of (3) and (4) is left as Exercise 6.30(a).	x-900-2
We assume in this proof that the hypergraphs considered are connected; generalization to the disconnected case is straightforward.	x-901-1
T1 := T1 ⊲< S1; T2 := T2 ⊲< S2;	x-902-1
Tn−1 := Tn−1 ⊲< Sn−1; Sn−1 := Sn−1 ⊲< Tn−1;	x-903-1
S2 := S2 ⊲< T2; S1 := S1 ⊲< T1;	x-904-1
But by pairwise consistency, each step of the full reducer leaves I unchanged.	x-905-1
It follows that I = I′ is globally consistent.	x-905-2
I	x-906-1
B1	x-907-1
Bq	x-908-1
p	x-909-1
p Figure 6.13: Instance for proof of Theorem 6.4.5 It follows easily from the minimality conditions that R is reduced.	x-910-1
In addition, by minimality no vertex (attribute) in U is in only one edge (relation schema).	x-910-2
Consider now the schema R′ = {R2 − R1, .	x-911-1
.	x-911-2
.	x-911-3
, Rn − R1}.	x-911-4
Two cases arise: Case 1: R′ is connected.	x-911-5
Suppose that R1 = {A1, .	x-911-6
.	x-911-7
.	x-911-8
, Ap} and U − R1 = {B1 .	x-911-9
.	x-911-10
.	x-911-11
, Bq}.	x-911-12
Consider the instance I over U shown in Fig.	x-912-1
6.13.	x-912-2
Define I = {I1, .	x-912-3
.	x-912-4
.	x-912-5
, In} so that Ij = πR (I ) for j ∈ [2, n], and j I1 = πR (I ) ∪ {0, 0, .	x-912-6
.	x-912-7
.	x-912-8
, 0}.	x-912-9
Using the facts that R′ is connected and that each vertex of R occurs in at least two edges, it is straightforward to verify that I is pairwise consistent but not globally consistent, which is a contradiction (see Exercise 6.30b).	x-913-1
Case 2: R′ is not connected.	x-914-1
Choose a connected component of R′ and let {S1, .	x-914-2
.	x-914-3
.	x-914-4
, Sk} be the set of edges of R − {R1} involved in that connected component.	x-914-5
Let S = ∪k S i=1 i and let R′ = R Subcase 2.a: R′ ⊆ S j for some j ∈ [1, k].	x-914-6
If this holds, then R′1 j is an articulation set for R, which is a contradiction (see Exercise 6.30b).	x-914-7
Subcase 2.b: R′ ⊆ S j for each j ∈ [1, k].	x-915-1
In this case R′′ = {S1, .	x-915-2
.	x-915-3
.	x-915-4
, Sk, R′1 hypergraph with fewer edges than R. In addition, it can be verified that this hypergraph satisfies Property (1) (see Exercise 6.30b).	x-915-5
By minimality of n, this implies that R′′ is acyclic.	x-915-6
Because it is connected and has at least two edges, it has an articulation set.	x-915-7
Two nested subcases arise: Subcase 2.b.i: Si ∩ Sj is an articulation pair for some i, j .	x-915-8
We argue in this case that Si ∩ Sj is an articulation pair for R. To see this, let x ∈ R′ − (S i ∩ Sj ) and let y be a vertex in some other component of R′′|S−{S i ∩Sj }.	x-915-9
Suppose that Ri1 il y to x.	x-915-10
Let Ri be the first edge in this path that is not in {S p p	x-915-11
Subcase 2.b.ii: R′ ∩ S i is an articulation pair for some i.	x-916-1
In this case R1 ∩ Si is an	x-916-2
Static Analysis and Optimization	x-917-1
It is easily verified that g′ is an ear of F (see Exercise 6.30b).	x-918-1
Because F |V −h has more than two connected components, it follows that F has at least two ears.	x-918-2
Finally, suppose that F = (V , F ) is acyclic.	x-919-1
If there is only one edge, then the GYO	x-919-2
Recall from Theorem 6.4.2 that computing projections of arbitrary joins is probably intractable if both query and data size are considered.	x-920-1
The following shows that this is not the case when the join is acyclic.	x-920-2
Corollary 6.4.6 If R is acyclic, then for each instance I over R, the expression πX(⊲⊳I) can be computed in time polynomial in the size of IR, the input, and the output.	x-921-1
Proof Because the computation for each connected component of R can be performed separately, we assume without loss of generality that R is connected.	x-922-1
Let R=(R1, .	x-922-2
.	x-922-3
.	x-922-4
, Rn) and I = (I1, .	x-922-5
.	x-922-6
.	x-922-7
, In).	x-922-8
First apply a full reducer to I to obtain I′ = (I ′, .	x-922-9
.	x-922-10
.	x-922-11
, I ′ n).	x-922-12
This takes time polynomial in the size of the query and the input; the result is globally consistent; and	x-922-13
Because R is acyclic, by Theorem 6.4.5 there is a join tree T for R. Choose a root for T , say R1.	x-923-1
For each subtree Tk of T with root Rk = R1, let Xk = X ∩ (∪{R | R ∈ Tk}), and Zk = Rk∩ (the parent of Rk).	x-923-2
Let Jk = I ′ for k ∈ [1, n].	x-923-3
Inductively remove nodes R k k J kZk k. A straightforward induction shows that immediately before nonleaf node Rk is deleted, then Jk = πX I ′).	x-923-4
It follows that at the end kRk Rl∈Tk l of this process the answer is πXJ1 and that at each intermediate stage each instance Jk has size bounded by |I ′| · |π k X(⊲⊳IIk)| (see Exercise 6.33).	x-923-5
Bibliographic Notes	x-924-1
The paper [SAC+79] describes query optimization in System/R, including a discussion of generating and analyzing multiple evaluation plans and a thorough discussion of accessing tuples from a single relation, as from a projection and selection.	x-925-1
System/R is the precursor of IBM’s DB2 database management system.	x-925-2
The optimizer for INGRES introduces query decomposition, including both join detachment and tuple substitution [WY76, SWKH76].	x-925-3
Bibliographic Notes The use of semi-joins in query optimization was first introduced in INGRES [WY76, SWKH76] and used for distributed databases in [BC81, BG81].	x-926-1
Research on optimizing buffer management policies includes [FNS91, INSS92, NCS91, Sto81].	x-926-2
Other system optimizers include those for Exodus [GD87], distributed INGRES [ESW78], SDD-1	x-926-3
The recent work [IK90] focuses on finding optimal and near-optimal evaluation plans for n-way joins, where n is in the hundreds, using simulated annealing and other techniques.	x-927-1
Perhaps most interesting about this work are characterizations of the space of evaluation plans (e.g., properties of evaluation plan cost in relation to natural metrics on this space).	x-927-2
Early research on generation and selection of query evaluation plans is found in	x-928-1
Many forward-chaining expert systems in AI also face the problem of evaluating what amounts to conjunctive queries.	x-929-1
The most common technique for evaluating conjunctive queries in this context is based on a sequential generate-and-test algorithm.	x-929-2
The paper	x-929-3
The technique of tableau query minimization was first developed in connection with database queries in [CM77], including the Homomorphism Theorem (Theorem 6.2.3) and Theorem 6.2.6.	x-930-1
Theorem 6.2.10 is also due to [CM77]; the proofs sketched in the exercises are due to [SY80] and [ASU79b].	x-930-2
Refinements of this result (e.g., to subclasses of typed tableau queries) are presented in [ASU79b, ASU79a].	x-930-3
The notion of tableau homomorphism is a special case of the notion of subsumption used in resolution theorem proving [CL73].	x-931-1
That work focuses on clauses (i.e., disjunctions of positive and negative literals), and permits function symbols.	x-931-2
A clause C = (L1 ∨ · · · ∨ Ln) subsumes a clause D = (M1 ∨ · · · ∨ Mk) if there is a substitution σ such that Cσ is a subclause of D. A generalized version of tableau minimization, called condensation, also arises in this connection.	x-931-3
A condensation of a clause C = (L1 ∨ · · · ∨ Ln) is a clause C′ = (Li ∨ · · · ∨ L ) with m minimal such that C′ = Cθ for some substitution θ .	x-931-4
As 1 im observed in [Joy76], condensations are unique up to variable substitution.	x-931-5
Reference [SY80] studies restricted usage of difference with SPCU queries, for which several positive results can be obtained (e.g., decidability of containment; see Exercise 6.22).	x-932-1
The undecidability results for the relational calculus derive from results in [DiP69] Static Analysis and Optimization instance, the test for containment is co-r.e.	x-933-1
in our context whereas it is r.e.	x-933-2
when possibly infinite structures are considered.	x-933-3
(This is by reduction to the validity of a formula in first-order predicate logic with equality using the Gödel Completeness Theorem.	x-933-4
The complexity of query languages is studied in [CH82, Var82a] and is considered in Part E of this volume.	x-934-1
D -hard.	x-935-1
On the other hand, two conjunctive queries are equivalent under the bag semantics iff they are isomorphic.	x-935-2
The notion of Berge acyclic is due to [Ber76a].	x-936-1
[Fag83] investigates several notions of acyclicity, including the notion studied in this chapter and Berge acyclicity.	x-936-2
Further investigation of these alternative notions of acyclicity is presented in [ADM85, DM86b, GR86].	x-936-3
Early attempts to develop a notion of acyclic that captured desirable database characteristics include [Zan76, Gra79].	x-936-4
The relationship of acyclicity with dependencies is considered in Chapter 8.	x-937-1
Many variations of the universal relation assumption arose in the late 1970s and early 1980s.	x-938-1
We return to this topic in Chapter 11; surveys of these notions include [AP82, Ull82a, MRW86].	x-938-2
Exercises Exercise 6.1	x-939-1
Exercises Exercise 6.2 Consider the transformation σF (q1 ⊲⊳G q2) → σF (q1) ⊲⊳G q2 of Fig.	x-940-1
6.2.	x-940-2
Describe a query q and database instance for which applying this transformation yields a query whose direct implementation is dramatically more expensive than that of q.	x-940-3
Exercise 6.3	x-941-1
Exercise 6.4 Present an algorithm that identifies when variables can be projected out during a left-to-right join of a sip strategy.	x-942-1
Exercise 6.5 Describe a generalization of sip strategies that permits evaluation of multiway joins according to an arbitrary binary tree rather than using only left-to-right join processing.	x-943-1
Give an example in which this yields an evaluation plan more efficient than any left-to-right join.	x-944-1
Exercise 6.6 Consider query expressions that have the form (†) mentioned in the discussion of join detachment in Section 6.1.	x-945-1
Exercise 6.7	x-946-1
Exercise 6.8 Prove Corollary 6.2.4.	x-947-1
Exercise 6.9	x-948-1
Exercise 6.10 For queries q, q′, write q ⊂ q′ to denote that q ⊆ q′ and q ≡ q′.	x-949-1
The meaning of q ⊃ q′ is defined analogously.	x-949-2
Static Analysis and Optimization	x-950-1
ing no constants over a single relation such that q′ ⊆ q′ and q′ ⊆ q′ for each pair i j j i i = j .	x-951-1
ing no constants over a single relation with the property that q′′ ⊃ q′′ ⊃ q′′ ⊃ .	x-952-1
.	x-952-2
.	x-952-3
.	x-952-4
Exercise 6.11	x-953-1
Exercise 6.12	x-954-1
to q.	x-955-1
In addition, do this using typed tableau queries.	x-955-2
Exercise 6.13 Let R be a relation schema of sort ABC.	x-956-1
For each of the following SPJR queries over R, construct an equivalent tableau (see Exercise 4.19), minimize the tableau, and construct from the minimized tableau an equivalent SPJR query with minimal number of joins.	x-956-2
Exercise 6.15 Exhibit a pair of typed restricted SPJ algebra queries q1, q2 over a relation R	x-957-1
Exercises	x-958-1
q′′ ≡ q′ .	x-959-1
Exercise 6.17	x-960-1
Exercise 6.18	x-961-1
i=1 Xi operations among all such queries is np-hard.	x-962-1
Exercise 6.19	x-963-1
Exercise 6.20 This exercise develops further undecidability results for the relational calculus.	x-964-1
Static Analysis and Optimization is not simple.	x-965-1
Exercise 6.23 Recall from Exercise 5.9 that an arbitrary nonrecursive datalog¬ rule can be described as a difference q1 − q2, where q1 is an SPC query and q2 is an SPCU query.	x-966-1
Hint: Use Exercise 6.22.	x-967-1
programs.	x-968-1
Exercise 6.24	x-969-1
Exercise 6.25	x-970-1
Exercise 6.26 Prove the following without using Theorem 6.4.5.	x-971-1
Exercise 6.27	x-972-1
Exercises Exercise 6.28 Prove that the output of Algorithm 6.4.4 is independent of the nondeterministic choices.	x-973-1
Exercise 6.29 until neither can be applied then F := (V − {v}, (F − {f } ∪ {f − {v}}) − {∅}).	x-974-1
then F := (V , F − {f }).	x-975-1
The result of applying the original GYO algorithm to a schema R is the GYO reduction of R.	x-976-1
Exercise 6.30 This exercise completes the proof of Theorem 6.4.5.	x-977-1
Exercise 6.31 Rj .	x-978-1
In other words, the intersection of each R s is contained i i with the union of the previous R′j in one of these.	x-978-2
Prove that R has the running intersection property iff R is acyclic.	x-978-3
Exercise 6.32	x-979-1
Exercise 6.33	x-980-1
Languages What do you mean by practical languages?	x-981-1
Riccardo: select from where .	x-982-1
That’s it?	x-983-1
Vittorio: Well, there are of course lots of bells and whistles.	x-984-1
Sergio: But basically, this forms the core of most practical languages.	x-985-1
In this chapter we discuss the relationship of the abstract query languages discussed so far to three representative commercial relational query languages: Structured Query Language (SQL), Query-By-Example (QBE), and Microsoft Access.	x-986-1
SQL is by far the dominant relational query language and provides the basis for languages in extensions of the relational model as well.	x-986-2
Although QBE is less widespread, it illustrates nicely the basic capabilities and problems of graphic query languages.	x-986-3
Access is a popular database management system for personal computers (PCs) and uses many elements of QBE.	x-986-4
Our discussion of the practical languages is not intended to provide a complete description of them, but rather to indicate some of the similarities and differences between theory and practice.	x-987-1
We focus here on the central aspects of these languages.	x-987-2
Many features, such as string-comparison operators, iteration, and embeddings into a host language, are not mentioned or are touched on only briefly.	x-987-3
We first present highlights of the three languages and then discuss considerations that arise from their use in the real world.	x-988-1
SQL: The Structured Query Language SQL has emerged as the preeminent query language for mainframe and client-server relational dbms’s.	x-989-1
This language combines the flavors of both the algebra and the calculus and is well suited for the specification of conjunctive queries.	x-989-2
This section begins by describing how conjunctive queries are expressed using SQL.	x-990-1
We then progress to additional features, including nested queries and various forms of negation.	x-991-1
Conjunctive Queries in SQL name Sequel at the IBM San Jose Research Laboratory.	x-992-1
It is currently supported by most of the dominant mainframe commercial relational systems, and increasingly by relational dbms’s for PCs.	x-992-2
The basic building block of SQL queries is the select-from-where clause.	x-993-1
Speaking loosely, these have the form select from where For example, queries (4.1) and (4.4) of Chapter 4 are expressed by select Director from Movies where Title = ‘Cries and Whispers’; select Location.Theater, Address from Movies, Location, Pariscope where Director = ‘Bergman’ In these queries, relation names themselves are used to denote variables ranging over tuples occurring in the corresponding relation.	x-993-2
For example, in the preceding queries, the identifier Movies can be viewed as ranging over tuples in relation Movies.	x-993-3
Relation name and attribute name pairs, such as Location.Theater, are used to refer to tuple components; and the relation name can be dropped if the attribute occurs in only one of the relations in the from clause.	x-993-4
The select keyword has the effect of the relational algebra projection operator, the from keyword has the effect of the cross-product operator, and the where keyword has the effect of the selection operator (see Exercise 7.3).	x-994-1
For example, the second query translates to (using abbreviated attribute names)	x-994-2
D=‘Bergman’∧M.T i=P .T i∧P .T h=L.T h If all of the attributes mentioned in the from clause are to be output, then * can be used in place of an attribute list in the select clause.	x-995-1
In general, the where condition may include conjunction, disjunction, negation, and (as will be seen shortly) nesting of select-from-where blocks.	x-995-2
If the where clause is omitted, then it is viewed as having value true for all tuples of the cross-product.	x-995-3
In implementations, as suggested in Chapter 6, optimizations will be used; for example, the from and where clauses will typically be merged to have the effect of an equi-join operator.	x-995-4
In SQL, as with most practical languages, duplicates may occur in a query answer.	x-996-1
Notes on Practical Languages Technically, then, the output of an SQL query may be a bag (also called “multiset”)—	x-997-1
If more than one variable ranging over the same relation is needed, then variables can be introduced in the from clause.	x-998-1
For example, query (4.7), which asks for pairs of persons such that the first directed the second and the second directed the first, can be expressed as select M1.	x-998-2
Director, M1.	x-998-3
Actor from Movies M1, Movies M2 where M1.	x-998-4
Director = M2.	x-998-5
Actor create table Movies Director character[30] In this case, Title and Director values would be comparable, even though they are character strings of different lengths.	x-998-6
Other scalar types supported in SQL include integer, small integer, float, and date.	x-998-7
Example 7.1.1 Let {R[A], S[B], T [C]} be a database schema, and consider the following query: select from R, S, T where R.A = S.B or R.A = T .C; which yields the empty answer if S is empty or if T is empty.	x-999-1
Thus the foregoing SQL query is not equivalent to the calculus query:	x-999-2
The select-from-where blocks of SQL can be combined in a variety of ways.	x-1000-1
We describe first the incorporation of the set operators (union, intersect, and difference).	x-1000-2
For example, the query List all actors and director of the movie “Apocalypse Now.” can be expressed as from Movies where Title = ‘Apocalypse Now’) union Director Participant from Movies where Title = ‘Apocalypse Now’); In the first subquery the output relation uses attribute Participant in place of Actor.	x-1000-3
This illustrates renaming of attributes, analogous to relation variable renaming.	x-1000-4
This is needed here so that the two relations that are unioned have compatible sort.	x-1000-5
SQL also includes a keyword contains, which can be used in a selection condition to test containment between the output of two nested select-from-where expressions.	x-1001-1
Nested SQL Queries Nesting permits the use of one SQL query within the where clause of another.	x-1002-1
A simple illustration of nesting is given by this alternative formulation of query (4.4): Notes on Practical Languages select Theater from Pariscope where Title in Title from Movies where Director = ‘Bergman’); The preceding example tests membership of a unary tuple in a unary relation.	x-1002-2
The keyword in can also be used to test membership for arbitrary arities.	x-1002-3
The symbols < and	x-1002-4
This can be expressed in SQL by select Title, Theater from Pariscope where Title, Theater not in P1.Title, P1.Theater from Pariscope P1, Pariscope P2 where P1.Title = P2.Title Expressing First-Order Queries in SQL We now discuss the important result that SQL is relationally “complete,” in the sense that it can express all relational queries expressible in the calculus.	x-1003-1
Recall from Chapter 5 that the family of nr-datalog¬ programs is equivalent to the calculus and algebra.	x-1003-2
We shall show how to simulate nr-datalog¬ using SQL.	x-1003-3
Intuitively, the result follows from the facts that (a) each rule can be simulated using the select-from-where construct; (b) multiple rules defining the same predicate can be simulated using union; and (c) negation in rule bodies can be simulated using not in.	x-1003-4
We present an example here and leave the formal proof for Exercise 7.4.	x-1004-1
Example 7.1.2 Consider the following query against the CINEMA database: Find the theaters showing every movie directed by Hitchcock.	x-1005-1
Pariscope′(xth, x title) ← Pariscope(xth, x title, x sch) Bad _th(xth) Location(xth, x loc, xph),	x-1006-1
In the program, Bad_th holds the list of “bad” theaters, for which one can find a movie by Hitchcock that the theater is not showing.	x-1007-1
The last rule takes the complement of Bad_th with respect to the list of theaters provided by Location.	x-1007-2
Pariscope′: select Theater, Title from Pariscope; Bad_th: select Theater from Movies, Location where Director = ‘Hitchcock’ not in from Pariscope′); select Theater from Location where Theater not in from Bad_th); The second step is to combine the queries.	x-1008-1
In general, this involves replacing nested queries by their definitions, starting from the answer relation and working backward.	x-1008-2
In this example, we have select Theater from Location where Theater not in Theater from Movies, Location where Director = ‘Hitchcock’ not in Theater, Title from Pariscope)); In this example, each idb (see Section 4.3) relation that occurs in a rule body occurs Notes on Practical Languages negatively.	x-1008-3
As a result, all variables that occur in the rule are bound by edb relations, and so the from part of the (possibly nested) query corresponding to the rule refers only to edb relations.	x-1008-4
In general, however, variables in rule bodies might be bound by positively occurring idb relations, which cannot be used in any from clause in the final SQL query.	x-1008-5
To resolve this problem, the nr-datalog¬ program should be rewritten so that all positively occurring relations in rule bodies are edb relations (see Exercise 7.4a).	x-1009-1
View Creation and Updates We conclude our consideration of SQL by noting that it supports both view creation and updates.	x-1010-1
SQL includes an explicit mechanism for view creation.	x-1011-1
The relation Champo-info from Example 4.3.4 is created in SQL by create view Le Champo as select Pariscope.Title, Schedule, Phone from Pariscope, Location where Pariscope.Theater = ‘Le Champo’ Views in SQL can be accessed as can normal relations and are useful in building up complex queries.	x-1011-2
We briefly illustrate these here; some theoretical aspects concerning updates are presented in Chapter 22.	x-1012-1
SQL provides three primitive commands for modifying the contents of a database— insert, delete, and update (in the sense of modifying individual tuples of a relation).	x-1013-1
The following can be used to insert a new tuple into the Movies database: insert into Movies values (‘Apocalypse Now,’ ‘Coppola,’ ‘Duvall’); delete Movies where Director = ‘Hitchcock’; Tuple update can also operate on sets of tuples (as illustrated by the following) that might be used to correct a typographical error: update Movies set Director = ‘Hitchcock’ where Director = ‘Hickcook’; The ability to insert and delete tuples provides an alternative approach to demonstrating the relational completeness of SQL.	x-1014-1
In particular, subexpressions of an algebra expression can be computed in intermediate, temporary relations (see Exercise 7.6).	x-1014-2
This approach does not allow the same degree optimization as the one based on views because the SQL interpreter is required to materialize each of the intermediate relations.	x-1014-3
Query-by-Example and Microsoft Access We now turn to two query languages that have a more visual presentation.	x-1015-1
The first, Query-by-Example (QBE), presents a visual display for expressing conjunctive queries that is close to the perspective of tableau queries.	x-1015-2
The second language, Access, is available on personal computers; it uses elements of QBE, but with a more graphical presentation of join relationships.	x-1015-3
QBE The language Query-By-Example (QBE) was originally developed at the IBM T. J. Watson Research Center and is currently supported as part of IBM’s Query Management Facility.	x-1016-1
What films with Allen as actor or director are currently featured at the Concorde?	x-1017-1
Under one natural semantics for QBE queries, which parallels the semantics of conjunctive queries and of SQL, this query will yield the empty answer if either σ Director=“Allen” Movies or σ Actor=“Allen” Movies is empty (see Example 7.1.1).	x-1018-1
QBE also includes a capability of condition boxes, which can be viewed as an extension of the incorporation of equality atoms into tableau queries.	x-1019-1
QBE does not provide a mechanism analogous to SQL for nesting of queries.	x-1020-1
It is hard to develop an appropriate visual representation of such nesting within the QBE framework, in part due to the lack of scoping rules.	x-1020-2
More recent extensions of QBE address this issue by incorporating, for example, hierarchical windows.	x-1020-3
QBE also provides mechanisms for both view definition and database update.	x-1020-4
Negation can be incorporated into QBE queries in a variety of ways.	x-1021-1
The use of database update is an obvious mechanism, although not especially efficient.	x-1021-2
Two restricted Notes on Practical Languages Movies Title Director Pariscope Theater Title Schedule Concorde P._X Concorde P._Y Figure 7.1: One form of union in QBE Movies Title Director Bergman Pariscope Theater Title Schedule P._champio ¬Concorde Figure 7.2: forms of negation are illustrated in Fig.	x-1021-3
7.2, which expresses the following query: (assuming that each film has only one director) what theaters, other than the Concorde, feature a film not directed by Bergman?	x-1021-4
The ¬ in the Pariscope relation restricts attention to those tuples with Theater coordinate not equal to Concorde, and the ¬ preceding the tuple in the Movies relation is analogous to a negative literal in a datalog rule and captures a limited form of ¬∃ from the calculus; in this case it excludes all films directed by Bergman.	x-1021-5
When such negation is used, it is required that all variables that occur in a row preceded by ¬ also appear in positive rows.	x-1021-6
Other restricted forms of negation in QBE include using negative literals in condition boxes and supporting an operator analogous to relational division (as defined in Exercise 5.8).	x-1021-7
The following example shows more generally how view definition can be used to obtain relational completeness.	x-1022-1
Example 7.2.1 Recall the query and nr-datalog¬ program of Example 7.1.2.	x-1023-1
As with SQL, the QBE query corresponding to an nr-datalog¬ will involve one or more views for each rule (see Exercise 7.5).	x-1023-2
For this example, however, it turns out that we can compute the effect of the first two rules with a single QBE query.	x-1023-3
Thus the two stages of the full query are shown in Fig.	x-1023-4
7.3, where the symbol I. indicates that the associated tuples are to be inserted into the answer.	x-1023-5
The creation of the view Bad_th is accomplished using the Stage I: Movies Title Director Hitchcock Location Theater Phone Pariscope Theater Title Schedule th title I.VIEW Bad_th I.	x-1023-6
Theater I.	x-1024-1
Stage II: Location Theater Phone Theater I.	x-1025-1
Bad_th Theater Figure 7.3: Illustration of relational completeness of QBE expression I.	x-1026-1
VIEW Bad _ th I., which both creates the view and establishes the attribute names for the view relation.	x-1026-2
Microsoft Access: A Query Language for PCs	x-1027-1
This includes a tabular display to indicate the form and content of desired output tuples, the use of single-attribute conditions within this display (in the rows named “Criteria” and	x-1028-1
Notes on Practical Languages SelectQuery: Query4 Movies Pariscope Location Title Theater Theater Director Title Schedule Phone Field Theater Director Table Location Location Movies Sort Show Criteria Or Figure 7.4: Example query in Access	x-1029-1
Limited forms of negation and union can be incorporated into the condition part of an Access query.	x-1030-1
For more general forms of negation and union, however, the technique of building views to serve as intermediate relations can be used.	x-1030-2
Confronting the Real World Because they are to be used in practical situations, the languages presented in this chapter incorporate a number of features not included in their formal counterparts.	x-1031-1
In this section we touch on some of these extensions and on fundamental issues raised by them.	x-1031-2
These include domain independence, the implications of incorporating many-sorted atomic objects, the use of arithmetic, and the incorporation of aggregate operators.	x-1031-3
Queries from all of the practical languages described in this chapter are domain independent.	x-1032-1
This is easily verified from the form of queries in these languages: Whenever a variable is introduced, the relation it ranges over is also specified.	x-1032-2
Furthermore, the specific semantics associated with or’s occurring in where clauses (see Example 7.1.1) prevent the kind of safety problem illustrated by query unsafe-2 of Section 5.3.	x-1032-3
Most practical languages permit the underlying domain of values to be many-sorted— for example, including distinct scalar domains for the types integer, real, character string, etc., and some constructed types, such as date, in some languages.	x-1033-1
(More recent systems, such as POSTGRES, permit the user to incorporate abstract data types as well.)	x-1033-2
For most of the theoretical treatment, we assumed that there was one underlying domain of values, dom, which was shared equally by all relational attributes.	x-1033-3
As noted in the discussion of SQL, the typing of attributes can be used to ensure that comparisons make sense, in that they compare values of comparable type.	x-1033-4
Much of the theory developed here for a single underlying domain can be generalized to the case of a many-sorted underlying domain (see Exercise 7.8).	x-1033-5
Exercise 4.30 explores the impact of incorporating comparators into the conjunctive queries.	x-1034-1
Many languages also incorporate string-comparison operators.	x-1034-2
Given the presence of integers and reals, it is natural to incorporate arithmetic operators.	x-1035-1
This yields a fundamental increase in expressive power: Even simple counting is beyond the power of the calculus (see Exercise 5.34).	x-1035-2
select count(distinct Title) from Movies where Director = ‘Hitchcock’;	x-1036-1
In the preceding example, the aggregate operator was applied to an entire relation.	x-1037-1
By using the group by command, aggregate operators can be applied to clusters of tuples, each common values on a specified set of attributes.	x-1038-1
For example, the following SQL query determines the number of movies directed by each director: select Director, count(distinct Title) from Movies group by Director; The semantics of group by in SQL are most easily understood when we study an extension of the relational model, called the complex object (or nested relation) model, which models grouping in a natural fashion (see Chapter 20).	x-1038-2
Notes on Practical Languages Bibliographic Notes General descriptions of SQL and QBE may be found in [EN89, KS91, Ull88]; more details on SQL can be found in [C+76], and on QBE in [Zlo77].	x-1039-1
Another language similar in spirit to SQL is Quel, which was provided with the original INGRES system.	x-1039-2
A description of Quel can be found in [SWKH76].	x-1039-3
Reference [OW93] presents a survey of QBE langauges and extensions.	x-1039-4
A reference on Microsoft Access is [Cam92].	x-1039-5
In Unix, the command awk provides a basic relational tool.	x-1039-6
The formal semantics for SQL are presented in [NPS91].	x-1040-1
Example 7.1.1 is from studies containment and equivalence of conjunctive queries under the bag semantics (see	x-1040-2
SQL has become the standard relational query language [57391, 69392]; reference	x-1041-1
QBE is available as part of IBM’s product QMF (Query Management Facility).	x-1042-1
Some personal computer products support more restricted graphical query languages, including Microsoft Access and Paradox (which supports a form-based language).	x-1042-2
Exercises Exercise 7.1 Write SQL, QBE, and Access queries expressing queries (4.1 to 4.14) from Chapter 4.	x-1043-1
Start by expressing them as nr-datalog¬ programs.	x-1043-2
Exercise 7.2 Consider again the queries (5.2 and 5.3) of Chapter 5.	x-1044-1
Express these in SQL, QBE, and Access.	x-1044-2
Exercise 7.3 Describe formally the mapping of SQL select-from-where blocks into the SPJR	x-1045-1
Exercise 7.5 Following Example 7.2.1, show that QBE is relationally complete.	x-1046-1
Exercise 7.6	x-1047-1
Exercises Exercise 7.7 In a manner analogous to Exercise 7.6, show that Access is relationally complete.	x-1048-1
Dependency Your model reduces the most interesting information to something flat and boring.	x-1049-1
Vittorio: You’re right, and this causes a lot of problems.	x-1050-1
Sergio: Designing the schema for a complex application is tough, and it is easy to make mistakes when updating a database.	x-1051-1
Riccardo:	x-1052-1
Vittorio: No, wait, we are going to fix it!	x-1053-1
Thischapterbeginswithaninformaldiscussionthatintroducessomesimpledependencies and illustrates the primary motivations for their development and study.	x-1054-1
The two following sections of the chapter are devoted to two of the simple kinds of dependencies; and the final section introduces the chase, an important tool for analyzing these dependencies and their effect on queries.	x-1054-2
Many of the early dependencies introduced in the literature use the named (as opposed to unnamed) perspective on tuples and relations.	x-1055-1
Dependency theory was one of the main reasons for adopting this perspective in theoretical investigations.	x-1055-2
This is because dependencies concern the semantics of data, and attribute names carry more semantics than column numbers.	x-1055-3
The general view of dependencies based on logic, which is considered in Chapter 10, uses the column-number perspective, but a special subcase (called typed) retains the spirit of the attribute-name perspective.	x-1055-4
Motivation Consider the database shown in Fig.	x-1056-1
8.1.	x-1056-2
Although the schema itself makes no restrictions on properties of data that might be stored, the intended application for the schema may involve several such restrictions.	x-1056-3
For example, we may know that there is only one director associated with each movie title, and that in Showings, only one movie title is associated with a given theater-screen pair.1 Such properties are called functional dependencies (fd’s) because the values of some attributes of a tuple uniquely or functionally determine the values of other attributes of that tuple.	x-1056-4
In the syntax to be developed in this chapter, the 1 Gone are the days of seeing two movies for the price of one!	x-1056-5
Functional and Join Dependency Movies Title Director The Birds Hitchcock Hedren The Birds Hitchcock Taylor Bladerunner Scott Hannah Coppola Brando Showings Theater Screen Title Snack Rex The Birds coffee Rex The Birds popcorn Rex Bladerunner coffee Rex Bladerunner popcorn Le Champo The Birds tea Le Champo The Birds popcorn Cinoche The Birds Coke Cinoche The Birds wine Cinoche Bladerunner Coke Cinoche Bladerunner wine The Birds tea The Birds popcorn Figure 8.1: Sample database illustrating simple dependencies dependency in the Movies relation is written as Movies : Title → Director Showings : Theater Screen → Title.	x-1057-1
Technically, there are sets of attributes on the left- and right-hand sides of the arrow, but we continue with the convention of omitting set braces when understood from the context.	x-1058-1
When there is no confusion from the context, a dependency R : X → Y is simply denoted X → Y .	x-1059-1
A relation I satisfies a functional dependency X → Y if for each pair s, t of tuples in I ,	x-1059-2
Title → Director Title, Actor → Director.	x-1060-1
We will say that dependency (a) implies dependency (b).	x-1061-1
It turns out that dependency (b) is equivalent to the key dependency Title, Actor → Title, Director, Actor.	x-1062-1
I = π Theater, Screen, Title(I ) ⊲⊳ π Theater, Snack(I ).	x-1063-1
This is a simple example of a join dependency (jd) which is formally expressed by Showings : ⊲⊳[{ Theater, Screen, Title}, { Theater, Snacks}].	x-1064-1
In general, a jd may involve more than two attribute sets.	x-1065-1
Multivalued dependency (mvd) is the special case of jd’s that have at most two attribute sets.	x-1065-2
Due to their naturalness, mvd’s were introduced before jd’s and have several interesting properties, which makes them worth studying on their own.	x-1065-3
is also satisfied.	x-1066-1
We will also study such interaction between fd’s and jd’s.	x-1066-2
So far we have considered dependencies that apply to individual relations.	x-1067-1
Typically these dependencies are used in the context of a database schema, in which case one has to specify the relation concerned by each dependency.	x-1067-2
We will also consider a third fundamental kind of dependency, called inclusion dependency (ind) and also referred to as Showings[ Title] ⊆ Movies[ Title].	x-1067-3
Functional and Join Dependency In general, ind’s may involve sequences of attributes on both sides.	x-1068-1
Inclusion dependencies will be studied in depth in Chapter 9.	x-1068-2
Data dependencies such as the ones just presented provide a formal mechanism for expressing properties expected from the stored data.	x-1069-1
If the database is known to satisfy a set of dependencies, this information can be used to (1) improve schema design, (2) protect data by preventing certain erroneous updates, and (3) improve performance.	x-1069-2
These aspects are considered in turn next.	x-1069-3
Schema Design and Update Anomalies The task of designing the schema in a large database application is far from being trivial, so the designer has to receive support from the system.	x-1070-1
Dependencies are used to provide information about the semantics of the application so that the system may help the user choose, among all possible schemas, the most appropriate one.	x-1070-2
There are various ways in which a schema may not be appropriate.	x-1071-1
The relations Movies and Showings illustrate the most prominent kinds of problems associated with fd’s and jd’s: Incomplete information: Suppose that one is to insert the title of a new movie and its director without knowing yet any actor of the movie.	x-1071-2
This turns out to be impossible with the foregoing schema, and it is an insertion anomaly.	x-1071-3
An analogue for deletion, a deletion anomaly, occurs if actor Marlon Brando is no longer associated with the movie	x-1071-4
Redundancy: The fact that Coke can be found at the Cinoche is recorded many times.	x-1072-1
Furthermore, suppose that the management of the Cinoche decided to sell Pepsi instead of Coke.	x-1073-1
It is not sufficient to modify the tuple Cinoche, 1, The Birds, Coke to Cinoche, 1, The Birds, Pepsi because this would lead to a violation of the jd.	x-1073-2
We have to modify several tuples.	x-1073-3
This is a modification anomaly.	x-1073-4
Insertion and deletion anomalies are also caused by redundancy.	x-1073-5
Thus because of a bad choice for the schema, updates can lead to loss of information, inconsistency in the data, and more difficulties in writing correct updates.	x-1074-1
These problems can be prevented by choosing a more appropriate schema.	x-1074-2
In the example, the relation Movies should be “decomposed” into two relations M-Director[ Title, Director] and M-Actor[ Title, Actor], where M-Director satisfies the fd Title → Director.	x-1074-3
Similarly, the relation Showings should be replaced by two relations ST-Showings[ Theater, Screen, Title] Title.	x-1074-4
This approach to schema design is explored in Chapter 11.	x-1074-5
Data Integrity Data dependencies also serve as a filter on proposed updates in a natural fashion: If a database is expected to satisfy a dependency σ and a proposed update would lead to the violation of σ , then the update is rejected.	x-1075-1
In fact, the system supports transactions.	x-1075-2
During a transaction, the database can be in an inconsistent state; but at the end of a transaction, the system checks the integrity of the database.	x-1075-3
If dependencies are violated, the whole transaction is rejected ( aborted); otherwise it is accepted ( validated).	x-1075-4
Efficient Implementation and Query Optimization It is natural to expect that knowledge of structural properties of the stored data be useful in improving the performances of a system for a particular application.	x-1076-1
which can be evaluated without a join.	x-1077-1
Whenever the pattern of tuples {t, d, a′, t, d′, a} is found in relation Movies, it must be the case that d = d′, so one may as well use just the pattern {t, d, a}, yielding the simplified query.	x-1077-2
This technique for query optimization is based on the chase and is considered in the last section of this chapter.	x-1077-3
Functional and Key Dependencies Functional dependencies are the most prominent form of dependency, and several elegant results have been developed for them.	x-1078-1
Key dependencies are a special case of functional dependencies.	x-1078-2
These are the dependencies perhaps most universally supported by relational systems and used in database applications.	x-1078-3
Many issues in dependency theory have nice solutions in the context of functional dependencies, and these dependencies lie at the origin of the decomposition approach to schema design.	x-1078-4
To specify a class of dependencies, one must define the syntax and the semantics of the dependencies of concern.	x-1079-1
This is done next for fd’s.	x-1079-2
Definition 8.2.1 If U is a set of attributes, then a functional dependency (fd) over U is an expression of the form X → Y , where X, Y ⊆ U .	x-1080-1
A key dependency over U is an fd of the form X → U .	x-1080-2
A relation I over U satisfies X → Y , denoted I |= X → Y , if for each Functional and Join Dependency pair s, t of tuples in I , πX(s) = πX(t) implies πY (s) = πY (t).	x-1080-3
For a set F of fd’s, I satisfies F, denoted I |= F, if I |= σ for each σ ∈ F.	x-1080-4
The notion of satisfaction of fd’s by instances over R is defined in the obvious way.	x-1081-1
In the remainder of this chapter, we consider only relational schemas.	x-1081-2
All can be extended easily to database schemas.	x-1081-3
The following simple property provides the basis for the decomposition approach to schema design.	x-1082-1
Intuitively, it says that if a certain fd holds in a relation, one can store instead of the relation two projections of it, without loss of information.	x-1082-2
More precisely, the original relation can be reconstructed by joining the projections.	x-1082-3
Such joins have been termed “lossless joins” and will be discussed in some depth in Section 11.2.	x-1082-4
Proposition 8.2.2 Let I be an instance over U that satisfies X → Y and Z = U − XY .	x-1083-1
Then I = πXY (I ) ⊲⊳ πXZ(I ).	x-1084-1
Proof The inclusion I ⊆ πXY (I ) ⊲⊳ πXZ(I ) holds for all instances I .	x-1085-1
For the opposite inclusion, let r be a tuple in the join.	x-1085-2
Then there are tuples s, t ∈ I such that πXY (r) =	x-1085-3
It follows that r = t, so r is in I .	x-1086-1
Logical Implication In general, we may know that a set F of fd’s is satisfied by an instance.	x-1087-1
A natural question is, What other fd’s are necessarily satisfied by this instance?	x-1087-2
This is captured by the following definition.	x-1087-3
Definition 8.2.3 Let F and Ŵ be sets of fd’s over an attribute set U .	x-1088-1
Then F ( logically) implies Ŵ, denoted F |=U Ŵ or simply F |= Ŵ, if U is understood from the context, if for all relations I over U , I |= F implies I |= Ŵ.	x-1088-2
Two sets Ŵ, F are ( logically) equivalent, denoted Ŵ ≡ F, if Ŵ |= F and F |= Ŵ.	x-1088-3
Example 8.2.4 Consider the set F1 = {A → C, B → C, CD → E} of fd’s over { A, B, C, D, E}.	x-1089-1
Then2 a simple argument allows to show that F1 |= AD → E. In addition, F1 |= CDE → C. In fact, ∅ |= CDE → C (where ∅ is the empty set of fd’s).	x-1089-2
The fd closure of a set F of fd’s over an attribute set U , denoted F∗,U or simply F∗ if U is understood from the context, is the set	x-1090-1
It is easily verified that for any set F of fd’s over U and any sets Y ⊆ X ⊆ U , X → Y ∈ F∗,U .	x-1091-1
This implies that the closure of a set of fd’s depends on the underlying set of attributes.	x-1091-2
It also implies that F∗,U has size greater than 2|U|.	x-1091-3
(It is bounded by 22|U| by definition.)	x-1091-4
Other properties of fd closures are considered in Exercise 8.3.	x-1091-5
Determining Implication for fd’s Is Linear Time One of the key issues in dependency theory is the development of algorithms for testing logical implication.	x-1092-1
Although a set F of fd’s implies an exponential (in terms of the number of attributes present in the underlying schema) number of fd’s, it is possible to test whether F implies an fd X → Y in time that is linear in the size of F and X → Y (i.e., the space needed to write them).	x-1092-2
Example 8.2.5 Recall the set F1 of fd’s from Example 8.2.4.	x-1093-1
Then A∗ = AC, ( AB)∗ =	x-1093-2
The following is easily verified (see Exercise 8.4): Lemma 8.2.6 Let F be a set of fd’s and X → Y an fd.	x-1094-1
Then F |= X → Y iff Y ⊆ X∗.	x-1094-2
Thus testing whether F |= X → Y can be accomplished by computing X∗.	x-1095-1
The following algorithm can be used to compute this set.	x-1095-2
Input: a set F of fd’s and a set X of attributes.	x-1096-1
Output: the closure X∗ of X under F.	x-1097-1
if W → Z ∈ unused and W ⊆ closure then i. unused := unused − {W → Z}; ii.	x-1098-1
closure := closure ∪ Z	x-1098-2
Functional and Join Dependency Proposition 8.2.8 On input F and X, Algorithm 8.2.7 computes (X, F)∗.	x-1099-1
Proof Let U be a set of attributes containing the attributes occurring in F or X, and let result be the output of the algorithm.	x-1100-1
Using properties established in Exercise 8.5, an easy induction shows that result ⊆ X∗.	x-1100-2
For the opposite inclusion, note first that for attribute sets Y, Z, if Y ⊆ Z then Y ∗ ⊆ Z∗.	x-1101-1
Because X ⊆ result, it now suffices to show that result∗ ⊆ result.	x-1102-1
It is enough to show that if A ∈ U − result, then F |= result → A.	x-1102-2
To show this, we construct an instance I over U such that I |= F but I |= result → A for A ∈ U − result.	x-1102-3
Let I = {s, t}, where π result(s) =	x-1102-4
The algorithm provides the means for checking whether a set of dependencies implies a single dependency.	x-1103-1
To test implication of a set of dependencies, it suffices to test independently the implication of each dependency in the set.	x-1103-2
In addition, one can check that the preceding algorithm runs in time O(n2), where n is the length of F and X.	x-1103-3
As shown in Exercise 8.7, this algorithm can be improved to linear time.	x-1103-4
The following summarizes this development.	x-1103-5
Theorem 8.2.9 Given a set F of fd’s and a single fd σ , determine whether F |= σ can be decided in linear time.	x-1104-1
Several interesting properties of fd-closure sets are considered in Exercises 8.11 and 8.12.	x-1105-1
In addition to developing algorithms for determining logical implication, the second fundamental theme in dependency theory has been the development of inference rules, which can be used to generate symbolic proofs of logical implication.	x-1106-1
Although the inference rules do not typically yield the most efficient mechanisms for deciding logical implication, in many cases they capture concisely the essential properties of the dependencies under study.	x-1106-2
The study of inference rules is especially intriguing because (as will be seen in the next section) there are several classes of dependencies for which there is no finite set of inference rules that characterizes logical implication.	x-1106-3
Inference rules and algorithms for testing implication provide alternative approaches to showing logical implication between dependencies.	x-1107-1
In general, the existence of a finite set of inference rules for a class of dependencies is a stronger property than the existence of an algorithm for testing implication.	x-1107-2
It will be shown in Chapter 9 that	x-1107-3
We now present the inference rules for fd’s.	x-1108-1
FD1: (reflexivity) If Y ⊆ X, then X → Y .	x-1109-1
FD2: (augmentation) If X → Y , then XZ → Y Z.	x-1110-1
FD3: (transitivity) If X → Y and Y → Z, then X → Z.	x-1111-1
The variables X, Y, Z range over sets of attributes.	x-1112-1
The first rule is sometimes called an axiom because it is degenerate in the sense that no fd’s occur in the antecedent.	x-1112-2
The inference rules are used to form proofs about logical implication between fd’s, in a manner analogous to the proofs found in mathematical logic.	x-1113-1
It will be shown that the resulting proof system is “sound” and “complete” for fd’s (two classical notions to be recalled soon).	x-1113-2
Before formally presenting the notion of proof, we give an example.	x-1113-3
Example 8.2.10 The following is a proof of AD → E from the set F1 of fd’s of Example 8.2.4.	x-1114-1
from σ1 using FD2, CD → E from σ2 and σ3 using FD3.	x-1115-1
Let U be a set of attributes.	x-1116-1
A substitution for an inference rule ρ (relative to U ) is a function that maps each variable appearing in ρ to a subset of U , such that each set inclusion indicated in the antecedent of ρ is satisfied by the associated sets.	x-1116-2
Now let F be a set of fd’s over U and σ an fd over U .	x-1116-3
A proof of σ from F using the set I = {FD1, FD2, FD3} is a sequence of fd’s σ1, .	x-1116-4
.	x-1116-5
.	x-1116-6
, σn = σ (n ≥ 1) such that for each i ∈ [1, n], either (a) σi ∈ F, or	x-1116-7
The fd σ is provable from F using I (relative to U ), denoted F I understood from the context, if there is a proof of σ from F using I.	x-1117-1
Let I be a set of inference rules.	x-1118-1
Then I is sound for logical implication of fd’s if F I I is complete for logical implication of fd’s if F |= σ implies F I	x-1118-2
We will generalize these definitions to other dependencies and other sets of inference rules.	x-1119-1
In general, a finite sound and complete set of inference rules for a class C of dependencies is called a (finite) axiomatization of C. In such a case, C is said to be (finitely) axiomatizable.	x-1120-1
We now state the following: Functional and Join Dependency Theorem 8.2.11 The set {FD1, FD2, FD3} is sound and complete for logical implica- tion of fd’s.	x-1121-1
Proof Suppose that F is a set of fd’s over an attribute set U .	x-1122-1
The proof of soundness involves a straightforward induction on proofs σ1, .	x-1122-2
.	x-1122-3
.	x-1122-4
, σn from F, showing that F |= σi for each i ∈ [1, n] (see Exercise 8.5).	x-1122-5
For the proof of completeness, we show that F |= X → Y implies F ⊢ X → Y .	x-1123-1
As a first step, we show that F ⊢ X → X∗ using an induction based on Algorithm 8.2.7.	x-1123-2
In particular, let closure i be the value of closure after i iterations of step 3 for some fixed execution of that algorithm on input F and X.	x-1123-3
We set closure 0 = X.	x-1123-4
Suppose inductively that a proof σ1, .	x-1123-5
.	x-1123-6
.	x-1123-7
, σk of X → closure i i has been constructed.	x-1123-8
[The case for i = 0 follows from FD1.]	x-1123-9
Suppose further that W → Z is chosen for the (i + 1)st iteration.	x-1123-10
It follows that W ⊆ closure i and closure i+1 = closure i ∪ Z.	x-1123-11
Extend the proof by adding the following steps: in F by FD1 by FD3 by FD2 by FD3	x-1123-12
Other inference rules for fd’s are considered in Exercise 8.9.	x-1124-1
In the proof of Proposition 8.2.8, an instance I is created such that I |= F but I |= X → A.	x-1125-1
Intuitively, this instance witnesses the fact that F |= X → A.	x-1126-1
This raises the following natural question: Given a set F of fd’s over U , is there a single instance I that satisfies F and that violates every fd not in F∗?	x-1126-2
It turns out that for each set of fd’s, there is such an instance; these are called Armstrong relations.	x-1126-3
Proposition 8.2.12 If F is a set of fd’s over U , then there is an instance I such that, for each fd σ over U , I |= σ iff σ ∈ F∗.	x-1127-1
Crux Suppose first that F |= ∅ → A for any A (i.e., ∅∗ = ∅).	x-1128-1
For each set X ⊆ U satisfying X = X∗, choose an instance IX = {sX, tX} such that sX(A) = tX(A) iff A ∈ X.	x-1128-2
In addition, choose these instances so that adom(IX) ∩ adom(IY ) = ∅ for X = Y .	x-1128-3
Then is an Armstrong relation for F.	x-1128-4
If ∅∗ = ∅, then the instances IX should be modified so that πA(IX) = πA(IY ) for each X, Y and A ∈ ∅∗.	x-1129-1
In some applications, the domains of certain attributes may be finite (e.g., Sex conventionally has two values, and Grade typically consists of a finite set of values).	x-1130-1
In such cases, the construction of an Armstrong relation may not be possible.	x-1130-2
This is explored in Exercise 8.13.	x-1130-3
Join and Multivalued Dependencies The second kind of simple dependency studied in this chapter is join dependency (jd), which is intimately related to the join operator of the relational algebra.	x-1131-1
As mentioned in Section 8.1, a basic motivation for join dependency stems from its usefulness in connection with relation decomposition.	x-1131-2
This section also discusses multivalued dependency (mvd), an important special case of join dependency that was historically the first to be introduced.	x-1131-3
The central results and tools for studying jd’s are different from those for fd’s.	x-1132-1
It has been shown that there is no sound and complete set of inference rules for jd’s analogous to those for fd’s.	x-1132-2
(An axiomatization for a much larger family of dependencies will be presented in Chapter 10.)	x-1132-3
In addition, as shown in the following section, logical implication for jd’s is decidable.	x-1132-4
The complexity of implication is polynomial for a fixed database schema but becomes np-hard if the schema is considered part of the input.	x-1132-5
(An exact characterization of the complexity remains open.)	x-1132-6
The following section also presents an interesting correspondence between mvd’s and acyclic join dependencies (i.e., those based on joins that are acyclic in the sense introduced in Chapter 6).	x-1133-1
Join Dependency and Decomposition Before defining join dependency, we recall the definition of natural join.	x-1134-1
For attribute set U , sets X1, .	x-1134-2
.	x-1134-3
.	x-1134-4
, Xn ⊆ U , and instances Ij over Xj for j ∈ [1, n], the ( natural) join of the Ij ’s is j =1 j } = {s over ∪ Xj | πXj j for each j ∈ [1, n]}.	x-1134-5
Functional and Join Dependency Definition 8.3.1 i=1 i = U .	x-1135-1
A relation I over U satisfies	x-1135-2
j =1 Xj	x-1136-1
The 2-ary jd’s are also called multivalued dependencies (mvd’s).	x-1137-1
These are often denoted in a style reminiscent of fd’s.	x-1137-2
Definition 8.3.2 If U is a set of attributes, then a multivalued dependency (mvd) over U is an expression of the form X → X →	x-1138-1
In the preceding definition, it would be equivalent to write ⊲⊳[XY, (U − Y )]; we choose the foregoing form to emphasize the importance of X.	x-1139-1
For instance, the jd can be written as an mvd using Theater → or equivalently, Theater →	x-1139-2
Exercise 8.16 explores the original definition of satisfaction of an mvd.	x-1140-1
Figure 8.2 shows a relation schema SDT and an instance that satisfies a 3-ary jd.	x-1141-1
This relation focuses on snacks, distributors, and theaters.	x-1141-2
We assume for this example that a tuple (s, d, p, t) is in SDT if the conjunction of the following predicates is true: P1(s, d, p): Snack s is supplied by distributor d at price p.	x-1141-3
P2(d, t): Theater t is a customer of distributor d.	x-1142-1
P3(s, t): Snack s is bought by theater t.	x-1143-1
Under these assumptions, each instance of SDT must satisfy the jd:	x-1144-1
For example, this holds for the instance in Fig.	x-1145-1
8.2.	x-1145-2
Note that if tuple coffee, Smart, 2.35, Cinoche were removed, then the instance would no longer satisfy the jd because coffee, Smart, 2.35, coffee, Cinoche, and Smart, Cinoche would remain in the appropriate projections.	x-1145-3
We also expect the instances of SDT to satisfy Snack, Distributor → Price.	x-1145-4
It can be argued that schema SDT with the aforementioned constraint is unnatural in the following sense.	x-1146-1
Intuitively, if we choose such a schema, the presence of a tuple SDT Snack Distributor Price Theater coffee Smart Rex coffee Smart Le Champo coffee Smart Cinoche coffee Leclerc Cinoche wine Smart Rex wine Smart Cinoche popcorn Leclerc Cinoche Figure 8.2: Illustration of join dependency s, d, p, t seems to indicate that t buys s from d. If we wish to record just the information about who buys what, who sells what, and who sells to whom, a more appropriate schema would consist of three relations SD[ Snack, Distributor, Price], ST [ Snack, Theater], and DT [ Distributor, Theater] corresponding to the three sets of attributes involved in the preceding jd.	x-1146-2
The jd then guarantees that no information is lost in the decomposition because the original relation can be reconstructed by joining the projections.	x-1146-3
Join Dependencies and Functional Dependencies The interaction of fd’s and jd’s is important in the area of schema design and user interfaces to the relational model.	x-1147-1
Although this is explored in more depth in Chapter 11, we present here one of the first results on the interaction of the two kinds of dependencies.	x-1147-2
Proposition 8.3.3 Let U be a set of attributes, {X, Y, Z} be a partition of U , and F be a set of fd’s over U .	x-1148-1
Then F |= ⊲⊳[XY, XZ] iff either F |= X → Y or F |= X → Z.	x-1148-2
Crux Sufficiency follows immediately from Proposition 8.2.2.	x-1149-1
For necessity, suppose that F does not imply either of the fd’s.	x-1149-2
Then Y − X∗ = ∅ and Z − X∗ = ∅, say C ∈ Y − X∗ if A is in X∗ and u(A) = 0, v(A) = 1 otherwise.	x-1149-3
Clearly, I satisfies F and one can verify that πXY (I ) ⊲⊳ πXZ(I ) contains a tuple w with w(C) = 0 and w(C′) = 1.	x-1149-4
Thus w is not in I , so I violates ⊲⊳[XY, XZ].	x-1149-5
We state first the following result without proof.	x-1150-1
Theorem 8.3.4 There is no axiomatization for the family of jd’s.	x-1151-1
Functional and Join Dependency In contrast, there is an axiomatization for the class of fd’s and multivalued dependencies.	x-1152-1
Note first that implication for fd’s is independent of the underlying set of attributes (i.e., if F ∪ {σ } is a set of fd’s over U and V ⊇ U , then F |= σ relative to U iff F |= σ relative to V ; see Exercise 8.6).	x-1152-2
An important difference between fd’s and mvd’s is that this is not the case for mvd’s.	x-1152-3
Thus the inference rules for mvd’s must be used in connection with a fixed underlying set of attributes, and a variable (denoted U ) referring to this set is used in one of the rules.	x-1152-4
The following lists the four rules for mvd’s alone and an additional pair of rules needed when fd’s are incorporated.	x-1153-1
MVD0: (complementation) If X →	x-1154-1
MVD1: (reflexivity) If Y ⊆ X, then X →	x-1155-1
MVD2: (augmentation) If X →	x-1156-1
MVD3: (transitivity) If X →	x-1157-1
FMVD1: (conversion) If X → Y , then X →	x-1158-1
FMVD2: (interaction) If X →	x-1159-1
Theorem 8.3.5 The set {FD1, FD2, FD3, MVD0, MVD1, MVD2, MVD3, FMVD1, FMVD2} is sound and complete for logical implication of fd’s and mvd’s considered together.	x-1160-1
Crux Soundness is easily verified.	x-1161-1
For completeness, let an underlying set U of attributes be fixed, and assume that F ⊢ σ , where σ = X → Y or σ = X →	x-1161-2
The dependency set of X is dep(X) = {Y ⊆ U | F ⊢ X →	x-1162-1
That is, it contains U and is closed under intersection, union, and difference (see Exercise 8.17).	x-1163-1
In addition, where X+ denotes {A ∈ U | F ⊢ X → A}.	x-1163-2
i=1 i = U ; (2) Wi = ∅ for i ∈ [1, n]; (3) Wi ∩ Wj = ∅ for i, j ∈ [1, n] with i = j ; and (4) if W ∈ dep(X), W = ∅, and W ⊆ Wi for some i ∈ [1, n], then W = Wi.	x-1164-1
One then proves that	x-1164-2
Now construct an instance I over U that contains all tuples t satisfying the following conditions:	x-1165-1
for all B ∈ Wi or t (B) = 1 for all B ∈ Wi.	x-1166-1
It can be shown that I |= F but I |= σ (see Exercise 8.17).	x-1167-1
This easily implies the following (see Exercise 8.18): Corollary 8.3.6 The set {MVD0, MVD1, MVD2, MVD3} is sound and complete for logical implication of mvd’s considered alone.	x-1168-1
The Chase This section presents the chase, a remarkable tool for reasoning about dependencies that highlights a strong connection between dependencies and tableau queries.	x-1169-1
The discussion here is cast in terms of fd’s and jd’s, but as will be seen in Chapter 10, the chase generalizes naturally to a broader class of dependencies.	x-1169-2
At the end of this section, we explore important applications of the chase technique.	x-1169-3
We show how it can also be used to determine logical implication between sets of dependencies and to optimize conjunctive queries.	x-1169-4
The following example illustrates an intriguing connection between dependencies and tableau queries.	x-1170-1
Example 8.4.1 Consider the tableau query (T , t) shown in Fig.	x-1171-1
8.3(a).	x-1171-2
Suppose the query is applied only to instances I satisfying some set F of fd’s and jd’s.	x-1171-3
The chase is based on the following simple idea.	x-1171-4
If ν is a valuation embedding T into an instance I satisfying F, ν(T ) must satisfy F. Valuations that do not satisfy F are therefore of no use.	x-1171-5
The chase is a procedure that eliminates the useless valuations by changing (T , t) itself so that T , viewed as an instance, satisfies F. We will show that the tableau query resulting from the chase is then equivalent to the original on instances satisfying F. As we shall see, this can be used to optimize queries and test implication of dependencies.	x-1172-1
Let us return to the example.	x-1173-1
Suppose first that F = {B → D}.	x-1173-2
Suppose (T , t) is applied to an instance I satisfying F. In each valuation embedding T into I , it must be the case that z and z′ are mapped to the same constant.	x-1173-3
Thus in this context one might as well replace T by the tableau where z = z′.	x-1173-4
This transformation is called “applying the fd B → D” to (T , t).	x-1173-5
It is easy to see that the resulting tableau query is in fact equivalent to the identity, because T contains an entire row of distinguished variables.	x-1173-6
Consider next an example involving both fd’s and jd’s.	x-1174-1
Let F consist of the following two dependencies over ABCD: the jd ⊲⊳[ AB, BCD] and the fd A → C. In this example we argue that for each I satisfying these dependencies, (T , t)(I ) = I or, in other words, in the context of input instances that satisfy the dependencies, the query (T , t) is equivalent to the identity query ({t}, t).	x-1174-2
Let I be an instance over ABCD satisfying the two dependencies.	x-1175-1
We first explain why (T , t)(I ) = (T ′, t)(I ) for the tableau query (T ′, t) of Fig.	x-1175-2
8.3(b).	x-1175-3
It is clear that (T ′, t )(I ) ⊆ (T , t )(I ), because T ′ is a superset of T .	x-1175-4
For the opposite inclusion, suppose that ν is a valuation for T with ν(T ) ⊆ I .	x-1175-5
Then, in particular, both ν(w, x, y, z′) and ν(w′, x, y′, z) are in I .	x-1175-6
Because I |= ⊲⊳[ AB, BCD], it follows that ν(w, x, y′, z) ∈ I .	x-1175-7
Thus ν(T ′) ⊆ I and ν(t) ∈ (T ′, t)(I ).	x-1176-1
The transformation from (T , t) to (T ′, t) is termed Functional and Join Dependency B C D B C D B C D T w x y T′ w x y T′′ w x y w′ x y′ w′ x y′ w′ x y w x y′ w x y t w x y t w x y t w x y the jd [ AB, BCD] the fd A → C Figure 8.3: Illustration of the chase	x-1176-2
The tableau T ′′ of Fig.	x-1177-1
8.3(c) is the result of chasing (T ′, t) with the fd A → C (i.e., replacing all occurrences of y′ by y).	x-1177-2
We now argue that (T ′, t)(I ) = (T ′′, t)(I ).	x-1177-3
First, by Theorem 6.2.3, (T ′, t)(I ) ⊇ (T ′′, t)(I ) because there is a homomorphism from (T ′, t) to (T ′′, t).	x-1177-4
For the opposite inclusion, suppose now that ν(T ′) ⊆ I .	x-1177-5
This implies that ν embeds the first tuple of T ′′ into I .	x-1177-6
In addition, because ν(w, x, y, z′) and ν(w, x, y′, z) are in I and I |= A → C, it follows that ν(y) = ν(y′).	x-1177-7
Thus ν(w′, x, y, z) = ν(w′, x, y′, z) ∈ I , and ν(w, x, y, z) = ν(w, x, y′, z) ∈ I , [i.e., ν embeds the second and third tuples of T ′′ into I , such that ν(T ′′) ⊆ I ].	x-1177-8
Note that (T ′′, t) is the result of identifying a pair of variables that caused a violation of A → C in T ′.	x-1177-9
We will see that by repeated applications of an fd, one can eventually “force” a tableau to satisfy the fd.	x-1177-10
Note that in this case, chasing with respect to A → C has no effect before chasing with respect to	x-1177-11
Finally, note that by the Homomorphism Theorem 6.2.3 of Chapter 6, (T ′′, t) ≡	x-1178-1
Defining the Chase sat(F) = {I over R | I |= F}.	x-1179-1
Query q1 is contained in q2 relative to F, denoted q1 ⊆F q2, if q1 ⊆ sat(F) q2.	x-1180-1
Equivalence relative to a family of instances (≡F ) and to a set of dependencies (≡F) are defined similarly.	x-1180-2
The chase is a general technique that can be used, given a set of dependencies F, to transform a tableau query q into a query q′ such that q ≡F q′.	x-1181-1
The chase is defined as a nondeterministic procedure based on the successive application of individual dependencies from F, but as will be seen this process is “Church-Rosser” in the sense that the procedure necessarily terminates with a unique end result.	x-1181-2
As a final step in this development, the chase will be used to characterize equivalence of conjunctive queries with respect to a set F of dependencies (≡F).	x-1181-3
In the following, we let R be a fixed relation schema, and we focus on sets F of fd’s and jd’s over R and tableau queries with no constants over R. The entire development can be generalized to database schemas and conjunctive queries with constants (Exercise 8.27) and to a considerably larger class of dependencies (Chapter 10).	x-1182-1
For technical convenience, we assume that there is a total order ≤ on the set var.	x-1183-1
Let R be a fixed relation schema and suppose that (T , t) is a tableau query over R. The chase is based on the successive application of the following two rules: fd rule: Let σ = X → A be an fd over R, and let u, v ∈ T be such that πX(u) = πX(v) and u(A) = v(A).	x-1183-2
Let x be the lesser variable in {u(A), v(A)} under the ordering ≤, and let y be the other one (i.e., {x, y} = {u(A), v(A)} and x < y).	x-1183-3
The result of applying the fd σ to u, v in (T , t) is the tableau query (θ (T ), θ (t)), where θ is the substitution that maps y to x and is the identity elsewhere.	x-1183-4
jd rule: Let σ =⊲⊳[X1, .	x-1184-1
.	x-1184-2
.	x-1184-3
, Xn] be a jd over R, let u be a free tuple over R not in T , and suppose that u1, .	x-1184-4
.	x-1184-5
.	x-1184-6
, un ∈ T satisfy πX (u i i ) = πXi	x-1184-7
Following the lead of Example 8.4.1, the following is easily verified (see Exercise 8.24a).	x-1185-1
Proposition 8.4.2 Suppose that F is a set of fd’s and jd’s over R, σ ∈ F, and q is a tableau query over R. If q′ is the result of applying σ to some tuples in q, then q′ ≡F q.	x-1186-1
such that for each i ≥ 0, (Ti+1, ti+1) (if defined) is the result of applying some dependency in F to (Ti, ti).	x-1187-1
The sequence is terminal if it is finite and no dependency in F can be applied to it.	x-1187-2
The last element of the terminal sequence is called its result.	x-1187-3
The notion of satisfaction of a dependency is extended naturally to tableaux.	x-1187-4
The following is an important property of terminal chasing sequences (Exercise 8.24b).	x-1187-5
Lemma 8.4.3 Let (T ′, t′) be the result of a terminal chasing sequence of (T , t) by F.	x-1188-1
Then T ′, considered as an instance, satisfies F.	x-1189-1
Functional and Join Dependency Because the chasing rules do not introduce new variables, it turns out that the chase procedure always terminates.	x-1190-1
The following is easily verified (Exercise 8.24c): Lemma 8.4.4 Let (T , t) be a tableau query over R and F a set of fd’s and jd’s over R.	x-1190-2
Then each chasing sequence of (T , t) by F is finite and is the initial subsequence of a terminal chasing sequence.	x-1191-1
Because the Church-Rosser property holds, we can define without ambiguity the result of chasing a tableau query by a set of fd’s and jd’s.	x-1192-1
Definition 8.4.5 If (T , t) is a tableau query over R and F a set of fd’s and jd’s over R, then the chase of (T , t) by F, denoted chase(T , t, F), is the result of some (any) terminal chasing sequence of (T , t) by F.	x-1193-1
From the previous discussion, chase(T , t, F) can be computed as follows.	x-1194-1
The dependencies are picked in some arbitrary order and arbitrarily applied to the tableau.	x-1194-2
Applying an fd to a tableau query q can be performed within time polynomial in the size of q.	x-1194-3
However, determining whether a jd can be applied to q is np-complete in the size of q.	x-1194-4
Thus the best-known algorithm for computing the chase is exponential (see Exercise 8.25).	x-1194-5
However, the complexity is polynomial if the schema is considered fixed.	x-1194-6
Until now, besides the informal discussion in Section 8.1, the chase remains a purely syntactic technique.	x-1195-1
We next state a result that shows that the chase is in fact determined by the semantics of the dependencies in F and not just their syntax.	x-1195-2
In the following proposition, recall that by definition, F ≡ F′ if F |= F′ and F′ |= F. The proof, which we omit, uses the Church-Rosser property of the chase (see also Exercise 8.26).	x-1196-1
Proposition 8.4.6 Let F and F′ be sets of fd’s and jd’s over R, and let (T , t) be a tableau query over R. If F ≡ F′, then chase(T , t, F) and chase(T , t, F′) coincide.	x-1197-1
We next consider several important uses of the chase that illustrate the power of this technique.	x-1198-1
Query Equivalence We consider first the problem of checking the equivalence of tableau queries in the presence of a set of fd’s and jd’s.	x-1199-1
This allows, for example, checking whether a tableau query can be replaced by a simpler tableau query when the dependencies are satisfied.	x-1199-2
Suppose now that (T ′, t′) and (T ′′, t′′) are two tableau queries and F a set of fd’s and jd’s such that (T ′, t ′) ≡F (T ′′, t′′).	x-1199-3
From the preceding development (Proposition 8.4.2), it follows that chase(T ′, t′, F) ≡F (T ′, t′) ≡F (T ′′, t′′) ≡F chase(T ′′, t′′, F).	x-1199-4
We now show that, in fact, chase(T ′, t′, F) ≡ chase(T ′′, t′′, F).	x-1200-1
Furthermore, this condition is sufficient as well as necessary.	x-1200-2
To demonstrate this result, we first establish the following more general fact.	x-1201-1
Theorem 8.4.7 Let F be a family of instances over relation schema R that is closed under isomorphism, and let (T1, t1), (T2, t2), (T ′, t′ ), and (T ′, t′ ) be tableau queries over 1 R. Suppose further that for i = 1, 2, i i F (Ti , ti ) and i Then (T1, t1) ⊆F (T2, t2) iff (T ′, t′ ) ⊆ (T ′, t′ ).	x-1202-1
Proof The if direction is immediate.	x-1203-1
For the only-if direction, suppose that (T1, t1) ⊆F t ′ ∈	x-1203-2
It follows that there is a homomorphism h such that h(T ′) ⊆ T ′ and h(t′ ) = t′ .	x-1204-1
Thus 2	x-1204-2
Together with Lemma 8.4.3, this implies the following: Theorem 8.4.8 Let (T1, t1) and (T2, t2) be tableau queries over R and F a set of fd’s and jd’s over R. Then	x-1205-1
Query Optimization	x-1206-1
We start by looking at the effect on tableau minimization of the chase using fd’s.	x-1207-1
In the following, we denote by min(T , t) the tableau resulting from the minimization of 3 More precisely, T ′ considered as an instance is in F means that some instance isomorphic to T ′ is in F .	x-1208-1
Functional and Join Dependency the tableau (T , t) using the Homomorphism Theorem 6.2.3 for tableau queries, and by	x-1209-1
Lemma 8.4.9 Let (T , t) be a tableau query and F a set of fd’s.	x-1210-1
Then | min( chase(T , t, F))| ≤ | min(T , t )|.	x-1210-2
Crux By the Church-Rosser property of the chase, the order of the dependencies used in a chase sequence is irrelevant.	x-1211-1
Clearly it is sufficient to show that for each tableau query (T ′, t ′) and σ ∈ F, | min( chase(T ′, t′, σ ))| ≤ | min(T ′, t′)|.	x-1211-2
We can assume without loss of generality that σ is of the form X → A, where A is a single attribute.	x-1211-3
Let (T ′′, t′′) = chase(T ′, t′, {X → A}), and let θ be the chase homomorphism of a chasing sequence for chase(T ′, t′, {X → A}), i.e., the homomorphism obtained by composing the substitutions used in that chasing sequence (see the proof of Theorem 8.4.18).	x-1212-1
We will use here the Church-Rosser property of the chase (Theorem 8.4.18) as well as a related property stating that the homomorphism θ , like the result, is also the same for all chase sequences (this follows from the proof of Theorem 8.4.18).	x-1213-1
By Theorem 6.2.6, there is some S ⊆ T ′ such that (S, t′) is a minimal tableau query equivalent to (T ′, t′); we shall use this as the representative of min(T ′, t′).	x-1214-1
Let h be a homomorphism such that h(T ′, t′) = (S, t′).	x-1214-2
Consider the mapping f on (T ′′, t′′) defined by f (θ (x)) = θ (h(x)), where x is a variable in (T ′, t′).	x-1214-3
If we show that f is well defined, we are done.	x-1214-4
[If f is well defined, then f is a homomorphism from (T ′′, t′′) to θ (S, t′) = To see that f is well defined, suppose θ (x) = θ (y).	x-1214-5
We have to show that θ (h(x)) =	x-1214-6
Let (h(ui ), h(v )), .	x-1215-1
.	x-1215-2
.	x-1215-3
, (h(u ), h(v )) be the subsequence of these pairs for which X → i1 ik ik i1 ik ik morphism θ ′.	x-1215-4
Note that for all x′, y′, if θ (x′) = θ (y′) then θ ′(h(x′)) = θ ′(h(y′)).	x-1215-5
In particular, θ ′(h(x)) = θ ′(h(y)).	x-1215-6
Because h(T ′) ⊆ T ′, θ ′ is the chase homomorphism of a chasing sequence σ1, .	x-1215-7
.	x-1215-8
.	x-1215-9
, σk of (T ′, t′).	x-1215-10
Let θ′′ be the chase homomorphism formed from a terminal chasing sequence that extends σ1, .	x-1215-11
.	x-1215-12
.	x-1215-13
, σk.	x-1215-14
Then θ′′(h(x)) = θ′′(h(y)).	x-1215-15
Finally, by the uniqueness of the chase homomorphism, θ ′′ = θ , and so θ (h(x)) = θ (h(y)) as desired.	x-1215-16
This concludes the proof.	x-1215-17
It turns out that jd’s behave differently than fd’s with respect to minimization of tableaux.	x-1216-1
The following shows that the chase using jd’s may yield simpler but also more complicated tableaux.	x-1216-2
B C D B C D B C D T w x y′ T′ w x y T′′ w′ x y w′ x y w′ x′ y′ w x′ y′ w′ x y′ t w x y t′ w x y w x′ y t′′ w x y chase( T′, t′, { [ AB, CD]}) Figure 8.4: Minimization and the chase using jd’s Example 8.4.10 Consider the tableau query (T , t) shown in Fig.	x-1217-1
8.4(a) and the jd σ =⊲⊳	x-1217-2
Next let (T ′, t′) be the tableau query in Fig.	x-1218-1
8.4(b) and σ =⊲⊳[AB, CD].	x-1218-2
Again (T ′, t′) is minimal.	x-1218-3
Now chase(T ′, t′, σ ) is represented in Fig.	x-1218-4
8.4(c) and is minimal.	x-1218-5
Thus	x-1218-6
Despite the limitations illustrated by the preceding example, the chase in conjunction with tableau minimization provides a powerful optimization technique that yields good results in many cases.	x-1219-1
This is illustrated by the following example and by Exercise 8.28.	x-1219-2
Example 8.4.11 Consider the SPJ expression q = π AB(π BCD(R) ⊲⊳ π ACD(R)) ⊲⊳ π AD(R), where R is a relation with attributes ABCD.	x-1220-1
Suppose we wish to optimize the query on databases satisfying the dependencies F = {B → D, D → C, ⊲⊳[ AB, ACD]}.	x-1220-2
The tableau (T , t) corresponding to q is represented in Fig.	x-1221-1
8.5(a).	x-1221-2
Note that (T , t) is minimal.	x-1221-3
Next we chase (T , t) using the dependencies in F. The chase using the fd’s in F does not change (T , t), which already satisfies them.	x-1221-4
The chase using the jd Functional and Join Dependency B C D B C D T w′ x y′ T′′ w′ x y′ w x′ y′ w x′ y′ w x′′ y′′ w x′′ y′ t w x y t′′ w x y B C D B C D T′ w′ x y′ T′′′ w′ x y′ w x′ y′ w x′ y′ w x′′ y′′ t′′′ w x y w x′ y′′ w x′′ y′ t′ w x y Optimization of SPJ expressions by tableau minimization and the chase	x-1221-5
The Chase and Logical Implication We consider a natural correspondence between dependency satisfaction and conjunctive query containment.	x-1222-1
This correspondence uses tableaux to represent dependencies.	x-1222-2
We will see that the chase provides an alternative point of view to dependency implication.	x-1222-3
First consider a jd σ =⊲⊳[X1, .	x-1223-1
.	x-1223-2
.	x-1223-3
, Xn].	x-1223-4
It is immediate to see that an instance I satisfies σ iff qσ (I ) ⊆ qid(I ), where qσ = [X1] ⊲⊳ · · · ⊲⊳ [Xn] i i ) = πXi	x-1223-5
It is again easy to see that qσ = (Tσ , t), so I |= σ iff (Tσ , t)(I ) ⊆ ({t}, t)(I ).	x-1224-1
For fd’s, the situation is only slightly more complicated.	x-1225-1
Consider an fd σ ′ = X → A over U .	x-1225-2
It is easy to see that I |= σ ′ iff (Tσ′, tσ′)(I ) ⊆ (Tσ′, t′σ′)(I), where X X Tσ′ u x v1 u x v1 u x′ v2 u x′ v2 tσ′ x x′ t ′σ′ x x where u, v1, v2 are vectors of distinct variables and x, x′ are distinct variables occurring in none of these vectors.	x-1225-3
The tableau query of σ ′ is (Tσ′, tσ′).	x-1225-4
In Chapter 10, we will consider the general class of algebraic dependencies based on containment of these expressions.	x-1226-1
Returning to the chase, we next use the tableau representation of dependencies to obtain a characterization of logical implication (Exercise 8.29).	x-1227-1
This result is generalized by Corollary 10.2.3.	x-1227-2
Theorem 8.4.12 Let F and {σ } be sets of fd’s and jd’s over relation schema R, let (Tσ , tσ ) be the tableau query of σ , and let T be the tableau in chase(Tσ , tσ , F).	x-1228-1
Then F |= σ iff	x-1228-2
This implies that determining logical implication for jd’s alone, and for fd’s and jd’s taken together, is decidable.	x-1229-1
On the other hand, tableau techniques are also used to obtain the following complexity results for logical implication of jd’s (see Exercise 8.30).	x-1229-2
Functional and Join Dependency Theorem 8.4.13	x-1230-1
In Section 6.4, a special family of joins called acyclic was introduced and was shown to enjoy a number of desirable properties.	x-1231-1
We show now a connection between those results, join dependencies, and multivalued dependencies.	x-1231-2
Using the chase, we show here that a jd is acyclic iff it is equivalent to a set of mvd’s.	x-1232-1
The discussion relies on the notation and techniques developed in the discussion of acyclic joins in Section 6.4.	x-1233-1
We shall use the following lemma.	x-1234-1
Lemma 8.4.14 Let σ = ⊲⊳X be a jd over U , and let X, Y ⊆ U be disjoint sets.	x-1235-1
Then the following are equivalent:	x-1235-2
Proof Let Z = U − XY .	x-1236-1
Let τ denote the mvd X → query corresponding to τ .	x-1236-2
Let Tτ = {tY , tZ} where tY [XY ] = tτ [XY ] and tZ[XZ] = tτ [XZ]	x-1236-3
We show now that (i) implies (ii).	x-1237-1
By Theorem 8.4.12, tτ ∈ T = chase(Tτ , tτ , σ ).	x-1237-2
Let Xi ∈ X.	x-1237-3
Suppose that t is a new tuple created by an application of σ during the computation of T .	x-1237-4
Then t[Xi] agrees with t′[Xi] for some already existing tuple.	x-1237-5
An induction implies that tτ [Xi] = tY [Xi] or tτ [Xi] = tZ[Xi].	x-1237-6
Because tY and tZ agree only on X, this implies that Xi cannot intersect with both Y and Z.	x-1237-7
That (ii) implies (iii) is immediate.	x-1238-1
To see that (iii) implies (i), consider an application of the jd ⊲⊳X on Tτ , where Xi ∈ X is associated with tY if Xi − X ⊆ Y , and Xi is associated with tZ otherwise.	x-1238-2
This builds the tuple tτ , and so by Theorem 8.4.12, σ |= X →	x-1238-3
We now have the following: Theorem 8.4.15	x-1239-1
Proof	x-1240-1
For each i ∈ [1, n − 1], let Pi = ∪j∈[1,i]Xj and Qi = ∪j∈[i+1,n]Xj .	x-1241-1
Let F = {[Pi ∩ Qi] →	x-1241-2
We begin by setting t1 to be the tuple of Tσ that corresponds to X1.	x-1242-1
Then t1[P1] = tσ [P1] because P1 = X1.	x-1242-2
More generally, given ti with i ≥ 1, the mvd [Pi ∩ Qi] → ti and the tuple corresponding to Xi+1 can be used to construct tuple ti+1 with the desired property.	x-1242-3
The final tuple tn constructed by this process is tσ , and so F |= σ as desired.	x-1242-4
Let Y= {Y1, .	x-1243-1
.	x-1243-2
.	x-1243-3
, Ym}.	x-1243-4
Suppose that s1, .	x-1243-5
.	x-1243-6
.	x-1243-7
are the tuples produced by some chasing sequence of (Tσ , tσ ).	x-1243-8
We argue by induction that for each k ≥ 1, sk[W ] ∈ πW (Tσ ).	x-1243-9
Suppose otherwise, and let sk be the first where this does not hold.	x-1243-10
Suppose that sk is the result of applying an mvd X →	x-1243-11
Let Z = U − XY .	x-1244-1
Because sk results from X → in Tσ or already produced, such that sk[XY ] = s′[XY ] and sk[XZ] = s′′[XZ].	x-1244-2
Because sk is chosen to be least, there are tuples ti and tj in Tσ , which correspond to Xi and Xj , respectively, such that s′[W ] = ti[W ] and s′′[W ] = tj [W ].	x-1244-3
Because ti and tj correspond to Xi and Xj , for each attribute A ∈ U we have ti[A] = tj [A] iff A ∈ Xi ∩ Xj .	x-1245-1
Thus X ∩ W ⊆ Xi ∩ Xj .	x-1245-2
Because sk[W ] = ti[W ], W − XZ = ∅, and because sk[W ] = tj [W ], W − XY = ∅.	x-1246-1
Now, by Lemma 8.4.14, because X → that Xk ∩ Y = ∅ and Xk ∩ Z = ∅.	x-1247-1
It follows that Y|W−X is disconnected.	x-1247-2
Finally, let Y = Xi ∩ W and Y ′ = Xj ∩ W .	x-1247-3
Because X ∩ W ⊆ Xi ∩ Xj , it follows that Y ∩ Y ′ is an articulation set for Y, a contradiction.	x-1247-4
We conclude with a complexity result about acyclic jd’s.	x-1248-1
The first part follows from the proof of the preceding theorem and the fact that the GYO algorithm runs in polynomial time.	x-1248-2
The second part, stated without proof, is an interesting converse of the first part.	x-1248-3
Proposition 8.4.16	x-1249-1
The Chase Is Church-Rosser To conclude this section, we provide the proof that the results of all terminal chasing sequences of a tableau query q by a set F of fd’s and jd’s are identical.	x-1250-1
To this end, we first introduce tools to describe correspondences between the free tuples occurring in the different elements of chasing sequences.	x-1250-2
Functional and Join Dependency Let (T , t) = (T0, t0), .	x-1251-1
.	x-1251-2
.	x-1251-3
, (Tn, tn) be a chasing sequence of (T , t) by F. Then for each i ∈ [1, n], the chase homomorphism for step i, denoted θi, is an assignment with domain var(Ti) defined as follows:	x-1251-4
The chase homomorphism of this chasing sequence is θ = θ1 ◦ · · · ◦ θn.	x-1252-1
If w ∈ (T ∪ {t}), then the tuple corresponding to w in (Ti, ti) is wi = θ1 ◦ · · · ◦ θi(w).	x-1252-2
It may arise that ui = vi for distinct tuples u, v in T .	x-1252-3
Observe that θ1 ◦ · · · ◦ θi(T ) ⊆ Ti and that, because of the jd rule, the inclusion may be strict.	x-1252-4
We now have the following: Lemma 8.4.17 Suppose that I |= F, ν is a substitution over var(T ), ν(T ) ⊆ I , and (T0, t0), .	x-1253-1
.	x-1253-2
.	x-1253-3
, (Tn, tn) is a chasing sequence of (T , t) by F. Then ν(wi) = ν(w) for each i ∈ [1, n] and each w ∈ (T ∪ {t}),	x-1253-4
Crux Use an induction on the chasing sequence (Exercise 8.24d).	x-1254-1
Observe that this also holds if I is a tableau over R that satisfies F. This is used in the following result.	x-1255-1
Theorem 8.4.18 Let (T , t) be a tableau query over R and F a set of fd’s and jd’s over R. Then the results of all terminal chasing sequences of (T , t) by F are identical.	x-1256-1
Proof Let (T ′, t′) and (T ′′, t′′) be the results of two terminal chasing sequences on (T , t) using F, and let θ ′, θ ′′ be the chase homomorphisms of these chasing sequences.	x-1257-1
For each tuple w ∈ T , let w′ denote the tuple of T ′ that corresponds to w, and similarly for w′′, T ′′.	x-1257-2
By construction, θ ′′(T ) ⊆ T ′′ and θ ′′(t) = t′′.	x-1258-1
Because T ′′ |= F and θ ′′(T ) ⊆ T ′′, θ ′′(T ′) ⊆ T ′′ by Lemma 8.4.17 considering the chasing sequence leading to T ′.	x-1258-2
The same argument shows that θ ′′(w′) = w′′ for each w in T and θ ′′(t′) = t′′.	x-1258-3
By symmetry, θ ′(T ′′) ⊆ T ′, θ ′(w′′) = w′ for each w in T and θ ′(t′′) = t′.	x-1258-4
We next prove that	x-1259-1
Let w′′ be in T ′′ for some w in T .	x-1260-1
Then	x-1260-2
Bibliographic Notes Observe that each variable x in var(T ′′) occurs in w′′, for some w in T .	x-1261-1
Thus θ ′ ◦ θ ′′ is the identity over var(T ′′).	x-1261-2
We therefore have	x-1261-3
By symmetry, θ ′′ ◦ θ ′ is the identity over var(T ′) and	x-1262-1
Thus |T ′′| = |T ′|.	x-1263-1
Because θ ′′(T ′) ⊆ T ′′, θ ′′(T ′) = T ′′ and θ ′′ is an isomorphism from (T ′, t ′) to (T ′′, t′′), so (*) holds.	x-1263-2
To conclude, we prove that	x-1264-1
We first show that for each pair x, y of variables occurring in T , (†)	x-1265-1
Suppose that θ ′′(x) = θ ′′(y).	x-1266-1
Then for some tuples u, v ∈ T and attributes A, B, we have u(A) = x, v(B) = y and u′′(A) = θ ′′(x) = θ ′′(y) = v′′(B).	x-1266-2
Next θ ′(x) = u′(A) and θ ′(y) = v′(B).	x-1266-3
Because θ ′ is an isomorphism from (T ′′, t′′) to (T ′, t′) and θ ′(u′′) = u′, θ ′(v′′) = v′, it follows that u′(A) = v′(B).	x-1266-4
Hence θ ′(x) = u′(A) = v′(B) = θ ′(y) as desired.	x-1266-5
The if direction follows by symmetry.	x-1266-6
Now let x ∈ var(T ′).	x-1267-1
To prove (**) and the theorem, it now suffices to show that θ ′′(x) = x.	x-1267-2
Let	x-1267-3
First (†) implies that A′ = A′′.	x-1268-1
Furthermore, an induction on the chasing sequence for (T ′, t′) shows that for each z ∈ A′, θ ′(z) is the least (under the ordering on var) element of A′, and similarly for (T ′′, t′′).	x-1268-2
Thus θ ′ and θ ′′ map all elements of A′ and A′′ to the same variable z.	x-1268-3
Because x ∈ var(T ′), it follows that z = x so, in particular, θ ′(x) =	x-1268-4
Bibliographic Notes On a general note, we first mention that comprehensive presentations of dependency theory can be found in [Var87, FV86].	x-1269-1
A more dense presentation is provided in [Kan91].	x-1269-2
Dependency theory is also the topic of the book [Tha91].	x-1270-1
Research on general integrity constraints considered from the perspective of first-order logic is presented in [GM78].	x-1271-1
Other early work in this framework includes [Nic78], which observes that fd’s and mvd’s have a natural representation in logic, and [Nic82], which Functional and Join Dependency considers incremental maintanence of integrity constraints under updates to the underlying state.	x-1271-2
Functional dependencies were introduced by Codd [Cod72b].	x-1272-1
The axiomatization is due to [Arm74].	x-1272-2
The problem of implication is studied in [BB79, Mai80].	x-1272-3
Several alternative formulations of fd implication, including formulation in terms of the propositional calculus perspective (see Exercise 8.22), are mentioned in [Kan91]; they are due to [SDPF81, CK85, CKS86].	x-1272-4
The structure of families of instances specified by a set of fd’s is studied in [GZ82, Hul84].	x-1273-1
Multivalued dependencies were discovered independently in [Zan76, Fag77b, Del78].	x-1274-1
They were generalized in [Ris77, Nic78, ABU79].	x-1275-1
The axiomatization of fd’s and mvd’s is from [BFH77].	x-1275-2
A probabilistic view of mvd’s in terms of conditional independence is presented in [PV88, Pea88].	x-1275-3
This provides an alternative motivation for the study of such dependencies.	x-1275-4
The issue of whether there is an axiomatization for jd’s has a lengthy history.	x-1276-1
As will be detailed in Chapter 10, the family of full typed dependencies subsumes the family of jd’s, and an axiomatization for these was presented in [BV84a, YP82]; see also [SU82].	x-1276-2
More focused axiomatizations, which start with jd’s and end with jd’s but use slightly more general dependencies at intermediate stages, are presented in [Sci82] and [BV85]; see also	x-1277-1
The connection between the chase and the more general theorem-proving technique of resolution with paramodulation (see [CL73]) is observed and analyzed in [BV80b].	x-1278-1
The chase technique is applied to datalog programs in [RSUV89, RSUV93].	x-1278-2
Exercises Exercise 8.1 Describe the set of fd’s, mvd’s, and jd’s that are tautologies (i.e., dependencies that are satisfied by all instances) for a relation schema R.	x-1279-1
Exercises Exercise 8.2 Let F1 be as in Example 8.2.4.	x-1280-1
Prove that F1 |= AD → E and F1 |= CDE → C.	x-1280-2
Exercise 8.3 Let U be a set of attributes, and let F, Ŵ be sets of dependencies over U .	x-1281-1
Show that	x-1281-2
State and prove analogous results for fd closures of attribute sets.	x-1282-1
Exercise 8.4 Prove Lemma 8.2.6.	x-1283-1
Exercise 8.5 Let U be a set of attributes and F a set of fd’s over U .	x-1284-1
Prove the soundness of FD1, FD2, FD3 and show that If F ⊢ X → Y and F ⊢ X → Z, then F ⊢ X → Y Z.	x-1284-2
Exercise 8.6 Let F be a set of fd’s over U .	x-1285-1
Hint: For each unused fd W → Z in F, record the number attributes of W not yet in closure.	x-1286-1
To do this efficiently, maintain a list for each attribute A of those unused fd’s of F for which A occurs in the left-hand side.	x-1287-1
Exercise 8.8 Give a proof of AB → F from F = {AB → C, A → D, CD → EF } using	x-1288-1
Exercise 8.9 Prove or disprove the soundness of the following rules: FD4: (pseudo-transitivity) If X → Y and Y W → Z, then XW → Z.	x-1289-1
FD5: (union) If X → Y and X → Z, then X → Y Z.	x-1290-1
FD6: (decomposition) If X → Y Z, then X → Y .	x-1291-1
MVD4: (pseudo-transitivity) If X →	x-1292-1
MVD5: (union) If X →	x-1293-1
MVD6: (decomposition) If X → X →	x-1294-1
bad-FD1: If XW → Y and XY → Z, then X → (Z − W ).	x-1295-1
bad-MVD1: If X →	x-1296-1
bad-FMVD1: If X →	x-1297-1
Exercise 8.10 Continuing with Exercise 8.9,	x-1298-1
Functional and Join Dependency	x-1299-1
Exercise 8.11	x-1300-1
S2: If Y ∈ satset and Z ∈ satset, then Y ∩ Z ∈ satset.	x-1301-1
Prove that satset = satset(Ŵ) for some set Ŵ of fd’s over U .	x-1302-1
Hint: Use Ŵ = {Y → Z| for each X ∈ satset, if Y ⊆ X then Z ⊆ X}.	x-1302-2
Exercise 8.12 Let F and Ŵ be sets of fd’s over U .	x-1303-1
Using the notation of Exercise 8.11, (a) Show that satset(F ∪ Ŵ) = satset(F) ∩ satset(Ŵ).	x-1303-2
Exercise 8.13	x-1304-1
i=1 i | n ≥ 0 and each Xi ∈ F }	x-1305-1
Exercise 8.14	x-1306-1
Develop an O(n2) algorithm that takes as input a set F of fd’s and produces as output a set F′ ≡ F, where F′ has no extraneous attributes.	x-1307-1
Exercise 8.15 Show that there is no set F of jd’s and fd X → A such that F |= X → A.	x-1308-1
Hint: Show that for any instance I there exists an instance I ′ such that I ⊆ I ′ and I ′ |= F. Then choose I violating X → A.	x-1308-2
Exercise 8.16 be a set of attributes and X, Y ⊆ U .	x-1309-1
Given an instance I over U and a tuple x ∈ πX(I ), the image Exercises of x on Y in I is the set image Y (x, I ) = πY (σX=x(I )) of tuples over Y .	x-1309-2
Prove that I |= X → iff for each x ∈ πX(I ) and each z ∈ image Z(x, I ), image Y (x, I ) = image Y (xz, I ), where Z = U − XY and xz denotes the tuple w over XZ such that πX(w) = x and πZ(w) = z.	x-1309-3
Claim 2: If A, B ∈ Wi for some i ∈ [1, n], then I |= A → B.	x-1310-1
Claim 3: For each i ∈ [1, n], I |= ∅ →	x-1311-1
Exercise 8.18 Prove Corollary 8.3.6.	x-1312-1
Exercise 8.19 MVD7: X →	x-1313-1
MVD8: If Y ∩ Z = ∅, X →	x-1314-1
FMVD3: If Y ∩ Z = ∅, X →	x-1315-1
Prove that {MVD7, MVD2, MVD8} are sound and complete for inferring implication for mvd’s, and that {FD1, FD2, FD3, MVD7, MVD2, MVD8, FMVD1, FMVD3} are sound and complete for inferring implication for fd’s and mvd’s considered together.	x-1316-1
Exercise 8.20 Y ∈ F} ∪ {X →	x-1317-1
Hint: For (b) do an induction on proofs using the inference rules.	x-1318-1
Exercise 8.21 For sets F and Ŵ of dependencies over U , F implies Ŵ for two-element instances, denoted F |=2 Ŵ, if for each instance I over U with |I | ≤ 2, I |= F implies I |= Ŵ.	x-1319-1
It satisfies an mvd X → or ξ(U − Y ) = T .	x-1320-1
Given a set F ∪ {σ } of fd’s and mvd’s, F implies σ in the propositional calculus, denoted F |=prop σ , if for each truth assignment ξ , ξ |= F implies ξ |= σ .	x-1320-2
Prove that for all sets F ∪ {σ } of fd’s and mvd’s, F |= σ iff F |=prop σ .	x-1320-3
Functional and Join Dependency	x-1321-1
Exercise 8.26 Prove Proposition 8.4.6.	x-1322-1
Hint: Rather than modifying the proof of Theorem 8.4.18, prove as a lemma that if F |= σ , then chase(T , t, F) = chase(T , t, F ∪ {σ }).	x-1322-2
Exercise 8.27	x-1323-1
Exercise 8.28 For each of the following relation schemas R, SPJ expressions q over R, and dependencies F over R, simplify q knowing that it is applied only to instances over R satisfying F. Use tableau minimization and the chase.	x-1324-1
Exercise 8.31 Exercises	x-1325-1
Exercise 8.32	x-1326-1
SSD1: If A is an attribute, then s(A).	x-1327-1
SSD2: If s(X) and Y ⊆ X, then s(Y ).	x-1328-1
SSD3: If s(X), s(Y ) and s(X △ Y ), then s(XY ) [where X △ Y denotes (X − Y ) ∪ (Y − X), i.e., the symmetric difference of X and Y ].	x-1329-1
Vittorio: Fd’s and jd’s give some structure to relations.	x-1330-1
But there are no connections between them.	x-1331-1
Sergio: Making connections is the next step .	x-1332-1
.	x-1332-2
.	x-1332-3
Riccardo:	x-1333-1
The story of inclusion dependencies starts in a manner similar to that for functional dependencies: Implication is decidable (although here it is pspace-complete), and there is a simple set of inference rules that is sound and complete.	x-1334-1
But the story becomes much more intriguing when functional and inclusion dependencies are taken together.	x-1334-2
First, the notion of logical implication will have to be refined because the behavior of these dependencies taken together is different depending on whether infinite instances are permitted.	x-1335-1
Second, both notions of logical implication are nonrecursive.	x-1335-2
And third, it can be proven in a formal sense that no “finite” axiomatization exists for either notion of logical implication of the dependencies taken together.	x-1335-3
At the end of this chapter, two restricted classes of inclusion dependencies are discussed.	x-1335-4
These are significant because they arise in modeling certain natural relationships such as those encountered in semantic data models.	x-1335-5
Positive results have been obtained for inclusion dependencies from these restricted classes considered with fd’s and other dependencies.	x-1336-1
Unlike fd’s or jd’s, a single inclusion dependency may refer to more than one relation.	x-1337-1
Inclusion Dependency in Isolation To accommodate the fact that inclusion dependencies permit the comparison of values from different columns of one or more relations, we introduce the following notation.	x-1338-1
Let R be a relation schema and X = A1, .	x-1338-2
.	x-1338-3
.	x-1338-4
, An a sequence of attributes (possibly with repeats) from R. For an instance I of R, the projection of I onto the sequence X, denoted I [X], is the n-ary relation {t (A1), .	x-1338-5
.	x-1338-6
.	x-1338-7
, t (An) | t ∈ I }.	x-1338-8
The syntax and semantics of inclusion dependencies is now given by the following: 192 Definition 9.1.1 Let R be a relational schema.	x-1339-1
An inclusion dependency (ind) over R is an expression of the form σ = R[A1, .	x-1339-2
.	x-1339-3
.	x-1339-4
, Am] ⊆ S[B1, .	x-1339-5
.	x-1339-6
.	x-1339-7
, Bm], where (a) R, S are (possibly identical) relation names in R,	x-1339-8
Satisfaction of a set of ind’s is defined in the natural manner.	x-1340-1
To illustrate this definition, we recall an example from the previous chapter.	x-1341-1
Example 9.1.2 There are two relations: Movies with attributes Title, Director, Actor and Showings with Theater, Screen, Title, Snack; and we have an ind Showings[ Title] ⊆ Movies[ Title].	x-1342-1
The generalization of ind’s to permit repeated attributes on the left-or right-hand side is considered in Exercise 9.4.	x-1343-1
The notion of logical implication between sets of ind’s is defined in analogy with that for fd’s.	x-1344-1
(This will be refined later when fd’s and ind’s are considered together.)	x-1344-2
Rules for Inferring ind Implication The following set of inference rules will be shown sound and complete for inferring logical implication between sets of ind’s.	x-1344-3
The variables X, Y , and Z range over sequences of distinct attributes; and R, S, and T range over relation names.	x-1344-4
IND1: (reflexivity) R[X] ⊆ R[X].	x-1345-1
IND2: (projection and permutation) If R[A1, .	x-1346-1
.	x-1346-2
.	x-1346-3
, Am] ⊆ S[B1, .	x-1346-4
.	x-1346-5
.	x-1346-6
, Bm], then R[Ai , 1 k i1 ik	x-1346-7
IND3: (transitivity) If R[X] ⊆ S[Y ] and S[Y ] ⊆ T [Z], then R[X] ⊆ T [Z].	x-1347-1
The notions of proof and of provability (denoted ⊢) using these rules are defined in analogy with that for fd’s.	x-1348-1
Theorem 9.1.3 The set {IND1, IND2, IND3} is sound and complete for logical impli- cation of ind’s.	x-1349-1
Proof Soundness of the rules is easily verified.	x-1350-1
For completeness, let F be a set of ind’s over database schema R = {R1, .	x-1350-2
.	x-1350-3
.	x-1350-4
, Rn}, and let σ = Ra[A1, .	x-1350-5
.	x-1350-6
.	x-1350-7
, Am] ⊆ Rb[B1, .	x-1350-8
.	x-1350-9
.	x-1350-10
, Bm] Inclusion Dependency be an ind over R such that F |= σ .	x-1350-11
We construct an instance I of R and use it to demonstrate that F ⊢ σ .	x-1350-12
To begin, let s′ be the tuple over Ra such that s′(Ai) = i for i ∈ [1, m] and s′(B) = 0 otherwise.	x-1351-1
Set I(Ra) = {s′} and I(Rj ) = ∅ for j = a.	x-1351-2
We now apply the following rule to I until it can no longer be applied.	x-1351-3
If Ri[C1, .	x-1352-1
.	x-1352-2
.	x-1352-3
, Ck] ⊆ Rj [D1, .	x-1352-4
.	x-1352-5
.	x-1352-6
, Dk] ∈ F and t ∈ I(Ri), then add (∗) u to I(Rj ), where u(Dl) = t (Cl) for l ∈ [1, k] and u(D) = 0 for D	x-1352-7
Remark 9.1.4 This construction is reminiscent of the chase for join dependencies.	x-1353-1
It differs because the ind’s may be embedded.	x-1353-2
Intuitively, an ind may not specify all the entries of the tuples we are adding.	x-1353-3
In the preceding rule (∗), the same value (0) is always used for tuple entries that are otherwise unspecified.	x-1353-4
It is easily seen that J |= F. Because F |= σ , we have J |= σ .	x-1354-1
To conclude the proof, we show the following: If for some Rj in R, u ∈ J(Rj ), integer q, and distinct attributes (∗∗) C1, .	x-1354-2
.	x-1354-3
.	x-1354-4
, Cq in sort(Rj ), u(Cp) > 0 for p ∈ [1, q], then F ⊢ Ra[Au(C1), .	x-1354-5
.	x-1354-6
.	x-1354-7
, Au(Cq)] ⊆ Rj[C1, .	x-1354-8
.	x-1354-9
.	x-1354-10
, Cq].	x-1354-11
Suppose that (∗∗) holds.	x-1355-1
Let s′′ be a tuple of J(Rb) such that s′′[B1, .	x-1355-2
.	x-1355-3
.	x-1355-4
, Bm] = s′[A1, .	x-1355-5
.	x-1355-6
.	x-1355-7
, Am].	x-1355-8
(Such a tuple exists because J |= σ .)	x-1355-9
Use (∗∗) with Rj = Rb, q = m, C1, .	x-1355-10
.	x-1355-11
.	x-1355-12
, Cq = B1, .	x-1355-13
.	x-1355-14
.	x-1355-15
, Bm.	x-1355-16
To demonstrate (∗∗), we show inductively that it holds for all tuples of J by considering them in the order in which they were inserted.	x-1356-1
The claim holds for s in J(Ra) by IND1.	x-1356-2
Suppose now that Rj [D1, .	x-1357-1
.	x-1357-2
.	x-1357-3
, Dk] ∈ F and tuple t ∈ I′(Ri).	x-1357-4
Now let {E1, .	x-1358-1
.	x-1358-2
.	x-1358-3
, Eq} be a set of distinct attributes in sort(Rj ) with u(Ep) > 0 for p ∈ F ⊢ Ri[Cρ(1), .	x-1358-4
.	x-1358-5
.	x-1358-6
, Cρ(q)] ⊆ Rj [E1, .	x-1358-7
.	x-1358-8
.	x-1358-9
, Eq].	x-1358-10
By the inductive assumption, F ⊢ Ra[At(Cρ(1)), .	x-1359-1
.	x-1359-2
.	x-1359-3
, At(Cρ(q))] ⊆ Ri[Cρ(1), .	x-1359-4
.	x-1359-5
.	x-1359-6
, Cρ(q)].	x-1359-7
Thus, by IND3, F ⊢ Ra[At(Cρ(1)), .	x-1360-1
.	x-1360-2
.	x-1360-3
, At(Cρ(q))] ⊆ Rj[E1, .	x-1360-4
.	x-1360-5
.	x-1360-6
, Eq].	x-1360-7
Finally, observe that for each p, t (Cρ(p)) = u(Dρ(p)) = u(Ep), so F ⊢ Ra[Au(E1), .	x-1361-1
.	x-1361-2
.	x-1361-3
, Au(Eq)] ⊆ Rj[E1, .	x-1361-4
.	x-1361-5
.	x-1361-6
, Eq].	x-1361-7
Deciding Logical Implication for ind’s The proof of Theorem 9.1.3 yields a decision procedure for determining logical implication between ind’s.	x-1362-1
To see this, we use the following result: Proposition 9.1.5 Let F be a set of ind’s over R and Ra[A1, .	x-1362-2
.	x-1362-3
.	x-1362-4
, Am] ⊆ Rb[B1, .	x-1362-5
.	x-1362-6
.	x-1362-7
, Bm].	x-1362-8
Then F |= Ra[A1, .	x-1362-9
.	x-1362-10
.	x-1362-11
, Am] ⊆ Rb[B1, .	x-1362-12
.	x-1362-13
.	x-1362-14
, Bm] iff there is a sequence Ri [ C Ri [ C k k] such that j Cj is a sequence of m distinct attributes in sort(Ri ) for j ∈ [1, k]; j C C k k] = Rb[B1, .	x-1362-15
.	x-1362-16
.	x-1362-17
, Bm]; C C j j ] ⊆ Rij+1 j +1] can be obtained from an ind in F by one application of rule IND2, for j ∈ [1, (k − 1)].	x-1362-18
Crux Use the instance J constructed in the proof of Theorem 9.1.3.	x-1363-1
Working backward from the tuple s′′ in J(Rb), a chain of relation-tuple pairs (Ri , s j j ) can be constructed so that each of 1, .	x-1363-2
.	x-1363-3
.	x-1363-4
, m occurs exactly once in sj , and sj+1 is inserted into I as a result of sj and IND2.	x-1363-5
Based on this, it is straightforward to verify that the following algorithm determines logical implication between ind’s.	x-1364-1
Note that only ind’s of arity m are considered in the algorithm.	x-1364-2
Input: A set F of ind’s over R and ind Ra[A1, .	x-1365-1
.	x-1365-2
.	x-1365-3
, Am] ⊆ Rb[B1, .	x-1365-4
.	x-1365-5
.	x-1365-6
, Bm].	x-1365-7
Output: Determine whether F |= Ra[A1, .	x-1366-1
.	x-1366-2
.	x-1366-3
, Am] ⊆ Rb[B1, .	x-1366-4
.	x-1366-5
.	x-1366-6
, Bm].	x-1366-7
Procedure: Build a set E of expressions of the form Ri[C1, .	x-1367-1
.	x-1367-2
.	x-1367-3
, Cm] as follows: 1.	x-1367-4
E := {Ra(A1, .	x-1367-5
.	x-1367-6
.	x-1367-7
, Am)}.	x-1367-8
Inclusion Dependency If Ri[C1, .	x-1368-1
.	x-1368-2
.	x-1368-3
, Cm] ∈ E and Ri[C1, .	x-1368-4
.	x-1368-5
.	x-1368-6
, Cm] ⊆ Rj [D1, .	x-1368-7
.	x-1368-8
.	x-1368-9
, Dm] can be derived from an ind of F by one application of IND2, then insert Rj [D1, .	x-1368-10
.	x-1368-11
.	x-1368-12
, Dm] into E.	x-1368-13
Theorem 9.1.7 Deciding logical implication for ind’s is pspace-complete.	x-1369-1
Crux	x-1370-1
Linear Space Acceptance (LSA) problem Input: The description of a linear bounded machine M and an input word x; Output: yes iff M accepts x.	x-1371-1
The heart of the proof is, given an instance (M, x) of the LSA problem, to construct a set F of ind’s and an ind σ such that F |= σ iff x is accepted by M.	x-1372-1
Let M = (K, Ŵ, K, s, h) be a Turing machine with states K, alphabet Ŵ, transition relation K, start state s, and accepting state h; and let x = x1 .	x-1373-1
.	x-1373-2
.	x-1373-3
xn ∈ Ŵ∗ have length n.	x-1373-4
Configurations of M are viewed as elements of Ŵ∗KŴ+ with length n + 1, where the placement of the state indicates the head position (the state is listed immediately left of the scanned letter).	x-1374-1
Observe that transitions can be described by expressions of the form α1, α2, α3 → β1, β2, β3 with α1, .	x-1374-2
.	x-1374-3
.	x-1374-4
, β3 in (K ∪ Ŵ).	x-1374-5
For instance, the transition corresponds to a, p, b → p, a, c for each a in Ŵ.	x-1374-6
Let χ be the set of all such expressions corresponding to transitions of M.	x-1374-7
The initial configuration is sx.	x-1375-1
The final configuration is h bn for some particular letter b, iff M accepts x.	x-1375-2
The ind’s of F are defined over a single relation R. The attributes of R are {Ai,j | i ∈	x-1376-1
The ind σ is R[(s, 1), (x1, 2), .	x-1377-1
.	x-1377-2
.	x-1377-3
, (xn, n + 1)] ⊆ R[(h, 1), ( b, 2), .	x-1377-4
.	x-1377-5
.	x-1377-6
, ( b, n + 1)].	x-1377-7
The ind’s in F correspond to valid moves of M. In particular, for each j ∈ [1, n − 1], F includes all ind’s of the form R[(α1, j ), (α2, j + 1), (α3, j + 2), where α1, α2, α3 → β1, β2, β3 is in χ, and of the attributes in Ŵ × {1, .	x-1378-1
.	x-1378-2
.	x-1378-3
, j − 1, j + 3, .	x-1378-4
.	x-1378-5
.	x-1378-6
, n + 1}.	x-1378-7
Thus each ind in F has arity 3 + (n − 2)|Ŵ|, and |F| ≤ n|K|.	x-1378-8
construction is still polynomial in the size of the linear space automaton problem (M, x).	x-1379-1
Using Proposition 9.1.5, it is now straightforward to verify that F |= σ iff M has an accepting computation of x.	x-1380-1
Exercise 9.10).	x-1381-1
The latter case arises in examples such as Grad − Stud[ Name, Major] ⊆ Student[ Name, Major].	x-1381-2
This theme is also examined at the end of this chapter.	x-1381-3
Finite versus Infinite Implication We now turn to the interaction between ind’s and fd’s, which leads to three interesting phenomena.	x-1382-1
The first of these requires a closer look at the notion of logical implication.	x-1382-2
Consider the notion of logical implication used until now: F logically implies σ if for all relation (or database) instances I, I |= F implies I |= σ .	x-1383-1
Although this notion is close to the corresponding notion of mathematical logic, it is different in a crucial way: In the context of databases considered until now, only finite instances are considered.	x-1383-2
From the point of view of logic, the study of logical implication conducted so far lies within finite model theory.	x-1383-3
It is also interesting to consider logical implication in the traditional mathematical logic framework in which infinite database instances are permitted.	x-1384-1
As will be seen shortly, when fd’s or ind’s are considered separately, permitting infinite instances has no impact on logical implication.	x-1384-2
However, when fd’s and ind’s are taken together, the two flavors of logical implication do not coincide.	x-1384-3
The notion of infinite relation and database instances is defined in the natural manner.	x-1385-1
Inclusion Dependency R B R B	x-1386-1
Figure 9.1: Instances used for distinguishing |=fin and |=unr Definition 9.2.1	x-1387-1
If finite and unrestricted implication coincide, or if the kind of implication is understood from the context, then we may use |= rather than |=fin or |=unr.	x-1388-1
This is what we implicitly did so far by using |= in place of |=fin.	x-1388-2
Of course, if F |=unr σ , then F |=fin σ .	x-1389-1
The following shows that the converse need not hold: Theorem 9.2.2	x-1389-2
Proof For part (a), let R be binary with attributes A, B; let F = {A → B, R[A] ⊆ R[B]}; and let σ be R[B] ⊆ R[A].	x-1390-1
To see that F |=fin σ , let I be a finite instance of R that satisfies F. Because I |= A → B, |πA(I )| ≥ |πB(I )| and because I |= R[A] ⊆ R[B], |πB(I )| ≥	x-1390-2
On the other hand, the instance shown in Fig.	x-1391-1
9.1(a) demonstrates that F |=unr σ .	x-1391-2
For part (b), let F be as before, and let σ be the fd B → A.	x-1392-1
As before, if I |= F, then	x-1392-2
It is now natural to reconsider implication for fd’s, jd’s, and inds taken separately and in combinations.	x-1393-1
Are unrestricted and finite implication different in these cases?	x-1393-2
The answer is given by the following: Theorem 9.2.3 Unrestricted and finite implication coincide for fd’s and jd’s considered separately or together and for ind’s considered alone.	x-1393-3
Proof Unrestricted implication implies finite implication by definition.	x-1394-1
For fd’s and jd’s taken separately or together, Theorem 8.4.12 on the relationship between chasing and logical implication can be used to obtain the opposite implication.	x-1394-2
For ind’s, Theorem 9.1.3 shows that finite implication and provability by the ind inference rules are equivalent.	x-1394-3
It is easily verified that these rules are also sound for unrestricted implication.	x-1394-4
Thus finite implication implies unrestricted implication for ind’s as well.	x-1394-5
The notion of finite versus unrestricted implication will be revisited in Chapter 10, where dependencies are recast into a logic-based formalism.	x-1395-1
Implication Is Undecidable for fd’s + ind’s	x-1396-1
The Word Problem for (Finite) Monoids The proof that (finite) implication for fd’s and ind’s taken together is undecidable uses a reduction from the word problem for monoids, which we discuss next.	x-1397-1
i ∈ [1..n]} be a finite set of equalities, and let e be an additional equality α = β, where αi, βi, α, β ∈ Ŵ∗.	x-1398-1
Then E (finitely) implies e, denoted E |=unr e (E |=fin e), if for each (finite) monoid M and homomorphism h : Ŵ∗ → M, if h(αi) = h(βi) for each i ∈ [1..n], then h(α) = h(β).	x-1398-2
The word problem for (finite) monoids is to decide, given E and e, whether E |=unr e (E |=fin e).	x-1398-3
Both the word problem for monoids and the word problem for finite monoids are undecidable.	x-1398-4
Using this, we have the following: Theorem 9.2.4 Unrestricted and finite implication for fd’s and ind’s considered together are undecidable.	x-1399-1
In particular, let F range over sets of fd’s and ind’s.	x-1399-2
The following sets are not recursive: Inclusion Dependency	x-1399-3
Crux We prove (a) using a reduction from the word problem for (finite) monoids to the (finite) implication problem for fd’s and ind’s.	x-1400-1
The proof of part (b) is similar and is left for Exercise 9.5.	x-1400-2
We first consider the unrestricted case.	x-1400-3
Let Ŵ be a fixed alphabet.	x-1401-1
Let E = {αi = βi | i ∈ [1, n]} be a set of equalities over Ŵ∗, and let e be another equality α = β.	x-1401-2
A prefix is defined to be any prefix of αi, βi, α, or β (including the empty string ε, and full words α1, β1, etc.).	x-1401-3
A single relation R is used, which has attributes where x and y are two fixed symbols.	x-1401-4
To understand the correspondence between constrained relations and homomorphisms over monoids, suppose that there is a homomorphism h from Ŵ∗ to some monoid M.	x-1402-1
Intuitively, a tuple of R will hold information about two elements h(x), h(y) of M (in columns Ax, Ay, respectively) and their product h(x) ◦ h(y) = h(xy) (in column Axy).	x-1403-1
For each a in Ŵ, tuples will also hold information about h(ya) and h(xya) in columns Aya, Axya.	x-1404-1
More precisely, the instance IM,h corresponding to the monoid M and the homomorphism h : Ŵ∗ → M is defined by IM,h = {tu,v | u, v ∈ Ŵ∗}, where for each u, v ∈ Ŵ∗, tu,v is the tuple such that tu,v(Ax) = h(u), tu,v(Aγ ) = h(γ ), for each prefix γ , tu,v(Ay) = h(v), tu,v(Aya) = h(va), for each a ∈ Ŵ, tu,v(Axy) = h(uv), tu,v(Axya) = h(uva), for each a ∈ Ŵ.	x-1404-2
Formally, to force the correspondence between the relations and homomorphisms over monoids, we use a set F of dependencies.	x-1405-1
In other words, we wish to find a set F of dependencies that characterizes precisely the instances over R that correspond to some homomorphism h from Ŵ∗ to some monoid M. The key to the proof is that this can be done using just fd’s and ind’s.	x-1405-2
Strictly speaking, the dependencies of (8) in the following list are not ind’s because an attribute is repeated in the left-hand side.	x-1405-3
As discussed in Exercise 9.4(e), the set of dependencies used here can be modified to a set of proper ind’s that has the desired properties.	x-1405-4
In addition, we use fd’s with an empty left-hand side, which are sometimes not considered as real fd’s.	x-1405-5
The use of such dependencies is not crucial.	x-1405-6
A slightly more complicated proof can be found that uses only fd’s with a nonempty left-hand side.	x-1405-7
The set F is defined as follows:	x-1405-8
i The ind σ is R[Aα] ⊆ R[Aβ].	x-1406-1
Let I be an instance satisfying .	x-1407-1
Observe that I has to satisfy a number of implied properties.	x-1407-2
In particular, one can verify that I also satisfies the following property: R[Axya] ⊆ R[Aya] ⊆ R[Ay] = R[Axy] ⊆ R[Ax]	x-1407-3
We now show that |=unr σ iff E |=unr e. We first show that E |=unr e implies	x-1408-1
For the opposite direction, suppose now that E |=unr e, and let I be a (possibly infinite) instance of R that satisfies .	x-1409-1
To conclude the proof, it must be shown that I [Aα] ⊆ I [Aβ].	x-1409-2
We now define a function h : Ŵ∗ → adom(I ).	x-1410-1
We will prove that h is a homomorphism from Ŵ∗ to a free monoid whose elements are h(Ŵ∗) and that satisfies the equations of E	x-1410-2
We now give an inductive definition of h and show that it has the property that h(v) ∈ I [Ay] for each v ∈ Ŵ∗.	x-1411-1
Basis: Set h(ε) to be the element in I [Aε].	x-1412-1
Note that h(ε) is also in I [Ay] because R[Aε] ⊆ R[Ay] ∈ .	x-1412-2
Inductive step: Given h(v) and a ∈ Ŵ, let t ∈ I be such that t[Ay] = h(v).	x-1413-1
Define h(va) = t (Aya).	x-1413-2
This is uniquely determined because Ay → Aya ∈ .	x-1413-3
In addition, h(va) ∈ I [Ay] because R[Ax, Aya, Axya] ⊆ R[Ax, Ay, Axy] ∈ .	x-1413-4
We next show by induction on v that h(u), h(v), h(uv) ∈ I [Ax, Ay, Axy] for each u, v ∈ Ŵ∗.	x-1414-1
For a fixed u, the basis (i.e., v = ε) is provided by the fact that h(u) ∈ I [Ay] and the ind R[Ay, Aε, Ay] ⊆ R[Ax, Ay, Axy] ∈ .	x-1415-1
For the inductive step, let h(u), h(v), h(uv) ∈ I [Ax, Ay, Axy] and a ∈ Ŵ.	x-1415-2
Let t ∈ I be such that t[Ax, Ay, Axy] = h(u), h(v), h(uv).	x-1415-3
Inclusion Dependency Then by construction of h, h(va) = t (Aya), and from the ind R[Axy, Axya] ⊆ R[Ay, Aya], we have h(uva) = t (Axya).	x-1416-1
Finally, the ind R[Ax, Aya, Axya] ⊆ R[Ax, Ay, Axy] implies that h(u), h(va), h(uva) ∈ I [Ax, Ay, Axy] as desired.	x-1416-2
Define the binary operation ◦ on h(Ŵ∗) as follows.	x-1417-1
For a, b ∈ h(Ŵ∗), let a ◦ b = c if for some t ∈ I , t[Ax, Ay, Axy] = a, b, c.	x-1417-2
There is such a tuple by (†) and c is uniquely defined because Ax, Ay → Axy ∈ .	x-1418-1
Furthermore, by (†), for each u, v, h(u) ◦ h(v) = h(uv).	x-1418-2
Thus for h(u), h(v), h(w) in h(Ŵ∗), (h(u) ◦ h(v)) ◦ h(w) = h(uvw) = (h(u) ◦ h(v)) ◦ h(w), h(u) ◦ h(ε) = h(u) so (h(Ŵ∗), ◦) is a monoid.	x-1418-3
In addition, h is a homomorphism from the free monoid over Ŵ∗ to the monoid (h(Ŵ∗), ◦).	x-1418-4
It is easy to see that I [Aα ] = {h(α i i )} and I [Aβi i )} for i ∈ [1, n].	x-1419-1
Let i be fixed.	x-1419-2
Because R[Aα ] ⊆ R[A ], h(α i i ) = h(βi ).	x-1419-3
Because E |=unr e, h(α) = h(β ).	x-1419-4
Thus I [Aα] = {h(α)} = {h(β)} = I [Aβ].	x-1419-5
It follows that I |=unr R[Aα] ⊆ R[Aβ] as desired.	x-1419-6
This completes the proof for the unrestricted case.	x-1420-1
For the finite case, note that everything has to be finite: The monoid is finite, I is finite, and the monoid h[Ŵ∗] is finite.	x-1420-2
The rest of the argument is the same.	x-1420-3
The issue of decidability of finite and unrestricted implication for classes of dependencies is revisited in Chapter 10.	x-1421-1
Nonaxiomatizability of fd’s + ind’s The inference rules given previously for fd’s, mvd’s and ind’s can be viewed as “inference rule schemas,” in the sense that each of them can be instantiated with specific attribute sets (sequences) to create infinitely many ground inference rules.	x-1422-1
In these cases the family of inference rule schemas is finite, and we informally refer to them as “finite axiomatizations.” Rather than formalizing the somewhat fuzzy notion of inference rule schema, we focus in this section on families R of ground inference rules.	x-1422-2
A ( ground) axiomatization of a family S of dependencies is a set of ground inference rules that is sound and complete for (finite or unrestricted) implication for S. Two properties of an axiomatization R will be considered, namely: (1) R is recursive, and (2) R is k-ary, in the sense (formally defined later in this section) that each rule in R has at most k dependencies in its condition.	x-1422-3
Speaking intuitively, if S has a “finite axiomatization,” that is, if there is a finite family R′ of inference rule schemas that is sound and complete for S, then R′ specifies a ground axiomatization for S that is both recursive and k-ary for some k. Two results are demonstrated in this section: (1) There is no recursive axiomatization for finite implication of fd’s and ind’s, and (2) there is no k-ary axiomatization for finite implication of fd’s and ind’s.	x-1423-1
It is also known that there is no k-ary axiomatization for unrestricted implication of fd’s and ind’s.	x-1423-2
The intuitive conclusion is that the family of fd’s and ind’s does not have a	x-1423-3
To establish the framework and some notation, we assume temporarily that we are dealing with a family F of database instances over a fixed database schema R =	x-1424-1
Let S be a family of dependencies over R. (At present, S would be the set of fd’s and ind’s over R.) Logical implication |= among dependencies in S is defined with respect to F in the natural manner.	x-1425-1
In particular, |=unr and |=fin are obtained by letting F be the set of unrestricted or finite instances.	x-1425-2
where S ⊆ S and s ∈ S.	x-1426-1
Let R be a set of rules over R. Then R is sound if each rule in R is sound.	x-1427-1
Let	x-1427-2
The aforementioned notions are now generalized to permit all schemas R. In particular, we consider a set R of rules that is a union ∪{RR | R is a schema}.	x-1428-1
The notions of sound, proof, etc.can be generalized in the natural fashion.	x-1428-2
Note that with the preceding definition, every set S of dependencies has a sound and complete axiomatization.	x-1429-1
This is provided by the set R of all rules of the form if S then s, where S |= s. Clearly, such trivial axiomatizations hold no interest.	x-1429-2
In particular, they are not necessarily effective (i.e., one may not be able to tell if a rule is in R, so one may not be able to construct proofs that can be checked).	x-1429-3
It is thus natural to restrict R to be recursive.	x-1429-4
We now present the first result of this section, which will imply that there is no recursive axiomatization for finite implication of fd’s and ind’s.	x-1430-1
In this result we assume that the dependencies in S are sentences in first-order logic.	x-1430-2
Proposition 9.3.1 Let S be a class of dependencies.	x-1431-1
If S has a recursive axiomatization for finite implications, then finite implication is decidable for S.	x-1431-2
Crux Suppose that S has a recursive axiomatization.	x-1432-1
Consider the set Inclusion Dependency Implic = {(S, s) | S ⊆ S, s ∈ S, and S |=fin s}.	x-1432-2
First note that the set Implic is r.e.	x-1433-1
; indeed, let R be a recursive axiomatization for S. One can effectively enumerate all proofs of implication that use rules in R. This allows one to enumerate Implic effectively.	x-1433-2
Thus Implic is r.e.	x-1433-3
We argue next that Implic is also co-r.e.	x-1433-4
To conclude that a pair (S, s) is not in Implic, it is sufficient to exhibit a finite instance satisfying S and violating s. To enumerate all pairs (S, s) not in Implic, one proceeds as follows.	x-1434-1
The set of all pairs (S, s) is clearly r.e., as is the set of all instances over a fixed schema.	x-1434-2
Repeat for all positive integers n the following.	x-1434-3
Enumerate the first n pairs (S, s) and the first n instances.	x-1434-4
For each (S, s) among the n, check whether one of the n instances is a counterexample to the implication S |= s, in which case output (S, s).	x-1434-5
Clearly, this procedure enumerates the complement of Implic, so Implic is co-r.e.	x-1434-6
Because it is both r.e.	x-1434-7
It follows that there is no recursive axiomatization for finite implication of fd’s and ind’s.	x-1435-1
[To see this, note that by Theorem 9.2.4, logical implication for fd’s and ind’s is undecidable.	x-1435-2
By Proposition 9.3.1, it follows that there can be no finite axiomatization for fd’s and ind’s.]	x-1435-3
Because implication for jd’s is decidable (Theorem 8.4.12), but there is no axiomatization for them (Theorem 8.3.4), the converse of the preceding proposition does not hold.	x-1435-4
Speaking intuitively, the preceding development implies that there is no finite set of inference rule schemas that is sound and complete for finite implication of fd’s and ind’s.	x-1436-1
However, the proof is rather indirect.	x-1436-2
Furthermore, the approach cannot be used in connection with unrestricted implication, nor with classes of dependencies for which finite implication is decidable (see Exercise 9.9).	x-1436-3
The notion of k-ary axiomatization developed now shall overcome these objections.	x-1436-4
We now turn to an analog in terms of logical implication of k-ary axiomatizability.	x-1437-1
closed under implication with respect to S if σ ∈ Ŵ whenever (a) σ ∈ S and (b) Ŵ |= σ closed under k-ary implication with respect to S if σ ∈ Ŵ whenever (a) σ ∈ S, and for some ⊆ Ŵ, (b1) |= σ and (b2) || ≤ k.	x-1438-1
Clearly, if Ŵ is closed under implication, then it is closed under k-ary implication for each k ≥ 0, and if Ŵ is closed under k-ary implication, then it is closed under k′-ary implication for each k′ ≤ k.	x-1439-1
Proposition 9.3.2 Let R be a database schema, S a set of dependencies over R, and k ≥ 0.	x-1440-1
Then there is a k-ary axiomatization for S iff whenever Ŵ ⊆ S is closed under k-ary implication, then Ŵ is closed under implication.	x-1440-2
Proof Suppose that there is a k-ary axiomatization for S, and let Ŵ ⊆ S be closed under k-ary implication.	x-1441-1
Suppose further that Ŵ |= σ for some σ ∈ S. Let σ1, .	x-1441-2
.	x-1441-3
.	x-1441-4
, σn be a proof of σ from Ŵ using R. Using the fact that R is k-ary and that Ŵ is closed under k-ary implication, a straightforward induction shows that σi ∈ Ŵ for i ∈ [1, n].	x-1441-5
Suppose now that for each Ŵ ⊆ S, if Ŵ is closed under k-ary implication, then Ŵ is closed under implication.	x-1442-1
Set R = {‘if S then s’ | S ⊆ S, s ∈ S, |S| ≤ k, and S |= s}.	x-1442-2
To see that R is complete, suppose that Ŵ |= σ .	x-1443-1
Consider the set Ŵ∗ = {γ | Ŵ ⊢R γ }.	x-1443-2
From the construction of R, Ŵ∗ is closed under k-ary implication.	x-1443-3
By assumption it is closed under implication, and so Ŵ ⊢R σ as desired.	x-1443-4
In the following, we consider finite implication, so F is the set of finite instances.	x-1444-1
Theorem 9.3.3 For no k does there exist a k-ary sound and complete axiomatization for finite implication of fd’s and ind’s taken together.	x-1445-1
More specifically, for each k there is a schema R for which there is no k-ary sound and complete axiomatization for finite implication of fd’s and ind’s over R.	x-1445-2
Proof Let k ≥ 0 be fixed.	x-1446-1
Let R = {R0, .	x-1446-2
.	x-1446-3
.	x-1446-4
, Rk} be a database schema where sort(Ri) =	x-1446-5
Let Ŵ be the union of with all fd’s and ind’s that are tautologies (i.e., that are satisfied by all finite instances over R).	x-1447-1
In the remainder of the proof, it is shown that (1) Ŵ is not closed under finite implication, but (2) Ŵ is closed under k-ary finite implication.	x-1448-1
Proposition 9.3.2 will then imply that the family of fd’s and ind’s has no k-ary sound and complete axiomatization for R.	x-1448-2
First observe that Ŵ does not contain σ , so to show that Ŵ is not closed under finite implication, it suffices to demonstrate that |=fin σ .	x-1449-1
Let I be a finite instance of R that satisfies .	x-1449-2
By the ind’s of , |I(Ri)[A]| ≤ |I(Ri+1)[B]| for each i ∈ [0, k], and by the fd’s of , |I(Ri)[B]| ≤ |I(Ri)[A]| for each i ∈ [0, k].	x-1449-3
From this we obtain Inclusion Dependency	x-1449-4
In particular, |I(Rk)[A]| = |I(R0)[B]|.	x-1450-1
Since I is finite and we have I(Rk)[A] ⊆ I(R0)[B]	x-1450-2
We now show that Ŵ is closed under k-ary finite implication.	x-1451-1
Suppose that $ ⊆ Ŵ has no more than k elements (|$| ≤ k).	x-1451-2
It must be shown that if γ is an fd or ind and $ |=fin γ , then γ ∈ Ŵ.	x-1451-3
Because contains k + 1 ind’s, any subset $ of Ŵ that has no more than k members must omit some ind δ of .	x-1451-4
We shall exhibit an instance I such that I |= γ iff γ ∈ Ŵ − {δ}.	x-1451-5
(Thus I will be an Armstrong instance for Ŵ − {δ}.)	x-1451-6
It will then follow that Ŵ − {δ} is closed under finite implication.	x-1451-7
Because $ ⊆ Ŵ − {δ}, this will imply that for each fd or ind γ , if $ |=fin γ , then Ŵ − {δ} |=fin γ , so γ ∈ Ŵ.	x-1451-8
Because is symmetric with regard to ind’s, we can assume without loss of generality that δ is the ind Rk[A] ⊆ R0[B].	x-1452-1
Assuming that N × N is contained in the underlying domain, define I so that I(R0) = { (0, 0), (0, k + 1), (1, 0), (1, k + 1), (2, 0), (1, k + 1)} I(Ri) = { (0, i), (0, i − 1), (1, i), (1, i − 1), .	x-1452-2
.	x-1452-3
.	x-1452-4
,	x-1452-5
Figure 9.2 shows I for the case k = 3.	x-1453-1
We now show for each fd and ind γ over R that I |= γ iff γ ∈ Ŵ − δ.	x-1454-1
Three cases arise: 1. γ is a tautology.	x-1454-2
Then this clearly holds.	x-1454-3
Ri : A → B, Ri : B → A, Ri : ∅ → A, Ri : ∅ → B, or Ri : ∅ → AB.	x-1455-1
If γ is Ri : A → B, then γ ∈ Ŵ and clearly I |= γ .	x-1456-1
In the other cases, γ ∈ Ŵ and I |= γ .	x-1456-2
I(R1)[A], I(R2)[B]; I(Rk−1)[A], I(Rk)[B].	x-1457-1
Furthermore, I |= Ri+1[B] ⊆ Ri[A] for each i ∈ [0, k]; and I |= Ri[A] ⊆ Ri+1[B].	x-1458-1
This implies that I |= γ iff γ ∈ Ŵ − {δ}, as desired.	x-1459-1
I(R0) B I(R1) B I(R2) B I(R3) B Figure 9.2: In the proof of the preceding theorem all relations used are binary, and all fd’s and ind’s are unary, in the sense that at most one attribute appears on either side of each dependency.	x-1460-1
In proofs that there is no k-ary axiomatization for unrestricted implication of fd’s and ind’s, some of the ind’s used involve at least two attributes on each side.	x-1461-1
This cannot be improved to unary ind’s, because there is a 2-ary sound and complete axiomatization for unrestricted implication of unary ind’s and arbitrary fd’s (see Exercise 9.18).	x-1461-2
Restricted Kinds of Inclusion Dependency This section explores two restrictions on ind’s for which several positive results have been obtained.	x-1462-1
The first one focuses on sets of ind’s that are acyclic in a natural sense, and the second restricts the ind’s to having only one attribute on either side.	x-1462-2
The restricted dependencies are important because they are sufficient to model many natural relationships, such as those captured by semantic models (see Chapter 11).	x-1462-3
These include subtype relationships of the kind “every student is also a person.” This section also presents a generalization of the chase that incorporates ind’s.	x-1462-4
Because ind’s are embedded, chasing in this context may lead to infinite chasing sequences.	x-1462-5
In the context of acyclic sets of ind’s, however, the chasing sequences are guaranteed to terminate.	x-1463-1
The study of infinite chasing sequences will be taken up in earnest in Chapter 10.	x-1463-2
Inclusion Dependency Ind’s and the Chase Because ind’s may involve more than one relation, the formal notation of the chase must be extended.	x-1464-1
Suppose now that R is a database schema, and let q = (T, t) be a tableau query over R. The fd and jd rules are generalized to this context in the natural fashion.	x-1464-2
We first present an example and then describe the rule that is used for ind’s.	x-1465-1
Example 9.4.1 Consider the database schemas consisting of two relation schemas P , Q with sort(P ) = ABC, sort(Q) = DEF, the dependencies Q[ DE] ⊆ P [ AB] P : A → B,	x-1466-1
The following rule is used for ind’s.	x-1467-1
ind rule: Let σ = R[X] ⊆ S[Y ] be an ind, let u ∈ T(R), and suppose that there is no free tuple v ∈ T(S) such that v[Y ] = u[X].	x-1468-1
In this case, we say that σ is applicable to R(u).	x-1468-2
Let w be a free tuple over S such that w[Y ] = u[X] and w has distinct new variables in all coordinates of sort(S) − Y that are greater than all variables occurring in q.	x-1469-1
Then	x-1469-2
For a tableau query q and a set of ind’s, it is possible that two terminal chasing sequences end with nonisomorphic tableau queries, that there are no finite terminal chasing sequences, or that there are both finite terminal chasing sequences and infinite chasing sequences (see Exercise 9.12).	x-1470-1
General approaches to resolving this problem will be considered in Chapter 10.	x-1470-2
In the present discussion, we focus on acyclic sets of ind’s, for which the chase always terminates after a finite number of steps.	x-1470-3
Definition 9.4.2 Si[Yi] (i ∈ [1, n]) of ind’s in where for i ∈ [1, n], Ri+1 = Si for i ∈ [1, n − 1], and R1 = Sn.	x-1471-1
A family of dependencies has acyclic ind’s if the set of ind’s in is acyclic.	x-1471-2
The following is easily verified (see Exercise 9.14): Proposition 9.4.3 Let q be a tableau query and a set of fd’s, jd’s, and acyclic ind’s over R. Then each chasing sequence of q by terminates after an exponentially bounded number of steps.	x-1472-1
T( P) B C T( Q) D E F x y 1 x y 2 x t y 1 x T T B C D E F x y w x y x y w x y x t y 1 x T T B C D E F x y w x y x y w x y x t y 1 x T T B C D E F x y x y w 1 x t y 1 x Figure 9.3: Chasing with ind’s For each tableau query q and set of fd’s, jd’s, and acyclic ind’s, let chase(q, ) denote the result of some arbitrary chasing sequence of q by .	x-1473-1
(One can easily come up with some syntactic strategy for arbitrarily choosing this sequence.)	x-1473-2
Using an analog to Lemma 8.4.3, one obtains the following result on tableau query containment (an analog to Theorem 8.4.8).	x-1473-3
Theorem 9.4.4 Let q, q′ be tableau queries and a set of fd’s, jd’s, and acyclic ind’s over R. Then q ⊆ q′ iff chase(q, ) ⊆ chase(q′, ).	x-1474-1
Next we consider the application of the chase to implication of dependencies.	x-1475-1
For database schema R and ind σ = R[X] ⊆ S[Y ] over R, the tableau query of σ is qσ = Inclusion Dependency x3, x4).	x-1475-2
In analogy with Theorem 8.4.12, we have the following for fd’s, jd’s, and acyclic ind’s.	x-1475-3
Theorem 9.4.5 Let be a set of fd’s, jd’s, and acyclic ind’s over database schema R	x-1476-1
This yields the following: Corollary 9.4.6 Finite and unrestricted implication for sets of fd’s, jd’s, and acyclic ind’s coincide and are decidable in exponential time.	x-1477-1
Unary Inclusion Dependencies	x-1478-1
For uind’s considered in isolation, the inference rules for ind’s are specialized to yield the following two rules, which are sound and complete for (unrestricted and finite) implication.	x-1479-1
Here A, B, and C range over attributes and R, S, and T over relation names: UIND1: (reflexivity) R[A] ⊆ R[A].	x-1479-2
UIND2: (transitivity) If R[A] ⊆ S[B] and S[B] ⊆ T [C], then R[A] ⊆ T [C].	x-1480-1
To capture the interaction of fd’s and uind’s in the finite case, the following family of rules is used: C : (cycle rules) For each positive integer n, R if then R1[A1] ⊆ Rn[Bn] Rn[Bn] ⊆ R1[A1].	x-1481-1
Exercises The soundness of this family of rules follows from a straightforward cardinality argument.	x-1482-1
More generally, we have the following (see Exercise 9.16): Theorem 9.4.7 The set {FD1, FD2, FD3, UIND1, UIND2} along with the cycle rules	x-1483-1
Bibliographic Notes Inclusion dependency is based on the notion of referential integrity, which was known to the broader database community during the 1970s (see, e.g., [Dat81]).	x-1484-1
A seminal paper on the theory of ind’s is [CFP84], in which inference rules for ind’s are presented and the nonaxiomatizability of both finite and unrestricted implication for fd’s and ind’s is demonstrated.	x-1484-2
A non-k-ary sound and complete set of inference rules for finite implication of fd’s and ind’s is presented in [Mit83b].	x-1484-3
Another seminal paper is [JK84b], which also observed the distinction between finite and unrestricted implication for fd’s and ind’s, generalized the chase to incorporate fd’s and ind’s, and used this to characterize containment between conjunctive queries.	x-1484-4
Related work is reported in [LMG83].	x-1484-5
Undecidability of (finite) implication for fd’s and ind’s taken together was shown independently by [CV85] and [Mit83a].	x-1485-1
The proof of Theorem 9.2.4 is taken from [CV85].	x-1485-2
Given the pspace complexity of implication for ind’s and the negative results in connection with fd’s, unary ind’s emerged as a more tractable form of inclusion dependency.	x-1486-1
The decision problems for finite and unrestricted implication for uind’s and fd’s taken together, although not coextensive, both lie in polynomial time [CKV90].	x-1487-1
This extensive paper also develops axiomatizations of both finite and unrestricted logical implication for unary ind’s and fd’s considered together, and develops results for uind’s with some of the more general dependencies studied in Chapter 10.	x-1487-2
Typed ind’s are studied in [CK86].	x-1488-1
In addition to using traditional techniques from dependency theory, such as chasing, this work develops tools for analyzing ind’s using equational theories.	x-1488-2
Ind’s in connection with other dependencies are also studied in [CV83].	x-1489-1
Exercises Exercise 9.1 Complete the proof of Proposition 9.1.5.	x-1490-1
Exercise 9.2 Complete the proof of Theorem 9.1.7.	x-1491-1
Exercise 9.3 B|, then {R[ C] ⊆ S[ B D], S : B → D} |=unr R : C.	x-1492-1
Inclusion Dependency B|, then {R[ C] ⊆ S[ B D], R[ E] ⊆ S[ B F ], S : B → D} |=unr R[ C E] B D F ].	x-1493-1
B|; = {R[ C] ⊆ S[ B D], R[ E] ⊆ S[ B D], S : B → D}; C] = u[ E] for each u ∈ I(R).	x-1494-1
Exercise 9.4	x-1495-1
IND4: If R[A1A2] ⊆ S[BB] and R[ C] ⊆ T [ D], then R[ C′] ⊆ T [ D], where C′ is obtained from C by replacing one or more occurrences of A2 by A1.	x-1496-1
IND5: If R[A1A2] ⊆ S[BB] and T [ C] ⊆ R[ D], then T [ C] ⊆ R[ D′], where D′ is obtained from D by replacing one or more occurrences of A2 by A1.	x-1497-1
Prove that the inference rules {IND1, IND2, IND3, IND4, IND5} are sound and complete for finite implication of sets of rind’s.	x-1498-1
Exercise 9.5	x-1499-1
Exercise 9.6	x-1500-1
Using the same set , find an fd that can be used in place of σ in the proof.	x-1501-1
Exercise 9.7 Prove that there is no k for which there is a k-ary sound and complete axiomatization for finite implication of fd’s, jd’s, and ind’s.	x-1502-1
Exercise 9.9 Recall the notion of sort-set dependency (ssd) from Exercise 8.32.	x-1503-1
Exercises	x-1504-1
Exercise 9.10	x-1505-1
Exercise 9.11 Suppose that some attribute domains may be finite.	x-1506-1
Exercise 9.12 Suppose that no restrictions are put on the order of application of ind rules in chasing sequences.	x-1507-1
Exercise 9.14	x-1508-1
Prove that q ≡ q′.	x-1509-1
Exercise 9.15 Inclusion Dependency	x-1510-1
Hint: Use a reduction from the problem of Permutation Generation [GJ79].	x-1511-1
S[	x-1512-1
Given a set of fd’s and uind’s over R, define G() to be a multigraph with node set R	x-1513-1
Exercise 9.17	x-1514-1
FD-UIND1: If ∅ → A and R[B] ⊆ R[A], then ∅ → B.	x-1515-1
FD-UIND1: If ∅ → A and R[B] ⊆ R[A], then R[A] ⊆ R[B].	x-1516-1
Exercises is sound and complete for unrestricted logical implication of fd’s and uind’s over a single relation schema R.	x-1517-1
fd’s, jd’s, mvd’s, ejd’s, emvd’s, ind’s—it’s all getting very confusing.	x-1518-1
Vittorio: Wait!	x-1519-1
We’ll use logic to unify it all.	x-1519-2
Sergio: Yes!	x-1520-1
Logic will make everything crystal clear.	x-1520-2
Riccardo:	x-1521-1
The dependencies studied in the previous chapters have a strong practical motivation and provide a good setting for studying two of the fundamental issues in dependency theory: deciding logical implication and constructing axiomatizations.	x-1522-1
Several new dependencies were introduced in the late 1970s and early 1980s, sometimes motivated by practical examples and later motivated by a desire to understand fundamental theoretical properties of unirelational dependencies or to find axiomatizations for known classes of dependencies.	x-1523-1
This process culminated with a rather general perspective on dependencies stemming from mathematical logic: Almost all dependencies that have been introduced in the literature can be described as logical sentences having a simple structure, and further syntactic restrictions on that structure yield natural subclasses of dependencies.	x-1523-2
The purpose of this chapter is to introduce this general class of dependencies and its natural subclasses and to present important results and techniques obtained for them.	x-1523-3
The general perspective is given in the first section, along with a simple application of logic to obtain the decidability of implication for a large class of dependencies.	x-1524-1
It turns out that the chase is an invaluable tool for analyzing implication; this is studied in the second section.	x-1524-2
Axiomatizations for important subclasses have been developed, again using the chase; this is the topic of the third section.	x-1524-3
We conclude the chapter with a provocative alternative view of dependencies stemming from relational algebra.	x-1524-4
The classes of dependencies studied in this chapter include complex dependencies that would not generally arise in practice.	x-1525-1
Even if they did arise, they are so intricate that they would probably be unusable—it is unlikely that database administrators would bother to write them down or that software would be developed to use or enforce them.	x-1525-2
Nevertheless, it is important to repeat that the perspective and results discussed in this chapter have served the important function of providing a unified understanding of virtually all dependencies raised in the literature and, in particular, of providing insight into the boundaries between tractable and intractable problems in the area.	x-1525-3
The fundamental property of all of the dependencies introduced so far is that they essentially say, “The presence of some tuples in the instance implies the presence of certain other tuples in the instance, or implies that certain tuple components are equal.” In the case of jd’s and mvd’s, the new tuples can be completely specified in terms of the old tuples, but for ind’s this is not the case.	x-1526-1
In any case, all of the dependencies discussed so far can be expressed using first-order logic sentences of the form	x-1526-2
Because we generally focus on sets of dependencies, we make several simplifying assumptions before continuing (see Exercise 10.1a).	x-1527-1
These include that (1) we may eliminate equality atoms from ϕ without losing expressive power; and (2) we can also assume without loss of generality that no existentially quantified variable participates in an equality atom in ψ.	x-1527-2
Thus we define an (embedded) dependency to be a sentence of the foregoing form, where	x-1527-3
We now present three fundamental classifications of dependencies.	x-1528-1
Full versus embedded: A full dependency is a dependency that has no existential quantifiers.	x-1529-1
Tuple generating versus equality generating: A tuple-generating dependency (tgd) is a dependency in which no equality atoms occur; an equality-generating dependency (egd) is a dependency for which the right-hand formula is a single equality atom.	x-1530-1
Typed versus untyped: A dependency is typed if there is an assignment of variables to column positions such that (1) variables in relation atoms occur only in their assigned position, and (2) each equality atom involves a pair of variables assigned to the same position.	x-1531-1
It is sometimes important to distinguish dependencies with a single atom in the right-hand formula.	x-1532-1
A dependency is single head if the right-hand formula involves a single atom; it is multi-head otherwise.	x-1532-2
The following result is easily verified (Exercise 10.1b).	x-1533-1
Untyped ind’s Embedded Typed jd’s Full fd’s mvd’s egd’s Single-head tgd’s Multi-head tgd’s tgd’s Figure 10.1: Dependencies Proposition 10.1.1 Each (typed) dependency is equivalent to a set of (typed) egd’s	x-1534-1
It is easy to classify the fd’s, jd’s, mvd’s, ejd’s, emvd’s and ind’s studied in Chapters 8	x-1535-1
However, for negative results the typed case sometimes requires more sophisticated proof techniques because it imposes more restrictions.	x-1536-1
There is a strong relationship between dependencies and tableaux.	x-1537-1
Tableaux provide a convenient notation for expressing and working with dependencies.	x-1537-2
(As will be seen in Section 10.4, the family of typed dependencies can also be represented using a formalism based on algebraic expressions.)	x-1537-3
The tableau representation of two untyped egd’s is shown in Figs.	x-1537-4
10.2(a) and 10.2(b).	x-1537-5
These two egd’s are equivalent.	x-1537-6
Note that all egd’s can be expressed as a pair (T , x = y), where T is a tableau and x, y ∈ va r(T ).	x-1537-7
If (T , x = y) is typed, unirelational, and x, y are in the A column of T , then this is referred to as an A- egd.	x-1537-8
Parts (c) and (d) of Fig.	x-1538-1
10.2 show two full tgd’s that are equivalent.	x-1538-2
This is especially interesting because, considered as tableau queries, (T ′, t) properly contains (T , t) (see Exercise 10.4).	x-1538-3
As suggested earlier, each full tgd is equivalent to some set of full single-head tgd’s.	x-1538-4
In the following, when considering full tgd’s, we will assume that they are single head.	x-1538-5
Part (e) of Fig.	x-1539-1
10.2 shows a typed tgd that is not single head.	x-1539-2
To represent these within B C B C S x y w S′ x y w y w y w u y w 3 u y w 3 y w x = z y w 5 x = z B B B T x y 1 T′ x y 1 T 1 x y 1 x 1 y 1 x 1 y 1 x 1 y 1 x 1 y x 1 y 2 x 1 y 2 t x y x 2 y 2 x′ y 2 x 2 y T x y t x y x′ y 3 Figure 10.2: Five dependencies the tableau notation, we use an ordered pair (T1, T2), where both T1 and T2 are tableaux.	x-1539-3
This tgd is not equivalent to any set of single-head tgd’s (see Exercise 10.6b).	x-1540-1
Finite versus Unrestricted Implication Revisited We now reexamine the issues of finite versus unrestricted implication using the logical perspective on dependencies.	x-1541-1
Because all of these lie within first-order logic, |=fin is co-r.e.	x-1541-2
On the other hand, because fd’s and uind’s are dependencies, we know from Theorem 9.2.4 that the two forms of implication do not coincide for (embedded) dependencies, and both are nonrecursive.	x-1542-1
Although not demonstrated here, these results have been extended to the family of embedded multivalued dependencies (emvd’s).	x-1542-2
To summarize: Theorem 10.1.2	x-1543-1
In particular, finite implication is not r.e., and unrestricted implication is not co-r.e.	x-1544-1
The Chase Revisited	x-1545-1
Chasing with Full Dependencies We first state without proof the natural generalization of chasing by fd’s and jd’s (Theorem 8.4.12) to full dependencies (see Exercise 10.8).	x-1546-1
In this context we begin either with a tableau T , or with an arbitrary tgd (T , T ′) or egd (T , x = y).	x-1546-2
The notion of applying a full dependency to this is defined in the natural manner.	x-1546-3
Lemma 8.4.17 and the notation developed for it generalize naturally to this context, as does the following analog of Theorem 8.4.18: Theorem 10.2.1 If is a set of full dependencies and T is a tableau (τ a dependency), then chasing T (τ ) by yields a unique finite result, denoted chase(T , ) ( chase(τ, )).	x-1546-4
Logical implication of (full or embedded) dependencies by sets of full dependencies will now be characterized by a straightforward application of the techniques developed in Section 8.4 (see Exercise 10.8).	x-1547-1
A dependency τ is trivial if (a) τ is an egd (T , x = x); or is the identity on var(T ) ∩ var(T ′).	x-1547-2
Note that if τ is a full tgd, then (b) simply says that T ′ ⊆ T .	x-1548-1
The following now provides a simple test for implication by full typed dependencies: Theorem 10.2.2 Let be a set of full typed dependencies and τ a typed dependency.	x-1549-1
Then |= τ iff chase(τ, ) is trivial.	x-1550-1
Recall that the chase relies on a total order ≤ on var.	x-1551-1
For egd (T , x = y) we assume that x < y and that these are the least and second to least variables appearing in the tableau; and for full tgd (T , t), t (A) is least in T (A) for each attribute A.	x-1551-2
Using this convention, we can obtain the following: Corollary 10.2.3 Let be a set of full typed dependencies.	x-1551-3
var( chase(T , )).	x-1552-1
Using the preceding results, it is straightforward to develop a deterministic exponential time algorithm for testing implication of full dependencies.	x-1553-1
It is also known that for both the typed and untyped cases, implication is complete in exptime.	x-1553-2
(Note that, in contrast, logical implication for arbitrary sets of initially extended Bernays-Schöfinkel sentences is known to be complete in nondeterministic exptime.)	x-1553-3
Dependencies and Views On a bit of a tangent, we now apply the chase to characterize the interaction of full dependencies and user views.	x-1554-1
Let R = {R1, .	x-1554-2
.	x-1554-3
.	x-1554-4
, Rn} be a database schema, where Rj has associated set j of full dependencies for j ∈ [1, n].	x-1554-5
Set = {Ri : σ | σ ∈ i}.	x-1554-6
Note that the elements of are tagged by the relation name they refer to.	x-1554-7
Suppose that a view is defined by algebraic expression E : R → S[V ].	x-1554-8
It is natural to ask what dependencies will hold in the view.	x-1554-9
Formally, we say that R : implies E : σ , denoted R : |= E : σ , if E(I) satisfies σ for each I that satisfies .	x-1554-10
The notion of R : |= E : Ŵ for a set Ŵ is defined in the natural manner.	x-1554-11
To illustrate these notions in a simple setting, we state the following easily verified result (see Exercise 10.10).	x-1555-1
Proposition 10.2.4 Let (R[U ], ) be a relation schema where is a set of fd’s and mvd’s, and let V ⊆ U .	x-1556-1
Then	x-1556-2
Given a database schema R, a family of tagged full dependencies over R, a view expression E mapping R to S[V ], and a full dependency γ , is it decidable whether R : |= E : γ ?	x-1557-1
If E ranges over the full relational algebra, the answer is no, even if the only dependencies considered are fd’s.	x-1557-2
Theorem 10.2.5 It is undecidable, given database schema R, tagged fd’s , algebra expression E : R → S and fd σ over S, whether R : |= E : σ .	x-1558-1
Proof Let R = {R[U ], S[U ]}, σ = R : ∅ → U and = {σ }.	x-1559-1
Given two algebra expressions E1, E2 : S → R, consider E = R ∪ [E1(S) − E2(S)] ∪ [E2(S) − E1(S)] Then R : |= E : σ iff E1 ≡ E2.	x-1559-2
This is undecidable by Corollary 6.3.2.	x-1559-3
In contrast, we now present a decision procedure, based on the chase, for inferring view dependencies when the view is defined using the SPCU algebra.	x-1560-1
Theorem 10.2.6 It is decidable whether R : |= E : γ , if E is an SPCU query and	x-1561-1
Crux We prove the result for SPC queries that do not involve constants, and leave the extension to include union and constants for the reader (Exercise 10.12).	x-1562-1
Let E : R → S[V ] be an SPC expression, where S ∈ R. Recall from Chapter 4 (Theorem 4.4.8; see also Exercise 4.18) that for each such expression E there is a tableau mapping τE = (T, t) equivalent to E.	x-1563-1
Set Z = ∪u∈W Tu.	x-1564-1
It can now be verified that R : |= E : γ iff w ∈ E( chase(Z, )).	x-1564-2
In the case where ∪ {γ } is a set of fd’s and mvd’s and the view is defined by an SPCU expression, testing the implication of a view dependency can be done in polynomial time, if jd’s are involved the problem is np-complete, and if full dependencies are considered the problem is exptime-complete.	x-1565-1
Recall from Section 8.4 that a satisfaction family is a family sat(R, ) for some set of dependencies.	x-1566-1
Suppose now that SPC expression E : R[U ] → S[V ] is given, and that is a set of full dependencies over R. Theorem 10.2.6, suitably generalized, shows that the family Ŵ of full dependencies implied by for view E is recursive.	x-1566-2
This raises the natural question: Does E( sat(R, )) = sat(Ŵ), that is, does Ŵ completely characterize the image of sat(R, ) under E?	x-1566-3
The affirmative answer to this question is stated next.	x-1566-4
This result follows from the proof of Theorem 10.2.6 (see Exercise 10.13).	x-1566-5
Theorem 10.2.7 If is a set of full dependencies over R and E : R → S is an SPC expression without constants, then there is a set Ŵ of full dependencies over S such that E( sat(R, )) = sat(S, Ŵ).	x-1567-1
Suppose now that E : R[U ] → S[V ] is given, and is a finite set of dependencies.	x-1568-1
Can a finite set Ŵ be found such that E( sat(R, )) = sat(S, Ŵ)?	x-1569-1
Even in the case where E is a simple projection and is a set of fd’s, the answer to this question is sometimes negative (Exercise 10.11c).	x-1569-2
Chasing with Embedded Dependencies We now turn to the case of (embedded) dependencies.	x-1570-1
From Theorem 10.1.2(b), it is apparent that we cannot hope to generalize Theorem 10.2.2 to obtain a decision procedure for (finite or unrestricted) implication of dependencies.	x-1570-2
As initially discussed in Chapter 9, the chase need not terminate if dependencies are used.	x-1570-3
All is not lost, however, because we are able to use the chase to obtain a proof procedure for testing unrestricted implication of a dependency by a set of dependencies.	x-1570-4
For nonfull tgd’s, we shall use the following rule.	x-1571-1
We present the rule as it applies to tableaux, but it can also be used on dependencies.	x-1571-2
tgd rule: Let T be a tableau, and let σ = (S, S′) be a tgd.	x-1572-1
Suppose that there is a valuation θ for S that embeds S into T , but no extension θ ′ to var(S) ∪ var(S′) of θ such that θ ′(S′) ⊆ T .	x-1572-2
In this case σ can be applied to T .	x-1572-3
Let θ1, .	x-1573-1
.	x-1573-2
.	x-1573-3
, θn be a list of all valuations having this property.	x-1573-4
For each i ∈ [1, n], (nondeterministically) choose a distinct extension, i.e., an extension θ ′ to var(S) ∪ i var(S′) of θi such that each variable in var(S′) − var(S) is assigned a distinct new variable greater than all variables in T .	x-1573-5
(The same variable is not chosen in two extensions θ ′, θ ′ , i = j .)	x-1573-6
i j The result of applying σ to T is T ∪ {θ ′(S′) | i ∈ [1, n]}.	x-1574-1
i This rule is nondeterministic because variables not occurring in T are chosen for the existentially quantified variables of σ .	x-1575-1
We assume that some fixed mechanism is used for selecting these variables when given T , (S, S′), and θ .	x-1575-2
The notion of a chasing sequence T = T1, T2, .	x-1576-1
.	x-1576-2
.	x-1576-3
of a tableau (or dependency) by a set of dependencies is now defined in the obvious manner.	x-1576-4
Clearly, this sequence may be infinite.	x-1576-5
Example 10.2.8 Let = {τ1, τ2, τ3}, where B C D B C D B C D T w x T′ w y T′′ x w y x y x t x y t′ w x B C D B C D x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 x 1 x 5 x 6 x 7 x 1 x 5 x 6 x 7 x 10 x 2 x 6 x 12 application x 10 x 2 x 6 x 4 x 11 x 5 x 3 x 13 of τ1 x 11 x 5 x 3 x 7 of τ3 B C D B C D x 1 x 2 x 3 x 4 x 1 x 2 x 3 x 4 x 1 x 5 x 6 x 7 x 1 x 5 x 6 x 4 x 10 x 2 x 6 x 4 x 10 x 2 x 6 x 4 x 11 x 5 x 3 x 7 x 11 x 5 x 3 x 4 x 1 x 5 x 20 x 4 x 1 x 5 x 20 x 4 x 11 x 2 x 21 x 7 x 11 x 2 x 21 x 4 x 1 x 2 x 22 x 7 x 1 x 2 x 22 x 4 x 10 x 5 x 23 x 4 of τ2 x 10 x 5 x 23 x 4 of τ3 Figure 10.3: Parts of a chasing sequence We show here only the relevant variables of τ1, τ2, and τ3; all other variables are assumed to be distinct.	x-1577-1
Here τ3 ≡ B → D.	x-1577-2
In Fig.	x-1578-1
10.3, we show some stages of a chasing sequence that demonstrates that	x-1578-2
Consider now the typed tgd’s: B C D B C D T′′′ w x T′′′′ w x w y w y t′′ x y t′′′ w x y The chasing sequence of Fig.	x-1579-1
10.3 also implies that |=unr τ4, because (x10, x2, x6, x4) is in the second tableau.	x-1579-2
On the other hand, we now argue that |=unr τ5.	x-1579-3
Consider the chasing sequence beginning as the one shown in Fig.	x-1579-4
10.3, and continuing by applying the sequence τ1, τ3, τ2, τ3 repeatedly.	x-1579-5
It can be shown that this chasing sequence will not terminate and that (x1, x2, x6, v) does not occur in the resulting infinite sequence for any variable v (see Exercise 10.16).	x-1579-6
It follows that |=unr τ5; in particular, the infinite result of the chasing sequence is a counterexample to this implication.	x-1579-7
On the other hand, this chasing sequence does not alone provide any information about whether |=fin τ5.	x-1579-8
It can be shown that this also fails.	x-1579-9
To ensure that all relevant dependencies have a chance to influence a chasing sequence, we focus on chasing sequences that satisfy the following conditions: (1) Whenever an egd is applied, it is applied repeatedly until it is no longer applicable.	x-1580-1
Even if these conditions are satisfied, it is possible to have two chasing sequences of a tableau T by typed dependencies, where one is finite and the other infinite (see Exercise 10.14).	x-1581-1
Now consider an infinite chasing sequence T1 = T , T2, .	x-1582-1
.	x-1582-2
.	x-1582-3
.	x-1582-4
Let us denote it by T , .	x-1582-5
Because egd’s may be applied arbitrarily late in T , , for each n, tuples of Tn may be modified as the result of later applications of egd’s.	x-1583-1
Thus we cannot simply take the union of some tail Tn, Tn+1, .	x-1583-2
.	x-1583-3
.	x-1583-4
to obtain the result of the chase.	x-1583-5
As an alternative, for the chasing sequence T , = T1, T2, .	x-1583-6
.	x-1583-7
.	x-1583-8
, we define chase(T , ) = {u | ∃n ∀m > n(u ∈ Tm)}.	x-1583-9
This is nonempty because (1) the “new” variables introduced by the tgd rule are always greater than variables already present; and (2) when the egd rule is applied, the newer variable is replaced by the older one.	x-1584-1
By generalizing the techniques developed, it is easily seen that the (possibly infinite) resulting tableau satisfies all dependencies in .	x-1585-1
More generally, let be a set of dependencies and σ a dependency.	x-1585-2
Then one can show that |=unr σ iff for some chasing sequence σ, of σ using , chase(σ, ) is trivial.	x-1585-3
Furthermore, it can be shown that	x-1585-4
This shows that, for practical purposes, it suffices to generate some chasing sequence of σ using and stop as soon as some tableau in the sequence becomes trivial.	x-1586-1
This section presents an axiomatization for the family of full typed tgd’s and typed egd’s (which is sound and complete for both finite and unrestricted implication).	x-1587-1
A generalization to the embedded case (for unrestricted implication) has also been developed (see Exercise 10.21).	x-1587-2
The axiomatization presented here is closely related to the chase.	x-1587-3
In the next section, a very different kind of axiomatization for typed dependencies is discussed.	x-1587-4
We now focus on the full typed dependencies (i.e., on typed egd’s and full typed tgd’s).	x-1588-1
The development begins with the introduction of a technical tool for forming the composition of tableaux queries.	x-1588-2
The axiomatization then follows.	x-1588-3
Composition of Typed Tableaux Suppose that τ = (T , t) and σ = (S, s) are two full typed tableau queries over relation schema R. It is natural to ask whether there is a tableau query τ • σ corresponding to the composition of τ followed by σ —that is, with the property that for each instance I over R, (τ • σ )(I ) = σ (τ (I ))	x-1589-1
Let T = {t1, .	x-1590-1
.	x-1590-2
.	x-1590-3
, tn} and S = {s1, .	x-1590-4
.	x-1590-5
.	x-1590-6
, sm}.	x-1590-7
Suppose that tuple w is in σ (τ (I )).	x-1590-8
Then there is an embedding ν of s1, .	x-1590-9
.	x-1590-10
.	x-1590-11
, sm into τ (I ) such that ν(s) = w. It follows that for each j ∈ [1, m] there is an embedding µj of T into I , with µj (t) = ν(sj ).	x-1590-12
This suggests that the tableau of τ • σ should have mn tuples, with a block of n tuples for each sj .	x-1590-13
To be more precise, for each j ∈ [1, m], let Ts be θ j j (T ), where θj is a substitution that maps t (A) to sj (A) for each attribute A of R and maps each other variable of T to a new, distinct variable not used elsewhere in the construction.	x-1591-1
Now set	x-1591-2
j The following is now easily verified (see Exercise 10.18): Proposition 10.3.1 For full typed tableau queries τ and σ over R, and for each instance I of R, τ • σ (I ) = σ (τ (I )).	x-1592-1
Example 10.3.2 The following table shows two full typed tableau queries and their composition.	x-1593-1
B C B C B C T x y S u v w′ u v p 1 x y′ u′ v w u p w′ x y′ s u v w u p p t w x y u′ v p 4 u′ p w u′ p p u v w It is straightforward to verify that the syntactic operation of composition is associative.	x-1594-1
Suppose that τ and σ are full typed tableau queries.	x-1595-1
It can be shown by simple chasing arguments that {τ, σ } and {τ • σ } are equivalent as sets of dependencies.	x-1595-2
It follows that full typed tgd’s are closed under finite conjunction, in the sense that each finite set of full typed tgd’s over a relation schema R is equivalent to a single full typed tgd.	x-1595-3
This property does not hold in the embedded case (see Exercise 10.20).	x-1595-4
For full typed tgd’s, τ = (T , t) and σ = (S, s), we say that τ embeds into σ denoted τ ֒→ σ , if there is a substitution ν such that ν(T ) ⊆ S and ν(t) = s. Recall from Chapter 4 that τ ⊇ σ (considered as tableau queries) iff τ ֒→ σ .	x-1596-1
As a result we have that if τ ֒→ σ , then τ |= σ , although the converse does not necessarily hold.	x-1596-2
Analogously, for A-egd’s τ = (T , x = y) and σ = (S, v = w), we define τ ֒→ σ if there is a substitution ν such that ν(T ) ⊆ S, and ν({x, y}) = {v, w}.	x-1596-3
Again, if τ ֒→ σ , then τ |= σ .	x-1596-4
We now list the axioms for full typed tgd’s: FTtgd1: (triviality) For each free tuple t without constants, ({t}, t).	x-1597-1
FTtgd2: (embedding) If τ and τ ֒→ σ , then σ .	x-1598-1
FTtgd3: (composition) If τ and σ , then τ • σ .	x-1599-1
The following rules focus exclusively on typed egd’s: Tegd1: (triviality) If x ∈ var(T ), then (T , x = x).	x-1600-1
Tegd2: (embedding) If τ and τ ֒→ σ , then σ .	x-1601-1
The final rules combining egd’s and full typed tgd’s use the following notation.	x-1602-1
Let R[U ] be a relation schema.	x-1602-2
For A ∈ U , A denotes U − {A}.	x-1602-3
Given typed A-egd τ = uy[A] consists of distinct variables not occurring in T .	x-1602-4
Define two full typed tgd’s τx =	x-1602-5
FTD1: (conversion) If τ = (T , x = y), then τx and τy.	x-1603-1
FTD2: (composition) If (T , t) and (S, x = y), then ([S](T , t), x = y).	x-1604-1
We now have the following: Theorem 10.3.3 The set {FTtgd1, FTtgd2, FTtgd3, Tegd1, Tegd2, FTD1, FTD2} is sound and complete for (finite and unrestricted) logical implication of full typed dependencies.	x-1605-1
Crux Soundness is easily verified.	x-1606-1
We illustrate completeness by showing that the FTtgd rules are complete for tgd’s.	x-1606-2
Suppose that |= τ = (T , t), where is a set of full typed tgd’s and (T , t) is full and typed.	x-1606-3
By Theorem 10.2.2 there is a chasing sequence of T by yielding T ′ with t ∈ T ′.	x-1606-4
Let σ1, .	x-1606-5
.	x-1606-6
.	x-1606-7
, σn (n ≥ 0) be the sequence of elements of used in the chasing sequence.	x-1606-8
It follows that t ∈ σn(.	x-1606-9
.	x-1606-10
.	x-1606-11
(σ1(T ) .	x-1606-12
.	x-1606-13
.	x-1606-14
), and by Proposition 10.3.1, t ∈ (σ1 • · · · • σn)(T ).	x-1606-15
This implies that (σ1 • · · · • σn) ֒→ (T , t).	x-1606-16
A proof of τ from is now obtained by starting with σ1 (or ({s}, s) if n = 0), followed by n − 1 applications of FTtgd3 and one application of FTtgd2 (see Exercise (10.18b).	x-1606-17
The preceding techniques and the chase can be used to develop an axiomatization of unrestricted implication for the family of all typed dependencies.	x-1607-1
This section develops a very different paradigm for specifying dependencies based on the use of algebraic expressions.	x-1608-1
Surprisingly, the class of dependencies formed is equivalent to the class of typed dependencies.	x-1608-2
We also present an axiomatization that is rooted primarily in algebraic properties rather than chasing and tableau manipulations.	x-1608-3
We begin with examples that motivate and illustrate this approach.	x-1609-1
Example 10.4.1 Let R[ ABCD] be a relation schema.	x-1610-1
Consider the tgd τ of Fig.	x-1610-2
10.4 and the algebraic expression	x-1610-3
It is straightforward to verify that for each instance I over ABCD, I |= τ iff π AC(π AB(I ) ⊲⊳ π BC(I )) ⊆ π AC(I ).	x-1611-1
Now consider dependency σ .	x-1612-1
One can similarly verify that for each instance I over ABCD, I |= σ iff π AC(π AB(I ) ⊲⊳ π BC(I )) ⊆ π AC(π AD(I ) ⊲⊳ π CD(I )).	x-1612-2
B C D B C D T x y′ S x y′ y′ y′ t x S′ x w′ w′ Figure 10.4: Dependencies of Example 10.4.1 The observation of this example can be generalized in the following way.	x-1613-1
A project-join (PJ) expression is an algebraic expression over a single relation schema using only projection and natural join.	x-1613-2
We describe next a natural recursive algorithm for translating PJ expressions into tableau queries (see Exercise 10.23).	x-1613-3
(This algorithm is also implicit in the equivalence proofs of Chapter 4.)	x-1613-4
Input: a PJ expression E over relation schema R[A1, .	x-1614-1
.	x-1614-2
.	x-1614-3
, An] Output: a tableau query (T , t) equivalent to E Basis: If E is simply R, then return ({ x1, .	x-1614-4
.	x-1614-5
.	x-1614-6
, xn}, x1, .	x-1614-7
.	x-1614-8
.	x-1614-9
, xn).	x-1614-10
Inductive steps:	x-1615-1
Let X be the intersection of the output sorts of q1 and q2.	x-1616-1
Assume without loss of generality that the two tableaux use distinct variables except that t1(A) = t2(A) for A ∈ X.	x-1616-2
Then return (T1 ∪ T2, t1 ⊲⊳ t2).	x-1616-3
Suppose now that (T , T ′) is a typed dependency with the property that for some free tuple t, (T , t) is the tableau associated by this algorithm with PJ expression E, and (T ′, t) is the tableau associated with PJ expression E′.	x-1617-1
Suppose also that the only variables common to T and T ′ are those in t. Then for each instance I , I |= (T , T ′) iff E(I ) ⊆ E′(I ).	x-1617-2
This raises three natural questions: (1) Is the family of PJ inclusions equivalent to the set of typed tgd’s?	x-1618-1
(2) If not, can this paradigm be extended to capture all typed tgd’s?	x-1618-2
(3) Can this paradigm be extended to capture typed egd’s as well as tgd’s?	x-1618-3
The answer to the first question is no (see Exercise 10.24).	x-1619-1
The answer to the second and third questions is yes.	x-1620-1
This relies on the notion of extended relations and extended project-join expressions.	x-1620-2
Let R[A1, .	x-1620-3
.	x-1620-4
.	x-1620-5
, An] be a relation schema.	x-1620-6
For each i ∈ [1, n], we suppose that there is an infinite set of attributes A1, A2, .	x-1620-7
.	x-1620-8
.	x-1620-9
, called copies of A i i i .	x-1620-10
The extended schema of R is the schema R[A1, .	x-1620-11
.	x-1620-12
.	x-1620-13
, A1 n, A2 n, .	x-1620-14
.	x-1620-15
.	x-1620-16
].	x-1620-17
For an instance I of R, the extended instance of R corresponding to j I , denoted I , has one “tuple” u for each tuple u ∈ I , where u(A ) = u(A i i ) for each i ∈ [1, n] and j > 0.	x-1620-18
B C D B C D T x w′ T x w′ w′ w′ x′ w x′ w T′ x y′ x = x′ y′ w Figure 10.5: tgd and egd of Example 10.4.3 projection operator is applied first to each occurrence of R. (This ensures that the evaluation and the result of such expressions involve only finite objects.)	x-1621-1
Given two extended PJ expressions E and E′ with the same target sort, and instance I over R, E(I ) ⊆e E′(I ) denotes E(I ) ⊆ E′(I ).	x-1621-2
This is illustrated next.	x-1622-1
Example 10.4.3 Consider the dependency τ of Fig.	x-1623-1
10.5.	x-1623-2
Let E = π ACD 1(R) ⊲⊳ πC1D1(R) ⊲⊳ πA1C1D(R).	x-1623-3
Here we use A, A1, .	x-1624-1
.	x-1624-2
.	x-1624-3
to denote different copies the attribute A, etc.	x-1624-4
It can be shown that, for each instance I over ABCD, I |= τ iff E1(I ) ⊆e E2(I ), where E1 = π ACD(E) E2 = π ACD(π AB 1(R) ⊲⊳ πB1 CD(R)).	x-1625-1
Consider now the functional dependency A → BC over ABCD.	x-1626-1
This is equivalent to π ABC(R) ⊲⊳ π AB 1C1(R) ⊆e π ABCB 1C1(R).	x-1626-2
Finally, consider σ of Fig.	x-1627-1
10.5.	x-1627-2
This is equivalent to F1 ⊆e F2, where F1 = π AA 1(E) F2 = π AA 1(R).	x-1627-3
We next see that algebraic dependencies correspond precisely to typed dependencies.	x-1628-1
Theorem 10.4.4 For each algebraic dependency, there is an equivalent typed depen- dency, and for each typed dependency, there is an equivalent algebraic dependency.	x-1629-1
Crux Let R[A1, .	x-1630-1
.	x-1630-2
.	x-1630-3
, An] be a relation schema, and let E ⊆e E′ be an algebraic dependency over R, where E and E′ have target sort X.	x-1630-4
Without loss of generality, we can assume that there is k such that the sets of attributes involved in E and E′ are contained in U = {A1, .	x-1630-5
.	x-1630-6
.	x-1630-7
, A1 n, .	x-1630-8
.	x-1630-9
.	x-1630-10
, Ak n U corresponding to E and E′.	x-1630-11
We assume without loss of generality that τ and τ ′ do not share any variables except that t (A) = t′(A) for each A ∈ X.	x-1630-12
Consider T (over U ).	x-1631-1
For each tuple s ∈ T and j ∈ [1, k], j R(x1, .	x-1631-2
.	x-1631-3
.	x-1631-4
, xn), where xi = s(A ) for each i ∈ [1, n]; i j j ′ s(A ) = s(A ) for each i ∈ [1, n] and j, j ′ satisfying i i	x-1631-5
Let ϕ(x1, .	x-1632-1
.	x-1632-2
.	x-1632-3
, xp) be the conjunction of all atoms obtained from τ in this manner.	x-1632-4
Let ψ (y1, .	x-1632-5
.	x-1632-6
.	x-1632-7
, yq) be constructed analogously from τ ′.	x-1632-8
It can now be shown (Exercise 10.26) that E ⊆e E′ is equivalent to the typed dependency where z1, .	x-1632-9
.	x-1632-10
.	x-1632-11
, zr is the set of variables in {y1, .	x-1632-12
.	x-1632-13
.	x-1632-14
, yq} − {x1, .	x-1632-15
.	x-1632-16
.	x-1632-17
, xp}.	x-1632-18
For the converse, we generalize the technique used in Example 10.4.3.	x-1633-1
For each attribute A, one distinct copy of A is used for each variable occurring in the A column.	x-1633-2
Figure 10.6 shows a family of inference rules for algebraic dependencies.	x-1634-1
Each of these rules stems from an algebraic property of join and project, and only the last explicitly uses a property of extended instances.	x-1634-2
(It is assumed here that all expressions are well formed.)	x-1634-3
The use of these rules to infer dependencies is considered in Exercises 10.31, and 10.32.	x-1634-4
It can be shown that: Theorem 10.4.5 The family {AD1, .	x-1635-1
.	x-1635-2
.	x-1635-3
, AD8} is sound and complete for inferring unrestricted implication of algebraic dependencies.	x-1635-4
To conclude this discussion of the algebraic perspective on dependencies, we consider a new operation, direct product, and the important notion of faithfulness.	x-1636-1
Faithfulness and Armstrong Relations We show now that sets of typed dependencies have Armstrong relations,1 although these may sometimes be infinite.	x-1637-1
To accomplish this, we first introduce a new way to combine instances and an important property of it.	x-1637-2
If E ⊆e E′ then πXE ⊆e πXE′ If E ⊆e E′, then E ⊲⊳ E′′ ⊆e E′ ⊲⊳ E′′ E ⊲⊳ E′ =e E′ ⊲⊳ E Suppose that X ⊆ sort(E) and Y ⊆ sort(E′).	x-1638-1
Then	x-1638-2
If X ⊆ sort(R) and A, A′ are copies of the same attribute, then πAA′R ⊲⊳ πAXR =e πAA′XR.	x-1639-1
Figure 10.6: Let R be a relation schema of arity n. We blur our notation and use elements of dom × dom as if they were elements of dom.	x-1640-1
Given tuples u = x1, .	x-1640-2
.	x-1640-3
.	x-1640-4
, xn and v = y1, .	x-1640-5
.	x-1640-6
.	x-1640-7
, yn, we define the direct product of u and v to be u ⊗ v = (x1, y1), .	x-1640-8
.	x-1640-9
.	x-1640-10
, (xn, yn).	x-1640-11
The direct product of two instances I, J over R is I ⊗ J = {u ⊗ v | u ∈ I, v ∈ J }.	x-1641-1
This is generalized to form k-ary direct product instances for each finite k. Furthermore, if J is a (finite or infinite) index set and {Ij | j ∈ J } is a family of instances over R, then	x-1642-1
The following holds because the ⊗ operator commutes with project, join, and “extension” (see Exercise 10.29).	x-1643-1
Bibliographic Notes Proposition 10.4.6 The family of typed dependencies is faithful.	x-1644-1
We can now prove that each set of typed dependencies has an Armstrong relation.	x-1645-1
Theorem 10.4.7 Let be a set of typed dependencies over relation R. Then there is a (possibly infinite) instance I such that for each typed dependency σ over R, I |= σ iff	x-1646-1
Proof Let Ŵ be the set of typed dependencies over R not in ∗.	x-1647-1
For each γ ∈ Ŵ, let Iγ be a nonempty instance that satisfies but not γ .	x-1647-2
Then ⊗{Iγ | γ ∈ Ŵ} is the desired relation.	x-1647-3
This result cannot be strengthened to yield finite Armstrong relations because one can exhibit a finite set of typed tgd’s with no finite Armstrong relation.	x-1648-1
Bibliographic Notes The papers [FV86, Kan91, Var87] all provide excellent surveys on the motivations and history of research into relational dependencies; these have greatly influenced our treatment of the subject here.	x-1649-1
Because readers could be overwhelmed by the great number of dependency theory terms we have used a subset of the terminology.	x-1650-1
For instance, the typed single-head tgd’s (that were studied in depth) are called template dependencies.	x-1650-2
In addition, the typed unirelational dependencies that are considered here were historically called embedded implicational dependencies (eid’s); and their full counterparts were called implicational dependencies (id’s).	x-1650-3
We use this terminology in the following notes.	x-1650-4
The proliferation of dependencies spawned interest in the development of a unifying framework that subsumed essentially all of them.	x-1651-1
Nicolas [Nic78] is credited with first observing that fd’s, mvd’s, and others have a natural representation in first-order logic.	x-1651-2
At roughly the same time, several researchers reached essentially the same generalized class of dependencies that was studied in this chapter.	x-1651-3
[BV81a] introduced the class of tgd’s and egd’s, defined using the paradigm of tableaux.	x-1651-4
Chasing was studied in connection with both full and embedded dependencies in [BV84c].	x-1651-5
Reference [Fag82b] introduced the class of typed dependencies, essentially the same family of dependencies but presented in the paradigm of first-order logic.	x-1651-6
Simultaneously, [YP82] introduced the algebraic dependencies, which present the same class in algebraic terms.	x-1651-7
A generalization of algebraic dependencies to the untyped case is presented in [Abi83].	x-1651-8
Related general classes of dependencies introduced at this time are the general dependencies [PJ81], which are equivalent to the full typed tgd’s, and generalized dependency constraints [GJ82], which are the full dependencies.	x-1652-1
Importantly, several kinds of constraints that lie outside the dependencies described in this chapter have been studied in the literature.	x-1653-1
Research on the use of arbitrary first-order logic sentences as constraints includes [GM78, Nic78, Var82b].	x-1653-2
A different extension of dependencies based on partitioning relationships, which are not expressible in first-order logic, is studied in [Cos87].	x-1653-3
Another kind of dependency is the afunctional dependency of	x-1653-4
On the other hand, the equivalence of finite and unrestricted implication for full dependencies was observed in [BV81a].	x-1654-1
That deciding implication for full typed dependencies is complete in exptime is due to [CLM81].	x-1654-2
See also [BV84c, FUMY83], which present numerous results on full and embedded typed dependencies.	x-1654-3
The special case of deciding implication of a typed dependency by ind’s has been shown to be pspace-complete	x-1654-4
The issue of inferring view dependencies was first studied in [Klu80], where Theorem 10.2.5 was presented.	x-1655-1
Reference [KP82] developed Theorem 10.2.6.	x-1655-2
The issue of attempting to characterize view images of a satisfaction family as a satisfaction family was first raised in [GZ82], where Exercise 10.11b was shown.	x-1656-1
Theorem 10.2.7 is due to [Fag82b], although a different proof technique was used there.	x-1656-2
Reference [Hul84] demonstrates that some projections of satisfaction families defined by fd’s Exercises cannot be characterized by any finite set of full dependencies (see Exercise 10.11c,d).	x-1656-3
That investigation is extended in [Hul85], where it is shown that if is a family of fd’s over U and V ⊆ U , and if πV ( sat(U, )) = sat(V , Ŵ) for any set Ŵ of fd’s, then πV ( sat(U, )) = sat(V , Ŵ) for any finite set Ŵ of full dependencies.	x-1657-1
The direct product construction is from [Fag82b].	x-1658-1
Proposition 10.4.6 is due to	x-1658-2
The direct product has been studied in mathematical logic; the notion of (upward) faithful presented here (see Exercise 10.28) is equivalent to the notion of “preservation under direct product” found there (see, e.g., [CK73]); and the notion of downward faithful is related to, but distinct from, the notion of “preservation under direct factors.” Reference [MV86] extends the work on direct product by characterizing the expressive power of different families of dependencies in terms of algebraic properties satisfied by families of instances definable using them.	x-1659-1
Exercises Exercise 10.1	x-1660-1
Exercise 10.2 Consider the tableaux in Example 10.3.2.	x-1661-1
Give σ • σ .	x-1661-2
Compare it (as a mapping) to σ .	x-1661-3
Give σ • τ .	x-1661-4
Compare it (as a mapping) to τ • σ .	x-1661-5
Exercise 10.3	x-1662-1
Exercise 10.4 This exercise concerns the dependencies of Fig.	x-1663-1
10.2.	x-1663-2
Exercise 10.5 Let R[ ABC] be a relation scheme.	x-1664-1
We construct a family of egd’s over R as follows.	x-1664-2
For n ≥ 0, let Tn = { xi, yi, z2i, xi, yi+1, z2i+1 | i ∈ [0, n]}	x-1664-3
Exercise 10.6	x-1665-1
Exercise 10.8	x-1666-1
Exercise 10.9 Prove that the triviality problem for typed tgd’s is np-complete.	x-1667-1
Hint: Use a reduction from tableau containment (Theorem 6.2.3).	x-1667-2
Exercise 10.10	x-1668-1
Exercise 10.11 Let R[ ABCDE] and S[ ABCD] be relation schemas, and let V = ABCD.	x-1669-1
Consider = {A → E, B → E, CE → D}.	x-1669-2
c, d1, a, b, c1, d2, a1, b, c, d3} over S.	x-1670-1
Exercises	x-1671-1
Exercise 10.12	x-1672-1
Exercise 10.13	x-1673-1
Exercise 10.14 Exhibit a typed tgd τ and a set of typed dependencies such that |= τ , and there are two chasing sequences of τ by , both of which satisfy conditions (1) and (2), in the definition of chasing for embedded dependencies in Section 10.2, where one sequence is finite and the other is infinite.	x-1674-1
Exercise 10.15 Consider these dependencies: B C B C x y x x y y x y	x-1675-1
Exercise 10.18	x-1676-1
Exercise 10.19	x-1677-1
Exercise 10.20	x-1678-1
equivalent to {τ, τ ′}.	x-1679-1
Hint: Assume that typed tgd’s were closed under conjunction in this way.	x-1679-2
Use part (a).	x-1679-3
Exercise 10.22	x-1680-1
Exercise 10.23 Prove that Algorithm 10.4.2 is correct.	x-1681-1
(See Exercise 4.18a).	x-1681-2
Exercise 10.24	x-1682-1
Prove that there is no pair E, E′ of (nonextended) PJ expressions such that τ is equivalent to E ⊆ E′ [i.e., such that I |= τ iff E(I ) ⊆ E′(I )].	x-1683-1
expressions such that τ is equivalent to E ⊆ E′.	x-1684-1
Exercise 10.25 In connection with Example 10.4.3,	x-1685-1
Exercise 10.27 Yn e E′ is shallow if E and E′ are shallow.	x-1686-1
Prove that every algebraic dependency is equivalent to a shallow one.	x-1686-2
Exercise 10.28	x-1687-1
Exercises is downward faithful but not upward faithful.	x-1688-1
is upward faithful but not downward faithful.	x-1689-1
Exercise 10.29	x-1690-1
Exercise 10.30	x-1691-1
Express this axiom in the paradigm of algebraic dependencies.	x-1692-1
Prove it using axioms {AD1,	x-1692-2
Exercise 10.33	x-1693-1
When the only tool you have is a hammer, everything begins to look like a nail.	x-1694-1
Will we use a hammer for schema design?	x-1695-1
Riccardo: Sure: decomposition, semantic modeling, .	x-1696-1
.	x-1696-2
.	x-1696-3
Vittorio:	x-1697-1
Sergio: The more intricate the hammer, the more intricate the nail.	x-1698-1
We have discussed earlier applications of dependencies in connection with query optimization (Section 8.4) and user views (Section 10.2).	x-1699-1
In this chapter, we briefly consider how dependencies are used in connection with the design of relational database schemas.	x-1699-2
The problem of designing database schemas is complex and spans the areas of cognitive science, knowledge representation, software practices, implementation issues, and theoretical considerations.	x-1700-1
Due to the interaction of these many aspects (some of them in-tegrally related to how people think and perceive the world), we can only expect a relatively narrow and somewhat simplistic contribution from theoretical techniques.	x-1700-2
As a result, the primary focus of this chapter is to introduce the kinds of formal tools that are used in the design process; a broader discussion of how to use these tools in practice is not attempted.	x-1700-3
The interested reader is referred to the Bibliographic Notes, which indicate where more broad-based treatments of relational schema design can be found.	x-1701-1
In the following discussion, designing a relational schema means coming up with a	x-1702-1
The choice of a schema is guided by semantic information about the application data provided by the designer.	x-1703-1
There are two main ways to do this, and each leads to a different approach to schema design.	x-1703-2
Semantic data model: In this approach (Section 11.1), the application data is first described using a model with richer semantic constructs than relations.	x-1704-1
Such models are called	x-1704-2
Refinement of relational schema: This approach (Section 11.2) starts by specifying an initial relational schema, augmented with dependencies (typically fd’s and mvd’s).	x-1705-1
The design process uses the dependencies to improve the schema.	x-1705-2
But what is it that makes 240 Design and Dependencies one schema better than another?	x-1705-3
This is captured by the notion of “normal form” for relational schemas, a central notion in design theory.	x-1705-4
Both of these approaches focus on the transformation of a schema S1 into a relational schema S2.	x-1706-1
Speaking in broad terms, three criteria are used to evaluate the result of this transformation:	x-1706-2
Condition (1) requires that information not be lost when instances of S1 are represented in S2.	x-1707-1
This is usually formalized by requiring that there be a “natural” mapping τ : Inst(S1) → Inst(S2) that is one-to-one.	x-1707-2
As we shall see, the notion of “natural” can vary, depending on the data model used for S1.	x-1707-3
Criterion (2) has been the focus of considerable research, especially in connection with the approach based on refining relational schemas.	x-1708-1
In this context, the notion of relational schema is generalized to incorporate dependencies, as follows: A relation schema is a pair (R, ), where R is a relation name and is a set of dependencies over R. Similarly, a database schema is a pair (R, ), where R is a database schema as before, and is a set of dependencies over R. Some of these may be tagged by a single relation (i.e., have the form Rj : σ , where σ is a dependency over Rj ∈ R).	x-1708-2
Others, such as ind’s, may involve pairs of relations.	x-1708-3
More generally, some dependencies might range over the full set of attributes occurring in R. (This requires a generalization of the notion of dependency satisfaction, which is discussed in Section 11.3.)	x-1708-4
With this notation established, we return to criterion (2).	x-1709-1
In determining whether one relational schema is better than another, the main factors that have been considered are redundancy in the representation of data and update anomalies.	x-1709-2
Recall that these were illustrated in Section 8.1, using the relations Movies and Showings.	x-1709-3
We concluded there that certain schemas yielded undesirable behavior.	x-1709-4
This resulted from the nature of the information contained in the database, as specified by a set of dependencies.	x-1709-5
Movies: Title → Director suggests that the attribute Director is a characteristic of Title, so the two attributes belong together and can safely be represented in isolation from the other data.	x-1710-1
It should be clear that one always needs some form of semantic information to guide schema design; in the absence of such information, one cannot distinguish “good” schemas from “bad” ones (except for trivial cases).	x-1710-2
As will be seen, the notion of normal form captures some characteristics of “good” schemas by guaranteeing that certain kinds of redundancies and update anomalies will not occur.	x-1710-3
It will also be seen that the semantic data model approach to schema design can lead to relational schemas in normal form.	x-1710-4
Design and Dependencies In broad terms, the intuition behind criterion (3) is that properties of data captured by schema S1 (e.g., functional or inclusion relationships) should also be captured by schema S2.	x-1711-1
In the context of refining relational schemas, a precise meaning will be given for this criterion in terms of “preservation” of dependencies.	x-1711-2
We shall see that there is a kind of trade-off between criteria (2) and (3).	x-1711-3
The approach of refining relational schemas typically makes a simplifying assumption called the “pure universal relation assumption” (pure URA).	x-1712-1
Intuitively, this states that the input schema S1 consists of a single relation schema, possibly with some dependencies.	x-1712-2
Section 11.3 briefly considers this assumption in a more general light.	x-1712-3
In addition, the	x-1712-4
This chapter is more in the form of a survey than the previous chapters, for several reasons.	x-1713-1
As noted earlier, more broad-based treatments of relational schema design may be found elsewhere and require a variety of tools complementary to formal analysis.	x-1713-2
The tools presented here can at best provide only part of the skeleton of a design methodology for relational schemas.	x-1713-3
Normal forms and the universal relation assumption were active research topics in the 1970s and early 1980s and generated a large body of results.	x-1713-4
Some of that work is now considered somewhat unfashionable, primarily due to the emergence of new data models.	x-1713-5
However, we mention these topics briefly because (1) they lead to interesting theoretical issues, and (2) we are never secure from a change of fashion.	x-1713-6
Semantic Data Models In this section we introduce semantic data models and describe how they are used in relational database design.	x-1714-1
Semantic data models provide a framework for specifying database schemas that is considerably richer than the relational model.	x-1714-2
In particular, semantic models are arguably closer than the relational model to ways that humans organize information in their own thinking.	x-1714-3
The semantic data models are precursors of the recently emerging object-oriented database models (presented in a more formal fashion in Chapter 21) and are thus of interest in their own right.	x-1714-4
In many practical contexts, the semantic model used is the Entity-Relationship model (ER model) or one of its many variants.	x-1715-1
The ER model is arguably the first semantic data model that appeared in the literature.	x-1715-2
We use the GSM because it incorporates several features of the semantic modeling literature not present in the ER model, and because the GSM presents a style closer to object-oriented database models.	x-1715-3
GSM Schemas Figure 11.1 shows the schema CINEMA-SEM from the GSM, which can be used to represent information on movies and theaters.	x-1716-1
The major building blocks of such schemas are abstract classes, attributes, complex value classes, and the ISA hierarchy; these will be considered briefly in turn.	x-1716-2
The schema of Fig.	x-1717-1
11.1 shows five classes that hold abstract objects: Person, Director, Actor, Movie, and Theater.	x-1717-2
These correspond to collections of similar objects in the world.	x-1717-3
There are two kinds of abstract class: primary classes, shown using diamonds, and subclasses shown using circles.	x-1717-4
This distinction will be clarified further when ISA relationships are discussed.	x-1717-5
Instances of semantic schemas are constructed from the usual printable classes (e.g., string, integer, float, etc.)	x-1718-1
and “abstract” classes.	x-1718-2
The printable classes correspond to (subsets of) the domain dom used in the relational model.	x-1718-3
The printable classes are indicated using squares; in Fig.	x-1718-4
11.1 we have labeled these to indicate the kind of values that populate them.	x-1718-5
Conceptually, the elements of an abstract class such as Person are actual persons in the world; in the formal model internal representations for persons are used.	x-1718-6
These internal representations have come to be known as object identifiers (OIDs).	x-1718-7
Because they are internal, it is usually assumed that OIDs cannot be presented explicitly to users, although programming and query languages can use variables that hold OIDs.	x-1718-8
The notion of instance will be defined more completely later and is illustrated in Example 11.1.1 and Fig.	x-1718-9
11.2.	x-1718-10
These are examples of single-valued attributes.	x-1719-1
(In this schema, all attributes are assumed to be total.)	x-1719-2
Multivalued attributes are also allowed; these map each object to a set of objects or printable values and are denoted using arrows with double heads.	x-1719-3
For example, acts_in maps actors to the movies that they have acted in.	x-1719-4
It is common to permit inverse constraints between pairs of attributes.	x-1719-5
For example, consider the relationship between actors and movies.	x-1719-6
It can be represented using the multivalued attribute acts_in on Actor or the multivalued attribute actors on Movie.	x-1719-7
In this schema, we assume that the attributes acts_in and actors are constrained to be inverses of each other, in the sense that m ∈ acts _ in( a) iff a ∈ actor( m).	x-1719-8
A similar constraint is assumed between the attributes associating movies with directors.	x-1719-9
In the schema CINEMA-SEM, the Pariscope node is an example of a complex value class.	x-1720-1
Members of the underlying class are triples whose coordinates are from the classes Theater, Time, and Movie, respectively.	x-1720-2
In the GSM, each complex value is the result of one application of the tuple construct.	x-1720-3
This is indicated using a node of the form ⊗, with components indicated using dashed arrows.	x-1720-4
The components of each complex value can be printable, abstract, or complex values.	x-1720-5
However, there cannot be a directed cycle in the set of edges used to define the complex values.	x-1720-6
As suggested by the attribute price, a complex value class may have attributes.	x-1720-7
Complex value classes can also serve as the range of an attribute, as illustrated by the class Award.	x-1720-8
Complex values are of independent interest and are discussed in some depth in Chapter 20.	x-1721-1
Complex values generally include hierarchical structures built from a handful of Design and Dependencies Name Pariscope Citizen- Price Person ship Theater Time Movie Director Name Phone Title Name Prize Figure 11.1: The schema CINEMA-SEM in the Generic Semantic Model basic constructors, including tuple (as shown here) set, and sometimes others such as bag and list.	x-1721-2
Rich complex value models are generally incorporated into object-oriented data models and into some semantic data models.	x-1721-3
Some constructs for complex values, such as set, cannot be simulated directly using the pure relational model (see Exercise 11.24).	x-1721-4
The final building block of the GSM is the ISA relationship, which represents set inclusion.	x-1722-1
In the example schema of Fig.	x-1722-2
11.1, the ISA relationships are depicted by double-shafted arrows and indicate that the set of Director is a subset of Person, and likewise that Actor is a subset of Person.	x-1722-3
In addition to indicating set inclusion, ISA relationships indicate a form of subtyping relationship, or inheritance.	x-1722-4
Specifically, if class B ISA class A, then each attribute of A is also relevant (and defined for) elements of class B.	x-1722-5
In the context of semantic models, this should be no surprise because the elements of B are elements of A.	x-1722-6
In the GSM, the graph induced by ISA relationships is a directed acyclic graph (DAG).	x-1723-1
The root nodes are primary abstract classes (represented with diamonds), and all other nodes are subclass nodes (represented with circles).	x-1724-1
Each subclass node has exactly one primary node above it.	x-1724-2
Complex value classes cannot participate in ISA relationships.	x-1724-3
In the GSM, the tuple and multivalued attribute constructs are somewhat redundant: A multivalued attribute is easily simulated using a tuple construct.	x-1725-1
Such redundancy is typical of semantic models: The emphasis is on allowing schemas that correspond closely to the way that users think about an application.	x-1725-2
On a bit of a tangent, we also note that the tuple construct of GSM is close to the relationship construct of the ER model.	x-1725-3
GSM Instances Let S be a GSM schema.	x-1726-1
It is assumed that a fixed (finite or infinite) domain is associated to each printable class in S. We also assume a countably infinite set obj of OIDs.	x-1726-2
Example 11.1.1 Part of a very small instance I1 of CINEMA-SEM is shown in Fig.	x-1727-1
11.2.	x-1727-2
The values of complex value Award, the attributes award, address, and phone are not shown.	x-1727-3
The symbols o1, o2, etc., denote OIDs.	x-1727-4
Consider an instance I′ that is identical to I1, except that o2 is replaced by o8 everywhere.	x-1728-1
Because OIDs serve only as internal representations that cannot be accessed Design and Dependencies I1( Person) = name(o1) = Alice citizenship(o1) = Great Britain name(o2) = Allen citizenship(o2) = United States name(o3) = Keaton citizenship(o3) = United States I1( Director) = {o2} directed(o2) = {o4, o5} I1( Actor) = {o2, o3} I1( Movie) = {o4, o5} title(o4) = Take the Money title(o5) = Annie Hall director(o4) = o2 director(o5) = o2 I1( Theater) = {o6} name(o6) = Le Champo I1( Pariscope) = price( o6, 20:00, o4) = 30FF Figure 11.2: Part of an instance I1 of CINEMA-SEM explicitly, I1 and I′ are considered to be identical in terms of the information that they represent.	x-1728-2
Let S be a GSM schema.	x-1729-1
An OID isomorphism is a function µ that is a permutation on the set obj of OIDs and leaves all printables fixed.	x-1729-2
Such functions are extended to Inst(S) in the natural fashion.	x-1729-3
Two instances I and I′ are OID equivalent, denoted I ≡ OID I′, if there is an OID isomorphism µ such that µ(I) = I′.	x-1729-4
This is clearly an equivalence relation.	x-1729-5
The GSM is a very basic semantic data model, and many variations on the semantic constructs included in the GSM have been explored in the literature.	x-1730-1
For example, a variety of simple constraints can be incorporated, such as cardinality constraints on attributes and disjointness between subclasses (e.g., that Director and Actor are disjoint).	x-1730-2
Another variation is to require that a class be “dependent” on an attribute (e.g., that each Award object must occur in the image of some Actor) or on a complex value class.	x-1730-3
More complex constraints based on first-order sentences have also been explored.	x-1730-4
Some semantic models support different kinds of ISA relationships, and some provide “derived data” (i.e., a form of user view incorporated into the base schema).	x-1730-5
Translating into the Relational Model We now describe an approach for translating semantic schemas into relational database schemas.	x-1731-1
As we shall see, the semantics associated with the semantic schema will yield dependencies of various forms in the relational schema.	x-1731-2
Informally, a surrogate of an object is a unique, unchanging printable value that is associated with the object.	x-1732-1
Many real-world objects have natural surrogates (e.g., Social Security number for persons in the United States or France; or Invoice Number for invoices in a commercial enterprise).	x-1732-2
In other cases, abstract surrogates can be used.	x-1732-3
The kernel of the translation of GSM schemas into relational ones concerns how objects in GSM instances can be represented using (tuples of) printables.	x-1733-1
For each class C occurring in the GSM schema, we associate a set of relational attributes, called the representation of C, and denoted rep(C).	x-1733-2
For a printable class C, rep(C) is a single attribute having this sort.	x-1733-3
For abstract class C, rep(C) is a set of attributes corresponding to the key attributes of the primary class above C. For a complex value class C = [C1, .	x-1733-4
.	x-1733-5
.	x-1733-6
, Cm], rep(C) consists of (disjoint copies of) all of the attributes occurring in rep(C1), .	x-1733-7
.	x-1733-8
.	x-1733-9
, rep(Cm).	x-1733-10
Translation of a GSM schema into a relation schema is illustrated in the following example.	x-1734-1
Example 11.1.2 One way to simulate schema CINEMA-SEM in the relational model is to use the schema CINEMA-REL, which has the following schema: Person Director Has_Award Movie Theater Pariscope Design and Dependencies Person name citizenship Movie title director_name Great Britain Take the Money and Run United States Keaton United States Pariscope theater_name time title price Le Champo Take the Money and Run Figure 11.3: Part of a relational instance I2 that simulates I1 Figure 11.3 shows three relations in the relational simulation I2 of the instance I1 of Fig.	x-1735-1
11.2.	x-1735-2
In schema CINEMA-REL, both Actor and Acts_in are included in case there are one or more actors that did not act in any movie.	x-1736-1
For similar reasons, Acts_in and Has_Award are separated.	x-1736-2
In contrast, we have assumed that each person has a citizenship (i.e., that citizenship is a total function).	x-1737-1
If not, then two relations would be needed in place of Person.	x-1737-2
Analogous remarks hold for directors, movies, theaters, and Pariscope objects.	x-1737-3
In schema CINEMA-REL, we have not explicitly provided relations to represent the attributes directed of Director or actors of Movie.	x-1738-1
This is because both of these are inverses of other attributes, which are represented explicitly (by Movie and Acts_in, respectively).	x-1738-2
If we were to consider the complex value class Awards of CINEMA-SEM to be dependent on the attribute award, then the relation Award could be omitted.	x-1739-1
Suppose that I is an instance of CINEMA-SEM and that I′ is the simulation of I.	x-1740-1
The semantics of CINEMA-SEM, along with the assumed keys, imply that I′ will satisfy several dependencies.	x-1741-1
This includes the following fd’s (in fact, key dependencies): Person name → citizenship Movie title → director _ name Theater theater _ name → address, phone Pariscope theater _ name, time, title → price A number of ind’s are also implied: Director[ name] Person[ name] Person[ name] Movie[ director _ name] Director[ name] Movie[ title] Has _ Award[ name] Has _ Award[ prize, year] Pariscope[ theater _ name] Theater[ theater _ name] Pariscope[ title] Movie[ title] The first group of ind’s follows from ISA relationships; the second from restrictions on attribute ranges; and the third from restrictions on the components of complex values.	x-1741-2
All but one of the ind’s here are unary, because all of the keys, except the key for Award, are based on a single attribute.	x-1741-3
Preservation of Data Suppose that S is a GSM schema with keys for primary classes, and (R, ∪ Ŵ) is a relational schema that simulates it, constructed in the fashion illustrated in Example 11.1.2, where is the set of fd’s and Ŵ is the set of ind’s.	x-1742-1
As noted in criterion (1) at the beginning of this chapter, it is desirable that there be a natural one-to-one mapping τ from instances of S to instances of (R, ∪ Ŵ).	x-1742-2
To formalize this, two obstacles need to be overcome.	x-1742-3
First, we have not developed a query language for the GSM.	x-1743-1
(In fact, no query language has become widely accepted for any of the semantic data models.	x-1743-2
In contrast, some query languages for object-oriented database models are now gaining wide acceptance.)	x-1743-3
We shall overcome this obstacle by developing a rather abstract notion of “natural” for this context.	x-1743-4
The second obstacle stems from the fact that OID-equivalent GSM instances hold essentially the same information.	x-1744-1
Thus we would expect OID-equivalent instances to map to the same relational instance.1 To refine criterion (1) for this context, we are searching for a one-to-one mapping from Inst(S)/ ≡ OID into Inst(R, ∪ Ŵ).	x-1744-2
The following can be verified (see Exercise 11.3): Theorem 11.1.3 (Informal) Let S be a GSM schema with keys for primary classes, Inst(R, ∪ Ŵ) such that τ is OID consistent and preserves the active domain, and such that τ : Inst(S)/≡ OID → Inst(R, ∪ Ŵ) is one-to-one and onto.	x-1745-1
Properties of the Relational Schema We now consider criteria (2) and (3) to highlight desirable properties of relational schemas that simulate GSM schemas.	x-1746-1
Design and Dependencies Criterion (2) for schema transformations concerns desirable properties of the target schema.	x-1747-1
We now describe three such properties resulting from the transformation of GSM schemas into relational ones.	x-1747-2
Suppose again that S is a GSM schema with keys, and (R, ∪ Ŵ) is a relational simulation of it.	x-1748-1
We assume as before that no constraints hold for S, aside from those implied by the constructs in S and the keys.	x-1748-2
The three properties are as follows:	x-1749-1
under .	x-1750-1
Together these properties present a number of desirable features.	x-1751-1
In particular, dependency implication is easy to check.	x-1751-2
Given a database schema R and sets of fd’s and Ŵ of ind’s over R, and Ŵ are independent if (1) for each fd σ over R, ( ∪ Ŵ) |= σ implies |= σ , and (2) for each ind γ over R, ( ∪ Ŵ) |= γ implies Ŵ |= γ .	x-1751-3
Suppose that S is a GSM schema and that (R, ∪ Ŵ) is a relational simulation of S. It can be shown that the three aforementioned properties imply that and Ŵ are independent (see Exercise 11.4).	x-1751-4
To conclude this section, we consider criterion (3).	x-1752-1
This criterion concerns the preservation of meta-data.	x-1752-2
We do not attempt to formalize this criterion for this context, but it should be clear that there is a close correspondence between the dependencies in ∪ Ŵ	x-1752-3
The preceding discussion assumes that no dependency holds for S, aside from those implied by the keys and the constructs in S. However, in many cases constraints will be incorporated into S that are not directly implied by the structure of S. For instance, recall Example 11.1.2, and suppose that the fd Pariscope : theater_name, time → price is true for the underlying data.	x-1753-1
The relational simulation will have to include this dependency and, as a result, the resulting relational schema may be missing some of the desirable features (e.g., the family of fd’s is not equivalent to a set of keys and the schema is no longer in BCNF).	x-1753-2
This suggests that a semantic model might be used to obtain a coarse relational schema, which might be refined further using the techniques for improving relational schemas developed in the next section.	x-1754-1
Normal Forms In this section, we consider schema design based on the refinement of relational schemas and normal forms, which provide the basis for this approach.	x-1755-1
The articulation of these normal forms is arguably the main contribution of relational database theory to the realm of schema design.	x-1755-2
We begin the discussion by presenting two of the most prominent normal forms and a design strategy based on “decomposition.” We then develop another normal form that overcomes certain technical problems of the first two, and describe an associated design strategy based on “synthesis.” We conclude with brief comments on the relationship of ind’s with decomposition.	x-1755-3
When all the dependencies in a relational schema (R, ) are considered to be tagged, one can view the database schema as a set {(R1, 1), .	x-1756-1
.	x-1756-2
.	x-1756-3
, (Rn, n)}, where each (Rj , j ) is a relation schema and the Rj ’s are distinct.	x-1756-4
In particular, an fd schema is a relation schema (R, ) or database schema (R, ), where is a set of tagged fd’s; this is extended in the natural fashion to other classes of dependencies.	x-1756-5
Much of the work on refinement of relational schemas has focused on fd schemas and (fd + mvd) schemas.	x-1756-6
This is what we consider here.	x-1756-7
(The impact of the ind’s is briefly considered at the end of this section.)	x-1756-8
A normal form restricts the set of dependencies that are allowed to hold in a relation schema.	x-1756-9
The main purpose of the normal forms is to eliminate at least some of the redundancies and update anomalies that might otherwise arise.	x-1756-10
Intuitively, schemas in normal form are “good” schemas.	x-1756-11
We introduce next two kinds of normal forms, namely BCNF and 4NF.	x-1757-1
(We will consider a third one, 3NF, later.)	x-1757-2
We then consider techniques to transform a schema into such desirable normal forms.	x-1757-3
BCNF: Do Not Represent the Same Fact Twice Recall the schema ( Movies[ T ( itle), D( irector), A( actor)], {T → D}) from Section 8.1.	x-1758-1
As discussed there, the Movies relation suffers from various anomalies, primarily because there is only one Director associated with each Title but possibly several Actors.	x-1758-2
Suppose that (R[U ], ) is a relation schema, |= X → Y , Y ⊆ X and |= X → U .	x-1758-3
It is not hard to see that anomalies analogous to those of Movies can arise in R. Boyce-Codd normal form prohibits this kind of situation.	x-1758-4
Definition 11.2.1 A relation schema (R[U ], ) is in Boyce-Codd normal form (BCNF) if |= X → U whenever |= X → Y for some Y ⊆ X.	x-1759-1
An fd schema (R, ) is in BCNF if each of its relation schemas is.	x-1759-2
BCNF is most often discussed in cases where involves only functional dependencies.	x-1760-1
In such cases, if (R, ) is in BCNF, the anomalies of Section 8.1 do not arise.	x-1760-2
An essential intuition underlying BCNF is, “Do not represent the same fact twice.” The question now arises: What does one do with a relation schema (R, ) that is not in BCNF?	x-1760-3
In many cases, it is possible to decompose this schema into subschemas (R1, 1), .	x-1760-4
.	x-1760-5
.	x-1760-6
, (Rn, n) without information loss.	x-1760-7
As a simple example, Movies can be decomposed into Design and Dependencies	x-1760-8
Consider the relation schema ( Studios[ N( ame), D( irector), L( ocation)], {N → tuple n, d, l is in Studios if director d is employed by the studio with name n and if this studio has an office in location l. Only trivial fd’s are satisfied by all instances of this schema, and so it is in BCNF.	x-1761-1
However, update anomalies can still arise, essentially because the D and L values are independent from each other.	x-1761-2
This gives rise to the following generalization of BCNF2: Definition 11.2.2	x-1761-3
It is clear that if a relation schema is in 4NF, then it is in BCNF.	x-1762-1
It is easily seen that Studios can be decomposed into two 4NF relations, without loss of information and that the resulting relation schemas do not have the update anomalies mentioned earlier.	x-1762-2
An essential intuition underlying 4NF is, “Do not store unrelated information in the same relation.” The General Framework of Decomposition One approach to refining relational schemas is decomposition.	x-1762-3
In this approach, it is usually assumed that the original schema consists of a single wide relation containing all attributes of interest.	x-1762-4
This is referred to as the pure universal relation assumption, or pure URA.	x-1762-5
A relaxation of the pure URA, called the “weak URA,” is considered briefly in Section 11.3.	x-1762-6
The pure URA is a simplifying assumption, because in practice the original schema is likely to consist of several tables, each with its own dependencies.	x-1763-1
In that case, the design process described for the pure URA is applied separately to each table.	x-1763-2
We adopt the pure URA here.	x-1763-3
In this context, the schema transformation produced by the design process consists of decomposing the original table into smaller tables by using the projection operator.	x-1763-4
with dependencies Ŵ, where ∪{Xj | j ∈ [1, n]} = Z.	x-1764-1
(The relation name ‘U ’ is used to suggest that it is a “universal” relation.)	x-1764-2
In the sequel, we often use relation names U (Ri) and attribute sets Z (Xi), interchangeably if ambiguity does not arise.	x-1764-3
We now consider the three criteria for schema transformation in the context of decomposition.	x-1765-1
As already suggested, criterion (2) is evaluated in terms of the normal forms.	x-1765-2
With regard to the preservation of data (1), the “natural” mapping from R to R is obtained by projection: The decomposition mapping of R is the function πR : Inst(U ) → Inst(R) such that for I ∈ inst(U ), we have πR(I )(Rj ) = πR (I ).	x-1765-3
Criterion (1) says that the decompo-j sition should not lose information when I is replaced by its projections (i.e., it should be one-to-one).	x-1765-4
Rn I over (U, ).	x-1766-1
But q(I ) = I simply says that I satisfies the jd ⊲⊳ [R].	x-1766-2
Thus we have the following: Theorem 11.2.3 Let (U, ) be a (full dependencies) schema and R a decomposition for (U, ).	x-1766-3
Then R has the lossless join property iff |=⊲⊳ [R].	x-1766-4
The preceding implication can be tested using the chase (see Chapter 8), as illustrated next.	x-1767-1
Example 11.2.4 Recall the schema ( Movies[ TDA], {T → D}).	x-1768-1
As suggested earlier, a decomposition into BCNF is R = { TD, TA}.	x-1768-2
This decomposition has the lossless join property.	x-1768-3
The tableau associated with the jd σ =⊲⊳ [ TD, TA] is as follows: Tσ T D t d t d1 tσ t d Consider the chase of Tσ , tσ with {T → D}.	x-1768-4
Because the two first tuples agree on the T column, d and d1 are merged because of the fd.	x-1768-5
Thus t, d, a ∈ chase(Tσ , tσ , {T → D}).	x-1768-6
Hence T → D implies the jd σ , so R has the lossless join property.	x-1769-1
(See also Exercise 11.9.)	x-1769-2
Referring to the preceding example, note that it is possible to represent information in R that cannot be directly represented in Movies.	x-1770-1
Specifically, in the decomposed schema we can represent a movie with a director but no actors and a movie with an actor but no director.	x-1770-2
This indicates, intuitively, that a decomposed schema may have more information capacity Design and Dependencies than the original (see Exercise 11.23).	x-1771-1
In practice, this additional capacity is exploited; in fact, it provides part of the solution of so-called deletion anomalies.	x-1771-2
Remark 11.2.5 In the preceding example, we used the natural join operator to reconstruct decompositions.	x-1772-1
Interestingly, there are cases in which the natural join does not suffice.	x-1772-2
To show that a decomposition is one-to-one, it suffices to exhibit an inverse to the projection, called a reconstruction mapping.	x-1772-3
If is permitted to include very general constraints expressed in first-order logic that may not be dependencies per se, then there are one-to-one decompositions whose reconstruction mappings are not the natural join (see Exercise 11.20).	x-1772-4
We now consider criterion (3), the preservation of meta-data.	x-1773-1
In the context of decomposition, this is formalized in terms of “dependency preservation”: Given schema (U, ), which is replaced by a decomposition R = {R1, .	x-1773-2
.	x-1773-3
.	x-1773-4
, Rn}, we would like to find for each j a family Ŵj of dependencies over Rj such that ∪j Ŵj is equivalent to the original .	x-1773-5
In the case where is a set of fd’s, we can make this much more precise.	x-1773-6
For V ⊆ U , let πV () = {X → A | XA ⊆ V and |= X → A}, let Ŵj = πX (), and let Ŵ = ∪ j j Ŵj .	x-1773-7
Obviously, |= Ŵ.	x-1773-8
(See Proposition 10.2.4.)	x-1773-9
Intu- itively, Ŵ consists of the dependencies in ∗ that are local to the relations in the decomposition R. The decomposition R is said to be dependency preserving iff Ŵ ≡ .	x-1773-10
In other words, can be enforced by the dependencies local in the decomposition.	x-1773-11
It is easy to see that the decomposition of Example 11.2.4 is dependency preserving.	x-1773-12
Given an fd schema (U, ) and V ⊆ U , πV () has size exponential in V , simply because of trivial fd’s.	x-1774-1
But perhaps there is a smaller set of fd’s that is equivalent to πV ().	x-1774-2
A cover of a set Ŵ of fd’s is a set Ŵ′ of fd’s such that Ŵ′ ≡ Ŵ.	x-1774-3
Unfortunately, in some cases the smallest cover for a projection πV () is exponential in the size of (see Exercise 11.11).	x-1774-4
What about projections of sets of mvd’s?	x-1775-1
Suppose that is a set of fd’s and mvd’s over U .	x-1775-2
Let V ⊆ U and	x-1775-3
V Consider a decomposition R of (U, ).	x-1776-1
Viewed as constraints on U , the sets π mvd() are Rj now embedded mvd’s.	x-1776-2
As we saw in Chapter 10, testing implication for embedded mvd’s is undecidable.	x-1776-3
However, the issue of testing for dependency preservation in the context of decompositions involving fd’s and mvd’s is rather specialized and remains open.	x-1776-4
Fd’s and Decomposition into BCNF We now present a simple algorithm for decomposing an fd schema (U, ) into BCNF relations.	x-1777-1
The decomposition produced by the algorithm has the lossless join property but is not guaranteed to be dependency preserving.	x-1777-2
We begin with a simple example.	x-1778-1
Example 11.2.6 Consider the schema (U, ), where U has attributes TITLE D_NAME TIME PRICE TH_NAME PHONE FD 1 : TH _ NAME → ADDRESS, PHONE FD 2 : TH _ NAME, TIME, TITLE → PRICE FD 3 : TITLE → D _ NAME Intuitively, schema (U, ) represents a fragment of the real-world situation represented by the semantic schema CINEMA-SEM.	x-1779-1
We now present the following: Input: A relation schema (U, ), where is a set of fd’s.	x-1780-1
Output: A database schema (R, Ŵ) in BCNF	x-1781-1
Design and Dependencies It is easily seen that the preceding algorithm terminates [each iteration of the loop eliminates at least one violation of BCNF among finitely many possible ones].	x-1782-1
The following is easily verified (see Exercise 11.10): Theorem 11.2.8 The BCNF Decomposition Algorithm yields a BCNF schema and a decomposition that has the lossless join property.	x-1782-2
What is the complexity of running the BCNF Decomposition Algorithm?	x-1783-1
The main expenses are (1) examining subschemas (S[V ], L) to see if they are in BCNF and, if not, finding a way to decompose them; and (2) computing the projections of L. (1) is polynomial, but (2) is inherently exponential (see Exercise 11.11).	x-1783-2
This suggests a modification to the algorithm, in which only the relational schemas S[V ] are computed at each stage, but L = πV () is not.	x-1783-3
However, the problem of determining, given fd schema (U, ) and V ⊆ U , whether (V , πV ()) is in BCNF is co-np-complete (see Exercise 11.12).	x-1783-4
Interestingly, a polynomial time algorithm does exist for finding some BCNF decomposition of an input schema (U, ) (see Exercise 11.13).	x-1783-5
When applying BCNF decomposition to the schema of Example 11.2.6, the same result is achieved regardless of the order in which the dependencies are applied.	x-1784-1
This is not always the case, as illustrated next.	x-1784-2
Example 11.2.9 Consider (ABC, {A → B, B → C}).	x-1785-1
This has two BCNF decompo- sitions R1 = {(AB, {A → B}), (BC, {B → C})} R2 = {(AB, {A → B}), (AC, ∅)}.	x-1785-2
Note that R1 is dependency preserving, but R2 is not.	x-1786-1
Fd’s, Dependency Preservation, and 3NF It is easy to check that the schemas in Examples 11.2.4, 11.2.6, and 11.2.9 have dependency-preserving decompositions into BCNF.	x-1787-1
However, this is not always achievable, as shown by the following example.	x-1787-2
Example 11.2.10 Consider a schema Lectures[ C( ourse), P( rofessor), H( our)], where tuple c, p, h indicates that course c is taught by professor p at hour h. We assume that Hour ranges over weekday-time pairs (e.g., Tuesday at 4PM) and that a given course may have lectures during several hours each week.	x-1788-1
Assume that the following two dependencies are to hold:	x-1788-2
C → P	x-1789-1
PH → C In other words, each course is taught by only one professor, and a professor can teach only one course at a given hour.	x-1790-1
The schema ( Lectures, ) is not in BCNF because |= C → P , but |= C → H .	x-1791-1
It is easily seen that { CP : C → P } |= , and so this decomposition does not preserve dependencies.	x-1792-1
A simple case analysis shows that there is no BCNF decomposition of Lectures that preserves dependencies.	x-1792-2
This raises the question: Is there a less restrictive normal form for fd’s so that a lossless join decomposition that preserves dependencies can always be found?	x-1793-1
The affirmative answer is based on “third normal form” (3NF).	x-1793-2
To define it, we need some auxiliary notions.	x-1793-3
Suppose that (R[U ], ) is an fd schema.	x-1793-4
A superkey of R is a set X ⊆ U such that |= X → U .	x-1793-5
A key of R is a minimal superkey.	x-1793-6
A key attribute is an attribute A ∈ U that is in some key of R. We now have the following: Definition 11.2.11	x-1793-7
Example 11.2.12 Recall the schema ( Lectures,{C → P , PH → C}) described in Example 11.2.10.	x-1794-1
Here PH is a key, so P is a key attribute.	x-1794-2
Thus the schema is in 3NF.	x-1794-3
Given a set of fd’s, a minimal cover of is a set ′ of fd’s such that (a) each dependency in ′ has the form X → A, where A is an attribute; (b) ′ ≡ ;	x-1795-1
We now have the following: Input: A relation schema (U, ), where is a set of fd’s that is a minimal cover.	x-1796-1
We assume that each attribute of U occurs in at least one fd of .	x-1796-2
Output: An fd schema (R, Ŵ) in 3NF	x-1797-1
Design and Dependencies	x-1798-1
Intuitively, then, the output relations result from combining or “synthesizing” attributes rather than decomposing the full attribute set.	x-1799-1
The following is easily verified (see Exercise 11.17): Theorem 11.2.14 The 3NF Synthesis Algorithm decomposes a relation schema into a database schema in 3NF that has the lossless join property and preserves dependencies.	x-1800-1
Several improvements to the basic 3NF Synthesis Algorithm can be made easily.	x-1801-1
For example, different schemas obtained in step (2.a) can be merged if they come from fd’s with the same left-hand side.	x-1801-2
Step (2.b) is not needed if step (2.a) already produced a schema whose set of attributes is a superkey for (U, ).	x-1801-3
In many practical situations, it may be appropriate to omit step (2.b) of the algorithm.	x-1801-4
In that case, the decomposition preserves dependencies but does not necessarily satisfy the lossless join property.	x-1801-5
In the preceding algorithm, it was assumed that each attribute of U occurs in at least one fd of .	x-1802-1
Obviously, this may not always be the case, for example, the attribute A_NAME in Example 11.2.15b does not participate in fd’s.	x-1802-2
One approach to remedy this situation is to introduce symbolic fd’s.	x-1802-3
For instance, in that example one might include the fd TITLE, A_NAME → ω1, where ω1 is a new attribute.	x-1802-4
One relation produced by the algorithm will be { TITLE, A _ NAME, ω1}.	x-1802-5
As a last step, attributes such as ω1 are removed.	x-1802-6
In Example 11.2.9 we saw that the output of a BCNF decomposition may depend on the order in which fd’s are applied.	x-1803-1
In the case of the preceding algorithm for 3NF, the minimal cover chosen greatly impacts the final result.	x-1803-2
Mvd’s and Decomposition into 4NF	x-1804-1
Example 11.2.15 D|L}) is in BCNF and 3NF but has update anomalies.	x-1805-1
The mvd suggests a decomposition into ({ Name, Director}, { Name, Location}).	x-1805-2
which can be further decomposed to incorporated into the original schema, we can further decompose the last relation and apply a step analogous to (2d) of the BCNF Decomposition Algorithm to obtain Fourth normal form (4NF) was originally developed to address these kinds of situations.	x-1806-1
As suggested by the preceding example, an algorithm yielding 4NF decompositions can be developed along the lines of the BCNF Decomposition Algorithm.	x-1806-2
As with BCNF, the output of 4NF decomposition is a lossless join decomposition that is not necessarily dependency preserving.	x-1806-3
In relational schema design starting with a semantic data model, numerous ind’s are typically generated.	x-1807-1
In contrast, the decomposition and synthesis approaches for refining relational schemas as presented earlier do not take ind’s into account.	x-1807-2
It is possible to incorporate ind’s into these approaches, but the specific choice of ind’s is dependent on the intended semantics of the target schema.	x-1807-3
Example 11.2.16 Recall the schema ( Movies[ TDA], {T → D}) and decomposition into (R1[ TD], {T → D}) and (R2[ TA], ∅).	x-1808-1
R1[T ] should be included.	x-1809-1
Design and Dependencies	x-1810-1
More generally, what if one is to refine a relational schema (R, ∪ Ŵ), where is a set of tagged fd’s and mvd’s and Ŵ is a set of ind’s?	x-1811-1
It may occur that there is an ind Ri[X] ⊆ Rj [Y ], and either X or Y is to be “split” as the result of a decomposition step.	x-1811-2
The desired semantics of the target schema can be used to select between a variety of heuristic approaches to preserving the semantics of this ind.	x-1812-1
If Ŵ consists of unary ind’s, such splitting cannot occur.	x-1812-2
Speaking intuitively, if the ind’s of Ŵ are key based, then the chances of such splitting are reduced.	x-1812-3
Universal Relation Assumption In the preceding section, we saw that the decomposition and synthesis approaches to relational schema design assume the pure URA.	x-1813-1
This section begins by articulating some of the implications that underly the pure URA.	x-1813-2
It then presents the “weak URA,” which provides an intuitively natural mechanism for viewing a relational database instance I as if it were a universal relation.	x-1813-3
Underlying Assumptions Suppose that an fd schema (U [Z], ) is given and that decomposition or synthesis will be applied.	x-1814-1
One of several different database schemas might be produced, but presumably all of them carry roughly the same semantics.	x-1814-2
This suggests that the attributes in Z can be grouped into relation schemas in several different ways, without substantially affecting their underlying semantics.	x-1814-3
Intuitively, then, it is the attributes themselves (along with the dependencies in ), rather than the attributes as they occur in different relation schemas, that carry the bulk of the semantics in the schema.	x-1814-4
The notion that the attributes can represent a substantial portion of the semantics of an application is central to schema design based on the pure URA.	x-1814-5
When decomposition and synthesis were first introduced, the underlying implications of this notion were not well understood.	x-1815-1
Several intuitive assumptions were articulated that attempted to capture these implications.	x-1815-2
We describe here two of the most important assumptions.	x-1815-3
Any approach to relational schema design based on the pure URA should also abide by these two assumptions.	x-1815-4
Universal Relation Scheme Assumption: This states that if an attribute name appears in two or more places in a database schema, then it refers to the same entity set in each place.	x-1816-1
For example, an attribute name Number should not be used for both serial numbers and employee numbers; rather two distinct attribute names Serial# and Employee# should be used.	x-1817-1
Unique Role Assumption: This states that for each set of attributes there is a unique rela- tionship between them.	x-1818-1
This is sometimes weakened to say that there may be several relationships, but one is deemed primary.	x-1818-2
This is illustrated in the following example.	x-1818-3
Example 11.3.1	x-1819-1
BL, which holds data about branches and loans they have given BA, which holds data about branches and checking accounts they provide CL, which holds data about customers and loans they have CA, which holds data about customers and checking accounts they have.	x-1820-1
This design does not satisfy the unique role assumption, mainly because of the cycle in the schema.	x-1821-1
For example, consider the relationship between branches and customers.	x-1821-2
In fact, there are two relationships—via loans and via accounts.	x-1821-3
Thus a request for “the” data in the relationship between banks and customers is somewhat ambiguous, because it could mean tuples stemming from either of the two relationships or from the intersection or union of both of them.	x-1821-4
One solution to this ambiguity is to “break” the cycle.	x-1822-1
For example, we could replace the Customer attribute by the two attributes L-C( ustomer) and A-C( ustomer).	x-1822-2
Now the user can specify the desired relationship by using the appropriate attribute.	x-1822-3
The Weak Universal Relation Assumption Suppose that schema (U, ) has decomposition (R, Ŵ) (with R = {R1, .	x-1823-1
.	x-1823-2
.	x-1823-3
, Rn}).	x-1823-4
When studying decomposition, we focused primarily on instances I of (R, Ŵ) that were the image of some instance I of (U, ) under the decomposition mapping πR.	x-1823-5
In particular, such instances I are globally consistent.	x-1823-6
[Recall from Chapter 6 that instance I is globally consistent if for each j ∈ [1, n], πR (⊲⊳ I) = I(R j j ); i.e., no tuple of I(Rj ) is dangling relative to the full join.]	x-1823-7
However, in many practical situations it might be useful to use the decomposed schema R to store instances I that are not globally consistent.	x-1823-8
Example 11.3.2 Recall the schema ( Movies[ TDA], {T → D}) from Example 11.2.4 and its decomposition { TD, TA}.	x-1824-1
Suppose that for some movie the director is known, but no actors are known.	x-1824-2
As mentioned previously, this information is easily stored in the decomposed database, but not in the original.	x-1824-3
The impossibility of representing this information in the original schema was one of the anomalies that motivated the decomposition in the first place.	x-1824-4
Suppose that fd schema (U, ) has decomposition (R, Ŵ) = {(R1, Ŵ1), .	x-1825-1
.	x-1825-2
.	x-1825-3
, (Rn, Ŵn)}.	x-1825-4
Suppose also that I is an instance of R such that (1) I(Rj ) |= Ŵj for each j , but (2) I is Design and Dependencies B B B b b b b BC B C BC B C BC B C b c b c b c C D C D C D c d c d c d c d′ c d′ I1 I2 I3 Figure 11.4: Instances illustrating weak URA not necessarily globally consistent.	x-1826-1
Should I be considered a “valid” instance of schema (R, Ŵ)?	x-1826-2
More generally, given a schema (U, ), a decomposition R of U , and a (not necessarily globally consistent) instance I over R, how should we define the notion of	x-1826-3
The weak universal relation assumption ( weak URA) provides one approach for answering this question.	x-1827-1
Under the weak URA, we say that I satisfies if there is some instance J ∈ sat (U, ) such that I(Rj ) ⊆ πR (J ) for each j ∈ [1, n].	x-1827-2
In this case, J is j called a weak instance for I.	x-1827-3
Example 11.3.3 Let U = { ABCD}, = {A → B, BC → D}, and R = { AB, BC, ACD}.	x-1828-1
Consider the three instances of R shown in Fig.	x-1829-1
11.4.	x-1829-2
The instance I1 satisfies under the weak URA, because J1 = { a, b, c, d} is a weak instance.	x-1829-3
On the other hand, I2, which contains I1, does not satisfy under the weak URA.	x-1830-1
To see this, suppose that J2 is a weak instance for I2.	x-1830-2
Then J2 must contain the following (not necessarily distinct) tuples: t1 = a, b, c1, d1 t2 = a′, b, c2, d2 t3 = a3, b, c, d3 t4 = a, b4, c, d t5 = a′, b5, c, d′ where the subscripted constants may be new.	x-1830-3
Because J2 |= A → B, by considering the pairs t1, t4 and t2, t5, we see that b4 = b5 = b.	x-1830-4
Next, because J2 |= BC → D, and by considering the pair t4, t5, we have that d = d′, a contradiction.	x-1830-5
Finally, I3 does satisfy under the weak URA.	x-1831-1
This yields the following (see Exercise 11.27): Theorem 11.3.4 Let be a set of fd’s over U and R a decomposition of U .	x-1832-1
Testing whether I over R satisfies under the weak URA can be performed in polynomial time.	x-1832-2
Of course, the chasing technique can be extended to arbitrary egd’s, although the complexity jumps to exptime-complete.	x-1833-1
What about full tgd’s?	x-1834-1
Recall that full tgd’s can always be satisfied by adding new tuples to an instance.	x-1834-2
Let be a set of full dependencies.	x-1834-3
It is easy to see that I satisfies under the weak URA iff I satisfies ∗ ∩ {σ | σ is an egd} under the weak URA.	x-1834-4
Querying under the Weak URA Let (U, ) be a schema, where is a set of full dependencies, and let R be a decomposition of U .	x-1835-1
Let us assume the weak URA, and suppose that database instance I over R satisfies .	x-1835-2
How should queries against I be answered?	x-1836-1
One approach is to consider the query against all weak instances for I and then take the intersection of the answers.	x-1836-2
That is, q weak(I) = ∩{q(I ) | I is a weak instance of I}.	x-1836-3
We develop now a constructive method for computing q weak.	x-1837-1
Given instance I of R, the representative instance of I is defined as follows: For each component Ij of I, let I ′ be the result of extending I j j to be a free instance over U by padding tuples with distinct variables.	x-1838-1
Set I ′ = ∪{I ′ | j ∈ [1, n]}.	x-1838-2
Now apply the chase j using to obtain the representative instance rep(I, ) (or the empty instance, if two distinct constants are to be identified).	x-1838-3
Note that some elements of rep(I, ) may have variables occurring in them.	x-1838-4
For X ⊆ U , let π ↓X( rep(I, )) denote the set of tuples (i.e., with no variables present) in πX( rep(I, )).	x-1839-1
The following can now be verified (see Exercise 11.28).	x-1839-2
Proposition 11.3.5 Let (U, ), R and I be as above, and let X ⊆ U .	x-1840-1
Then	x-1840-2
Design and Dependencies This proposition provides the basis of a constructive method for evaluating an arbitrary algebra query q under the weak URA.	x-1841-1
Furthermore, if is a set of fd’s, then evaluating q will take time at most polynomial in the size of the input instance.	x-1841-2
This approach can be generalized to the case where is a set of full dependencies but computing the projection is exptime-complete.	x-1841-3
Bibliographic Notes The recent book [MR92] provides an in-depth coverage of relational schema design, including both the theoretical underpinnings and other, less formal factors that go into good design.	x-1842-1
Extensive treatments of the topic are also found in [Dat86, Fv89, Ull88, Vos91].	x-1842-2
References [Ken78, Ken79, Ken89] illustrate the many difficulties that arise in schema design, primarily with a host of intriguing examples that show how skilled the human mind is at organizing diverse information and how woefully limiting data models are.	x-1843-1
Surveys of semantic data models include [Bor85, HK87, PM88], and the book [TL82];	x-1844-1
Reference [Che76] describes a translation of the ER model into the relational model, so that the resulting schema is in BCNF.	x-1845-1
From a practical perspective, this has become widely accepted as the method of choice for designing relational schemas; [TYF86] provides a subsequent perspective on this approach.	x-1845-2
There has also been considerable work on understanding the properties of relational schemas resulting from ER schemas and mapping relational schemas into ER ones.	x-1845-3
Reference [MR92] provides an in-depth discussion of this area.	x-1845-4
Reference [LV87] presents a translation from a semantic to the relational model and studies the constraints implied for the relational schema, including cardinality constraints.	x-1846-1
The logical implication of constraints within a semantic model schema is studied in [CL94].	x-1846-2
References [Lie80, Lie82] study the relationship of schemas from the network and relational models.	x-1846-3
Bibliographic Notes provides justification for translations from the Entity-Relationship model into the relational model using notions of relative information capacity.	x-1847-1
Formal notions of relative information capacity have also been applied in the context of schema integration and translation	x-1847-2
The area of normal forms and relational database design was studied intensively in the 1970s and early 1980s.	x-1848-1
Much more complete coverage of this topic than presented here may be found in [Dat86, Mai83, Ull88, Vos91].	x-1848-2
We mention some of the most important papers in this area.	x-1848-3
First normal form [Cod70] is actually fundamental to the relational model: A relation is in first normal form (1NF) if each column contains atomic values.	x-1848-4
In Chapter 20 this restriction shall be relaxed to permit relations some of whose columns themselves hold relations (which again may not be in first normal form).	x-1848-5
References [Cod71, Cod72a] raised the issue of update anomalies and initiated the search for normal forms that prevent them by introducing second and third normal forms.	x-1848-6
The definition of 3NF used here is from [Zan82].	x-1848-7
(Second normal form is less restrictive than third normal form.)	x-1848-8
Boyce-Codd normal form (BCNF) was introduced in [Cod74] to provide a normal form simpler than 3NF.	x-1848-9
Another improvement of 3NF is proposed in [LTK81].	x-1848-10
Fourth normal form was introduced in [Fag77b]; Example 11.2.15 is inspired from that reference.	x-1848-11
Even richer normal forms include project-join normal form (PJ/NF) [Fag79] and domain-key normal form [Fag81].	x-1848-12
In addition to introducing second and third normal form, [Cod72a] initiated the search for normalization algorithms by proposing the first decomposition algorithms.	x-1849-1
This spawned other research on decomposition [DC72, RD75, PJ81] and synthesis [BST75, Ber76b, WW75].	x-1849-2
The fact that these two criteria are not equivalent was stressed in [Ris77], where it is proposed that both be attempted.	x-1849-3
Early surveys on these approaches to relational design include [BBG78, Fag77a, Ris78].	x-1849-4
Algorithms for synthesis into 3NF include	x-1849-5
The more formal study of decompositions and their properties was initiated in [Ris77], which considered decompositions into two-element sets and proposed the notion of independent components; and [AC78], which studied decompositions with lossless joins and dependency preservation.	x-1850-1
This was extended independently to arbitrary decompositions over fd’s by [BR80] and [MMSU80].	x-1850-2
Lossless join was further investigated in [Var82b]	x-1850-3
The notion that not all integrity constraints specified in a schema should be considered for the design process was implicit in various works on semantic data modeling (e.g.,	x-1851-1
Design and Dependencies The universal relation assumption has a long history; the reader is directed to [AA93, MUV84, Ull89b] for a much more complete coverage of this topic than found in this chapter.	x-1852-1
The URA was implicit in much of the early work on normal forms and decompositions; this was articulated more formally in [FMU82, MUV84].	x-1852-2
The weak URA was studied in connection with query processing in [Sag81, Sag83], and in connection with fd satisfaction in [Hon82].	x-1852-3
Proposition 11.3.5(a) is due to [MUV84] and part (b) is due to [Hon82]; the extension to full dependencies is due to [GMV86].	x-1852-4
Reference [Sci86] presents an interesting comparison of the relational model with inclusion dependencies to a variant of the universal relation model and shows an equivalence when certain natural restrictions are imposed.	x-1852-5
Exercises Exercise 11.1	x-1853-1
Exercise 11.2	x-1854-1
What dependencies are satisfied?	x-1855-1
Exercise 11.3	x-1856-1
Exercise 11.5	x-1857-1
Exercises Exercise 11.6	x-1858-1
Exercise 11.7 Let (U, ) be a schema, where contains possibly fd’s, mvd’s, and jd’s.	x-1859-1
Show that (a) (U, ) is in BCNF implies (U, ) is in 3NF; (b) (U, ) is in 4NF implies (U, ) is in BCNF; (c) (U, ) is in PJ/NF implies (U, ) is in 4NF.	x-1859-2
Exercise 11.8	x-1860-1
Exercise 11.9 Recall the schema ( Movies[ TDA],{T → D}).	x-1861-1
Consider the decomposition R1 =	x-1861-2
R1 Exercise 11.10 Verify Theorem 11.2.8.	x-1862-1
Hint: To prove the lossless join property, use repeated applications of Proposition 8.2.2.	x-1862-2
Exercise 11.11	x-1863-1
Exercise 11.12	x-1864-1
Exercise 11.14 Recall the schema Showings[ Th( eater), Sc( reen), Ti( tle), Sn( ack)] of Section 8.1, which satisfies the fd Th, Sc → Ti and the mvd Th → decompositions R1 = {{ Th, Sc, Ti}, { Th, Sn}} R2 = {{ Th, Sc, Ti}, { Th, Sc, Sn}}.	x-1865-1
Exercise 11.15	x-1866-1
Design and Dependencies Exercise 11.16	x-1867-1
Exercise 11.17 Prove Theorem 11.2.14.	x-1868-1
Exercise 11.18	x-1869-1
Exercise 11.19	x-1870-1
Consider the schema R[ ABCD].	x-1871-1
Given t ∈ I ∈ inst(R), t[A] is a key element for AB in I if there is no s ∈ I with t[A] = s[A] and t[B] = s[B].	x-1871-2
The notion of t[C] being a key element for CD is defined analogously.	x-1871-3
Let consist of the constraints (i) ∃t ∈ I such that both t[A] and t[C] are key elements.	x-1871-4
s[AB] and u[ CD] = t[ CD].	x-1872-1
Let R = {R1[AB], R2[ CD]} be a decomposition of (R, ).	x-1873-1
This and the following exercise provide one kind of characterization of the relative information capacity of decompositions of relation schemas.	x-1874-1
Let U be a set of attributes, let α = {X1, .	x-1874-2
.	x-1874-3
.	x-1874-4
, Xn} be a nonempty family of subsets of U , and let X = ∪n X i=1 i .	x-1874-5
The project- join mapping determined by α, denoted PJ α, is a mapping from instances over U to instances over ∪n X i=1 i defined by PJ α(I ) = ⊲⊳n i=1 Xi i=1 full project-join mapping.	x-1874-6
Prove the following for instances I and J over U : Exercises	x-1875-1
of subsets of U that the following are equivalent:	x-1876-1
Exercise 11.23 Given relational database schemas S and S′, we say that S′ dominates S using the calculus, denoted S (calc S′, if there are calculus queries q : Inst(S) → Inst(S′) and q′ : Inst(S′) → Inst(S) such that q ◦ q′ is the identity on Inst(S).	x-1877-1
Let schema R = (ABC, {A → B}) and the decomposition R = {(AB, {A → B}), (AC, ∅)}.	x-1877-2
(a) Verify that R (calc R. (b) Show that R (calc R. Hint: For schemas S and S′, S′ dominates S absolutely, denoted S (abs S′, if there is some n ≥ 0 such that for each finite subset d ⊆ dom with |d| ≥ n, |{I ∈ Inst(S) | adom(I) ⊆ d}| ≤ |{I ∈ Inst(S′) | adom(I) ⊆ d}|.	x-1877-3
Show that S (calc S′ implies S (abs S′.	x-1877-4
Then show that R (abs R.	x-1877-5
Hint: First prove the result for the case where the decomposition has two elements (i.e., it is based on an mvd).	x-1878-1
Then generalize to acyclic decompositions, using an induction based on the GYO algorithm.	x-1878-2
Exercise 11.26	x-1879-1
j I |=2 : if ⊲⊳ I |= .	x-1880-1
I |=3 : if I = πR(I ) for some I over U such that I |= .	x-1881-1
Exercise 11.28	x-1882-1
P A R T D DatalogandRecursion InPartB,weconsideredquerylanguagesrangingfromconjunctivequeriestofirst-order queries in the three paradigms: algebraic, logic, and deductive.	x-1883-1
We did this by enriching the conjunctive queries first with union (disjunction) and then with difference (negation).	x-1883-2
In this part, we further enrich these languages by adding recursion.	x-1884-1
First we add recursion to the conjunctive queries, which yields datalog.	x-1884-2
We study this language in Chapter 12.	x-1884-3
Datalog owes a great debt to Prolog and the logic-programming area in general.	x-1885-1
A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion.	x-1885-2
The perspective of databases, however, is significantly different from that of logic programming.	x-1885-3
(For example, in databases datalog programs define mappings from instances to instances, whereas logic programs generally carry their data with them and are studied as stand-alone entities.)	x-1885-4
We adapt the logic-programming approach to the framework of databases.	x-1885-5
We study evaluation techniques for datalog programs in Chapter 13, which covers the main optimization techniques developed for recursion in query languages, including seminaive evaluation and magic sets.	x-1886-1
Chapter 15 considers approaches to incorporating negation in datalog that are closer in spirit to logic programming.	x-1887-1
Several important semantics for negation are presented, including stratification and well-founded semantics.	x-1887-2
What do we see next?	x-1888-1
Riccardo: We introduce recursion.	x-1889-1
Sergio: He means we ask queries about your ancestors.	x-1890-1
Vittorio: Kind of — queries related to paths in a graph call for recursion and are crucial for many applications.	x-1891-1
Foralongtime,relationalcalculusandalgebrawereconsidered the databaselanguages.	x-1892-1
Codd even defined as “complete” a language that would yield precisely relational calculus.	x-1893-1
Nonetheless, there are simple operations on data that cannot be realized in the calculus.	x-1893-2
The most conspicuous example is graph transitive closure.	x-1893-3
In this chapter, we study a language that captures such queries and is thus more “complete” than relational calculus.1 The language, called datalog, provides a feature not encountered in languages studied so far: recursion.	x-1893-4
We start with an example that motivates the need for recursion.	x-1894-1
Consider a database for the Parisian Metro.	x-1894-2
Note that this database essentially describes a graph.	x-1894-3
(Database applications in which part of the data is a graph are common.)	x-1894-4
To avoid making the Metro database too static, we assume that the database is describing the available metro connections on a day of strike (not an unusual occurrence).	x-1894-5
So some connections may be missing, and the graph may be partitioned.	x-1894-6
An instance of this database is shown in Fig.	x-1894-7
12.1.	x-1894-8
Natural queries to ask are as follows: What are the stations reachable from Odeon?	x-1895-1
What lines can be reached from Odeon?	x-1896-1
Can we go from Odeon to Chatelet?	x-1897-1
Is there a cycle in the graph (i.e., a station reachable in one or more stops from itself)?	x-1898-1
Unfortunately, such queries cannot be answered in the calculus without using some a 1 We postpone a serious discussion of completeness until Part E, where we tackle fundamental issues such as “What is a formal definition of data manipulation (as opposed to arbitrary computation)?	x-1899-1
What is a reasonable definition of completeness for database languages?” Datalog Links Line Station Next Station St.-Germain Odeon Odeon St.-Michel St.-Michel Chatelet Chatelet Louvre Louvre Palais-Royal Palais-Royal Tuileries Tuileries Concorde Pont de Sevres Billancourt Billancourt Michel-Ange Michel-Ange Iena Iena F. D. Roosevelt F. D. Roosevelt Republique Republique Voltaire Figure 12.1: priori knowledge on the Metro graph, such as the graph diameter.	x-1900-1
More generally, given a graph G, a particular vertex a, and an integer n, it is easy to write a calculus query finding the vertexes at distance less than n from a; but it seems difficult to find a query for all vertexes reachable from a, regardless of the distance.	x-1900-2
We will prove formally in Chapter 17 that such a query is not expressible in the calculus.	x-1900-3
Intuitively, the reason is the lack of recursion in the calculus.	x-1900-4
The objective of this chapter is to extend some of the database languages considered so far with recursion.	x-1901-1
Although there are many ways to do this (see also Chapter 14), we focus in this chapter on an approach inspired by logic programming.	x-1901-2
This leads to a field called deductive databases, or database logic programming, which shares motivation and techniques with the logic-programming area.	x-1901-3
Most of the activity in deductive databases has focused on a toy language called datalog, which extends the conjunctive queries with recursion.	x-1902-1
The interaction between negation and recursion is more tricky and is considered in Chapters 14 and 15.	x-1902-2
The importance of datalog for deductive databases is analogous to that of the conjunctive queries for the relational model.	x-1902-3
Most optimization techniques for relational algebra were developed for conjunctive queries.	x-1902-4
Similarly, in this chapter most of the optimization techniques in deductive databases have been developed around datalog (see Chapter 13).	x-1902-5
Before formally presenting the language datalog, we present informally the syntax and various semantics that are considered for that language.	x-1903-1
Following is a datalog program PT C that computes the transitive closure of a graph.	x-1903-2
The graph is represented in relation G T (x, y) ← G(x, y) T (x, y) ← G(x, z), T (z, y).	x-1903-3
Datalog Observe that, except for the fact that relation T occurs both in the head and body of the second rule, these look like the nonrecursive datalog rules of Chapter 4.	x-1904-1
Thus a datalog program is interpreted as a mapping from instances over the relations occurring in the bodies only, to instances over the relations occurring in the heads.	x-1905-1
For instance, the preceding program maps a relation over G (a graph) to a relation over T (its transitive closure).	x-1905-2
The result T must satisfy the foregoing sentences.	x-1906-1
However, this is not sufficient to determine the result uniquely because it is easy to see that there are many T s that satisfy the sentences.	x-1906-2
However, it turns out that the result becomes unique if one adds the following natural minimality requirement: T consists of the smallest set of facts that makes the sentences true.	x-1906-3
As it turns out, for each datalog program and input, there is a unique minimal model.	x-1906-4
This defines the semantics of a datalog program.	x-1906-5
For example, suppose that the instance contains G(a, b), G(b, c), G(c, d).	x-1906-6
It turns out that T (a, d) holds in each instance that obeys (1) and (2) and where these three facts hold.	x-1907-1
In particular, it belongs to the minimum model of (1) and (2).	x-1907-2
The second proof-theoretic approach is based on obtaining proofs of facts.	x-1908-1
A proof of the fact T (a, d) is as follows:	x-1908-2
In the proof-theoretic perspective, there are two ways to derive facts.	x-1909-1
The first is to view programs as “factories” producing all facts that can be proven from known facts.	x-1909-2
The rules are then used bottom up, starting from the known facts and deriving all possible new facts.	x-1910-1
An alternative top-down evaluation starts from a fact to be proven and attempts to demonstrate it by deriving lemmas that are needed for the proof.	x-1910-2
This is the underlying Datalog intuition of a particular technique (called resolution) that originated in the theorem-proving field and lies at the core of the logic-programming area.	x-1910-3
The last approach is the fixpoint approach.	x-1911-1
We will see that the semantics of the program can be defined as a particular solution of a fixpoint equation.	x-1911-2
This approach leads to iterating a query until a fixpoint is reached and is thus procedural in nature.	x-1911-3
However, this computes again the facts that can be deduced by applications of the rules, and in that respect it is tightly connected to the (bottom-up) proof-theoretic approach.	x-1911-4
It corresponds to a natural strategy for generating proofs where shorter proofs are produced before longer proofs so facts are proven “as soon as possible.” In the next sections we describe in more detail the syntax, model-theoretic, fixpoint, and proof-theoretic semantics of datalog.	x-1911-5
As a rule, we introduce only the minimum amount of terminology from logic programming needed in the special database case.	x-1911-6
However, we make brief excursions into the wider framework in the text and exercises.	x-1911-7
The last section deals with static analysis of datalog programs.	x-1911-8
It provides decidability and undecidability results for several fundamental properties of programs.	x-1911-9
Techniques for the evaluation of datalog programs are discussed separately in Chapter 13.	x-1911-10
Syntax of Datalog	x-1912-1
We provide next a detailed definition of its syntax.	x-1913-1
We also briefly introduce some of the fundamental differences between datalog and logic programming.	x-1913-2
Definition 12.1.1 R1(u1) ← R2(u2), .	x-1914-1
.	x-1914-2
.	x-1914-3
, Rn(un), where n ≥ 1, R1, .	x-1914-4
.	x-1914-5
.	x-1914-6
, Rn are relation names and u1, .	x-1914-7
.	x-1914-8
.	x-1914-9
, un are free tuples of appropriate arities.	x-1914-10
Each variable occurring in u1 must occur in at least one of u2, .	x-1914-11
.	x-1914-12
.	x-1914-13
, un.	x-1914-14
A datalog program is a finite set of datalog rules.	x-1914-15
The head of the rule is the expression R1(u1); and R2(u2), .	x-1915-1
.	x-1915-2
.	x-1915-3
, Rn(un) forms the body.	x-1915-4
The set of constants occurring in a datalog program P is denoted adom(P ); and for an instance I, we use adom(P , I) as an abbreviation for adom(P ) ∪ adom(I).	x-1916-1
We next recall a definition from Chapter 4 that is central to this chapter.	x-1917-1
Definition 12.1.2 Given a valuation ν, an instantiation R1(ν(u1)) ← R2(ν(u2)), .	x-1918-1
.	x-1918-2
.	x-1918-3
, Rn(ν(un)) of a rule R1(u1) ← R2(u2), .	x-1918-4
.	x-1918-5
.	x-1918-6
, Rn(un) with ν is obtained by replacing each variable x by ν(x).	x-1918-7
Let P be a datalog program.	x-1919-1
An extensional relation is a relation occurring only in the body of the rules.	x-1919-2
An intensional relation is a relation occurring in the head of some rule of P .	x-1919-3
The extensional (database) schema, denoted edb(P ), consists of the set of all extensional relation names; whereas the intensional schema idb(P ) consists of all the intensional ones.	x-1919-4
The schema of P , denoted sch(P ), is the union of edb(P ) and idb(P ).	x-1919-5
The semantics of a datalog program is a mapping from database instances over edb(P ) to database instances over idb(P ).	x-1919-6
In some contexts, we call the input data the extensional database and the program the intensional database.	x-1919-7
Note also that in the context of logic-based languages, the term predicate is often used in place of the term relation name.	x-1919-8
Let us consider an example.	x-1920-1
Example 12.1.3 The following program P metro computes the answers to queries (12.1), (12.2), and (12.3): St _ Reachable(x, x) ← St _ Reachable(x, y) ← St _ Reachable(x, z), Links(u, z, y) Li _ Reachable(x, u) ← St _ Reachable(x, z), Links(u, z, y) Ans _1(y) Observe that St _ Reachable is defined using recursion.	x-1921-1
Clearly, edb(P metro) = { Links}, idb(P metro) = { St _ Reachable, Li _ Reachable, Ans _ 1, Ans _ 2, Ans _ 3} For example, an instantiation of the second rule of P metro is as follows: St _ Reachable( Odeon, Louvre) ← St _ Reachable( Odeon, Chatelet), Links(1, Chatelet, Louvre) Datalog Datalog versus Logic Programming Given the close correspondence between datalog and logic programming, we briefly highlight the central differences between these two fields.	x-1921-2
The major difference is that logic programming permits function symbols, but datalog does not.	x-1921-3
Example 12.1.4 The simple logic program Pleq is given by leq(0, x) ← leq(s(x), s(y)) ← leq(x, y) leq(x, +(x, y)) ← leq(x, z) ← leq(x, y), leq(y, z) Here 0 is a constant, s a unary function sysmbol, + a binary function sysmbol, and leq a binary predicate.	x-1922-1
Intuitively, s might be viewed as the successor function, + as addition, and leq as capturing the less-than-or-equal relation.	x-1922-2
However, in logic programming the function symbols are given the “free” interpretation—two terms are considered nonequal whenever they are syntactically different.	x-1922-3
For example, the terms +(0, s(0)), +(s(0), 0), and s(0) are all nonequal.	x-1922-4
Importantly, functional terms can be used in logic programming to represent intricate data structures, such as lists and trees.	x-1922-5
Observe also that in the preceding program the variable x occurs in the head of the first rule and not in the body, and analogously for the third rule.	x-1923-1
Later in this chapter we present further comparisons of the two frameworks.	x-1924-1
Model-Theoretic Semantics The key idea of the model-theoretic approach is to view the program as a set of first-order sentences (also called a first-order theory) that describes the desired answer.	x-1925-1
Thus the database instance constituting the result satisfies the sentences.	x-1925-2
Such an instance is also called a model of the sentences.	x-1925-3
However, there can be many (indeed, infinitely many) instances satisfying the sentences of a program.	x-1925-4
Thus the sentences themselves do not uniquely identify the answer; it is necessary to specify which of the models is the intended answer.	x-1925-5
This is usually done based on assumptions that are external to the sentences themselves.	x-1925-6
In this section we formalize (1) the relationship between rules and logical sentences, (2) the notion of model, and (3) the concept of intended model.	x-1925-7
We begin by associating logical sentences with rules, as we did in the beginning of this chapter.	x-1926-1
To a datalog rule we associate the logical sentence where x1, .	x-1926-2
.	x-1926-3
.	x-1926-4
, xm are the variables occurring in the rule and ← is the standard logical implication.	x-1926-5
Observe that an instance I satisfies ρ, denoted I |= ρ, if for each instantiation R1(ν(u1)) ← R2(ν(u2)), .	x-1926-6
.	x-1926-7
.	x-1926-8
, Rn(ν(un)) such that R2(ν(u2)), .	x-1926-9
.	x-1926-10
.	x-1926-11
, Rn(ν(un)) belong to I, so does R1(ν(u1)).	x-1926-12
In the following, we do not distinguish between a rule ρ and the associated sentence.	x-1926-13
For a program P , the conjunction of the sentences associated with the rules of P is denoted by P .	x-1926-14
It is useful to note that there are alternative ways to write the sentences associated with rules of programs.	x-1927-1
In particular, the formula is equivalent to	x-1927-2
This last form is particularly interesting.	x-1928-1
Formulas consisting of a disjunction of literals of which at most one is positive are called in logic Horn clauses.	x-1928-2
A datalog program can thus be viewed as a set of (particular) Horn clauses.	x-1928-3
We next discuss the issue of choosing, among the models of P , the particular model that is intended as the answer.	x-1929-1
This is not a hard problem for datalog, although (as we shall see in Chapter 15) it becomes much more involved if datalog is extended with negation.	x-1929-2
For datalog, the idea for choosing the intended model is simply that the model should not contain more facts than necessary for satisfying P .	x-1930-1
So the intended model is minimal in some natural sense.	x-1930-2
This is formalized next.	x-1930-3
Definition 12.2.1 Let P be a datalog program and I an instance over edb(P ).	x-1931-1
A model of P is an instance over sch(P ) satisfying P .	x-1931-2
The semantics of P on input I, denoted P (I), is the minimum model of P containing I, if it exists.	x-1931-3
Datalog Station Line Odeon St.-Michel Chatelet Louvres Palais-Royal Tuileries Concorde Figure 12.2: Relations of P metro(I) For P metro as in Example 12.1.3, and I as in Fig.	x-1932-1
12.1, the values of Ans _1, Ans _2, and Ans _3 in P (I) are shown in Fig.	x-1932-2
12.2.	x-1932-3
We briefly discuss the choice of the minimal model at the end of this section.	x-1933-1
We next provide simple answers to both of these problems.	x-1934-1
Observe that by definition, P (I) is an instance over sch(P ).	x-1935-1
A priori, we must consider all instances over sch(P ), an infinite set.	x-1935-2
It turns out that it suffices to consider only those instances with active domain in adom(P , I) (i.e., a finite set of instances).	x-1935-3
For given P and I, let B(P , I) be the instance over sch(P ) defined by 1.	x-1935-4
For each R in edb(P ), a fact R(u) is in B(P , I) iff it is in I; and 2.	x-1935-5
For each R in idb(P ), each fact R(u) with constants in adom(P , I) is in B(P , I).	x-1935-6
We now verify that B(P , I) is a model of P containing I.	x-1936-1
Lemma 12.2.2 Let P be a datalog program and I an instance over edb(P ).	x-1937-1
Then B(P , I) is a model of P containing I.	x-1937-2
Proof Let A1 ← A2, .	x-1938-1
.	x-1938-2
.	x-1938-3
, An be an instantiation of some rule r in P such that A2, .	x-1938-4
.	x-1938-5
.	x-1938-6
, An hold in B(P , I).	x-1938-7
Then consider A1.	x-1938-8
Because each variable occurring in the head of r also occurs in the body, each constant occurring in A1 belongs to adom(P , I).	x-1938-9
Thus by definition 2 just given, A1 is in B(P , I).	x-1938-10
Hence B(P , I) satisfies the sentence associated with that particular rule, so B(P , I) satisfies P .	x-1938-11
Clearly, B(P , I) contains I by definition 1.	x-1938-12
Thus the semantics of P on input I, if defined, is a subset of B(P , I).	x-1939-1
This means that there is no need to consider instances with constants outside adom(P , I).	x-1939-2
We next demonstrate that P (I) is always defined.	x-1940-1
Theorem 12.2.3 Let P be a datalog program, I an instance over edb(P ), and X the set of models of P containing I.	x-1941-1
Then	x-1941-2
Proof Note that X is nonempty, because B(P , I) is in X .	x-1942-1
Let r ≡ A1 ← A2, .	x-1942-2
.	x-1942-3
.	x-1942-4
, An be a rule in P and ν a valuation of the variables occurring in the rule.	x-1942-5
To prove (1), we show that if ν(A2), .	x-1942-6
.	x-1942-7
.	x-1942-8
, ν(An) are in ∩X then ν(A1) is also in ∩X .	x-1942-9
For suppose that (*) holds.	x-1943-1
Then ∩X |= r, so ∩X satisfies P .	x-1943-2
Because each instance in X contains I, ∩X contains I.	x-1943-3
Hence ∩X is a model of P containing I.	x-1943-4
By construction, ∩X is minimal, so (1) holds.	x-1943-5
To show (*), suppose that ν(A2), .	x-1944-1
.	x-1944-2
.	x-1944-3
, ν(An) are in ∩X and let K be in X .	x-1944-4
Because	x-1944-5
By Lemma 12.2.2, B(P , I) is a model of P containing I.	x-1945-1
Therefore P (I) ⊆ B(P , I).	x-1945-2
Hence	x-1946-1
B(P , I)(R) = I(R); which shows (3).	x-1947-1
The previous development also provides an algorithm for computing the semantics of datalog programs.	x-1948-1
Given P and I, it suffices to consider all instances that are subsets of B(P , I), find those that are models of P and contain I, and compute their intersection.	x-1948-2
However, this is clearly an inefficient procedure.	x-1948-3
The next section provides a more reasonable algorithm.	x-1948-4
We conclude this section with two remarks on the definition of semantics of datalog programs.	x-1949-1
The first explains the choice of a minimal model.	x-1949-2
The second rephrases our definition in more standard logic-programming terminology.	x-1949-3
Why Choose the Minimal Model?	x-1950-1
This choice is the natural consequence of an implicit hypothesis of a philosophical nature: the closed world assumption (CWA) (see Chapter 2).	x-1951-1
The CWA concerns the connection between the database and the world it models.	x-1952-1
Datalog Clearly, databases are often incomplete (i.e., facts that may be true in the world are not necessarily recorded in the database).	x-1953-1
Thus, although we can reasonably assume that a fact recorded in the database is true in the world, it is not clear what we can say about facts not explicitly recorded.	x-1953-2
Should they be considered false, true, or unknown?	x-1953-3
The CWA provides the simplest solution to this problem: Treat the database as if it records complete information about the world (i.e., assume that all facts not in the database are false).	x-1953-4
This is equivalent to taking as true only the facts that must be true in all worlds modeled by the database.	x-1953-5
By extension, this justifies the choice of minimal model as the semantics of a datalog program.	x-1953-6
Indeed, the minimal model consists of the facts we know must be true in all worlds satisfying the sentences (and including the input instance).	x-1953-7
As we shall see, this has an equivalent proof-theoretic counterpart, which will justify the proof-theoretic semantics of datalog programs: Take as true precisely the facts that can be proven true from the input and the sentences corresponding to the datalog program.	x-1953-8
Facts that cannot be proven are therefore considered false.	x-1953-9
Importantly, the CWA is not so simple to use in the presence of negation or disjunction.	x-1954-1
For example, suppose that a database holds {p ∨ q}.	x-1955-1
Under the CWA, then both ¬p and	x-1955-2
Herbrand Interpretation We relate briefly the semantics given to datalog programs to standard logic-programming terminology.	x-1956-1
In logic programming, the facts of an input instance I are not separated from the sentences of a datalog program P .	x-1957-1
Instead, sentences stating that all facts in I are true are included in P .	x-1957-2
This gives rise to a logical theory P, I consisting of the sentences in P	x-1957-3
The semantics is defined as a particular model of this set of sentences.	x-1958-1
A problem is that standard interpretations in first-order logic permit interpretation of constants of the theory with arbitrary elements of the domain.	x-1958-2
For instance, the constants Odeon and St.-Michel may be interpreted by the same element (e.g., John).	x-1958-3
This is clearly not what we mean in the database context.	x-1958-4
We wish to interpret Odeon by Odeon and similarly for all other constants.	x-1958-5
Interpretations that use the identity function to interpret the constant symbols are called Herbrand interpretations (see Chapter 2).	x-1958-6
(If function symbols are present, restrictions are also placed on how terms involving functions are interpreted.)	x-1958-7
Given a set Ŵ of formulas, a Herbrand model of Ŵ is a Herbrand interpretation satisfying Ŵ.	x-1958-8
Thus in logic programming terms, the semantics of a program P given an instance I can be viewed as the minimum Herbrand model of P, I.	x-1959-1
Fixpoint Semantics In this section, we present an operational semantics for datalog programs stemming from fixpoint theory.	x-1960-1
We use an operator called the immediate consequence operator.	x-1960-2
The operator produces new facts starting from known facts.	x-1960-3
We show that the model-theoretic se- mantics, P (I), can also be defined as the smallest solution of a fixpoint equation involving that operator.	x-1960-4
It turns out that this solution can be obtained constructively.	x-1960-5
This approach therefore provides an alternative constructive definition of the semantics of datalog programs.	x-1960-6
It can be viewed as an implementation of the model-theoretic semantics.	x-1960-7
Let P be a datalog program and K an instance over sch(P ).	x-1961-1
A fact A is an immediate consequence for K and P if either A ∈ K(R) for some edb relation R, or A ← A1, .	x-1961-2
.	x-1961-3
.	x-1961-4
, An is an instantiation of a rule in P and each Ai is in K. The immediate consequence operator of P , denoted TP , is the mapping from inst( sch(P )) to inst( sch(P )) defined as follows.	x-1961-5
For each K, TP (K) consists of all facts A that are immediate consequences for K and P .	x-1962-1
We next note some simple mathematical properties of the operator TP over sets of instances.	x-1963-1
We first define two useful properties.	x-1963-2
For an operator T ,	x-1963-3
The proof of the next lemma is straightforward and is omitted (see Exercise 12.9).	x-1964-1
Lemma 12.3.1 Let P be a datalog program.	x-1965-1
It turns out that P (I) (as defined by the model-theoretic semantics) is a fixpoint of TP .	x-1966-1
In particular, it is the minimum fixpoint containing I.	x-1967-1
This is shown next.	x-1967-2
Theorem 12.3.2 For each P and I, TP has a minimum fixpoint containing I, which equals P (I).	x-1968-1
Proof Observe first that P (I) is a fixpoint of TP : In addition, each fixpoint of TP containing I is a model of P and thus contains P (I) (which is the intersection of all models of P containing I).	x-1969-1
Thus P (I) is the minimum fixpoint of P containing I.	x-1969-2
The fixpoint definition of the semantics of P presents the advantage of leading to a constructive definition of P (I).	x-1970-1
In logic programming, this is shown using fixpoint theory (i.e., using Knaster-Tarski’s and Kleene’s theorems).	x-1970-2
However, the database framework is much simpler than the general logic-programming one, primarily due to the lack of function symbols.	x-1970-3
We therefore choose to show the construction directly, without the formidable machinery of the theory of fixpoints in complete lattices.	x-1970-4
In Remark 12.3.5 Datalog we sketch the more standard proof that has the advantage of being applicable to the larger context of logic programming.	x-1970-5
Given an instance I over edb(P ), one can compute TP (I), T 2(I), T 3(I), etc.	x-1971-1
Clearly, P P I ⊆ TP (I) ⊆ T 2 P (I) ⊆ T 3(I) .	x-1971-2
.	x-1971-3
.	x-1971-4
⊆ B(P , I).	x-1971-5
P This follows immediately from the fact that I ⊆ TP (I) and the monotonicity of TP .	x-1972-1
Let N be the number of facts in B(P , I).	x-1972-2
(Observe that N depends on I.)	x-1972-3
The sequence {T i (I)} P i reaches a fixpoint after at most N steps.	x-1972-4
That is, for each i ≥ N , T i (I) = T N (I).	x-1972-5
In P P particular, TP (T N(I)) = T N(I), so T N(I) is a fixpoint of T P P P P .	x-1972-6
We denote this fixpoint by T ω(I).	x-1972-7
P Example 12.3.3 Recall the program PT C for computing the transitive closure of a graph G: T (x, y) ← G(x, y) T (x, y) ← G(x, z), T (z, y).	x-1973-1
Consider the input instance I = {G(1, 2), G(2, 3), G(3, 4), G(4, 5)}.	x-1974-1
Then we have TP (I ) = I ∪ {T (1, 2), T (2, 3), T (3, 4), T (4, 5)} T C T 2 P T C T C T 3 (I ) = T 2 (I ) ∪ {T (1, 4), T (2, 5)} PT C PT C T 4 P T C PT C T 5 (I ) = T 4 (I ).	x-1975-1
PT C PT C Thus T ω (I ) = T 4 (I ).	x-1976-1
PT C PT C We next show that T ω(I) is exactly P (I) for each datalog program P .	x-1977-1
P Theorem 12.3.4 Let P be a datalog program and I an instance over edb(P ).	x-1978-1
Then T ω(I) = P (I).	x-1978-2
P Proof By Theorem 12.3.2, it suffices to show that T ω(I) is the minimum fixpoint of T P P containing I.	x-1979-1
As noted earlier, TP (T ω(I)) = T	x-1979-2
P P (T N P P P where N is the number of facts in B(P , I).	x-1980-1
Therefore T ω(I) is a fixpoint of T P P that con- tains I.	x-1980-2
To show that it is minimal, consider an arbitrary fixpoint J of TP containing I.	x-1981-1
Then J ⊇ T 0(I) = I.	x-1981-2
By induction on i, J ⊇ T i (I) for each i, so J ⊇ T ω(I).	x-1981-3
Thus T ω(I) is the P P P P minimum fixpoint of TP containing I.	x-1981-4
The smallest integer i such that T i (I) = T ω(I) is called the stage for P and I and is P P denoted stage(P , I).	x-1982-1
As already noted, stage(P , I) ≤ N = |B(P , I)|.	x-1982-2
Evaluation The fixpoint approach suggests a straightforward algorithm for the evaluation of datalog.	x-1983-1
We explain the algorithm in an example.	x-1984-1
We extend relational algebra with a while operator that allows us to iterate an algebraic expression while some condition holds.	x-1984-2
(The resulting language is studied extensively in Chapter 17.)	x-1984-3
Consider again the transitive closure query.	x-1985-1
We wish to compute the transitive closure of relation G in relation T .	x-1985-2
Both relations are over AB.	x-1985-3
This computation is performed by the following program: T : = G; while q(T ) = T do T : = q(T ); where q(T ) = G ∪ πAB(δB→C(G) ⊲⊳ δA→C(T )).	x-1985-4
The while construct is needed only for recursion.	x-1986-1
Let us consider again the nonrecursive datalog of Chapter 4.	x-1986-2
Let P be a datalog program.	x-1986-3
Consider the graph ( sch(P ), EP ), where S , S ′ is an edge in EP if S′ occurs in the head of some rule r in P and S occurs in the body of r. Then P is nonrecursive if the graph is acyclic.	x-1986-4
We mentioned already that nr-datalog programs are equivalent to SPJRU queries (see Section 4.5).	x-1986-5
It is also easy to see that, for each nr-datalog program P , there exists a constant d such that for each I over edb(P ), stage(P , I) ≤ d. In other words, the fixpoint is reached after a bounded number of steps, dependent only on the program.	x-1986-6
(See Exercise 12.29.)	x-1986-7
Programs for which this happens are called bounded.	x-1986-8
We examine this property in more detail in Section 12.5.	x-1986-9
Datalog Remark 12.3.5 In this remark, we make a brief excursion into standard fixpoint theory to reprove Theorem 12.3.4.	x-1987-1
This machinery is needed when proving the analog of that theorem in the more general context of logic programming.	x-1987-2
A partially ordered set (U, ≤) is a complete lattice if each subset has a least upper bound and a greatest lower bound, denoted sup and inf , respectively.	x-1987-3
In particular, inf (U ) is denoted ⊥ and sup(U ) is denoted	x-1987-4
To each datalog program P and instance I, we associate the program PI consisting of the rules of P and one rule R(u) ← for each fact R(u) in I.	x-1988-1
We consider the complete lattice formed with ( inst( sch(P )), ⊆) and the operator TP defined by the following: For I each K, a fact A is in TP (K) if A is an immediate consequence for K and P I I.	x-1988-2
The operator TP on ( inst( sch(P )), ⊆) is continuous (so also monotone).	x-1988-3
I The Knaster-Tarski theorem states that a monotone operator in a complete lattice has a least fixpoint that equals inf ({x | x ∈ U, T (x) ≤ x}).	x-1989-1
Thus the least fixpoint of TPI exists.	x-1989-2
Fixpoint theory also provides the constructive definition of the least fixpoint for continuous operators.	x-1989-3
Indeed, Kleene’s theorem states that if T is a continuous operator on a complete lattice, then its least fixpoint is sup({Ki | i ≥ 0}) where K0 = ⊥ and for each i > 0, Ki = T (Ki−1).	x-1989-4
Now in our case, ⊥ = ∅ and I PI coincides with P (I).	x-1989-5
In logic programming, function symbols are also considered (see Example 12.1.4).	x-1990-1
In this context, the sequence of {T i (I)} P i>0 does not generally converge in a finite number I of steps, so the fixpoint evaluation is no longer constructive.	x-1990-2
However, it does converge in countably many steps to the least fixpoint ∪{T i (∅) | i ≥ 0}.	x-1990-3
Thus fixpoint theory is useful PI primarily when dealing with logic programs with function symbols.	x-1990-4
It is an overkill in the simpler context of datalog.	x-1990-5
Proof-Theoretic Approach	x-1991-1
The first step is to define what is meant by proof .	x-1992-1
A proof tree of a fact A from I and P is a labeled tree where	x-1992-2
Such a tree provides a proof of the fact A.	x-1993-1
rule 1 S(1,6) S rule 2 T(1,5) R(5, a,6) T rule 3 R(1, a,2) R(2, b,3) T(3,5) b T R(3, a,4) R(4, a,5) Figure 12.3: Proof tree Example 12.4.1 Consider the following program: S(x1, x3) ← T (x1, x2), R(x2, a, x3) T (x1, x4) ← R(x1, a, x2), R(x2, b, x3), T (x3, x4) T (x1, x3) ← R(x1, a, x2), R(x2, a, x3)	x-1994-1
The reader familiar with context-free languages will notice the similarity between proof trees and derivation trees in context-free languages.	x-1995-1
This connection is especially strong in the case of datalog programs that have the form of the one in Example 12.4.1.	x-1995-2
This will be exploited in the last section of this chapter.	x-1996-1
Proof trees provide proofs of facts.	x-1997-1
It is straightforward to show that a fact A is in P (I) iff there exists a proof tree for A from I and P .	x-1997-2
Now given a fact A to prove, one can look for a proof either bottom up or top down.	x-1997-3
The bottom-up approach is an alternative way of looking at the constructive fixpoint technique.	x-1998-1
One begins with the facts from I and then uses the rules to infer new facts, much like the immediate consequence operator.	x-1998-2
This is done repeatedly until no new facts can be inferred.	x-1998-3
The rules are used as “factories” producing new facts from already proven ones.	x-1998-4
This eventually yields all facts that can be proven and is essentially the same as the fixpoint approach.	x-1999-1
In contrast to the bottom-up and fixpoint approaches, the top-down approach allows one to direct the search for a proof when one is only interested in proving particular facts.	x-2000-1
Datalog For example, suppose the query Ans _1( Louvre) is posed against the program P metro of Example 12.1.3, with the input instance of Fig.	x-2001-1
12.1.	x-2001-2
Then the top-down approach will never consider atoms involving stations on Line 9, intuitively because they are are not reachable from Odeon or Louvre.	x-2001-3
More generally, the top-down approach inhibits the indiscriminate inference of facts that are irrelevant to the facts of interest.	x-2001-4
The top-down approach is described next.	x-2002-1
This takes us to the field of logic programming.	x-2002-2
But first we need some notation, which will remind us once again that “To bar an easy access to newcomers every scientific domain has introduced its own terminology and notation” [Apt91].	x-2002-3
Notation	x-2003-1
where the Ai, Bj are positive literals, is called a clause.	x-2004-1
Such a clause is written in clausal form as	x-2004-2
definite T (x, y) ← R(x, z), T (z, y) T (x, y) ∨ ¬R(x, z) ∨ ¬T (z, y) unit T (x, y) ← T (x, y) goal empty false The empty clause is interpreted as a contradiction.	x-2005-1
Intuitively, this is because it corresponds to the disjunction of an empty set of formulas.	x-2005-2
The top-down proof technique introduced here is called SLD resolution.	x-2006-1
Goals serve as the basic focus of activity in SLD resolution.	x-2006-2
As we shall see, the procedure begins with a goal such as ← St _ Reachable(x, Concorde), Li _ Reachable(x, 9).	x-2006-3
A correct answer of this goal on input I is any value a such that St _ Reachable(a, Concorde) and Li _ Reachable(a, 9) are implied by P metro, I top-down approach consists of obtaining a new goal from a previous goal.	x-2006-4
Finally, the procedure is deemed successful if the final goal reached is empty.	x-2006-5
The standard exposition of SLD resolution is based on definite clauses.	x-2007-1
There is a subtle distinction between datalog rules and definite clauses: For datalog rules, we imposed the restriction that each variable that occurs in the head also appears in the body.	x-2007-2
(In particular, a datalog unit clause must be ground.)	x-2007-3
We will briefly mention some minor consequences of this distinction.	x-2007-4
This ignores the distinction between edb and idb relations, which no longer exists for PI.	x-2008-1
Example 12.4.2 Consider the program P and instance I of Example 12.4.1.	x-2009-1
The rules of PI are Warm-Up Before discussing SLD resolution, as a warm-up we look at a simplified version of the technique by considering only ground rules.	x-2009-2
To this end, consider a datalog program PI (integrating the facts) consisting only of fully instantiated rules (i.e., with no occurrences of variables).	x-2009-3
Consider a ground goal g ≡	x-2009-4
Viewed as logical sentences, the resolvent of g with r is actually implied by g and r.	x-2010-1
This is best seen by writing these explicitly as clauses: Datalog S(1,6) ← T(1,5), R(5, a,6) R(5, a,6) T(1,5) ← R(1, a,2), R(2, b,3), T(3,5) R(5, a,6) T(3,5) ← R(3, a,4), R(4, a,5) R(4, a,5) ← R(5, a,6) ← Figure 12.4: SLD ground refutation	x-2011-1
In general, the converse does not hold.	x-2012-1
g1, .	x-2013-1
.	x-2013-2
.	x-2013-3
, gi, .	x-2013-4
.	x-2013-5
.	x-2013-6
, gq ≡ .	x-2013-7
Example 12.4.3 Consider Example 12.4.1 and the program obtained by all possible instantiations of the rules of PI in Example 12.4.2.	x-2014-1
An SLD ground refutation is shown in Fig.	x-2014-2
12.4.	x-2014-3
It is a refutation of ← S(1, 6) [i.e.	x-2014-4
a proof of S(1, 6)].	x-2014-5
Let us now explain why refutations provide proofs of facts.	x-2015-1
Suppose that we wish to prove A1 ∧ · · · ∧ An.	x-2015-2
To do this we may equivalently prove that its negation (i.e.	x-2015-3
¬A1 ∨	x-2015-4
Example 12.4.4 Continuing with the previous example, to prove S(1, 6), we try to refute its negation [i.e., ¬S(1, 6) or ← S(1, 6)].	x-2016-1
This leads us to considering, in turn, the formulas Goal Rule used	x-2016-2
Thus refutations provide proofs.	x-2017-1
As a consequence, a goal can be thought of as a query.	x-2017-2
Indeed, the arrow is sometimes denoted with a question mark in goals.	x-2018-1
For instance, we sometimes write	x-2018-2
Observe that the process of finding a proof is nondeterministic for two reasons: the choice of the literal A to replace and the rule that is used to replace it.	x-2019-1
We now have a technique for proving facts.	x-2020-1
The benefit of this technique is that it is sound and complete, in the sense that the set of facts in P (I) coincides with the facts that can be proven from PI.	x-2020-2
Theorem 12.4.5 Let PI be a datalog program and ground(PI) be the set of instantiations of rules in PI with values in adom(P , I).	x-2021-1
Then for each ground goal g, PI(∅) |= ¬g iff there exists a refutation of g with ground(PI).	x-2021-2
Crux To show the “only if,” we prove by induction that for each ground goal g, if T i (∅) |= ¬g, PI there exists a refutation of g with ground(PI).	x-2022-1
The base case is obvious.	x-2023-1
Now suppose that (**) holds for some i ≥ 0, and let A1, .	x-2023-2
.	x-2023-3
.	x-2023-4
, Am be ground atoms such that T i+1(∅) |= A P I in T i+1(∅).	x-2023-5
Consider some j .	x-2023-6
If A P j is an edb fact, we are back to the base case.	x-2023-7
Otherwise I Datalog S( x 1, x 3) ← T( x 1, x 2), R( x 2, a, x 3) R( x T( x 1, x 4) ← R( x 1, a, x 2), R( x 2, b, x 3), T( x 3, x 4) R( y T( x R(2, b,3) ← R( x T( x 1, x 3) ← R( x 1, a, x 2), R( x 2, a, x 3) R( z R( x R(4, a,5) ← R(5, a,6) ← Figure 12.5: SLD refutation there exists an instantiation Aj ← B1, .	x-2023-8
.	x-2023-9
.	x-2023-10
, Bp of some rule in PI such that B1, .	x-2023-11
.	x-2023-12
.	x-2023-13
, Bp are in T i (∅).	x-2023-14
The refutation of ← A P j with ground(PI) is as follows.	x-2023-15
It starts with I	x-2023-16
Now by induction there exist refutations of ← Bn, 1 ≤ n ≤ p, with ground(PI).	x-2024-1
Using these refutations, one can extend the preceding derivation to a derivation leading to the empty clause.	x-2024-2
Furthermore, the refutations for each of the Aj ’s can be combined to obtain a refutation of ← A1, .	x-2024-3
.	x-2024-4
.	x-2024-5
, Am as desired.	x-2024-6
Therefore (**) holds for i + 1.	x-2024-7
By induction, (**) holds.	x-2024-8
SLD Resolution The main difference between the general case and the warm-up is that we now handle goals and tuples with variables rather than just ground ones.	x-2025-1
In addition to obtaining the goal , the process determines an instantiation θ for the free variables of the goal g, such that PI(∅) |= ¬θg.	x-2025-2
We start with an example: An SLD refutation of ← S(1, x) is shown in Fig.	x-2025-3
12.5.	x-2025-4
In general, we start with a goal (which does not have to be ground):	x-2026-1
Suppose that we selected a literal to be replaced [e.g., Ai = Q(1, x2, x5)].	x-2027-1
Any rule used for the replacement must have Q for predicate in the head, just as in the ground case.	x-2027-2
For instance, we might try some rule Q(x1, x4, x3) ← P (x1, x2), P (x2, x3), Q(x3, x4, x5).	x-2027-3
We now have two difficulties:	x-2028-1
The first of these two difficulties is handled easily by renaming the variables of the rules.	x-2029-1
We shall use the following renaming discipline: Each time a rule is used, a new set of distinct variables is substituted for the ones in the rule.	x-2030-1
Thus we might use instead the rule Q(x11, x14, x13) ← P (x11, x12), P (x12, x13), Q(x13, x14, x15).	x-2030-2
The second difficulty requires a more careful approach.	x-2031-1
It is tackled using unification, which matches the pattern of the selected literal to that of the head of the rule, if possible.	x-2031-2
In the example, unification consists of finding a substitution θ such that θ (Q(1, x2, x5)) =	x-2032-1
Definition 12.4.6 Let A, B be two atoms.	x-2033-1
A unifier for A and B is a substitution θ such that θ A = θ B.	x-2033-2
A substitution θ is more general than a substitution ν, denoted θ ֒→ ν, if for some substitution ν′, ν = θ ◦ ν′.	x-2033-3
A most general unifier (mgu) for A and B is a unifier θ for A, B such that, for each unifier ν of A, B, we have θ ֒→ ν.	x-2033-4
Clearly, the relation ֒→ between unifiers is reflexive and transitive but not antisymmetric.	x-2034-1
Let ≈ be the equivalence relation on substitutions defined by θ ≈ ν iff θ ֒→ ν and ν ֒→ θ .	x-2034-2
If θ ≈ ν, then for each atom A, θ (A) and ν(A) are the same modulo renaming of variables.	x-2034-3
Datalog Computing the mgu We now develop an algorithm for computing an mgu for two atoms.	x-2035-1
Let R be a relation of arity p and R(x1, .	x-2035-2
.	x-2035-3
.	x-2035-4
, xp), R(y1, .	x-2035-5
.	x-2035-6
.	x-2035-7
, yp) two literals with disjoint sets of variables.	x-2035-8
Compute ≡, the equivalence relation on var ∪ dom defined as the reflexive, transitive closure of: xi ≡ yi for each i in [1, p].	x-2036-1
The mgu of R(x1, .	x-2036-2
.	x-2036-3
.	x-2036-4
, xp) and R(y1, .	x-2036-5
.	x-2036-6
.	x-2036-7
, yp) does not exist if two distinct constants are in the same equivalence class.	x-2036-8
Otherwise their mgu is the substitution θ such that	x-2036-9
We show that the foregoing computes an mgu.	x-2037-1
Lemma 12.4.7 The substitution θ just computed is an mgu for R(x1, .	x-2038-1
.	x-2038-2
.	x-2038-3
, xp) and R(y1, .	x-2038-4
.	x-2038-5
.	x-2038-6
, yp).	x-2038-7
Proof Clearly, θ is a unifier for R(x1, .	x-2039-1
.	x-2039-2
.	x-2039-3
, xp) and R(y1, .	x-2039-4
.	x-2039-5
.	x-2039-6
, yp).	x-2039-7
Suppose ν is another unifier for the same atoms.	x-2039-8
Let ≡ν be the equivalence relation on var ∪ dom defined by x ≡ν y iff ν(x) = ν(y).	x-2039-9
Because ν is a unifier, ν(xi) = ν(yi).	x-2039-10
It follows that xi ≡ν yi, so	x-2039-11
The following facts about mgu’s are important to note.	x-2040-1
Their proof is left to the reader (Exercise 12.19).	x-2040-2
In particular, part (ii) of the lemma says that the mgu of two atoms, if it exists, is essentially unique (modulo renaming of variables).	x-2040-3
Lemma 12.4.8 Let A, B be atoms.	x-2041-1
We are now ready to rephrase the notion of resolvent to incorporate variables.	x-2042-1
Let g ≡← A1, .	x-2042-2
.	x-2042-3
.	x-2042-4
, Ai, .	x-2042-5
.	x-2042-6
.	x-2042-7
, An, r ≡ B1 ← B2, .	x-2042-8
.	x-2042-9
.	x-2042-10
, Bm be a goal and a rule such that	x-2042-11
Then the resolvent of g with r using θ is the goal	x-2043-1
I is an SLD derivation g0 = g, .	x-2044-1
.	x-2044-2
.	x-2044-3
, gq = with PI.	x-2044-4
We now explain the meaning of such a refutation.	x-2045-1
As in the variable-free case, the existence of a refutation of a goal ← A1, .	x-2045-2
.	x-2045-3
.	x-2045-4
, An with PI can be viewed as a proof of the negation of the goal.	x-2045-5
The goal is where x1, .	x-2045-6
.	x-2045-7
.	x-2045-8
, xm are the variables in the goal.	x-2045-9
Its negation is therefore equivalent to	x-2045-10
This is not the case when one allows arbitrary definite clauses rather than datalog rules, as illustrated in the following example.	x-2046-1
Example 12.4.9 Consider the program S(x, z) ← G(x, z) S(x, z) ← G(x, y), S(y, z) S(x, x) ← that computes in S the reflexive transitive closure of graph G. This is a set of definite clauses but not a datalog program because of the last rule.	x-2047-1
However, resolution can be extended to (and is indeed in general presented for) definite clauses.	x-2047-2
Observe, for instance, that the goal	x-2047-3
SLD resolution is a technique that provides proofs of facts.	x-2048-1
One must be sure that it produces only correct proofs (soundness) and that it is powerful enough to prove all Datalog true facts (completeness).	x-2048-2
To conclude this section, we demonstrate the soundness and completeness of SLD resolution for datalog programs.	x-2048-3
We use the following lemma: Lemma 12.4.10 Let g ≡← A1, .	x-2049-1
.	x-2049-2
.	x-2049-3
, Ai, .	x-2049-4
.	x-2049-5
.	x-2049-6
, An and r ≡ B1 ← B2, .	x-2049-7
.	x-2049-8
.	x-2049-9
, Bm be a goal and a rule with no variables in common, and let g′ ≡← A1, .	x-2049-10
.	x-2049-11
.	x-2049-12
, Ai−1, B2, .	x-2049-13
.	x-2049-14
.	x-2049-15
, Bm, Ai+1, .	x-2049-16
.	x-2049-17
.	x-2049-18
, An.	x-2049-19
If θg′ is a resolvent of g with r using θ , then the formula r implies: r′ ≡ ¬θg′ → ¬θg	x-2050-1
Proof Let J be an instance over sch(P ) satisfying r and let valuation ν be such that J |= ν[θ (A1) ∧ · · · ∧ θ(Ai−1) ∧ θ(B2) ∧ · · · ∧ θ(Bm) ∧ θ(Ai+1) ∧ · · · ∧ θ(An)].	x-2051-1
Because J |= ν[θ (B2) ∧ · · · ∧ θ(Bm)]	x-2052-1
Hence for each ν, J |= νr′.	x-2053-1
Therefore J |= r′.	x-2053-2
Thus each instance over sch(P ) satisfying r also satisfies r′, so r implies r′.	x-2053-3
Using this lemma, we have the following: Theorem 12.4.11	x-2054-1
Proof Let J be some instance over sch(P ) satisfying PI.	x-2055-1
Let g0 = g, .	x-2055-2
.	x-2055-3
.	x-2055-4
, gq = be an SLD refutation of g with PI and for each j , let gj be a resolvent of gj−1 with some rule in PI using some mgu θj .	x-2055-5
Then for each j , the rule that is used implies ¬gj → θj (¬gj−1) by Lemma 12.4.10.	x-2055-6
Because J satisfies PI, for each j , J |= ¬gj → θj (¬gj−1).	x-2055-7
Clearly, this implies that for each j , J |= θj+1 ◦ · · · ◦ θq(¬gj ) → θj ◦ · · · ◦ θq(¬gj−1).	x-2056-1
By transitivity, this shows that J |= ¬gq → θ1 ◦ · · · ◦ θq(¬g0), J |= true → θ1 ◦ · · · ◦ θq(¬g).	x-2057-1
Thus J |= θ1 ◦ · · · ◦ θq(A1 ∧ · · · ∧ An).	x-2058-1
We next prove the converse of the previous result (namely, the completeness of SLD resolution).	x-2059-1
Theorem 12.4.12	x-2060-1
Proof Suppose that PI implies ¬g.	x-2061-1
Consider the set ground(PI) of instantiations of rules in PI with constants in adom(P , I).	x-2061-2
Clearly, ground(PI)(∅) is a model of PI, so it satisfies	x-2061-3
Let g0 = θg, .	x-2062-1
.	x-2062-2
.	x-2062-3
, gp = be that refutation.	x-2062-4
We show by induction on k that for each k in [0, p], g, .	x-2062-5
.	x-2062-6
.	x-2062-7
, g′ with for some k PI such that gk = θkg′k	x-2062-8
For suppose that (†) holds for each k. Then for k = p, there exists a derivation g′ = g, .	x-2063-1
.	x-2063-2
.	x-2063-3
, g′ with for some p PI such that	x-2063-4
The basis of the induction holds because g0 = θg = θg′ .	x-2064-1
Now suppose that (†) holds 0 for some k. The next step of the refutation consists of selecting some atom B of gk and applying a rule r in ground(PI).	x-2064-2
In g′ select the atom B′ with location in g′ corresponding k to the location of B in gk.	x-2064-3
Note that B = θkB′.	x-2064-4
In addition, we know that there is rule r′′ = B′′ ← A′′ .	x-2064-5
.	x-2064-6
.	x-2064-7
A′′ in P n I that has r for instantiation via some substitution θ ′′ (such a pair B′, r′′ exists although it may not be unique).	x-2064-8
As usual, we can assume that the variables in g′ are disjoint from those in r′′.	x-2064-9
Let θ k k ⊕ θ ′′ be the substitution defined by k k ⊕ θ ′′(x) = θ ′′(x) if x is a variable in r ′′.	x-2064-10
Clearly, θk ⊕ θ′′(B′) = θk ⊕ θ′′(B′′) = B so, by Lemma 12.4.8 (i), B′ and B′′ have some mgu θ .	x-2065-1
Let g′ be the resolvent of g′ with r′′, B′ using mgu θ .	x-2065-2
By the definition of mgu, k+1 k there exists a substitution θk+1 such that θk ⊕ θ′′ = θ ◦ θk+1.	x-2065-3
Clearly, θk+1(g′ k+1 k+1	x-2065-4
Datalog Infinite no possible derivation subtree Figure 12.6: SLD tree SLD Trees We have shown that SLD resolution is sound and complete.	x-2066-1
Thus it provides an adequate top-down technique for obtaining the facts in the answer to a datalog program.	x-2066-2
To prove that a fact is in the answer, one must search for a refutation of the corresponding goal.	x-2066-3
Clearly, there are many refutations possible.	x-2066-4
There are two sources of nondeterminism in searching for a refutation: (1) the choice of the selected atom, and (2) the choice of the clause to unify with the atom.	x-2066-5
Now let us assume that we have fixed some golden rule, called a selection rule, for choosing which atom to select at each step in a refutation.	x-2066-6
A priori, such a rule may be very simple (e.g., as in Prolog, always take the leftmost atom) or in contrast very involved, taking into account the entire history of the refutation.	x-2066-7
Once an atom has been selected, we can systematically search for all possible unifying rules.	x-2066-8
Such a search can be represented in an SLD tree.	x-2066-9
For instance, consider the tree of Fig.	x-2066-10
12.6 for the program in Example 12.4.2.	x-2066-11
The selected atoms are represented with boxes.	x-2066-12
Edges denote unifications used.	x-2066-13
Given S(1, x), only one rule can be used.	x-2066-14
Given T (1, x2), two rules are applicable that account for the two descendants of vertex T (1, x2).	x-2066-15
The first number in edge labels denotes the rule that is used and the remaining part denotes the substitution.	x-2066-16
An SLD tree is a representation of all the derivations obtained with a fixed selection rule for atoms.	x-2066-17
There are several important observations to be made about this particular SLD tree: (i) It is successful because one branch yields .	x-2067-1
We can now explain (to a certain extent) the acronym SLD.	x-2068-1
SLD stands for selection rule-driven linear resolution for definite clauses.	x-2068-2
Rule-driven refers to the rule used for selecting the atom.	x-2068-3
An important fact is that the success or failure of an SLD tree does not depend on the rule for selecting atoms.	x-2068-4
This explains why the definition of an SLD tree does not specify the selection rule.	x-2068-5
Datalog versus Logic Programming, Revisited Having established the three semantics for datalog, we summarize briefly the main differences between datalog and the more general logic-programming (lp) framework.	x-2069-1
Syntax: Datalog has only relation symbols, whereas lp uses also function symbols.	x-2070-1
Datalog requires variables in rule heads to appear in bodies; in particular, all unit clauses are ground.	x-2070-2
Model-theoretic semantics: Due to the presence of function symbols in lp, models of lp programs may be infinite.	x-2071-1
Datalog programs always have finite models.	x-2071-2
Apart from this distinction, lp and datalog are identical with respect to model-theoretic semantics.	x-2071-3
Fixpoint semantics: Again, the minimum fixpoint of the immediate consequence operator may be infinite in the lp case, whereas it is always finite for datalog.	x-2072-1
Thus the fixpoint approach does not necessarily provide a constructive semantics for lp.	x-2072-2
Proof-theoretic semantics: The technique of SLD resolution is similar for datalog and lp, with the difference that the computation of mgu’s becomes slightly more complicated with function symbols (see Exercise 12.20).	x-2073-1
For datalog, the significance of SLD resolution concerns primarily optimization methods inspired by resolution (such as resolution.	x-2073-2
Thus SLD resolution emerges as the practical alternative.	x-2073-3
Expressive power: A classical result is that lp can express all recursively enumerable (r.e.)	x-2074-1
predicates.	x-2074-2
However, as will be discussed in Part E, the expressive power of datalog lies within ptime.	x-2074-3
Why is there such a disparity?	x-2074-4
A fundamental reason is that function symbols are used in lp, and so an infinite domain of objects can be constructed from a finite set of symbols.	x-2074-5
Speaking technically, the result for lp states that if S is a (possibly infinite) r.e.	x-2074-6
predicate over terms constructed using a finite language, then there is an lp program that produces for some predicate symbol exactly the tuples in S. Speaking intuitively, this follows from the facts that viewed in a bottom-up sense, lp provides composition and looping, and terms of arbitrary length can be used as scratch paper Datalog	x-2074-7
Static Program Analysis In this section, the static analysis of datalog programs is considered.2 As with relational calculus, even simple static properties are undecidable for datalog programs.	x-2075-1
In particular, although tableau homomorphism allowed us to test the equivalence of conjunctive queries, equivalence of datalog programs is undecidable in general.	x-2075-2
This complicates a systematic search for alternative execution plans for datalog queries and yields severe limitations to query optimization.	x-2075-3
It also entails the undecidability of many other problems related to optimization, such as deciding when selection propagation (in the style of “pushing” selections in relational algebra) can be performed, or when parallel evaluation is possible.	x-2075-4
We consider three fundamental static properties: satisfiability, containment, and a new one, boundedness.	x-2076-1
We exhibit a decision procedure for satisfiability.	x-2076-2
Recall that we showed in Chapter 5 that an analogous property is undecidable for CALC.	x-2076-3
The decidability of satisfiability for datalog may therefore be surprising.	x-2076-4
However, one must remember that, although datalog is more powerful than CALC in some respects (it has recursion), it is less powerful in others (there is no negation).	x-2076-5
It is the lack of negation that makes satisfiability decidable for datalog.	x-2076-6
We prove the undecidability of containment and boundedness for datalog programs and consider variations or restrictions that are decidable.	x-2077-1
Satisfiability Let P be a datalog program.	x-2078-1
An intensional relation T is satisfiable by P if there exists an instance I over edb(P ) such that P (I)(T ) is nonempty.	x-2078-2
We give a simple proof of the decidability of satisfiability for datalog programs.	x-2078-3
We will soon see an alternative proof based on context-free languages.	x-2078-4
We first consider constant-free programs.	x-2079-1
We then describe how to reduce the general case to the constant-free one.	x-2079-2
To prove the result, we use an auxiliary result about instance homomorphisms that is of some interest in its own right.	x-2080-1
Note that any mapping θ from dom to dom can be extended to a homomorphism over the set of instances, which we also denote by θ .	x-2080-2
Lemma 12.5.1 Let P be a constant-free datalog program, I, J two instances over sch(P ), q a positive-existential query over sch(P ), and θ a mapping over dom.	x-2081-1
If θ (I) ⊆ J, then (i) θ (q(I)) ⊆ q(J), and (ii) θ (P (I)) ⊆ P (J).	x-2081-2
Proof For (i), observe that q is monotone and that q ◦ θ ⊆ θ ◦ q (which is not necessary if q has constants).	x-2082-1
Because TP can be viewed as a positive-existential query, a straightforward induction proves (ii).	x-2082-2
This result does not hold for datalog programs with constants (see Exercise 12.21).	x-2083-1
Theorem 12.5.2 The satisfiability of an idb relation T by a constant-free datalog program P is decidable.	x-2084-1
Proof Suppose that T is satisfiable by a constant-free datalog program P .	x-2085-1
We prove that P (Ia)(T ) is nonempty for some particular instance Ia.	x-2085-2
Let a be in dom.	x-2085-3
Let Ia be the instance over edb(P ) such that for each R in edb(P ), Ia(R) contains a single tuple with a in each entry.	x-2085-4
Because T is satisfiable by P , there exists I such that P (I)(T ) = ∅.	x-2085-5
Consider the function θ that maps every constant in dom to a.	x-2085-6
Then θ (I) ⊆ Ia.	x-2085-7
By the previous lemma, θ (P (I)) ⊆ P (Ia).	x-2085-8
Therefore P (Ia)(T ) is nonempty.	x-2085-9
Hence T is satisfiable by P iff P (Ia)(T ) = ∅.	x-2085-10
Let us now consider the case of datalog programs with constants.	x-2086-1
Let P be a datalog program with constants.	x-2086-2
For example, suppose that b, c are the only two constants occurring in the program and that R is a binary relation occurring in P .	x-2086-3
We transform the problem into a problem without constants.	x-2086-4
Specifically, we replace R with nine new relations: R⋆⋆, Rb⋆, Rc⋆, R⋆b, R⋆c, Rbc, Rcb, Rbb, Rcc.	x-2086-5
The first one is binary, the next four are unary, and the last four are 0-ary (i.e., are proposi-tions).	x-2087-1
Intuitively, a fact R(x, y) is represented by the fact R⋆⋆(x, y) if x, y are not in {b, c}; R(b, x) with x not in {b, c} is represented by Rb⋆(x), and similarly for Rc⋆, R⋆b, R⋆c.	x-2087-2
The fact R(b, c) is represented by proposition Rbc(), etc.	x-2087-3
Using this kind of transformation for each relation, one translates program P into a constant-free program P ′ such that T is satisfiable by P iff Tw is satisfiable by P ′ for some string w of ⋆ or constants occurring in P .	x-2087-4
Containment Consider two datalog programs P , P ′ with the same extensional relations edb(P ) and a target relation T occurring in both programs.	x-2088-1
We say that P is included in P ′ with respect to T , denoted P ⊆T P ′, if for each instance I over edb(P ), P (I)(T ) ⊆ P ′(I)(T ).	x-2088-2
The containment problem is undecidable.	x-2089-1
We prove this by reduction of the containment problem for context-free languages.	x-2089-2
The technique is interesting because it exhibits a correspondence between proof trees of certain datalog programs and derivation trees of context-free languages.	x-2089-3
Datalog We first illustrate the correspondence in an example.	x-2090-1
Example 12.5.3 Consider the context-free grammar G = (V , , , S), where V = T → abT | aa.	x-2091-1
The corresponding datalog program PG is the program of Example 12.4.1.	x-2092-1
A proof tree and its corresponding derivation tree are shown in Fig.	x-2092-2
12.3.	x-2092-3
We next formalize the correspondence between proof trees and derivation trees.	x-2093-1
denotes the empty string) and	x-2094-1
We use the following: Fact It is undecidable, given (⋆) grammars G1, G2, whether L(G1) ⊆ L(G2).	x-2095-1
For each (⋆) grammar G, let PG, the corresponding datalog program, be constructed (similar to Example 12.5.3) as follows: Let G = (V , , , S).	x-2096-1
We may assume without loss of generality that V is a set of relation names of arity 2 and a set of elements from dom.	x-2096-2
Then idb(PG) = V and edb(PG) = {R}, where R is a ternary relation.	x-2096-3
Let x1, x2, .	x-2096-4
.	x-2096-5
.	x-2096-6
be an infinite sequence of distinct variables.	x-2097-1
To each production in , T → C1 .	x-2097-2
.	x-2097-3
.	x-2097-4
Cn, we associate a datalog rule T (x1, xn+1) ← A1, .	x-2097-5
.	x-2097-6
.	x-2097-7
, An, where for each i	x-2097-8
Note that, for any proof tree of a fact S(a1, an) using PG, the sequence of its leaves is (in this order) R(a1, b1, a2), .	x-2098-1
.	x-2098-2
.	x-2098-3
, R(an−1, bn−1, an), for some a2, .	x-2098-4
.	x-2098-5
.	x-2098-6
, an−1 and b1, .	x-2098-7
.	x-2098-8
.	x-2098-9
, bn−1.	x-2098-10
The connection between derivation trees of G and proof trees of PG is shown in the following.	x-2098-11
Proposition 12.5.4 Let G be a (⋆) grammar and PG be the associated datalog pro- gram constructed as just shown.	x-2099-1
For each a1, .	x-2099-2
.	x-2099-3
.	x-2099-4
, an, b1, .	x-2099-5
.	x-2099-6
.	x-2099-7
, bn−1, there is a proof tree of S(a1, an) from PG with leaves R(a1, b1, a2), .	x-2099-8
.	x-2099-9
.	x-2099-10
, R(an−1, bn−1, an) (in this order) iff b1 .	x-2099-11
.	x-2099-12
.	x-2099-13
bn−1 is in L(G).	x-2099-14
The proof of the proposition is left as Exercise 12.25.	x-2100-1
Now we can show the following: Theorem 12.5.5 It is undecidable, given P , P ′ (with edb(P ) = edb(P ′)) and T , whether P ⊆T P ′.	x-2100-2
Proof It suffices to show that for each pair G1, G2 of (⋆) grammars, L(G1) ⊆ L(G2) ⇔ PG ⊆	x-2101-1
S PG2 Suppose (‡) holds and T containment is decidable.	x-2102-1
Then we obtain an algorithm to decide containment of (⋆) grammars, which contradicts the aforementioned fact.	x-2102-2
Let G2, G2 be two (⋆) grammars.	x-2103-1
We show here that L(G1) ⊆ L(G2) ⇒ PG ⊆	x-2103-2
S PG2 S(a1, an) be in PG (I).	x-2104-1
Then there exists a proof tree of S(a and I, with leaves labeled by facts R(a1, b1, a2), .	x-2104-2
.	x-2104-3
.	x-2104-4
, R(an−1, bn−1, an), in this order.	x-2104-5
By Proposition 12.5.4, b1 .	x-2104-6
.	x-2104-7
.	x-2104-8
bn−1 is in L(G1).	x-2104-9
Because L(G1) ⊆ L(G2), b1 .	x-2104-10
.	x-2104-11
.	x-2104-12
bn−1 is in L(G2).	x-2104-13
By the proposition again, there is a proof tree of S(a1, an) from PG2 with leaves R(a1, b1, a2), .	x-2104-14
.	x-2104-15
.	x-2104-16
, R(an−1, bn−1, an), all of which are facts in I.	x-2104-17
Thus S(a1, an) is in PG (I), so P	x-2104-18
G1 S PG2 Note that the datalog programs used in the preceding construction are very particular: They are essentially chain programs.	x-2105-1
Intuitively, in a chain program the variables in a rule body form a chain.	x-2105-2
More precisely, rules in chain programs are of the form A0(x0, xn) ← A1(x0, x1), A2(x1, x2), .	x-2105-3
.	x-2105-4
.	x-2105-5
, An(xn−1, xn).	x-2105-6
The preceding proof can be tightened to show that containment is undecidable even for chain programs (see Exercise 12.26).	x-2106-1
The connection with grammars can also be used to provide an alternate proof of the decidability of satisfiability; satisfiability can be reduced to the emptiness problem for context-free languages (see Exercise 12.22c).	x-2107-1
Datalog set of intensional and extensional relations, we say that P is uniformly contained in P ′, denoted P ⊆ P ′, iff for each I over sch(P ), P (I) ⊆ P ′(I).	x-2108-1
Uniform containment is a sufficient condition for containment.	x-2108-2
Interestingly, one can decide uniform containment.	x-2108-3
The test for uniform containment uses dependencies studied in Part D and the fundamental chase technique (see Exercises 12.27 and 12.28).	x-2109-1
Boundedness	x-2110-1
Example 12.5.6 Consider the following two-rule program: Buys( x, y) ← Trendy(x), Buys( z, y) Buys( x, y) ← Likes( x, y) This program is bounded because Buys(z,y) can be replaced in the body by Likes(z,y), yielding an equivalent recursion-free program.	x-2111-1
On the other hand, the program Buys( x, y) ← Knows( x, z), Buys( z, y) Buys( x, y) ← Likes( x, y) is inherently recursive (i.e., is not equivalent to any recursion-free program).	x-2111-2
It is important to distinguish truly recursive programs from falsely recursive (bounded) programs.	x-2112-1
Unfortunately, boundedness cannot be tested.	x-2112-2
Theorem 12.5.7 Boundedness is undecidable for datalog programs.	x-2113-1
The proof is by reduction of the PCP (see Chapter 2).	x-2114-1
One can even show that boundedness remains undecidable under strong restrictions, such as that the programs that are considered (1) are constant-free, (2) contain a unique recursive rule, or (3) contain a unique intensional relation.	x-2114-2
Decidability results have been obtained for linear programs or chain-rule programs (see Exercise 12.31).	x-2114-3
Bibliographic Notes It is difficult to attribute datalog to particular researchers because it is a restriction or extension of many previously proposed languages; some of the early history is discussed in [MW88a].	x-2115-1
The name datalog was coined (to our knowledge) by David Maier.	x-2115-2
Bibliographic Notes Many particular classes of datalog programs have been investigated.	x-2116-1
Examples are the class of monadic programs (all intensional relations have arity one), the class of linear programs (in the body of each rule of these programs, there can be at most one relation that is mutually recursive with the head relation; see Chapter 13), the class of chain programs	x-2116-2
The fixpoint semantics that we considered in this chapter is due to [CH85].	x-2117-1
However, it has been considered much earlier in the context of logic programming [vEK76, AvE82].	x-2117-2
For logic programming, the existence of a least fixpoint is proved using [Tar55].	x-2118-1
The study of stage functions stage(d, H ) is a major topic in [Mos74], where they are defined for finite structures (i.e., instances) as well as for infinite structures.	x-2119-1
Resolution was originally proposed in the context of automatic theorem proving.	x-2120-1
Its foundations are due to Robinson [Rob65].	x-2120-2
SLD resolution was developed in [vEK76].	x-2120-3
These form the basis of logic programming introduced by Kowalski [Kow74] and	x-2121-1
The programming language Prolog proposed by Colmerauer [CKRP73] is based on SLD resolution.	x-2122-1
It uses a particular strategy for searching for SLD refutations.	x-2122-2
Various ways to couple Prolog with a relational database system have been considered (see	x-2122-3
The undecidability of containment is studied in [CGKV88, Shm87].	x-2123-1
The decidability of uniform containment is shown in [CK86, Sag88].	x-2123-2
The decidability of containment for monadic programs is studied in [CGKV88].	x-2123-3
The equivalence of recursive and nonrecursive datalog programs is shown to be decidable in [CV92].	x-2123-4
The complexity of this problem is considered in [CV94].	x-2123-5
Interestingly, bounded recursion is defined and used early in the context of universal relations [MUV84].	x-2124-1
Example 12.5.6 is from [Nau86].	x-2124-2
Undecidability results for boundedness of various datalog classes are shown in [GMSV87, GMSV93, Var88, Abi89].	x-2124-3
Decidability results for particular subclasses are demonstrated in [Ioa85, Nau86, CGKV88, NS87, Var88].	x-2124-4
Boundedness implies that the query expressed by the program is a positive existential query and therefore is expressible in CALC (over finite inputs).	x-2125-1
What about the converse?	x-2125-2
If infinite inputs are allowed, then (by a compactness argument) unboundedness implies nonexpressibility by CALC.	x-2126-1
But in the finite (database) case, compactness does not hold, and the question remained open for some time.	x-2126-2
Kolaitis observed that unboundedness does not imply nonexpressibility by CALC over finite structures for datalog with inequalities (x = y).	x-2126-3
(We did not consider comparators =, <, ≤, etc.	x-2126-4
in this chapter.)	x-2126-5
The question was settled by Ajtai and Gurevich [AG89], who showed by an elegant argument that no unbounded datalog program is expressible in CALC, even on finite structures.	x-2126-6
Datalog set of fd’s on edb(P ), and set Ŵ of fd’s on idb(P ) whether P (I) |= Ŵ whenever I |=	x-2127-1
The expressive power of datalog has been investigated in [AC89, ACY91, CH85, Shm87, LM89, KV90c].	x-2128-1
Clearly, datalog expresses only monotonic queries, commutes with homomorphisms of the database (if there are no constants in the program), and can be evaluated in polynomial time (see also Exercise 12.11).	x-2128-2
It is natural to wonder if datalog expresses precisely those queries.	x-2128-3
The answer is negative.	x-2128-4
Indeed, [ACY91] shows that the existence of a path whose length is a perfect square between two nodes is not expressible in datalog= (datalog augmented with inequalities x = y), and so not in datalog.	x-2128-5
This is a monotonic, polynomial-time query commuting with homomorphisms.	x-2128-6
The parallel complexity of datalog is surveyed in [Kan88].	x-2128-7
The function symbols used in logic programming are interpreted over a Herbrand domain and are prohibited in datalog.	x-2129-1
However, it is interesting to incorporate arithmetic functions such as addition and multiplication into datalog.	x-2129-2
Such functions can also be viewed as infinite base relations.	x-2129-3
If these are present, it is possible that the bottom-up evaluation of a datalog program will not terminate.	x-2129-4
This issue was first studied in [RBS87], where finiteness dependencies were introduced.	x-2129-5
These dependencies can be used to describe how the finiteness of the range of a set of variables can imply the finiteness of the range of another variable.	x-2129-6
[For example, the relation +(x, y, z) satisfies the finiteness dependencies {x, y} ❀ {z}, {x, z} ❀ {y}, and {y, z} ❀ {x}.]	x-2129-7
Safety of datalog programs with infinite relations constrained by finiteness dependencies is undecidable [SV89].	x-2129-8
Various syntactic conditions on datalog programs that ensure safety are developed in [RBS87, KRS88a, KRS88b, SV89].	x-2129-9
Finiteness dependencies were used to develop a safety condition for the relational calculus with infinite base relations in [EHJ93].	x-2129-10
Safety was also considered in the context of data functions (i.e., functions whose extent is predefined).	x-2129-11
Exercises Exercise 12.1 Refer to the Parisian Metro database.	x-2130-1
Give a datalog program that yields, for each pair of stations (a, b), the stations c such that c is reachable (1) from both a and b; and (2) from a or b.	x-2130-2
Exercise 12.2 Consider a database consisting of the Metro and Cinema databases, plus a relation Theater-Station giving for each theater the closest metro station.	x-2131-1
Suppose that you live near the Odeon metro station.	x-2131-2
Write a program that answers the query “Near which metro station can I see a Bergman movie?” (Having spent many years in Los Angeles, you do not like walking, so your only option is to take the metro at Odeon and get off at the station closest to the theater.)	x-2131-3
Exercise 12.3	x-2131-4
Exercise 12.4 We are given two directed graphs G black and G white over the same set V of vertexes, represented as binary relations.	x-2132-1
Write a datalog program P that computes the set of pairs (a, b) of vertexes such that there exists a path from a to b where black and white edges alternate, starting with a white edge.	x-2132-2
Exercises Exercise 12.5 Suppose we are given an undirected graph with colored vertexes represented by a binary relation Color giving the colors of vertexes and a binary relation Edge giving the connection between them.	x-2133-1
(Although Edge provides directed edges, we ignore the direction, so we treat the graph as undirected.)	x-2133-2
Say that a vertex is good if it is connected to a blue vertex (blue is a constant) or if it is connected to an excellent vertex.	x-2133-3
An excellent vertex is a vertex that is connected to an outstanding vertex and to a red vertex.	x-2133-4
An outstanding vertex is a vertex that is connected to a good vertex, an excellent one, and a yellow one.	x-2133-5
Write a datalog program that computes the excellent vertexes.	x-2133-6
Exercise 12.6 Consider a directed graph G represented as a binary relation.	x-2134-1
Show a datalog program that computes a binary relation T containing the pairs (a, b) for which there is a path of odd length from a to b in G.	x-2134-2
Exercise 12.7 Given a directed graph G represented as a binary relation, write a datalog program that computes the vertexes x such that (1) there exists a cycle of even length passing through x; (2) there is a cycle of odd length through x; (3) there are even- and odd-length cycles through x.	x-2135-1
Exercise 12.8 Consider the following program P : R(x, y) ← Q(y, x), S(x, y) S(x, y) ← Q(x, y), T (x, z) T (x, y) ← Q(x, z), S(z, y) Let I be a relation over edb(P ).	x-2136-1
Describe the output of the program.	x-2136-2
Now suppose the first rule is replaced by R(x, y) ← Q(y, x).	x-2136-3
Describe the output of the new program.	x-2136-4
Exercise 12.9 Prove Lemma 12.3.1.	x-2137-1
Exercise 12.10 Prove that datalog queries are monotone.	x-2138-1
Exercise 12.11 Suppose P is some property of graphs definable by a datalog program.	x-2139-1
Show that P is preserved under extensions and homomorphisms.	x-2139-2
That is, if G is a graph satisfying P , then (1) every supergraph of G satisfies P and (2) if h is a graph homomorphism, then h(G) satisfies P .	x-2139-3
Exercise 12.12 Show that the following graph properties are not definable by datalog programs:	x-2140-1
Show that nontrivial cycles can be detected if inequalities of the form x = y are allowed in rule bodies.	x-2141-1
Hint: For (ii), consider “words” consisting of simple paths from a to b, and prove a pumping lemma for words “accepted” by datalog programs.	x-2142-1
Datalog Exercise 12.14 Present an algorithm that, given the set of proof trees of depth i with a program P and instance I, constructs all proof trees of depth i + 1.	x-2143-1
Make sure that your algorithm terminates.	x-2143-2
Exercise 12.15 Let P be a datalog program, I an instance of edb(P ), and R in idb(P ).	x-2144-1
Let u be a vector of distinct variables of the arity of R. Demonstrate that P (I)(R) = {θ R(u) | there is a refutation of ← R(u) using PI and substitutions θ1, .	x-2144-2
.	x-2144-3
.	x-2144-4
θn such that θ = θ1 ◦ · · · ◦ θn}.	x-2144-5
Exercise 12.16	x-2145-1
Exercise 12.17 Reprove Theorem 12.3.4 using Tarski’s and Kleene’s theorems stated in Remark 12.3.5.	x-2146-1
Exercise 12.18 Prove the “if part” of Theorem 12.4.5.	x-2147-1
Exercise 12.19 Prove Lemma 12.4.8.	x-2148-1
For example, f (g(x, 5), y, f (y, x, x)) is a term.	x-2149-1
In this context, a substitution θ is a mapping from a subset of var into the set of terms.	x-2149-2
Given a substitution θ , it is extended in the natural manner to include all terms constructed over the domain of θ .	x-2149-3
Extend the definitions of unifier and mgu to terms and to atoms permitting terms.	x-2149-4
Give an algorithm to obtain the mgu of two atoms.	x-2149-5
Exercise 12.21 Prove that Lemma 12.5.1 does not generalize to datalog programs with constants.	x-2150-1
Exercise 12.22 This exercise develops three alternative proofs of the generalization of Theorem 12.5.2 to datalog programs with constants.	x-2151-1
Prove the generalization by (a) using the technique outlined just after the statement of the theorem (b) making a direct proof using as input an instance IC∪{a}, where C is the set of all constants occurring in the program and a is new, and where each relation in I contains all tuples constructed using C ∪ {a}	x-2151-2
Exercise 12.25 Prove Proposition 12.5.4.	x-2152-1
Exercises Exercise 12.26 Prove that containment of chain datalog programs is undecidable.	x-2153-1
Hint: Modify the proof of Theorem 12.5.5 by using, for each b ∈ , a relation Rb such that Rb(x, y) iff R(x, b, y).	x-2153-2
Exercise 12.27 Prove that containment does not imply uniform containment by exhibiting two programs P , Q over the same edb’s and with S as common idb such that P ⊆S Q but P ⊆ Q.	x-2154-1
Exercise 12.29 Prove that each nr-datalog program is bounded.	x-2155-1
Exercise 12.31	x-2156-1
R(x) ← R(y), R(z), S(x, y, z) is complete in ptime.	x-2157-1
(This has been called variously the graph accessibility problem and the blue-blooded water buffalo problem; a water buffalo is blue blooded only if both of its parents are.)	x-2157-2
R(x) ← R(y), R(z), T (y, x), T (x, z) is complete in ptime.	x-2158-1
Datalog Show that the positive first order extended with generalized transitive closure is in logspace.	x-2159-1
I don’t mean to sound naive, but isn’t it awfully expensive to answer datalog queries?	x-2160-1
Riccardo: Not if you use the right bag of tricks .	x-2161-1
.	x-2161-2
.	x-2161-3
Vittorio:	x-2162-1
Sergio: Well, there is no real need for magic.	x-2163-1
We will see that the evaluation is much easier if the algorithm knows where it is going and takes advantage of this knowledge.	x-2163-2
The introduction of datalog led to a flurry of research in optimization during the late 1980s and early 1990s.	x-2164-1
A variety of techniques emerged covering a range of different approaches.	x-2164-2
These techniques are usually separated into two classes depending on whether they focus on top-down or bottom-up evaluation.	x-2164-3
Another key dimension of the techniques concerns whether they are based on direct evaluation or propose some compilation of the query into a related query, which is subsequently evaluated using a direct technique.	x-2164-4
This chapter provides a brief introduction to this broad family of heuristic techniques.	x-2165-1
The advantage of top-down techniques is that selections that form part of the initial query can be propagated into the rules as they are expanded.	x-2166-1
There is no direct way to take advantage of this information in bottom-up evaluation, so it would seem that the bottom-up technique is at a disadvantage with respect to optimization.	x-2166-2
A rather elegant conclusion that has emerged from the research on datalog evaluation is that, surprisingly, there are bottom-up techniques that have essentially the same running time as top-down techniques.	x-2166-3
Exposition of this result is a main focus of this chapter.	x-2167-1
Some of the evaluation techniques presented here are intricate, and our main emphasis is on conveying the essential ideas they use.	x-2168-1
The discussion is centered around the presentation of the techniques in connection with a concrete running example.	x-2168-2
In the cases of Query-Subquery and magic sets rewriting, we also informally describe how they can be applied in the general case.	x-2168-3
This is sufficient to give a precise understanding of the techniques without becoming overwhelmed by notation.	x-2168-4
Proofs of the correctness of these techniques are typically lengthy but straightforward and are left as exercises.	x-2168-5
Evaluation of Datalog f up flat down f f e g f l f l m n o p f m n m f d d u u u u u d f m m o g b g n p m h c e f g h i j k f h n i d i o p k u u d d d j o b c d Figure 13.1: Instance I0 for RSG example Seminaive Evaluation The first stop on our tour of evaluation techniques is a strategy for improving the efficiency of the bottom-up technique described in Chapter 12.	x-2169-1
To illustrate this and the other techniques, we use as a running example the program “Reverse-Same-Generation” (RSG) given by rsg(x, y) ← flat(x, y) rsg(x, y) ← up(x, x1), rsg(y1, x1), down(y1, y) and the sample instance I0 illustrated in Fig.	x-2169-2
13.1.	x-2169-3
This is a fairly simple program, but it will allow us to present the main features of the various techniques presented throughout this chapter.	x-2169-4
If the bottom-up algorithm of Chapter 12 is used to compute the value of rsg on input I0, the following values are obtained: level 0: level 1: level 2: level 3: level 4:	x-2170-1
This algorithm has been termed the naive algorithm for datalog evaluation.	x-2171-1
The central idea of the seminaive algorithm is to focus, to the extent possible, on the new facts generated at each level and thereby avoid recomputing the same facts.	x-2171-2
Consider the facts inferred using the second rule of RSG in the consecutive stages of the naive evaluation.	x-2172-1
At each stage, some new facts are inferred (until a fixpoint is reached).	x-2172-2
To infer a new fact at stage i + 1, one must use at least one fact newly derived at stage i.	x-2173-1
This is the main idea of seminaive evaluation.	x-2174-1
It is captured by the following “version” of RSG, called RSG′: rsg (x, y) ← up(x, x1), .i rsg(y1, x1), down(y1, y) where an instance of the second rule is included for each i ≥ 1.	x-2174-2
Strictly speaking, this is not a datalog program because it has an infinite number of rules.	x-2174-3
On the other hand, it is not recursive.	x-2174-4
Intuitively, .i contains the facts in rsg rsg newly inferred at the ith stage of the naive evaluation.	x-2175-1
To see this, we note a close relationship between the repeated applications of T RSG and the values taken by the .i .	x-2175-2
Let I be a fixed input instance.	x-2175-3
Then rsg RSG RSG on I); and when rsg RSG′(I)(.i rsg) (i.e., the value of .i rsg T RSG′ reaches a fixpoint on I).	x-2175-4
It is easily verified for each i ≥ 1 that T i−1 RSG′(I)(.i rsg) = ∅ and T i RSG′(I)(.i rsg) = δi rsg thermore, for each i ≥ 0 we have rsg i+1 − rsg i ⊆ δi+1 ⊆ rsg rsg i+1.	x-2176-1
Therefore RSG j rsg).	x-2177-1
Furthermore, if j satisfies δ rsg ⊆ ∪i<j δi rsg then RSG(I)( rsg) = ∪i<j δi , that is, only rsg j levels of RSG′ need be computed to find RSG(I)( rsg).	x-2177-2
Importantly, bottom-up evaluation of RSG′ typically involves much less redundant computation than direct bottom-up evaluation of RSG.	x-2177-3
Continuing with the informal development, we introduce now two refinements that further reduce the amount of redundant computation.	x-2178-1
The first is based on the observation that when executing RSG′, we do not always have δi+1 = rsg rsg i+1 − rsg i.	x-2178-2
Using I0, we have g, f ∈ δ2 but not in rsg rsg 2 − rsg 1.	x-2178-3
This suggests that the efficiency can be further improved by using rsg i − rsg i−1 in place of .i in the body of the second “rule” of RSG′.	x-2178-4
rsg Using a pidgin language that combines both datalog and imperative commands, the new version RSG′′ is given by	x-2179-1
rsg(x, y) flat(x, y) rsg 1 rsg (x, y) up(x, x1), .i rsg(y1, x1), down(y1, y)  rsg temp i+1 rsg rsg i rsg i ∪ .i+1 rsg	x-2180-1
Evaluation of Datalog The second improvement to reduce redundant computation is useful when a given idb predicate occurs twice in the same rule.	x-2181-1
To illustrate, consider the nonlinear version of the ancestor program:	x-2181-2
par(x, y) temp i+1 − anc i Note here that both .i	x-2182-1
Consider now an input instance consisting of par(1, 2), par(2, 3).	x-2183-1
Then we have Furthermore, both of the rules for temp 2 will compute the join of tuples 1	x-2183-2
temp i+1(x, y) ← .i anc(x, z), anc i−1(z, y) temp i+1(x, y) ← anc i(x, z), .i anc(z, y) This approach is adopted below.	x-2184-1
We now present the seminaive algorithm for the general case.	x-2185-1
Let P be a datalog program over edb R and idb T. Consider a rule S(u) ← R1(v1), .	x-2185-2
.	x-2185-3
.	x-2185-4
, Rn(vn), T1(w1), .	x-2185-5
.	x-2185-6
.	x-2185-7
, Tm(wm) in P , where the Rk’s are edb predicates and the Tj ’s are idb predicates.	x-2185-8
Construct for each j ∈ [1, m] and i ≥ 1 the rule temp i+1(u) ← R S T i1(w1), .	x-2185-9
.	x-2185-10
.	x-2185-11
, T i j −1(wj −1), .iT j ), T i−1 j +1), .	x-2185-12
.	x-2185-13
.	x-2185-14
, T i−1 j j +1 m	x-2185-15
Let P i represent the set of all i-level rules of this form constructed for the idb predicate S S	x-2186-1
S Suppose now that T1, .	x-2187-1
.	x-2187-2
.	x-2187-3
, Tl is a listing of the idb predicates of P that occur in the body of a rule defining S. We write P i (I, T i−1, .	x-2187-4
.	x-2187-5
.	x-2187-6
, T i−1, T i S l l T1 Tl to denote the set of tuples that result from applying the rules in P i to given values for input S instance I and for the T i−1, T i, and .i .	x-2187-7
j j Tj We now have the following: Input: Datalog program P and input instance I Output: P (I) S for each idb predicate S, where T1, .	x-2188-1
.	x-2188-2
.	x-2188-3
, Tl begin Si := Si−1 ∪ .i ; S S l l T1 Tl end; i := i + 1 end until .i = ∅ for each idb predicate S.	x-2188-4
S	x-2189-1
The correctness of this algorithm is demonstrated in Exercise 13.3.	x-2190-1
However, it is still doing a lot of unnecessary work on some programs.	x-2190-2
We now analyze the structure of datalog programs to develop an improved version of the seminaive algorithm.	x-2190-3
It turns out that this analysis, with simple control of the computation, allows us to know in advance which predicates are likely to grow at each iteration and which are not, either because they are already saturated or because they are not yet affected by the computation.	x-2190-4
Let P be a datalog program.	x-2191-1
Form the precedence graph GP for P as follows: Use the idb predicates in P as the nodes and include edge (R, R′) if there is a rule with head predicate R′ in which R occurs in the body.	x-2191-2
P is recursive if GP has a directed cycle.	x-2191-3
Two predicates R and R′ are mutually recursive if R = R′ or R and R′ participate in the same Evaluation of Datalog cycle of GP.	x-2191-4
Mutual recursion is an equivalence relation on the idb predicates of P , where each equivalence class corresponds to a strongly connected component of GP.	x-2191-5
A rule of P is recursive if the body involves a predicate that is mutually recursive with the head.	x-2191-6
We now have the following: Input: Datalog program P and edb instance I Output: P (I)	x-2192-1
The correctness of this algorithm is left as Exercise 13.4.	x-2193-1
Linear Datalog We conclude this discussion of the seminaive approach by introducing a special class of programs.	x-2194-1
Let P be a program.	x-2195-1
A rule in P with head relation R is linear if there is at most one atom in the body of the rule whose predicate is mutually recursive with R. P is linear if each rule in P is linear.	x-2195-2
We now show how the Improved Seminaive Algorithm can be simplified for such programs.	x-2195-3
Suppose that P is a linear program, and is a rule in P , where Tj is mutually recursive with R. Associate with this the “rule” R j ), .	x-2196-1
.	x-2196-2
.	x-2196-3
, Tn(vn).	x-2196-4
j Note that this is the only rule that will be associated by the Improved Seminaive Algorithm with ρ.	x-2197-1
Thus, given an equivalence class [Tk] of mutually recursive predicates of P , the rules for predicates S in [Tk] use only the .i , but not the Si.	x-2197-2
In contrast, as seen earlier, S both the .i and Si must be used in nonlinear programs.	x-2197-3
S Top-Down Techniques Consider the RSG program from the previous section, augmented with a selection-based query: rsg(x, y) ← flat(x, y) rsg(x, y) ← up(x, x1), rsg(y1, x1), down(y1, y) query(y) ← rsg(a, y) where a is a constant.	x-2198-1
This program will be called the RSG query.	x-2198-2
Suppose that seminaive evaluation is used.	x-2198-3
Then each pair of rsg will be produced, including those that are not used to derive any element of query.	x-2198-4
For example, using I0 of Fig.	x-2198-5
13.1 as input, fact rsg(f, k) will be produced but not used.	x-2198-6
A primary motivation for the top-down approaches to datalog query evaluation is to avoid, to the extent possible, the production of tuples that are not needed to derive any answer tuples.	x-2198-7
For this discussion, we define a datalog query to be a pair (P , q), where P is a datalog program and q is a datalog rule using relations of P in its body and the new relation query in its head.	x-2199-1
We generally assume that there is only one rule defining the predicate query, and it has the form query(u) ← R(v) for some idb predicate R.	x-2199-2
The top-down approaches use natural heuristics to focus attention on relevant facts.	x-2200-1
In particular, they use the framework provided by SLD resolution.	x-2200-2
The starting point for these algorithms (namely, the query to be answered) often includes constants; these have the effect of restricting the search for derivation trees and thus the set of facts produced.	x-2200-3
In the context of databases without function symbols, the top-down datalog evaluation algorithms can generally be forced to terminate on all inputs, even when the corresponding SLD-resolution algorithm does not.	x-2200-4
In this section, we focus primarily on the query-subquery (QSQ) framework.	x-2200-5
There are four basic elements of this framework:	x-2201-1
Recall the RSG query given earlier.	x-2202-1
Consider an SLD tree for it.	x-2202-2
The child of the root would be rsg(a, y).	x-2202-3
Speaking intuitively, not all values for rsg are requested, but rather only those Evaluation of Datalog with first coordinate a.	x-2202-4
More generally, we are interested in finding derivations for rsg where the first coordinate is bound and the second coordinate is free.	x-2202-5
This is denoted by the expression rsg bf , where the superscript ‘bf ’ is called an adornment.	x-2202-6
The next layer of the SLD tree will have a node holding flat(a, y) and a node holding up(a, x1), rsg(y1, x1), down(y1, y).	x-2203-1
Answers generated for the first of these nodes are given by π2(σ1 = ‘a’( flat)).	x-2203-2
Answers for the other node can be generated by a left-to-right evaluation.	x-2203-3
First the set of possible values for x1 is J = π2(σ1 = ‘a’( up)).	x-2203-4
Next the possible values for y1 are given by {y1 | y1, x1 ∈ rsg and x1 ∈ J } (i.e., the first coordinate values of rsg stemming from second coordinate values in J ).	x-2203-5
More generally, then, this calls for an evaluation of rsg f b, where the second coordinate values are bound by J .	x-2203-6
Finally, given y1 values, these can be used with down to obtain y values (i.e., answers to the query).	x-2204-1
query were applied to the instance of Fig.	x-2205-1
13.1, the first subquery generated would be ( rsg f b, {e, f }).	x-2205-2
As we shall see, the QSQ framework is based on a systematic evaluation of subqueries.	x-2205-3
Let P be a datalog program and I an input instance.	x-2206-1
Suppose that R is an idb predicate and γ is an adornment for R (i.e., a string of b’s and f ’s having length the arity of R).	x-2206-2
Then bound(R, γ ) denotes the coordinates of R bound in γ .	x-2206-3
Let t be a tuple over bound(R, γ ).	x-2206-4
Then a completion for t in Rγ is a tuple s such that s[ bound(R, γ )] = t and s ∈ P (I)(R).	x-2207-1
The answer to a subquery (Rγ , J ) over I is the set of all completions of all tuples in J .	x-2208-1
The use of adornments within a rule body is a generalization of the technique of sideways information passing discussed in Chapter 6.	x-2209-1
Consider the rule (*) R(x, y, z) ← R1(x, u, v), R2(u, w, w, z), R3(v, w, y, a).	x-2209-2
Suppose that a subquery involving R bfb is invoked.	x-2210-1
Assuming a left-to-right evaluation, this will lead to subqueries involving bff bffb bbfb R bff bffb bbfb R bfb(x, y, z) ← R to emphasize the adornments.	x-2210-2
This is an example of an adorned rule.	x-2210-3
As we shall see, the adornments of idb predicates in rule bodies shall be used to guide evaluations of queries and subqueries.	x-2210-4
It is common to omit the adornments of edb predicates.	x-2210-5
The general algorithm for adorning a rule, given an adornment for the head and an ordering of the rule body, is as follows: (1) All occurrences of each bound variable in the rule head are bound, (2) all occurrences of constants are bound, and (3) if a variable x occurs in the rule body, then all occurrences of x in subsequent literals are bound.	x-2211-1
The definition of adorned rule also applies to situations in which there are repeated variables or constants in the rule head (see Exercise 13.9).	x-2212-1
However, adornments do not capture all of the relevant information that can arise as the result of repeated variables or constants that occur in idb predicates in rule bodies.	x-2212-2
Mechanisms for doing this are discussed in Section 13.4.	x-2212-3
Supplementary Relations and QSQ Templates bff bffb bbfb	x-2213-1
To do this, QSQ templates rely on supplementary relations.	x-2214-1
A total of n + 1 supplementary relations are associated to a rule body with n atoms.	x-2214-2
For example, the supplementary relations sup 0, .	x-2214-3
.	x-2214-4
.	x-2214-5
, sup 3 for the rule (*) with head adorned by R bfb are bff bffb bbfb R bfb(x, y, z) ← R sup 0[x, z] sup 1[x, z, u, v] sup 2[x, z, v, w] sup 3[x, y, z] Note that variables serve as attribute names in the supplementary relations.	x-2214-6
Speaking intuitively, the body of a rule may be viewed as a process that takes as input tuples over the bound attributes of the head and produces as output tuples over the variables (bound and free) of the head.	x-2214-7
This determines the attributes of the first and last supplementary relations.	x-2214-8
In addition, a variable (i.e., an attribute name) is in some supplementary relation if it is has been bound by some previous literal and if it is needed in the future by some subsequent literal or in the result.	x-2215-1
More formally, for a rule body with atoms A1, .	x-2216-1
.	x-2216-2
.	x-2216-3
, An, the set of variables used as attribute names for the ith supplementary relation is determined as follows:	x-2216-4
The QSQ template for an adorned rule is the sequence ( sup 0, .	x-2217-1
.	x-2217-2
.	x-2217-3
, sup n) of relation schemas for the supplementary relations of the rule.	x-2217-4
During the process of QSQ query evaluation, relation instances are assigned to these schemas; typically these instances repeatedly acquire new tuples as the algorithm runs.	x-2217-5
Figure 13.2 shows the use of QSQ templates in connection with the RSG query.	x-2217-6
Evaluation of Datalog rsgbf( x, y) rsgbf( x, y) flat( x, y) up( x, x ), rsgfb( y , x ), down( y , y) 1 sup 1[ x] sup 1[ x, y] sup 3[ x] sup 3[ x, x ] sup 3[ x, y ] sup 3[ x, y] rsg fb( x, y) rsg fb( x, y) flat( x, y) down( y , y), rsgbf( y , x ), up( x, x ) 1 sup 2[ y] sup 2[ x, y] sup 4[ y] sup 4[ y, y ] sup 4[ y, x ] sup 4[ x, y] e g f e f l f f f m input_rsgbf input_rsg fb e g f f Figure 13.2: Illustration of QSQ framework The Kernel of QSQ Evaluation The key components of QSQ evaluation are as follows.	x-2218-1
Let (P , q) be a datalog query and let I be an edb instance.	x-2218-2
Speaking conceptually, QSQ evaluation begins by constructing an adorned rule for each adornment of each idb predicate in P and for the query q.	x-2218-3
In practice, the construction of these adorned rules can be lazy (i.e., they can be constructed only if needed during execution of the algorithm).	x-2218-4
Let (P ad, qad) denote the result of this transformation.	x-2218-5
The relevant adorned rules for the RSG query are as follows:	x-2219-1
Note that in the fourth rule, the literals of the body are ordered so that the binding of y in down can be “passed” via y1 to rsg and via x1 to up.	x-2220-1
following relations are needed and will serve as variables in the QSQ evaluation algorithm: (a) for each idb predicate R and relevant adornment γ the variable ans _Rγ , with same arity as R;	x-2221-1
j j Intuitively, input _Rγ will be used to form subqueries (Rγ , input _Rγ ).	x-2222-1
The completion of tuples in input _Rγ will go to ans _Rγ .	x-2222-2
Thus ans _Rγ will hold tuples that are in P (I)(R) and were generated from subqueries based on Rγ .	x-2222-3
The query is then used to initialize the process.	x-2223-1
For example, the rule query(y) ← rsg(a, y) gives the initial value of {a} to input _ rsg bf .	x-2223-2
In general, this gives rise to the subquery (Rγ , {t }), where t is constructed using the set of constants in the initial query.	x-2223-3
There are essentially four kinds of steps in the execution.	x-2224-1
Different possible orderings for these steps will be considered.	x-2224-2
The first of these is used to initialize rules.	x-2224-3
New tuples are generated in supplementary relations sup i in two ways: Either some j new tuples have been obtained for sup i j −1 for the idb predicate occurring between sup i	x-2225-1
j −1 j j −1 yet been processed, and sup i is not the last supplementary relation of the corresponding j −1 rule.	x-2226-1
Suppose that Aj is the atom in the rule immediately following sup i .	x-2226-2
j −1 Evaluation of Datalog Two cases arise:	x-2227-1
j	x-2228-1
j −1	x-2229-1
j	x-2230-1
occurs in some rule, with surrounding supplementary variables sup i and sup i.	x-2231-1
In this j −1 j case, use join and projection on all tuples in sup i j −1 create new tuples to be added to sup i.	x-2231-2
j tuples in the final supplementary variable sup i of a rule.	x-2232-1
Suppose that the rule predicate is n Rγ .	x-2232-2
Add the new tuples in sup i to n	x-2232-3
Example 13.2.1 Figure 13.2 illustrates the data structures and “scratch paper” relations used in the QSQ algorithm, in connection with the RSG query, as applied to the instance of Fig.	x-2233-1
13.1.	x-2233-2
Recall the adorned version of the RSG query presented on page 321.	x-2233-3
The QSQ templates for these are shown in Fig.	x-2233-4
13.2.	x-2233-5
Finally, the scratch paper relations for the input-	x-2233-6
Figure 13.2 shows the contents of the relation variables after several steps of the QSQ approach have been applied.	x-2234-1
The procedure begins with the insertion of a into input _ rsg bf ; this corresponds to the rule query(y) ← rsg(a, y) step (B.ii.a) does not yield any tuples for sup 3.	x-2234-2
However, step (B.ii.b) is used to insert e 2	x-2234-3
Global Control Strategies We have now described all of the basic building blocks of the QSQ approach: the use of QSQ templates to perform information passing both into rules and sideways through rule bodies, and the three classes of relations used.	x-2235-1
A variety of global control strategies can be used for the QSQ approach.	x-2235-2
The most basic strategy is stated simply: Apply steps (A) through (D) until a fixpoint is reached.	x-2235-3
The following can be shown (see Exercise 13.12): Theorem 13.2.2 Let (P , q) be a datalog query.	x-2235-4
For each input I, any evaluation of QSQ on (P ad, qad) yields the answer of (P , q) on I.	x-2235-5
We now present a more specific algorithm based on the QSQ framework.	x-2236-1
This algorithm, called QSQ Recursive (QSQR) is based on a recursive strategy.	x-2236-2
To understand the central intuition behind QSQR, suppose that step (B) described earlier is to be performed, passing from supplementary relation sup i j −1 relation sup i .	x-2236-3
This may lead to the introduction of new tuples into sup i by step (B.ii.a) and j j to the introduction of new tuples into input _Rγ by step (B.ii.b).	x-2236-4
The essence of QSQR is that it now performs a recursive call to determine the Rγ values corresponding to the new tuples added to input _Rγ , before applying step (B) or (D) to the new tuples placed into sup i .	x-2236-5
j We present QSQR in two steps: first a subroutine and then the recursive algorithm itself.	x-2237-1
During processing in QSQR, the global state includes values for ans _Rγ and input _Rγ for each idb predicate R and relevant adornment γ .	x-2237-2
However, the supplementary relations are not global—local copies of the supplementary relations are maintained by each call of the subroutine.	x-2237-3
Subroutine Process subquery on one rule Input: A rule for adorned predicate Rγ , input instance I, a QSQR “state” (i.e., set of values for the input- and ans-variables), and a set T ⊆ input _Rγ .	x-2238-1
(Intuitively, the tuples in T have not been considered with this rule yet).	x-2238-2
For each atom Aj	x-2239-1
Evaluation of Datalog for the tuples in S.] to populate sup j.	x-2240-1
[This includes steps (B.ii.a) and (C).]	x-2240-2
The main algorithm is given by the following: Input: A query of the form (Rγ , T ), input instance I, and a QSQR “state” (i.e., set of values for the input- and ans-variables).	x-2240-3
Procedure: Call the subroutine to process subquery (Rγ , T ) on each rule defining R.	x-2241-1
Suppose that we are given the query query(u) ← R(v) Let γ be the adornment of R corresponding to v, and let T be the singleton relation corresponding to the constants in v. To find the answer to the query, the QSQR algorithm is invoked with input (Rγ , T ) and the global state where input _Rγ = T and all other input-	x-2242-1
It is straightforward to show that QSQR is correct (Exercise 13.12).	x-2243-1
Magic rsg bf (x, y) rsg f b(x, y) sup 31(x, x1) sup 32(x, y1) rsg bf (x, y) sup 41(y, y1) sup 42(y, x1) rsg f b(x, y) input _ rsg bf (x1) ← sup 31(x, x1) input _ rsg f b(y1) ← sup 41(y, y1) input _ rsg bf (a) ← query(y) Figure 13.3: Transformation of RSG query using magic sets such as QSQ.	x-2244-1
In particular, then, (P m, qm) incorporates the effect of “pushing” selections from the query into bottom-up computations, as if by magic.	x-2244-2
We focus on a technique originally called “generalized supplementary magic”; it is perhaps the most general magic set technique for datalog in the literature.	x-2245-1
(An earlier form of magic is considered in Exercise 13.18.)	x-2245-2
The discussion begins by explaining how the technique works in connection with the RSG query of the previous section and then presents the general algorithm.	x-2245-3
We first present a primitive family of rules corrresponding to that rule, and then apply some optimizations.	x-2246-1
Evaluation of Datalog sup 30(x) sup 31(x, x1) ← sup 30(x), up(x, x1) sup 32(x, y1) ← sup 31(x, x1), rsg f b(y1, x1) (s3.3’) sup 33(x, y) ← sup 32(x, y1), down(y1, y) rsg bf (x, y) ← sup 33(x, y) Rule (s3.0’) corresponds to step (A) of the QSQ algorithm; rules (s3.1’) and (s3.3’) correspond to step (B.i); rule (s3.2) corresponds to steps (B.ii.a) and (C); and rule (s3.4’) corresponds to step (D).	x-2247-1
In the literature, the predicate input _ rsg f b has usually been denoted as magic _ rsg f b and sup i as supmagic i .	x-2247-2
We use the current notation to stress the j j connection with the QSQ framework.	x-2247-3
Note that the predicate rsg bf here plays the role of ans _ rsg bf there.	x-2247-4
redundant.	x-2248-1
In general, if the ith rule defines Rγ , then the predicate sup i is eliminated, with 0 input _Rγ used in its place to eliminate rule (3.0’) and to form (s3.1) sup 31(x, x1) ← input _ rsg bf (x), up(x, x1).	x-2248-2
Similarly, the predicate of the last supplementary relation can be eliminated to delete rule (s3.4’) and to form rsg bf (x, y) ← sup 32(x, y1), down(y1, y).	x-2249-1
Therefore the set of rules (s3.0’) through (s3.4’) may be replaced by (s3.1), (s3.2), and (s3.3).	x-2250-1
Rules (s4.1), (s4.2), and (s4.3) of Fig.	x-2250-2
13.3 are generated from rule (4) of the adorned program for the RSG query (see p. 321).	x-2250-3
(Recall how the order of the body literals in that rule are reversed to pass bounding information.)	x-2250-4
Finally, rules (s1.1) and (s2.1) stem from rules (1) and (2) of the adorned program.	x-2250-5
The second class of rules is used to provide values for the input predicates [i.e., simulating step (B.ii.b) of the QSQ algorithm].	x-2251-1
In the RSG query, one rule for each of input _ rsg bf and input _ rsg f b is needed: (i3.2) input _ rsg bf (x1) ← sup 31(x, x1) input _ rsg f b(y1) ← sup 41(y, y1).	x-2251-2
Intuitively, the first rule comes from rule (s3.2).	x-2252-1
In other words, it follows from the second atom of the body of rule (3) of the original adorned program (see p. 321).	x-2252-2
In general, an adorned rule with k idb atoms in the body will generate k input rules of this form.	x-2252-3
The third and fourth classes of rules include one rule each; these initialize and conclude the simulation of QSQ, respectively.	x-2253-1
The first of these acts as a “seed” and is derived from the initial query.	x-2253-2
In the running example, the seed is input _rsgbf (a) ← .	x-2253-3
The second constructs the answer to the query; in the example it is query(y) ← rsg bf (a, y).	x-2254-1
From this example, it should be straightforward to specify the magic set rewriting of an adorned query (P ad, qad) (see Exercise 13.16a).	x-2255-1
The example showed how the “first” and “last” supplementary predicates sup 3 and 0 sup 3 were redundant with input _ rsg bf and rsg bf , respectively, and could be eliminated.	x-2256-1
Rγ (u) ← R 1(u n (un) i.k′′) Rγ (u) ← sup i k (u k+1(u k−1(vk−1), Rk k), Rk+1 k+1), .	x-2257-1
.	x-2257-2
.	x-2257-3
, Rγn n (un).	x-2257-4
For example, rules (s3.2) and (s3.3) of Fig.	x-2258-1
13.3 can be replaced by (s3.2′′) rsg bf (x, y) ← sup 31(x, x1), rsg f b(y1, x1), down(y1, y).	x-2258-2
This simplification can also be used within rules.	x-2259-1
Suppose that Rk and Rl are idb relations with only edb relations occurring in between.	x-2259-2
Then rules (i.k), .	x-2259-3
.	x-2259-4
.	x-2259-5
, (i.l − 1) can be replaced with i.k′′) sup i k (u k+1(u l−1(u l−1(vl−1) ← sup ik−1(vk−1), Rk k), Rk+1 k+1), .	x-2259-6
.	x-2259-7
.	x-2259-8
, Rl−1 l−1).	x-2259-9
To summarize the development, we state the following (see Exercise 13.16): Theorem 13.3.1 Let (P , q) be a query, and let (P m, qm) be the query resulting from the magic rewriting of (P , q).	x-2260-1
Then	x-2260-2
Two Improvements This section briefly presents two improvements of the techniques discussed earlier.	x-2261-1
The first focuses on another kind of information passing resulting from repeated variables and constants occurring in idb predicates in rule bodies.	x-2261-2
The second, called counting, is applicable to sets of data and rules having certain acyclicity properties.	x-2261-3
Evaluation of Datalog Repeated Variables and Constants in Rule Bodies (by Example) Consider the program Pr: T (x, y, z) ← R(x, y, z) T (x, y, z) ← S(x, y, w), T (w, z, z) query(y, z) ← T (1, y, z) Consider as input the instance I1 shown in Fig.	x-2262-1
13.4(a).	x-2262-2
The data structures for a QSQ evaluation of this program are shown in Fig.	x-2262-3
13.4(b).	x-2262-4
(The annotations ‘$2 = $3’, ‘$2 = $3	x-2262-5
T bff (x, y, z) sup 21(x, y, w) ← input _T bff (x), S(x, y, w) T bff (x, y, z) input _T bff (w) ← sup 21(x, y, w) input _T bff (1) ← query(y, z)	x-2263-1
On input I1, the query returns the empty instance.	x-2264-1
Furthermore, the SLD tree for this query on I1 shown in Fig.	x-2264-2
13.5, has only 9 goals and a total of 13 atoms, regardless of the value of n. However, both the QSQ and magic set approach generate a set of facts with size proportional to n (i.e., to the size of I1).	x-2264-3
Why do both QSQ and magic sets perform so poorly on this program and query?	x-2265-1
The answer is that as presented, neither QSQ nor magic sets take advantage of restrictions on derivations resulting from the repeated z variable in the body of rule (2).	x-2265-2
Analogous examples can be developed for cases where constants appear in idb atoms in rule bodies.	x-2265-3
Both QSQ and magic sets can be enhanced to use such information.	x-2266-1
In the case of QSQ, the tuples added to supplementary relations can be annotated to carry information about restrictions imposed by the atom that “caused” the tuple to be placed into the leftmost supplementary relation.	x-2266-2
This is illustrated by the annotations in Fig.	x-2266-3
13.4(b).	x-2266-4
First consider the annotation ‘$2 = $3’ on the tuple 3 in input _T bff .	x-2266-5
This tuple is included into input _ T bff because 1, 2, 3 is in sup 2, and the next atom considered is T bff (w, z, z).	x-2266-6
In particular, 1 then, any valid tuple (x, y, z) resulting from 3 must have second and third coordinates equal.	x-2266-7
The annotation ‘$2 = $3’ is passed with 3 into sup 1 and sup 2.	x-2266-8
Because variable y is bound to 4 in the tuple 3, 4, 5 in sup 2, the annotation ‘$2 =	x-2267-1
Now consider the tuple 5 in sup 1, with annotation ($2 = $3 = 4).	x-2268-1
This can generate a 0 tuple in sup 1 only if 5, 4, 4 is in R. For input I B C B C R S	x-2268-2
n I1( R) I1( S) Tbff( x, y, z) R( x, y, z) input_Tbff sup 1[ x] sup 1[ x, y, z]	x-2269-1
n Tbff( x, y, z) S( x, y, w), Tbff( w, z, z)	x-2270-1
sup 2[ x] sup 2[ x, y, w] sup 2[ x, y, z] n Figure 13.4: Behavior of QSQ on program with repeated variables Evaluation of Datalog Figure 13.5: Behavior of SLD on program with repeated variables tuple 5 in sup 1 generates nothing (even though in the original QSQ framework many 0 tuples are generated).	x-2271-1
Analogously, because there is no tuple 5, 4, w in S, the annotated tuple 5 of sup 2 does not generate anything in sup 2.	x-2271-2
This illustrates how annotations can 0 be used to restrict the facts generated during execution of QSQ.	x-2271-3
More generally, annotations on tuples are conjunctions of equality terms of the form	x-2272-1
The magic set technique can also be enhanced to incorporate the information captured by the annotations just described.	x-2273-1
This is accomplished by an initial preprocessing of the program (and query) called “subgoal rectification.” Speaking loosely, a subgoal corresponding to an idb predicate is rectified if it has no constants and no repeated variables.	x-2273-2
Rectified subgoals may be formed from nonrectified ones by creating new idb predicates that correspond to versions of idb predicates with repeated variables and constants.	x-2274-1
For example, the following is the result of rectifying the subgoals of the program Pr: T (x, y, z) T (x, y, z) T$2=$3(x, z) ← R(x, z, z) T$2=$3(x, z) ← S(x, z, w), T$2=$3(w, z) query(y, z) ← T (1, y, z) query(z, z) ← T$2=$3(1, z).	x-2274-2
It is straightforward to develop an iterative algorithm that replaces an arbitrary datalog program and query with an equivalent one, all of whose idb subgoals are rectified (see Exercise 13.20).	x-2275-1
Note that there may be more than one rule defining the query after rectification.	x-2275-2
The magic set transformation is applied to the rectified program to obtain the final result.	x-2276-1
In the preceding example, there are two relevant adornments for the predicate T$2=$3	x-2276-2
The following can be verified (see Exercise 13.21): Theorem 13.4.1 (Informal) The framework of annotated QSQ and the magic set trans- formation augmented with subgoal rectification are both correct.	x-2277-1
Furthermore, the set of idb predicate facts generated by evaluating a datalog query with either of these techniques is identical to the set of facts occurring in the corresponding SLD tree.	x-2277-2
Counting (by Example) We now present a brief sketch of another improvement of the magic set technique.	x-2278-1
It is different from the previous one in that it works only when the underlying data set is known to have certain acyclicity properties.	x-2278-2
Consider evaluating the following SG query based on the Same-Generation program: (1) sg(x, y) ← flat(x, y) sg(x, y) ← up(x, x1), sg(x1, y1), down(y1, y) query(y) ← sg(a, y) on the input Jn given by Jn( up) Jn( flat) Jn( down) = {di, ej | i, j ∈ [1, n]} ∪ {ei, f | i ∈ [1, n]}.	x-2279-1
Instance J2 is shown in Fig.	x-2280-1
13.6.	x-2280-2
The completed QSQ template on input J2 for the second rule of the SG query is shown in Fig.	x-2281-1
13.7(a).	x-2281-2
(The tuples are listed in the order in which QSQR would discover them.)	x-2281-3
Note that on input Jn both sup 2 and sup 2 would contain n(n + 1) tuples.	x-2281-4
Consider now the proof tree of SG having root sg(a, f ) shown in Fig.	x-2282-1
13.8 (see Chapter 12).	x-2282-2
There is a natural correspondence of the children at depth 1 in this tree with the supplementary relation atoms sup 2(a), sup 2(a, b Evaluation of Datalog flat c c d d up down b b e e up down f Figure 13.6: Instance J2 for counting by QSQ; and between the children at depth 2 with sup 2(b sup 2(b	x-2282-3
sup 2(1, e sup 2(a, b sponds to both sup 2(b	x-2283-1
More generally, the modified supplementary relation atoms hold an “index” that indicates a level in a proof tree corresponding to how the atom came to be created.	x-2284-1
Because of the structure of SG, and assuming that the up relation is acyclic, these modified supplementary relations can be used to find query answers.	x-2284-2
Note that on input Jn, the relations countsup 2′ and count _ sup 2′ hold 2n tuples each rather than n(n + 1), as in the original QSQ	x-2284-3
We now describe how the magic set program associated with the SG query can be transformed into an equivalent program (on acyclic input) that uses the indexes suggested by Fig.	x-2285-1
13.7(b).	x-2285-2
The magic set rewriting of the SG query is given by (s1.1) sg bf (x, y) ← input _ sg bf (x), flat(x, y) (s2.1) sup 21(x, x1) ← input _ sg bf (x), up(x, x1) (s2.2) sup 22(x, y1) ← sup 21(x, x1), sg bf (x1, y1) (s2.3) sg bf (x, y) ← sup 22(x, y1), down(y1, y) sgbf( x, y) up( x, x ), sgbf( x , y ), down( y , y) 1 sup 2[ x] sup 2[ x, x ] sup 2[ x, y ] sup 2[ x, y] b d b e b b d b e b b c b d b e b c b d b e b c b c sgbf( x, y) up( x, x ), sgbf( x , y ), down( y , y) 1 count_sup 2[ d, x] count_sup 2[ d, x ] count_sup 2[ d, y ] count_sup 2[ d, y] Figure 13.7: Illustration of intuition behind counting input _ sg bf (x1) ← sup 21(x, x1) input _ sg bf (a) ← query(y)	x-2285-3
The counting version of this is now given.	x-2286-1
(In other literature on counting, the seed is initialized with 0 rather than 1.)	x-2286-2
Evaluation of Datalog sg( a, f) up( a, b ) sg( b , e ) down( e , f) up( b , c ) sg( c , d ) down( d , e ) flat( c , d ) Figure 13.8: count _ sg bf (I, y) count _ sup 21(I, x1) count _ sup 22(I, y1) count _ sg bf (I, y) count _ input _ sg bf (I + 1, x1) ← count _ sup 21(I, x1) (c-seed) count _ input _ sg bf (1, a) In the preceding, expressions such as I + 1 are viewed as a short hand for using a variable J in place of I + 1 and including J = I + 1 in the rule body.	x-2287-1
In the counting version, the first coordinate of each supplementary relation keeps track of a level in a proof tree rather than a specific value.	x-2288-1
Intuitively, when “constructing” sg bf (I + 1, y1) is used in rule (c-s2.2).	x-2288-2
Furthermore, rule (c-i2.2) initiates the “construction” corresponding to a new layer of the proof tree.	x-2288-3
The counting program of the preceding example is not safe, in the sense that on some inputs the program may produce an infinite set of tuples in some predicates (e.g., count _ sup 2).	x-2289-1
For example, this will happen if there is a cycle in the up relation reachable 1 from a. Analogous situations occur with most applications of counting.	x-2289-2
As a result, the counting technique can only be used where the underlying data set is known to satisfy certain restrictions.	x-2289-3
Bibliographic Notes This preceding example is a simple application of the general technique of counting.	x-2290-1
Bibliographic Notes This chapter has presented a brief introduction to the research on heuristics for datalog evaluation.	x-2291-1
An excellent survey of this work is [BR88a], which presents a taxonomy of different techniques and surveys a broad number of them.	x-2291-2
Several books provide substantial coverage of this area, including [Bid91a, CGT90, Ull89b].	x-2291-3
Experimental results comparing several of the techniques in the context of datalog are described in [BR88b].	x-2291-4
An excellent survey on deductive database systems, which includes an overview of several prototype systems that support datalog, is presented in [RU94].	x-2291-5
The naive and seminaive strategies for datalog evaluation underlie several early investigations and implementations [Cha81b, MS81]; the seminaive strategy for evaluation is described in [Ban85, Ban86], which also propose various refinements.	x-2292-1
The use of T i−1 and T i in Algorithm 13.1.1 is from [BR87b].	x-2292-2
Reference [CGT90] highlights the close relationship of these approaches to the classical Jacobi and Gauss-Seidel algorithms of numerical analysis.	x-2292-3
The Query-Subquery (QSQ) approach was initially presented in [Vie86]; the independently developed method of “extension tables” [DW87] is essentially equivalent to this.	x-2293-1
The QSQ approach is extended in [Vie88, Vie89] to incorporate certain global optimizations.	x-2294-1
An extension of the technique to general logic programming, called SLD-AL, is developed in [Vie87a, Vie89].	x-2294-2
Related approaches include APEX [Loz85], Earley Deduction [PW80, Por86], and those of [Nej87, Roe87].	x-2294-3
The connection between context-free parsing and datalog evaluation is highlighted in [Lan88].	x-2294-4
The algorithms of the QSQ family are sometimes called “memo-ing” approaches, because they use various data structures to remember salient inferred facts to filter the work of traditional SLD resolution.	x-2295-1
Perhaps the most general of the top-down approaches uses “rule/goal” graphs [Ull85]; these potentially infinite trees intuitively correspond to a breadth-first, set-at-a-time execution of SLD resolution.	x-2296-1
Rule/goal graphs are applied in [Van86] to evaluate datalog queries in distributed systems.	x-2296-2
Similar graph structures have also been used in connection with general logic programs (e.g., [Kow75, Sic76]).	x-2296-3
A survey of several graph-based approaches is	x-2296-4
Turning to bottom-up approaches, the essentially equivalent approaches of [HN84] and Evaluation of Datalog	x-2297-1
The magic set and counting techniques originally appeared for linear datalog in	x-2298-1
The counting method is generalized and combined with magic sets in [SZ86, SZ88].	x-2299-1
Supplementary magic is incorporated in [BR91].	x-2300-1
Analytic comparisons of magic and counting for selected programs are presented in [MSPS87].	x-2300-2
Several of the investigations just mentioned, including [BR87a, KL86a, KL86b, Ull85, Vie86], emphasize the idea that sideways information passing and control are largely independent.	x-2301-1
Both [SZ88] and [BR91] describe fairly general mechanisms for specifying and using alternative sideways information passing and related message passing.	x-2301-2
A more general form of sideways information passing, which passes bounding inequalities between subgoals, is studied in [APP+86].	x-2301-3
A formal framework for studying the success of pushing selections into datalog programs is developed in [BKBR87].	x-2301-4
Several papers have studied the connection between top-down and bottom-up evaluation techniques.	x-2302-1
One body of the research in this direction focuses on the sets of facts generated by the top-down and bottom-up techniques.	x-2302-2
One of the first results relating top-down and bottom-up is from [BR87a, BR91], where it is shown that if a top-down technique and the generalized supplementary magic set technique use a given family of sideways information passing techniques, then the sets of intermediate facts produced by both techniques correspond.	x-2302-3
That research is conducted in the context of general logic programs that are range restricted.	x-2302-4
These results are generalized to possibly non-range-restricted logic programs in the independent research [Ram91] and [Sek89].	x-2302-5
In that research, bottom-up evaluations may use terms and tuples that include variables, and bottom-up evaluation of rewritten programs uses unification rather than simple relational join.	x-2302-6
A close correspondence between top-down and bottom-up evaluation for datalog was established in [Ull89a], where subgoal rectification is used.	x-2302-7
The treatment of Program Pr and Theorem 13.4.1 are inspired by that development.	x-2302-8
This close correspondence is extended to arbitrary logic programs in [Ull89b].	x-2302-9
Using a more detailed cost model, [SR93] shows that bottom-up evaluation asymptotically dominates top-down evaluation for logic programs, even if they produce nonground terms in their output.	x-2302-10
Exercises the QSQ until a fixpoint is reached.	x-2303-1
Note that the fixpoint operator used in this chapter is different from the conventional bottom-up application of TP used by the naive algorithm for datalog evaluation.	x-2303-2
The framework presented in [Bry89] is based on meta-interpreters (i.e., interpreters that operate on datalog rules in addition to data); these can be used to specify QSQ and related algorithms as bottom-up, fixpoint evaluations.	x-2303-3
(Such meta-programming is common in functional and logic programming but yields novel results in the context of datalog.)	x-2303-4
Reference [Bry89] goes on to describe several top-down and bottom-up datalog evaluation techniques within the framework, proving their correctness and providing a basis for comparison.	x-2303-5
Extensions of the datalog evaluation techniques to stratified datalog¬ programs (see Chapter 15) include [BPR87, Ros91, SI88, KT88].	x-2304-1
Exercises Exercise 13.1 Recall the program RSG′ from Section 13.1.	x-2305-1
Exhibit an instance I such that on this input, δi = ∅ for each i > 0.	x-2305-2
rsg Exercise 13.2 Recall the informal discussion of the two seminaive “versions” of the nonlinear ancestor program discussed in Section 13.1.	x-2306-1
Let P1 denote the first of these, and P2 the second.	x-2306-2
Show the following.	x-2307-1
Exercise 13.3 Consider the basic seminaive algorithm (13.1.1).	x-2308-1
Evaluation of Datalog	x-2309-1
S to T i+1(I)(S) − T i (I)(S).	x-2310-1
P P	x-2311-1
Exercise 13.4 Consider the improved seminaive algorithm (13.1.2).	x-2312-1
Exercise 13.5 Let P be a linear datalog program, and let P ′ be the set of rules associated with P by the improved seminaive algorithm.	x-2313-1
Suppose that the naive algorithm is performed using P ′ on some input I.	x-2313-2
Does this yield P (I)?	x-2313-3
Why or why not?	x-2313-4
What if the basic seminaive algorithm is used?	x-2313-5
Exercise 13.6	x-2314-1
Exercise 13.7 where S3, S4 are edb relations.	x-2315-1
Observe that the atoms S3(u, v) and S4(v, w) are not connected to the other atoms of the rule body or to the rule head.	x-2315-2
Furthermore, in an evaluation of P on input I, this rule may contribute some tuple to S only if there is an assignment α for u, v, w such that {S3(u, v), S4(v, w)}[α] ⊆ I.	x-2315-3
Explain why it is typically more efficient to replace ρ with ρ′ : S(x, y) ← S1(x, z), S2(z, y) if there is such an assignment and to delete ρ from P otherwise.	x-2315-4
Extend this to the case when S3, S4 are idb relations.	x-2315-5
State a general version of this heuristic improvement.	x-2315-6
Exercise 13.8 Consider the adorned rule bf bf ff bf Rbf (x, w) ← S	x-2316-1
Explain why it makes sense to view the second occurrence of v as bound.	x-2317-1
Exercise 13.9 Consider the rule R(x, y, y) ← S(y, z), T (z, x).	x-2318-1
Exercises	x-2319-1
Exercise 13.10	x-2320-1
Exercise 13.14 Give the magic set transformation of this program and query.	x-2321-1
Exercise 13.15 Give examples of how a query (P m, qm) resulting from magic set rewriting can produce nonrelevant and redundant facts.	x-2322-1
Exercise 13.17 Compare the difficulties, in practical terms, of using the QSQ and magic set frameworks for evaluating datalog queries.	x-2323-1
Evaluation of Datalog sgv bf (x, y) sgv bf (x, y) input _ sgv bf (z1) ← input _ sgv bf (x), up(x, z1) (o-i2.4) input _ sgv bf (z3) ← input _ sgv bf (x), up(x, z1), sgv bf (z1, z2), flat(z2, z3) input _ sgv(a) query(y) Intuitively, the original magic set transformation uses the relations input _Rγ , but not supplementary relations.	x-2324-1
bf bf bf bf bbf Rbbf (x, y, z) ← T	x-2325-1
Exercise 13.22 Write a program using counting that can be used to answer the RSG query presented at the beginning of Section 13.2.	x-2326-1
Exercises count _ sgv bf (I, K, L, y) count _ sup 21(I, K, L, z1) count _ sup 22(I, K, L, z2) count _ sgv bf (I + 1, 2K + 2, 5L + 2, z2) count _ sup 23(I, K, L, z3) count _ sup 24(I, K, L, z4) count _ sgv bf (I + 1, 2K + 2, 5L + 4, z4), count _ sgv bf (I, K, L, y) count _ input _ sgv bf (I + 1, 2K + 2, 5L + 2, z1) count _ input _ sgv bf (I + 1, 2K + 2, 5L + 4, z3) count _ input _ sgv bf (1, 0, 0, a) ← query(y) Figure 13.9: Generalized counting transformation on SGV query	x-2327-1
Vittorio: Let’s combine recursion and negation.	x-2328-1
Riccardo: That sounds hard to me.	x-2329-1
Sergio: It’s no problem, just add fixpoint to the calculus, or while to the algebra.	x-2330-1
Riccardo: That sounds hard to me.	x-2331-1
Vittorio: OK—how about datalog with negation?	x-2332-1
Riccardo: That sounds hard to me.	x-2333-1
Riccardo, you are recursively negative.	x-2334-1
The query languages considered so far were obtained by augmenting the conjunctive queries successively with disjunction, negation, and recursion.	x-2335-1
In this chapter, we consider languages that provide both negation and recursion.	x-2335-2
They allow us to ask queries such as, “Which are the pairs of metro stops which are not connected?” .	x-2335-3
This query is not expressible in relational calculus and algebra or in datalog.	x-2335-4
The integration of recursion and negation is natural and yields highly expressive languages.	x-2336-1
We will see how it can be achieved in the three paradigms considered so far: algebraic, logic, and deductive.	x-2336-2
The algebraic language is an extension of the algebra with a looping construct and an assignment, in the style of traditional imperative programming languages.	x-2336-3
The logic language is an extension of the calculus in which recursion is provided by a fixpoint operator.	x-2336-4
The deductive language extends datalog with negation.	x-2336-5
In this chapter, the semantics of datalog with negation is defined from a purely computational perspective that is in the spirit of the algebraic approach.	x-2337-1
More natural and widely accepted model-theoretic semantics, such as stratified and well-founded semantics, are presented in Chapter 15.	x-2337-2
Recursion and Negation of such queries imply that there are queries that are not fixpoint or while queries.	x-2338-1
More powerful languages are considered in Chapter 18.	x-2338-2
Before describing specific languages, we present an example that illustrates the principles underlying the two flavors of the languages.	x-2339-1
Example The following is based on a version of the well-known “game of life,” which is used to model biological evolution.	x-2340-1
The game starts with a set of cells, some of which are alive and some dead; the alive ones are colored in blue or red.	x-2340-2
(One cell may have two colors.)	x-2340-3
Each cell has other cells as neighbors.	x-2340-4
Suppose that a binary relation Neighbor holds the neighbor relation (considered as a symmetric relation) and that the information about living cells and their color is held in a binary relation Alive (see Fig.	x-2340-5
14.1).	x-2340-6
Suppose first that a cell can change status from dead to alive following this rule: (α) The evolution of a particular population for the Neighbor graph of Fig.	x-2340-7
14.1(a) is given in Fig.	x-2340-8
14.1(b).	x-2340-9
Observe that the sets of tuples keep increasing and that we reach a stable state.	x-2340-10
This is an example of inflationary iteration.	x-2341-1
Now suppose that the evolution also obeys the second rule:	x-2342-1
The evolution of the population with the two rules is given in Fig.	x-2343-1
14.1(c).	x-2343-2
Observe that the number of tuples sometimes decreases and that the computation diverges.	x-2343-3
This is an example of noninflationary iteration.	x-2343-4
i=1(n + c)ri , which is a polynomial in n. Thus such queries can be evaluated in polynomial space.	x-2344-1
As will be seen when the formal definitions are in place, this implies that each noninflationary iteration, and hence each noninflationary query, can be evaluated in polynomial space, whether or not it terminates.	x-2344-2
In contrast, the inflationary semantics ensures termination by requiring that a tuple can never be deleted once it has been inserted.	x-2344-3
Because there are only polynomially many tuples, each such program terminates in polynomial time.	x-2345-1
To summarize, the inflationary languages use iteration based on an “inflation of tuples.” In all three paradigms, inflationary queries can be evaluated in polynomial time, and the same expressive power is obtained.	x-2346-1
The noninflationary languages use noninflationary or destructive assignment inside of iterations.	x-2346-2
In all three paradigms, noninflationary queries can be evaluated in polynomial space, and again the same expressive power is Recursion and Negation Neighbor e b e c e d e blue blue blue b red b red b red c blue c blue c blue	x-2346-3
d red d red d red e blue e blue e red e red blue blue blue blue blue b red b red b red b red b red	x-2347-1
c blue c blue c blue c blue c blue d red d red d red d red d red e blue e blue e red e red Figure 14.1: Game of life obtained.	x-2348-1
(We note, however, that it remains open whether the inflationary and the noninflationary languages have equivalent expressive power; we discuss this issue later.)	x-2348-2
14.1 Relational algebra is essentially a procedural language.	x-2348-3
Of the query languages, it is the closest to traditional imperative programming languages.	x-2348-4
Chapters 4 and 5 described how it can be extended syntactically using assignment (:=) and composition (;) without increasing its expressive power.	x-2348-5
The extensions of the algebra with recursion are also consistent with the imperative paradigm and incorporate a while construct, which calls for the iteration of a program segment.	x-2348-6
The resulting language comes in two flavors: inflationary and noninflationary.	x-2348-7
The two versions of the language differ in the semantics of the assignment statement.	x-2348-8
The noninflationary version was the one first defined historically, and we discuss it next.	x-2348-9
The resulting language is called the while language.	x-2348-10
Noninflationary Semantics Recall from Chapter 4 that assignment statements can be incorporated into the algebra using expressions of the form R := E, where E is an algebra expression and R a relational variable of the same sort as the result of E. (The difference from Chapter 4 is that it is no longer required that each successive assignment statement use a distinct, previously unused variable.)	x-2349-1
In the while language, the semantics of an assignment statement is as follows: The value of R becomes the result of evaluating the algebra expression E on the current state of the database.	x-2349-2
This is the usual destructive assignment in imperative programming languages, where the old value of a variable is overwritten.	x-2349-3
While statements have the form while change do begin loop body end There is no explicit termination condition.	x-2350-1
Instead a loop runs as long as the execution of the body causes some change to some relation (i.e., until a stable state is reached).	x-2350-2
At the end of this section, we consider the introduction of explicit terminating conditions and see that this does not affect the language in an essential manner.	x-2350-3
Nesting of loops is permitted.	x-2351-1
A while program is a finite sequence of assignment or while statements.	x-2351-2
The program uses a finite set of relational variables of specified sorts, including the names of relations in the input database.	x-2351-3
Relational variables that are not in the input database are initialized to the empty relation.	x-2351-4
A designated relational variable holds the output to the program at the end of the computation.	x-2351-5
The image (or value) of program P on I, denoted P (I), is the value finally assigned to the designated variable if P terminates on I; otherwise P (I) is undefined.	x-2351-6
Example 14.1.1 (Transitive Closure) Consider a binary relation G[AB], specifying the edges of a graph.	x-2352-1
The following while program computes in T [AB] the transitive closure of G.	x-2352-2
T := G; while change do begin T := T ∪ πAB(δB→C(T ) ⊲⊳ δA→C(G)); end	x-2353-1
Recursion and Negation Example 14.1.2 (Add-Remove) Consider again a binary relation G specifying the edges of a graph.	x-2354-1
Each loop of the following program	x-2354-2
This is iterated while some change occurs.	x-2355-1
The result is placed into the binary relation T .	x-2355-2
In addition, the binary relation variables ToAdd and ToRemove are used as “scratch paper.” For the sake of readability, we use the calculus with active domain semantics whenever this is easier to understand than the corresponding algebra expression.	x-2356-1
T := G; while change do begin ToRemove := {x, y | ∃z(T (x, z) ∧ T (z, y))}; ToAdd := {x, y | ∃z(¬T (x, z) ∧ ¬T (z, x) ∧ ¬T (y, z) ∧ ¬T (z, y))}; T := (T ∪ ToAdd) − ToRemove; end In the Transitive Closure example, the transitive closure query always terminates.	x-2357-1
This is not the case for the Add-Remove query.	x-2357-2
(Try the graph {a, a, a, b, b, a, b, b}.)	x-2357-3
The halting problem for while programs is undecidable (i.e., there is no algorithm that, given a while program P , decides whether P halts on each input; see Exercise 14.2).	x-2357-4
Observe, however, that for a pair (P , I), one can decide whether P halts on input I because, as argued earlier, while computations are in pspace.	x-2357-5
Inflationary Semantics We define next an inflationary version of the while language, denoted by while+.	x-2358-1
The while+ language differs with while in the semantics of the assignment statement.	x-2358-2
In particular, in while+, assignment is cumulative rather than destructive: Execution of the statement assigning E to R results in adding the result of E to the old value of R. Thus no tuple is removed from any relation throughout the execution of the program.	x-2358-3
To distinguish the cumulative semantics from the destructive one, we use the notation P += e for the cumulative semantics.	x-2358-4
Example 14.1.3 (Transitive Closure Revisited) Following is a while+ program that computes the transitive closure of a graph represented by a binary relation G[AB].	x-2359-1
The result is obtained in the variable T [AB].	x-2359-2
T += G; while change do begin T += πAB(δB→C(T ) ⊲⊳ δA→C(G)); end This is almost exactly the same program as in the while language.	x-2360-1
The only difference is that because assignment is cumulative, it is not necessary to add the content of T to the result of the projection.	x-2360-2
To conclude this section, we consider alternatives for the control condition of loops.	x-2361-1
Until now, we based termination on reaching a stable state.	x-2362-1
It is also common to use explicit terminating conditions, such as tests for emptiness of the form E = ∅, E = ∅, or E = E′, where E, E′ are relational algebra expressions.	x-2362-2
The body of the loop is executed as long as the condition is satisfied.	x-2362-3
The following example shows how transitive closure is computed using explicit looping conditions.	x-2362-4
Example 14.1.4 We use another relation schema old T also of sort AB.	x-2363-1
T += G; while (T − old T ) = ∅ do begin old T += T ; T += πAB(δB→C(T ) ⊲⊳ δA→C(G)); end In the program, old T keeps track of the value of T resulting from the previous iteration of the loop.	x-2364-1
The computation ends when old T and T coincide, which means that no new edges were added in the current iteration, so T now holds the transitive closure of G.	x-2364-2
It is easily shown that the use of such termination conditions does not modify the expressive power of while, and the use of conditions such as E = E′ does not modify the expressive power of while+ (see Exercise 14.5).	x-2365-1
In Section 14.4 we shall see that nesting of loops in while queries does not increase expressive power.	x-2366-1
Calculus + Fixpoint Just as in the case of the algebra, we provide inflationary and noninflationary extensions of the calculus with recursion.	x-2367-1
This could be done using assignment statements and while loops, as for the algebra.	x-2367-2
Indeed, we used calculus notation in Example 14.1.2 ( Add-Remove).	x-2367-3
Instead we use an equivalent but more logic-oriented construct to augment the calculus.	x-2367-4
The construct, called a fixpoint operator, allows the iteration of calculus formulas up to a fixpoint.	x-2367-5
In effect, this allows defining relations inductively using calculus formulas.	x-2367-6
For the remainder of this chapter, as a notational convenience, we use active domain semantics for calculus queries.	x-2368-1
In addition, we often use a formula ϕ(x1, .	x-2368-2
.	x-2368-3
.	x-2368-4
, xn) as an abbreviation for the query {x1, .	x-2368-5
.	x-2368-6
.	x-2368-7
, xn | ϕ(x1, .	x-2368-8
.	x-2368-9
.	x-2368-10
, xn)}.	x-2368-11
These two simplifications do not affect the results developed.	x-2368-12
Recursion and Negation Partial Fixpoints The noninflationary version of the fixpoint operator is considered first.	x-2369-1
It is illustrated in the following example.	x-2369-2
Example 14.2.1 (Transitive Closure Revisited) Consider again the transitive closure of a graph G. The relations Jn holding pairs of nodes at distance at most n can be defined inductively using the single formula J0 = ∅; Jn = ϕ(Jn−1), n > 0.	x-2370-1
Here ϕ(Jn−1) denotes the result of evaluating ϕ(T ) when the value of T is Jn−1.	x-2371-1
Note that, for each input G, the sequence {Jn}n≥0 converges.	x-2371-2
That is, there exists some k for which Jk = Jj for every j > k (indeed, k is the diameter of the graph).	x-2371-3
Clearly, Jk holds the transitive closure of the graph.	x-2371-4
Thus the transitive closure of G can be defined as the limit of the foregoing sequence.	x-2371-5
Note that Jk = ϕ(Jk), so Jk is also a fixpoint of ϕ(T ).	x-2371-6
The relation Jk thereby obtained is denoted by µT (ϕ(T )).	x-2371-7
Then the transitive closure of G is defined by	x-2371-8
By definition, µT is an operator that produces a new relation (the fixpoint Jk) when applied to ϕ(T ).	x-2372-1
Note that, although T is used in ϕ(T ), T is not a database relation but rather a relation used to define inductively µT (ϕ(T )) from the database, starting with T = ∅.	x-2372-2
T is said to be bound to µT .	x-2372-3
Indeed, µT is somewhat similar to a quantifier over relations.	x-2372-4
Note that the scope of the free variables of ϕ(T ) is restricted to ϕ(T ) by the operator µT .	x-2372-5
In the preceding example, the limit of the sequence {Jn}n≥0 happens to exist and is in fact the least fixpoint of ϕ.	x-2373-1
This is not always the case; the possibility of nontermination is illustrated next (and Exercise 14.4 considers cases in which a nonminimal fixpoint is reached).	x-2373-2
Example 14.2.2 Consider	x-2374-1
In this case the sequence {Jn}n≥0 is ∅, {0}, {1}, {0}, .	x-2375-1
.	x-2375-2
.	x-2375-3
(i.e., T flip-flops between zero and one).	x-2375-4
Thus the sequence does not converge, and µT (ϕ(T )) is not defined.	x-2375-5
Situations in which µ is undefined correspond to nonterminating computations in the while language.	x-2375-6
The following nonterminating while program corresponds to µT (ϕ(T )).	x-2376-1
T := {0}; while change do begin T := {0, 1} − T ; end Because µ is only partially defined, it is called the partial fixpoint operator.	x-2377-1
We now define its syntax and semantics in more detail.	x-2377-2
Partial Fixpoint Operator Let R be a database schema, and let T [m] be a relation schema not in R. Let S denote the schema R ∪ {T }.	x-2378-1
Let ϕ(T ) be a formula using T and relations in R, with m free variables.	x-2378-2
Given an instance I over R, µT (ϕ(T )) denotes the relation that is the limit, if it exists, of the sequence {Jn}n≥0 defined by J0 = ∅; Jn = ϕ(Jn−1), n > 0, where ϕ(Jn−1) denotes the result of evaluating ϕ on the instance Jn−1 over S whose restriction to R is I and Jn−1(T ) = Jn−1.	x-2378-3
The expression µT (ϕ(T )) denotes a new relation (if it is defined).	x-2379-1
In turn, it can be used in more complex formulas like any other relation.	x-2379-2
For example, µT (ϕ(T ))(y, z) states that y, z is in µT (ϕ(T )).	x-2379-3
If µT (ϕ(T )) defines the transitive closure of G, the complement of the transitive closure is defined by	x-2379-4
The extension of the calculus with µ is called partial fixpoint logic, denoted CALC+µ.	x-2380-1
Partial Fixpoint Logic CALC+µ formulas are obtained by repeated applications of CALC operators (∃, ∀, ∨, ∧, ¬) and the partial fixpoint operator, starting from atoms.	x-2381-1
In particular, µT (ϕ(T ))(e1, .	x-2381-2
.	x-2381-3
.	x-2381-4
, en), where T has arity n, ϕ(T ) has n free variables, and the ei are variables or constants, is a formula.	x-2381-5
Its free variables are the variables in the set where ξ is a CALC+µ formula whose free variables are those occurring in e1, .	x-2381-6
.	x-2381-7
.	x-2381-8
, en.	x-2381-9
The formula ξ may use relation names in addition to those in R; however, each occurrence P of such relation name must be bound to some partial fixpoint operator µP .	x-2381-10
The semantics of CALC+µ queries is defined as follows.	x-2381-11
First note that, given an instance I over R and a sentence σ in CALC+µ, there are three possibilities: σ is undefined on I; σ is defined on I Recursion and Negation q = {e1, .	x-2381-12
.	x-2381-13
.	x-2381-14
, en | ξ } is undefined if the application of some µ in a subformula is undefined.	x-2381-15
Otherwise the answer to q is the n-ary relation consisting of all valuations ν of e1, .	x-2381-16
.	x-2381-17
.	x-2381-18
, en for which ξ(ν(e1), .	x-2381-19
.	x-2381-20
.	x-2381-21
, ν(en)) is defined and true.	x-2381-22
The queries expressible in partial fixpoint logic are called the partial fixpoint queries.	x-2381-23
Example 14.2.3 (Add-Remove Revisited) Consider again the query in Example	x-2382-1
To distinguish the initialization step from the subsequent ones, we use a ternary relation Q where	x-2383-1
Clearly, this query is more awkward than its counterpart in while.	x-2384-1
The simulation highlights some peculiarities of computing with CALC+µ.	x-2384-2
In Section 14.4 it is shown that the family of partial fixpoint queries is equivalent to the while queries.	x-2385-1
In the preceding definition of µT (ϕ(T )), the scope of all free variables in ϕ is defined by µT .	x-2385-2
For example, if T is binary in the following then ϕ(T , x, y) has free variables x, y.	x-2385-3
According to the definition, y is not free in µT (ϕ(T , x, y))(z, w) (the free variables are z, w).	x-2385-4
Hence the quantifier ∃y applies to the y in P (y) alone and has no relation to the y in µT (ϕ(T , x, y))(z, w).	x-2385-5
To avoid confusion, it is preferable to use distinct variable names in such cases.	x-2385-6
For instance, the preceding sentence can be rewritten as	x-2385-7
Simultaneous Induction Consider the following use of nested partial fixpoint operators, where G, P , and Q are binary:	x-2386-1
Here ϕ(P , Q) involves both P and Q.	x-2387-1
This corresponds to a nested iteration.	x-2387-2
In each iteration i in the computation of {Jn}n≥0 over P , the fixpoint µQ(ϕ(P , Q)) is recomputed for the successive values Ji of P .	x-2387-3
In contrast, we now consider a generalization of the partial fixpoint that permits simultaneous iteration over two or more relations.	x-2388-1
For example, let R be a database schema and ϕ(P , Q) and ψ(P , Q) be calculus formulas using P and Q not in R, such that the arity of P (respectively Q) is the number of free variables in ϕ (ψ).	x-2388-2
On input I over R, one can define inductively the sequence {Jn}n≥0 of relations over {P , Q} as follows: J0(P ) = ∅ J0(Q) = ∅ Jn(P ) = ϕ(Jn−1(P ), Jn−1(Q)) Jn(Q) = ψ(Jn−1(P ), Jn−1(Q)).	x-2388-3
Such a mutually recursive definition of Jn(P ) and Jn(Q) is referred to as simultaneous induction.	x-2389-1
If the sequence {Jn(P ), Jn(Q)}n≥0 converges, the limit is a fixpoint of the mapping on pairs of relations defined by ϕ(P , Q) and ψ(P , Q).	x-2389-2
This pair of values for P and Q is denoted by µP,Q(ϕ(P , Q), ψ(P , Q)), and µP,Q is a simultaneous induction partial fixpoint operator.	x-2389-3
The value for P in µP,Q is denoted by µP,Q(ϕ(P , Q), ψ(P , Q))(P ) and the value for Q by µP,Q(ϕ(P , Q), ψ(P , Q))(Q).	x-2389-4
Clearly, simultaneous induction definitions like the foregoing can be extended for any number of relations.	x-2389-5
Simultaneous induction can simplify certain queries, as shown next.	x-2389-6
Example 14.2.4 (Add-Remove by Simultaneous Induction) Consider again the query Add-Remove in Example 14.2.3.	x-2390-1
One can simplify the query by introducing an auxiliary unary relation Off , which inhibits the transfer of G into T after the first step in a direct fashion.	x-2390-2
T and Off are defined in a mutually recursive fashion by ϕ Off and ϕT , respectively: Recursion and Negation	x-2390-3
The Add-Remove query can now be written as	x-2391-1
It turns out that using simultaneous induction instead of regular fixpoint operators does not provide additional power.	x-2392-1
For example, a CALC+µ formula equivalent to the query in Example 14.2.4 is the one shown in Example 14.2.3.	x-2392-2
More generally, we have the following: Lemma 14.2.5 For some n, let ϕi(R1, .	x-2392-3
.	x-2392-4
.	x-2392-5
, Rn) be CALC formulas, i in [1..n], such that µR	x-2392-6
e i i of variables or constants such that for each i,	x-2393-1
ei).	x-2394-1
Crux We illustrate the construction with reference to the query of Example 14.2.4.	x-2395-1
Instead of using two relations Off and T , we use a ternary relation Q that encodes both Off and T .	x-2395-2
The extra coordinate is used to distinguish between tuples in T and tuples in Off .	x-2395-3
Note that the use of the tuples !	x-2396-1
ei allows one to perform appropriate selections and projections on µQ(ϕ′(Q)) necessary for decoding.	x-2397-1
These selections and projections are i essential and cannot be avoided (see Exercise 14.17c).	x-2397-2
Inflationary Fixpoint The nonconvergence in some cases of the sequence {Jn}n≥0 in the semantics of the partial fixpoint operator is similar to nonterminating computations in the while language with noninflationary semantics.	x-2398-1
The semantics of the partial fixpoint operator µ is essentially noninflationary because in the inductive definition of Jn, each step is a destructive assignment.	x-2398-2
As with while, we can make the semantics inflationary by having the assignment at each step of the induction be cumulative.	x-2398-3
This yields an inflationary version of µ, denoted by µ+ and called the inflationary fixpoint operator, which is defined for all formulas and databases to which it is applied.	x-2398-4
Inflationary Fixpoint Operators and Logic The definition of µ+(ϕ(T )) is identical to T that of the partial fixpoint operator except that the sequence {Jn}n≥0 is defined as follows: J0 = ∅; Jn = Jn−1 ∪ ϕ(Jn−1), n > 0.	x-2399-1
This definition ensures that the sequence {Jn}n≥0 is increasing: Ji−1 ⊆ Ji for each i > 0.	x-2400-1
Because for each instance there are finitely many tuples that can be added, the sequence converges in all cases.	x-2401-1
The set of queries expressible by inflationary fixpoint logic is called the fixpoint queries.	x-2402-1
The fixpoint queries were historically defined first among the inflationary languages in the algebraic, logic, and deductive paradigms.	x-2402-2
Therefore the class of queries expressible in inflationary languages in the three paradigms has come to be referred to as the fixpoint queries.	x-2402-3
T Recall that datalog as presented in Chapter 12 uses an inflationary operator and yields the minimal fixpoint of a set of rules.	x-2403-1
One may also be tempted to assume that an inflationary simultaneous induction of the form µ+ (ϕ(P , Q), ψ(P , Q)) is equivalent to a system P ,Q of equational definitions of the form P = ϕ(P , Q) Q = ψ (P , Q)	x-2403-2
Example 14.2.6 Consider the equation T (x, y) CT (x, y) = ¬T (x, y).	x-2404-1
One is tempted to believe that the fixpoint of these two equations yields the complement of transitive closure.	x-2405-1
However, with the inflationary semantics Recursion and Negation J0(T ) = ∅ J0(CT ) = ∅ Jn(T ) = Jn−1(T ) ∪ {x, y | G(x, y) ∨ Jn−1(T )(x, y) Jn(CT ) = Jn−1(CT ) ∪ {x, y | ¬Jn−1(T )(x, y)} leads to saturating CT at the first iteration.	x-2405-2
Positive and Monotone Formulas Making the fixpoint operator inflationary by definition is not the only way to guarantee polynomial-time termination of the fixpoint iteration.	x-2406-1
An alternative approach is to restrict the formulas ϕ(T ) so that convergence of the sequence {Jn}n≥0 associated with µT (ϕ(T )) is guaranteed.	x-2406-2
One such restriction is monotonicity.	x-2406-3
Recall that a query q is monotone if for each I, J, I ⊆ J then q(I) ⊆ q(J).	x-2406-4
One can again show that for such formulas, a least fixpoint always exists and that it is obtained after a finite (but unbounded) number of stages of inductive applications of the formula.	x-2406-5
Unfortunately, monotonicity is an undecidable property for CALC.	x-2407-1
One can also restrict the application of fixpoint to positive formulas.	x-2407-2
This was historically the first track that was followed and presents the advantage that positiveness is a decidable (syntactic) property.	x-2407-3
It is done by requiring that T occur only positively in ϕ(T ) (i.e., under an even number of negations in the syntax tree of the formula).	x-2407-4
All formulas thereby obtained are monotone, and so µT (ϕ(T )) is always defined (see Exercise 14.10).	x-2407-5
It can be shown that the approach of inflationary fixpoint and the two approaches based on fixpoint of positive or monotone formulas are equivalent (i.e., the sets of queries expressed are identical; see Exercise 14.10).	x-2408-1
Fixpoint Operators and Circumscription In some sense, the fixpoint operators act as quantifiers on relational variables.	x-2409-1
This is somewhat similar to the well-known technique of circumscription studied in artificial intelligence.	x-2409-2
Suppose ψ(T ) is a calculus sentence (i.e., no free variables) that uses T in addition to relations from a database schema R. The circumscription of ψ(T ) with respect to T , denoted here by circ T (ψ(T )), can be thought of as an operator defining a new relation, starting from the database.	x-2409-3
More precisely, let I be an instance over R. Then circ T (ψ(T )) denotes the relation containing all tuples belonging to every relation T such that (1) ψ(T ) holds for I, and (2) T is minimal under set inclusion2 with this property.	x-2409-4
Consider now a fixpoint query.	x-2409-5
As stated earlier, fixpoint queries can be expressed using just fixpoint operators µT applied to formulas positive in T (i.e., T always appears in ϕ under an even number of negations).	x-2409-6
We claim that µT (ϕ(T )) = circ T (ϕ′(T )), where ϕ′(T ) is a sentence 2 Other kinds of minimality have also been considered.	x-2409-7
obtained from ϕ(T ) as follows:	x-2410-1
Datalog with Negation Datalog provides recursion but no negation.	x-2411-1
It defines only monotonic queries.	x-2411-2
Viewed from the standpoint of the deductive paradigm, datalog provides a form of monotonic reasoning.	x-2411-3
Adding negation to datalog rules permits the specification of nonmonotonic queries and hence of nonmonotonic reasoning.	x-2411-4
For instance, the basic assumptions in the reasoning process may require that once a fact is assumed false at some point in the inferencing process, it should not be proven true at a later point.	x-2412-1
This idea lies at the core of stratified and well-founded semantics, two of the most widely accepted in the deductive framework.	x-2412-2
The deductive point of view is considered in depth in Chapter 15.	x-2412-3
The semantics given here for datalog with negation follows the semantics given in Chapter 12 for datalog, but does not correspond directly to the semantics for nonrecursive datalog¬ given in Chapter 5.	x-2413-1
The semantics in Chapter 5 is inspired by the stratified semantics but can be simulated by (either of) the semantics presented in this chapter.	x-2413-2
Inflationary Semantics The inflationary language allows negations in bodies of rules and is denoted by datalog¬.	x-2414-1
Like datalog, its rules are used to infer a set of facts.	x-2415-1
Once a fact is inferred, it is never removed from the set of true facts.	x-2415-2
This yields the inflationary character of the language.	x-2415-3
Example 14.3.1 We present a datalog¬ program with input a graph in binary re- lation G. The program computes the relation closer(x, y, x′, y′) defined as follows: Recursion and Negation closer(x, y, x′, y′) means that the distance d(x, y) from x to y in G is smaller than the distance d(x′, y′) from x′ to y′ [d(x, y) is infinite if there is no path from x to y].	x-2416-1
T (x, y) T (x, y) closer(x, y, x′, y′) ← T (x, y), ¬T (x′, y′) The program is evaluated as follows.	x-2417-1
The rules are fired simultaneously with all applicable valuations.	x-2417-2
At each such firing, some facts are inferred.	x-2417-3
This is repeated until no new facts can be inferred.	x-2417-4
A negative fact such as ¬T (x′, y′) is true if T (x′, y′) has not been inferred so far.	x-2417-5
This does not preclude T (x′, y′) from being inferred at a later firing of the rules.	x-2417-6
One firing of the rules is called a stage in the evaluation of the program.	x-2418-1
In the preceding program, the transitive closure of G is computed in T .	x-2418-2
Consider the consecutive stages in the evaluation of the program.	x-2418-3
Note that if the fact T (x, y) is inferred at stage n, then d(x, y) = n. So if T (x′, y′) has not been inferred yet, this means that the distance between x and y is less than that between x′ and y′.	x-2418-4
Thus if T (x, y) and ¬T (x′, y′) hold at some stage n, then d(x, y) ≤ n and d(x′, y′) > n and closer(x, y, x′, y′) is inferred.	x-2418-5
The formal syntax and semantics of datalog¬ are straightforward extensions of those for datalog.	x-2419-1
A datalog¬ rule is an expression of the form where A is an atom and each Li is either an atom Bi (in which case it is called positive) or a negated atom ¬Bi (in which case it is called negative).	x-2419-2
(In this chapter we use an active domain semantics for evaluating datalog¬ and so do not require that the rules be range restricted; see Exercise 14.13.)	x-2419-3
The semantics of datalog¬ that we present in this chapter is an extension of the fixpoint semantics of datalog.	x-2420-1
Let K be an instance over sch(P ).	x-2420-2
Recall that an (active domain) instantiation of a rule A ← L1, .	x-2420-3
.	x-2420-4
.	x-2420-5
, Ln is a rule ν(A) ← ν(L1), .	x-2420-6
.	x-2420-7
.	x-2420-8
, ν(Ln), where ν is a valuation that maps each variable into adom(P , K).	x-2420-9
A fact A′ is an immediate consequence for K and P if A′ ∈ K(R) for some edb relation R, or A′ ← L′ , .	x-2420-10
.	x-2420-11
.	x-2420-12
, L′ is an instantiation 1 n of a rule in P and each positive L′ is a fact in K, and for each negative L′ = ¬A′ , A′ ∈ i i i i K. The immediate consequence operator of P , denoted ŴP , is now defined as follows.	x-2420-13
For each K over sch(P ),	x-2420-14
Given an instance I over edb(P ), one can compute ŴP (I), Ŵ2 (I), Ŵ3 (I), etc.	x-2421-1
As suggested P P in Example 14.3.1, each application of ŴP is called a stage in the evaluation.	x-2421-2
From the definition of ŴP , it follows that	x-2421-3
P steps.	x-2422-1
The restriction of this to the idb relations (or some subset thereof) is called the image (or answer) of P on I.	x-2422-2
minimal model of P containing I, as illustrated next.	x-2423-1
Example 14.3.2 Let P be the program R(0) ← Q(0), ¬R(1) R(1) ← Q(0), ¬R(0).	x-2424-1
Let I = {Q(0)}.	x-2425-1
Then P (I) = {Q(0), R(0), R(1)}.	x-2425-2
Although P (I) is a model of P , it is not minimal.	x-2425-3
The minimal models containing I are {Q(0), R(0)} and {Q(0), R(1)}.	x-2425-4
Noninflationary Semantics The language datalog¬ has inflationary semantics because the set of facts inferred through the consecutive firings of the rules is increasing.	x-2426-1
To obtain a noninflationary variant, there are several possibilities.	x-2426-2
One could keep the syntax of datalog¬ but make the semantics noninflationary by retaining, at each stage, only the newly inferred facts (see Exercise 14.16).	x-2426-3
Another possibility is to allow explicit retraction of a previously inferred fact.	x-2426-4
Syntactically, this can be done using negations in heads of rules, interpreted as deletions of facts.	x-2427-1
We adopt this solution here, in part because it brings our language closer to some practical languages that use so-called (production) rules in the sense of expert and active database systems.	x-2427-2
The resulting language is denoted by datalog¬¬, to indicate that negations are allowed in both heads and bodies of rules.	x-2427-3
Example 14.3.3 (Add-Remove Visited Again) The following datalog¬¬ program computes in T the Add-Remove query of Example 14.1.2, given as input a graph G.	x-2428-1
Recursion and Negation T (x, y) off (1) T (x, y) Relation off is used to inhibit the first rule (initializing T to G) after the first step.	x-2429-1
The immediate consequence operator ŴP and semantics of a datalog¬¬ program are analogous to those for datalog¬, with the following important proviso.	x-2430-1
If a negative literal	x-2430-2
With the semantics chosen previously, termination is no longer guaranteed.	x-2431-1
For instance, the program T (0) T (1) never terminates on input T (0).	x-2431-2
The value of T flip-flops between {0} and {1}, so no fixpoint is reached.	x-2431-3
Datalog¬¬ and Datalog¬ as Fragments of CALC+µ and CALC+µ+ Consider datalog¬¬.	x-2432-1
It can be viewed as a subset of CALC+µ in the following manner.	x-2432-2
Suppose that P is a datalog¬¬ program.	x-2433-1
The idb relations defined by rules can alternately be defined by simultaneous induction using formulas that correspond to the rules.	x-2433-2
Each firing of the rules corresponds to one step in the simultaneous inductive definition.	x-2433-3
For instance, the simultaneous induction definition corresponding to the program in Example 14.3.3 is the one in Example 14.2.4.	x-2433-4
Because simultaneous induction can be simulated in CALC+µ	x-2433-5
quantifiers).	x-2434-1
The same can be shown in the noninflationary case, although the proof is more subtle.	x-2434-2
In summary (see Exercise 14.18), the following applies: Lemma 14.3.4 Each datalog¬¬ (datalog¬) query is equivalent to a CALC+µ (CALC+µ+) query of the form	x-2434-3
x | µ(+)(ϕ(T ))(!t)}, T where	x-2435-1
x is the tuple of distinct free variables in !t.	x-2436-1
The Rule Algebra The examples of datalog¬ programs shown in this chapter make it clear that the semantics of such programs is not always easy to understand.	x-2437-1
There is a simple mechanism that facilitates the specification by the user of various customized semantics.	x-2437-2
This is done by means of the rule algebra, which allows specification of an order of firing of the rules as well as firing up to a fixpoint in an inflationary or noninflationary manner.	x-2437-3
For the inflationary version RA+ of the rule algebra, the base expressions are individual datalog¬ rules; the semantics associated with a rule is to apply its immediate consequence operator once in a cumulative fashion.	x-2437-4
Union (∪) can be used to specify simultaneous application of a pair of rules or more complex programs.	x-2437-5
The expression P ; Q specifies the composition of P and Q; its semantics is to execute P once and then Q once.	x-2437-6
Inflationary iteration of program P is called for by (P )+.	x-2437-7
The noninflationary version of the rule algebra, denoted RA, starts with datalog¬ rules, but now with a noninflationary, destructive semantics, as defined in Exercise 14.16.	x-2437-8
Union and composition are generalized in the natural fashion, and the noninflationary iterator, denoted ∗, is used.	x-2437-9
Example 14.3.5 Let P be the set of rules T (x, y) ← G(x, y) T (x, y) ← T (x, z), G(z, y) CT (x, y) ← ¬T (x, y).	x-2438-1
The RA+ program (P )+; Q computes in CT the complement of the transitive closure of G.	x-2439-1
It follows easily from the results of Section 14.4 that RA+ is equivalent to datalog¬, and RA is equivalent to noninflationary datalog¬ and hence to datalog¬¬ (Exercise 14.23).	x-2440-1
Thus an RA+ program can be compiled into a (possibly much more complicated) datalog¬ Recursion and Negation program.	x-2441-1
For instance, the RA+ program in Example 14.3.5 is equivalent to the datalog¬ program in Example 14.4.2.	x-2441-2
The advantage of the rule algebra is the ease of expressing various semantics.	x-2441-3
In particular, RA+ can be used easily to specify the stratified and well-founded semantics for datalog¬ introduced in Chapter 15.	x-2441-4
Equivalence The previous sections introduced inflationary and noninflationary recursive languages with negation in the algebraic, logic, and deductive paradigms.	x-2442-1
This section shows that the inflationary languages in the three paradigms, while+, CALC+µ+, and datalog¬, are equivalent and that the same holds for the noninflationary languages while, CALC+µ, and datalog¬¬.	x-2442-2
This yields two classes of queries that are central in the theory of query languages: the fixpoint queries (expressed by the inflationary languages) and the while queries (expressed by the noninflationary languages).	x-2443-1
This is summarized in Fig.	x-2443-2
14.2, at the end of the chapter.	x-2443-3
We begin with the equivalence of the inflationary languages because it is the more difficult to show.	x-2444-1
The equivalence of CALC+µ+ and while+ is easy because the languages have similar capabilities: Program composition in while+ corresponds closely to formula composition in CALC+µ+, and the while change loop of while+ is close to the inflationary fixpoint operator of CALC+µ+.	x-2444-2
More difficult and surprising is the equivalence of these languages with datalog¬, because this much simpler language has no explicit constructs for program composition or nested recursion.	x-2444-3
Lemma 14.4.1 CALC+µ+ and while+ are equivalent.	x-2445-1
Proof We consider first the simulation of CALC+µ+ queries by while+.	x-2446-1
Let {x1,.	x-2446-2
.	x-2446-3
.	x-2446-4
,xm | Rξ += Eξ , where Eξ is the relational algebra expression corresponding to ξ .	x-2446-5
Now suppose the statement is true for formulas with depth of nesting of the fixpoint operator less than d(d > 0).	x-2446-6
Let ξ be a formula with d(ξ ) = d.	x-2447-1
If ξ = µQ(ϕ(Q))(f1, .	x-2448-1
.	x-2448-2
.	x-2448-3
, fk), then Pξ is Q += ∅; while change do begin Eϕ; Q += Rϕ end; Rξ += π(σ (Q)), where π(σ (Q)) denotes the selection and projection corresponding to f1, .	x-2448-4
.	x-2448-5
.	x-2448-6
, fk.	x-2448-7
Suppose now that ξ is obtained by first-order operations from k formulas ξ1, .	x-2449-1
.	x-2449-2
.	x-2449-3
, ξk, each having µ+ as root.	x-2449-4
Let Eξ (Rξ , .	x-2449-5
.	x-2449-6
.	x-2449-7
, R ) be the relational algebra expression corre-1 sponding to ξ , where each subformula ξi = µQ(ϕ(Q))(ei , .	x-2449-8
.	x-2449-9
.	x-2449-10
, ei ) is replaced by R .	x-2449-11
For 1 n i i each i, let Pξ be a program that produces the value of µ i Q(ϕ(Q))(ei1 ni it into Rξ .	x-2449-12
Then P i Pξ ; .	x-2449-13
.	x-2449-14
.	x-2449-15
; P ; Rξ += Eξ (Rξ , .	x-2449-16
.	x-2449-17
.	x-2449-18
, R ).	x-2449-19
This completes the induction and the proof that CALC+µ+ can be simulated by while+.	x-2450-1
The converse simulation is similar (Exercise 14.20).	x-2451-1
We now turn to the equivalence of CALC+µ+ and datalog¬.	x-2452-1
Lemma 14.3.4 yields the subsumption of datalog¬ by CALC+µ+.	x-2452-2
For the other direction, we simulate CALC+µ+ queries using datalog¬.	x-2452-3
This simulation presents two main difficulties.	x-2452-4
The first involves delaying the firing of a rule until after the completion of a fixpoint by another set of rules.	x-2453-1
Intuitively, this is hard because checking that the fixpoint has been reached involves checking the nonexistence rather than the existence of some valuation, and datalog¬ is more naturally geared toward checking the existence of valuations.	x-2453-2
The solution to this difficulty is illustrated in the following example.	x-2453-3
Example 14.4.2 The following datalog¬ program computes the complement of the tran- sitive closure of a graph G. The example illustrates the technique used to delay the firing of a rule (computing the complement) until the fixpoint of a set of rules (computing the transitive closure) has been reached (i.e., until the application of the transitivity rule yields no new tuples).	x-2454-1
To monitor this, the relations old-T , old-T - except- final are used.	x-2454-2
old-T follows the computation of T but is one step behind it.	x-2454-3
The relation old-T - except- final is identical to old-T but the rule defining it includes a clause that prevents it from firing when T has reached its last iteration.	x-2454-4
Thus old-T and old-T - except- final differ only in the iteration after the transitive closure T reaches its final value.	x-2454-5
In the subsequent iteration, the program recognizes that the fixpoint has been reached and fires the rule computing the complement in relation CT .	x-2454-6
The program is T (x, y) T (x, y) old-T (x, y) old-T - except- final(x, y) ← T (x, y), T (x′, z′), T (z′, y′), ¬T (x′, y′) CT (x, y)	x-2454-7
Recursion and Negation The second difficulty concerns keeping track of iterations in the computation of a fixpoint.	x-2455-1
Given a formula µ+(ϕ(T )), the simulation of ϕ itself may involve numerous re-T lations other than T , whose behavior may be “sabotaged” by an overly zealous application of iteration of the immediate consequence operator.	x-2455-2
To overcome this, we separate the internal computation of ϕ from the external iteration over T , as illustrated in the following example.	x-2455-3
Example 14.4.3 Let G be a binary relation schema.	x-2456-1
Consider the CALC+µ+ query good	x-2456-2
Note that the query computes the set of nodes in G that are not reachable from a cycle (in other words, the nodes such that the length of paths leading to them is bounded).	x-2457-1
One application of ϕ( good) is achieved by the datalog¬ program P : bad(x) ← G(y, x), ¬ good(y) delay good(x) ← delay, ¬ bad(x) Simply iterating P does not yield the desired result.	x-2457-2
Intuitively, the relations delay and bad, which are used as “scratch paper” in the computation of a single iteration of µ+, cannot be reinitialized and so cannot be reused to perform the computation of subsequent iterations.	x-2457-3
To surmount this problem, we essentially create a version of P for each iteration of ϕ( good).	x-2458-1
The versions are distinguished by using “timestamps.” The nodes themselves serve as timestamps.	x-2458-2
The timestamps marking iteration i are the values newly introduced in relation good at iteration i − 1.	x-2458-3
Relations delay and delay-stamped are used to delay the derivation of new tuples in good until bad and bad-stamped (respectively) have been computed in the current iteration.	x-2458-4
The process continues until no new values are introduced in an iteration.	x-2458-5
The full program is the union of the three rules given earlier, which perform the first iteration, and the following rules, which perform the iteration with timestamp t: bad-stamped(x, t ) ← G(y, x), ¬ good(y), good(t ) delay-stamped(t ) ← good(t ) good(x)	x-2458-6
We now embark on the formal demonstration that datalog¬ can simulate CALC+µ+.	x-2459-1
We first introduce some notation relating to the timestamping of a program in the simulation.	x-2460-1
Let m ≥ 1.	x-2460-2
For each relation schema Q, let Q be a new relational schema with arity(Q) = arity(Q) + m. If (¬)Q(e1, .	x-2460-3
.	x-2460-4
.	x-2460-5
, en) is a literal and !z an m-tuple of distinct variables, then (¬)Q(e1, .	x-2460-6
.	x-2460-7
.	x-2460-8
, en)[!z] denotes the literal (¬)Q(e1, .	x-2460-9
.	x-2460-10
.	x-2460-11
, en, z1, .	x-2460-12
.	x-2460-13
.	x-2460-14
, zm).	x-2460-15
For each program P and tuple !z, P [!z] denotes the program obtained from P by replacing each literal A by A[!	x-2460-16
To illustrate the previous notation, consider the program P consisting of the following two rules: S(x, y) ← R(x, y) S(x, y) ← R(x, z), S(z, y).	x-2461-1
Then P [z] // ¬T (x, w, y) is S(x, y, z) ← R(x, y, z), ¬T (x, w, y) S(x, y, z) ← R(x, z, z), S(z, y, z), ¬T (x, w, y).	x-2462-1
Lemma 14.4.4 CALC+µ+ and datalog¬ are equivalent.	x-2463-1
Proof program as well as to produce concomitantly a predicate that only becomes true when the simulation has been completed.	x-2464-1
More precisely, we will prove by induction the following: For each CALC+µ+ formula ϕ over a database schema R, there exists a datalog¬ program prog(ϕ) whose edb relations are the relations in R, whose idb relations include result ϕ with arity equal to the number of free variables in ϕ and a 0-ary relation done ϕ such that for every instance I over R,	x-2464-2
We will assume, without loss of generality, that no variable of ϕ occurs free and bound, or bound to more than one quantifier, that ϕ contains no ∀ or ∨, and that the initial query has the form {x1, .	x-2465-1
.	x-2465-2
.	x-2465-3
, xn | ξ }, where x1, .	x-2465-4
.	x-2465-5
.	x-2465-6
, xn are distinct variables.	x-2465-7
Note that the last assumption implies that (i) establishes the desired result.	x-2465-8
Suppose now that ϕ is an atom R(!e).	x-2466-1
Let !	x-2466-2
x be the tuple of distinct variables occurring in !e.	x-2467-1
Then prog(ϕ) consists of the rules done ϕ result ϕ(!	x-2467-2
x) ← R(!	x-2468-1
e).	x-2469-1
There are four cases to consider for the induction step.	x-2470-1
x and !	x-2471-1
y be the tuples of distinct free variables of α and β, re- spectively, and let !z be the tuple of distinct free variables occurring in !	x-2472-1
x or !	x-2473-1
y.	x-2474-1
Recursion and Negation Then prog(ϕ) consists of the following rules: prog(α) prog(β) result ϕ(!z) ← done α, done β, result α(!	x-2475-1
x), result β(!	x-2476-1
y) done ϕ	x-2477-1
y be the tuple of distinct free variables of ψ, and let !	x-2478-1
obtained from !	x-2479-1
y by removing the variable x.	x-2480-1
Then prog(ϕ) consists of the rules prog(ψ) result ϕ(!z) ← done ψ, result ψ(!	x-2480-2
y) done ϕ	x-2481-1
x be the tuple of distinct free variables occurring in ψ.	x-2482-1
Then prog(ϕ) consists of prog(ψ) result ϕ(!	x-2482-2
x) ← done ψ, ¬ result ψ(!	x-2483-1
x) done ϕ	x-2484-1
Relation fixpoint ϕ contains µS(ψ(S)) at the end of the computation, and result ϕ contains µS(ψ(S))(!e).	x-2485-1
Relation run ϕ contains the timestamps.	x-2486-1
Relation used ϕ contains the timestamps introduced in the previous stages of the iteration.	x-2487-1
The active timestamps are in run ϕ − used ϕ.	x-2487-2
Relation not- final ϕ is used to detect the final iteration (i.e., the iteration that adds no new tuples to fixpoint ϕ).	x-2488-1
The presence of a timestamp in used ϕ − not - final ϕ indicates that the final iteration has been completed.	x-2488-2
Relations delay ϕ and not- empty ϕ are used for timing and to detect an empty result.	x-2489-1
In the following, !	x-2490-1
y and !t are tuples of distinct variables with the same arity as S. We first have particular rules to perform the first iteration and to handle the special case of an empty result: prog(ψ) fixpoint ϕ(!y) ← result ψ(!y), done ψ delay done ψ not-empty result ψ(!	x-2491-1
y) done ϕ	x-2492-1
The remainder of the program contains the following rules:	x-2493-1
x of distinct variables with same arity as R, R(!	x-2494-1
x, !t) ← R(!	x-2495-1
x), fixpoint ϕ(!t) run ϕ(!t) ← fixpoint ϕ(!t) S(!	x-2496-1
y, !t) ← fixpoint ϕ(!y), fixpoint ϕ(!t).	x-2497-1
prog(ψ)[!t]// run ϕ(!t), ¬ used ϕ(!t) result ϕ(!z) ← fixpoint ϕ(!e) where !z is the tuple of distinct variables in !e, done ϕ ← used ϕ(!t), ¬ not- final ϕ(!t).	x-2498-1
It is easily verified by inspection that prog(ϕ) satisfies (i) and (ii) under the induction hypothesis for cases (1) through (3).	x-2499-1
To see that (i) and (ii) hold in case (4), we carefully consider the stages in the evaluation of prog ϕ.	x-2499-2
Let I be an instance over the relations in ψ other than S; let J0 = ∅ be over S; and let Ji = Ji−1 ∪ ψ(Ji−1) for each i > 0.	x-2499-3
Then µS(ψ(S))(I) = Jn for some n such that Jn = Jn−1.	x-2500-1
The program prog ϕ simulates the consecutive iterations of this process.	x-2500-2
The first iteration is simulated using prog ψ directly, whereas the subsequent iterations are simulated by prog ψ timestamped with the tuples added at the previous iteration.	x-2500-3
(We omit consideration of the case in which the fixpoint is ∅; this is taken care of by the rules involving delay ϕ and not- empty ϕ.)	x-2500-4
Recursion and Negation We focus on the stages in the evaluation of prog ϕ corresponding to the end of the simulation of each iteration of ψ.	x-2501-1
The stage in which the simulation of the first iteration is completed immediately follows the stage in which done ψ becomes true.	x-2501-2
The subsequent iterations are completed immediately following the stages in which becomes true.	x-2501-3
Thus let k1 be the stage in which done ψ becomes true, and let ki (2 < i ≤ n) be the successive stages in which is true.	x-2501-4
First note that	x-2501-5
y | result ψ(!	x-2502-1
y)} = ψ (J0); fixpoint = J1.	x-2503-1
For i > 1 it can be shown by induction on i that	x-2504-1
y | done ψ(!t) ∧ result ψ(!	x-2505-1
y, !t) ∧ ¬ used ϕ(!t)} = ψ(Ji−1); fixpoint = Ji−1 ∪ ψ(Ji−1) = Ji, used ϕ = not-last ϕ = done ψ = Ji−1;	x-2506-1
x | R(!	x-2507-1
x, !t) ∧ run ϕ(!t) ∧ ¬ used ϕ(!t)} = I(R),	x-2508-1
x | S(!	x-2509-1
x, !t) ∧ run ϕ(!t) ∧ ¬ used ϕ(!t)} = Ji.	x-2510-1
Finally, at stage kn + 1 used ϕ = Jn−1, not-last ϕ = Jn−2, fixpoint = Jn = µS(ψ(S))(I), result ϕ = µS(ψ(S))(!z)(I), done ϕ = true.	x-2511-1
Thus (i) and (ii) hold for prog ϕ in case (4), which concludes the induction.	x-2512-1
Lemmas 14.4.1 and 14.4.4 now yield the following: Theorem 14.4.5 while+, CALC+µ+, and datalog¬ are equivalent.	x-2513-1
The set of queries expressible in while+, CALC+µ+, and datalog¬ is called the fixpoint queries.	x-2514-1
An analogous equivalence result can be proven for the noninflationary languages while, CALC+µ, and datalog¬¬.	x-2514-2
The proof of the equivalence of CALC+µ and datalog¬¬ is easier than in the inflationary case because the ability to perform deletions in datalog¬¬ facilitates the task of simulating explicit control (see Exercise 14.21).	x-2514-3
Thus we can prove the following: Theorem 14.4.6 while, CALC+µ, and datalog¬¬ are equivalent.	x-2514-4
The set of queries expressible in while, CALC+µ, and datalog¬¬ is called the while queries.	x-2515-1
We will look at the fixpoint queries and the while queries from a complexity and expressiveness standpoint in Chapter 17.	x-2515-2
Although the spirit of our discussion in this chapter suggested that fixpoint and while are distinct classes of queries, this is far from obvious.	x-2515-3
In fact, the question remains open: As shown in Chapter 17, fixpoint and while are equivalent iff ptime = pspace (Theorem 17.4.3).	x-2515-4
The equivalences among languages discussed in this chapter are summarized in Fig.	x-2516-1
14.2.	x-2516-2
Normal Forms The two equivalence theorems just presented have interesting consequences for the underlying extensions of datalog and logic.	x-2517-1
First they show that these languages are closed under composition and complementation.	x-2517-2
For instance, if two mappings f, g, respectively, from a schema S to a schema S′ and from S′ to a schema S′′ are expressible in datalog¬(¬), then f ◦ g and ¬f are also expressible in datalog¬(¬).	x-2517-3
Analogous results are true for CALC+µ(+).	x-2517-4
This yields a normal form for CALC+µ+ queries and implies that a single application of Recursion and Negation Languages Class of queries while+ inflationary CALC +µ+ fixpoint datalog¬ while noninflationary CALC +µ while datalog¬¬ Figure 14.2: Summary of language equivalence results the inflationary fixpoint operator is all that is needed.	x-2518-1
Similar remarks apply to CALC+µ queries.	x-2518-2
In summary, the following applies: Theorem 14.4.7 Each CALC+µ(+) query is equivalent to a CALC+µ(+) query of the form	x-2518-3
x | µ(+)(ϕ(T ))(!t)}, T where ϕ is an existential CALC formula.	x-2519-1
Recursion in Practical Languages To date, there are numerous prototypes (but no commercial product) that provide query and update languages with recursion.	x-2520-1
Many of these languages provide semantics for recursion in the spirit of the procedural semantics described in this chapter.	x-2520-2
Prototypes implementing the deductive paradigm are discussed in Chapter 15.	x-2520-3
SQL 2-3 (a norm provided by ISO/ANSII) allows select statements that define a table used recursively in the from and where clauses.	x-2521-1
Such recursion is also allowed in Starburst.	x-2521-2
The semantics of the recursion is inflationary, although noninflationary semantics can be achieved using deletion.	x-2522-1
An extension of SQL 2-3 is ESQL (Extended SQL).	x-2522-2
To illustrate the flavor of the syntax (which is typical for this category of languages), the following is an ESQL program defining a table SPARTS (subparts), the transitive closure of the table PARTS.	x-2522-3
This is done using a view creation mechanism.	x-2522-4
create view SPARTS as select * from PARTS union Bibliographic Notes select P1.PART, P2.COMPONENT from SPARTS P1, PARTS P2 where P1.COMPONENT = P2.PART ; This is in the spirit of CALC+µ+.	x-2523-1
With deletion, one can simulate CALC+µ.	x-2523-2
The system Postgres also provides similar iteration up to a fixpoint in its query language POSTQUEL.	x-2523-3
programs.	x-2524-1
The recursion is provided by while loops in the host language.	x-2524-2
The recursion provided by datalog¬ and datalog¬¬ is close in spirit to production-rule systems.	x-2525-1
Speaking loosely, a production rule has the form if condition then action.	x-2525-2
Production rules permit the specification of database updates, whereas deductive rules usually support only database queries (with some notable exceptions).	x-2526-1
Note that the deletion in datalog¬¬ can be viewed as providing an update capability.	x-2526-2
The production-rule approach has been studied widely in connection with expert systems in artificial intelligence; OPS5 is a well-known system that uses this approach.	x-2526-3
In active databases, the rule condition is often broken into two pieces; one piece, called the trigger, is usually closely tied to the database (e.g., based on insertions to or deletions from relations) and can be implemented deep in the system.	x-2527-1
In active database systems, rules are recursively fired when conditions become true in the database.	x-2528-1
Speaking in broad terms, the noninflationary languages studied in this chapter can be viewed as an abstraction of this behavior.	x-2528-2
For example, the database language RDL1 is close in spirit to the language datalog¬¬.	x-2528-3
(See also Chapter 22 for a discussion of active databases.)	x-2528-4
The language Graphlog, a visual language for queries on graphs developed at the University of Toronto, emphasizes queries involving paths and provides recursion specified using regular expressions that describe the shape of desired paths.	x-2529-1
Bibliographic Notes The while language was first introduced as RQ in [CH82] and as LE in [Cha81a].	x-2530-1
The other noninflationary languages, CALC+µ and datalog¬¬, were defined in [AV91a].	x-2530-2
The equivalence of the noninflationary languages was also shown there.	x-2530-3
The fixpoint languages have a long history.	x-2531-1
Logics with fixpoints have been considered by logicians in the general case where infinite structures (corresponding to infinite database instances) are allowed [Mos74].	x-2531-2
In the finite case, which is relevant in this book, the fixpoint queries were first defined using the partial fixpoint operator µT applied only to formulas positive in T [CH82].	x-2531-3
The language allowing applications of µT to formulas monotonic, but not necessarily positive, in T was further studied in [Gur84].	x-2531-4
An interesting difference between unrestricted and finite models arises here: Every CALC formula monotone in some predicate R is equivalent for unrestricted structures to some CALC formula positive in R (Lyndon’s lemma), whereas this is not the case for finite structures [AG87].	x-2531-5
Monotonicity is undecidable for both cases [Gur84].	x-2532-1
Recursion and Negation The languages (1) with fixpoint over positive formulas, (2) with fixpoint over monotone formulas, and (3) with inflationary fixpoint over arbitrary formulas were shown equivalent in [GS86].	x-2533-1
As a side-effect, it was shown in [GS86] that the nesting of µ (or µ+) provides no additional power.	x-2533-2
This fact had been proven earlier for the first language in [Imm86].	x-2533-3
Moreover, a new alternative proof of the sufficiency of a single application of the fixpoint in CALC+µ+ is provided in [Lei90].	x-2533-4
The simultaneous induction lemma (Lemma 14.2.5) was also proven in [GS86], extending an analogous result of [Mos74] for infinite structures.	x-2533-5
Of the other inflationary languages, while+ was defined in [AV90] and datalog¬ with fixpoint semantics was first defined in [AV88c, KP88].	x-2533-6
The equivalence of datalog¬ with CALC+µ+ and while+ was shown in [AV91a].	x-2534-1
The relationship between the while and fixpoint queries was investigated in [AV91b], where it was shown that they are equivalent iff ptime = pspace.	x-2534-2
The issues of complexity and expressivity of fixpoint and while queries will be considered in detail in Chapter 17.	x-2534-3
The rule algebra for logic programs was introduced in [IN88].	x-2535-1
The game of life is described in detail in [Gar70].	x-2536-1
The normal forms discussed in this chapter can be viewed as variations of well-known folk theorems, described in [Har80].	x-2536-2
SQL 2-3 is described in an ISO/ANSII norm [57391, 69392]).	x-2537-1
Starburst is presented in	x-2537-2
The area of active databases is the subject of numerous works, including [Mor83, Coh89, KDM88, SJGP90, MD89, WF90, HJ91a].	x-2538-1
Early work on database triggers includes	x-2538-2
The visual graph language Graphlog, developed at the University of Toronto, is described in [CM90, CM93a, CM93b].	x-2539-1
Exercises Exercise 14.1	x-2540-1
Exercise 14.2 Prove that the termination problem for a while program is undecidable (i.e., that it is undecidable, given a while query, whether it terminates on all inputs).	x-2541-1
Hint: Use a reduction of the containment problem for algebra queries.	x-2541-2
Exercise 14.3 Recall the datalog¬¬ program of Example 14.4.2.	x-2542-1
Exercise 14.4 Recall the definition of µT (ϕ(T )).	x-2543-1
Exercises	x-2544-1
Exercise 14.5	x-2545-1
Exercise 14.6 Consider the problem of finding, given two graphs G, G′ over the same vertex set, the minimum set X of vertexes satisfying the following conditions: (1) For each vertex v, if all vertexes v′ such that there is a G-edge from v′ to v are in X, then v is in X; and (2) the analogue for G′-edges.	x-2546-1
Exhibit a while program and a fixpoint query that compute this set.	x-2546-2
Exercise 14.7 Recall the CALC+µ+ query of Example 14.4.3.	x-2547-1
Exercise 14.9	x-2548-1
such that I(R) = J(R) and I(T ) ⊆ J(T ), ϕ(I) ⊆ ϕ(J).	x-2549-1
Recursion and Negation be a formula where T has arity n and the xi and yj are free in ϕ.	x-2550-1
Then µT ,x is a correct formula, whose free variables are the yj and those occurring among the ei.	x-2550-2
The fixpoint is defined with respect to a given valuation of the yj .	x-2550-3
For instance, is a well-formed formula.	x-2550-4
Give a precise definition of the semantics for queries using this operator.	x-2550-5
Show that this extension does not yield increased expressive power over CALC+µ+.	x-2550-6
Do the same for CALC+µ.	x-2551-1
Exercise 14.12 Let G be a graph.	x-2552-1
Give a fixpoint query in each of the three paradigms that computes the pairs of vertexes such that the shortest path between them is of even length.	x-2552-2
Exercise 14.13 Let datalog¬(¬) rr denote the family of datalog¬(¬) programs that are range restricted, in the sense that for each rule r and each variable x occurring in r, x occurs in a positive literal in the body of r. Prove that datalog¬ ≡ datalog¬ and datalog¬¬ ≡ datalog¬¬.	x-2553-1
rr rr Exercise 14.14 Show that negations in bodies of rules are redundant in datalog¬¬ (i.e., for each datalog¬¬ program P there exists an equivalent datalog¬¬ program Q that uses no negations in bodies of rules).	x-2554-1
Hint: Maintain the complement of each relation R in a new relation R′, using deletions.	x-2554-2
For a datalog¬¬ program P , let Pξ , denote the program P with semantics ξ ∈ {α, β, γ , δ}.	x-2555-1
log¬¬ ≡ datalog¬¬ ≡ datalog¬¬.	x-2556-1
Exercises Exercise 14.16	x-2557-1
where σ denotes a selection and π a projection.	x-2558-1
Exercise 14.19 Prove that the simulation in Example 14.4.3 works.	x-2559-1
Exercise 14.20 Complete the proof of Lemma 14.4.1 (i.e., prove that each while+ program can be simulated by a CALC+µ+ program).	x-2560-1
Exercise 14.22 Formulate and prove a normal form for while+ and while, analogous to the normal forms stated for CALC+µ+ and CALC+µ.	x-2561-1
Exercise 14.23 Prove that RA+ is equivalent to datalog¬ and RA is equivalent to noninflationary datalog¬, and hence to datalog¬¬.	x-2562-1
Hint: Use Theorems 14.4.5 and 14.4.6 and Exercise 14.16.	x-2562-2
Exercise 14.24 Let the star height of an RA program be the maximum number of occurrences of ∗ and + on a path in the syntax tree of the program.	x-2563-1
Show that each RA program is equivalent to an RA program of star height one.	x-2563-2
I thought we already talked about negation.	x-2564-1
Sergio: Yes, but they say you don’t think by fixpoint.	x-2565-1
Humbug, I just got used to it!	x-2566-1
Riccardo: So we have to tell you how you really think.	x-2567-1
Vittorio:	x-2568-1
This chapter begins with illustrations of how the various semantics for datalog do not naturally extend to datalog¬.	x-2569-1
Two semantics for datalog¬ are then considered.	x-2569-2
The first, called stratified, involves a syntactic restriction on programs but provides a semantics that is natural and relatively easy to understand.	x-2569-3
The second, called well founded, requires no syntactic restriction on programs, but the meaning associated with some programs is expressed using a 3-valued logic.	x-2569-4
(In this logic, facts are true, false, or unknown.)	x-2569-5
With respect to expressive power, well-founded semantics is equivalent to the fixpoint queries, whereas the stratified semantics is strictly weaker.	x-2569-6
A proof-theoretic semantics for datalog¬, based on negation as failure, is discussed briefly at the end of this chapter.	x-2569-7
The Basic Problem Suppose that we want to compute the pairs of disconnected nodes in a graph G (i.e., we are interested in the complement of the transitive closure of a graph whose edges are given by a binary relation G).	x-2570-1
We already know how to define the transitive closure of G in a relation T using the datalog program PT C of Chapter 12: T (x, y) ← G(x, y) T (x, y) ← G(x, z), T (z, y).	x-2570-2
To define the complement CT of T , we are naturally tempted to use negation as we 374 did in Chapter 5.	x-2571-1
Let PT C comp be the result of adding the following rule to PT C: CT (x, y) ← ¬T (x, y).	x-2571-2
To simplify the discussion, we generally assume an active domain interpretation of datalog¬ rules.	x-2572-1
In this example, negation appears to be an appealing addition to the datalog syntax.	x-2573-1
The language datalog¬ is defined by allowing, in bodies of rules, literals of the form	x-2574-1
One might hope to extend the model-theoretic, fixpoint, and proof-theoretic semantics of datalog just as smoothly as the syntax.	x-2575-1
Unfortunately, things are less straightforward when negation is present.	x-2575-2
We illustrate informally the problems that arise if one tries to extend the least-fixpoint and minimal-model semantics of datalog.	x-2575-3
We shall discuss the proof-theoretic aspect later.	x-2575-4
Fixpoint Semantics: Problems Recall that, for a datalog program P , the fixpoint semantics of P on input I is the unique minimal fixpoint of the immediate consequence operator TP containing I.	x-2576-1
The immediate consequence operator can be naturally extended to a datalog¬ program P .	x-2576-2
For a program P , TP is defined as follows1: For each K over sch(P ), A is TP (K) if A ∈ K| edb(P ) or if there exists some instantiation A ← A1, .	x-2576-3
.	x-2576-4
.	x-2576-5
, An of a rule in P for which (1) if Ai is a positive literal, then Ai ∈ K; and (2) if Ai = ¬Bi where Bi is a positive literal, then Bi ∈ K.	x-2576-6
Example 15.1.1	x-2577-1
P i>0 for a given datalog¬ program P .	x-2578-1
Recall that for datalog, the sequence is increasing and converges to the least fixpoint of TP .	x-2578-2
In the case of datalog¬ , the situation is more intricate:	x-2579-1
Negation in Datalog TP has a least fixpoint {p} but {T i (∅)} P i>0 alternates between ∅ and	x-2580-1
P i>0 converges, its limit is not necessarily a minimal fixpoint of TP , even if such fixpoints exist.	x-2581-1
To see this, let P4 = {p ← p, q ← q, p ← ¬p, q ← ¬p}.	x-2581-2
Now {T i (∅)} P i>0 converges to {p, q } but the least fixpoint of TP equals {p}.	x-2581-3
Remark 15.1.2 (Inflationary fixpoint semantics) The program P4 of the preceding ex-	x-2582-1
However, rules of the form R(x1, .	x-2583-1
.	x-2583-2
.	x-2583-3
, xn) ← R(x1, .	x-2583-4
.	x-2583-5
.	x-2583-6
, xn) have a nontrivial impact on the immediate consequence operator TP .	x-2583-7
If such rules are added for each idb relation R, this results in making TP inflationary [i.e., K ⊆ TP (K) for each K], because each fact is an immediate consequence of itself.	x-2583-8
It is worth noting that in this case, {T i (I)} P i>0 al- ways converges and the semantics given by its limit coincides with the inflationary fixpoint semantics for datalog¬ programs exhibited in Chapter 14.	x-2583-9
To see the difference between the two semantics, consider again program PT C comp.	x-2584-1
The sequence {T i P i>0 on input I over G converges to the desired answer (the T C comp complement of transitive closure).	x-2585-1
With the inflationary fixpoint semantics, CT becomes a complete graph at the first iteration (because T is initially empty) and PT C comp does not compute the complement of transitive closure.	x-2585-2
Nonetheless, it was shown in Chapter 14 that there is a different (more complicated) datalog¬ program that computes the complement of transitive closure with the inflationary fixpoint semantics.	x-2585-3
Model-Theoretic Semantics: Problems sentences corresponding to the rules of P .	x-2586-1
Note first that, as with datalog, P always has at least one model containing any given input I.	x-2586-2
B(P , I) is such a model.	x-2586-3
[Recall that B(P , I), introduced in Chapter 12, is the instance in which the idb relations contain all tuples with values in I or P .]	x-2586-4
For datalog, the model-theoretic semantics of a program P was given by the unique minimal model of P containing the input.	x-2586-5
Unfortunately, this simple solution no longer works for datalog¬, because uniqueness of a minimal model containing the input is not guaranteed.	x-2586-6
Program P2 in Example 15.1.1(b) provides one example of this: {p} and {q} satisfying J(G) = I .	x-2586-7
T C comp It is worth noting the connection between TP and models of P : An instance K over sch(P ) is a model of P iff TP (K) ⊆ K. In particular, every fixpoint of TP is a model of P .	x-2587-1
The converse is false (Exercise 15.3).	x-2587-2
When for a program P , P has several minimal models, one must specify which	x-2588-1
In summary, the approach we used for datalog, based on equivalent least-fixpoint or minimum-model semantics, breaks down when negation is present.	x-2589-1
We shall describe several solutions to the problem of giving semantics to datalog¬ programs.	x-2589-2
We begin with the simplest case and build up from there.	x-2589-3
Stratified Semantics This section begins with the restricted case in which negation is applied only to edb relations.	x-2590-1
The semantics for negation is straightforward in this case.	x-2590-2
We then turn to stratified semantics, which extends this simple case in an extremely natural fashion.	x-2590-3
Semipositive Datalog¬ We consider now semipositive datalog¬ programs, which only apply negation to edb relations.	x-2591-1
For example, the difference of R and R′ can be defined by the one-rule program Diff ( x) ← R(x), ¬R′(x).	x-2591-2
To give semantics to ¬R′(x), we simply use the closed world assumption (see Chapter 2):	x-2592-1
Definition 15.2.1	x-2593-1
Theorem 15.2.2 Let P be a semipositive datalog¬ program.	x-2594-1
For every instance I over edb(P ),	x-2594-2
Negation in Datalog P i>0.	x-2595-1
Remark 15.2.3 Observe that in the theorem, we use the formulation “minimal model satisfying J| edb(P ) = I,” whereas in the analogous result for datalog we used “minimal model containing I.” Both formulations would be equivalent in the datalog setting because adding tuples to the edb predicates would result in larger models because of monotonicity.	x-2596-1
This is not the case here because negation destroys monotonicity.	x-2597-1
Given a semipositive datalog¬ program P and an input I, we denote by P semi− pos(I) the minimum model of P (or equivalently, the least fixpoint of TP ) whose restriction to edb(P ) equals I.	x-2598-1
T (x, y) ← ¬G(x, y) T (x, y) ← ¬G(x, z), T (z, y).	x-2599-1
This program computes the transitive closure of the complement of G. On the other hand, the foregoing program for the complement of transitive closure is not a semipositive program.	x-2600-1
However, it can naturally be viewed as the composition of two semipositive programs: the program computing the transitive closure followed by the program computing its complement.	x-2600-2
Stratification, which is studied next, may be viewed as the closure of semipositive programs under composition.	x-2600-3
It will allow us to specify, for instance, the composition just described, computing the complement of transitive closure.	x-2600-4
Syntactic Restriction for Stratification We now consider a natural extension of semipositive programs.	x-2601-1
In semipositive programs, the use of negation is restricted to edb relations.	x-2601-2
Now suppose that we use some defined relations, much like views.	x-2601-3
Once a relation has been defined by some program, other programs can subsequently treat it as an edb relation and apply negation to it.	x-2601-4
This simple idea underlies an important extension to semipositive programs, called stratified programs.	x-2601-5
Suppose we have a datalog¬ program P .	x-2602-1
Each idb relation is defined by one or more rules of P .	x-2602-2
If we are able to “read” the program so that, for each idb relation R′, the portion of P defining R′ comes before the negation of R′ is used, then we can simply compute R′ before its negation is used, and we are done.	x-2602-3
For example, consider program PT C comp introduced at the beginning of this chapter.	x-2602-4
Clearly, we intended for T to be defined by the first two rules before its negation is used in the rule defining CT .	x-2602-5
Thus the first two rules are applied before the third.	x-2602-6
Such a way of “reading” P is called a stratification of P and is defined next.	x-2602-7
Definition 15.2.4 programs P 1, .	x-2603-1
.	x-2603-2
.	x-2603-3
, P n such that for some mapping σ from idb(P ) to [1..n], (i) {P 1, .	x-2603-4
.	x-2603-5
.	x-2603-6
, P n} is a partition of P .	x-2603-7
Given a stratification P 1, .	x-2604-1
.	x-2604-2
.	x-2604-3
, P n of P , each P i is called a stratum of the stratification, and σ is called the stratification mapping.	x-2604-4
Intuitively, a stratification of a program P provides a way of parsing P as a sequence of subprograms P 1, .	x-2605-1
.	x-2605-2
.	x-2605-3
, P n, each defining one or several idb relations.	x-2605-4
By (iii), if a relation R′ is used positively in the definition of R, then R′ must be defined earlier or simultaneously with R (this allows recursion!).	x-2605-5
If the negation of R′ is used in the definition of R, then by (iv) the definition of R′ must come strictly before that of R.	x-2605-6
Unfortunately, not every datalog¬ program has a stratification.	x-2606-1
For example, there is no way to “read” program P2 of Example 15.1.1 so that p is defined before q and q before p. Programs that have a stratification are called stratifiable.	x-2606-2
Thus P2 is not stratifiable.	x-2606-3
On the other hand, PT C comp is clearly stratifiable: The first stratum consists of the first two rules (defining T ), and the second stratum consists of the third rule (defining CT using T ).	x-2606-4
Example 15.2.5 Consider the program P7 defined by r1 S(x) ← R′1(x), ¬R(x) r2 T (x) ← R′2(x), ¬R(x) r3 U (x) ← R′3(x), ¬T (x) r4 V (x) ← R′4(x), ¬S(x), ¬U(x).	x-2607-1
Then P7 has 5 distinct stratifications, namely,	x-2608-1
These lead to five different ways of reading the program P7.	x-2609-1
As will be seen, each of these yields the same semantics.	x-2609-2
There is a simple test for checking if a program is stratifiable.	x-2610-1
Not surprisingly, it involves testing for an acyclicity condition in definitions of relations using negation.	x-2610-2
Let P be a datalog¬ program.	x-2610-3
The precedence graph GP of P is the labeled graph whose nodes are the idb relations of P .	x-2610-4
Its edges are the following: Negation in Datalog V P T CT P : P Q P : S U TC comp T Figure 15.1: Precedence graphs for PCT , P2, and P7	x-2610-5
For example, the precedence graphs for program PT C comp, P2, and P7 are represented in Fig.	x-2611-1
15.1.	x-2611-2
It is straightforward to show the following (proof omitted): Lemma 15.2.6 Let P be a program with stratification σ .	x-2611-3
If there is a path from R′ to R in GP, then σ (R′) ≤ σ (R); and if there is a path from R′ to R in GP containing some negative edge, then σ (R′) < σ (R).	x-2611-4
We now show how the precedence graph of a program can be used to test the stratifiability of the program.	x-2612-1
Proposition 15.2.7 has no cycle containing a negative edge.	x-2613-1
Proof Consider the “only if” part.	x-2614-1
Suppose P is a datalog¬ program whose precedence graph has a cycle R1, .	x-2614-2
.	x-2614-3
.	x-2614-4
Rm, R1 containing a negative edge, say from Rm to R1.	x-2614-5
Suppose, toward a contradiction, that σ is a stratification mapping for P .	x-2614-6
By Lemma 15.2.6, σ (R1) < σ (R1), because there is a path from R1 to R1 with a negative edge.	x-2614-7
This is a contradiction, so no stratification mapping σ exists for P .	x-2614-8
Conversely, suppose P is a program whose precedence graph GP has no cycle with negative edges.	x-2615-1
Let ≺ be the binary relation among the strongly connected components of GP defined as follows: C ≺ C′ if C = C′ and there is a (positive or negative) edge in GP from some node of C to some node of C′.	x-2615-2
We first show that	x-2616-1
Suppose there is a cycle in ≺.	x-2617-1
Then by construction of ≺, this cycle must traverse two distinct strongly connected components, say C, C′.	x-2617-2
Let A be in C. It is easy to deduce that there is a path in GP from some vertex in C′ to A and from A to some vertex in C′.	x-2617-3
Because C′ is a strongly connected component of GP, A is in C′.	x-2618-1
Thus C ⊆ C′, so C = C′, a contradiction.	x-2618-2
Hence (*) holds.	x-2618-3
In view of (*), the binary relation ≺ induces a partial order among the strongly connected components of GP, which we also denote by ≺, by abuse of notation.	x-2619-1
Let C1, .	x-2619-2
.	x-2619-3
.	x-2619-4
, Cn be a topographic sort with respect to ≺ of the strongly connected components of GP; that is, C1 .	x-2619-5
.	x-2619-6
.	x-2619-7
Cn is the set of strongly connected components of GP and if Ci ≺ Cj , then i ≤ j .	x-2619-8
Finally, for each i, 1 ≤ i ≤ n, let Qi consist of all rules defining some relation in Ci.	x-2619-9
Then Q1, .	x-2619-10
.	x-2619-11
.	x-2619-12
, Qn is a stratification of P .	x-2619-13
Indeed, (i) and (ii) in the definition of stratification are clearly satisfied.	x-2619-14
Conditions (iii) and (iv) follow immediately from the construction of GP and ≺ and from the hypothesis that GP has no cycle with negative edge.	x-2619-15
Clearly, the stratifiability test provided by Proposition 15.2.7 takes time polynomial in the size of the program P .	x-2620-1
Verification of the following observation is left to the reader (Exercise 15.4).	x-2621-1
Lemma 15.2.8 Let P 1, .	x-2622-1
.	x-2622-2
.	x-2622-3
, P n be a stratification of P , and let Q1, .	x-2622-4
.	x-2622-5
.	x-2622-6
, Qm be obtained as in Proposition 15.2.7.	x-2622-7
If Qj ∩ P i = ∅, then Qj ⊆ P i.	x-2622-8
In particular, the partition Q1, .	x-2622-9
.	x-2622-10
.	x-2622-11
, Qm of P refines all other partitions given by stratifications of P .	x-2622-12
Semantics of Stratified Programs Consider a stratifiable program P with a stratification σ = P 1, .	x-2623-1
.	x-2623-2
.	x-2623-3
, P n. Using the stratification σ , we can now easily give a semantics to P using the well-understood semipositive programs.	x-2623-4
Notice that for each program P i in the stratification, if P i uses the negation of R′, then R′ ∈ edb(P i) [note that edb(P i) may contain some of the idb relations of P ].	x-2623-5
Furthermore, R′ is either in edb(P ) or is defined by some P j preceding P i Ii = Ii−1 ∪ P i(Ii−1| edb(P i)), 0 < i ≤ n.	x-2623-6
Note that Ii extends Ii−1 by providing values to the relations defined by P i; and that P i(Ii−1| edb(P i)), or equivalently, P i(Ii−1), is the semantics of the semipositive program P i applied to the values of its edb relations provided by Ii−1.	x-2624-1
Let us denote the final instance In thus obtained by σ (I).	x-2624-2
This provides the semantics of a datalog¬ program under a stratification σ .	x-2624-3
Independence of Stratification	x-2625-1
Will the different stratifications yield the same semantics?	x-2626-1
Fortunately, the answer is yes.	x-2626-2
Negation in Datalog To demonstrate this, we use the following simple lemma, whose proof is left to the reader (Exercise 15.10).	x-2627-1
Lemma 15.2.9 Let P be a semipositive datalog¬ program and σ a stratification for P .	x-2628-1
Then P semi− pos(I) = σ (I) for each instance I over edb(P ).	x-2629-1
Two stratifications of a datalog¬ program are equivalent if they yield the same semantics on all inputs.	x-2630-1
Theorem 15.2.10 Let P be a stratifiable datalog¬ program.	x-2631-1
All stratifications of P are equivalent.	x-2631-2
Proof Let GP be the precedence graph of P and σG = Q1, .	x-2632-1
.	x-2632-2
.	x-2632-3
, Qn be a stratification P constructed from GP as in the proof of Theorem 15.2.7.	x-2632-4
Let σ = P 1, .	x-2632-5
.	x-2632-6
.	x-2632-7
, P k be a stratification of P .	x-2632-8
It clearly suffices to show that σ is equivalent to σG .	x-2632-9
The stratification σ P GP is used as a reference because, as shown in Lemma 15.2.8, its strata are the finest possible among all stratifications for P .	x-2632-10
We say that a sequence Qi1, .	x-2633-1
.	x-2633-2
.	x-2633-3
, Qir of some of the Qi is compatible with ≺ if for every l < m it is not the case that Qim ≺ Qil.	x-2633-4
We shall prove that P	x-2634-1
Before demonstrating these, we argue that the foregoing statements (1 through 3) are sufficient to show that σ and σG are equivalent.	x-2635-1
By statement 2, each σ P i is a stratification of P i. Lemma 15.2.9 implies that P i is equivalent to σi.	x-2635-2
It follows that σ = P 1, .	x-2635-3
.	x-2635-4
.	x-2635-5
, P k is equivalent to σ1, .	x-2635-6
.	x-2635-7
.	x-2635-8
, σk which, by statement 3, is a permutation of σG compatible with P	x-2635-9
P GP Consider statement 1.	x-2636-1
Note first that one can obtain σ ′′ from σ ′ by a sequence of exchanges of adjacent Qi, Qj such that Qi ≺ Qj and Qj ≺ Qi (Exercise 15.9).	x-2636-2
Thus it is sufficient to show that for every such pair, Qi, Qj is equivalent to Qj , Qi.	x-2636-3
Because Qi ≺ Qj and Qj ≺ Qi, it follows that no idb relation of Qi occurs in Qj and conversely.	x-2636-4
Then Qi ∪ Qj is a semipositive program [with respect to edb(Qi ∪ Qj )] and both Qi, Qj and Qj , Qi are stratifications of Qi ∪ Qj .	x-2637-1
By Lemma 15.2.9, Qi, Qj and Qj , Qi are both equivalent to Qi ∪ Qj (as a semipositive program), so Qi, Qj and Qj , Qi are equivalent.	x-2637-2
Statement 2 follows immediately from Lemma 15.2.8.	x-2638-1
Finally, consider statement 3.	x-2639-1
By statement 2, each σi is compatible with ≺.	x-2639-2
Thus it remains to be shown that, if Qm occurs in σi, Ql occurs in σj , and i < j , then Ql ≺ Qm.	x-2639-3
Note that Ql is included in P j , and Qm is included in P i.	x-2640-1
It follows that for all relations R defined by Qm and R′ defined by Ql, σ (R) < σ (R′), where σ is the stratification function of P 1, .	x-2640-2
.	x-2640-3
.	x-2640-4
, P k. Hence R′ ≺ R so Ql ≺ Qm.	x-2640-5
Thus all stratifications of a given stratifiable program are equivalent.	x-2641-1
This means that we can speak about the semantics of such a program independently of a particular stratification.	x-2641-2
Given a stratifiable datalog¬ program P and an input I over edb(P ), we shall take as the semantics of P on I the semantics σ (I) of any stratification σ of P .	x-2641-3
This semantics, well defined by Theorem 15.2.10, is denoted by P strat(I).	x-2641-4
Clearly, P strat(I) can be computed in time polynomial with respect to I.	x-2641-5
Now that we have a well-defined semantics for stratified programs, we can verify that for semipositive programs, the semantics coincides with the semantics already introduced.	x-2642-1
If P is a semipositive datalog¬ program, then P is also stratifiable.	x-2643-1
By Lemma 15.2.9, P semi− pos and P strat are equivalent.	x-2643-2
Properties of Stratified Semantics Stratified semantics has a procedural flavor because it is the result of an ordering of the rules, albeit implicit.	x-2644-1
What can we say about P strat(I) from a model-theoretic point of view?	x-2644-2
Rather pleasantly, P strat(I) is a minimal model of P containing I.	x-2644-3
However, no precise characterization of stratified semantics in model-theoretic terms has emerged.	x-2644-4
Some model-theoretic properties of stratified semantics are established next.	x-2644-5
Proposition 15.2.11 For each stratifiable datalog¬ program P and instance I over edb(I),	x-2645-1
Proof For part (a), let σ = P 1, .	x-2646-1
.	x-2646-2
.	x-2646-3
, P n be a stratification of P and I an instance over edb(P ).	x-2646-4
We have to show that P strat(I) is a minimal model of P whose restriction to edb(P ) equals I.	x-2646-5
Clearly, P strat(I) is a model of P whose restriction to edb(P ) equals I.	x-2646-6
To prove its minimality, it is sufficient to show that, for each model J of P , (**) if I ⊆ J ⊆ P strat(I) then J = P strat(I).	x-2647-1
Thus suppose I ⊆ J ⊆ P strat(I).	x-2648-1
We prove by induction on k that (†) P strat(I)| sch(∪i≤kP i) = J| sch(∪i≤kP i) for each k, 1 ≤ k ≤ n. The equality of P strat(I) and J then follows from (†) with k = n.	x-2648-2
For k = 1, edb(P 1) ⊆ edb(P ) so P strat(I)| edb(P 1) = I| edb(P 1) = J| edb(P 1).	x-2649-1
By the definition of stratified semantics and Theorem 15.2.2, P strat(I)| sch(P 1) is the Negation in Datalog minimum model of P1 whose restriction to edb(P 1) equals P strat(I)| edb(P 1).	x-2650-1
On the other hand, J| sch(P 1) is also a model of P1 whose restriction to edb(P 1) equals P strat(I)| edb(P 1).	x-2650-2
From the minimality of P strat(I)| sch(P 1), it follows that P strat(I)| sch(P 1) ⊆ J| sch(P 1).	x-2650-3
From (**) it then follows that P strat(I)| sch(P 1) = J| sch(P 1), which establishes (†) for k = 1.	x-2651-1
For the induction step, suppose (†) is true for k, 1 ≤ k < n. Then (†) for k + 1 is shown in the same manner as for the case k = 1.	x-2651-2
This proves (†) for 1 ≤ k ≤ n. It follows that P strat(I) is a minimal model of P whose restriction to edb(P ) equals I.	x-2651-3
The proof of part (b) is left for Exercise 15.12.	x-2652-1
There is another appealing property of stratified semantics that takes into account the syntax of the program in addition to purely model-theoretic considerations.	x-2653-1
This property is illustrated next.	x-2653-2
Consider the two programs P5 = {p ← ¬q} P6 = {q ← ¬p} From the perspective of classical logic, P and P6 P6 P5 whereas that of TP is {q}.	x-2654-1
This is partially captured by the notion of “supported” as follows.	x-2654-2
Let datalog¬ program P and input I be given.	x-2655-1
As with pure datalog, J is a model of P iff J ⊇ TP (J).	x-2655-2
We say that J is a supported model if J ⊆ TP (J) (i.e., if each fact in J is	x-2655-3
The proof of the following is left to the reader (Exercise 15.13).	x-2656-1
Proposition 15.2.12 For each stratifiable program P and instance I over edb(P ), P strat(I) is a supported model of P relative to I.	x-2657-1
We have seen that stratification provides an elegant and simple approach to defining semantics of datalog¬ programs.	x-2658-1
Nonetheless, it has two major limitations.	x-2658-2
First, it does not provide semantics to all datalog¬ programs.	x-2658-3
Second, stratified datalog¬ programs are not entirely satisfactory with regard to expressive power.	x-2658-4
From a computational point of view, they provide recursion and negation and are inflationary.	x-2658-5
Therefore, as discussed in Chapter 14, one might expect that they express the fixpoint queries.	x-2658-6
Unfortunately, stratified datalog¬ programs fall short of expressing all such queries, as will be shown in Section 15.4.	x-2658-7
Intuitively, this is because the stratification condition prohibits recursive	x-2658-8
For these reasons, we consider another semantics for datalog¬ programs called well founded.	x-2659-1
As we shall see, this provides semantics to all datalog¬ programs and expresses all fixpoint queries.	x-2659-2
Furthermore, well-founded and stratified semantics agree on stratified datalog¬ programs.	x-2659-3
Well-Founded Semantics Well-founded semantics relies on a fundamental revision of our expectations of the answer to a datalog¬ program.	x-2660-1
So far, we required that the answer must provide information on the truth or falsehood of every fact.	x-2660-2
Well-founded semantics is based on the idea that a given program may not necessarily provide such information on all facts.	x-2660-3
Instead some facts may simply be indifferent to it, and the answer should be allowed to say that the truth value of those facts is unknown.	x-2660-4
As it turns out, relaxing expectations about the answer in this fashion allows us to provide a natural semantics for all datalog¬ programs.	x-2660-5
The price is that the answer is no longer guaranteed to provide total information.	x-2660-6
This section begins by introducing a largely declarative semantics for datalog¬ programs.	x-2661-1
Next an equivalent fixpoint semantics is developed.	x-2661-2
Finally it is shown that stratified and well-founded semantics agree on the family of stratified datalog¬ programs.	x-2661-3
The aim of giving semantics to a datalog¬ program P will be to find an appropriate 3-valued model I of P .	x-2662-1
In considering what appropriate might mean, it is useful to recall the basic motivation underlying the logic-programming approach to negation as opposed to the purely computational approach.	x-2662-2
An important goal is to model some form of natural reasoning process.	x-2662-3
In particular, consistency in the reasoning process is required.	x-2662-4
Specifically, one cannot use a fact and later infer its negation.	x-2663-1
This should be captured in the notion of appropriateness of a 3-valued model I, and it has two intuitive aspects:	x-2663-2
Negation in Datalog Example 15.3.1 The example concerns a game with states, a, b, .	x-2664-1
.	x-2664-2
.	x-2664-3
.	x-2664-4
The game is between two players.	x-2664-5
The possible moves of the games are held in a binary relation moves.	x-2664-6
A tuple a, b in moves indicates that when in state a, one can choose to move to state b.	x-2664-7
A player loses if he or she is in a state from which there are no moves.	x-2664-8
The goal is to compute the set of winning states (i.e., the set of states such that there exists a winning strategy for a player in this state).	x-2664-9
These are obtained in a unary predicate win.	x-2664-10
Consider the input K with the following value for moves: K( moves) = {b, c, c, a, a, b, a, d, d, e, d, f , f, g} Graphically, the input is represented as b c e d f g It is seen easily that there are indeed winning strategies from states d (move to e) and f (move to g).	x-2665-1
Slightly more subtle is the fact that there is no winning strategy from any of states a, b, or c. A given player can prevent the other from winning, essentially by forcing a nonterminating sequence of moves.	x-2665-2
Now consider the following nonstratifiable program P win: win(x) ← moves(x, y), ¬ win(y) Intuitively, P win states that a state x is in win if there is at least one state y that one can move to from x, for which the opposing player loses.	x-2666-1
We now exhibit a 3-valued model J of P win that agrees with K on moves.	x-2666-2
As will be seen, this will in fact be the well-founded semantics of P win on input K. Instance J is such that J( moves) = K( moves) and the values of win-atoms are given as follows: true win(d), win(f ) false win(e), win(g) unknown win(a), win(b), win(c) We now embark on defining formally the well-founded semantics.	x-2666-3
We do this in three steps.	x-2666-4
First we define the notion of 3-valued instance and extend the notion of truth value and satisfaction.	x-2666-5
Then we consider datalog and show the existence of a minimum 3-valued model for each datalog program.	x-2666-6
Finally we consider datalog¬ and the notion of 3-stable model, which is the basis of well-founded semantics.	x-2666-7
Dealing with three truth values instead of the usual two requires extending some of the basic notions like instance and model.	x-2667-1
As we shall see, this is straightforward.	x-2667-2
We will denote true by 1, false by 0, and unknown by 1/2.	x-2667-3
Consider a datalog¬ program P and a classical 2-valued instance I.	x-2668-1
As was done in the discussion of SLD resolution in Chapter 12, we shall denote by PI the program obtained from P by adding to P unit clauses stating that the facts in I are true.	x-2668-2
Then P (I) = PI(∅).	x-2668-3
For the moment, we shall deal with datalog¬ programs such as these, whose input is included in the program.	x-2669-1
Recall that B(P ) denotes all facts of the form R(a1, .	x-2669-2
.	x-2669-3
.	x-2669-4
, ak), where R is a relation and a1, .	x-2669-5
.	x-2669-6
.	x-2669-7
, ak constants occurring in P .	x-2669-8
In particular, B(PI) = B(P , I).	x-2669-9
Let P be a datalog¬ program.	x-2670-1
A 3-valued instance I over sch(P ) is a total mapping from B(P ) to {0, 1/2, 1}.	x-2670-2
We denote by I1, I1/2, and I0 the set of atoms in B(P ) whose truth value is 1, 1/2, and 0, respectively.	x-2670-3
A 3-valued instance I is total, or 2-valued, if I1/2 = ∅.	x-2670-4
There is a natural ordering ≺ among 3-valued instances over sch(P ), defined by I ≺ J iff for each A ∈ B(P ), I(A) ≤ J(A).	x-2671-1
Note that this is equivalent to I1 ⊆ J1 and I0 ⊇ J0 and that it generalizes containment for 2-valued instances.	x-2672-1
Occasionally, we will represent a 3-valued instance by listing the positive and negative facts and omitting the undefined ones.	x-2673-1
For example, the 3-valued instance I, where I(p) =	x-2673-2
Given a 3-valued instance I, we next define the truth value of Boolean combinations of facts using the connectives ∨, ∧, ¬, ←.	x-2674-1
The truth value of a Boolean combination α of facts is denoted by ˆI(α), defined by	x-2674-2
The reader should be careful: Known facts about Boolean operators in the 2-valued context may not hold in this more complex one.	x-2675-1
For instance, note that the truth value of p ← q may be different from that of p ∨ ¬q (see Exercise 15.15).	x-2675-2
To see that the preceding definition matches the intuition, one might want to verify that with the specific semantics of ← used here, the instance J of Example 15.3.1 does satisfy (the ground instantiation of) P win, K. That would not be the case if we define the semantics of ← in a more standard way; by using p ← q ≡ p ∨ ¬q.	x-2675-3
Example 15.3.2 Recall the program P win of Example 15.3.1 and the input instance K win(a) ← moves(a, b), ¬ win(b).	x-2676-1
Negation in Datalog The first is true for J, because ˆJ(¬ win(d)) = 0, ˆJ( moves(a, d)) = 1, ˆJ( win(a)) = 1/2, and 1/2 ≥ 0.	x-2677-1
The second is true because ˆJ(¬ win(b)) = 1/2, ˆJ( moves(a, b)) = 1, ˆJ( win(a)) =	x-2677-2
Observe that, on the other hand,	x-2678-1
We next extend the definition and semantics of datalog programs to the context of 3-valued instances.	x-2679-1
Although datalog programs do not contain negation, they will now be allowed to infer positive, unknown, and false facts.	x-2679-2
The syntax of a 3-extended datalog program is the same as for datalog, except that the truth values 0, 1/2, and 1 can occur as literals in bodies of rules.	x-2680-1
Given a 3-extended datalog program P , the 3-valued immediate consequence operator 3-T P of P is a mapping on 3-valued instances over sch(P ) defined as follows.	x-2680-2
Given a 3-valued instance I and A ∈ B(P ), 3-T P (I)(A) is	x-2680-3
Example 15.3.3 Consider the 3-extended datalog program P = {p ← 1/2; p ← q, 1/2; q ← p, r; q ← p, s; s ← q; r ← 1}.	x-2681-1
Then	x-2681-2
In the following, 3-valued instances are compared with respect to ≺.	x-2682-1
Thus “least,”	x-2682-2
With the preceding definitions, extended datalog programs on 3-valued instances behave similarly to classical programs.	x-2683-1
The next lemma can be verified easily (Exercise 15.16): Lemma 15.3.4 Let P be a 3-extended datalog program.	x-2683-2
Then P i>0 is increasing and converges to the least fixpoint of 3- TP ;	x-2683-3
The semantics of an extended datalog program is the minimum 3-valued model of P .	x-2684-1
We are now ready to look at datalog¬ programs and formally define 3-stable models of a datalog¬ program P .	x-2685-1
We “bootstrap” to the semantics of programs with negation, using the semantics for 3-extended datalog programs described earlier.	x-2685-2
Let I be a 3-valued instance over sch(P ).	x-2685-3
We reduce the problem to that of applying a positive datalog program, as follows.	x-2685-4
The positivized ground version of P given I, denoted pg(P , I), is the 3-extended datalog program obtained from ground(P ) by replacing each negative premise ¬A by Î(¬A) (i.e., 0, 1, or 1/2).	x-2685-5
Because all negative literals in ground(P ) have been replaced by their truth value in I, pg(P , I) is now a 3-extended datalog program (i.e, a program without negation).	x-2685-6
Its least fixpoint pg(P , I)(⊥) contains all the facts that are consequences of P by assuming the values for the negative premises as given by I.	x-2685-7
We denote pg(P , I)(⊥) by conseq P (I).	x-2685-8
Thus the intuitive conditions required of 3-stable models now amount to conseq P (I) = I.	x-2685-9
Definition 15.3.5 Let P be a datalog¬ program.	x-2686-1
A 3-valued instance I over sch(P ) is a 3-stable model of P iff conseq P (I) = I.	x-2686-2
Observe an important distinction between conseq P and the immediate consequence operator used for inflationary datalog¬.	x-2687-1
For inflationary datalog¬, we assumed that ¬A was true as long as A was not inferred.	x-2687-2
Here we just assume in such a case that A is unknown and try to prove new facts.	x-2687-3
Of course, doing so requires the 3-valued approach.	x-2687-4
Example 15.3.6 Consider the following datalog¬ program P : p ← ¬r q ← ¬r, p s ← ¬t t ← q, ¬s u ← ¬t, p, s The program has three 3-stable models (represented by listing the positive and negative facts and leaving out the unknown facts): I1 = {p, q, t, ¬r, ¬s, ¬u} I2 = {p, q, s, ¬r, ¬t, ¬u} I3 = {p, q, ¬r} Let us check that I3 is a 3-stable model of P .	x-2688-1
The program P ′ = pg(P , I3) is Negation in Datalog p ← 1 q ← 1, p s ← 1/2 t ← q, 1/2 u ← 1/2, p, s The minimum 3-valued model of pg(P , I3) is obtained by iterating 3- TP ′(⊥) up to a fixpoint.	x-2688-2
Thus we start with ⊥ = {¬p, ¬q, ¬r, ¬s, ¬t, ¬u}.	x-2688-3
The first application of 3- TP ′ yields 3- TP ′(⊥) = {p, ¬q, ¬r, ¬t, ¬u}.	x-2688-4
Next ( 3- TP ′)2(⊥) = {p, q, ¬r, ¬t}.	x-2688-5
Finally ( 3- TP ′)3(⊥) = ( 3- TP ′)4(⊥) = {p, q, ¬r}.	x-2688-6
Thus conseq P (I3) = pg(P , I3)(⊥) = ( 3- TP ′)3(⊥) = I3, and I3 is a 3-stable model of P .	x-2688-7
The reader is invited to verify that in Example 15.3.1, the instance J is a 3-stable model of the program P win, K for the input instance K presented there.	x-2689-1
We will show later that each datalog¬ program has at least one 3-stable model.	x-2690-1
Therefore it makes sense to let the final answer consist of the positive and negative facts belonging to all 3-stable models of the program.	x-2690-2
As we shall see, the 3-valued instance so obtained is itself a 3-stable model of the program.	x-2690-3
Definition 15.3.7 Let P be a datalog¬ program.	x-2691-1
The well-founded semantics of P is the 3-valued instance consisting of all positive and negative facts belonging to all 3-stable models of P .	x-2691-2
This is denoted by P wf (∅),or simply, P wf .	x-2691-3
Given datalog¬ program P and input instance I, wf P	x-2691-4
I Thus the well-founded semantics of the program P in Example 15.3.6 is P wf (∅) = wf p, q, ¬r}.	x-2692-1
We shall see later that in Example 15.3.1, P	x-2692-2
win Note that the preceding description of the well-founded semantics, although effective, is inefficient.	x-2693-1
The straightforward algorithm yielded by this description involves checking all possible 3-valued instances of a program, determining which are 3-stable models, and then taking their intersection.	x-2693-2
We next provide a simpler, efficient way of computing the well-founded semantics.	x-2693-3
It is based on an “alternating fixpoint” computation that converges to the well-founded semantics.	x-2693-4
As a side-effect, the proof will show that each datalog¬ program has at least one 3-stable model (and therefore the well-founded semantics is always defined), something we have not proven.	x-2693-5
It will also show that the well-founded model is itself a 3-stable model, in some sense the smallest.	x-2693-6
The idea of the computation is as follows.	x-2694-1
We define an alternating sequence {Ii}i≥0 of 3-valued instances that are underestimates and overestimates of the facts known in every I0 Ii+1 = conseq P (Ii).	x-2694-2
Recall that ⊥ is the least 3-valued instance and that all facts have value 0 in ⊥.	x-2695-1
Also note that each of the Ii just defined is a total instance.	x-2695-2
This follows easily from the following facts (Exercise 15.17):	x-2695-3
The intuition behind the construction of the sequence {Ii}i≥0 is the following.	x-2696-1
The sequence starts with ⊥, which is an overestimate of the negative facts in the answer (it contains all negative facts).	x-2696-2
From this overestimate we compute I1 = conseq P (⊥), which includes all positive facts that can be inferred from ⊥.	x-2696-3
This is clearly an overestimate of the positive facts in the answer, so the set of negative facts in I1 is an underestimate of the negative facts in the answer.	x-2696-4
Using this underestimate of the negative facts, we compute I2 = conseq P (I1), whose positive facts will now be an underestimate of the positive facts in the answer.	x-2696-5
By continuing the process, we see that the even-indexed instances provide underestimates of the positive facts in the answer and the odd-indexed ones provide underestimates of the negative facts in the answer.	x-2696-6
Then the limit of the even-indexed instances provides the positive facts in the answer and the limit of the odd-indexed instances provides the negative facts in the answer.	x-2696-7
This intuition will be made formal later in this section.	x-2696-8
It is easy to see that conseq P (I) is antimonotonic.	x-2697-1
That is, if I ≺ J, then conseq P (J) ≺ conseq P (I) (Exercise 15.17).	x-2697-2
From this and the facts that ⊥ ≺ I1 and ⊥ ≺ I2, it immediately follows that, for all i > 0, I0 ≺ I2 .	x-2697-3
.	x-2697-4
.	x-2697-5
≺ I2i ≺ I2i+2 ≺ .	x-2697-6
.	x-2697-7
.	x-2697-8
≺ I2i+1 ≺ I2i−1 ≺ .	x-2697-9
.	x-2697-10
.	x-2697-11
≺ I1.	x-2697-12
Thus the even subsequence is increasing and the odd one is decreasing.	x-2698-1
Because there are finitely many 3-valued instances relative to a given program P , each of these sequences becomes constant at some point.	x-2698-2
Let I∗ denote the limit of the increasing sequence if I∗(A) = I∗(A) = 1 I∗∗(A) = 0 if I∗(A) = I∗(A) = 0 and otherwise.	x-2698-3
Equivalently, I∗∗ = (I∗)1 ∪ (I∗)0.	x-2699-1
As will be seen shortly, I∗∗ = P wf (∅).	x-2699-2
Before proving this, we illustrate the alternating fixpoint computation with several examples.	x-2699-3
Negation in Datalog Example 15.3.8 I1 = {p, q, ¬r, s, t, u}, I2 = {p, q, ¬r, ¬s, ¬t, ¬u}, I3 = {p, q, ¬r, s, t, u}, I4 = {p, q, ¬r, ¬s, ¬t, ¬u}.	x-2700-1
Thus I∗ = I4 = {p, q, ¬r, ¬s, ¬t, ¬u} and I∗ = I3 = {p, q, ¬r, s, t, u}.	x-2701-1
Finally I∗∗ = {p, q, ¬r}, which coincides with the well-founded semantics of P computed in Example 15.3.6.	x-2701-2
I1 = { win(a), win(b), win(c), win(d), ¬ win(e), win(f ), ¬ win(g)} I2 = {¬ win(a), ¬ win(b), ¬ win(c), win(d), ¬ win(e), win(f ), ¬ win(g)} I3 = I1 I4 = I2.	x-2702-1
Thus I∗ = I2 = {¬ win(a), ¬ win(b), ¬ win(c), win(d), ¬ win(e), win(f ), ¬ win(g)} I∗ = I1 = { win(a), win(b), win(c), win(d), ¬ win(e), win(f ), ¬ win(g)} I∗∗ = { win(d), ¬ win(e), win(f ), ¬ win(g)}, which is the instance J of Example 15.3.1.	x-2703-1
Consider the instance K over G and good, where K(G) K( good) = {a}.	x-2704-1
We assume that the facts of the database are added as unit clauses to P , yielding PK.	x-2705-1
Again we perform the alternating fixpoint computation for PK.	x-2705-2
We start with I0 = ⊥ (containing all negated atoms).	x-2705-3
Applying conseq P yields the following K sequence {Ii}i>0: bad I0 I1 I2 I3 I4 We have omitted [as in (b)] the facts relating to the edb predicates G and good, which do not change after step 1.	x-2705-4
Thus I∗∗ = I∗ = I∗ = I3 = I4.	x-2706-1
Note that P is stratified and its well-founded semantics coincides with its stratified semantics.	x-2706-2
As we shall see, this is not accidental.	x-2706-3
We now show that the fixpoint construction yields the well-founded semantics for datalog¬ programs.	x-2707-1
Theorem 15.3.9 For each datalog¬ program P ,	x-2708-1
Proof For statement 1, we need to show that conseq P (I∗∗) = I∗∗.	x-2709-1
We show that for every fact A, if I∗∗(A) = ǫ ∈ {0, 1/2, 1}, then conseq P (I∗∗)(A) = ǫ.	x-2709-2
From the antimonotonicity of conseq P , the fact that I∗ ≺ I∗∗ ≺ I∗ and conseq P (I∗) = I∗, conseq P (I∗) = I∗, it follows that I∗ ≺ conseq P (I∗∗) ≺ I∗.	x-2709-3
If I∗∗(A) = 0, then I∗(A) = 0 so conseq P (I∗∗)(A) = 0; similarly for I∗∗(A) = 1.	x-2709-4
Now suppose that I∗∗(A) = 1/2.	x-2709-5
It is sufficient to prove that conseq P (I∗∗)(A) ≥ We now prove that conseq P (I∗∗)(A) ≥ 1/2.	x-2709-6
By the definition of I∗∗, I∗(A) = 0 and I∗(A) = 1.	x-2709-7
Recall that conseq P (I∗) = I∗, so conseq P (I∗)(A) = 1.	x-2709-8
In addition, conseq P (I∗) is the limit of the sequence { 3- T i pg(P , I∗) i>0.	x-2709-9
Let stage(A) be the minimum i such that 3- T i pg(P , I∗) P (I∗ pose that stage(A) = 1.	x-2709-10
Then there exists in ground(P ) a rule of the form A ←, or one of the form A ← ¬B1, .	x-2709-11
.	x-2709-12
.	x-2709-13
, ¬Bn, where I∗(Bj ) = 0, 1 ≤ j ≤ n. However, the first case cannot occur, for otherwise conseq P (I∗)(A) must also equal 1 so I∗(A) = 1 and therefore I∗∗(A) = 1, contradicting the fact that I∗∗(A) = 1/2.	x-2709-14
By the same argument, I∗(Bj ) = 1, so I∗∗(Bj) = 1/2, 1 ≤ j ≤ n. Consider now pg(P , I∗∗).	x-2709-15
Because I∗∗(Bj) = Negation in Datalog pg(P , I∗) k) = 1 for each j and k. Because I∗(Bj ) = 0, I∗∗(Bj) ≤ 1/2 so I∗∗(¬Bj) ≥ 1/2.	x-2709-16
In addition, by the induction hypothesis, conseq P (I∗∗)(Ak) ≥ 1/2.	x-2709-17
It follows that conseq P (I∗∗)(A) ≥ 1/2, and the induction is complete.	x-2709-18
Thus conseq P (I∗∗) = I∗∗ and I∗∗ is a 3-stable model of P .	x-2709-19
Consider statement 2.	x-2710-1
We have to show that the positive and negative facts in I∗∗ are those belonging to every 3-stable model M of P .	x-2710-2
Because I∗∗ is itself a 3-stable model of P , it contains the positive and negative facts belonging to every 3-stable model of P .	x-2710-3
It remains to show the converse (i.e., that the positive and negative facts in I∗∗ belong to every 3-stable model of P ).	x-2710-4
To this end, we first show that for each 3-stable model M of P and i ≥ 0, I2i ≺ M ≺ I2i+1.	x-2710-5
The proof is by induction on i.	x-2711-1
For i = 0, we have I0 = ⊥ ≺ M.	x-2711-2
Because conseq P is antimonotonic, conseq P (M) ≺ conseq P (I0).	x-2712-1
Now conseq P (I0) = I1	x-2712-2
The induction step is similar and is omitted.	x-2713-1
By (‡), I∗ ≺ M ≺ I∗.	x-2714-1
Now a positive fact in I∗∗ is in I∗ and so is in M because I∗ ≺ M.	x-2714-2
Similarly, a negative fact in I∗∗ is in I∗ and so is in M because M ≺ I∗.	x-2715-1
Note that the proof of statement 2 above formalizes the intuition that the I2i provide underestimates of the positive facts in all acceptable answers (3-stable models) and the I2i+1 provide underestimates of the negative facts in those answers.	x-2716-1
The fact that P wf (∅) is a minimal model of P is left for Exercise 15.19.	x-2716-2
Variations of the alternating fixpoint computation can be obtained by starting with initial instances different from ⊥.	x-2717-1
For example, it may make sense to start with the content of the edb relations as an initial instance.	x-2717-2
Such variations are sometimes useful for technical reasons.	x-2717-3
It turns out that the resulting sequences still compute the well-founded semantics.	x-2717-4
We show the following: Proposition 15.3.10 Let P be a datalog¬ program.	x-2718-1
Let {Ii}i≥0 be defined in the same way as the sequence {Ii}i≥0, except that I0 is some total instance such that	x-2718-2
Then I0 ≺ I2 .	x-2719-1
.	x-2719-2
.	x-2719-3
≺ I2i ≺ I2i+2 ≺ .	x-2719-4
.	x-2719-5
.	x-2719-6
≺ I2i+1 ≺ I2i−1 ≺ .	x-2719-7
.	x-2719-8
.	x-2719-9
≺ I1 I∗ = P wf (∅).	x-2719-10
Proof Let us compare the sequences {Ii}i≥0 and {Ii}i≥0.	x-2720-1
Because I0 ≺ P wf (∅) and I0 is total, it easily follows that I0 ≺ I∗.	x-2720-2
Thus ⊥ = I0 ≺ I0 ≺ I∗.	x-2720-3
From the antimonotonicity of the conseq P operator and the fact that conseq 2 (I P I = conseq P (I∗) = conseq P (I∗) = I∗ so I∗ = I∗∗ = P wf (∅).	x-2720-4
Finally, the alternating fixpoint computation of the well-founded semantics involves looking at the ground rules of the given program.	x-2721-1
However, one can clearly compute the semantics without having to explicitly look at the ground rules.	x-2721-2
We show in Section 15.4 how the well-founded semantics can be computed by a fixpoint query.	x-2721-3
Well-Founded and Stratified Semantics Agree Because the well-founded semantics provides semantics to all datalog¬ programs, it does so in particular for stratified programs.	x-2722-1
Example 15.3.8(c) showed one stratified program for which stratified and well-founded semantics coincide.	x-2722-2
Fortunately, as shown next, stratified and well-founded semantics are always compatible.	x-2722-3
Thus if a program is stratified, then the stratified and well-founded semantics agree.	x-2722-4
Theorem 15.3.11 If P is a stratified datalog¬ program, then P is total under the well-founded semantics, and for each 2-valued instance I over edb(P ), P wf (I) = P strat(I).	x-2723-1
Proof Let P be stratified, and let input I0 over edb(P ) be fixed.	x-2724-1
The idea of the proof is the following.	x-2724-2
Let J be a 3-stable model of PI .	x-2724-3
We shall show that J = P strat(I 0 imply that P strat(I0) is the unique 3-stable model for PI .	x-2724-4
In particular, it contains only the 0 positive and negative facts in all 3-stable models of PI and is thus P wf (I 0	x-2724-5
For the proof, we will need to develop some notation.	x-2725-1
Notation for the stratification: Let P 1, .	x-2726-1
.	x-2726-2
.	x-2726-3
, P n be a stratification of P .	x-2726-4
Let P 0 = ∅I (i.e., 0 the program corresponding to all of the facts in I0).	x-2726-5
For each k in [0, n], let Sk = idb(P k) (S0 is edb(P )); S[0,k] = ∪i∈[0,k]Si; and Negation in Datalog Ik = (P 1 ∪ · · · ∪ P k) strat(I0) = In|S[0,k] (and, in particular, P strat(I0) = In).	x-2726-6
Notation for the 3-stable model: Let ˆ P = pg(PI , J).	x-2727-1
Recall that because J is 3-stable for 0 PI , J = conseq ˆ (J) = lim 3-T i (∅).	x-2727-2
P P For each k in [0, n], P k+1 = pg(P k+1, J	x-2728-1
J k) = pg(P k+1 k Jk J k) = pg(P k+1 k Jk cates in S[0,k].]	x-2729-1
To demonstrate the result, we will show by induction on k ∈ [0, n] that (*)	x-2729-2
P Clearly, for k = n, (*) demonstrates the result.	x-2730-1
The case where k = 0 is satisfied by setting l0 = 1, because J0 = 3-T 1+i(∅)|S P for each i ≥ 0.	x-2731-1
Suppose now that (*) is true for some k ∈ [0, n − 1].	x-2732-1
Then for each i ≥ 0, by the choice of ˆ P k+1, the form of P k+1, and (*), T i P k+1(Ik)|Sk+1 ⊆ 3-T i+1 k+1 ⊆ T i+1 k)|Sk+1.	x-2732-2
P k+1 P k+1 P k+1 k = Jk are available when applying TPk+1 the first time but are available only during the second application of 3- T ând 3- T i+1 terms may not be equal (e.g., if there is P k+1.	x-2733-1
On the other hand, the T i P k+1 P k+1	x-2733-2
By (1) and finiteness of the input, there is some m ≥ 0 such that for each i ≥ 0, (2) In|Sk+1 = T m+i (I P k+1 k)|Sk+1 = 3-T m+i k+1.	x-2734-1
P k+1 This is almost what is needed to complete the induction, except that ˆ P k+1 is used instead of ˆ P .	x-2735-1
However, observe that for each i ≥ 0, P P k+1 because 3-T i (∅)|S that for each i ≥ 0, P k+1 P because 3-T lk(∅)|S	x-2735-2
P Then for each i ≥ 0 we have k+1 ⊆ 3-T m+i+lk k+1 by (4) P k+1 P k+1 by (3) P k+1 k+1 by (2).	x-2736-1
P k+1 It follows that k+1 = 3-T m+i+lk k+1.	x-2737-1
P k+1 P Set l(k+1) = lk + m. Combining (2) and (5), we have, for each i ≥ 0, l J|S k+1 = 3-T k+1 = In|Sk+1.	x-2738-1
P Together with the inductive hypothesis, we obtain for each i ≥ 0 that l J|S P which concludes the proof.	x-2739-1
Expressive Power In this section, we examine the expressive power of datalog¬ with the various semantics for negation we have considered.	x-2740-1
More precisely, we focus on semipositive, stratified, and well-founded semantics.	x-2740-2
We first look at the relative power of these semantics and show that semipositive programs are weaker than stratified, which in turn are weaker than well founded.	x-2740-3
Then we look at the connection with languages studied in Chapter 14 that also use recursion and negation.	x-2740-4
We prove that well-founded semantics can express precisely the fixpoint queries.	x-2740-5
Finally we look at the impact of order on expressive power.	x-2741-1
An ordered database contains a special binary relation succ that provides a successor relation on all constants Negation in Datalog in the active domain.	x-2741-2
Thus the constants are ordered by succ and in fact can be viewed as integers.	x-2741-3
The impact of assuming that a database is ordered is examined at length in Chapter 17.	x-2741-4
Rather surprisingly, we show that in the presence of order, semipositive programs are as powerful as programs with well-founded semantics.	x-2741-5
In particular, all three semantics are equivalent and express precisely the fixpoint queries.	x-2741-6
We begin by briefly noting the connection between stratified datalog¬ and relational calculus (and algebra).	x-2742-1
To see that stratified datalog¬ can express all queries in CALC, recall the nonrecursive datalog¬ (nr-datalog¬) programs introduced in Chapter 5.	x-2742-2
Clearly, these are stratified datalog¬ programs in which recursion is not allowed.	x-2742-3
Theorem 5.3.10 states that nr-datalog¬ (with one answer relation) and CALC are equivalent.	x-2742-4
It follows that stratified datalog¬ can express all of CALC.	x-2742-5
Because transitive closure of a graph can be expressed in stratified datalog¬ but not in CALC (see Proposition 17.2.3), it follows that stratified datalog¬ is strictly stronger than CALC.	x-2742-6
Stratified Datalog Is Weaker than Fixpoint Let us look at the expressive power of stratified datalog¬.	x-2743-1
Computationally, stratified programs provide recursion and negation and are inflationary.	x-2743-2
Therefore one might expect that they express the fixpoint queries.	x-2743-3
It is easy to see that all stratified datalog¬ are fixpoint queries (Exercise 15.28).	x-2743-4
In particular, this shows that such programs can be evaluated in polynomial time.	x-2743-5
Can stratified datalog¬ express all fixpoint queries?	x-2743-6
Unfortunately, no.	x-2743-7
The intuitive reason is that in stratified datalog¬ there is no recursion through negation, so the number of applications of negation is bounded.	x-2744-1
In contrast, fixpoint queries allow recursion through negation, so there is no bound on the number of applications of negation.	x-2744-2
This distinction turns out to be crucial.	x-2745-1
We next outline the main points of the argument, showing that stratified datalog¬ is indeed strictly weaker than fixpoint.	x-2745-2
The proof uses a game played on so-called game trees.	x-2746-1
The game is played on a given tree.	x-2746-2
The nodes of the tree are the possible positions in the game, and the edges are the possible moves from one position to another.	x-2746-3
Additionally, some leaves of the tree are labeled black.	x-2746-4
The game is between two players.	x-2746-5
A round of the game starting at node x begins with Player I making a move from x to one of its children y.	x-2746-6
Player II then makes a move from y, etc.	x-2746-7
The game ends when a leaf is reached.	x-2746-8
Player I wins if Player II picks a black leaf.	x-2746-9
For a given tree (with labels), Player I has a winning strategy for the game starting at node x if he or she can win starting at x no matter how Player II plays.	x-2746-10
We are interested in programs determining whether there is such a winning strategy.	x-2746-11
The game tree is represented as follows.	x-2747-1
The set of possible moves is given by a binary relation move and the set of black nodes by a unary relation black.	x-2747-2
Consider the query winning (not to be confused with the predicate win of Example 15.3.1), which asks if Player I has a winning strategy starting at the root of the tree.	x-2747-3
We will define a set of game trees G such that	x-2747-4
Clearly, (ii) shows that the winning query on game trees is not definable by a stratified datalog¬ program.	x-2748-1
The set G of game trees is defined next.	x-2748-2
It consists of the Gl,k and G′l,k defined by induction as follows: in G′ .	x-2748-3
i,k i,k, and a new root di+1.	x-2749-1
The moves are the union of the moves in the copies of G′ i,k i,k together with new moves from the root di+1 to the roots of the copies.	x-2749-2
The labels remain unchanged.	x-2749-3
consists of k + 1 disjoint copies of G from which i+1,k i,k and a new root d ′i+1 moves are possible to the roots of the copies of Gi,k.	x-2750-1
The game trees G4,1 and G′ are represented in Fig.	x-2751-1
15.2.	x-2751-2
It is easy to see that winning 4,1 is true on the game trees G2i,k and false on game trees G′	x-2751-3
We first note that the query winning on game trees in G can be defined by a fixpoint query.	x-2752-1
Consider	x-2752-2
Root G 4.1 Root G′4.1 Figure 15.2: Game trees Negation in Datalog It is easy to verify that winning is defined by µT (ϕ(T ))( root), where root is the root of the game tree (Exercise 15.30).	x-2753-1
Next we note that the winning query is not expressible by any stratified datalog¬ program.	x-2753-2
To this end, we use the following result, stated without proof.	x-2753-3
Lemma 15.4.1 For each stratified datalog¬ program P , there exist i, k such that P (Gi,k)( winning) = P (G′i,k)( winning).	x-2754-1
The proof of Lemma 15.4.1 uses an extension of Ehrefeucht-Fraissé games (the games are described in Chapter 17).	x-2755-1
The intuition of the lemma is that, to distinguish between Gi,k and G′ for i and k sufficiently large, one needs to apply more negations than the i,k fixed number allowed by P .	x-2755-2
Thus no stratified program can distinguish between all the Gi,k and G′ .	x-2755-3
In particular, it follows that the fixpoint query winning is not equivalent to i,k	x-2755-4
Theorem 15.4.2 The class of queries expressible by stratified datalog¬ programs is strictly included in the fixpoint queries.	x-2756-1
Remark 15.4.3 The game tree technique can also be used to prove that the number of strata in stratified datalog¬ programs has an impact on expressive power.	x-2757-1
Specifically, let Strat i consist of all queries expressible by stratified datalog¬ programs with i strata.	x-2757-2
Then it can be shown that for all i, Strat i ⊂ Strat i+1.	x-2757-3
In particular, semipositive datalog¬ is weaker than stratified datalog¬.	x-2757-4
Well-Founded Datalog¬ Is Equivalent to Fixpoint Next we consider the expressive power of datalog¬ programs with well-founded semantics.	x-2758-1
We prove that well-founded semantics can express precisely the fixpoint queries.	x-2759-1
We begin by showing that the well-founded semantics can be computed by a fixpoint query.	x-2759-2
More precisely, we show how to compute the set of false, true, and undefined facts of the answer using a while+ program (see Chapter 14 for the definition of while+ programs).	x-2759-3
Theorem 15.4.4 Let P be a datalog¬ program.	x-2760-1
There exists a while+ program w with input relations edb(P ), such that	x-2760-2
Crux Let P be a datalog¬ program.	x-2761-1
The while+ program mimics the alternating fixpoint computation of P wf .	x-2761-2
Recall that this involves repeated applications of the operator conseq P , resulting in the sequence I0 ≺ I2 .	x-2761-3
.	x-2761-4
.	x-2761-5
≺ I2i ≺ I2i+2 ≺ .	x-2761-6
.	x-2761-7
.	x-2761-8
≺ I2i+1 ≺ I2i−1 ≺ .	x-2761-9
.	x-2761-10
.	x-2761-11
≺ I1.	x-2761-12
Recall that the Ii are all total instances.	x-2762-1
Thus 3-valued instances are only required to produce the final answer from I∗ and I∗ at the end of the computation, by one last first-order query.	x-2762-2
It is easily verified that while+ can simulate one application of conseq P on total instances (Exercise 15.27).	x-2763-1
The only delicate point is to make sure the computation is inflationary.	x-2763-2
To this end, the program w will distinguish between results of even and odd iterations of conseq P by having, for each R, an odd and even version R0 and R1 .	x-2763-3
R0 odd even odd holds at iteration 2i + 1 the negative facts of R in I2i+1, and R1 holds at iteration 2 even i the positive facts of R in I2i.	x-2763-4
Note that both R0 odd even computation.	x-2763-5
We elaborate on the simulation of the operator conseq P on a total instance I.	x-2764-1
The program w will have to distinguish between facts in the input I, used to resolve the negative premises of rules in P , and those inferred by applications of 3- TP .	x-2764-2
Therefore for each relation R, the while+ program will also maintain a copy ¯ R even and ¯ R odd to hold the facts produced by consecutive applications of 3- TP in the even and odd cases, respectively.	x-2764-3
More precisely, the ¯ R odd hold the positive facts inferred from input I2i represented in R1 , and even the ¯ R even hold the positive facts inferred from input I2i+1 represented in R0 .	x-2764-4
It is easy odd to write a first-order query defining one application of 3- TP for the even or odd cases.	x-2764-5
Because the representations of the input are different in the even and odd cases, different programs must be used in the two cases.	x-2765-1
This can be iterated in an inflationary manner, because the set of positive facts inferred in consecutive applications of 3- TP is always increasing.	x-2765-2
However, the ¯ R odd and ¯ R even have to be initialized to ∅ at each application of conseq P .	x-2765-3
Because the computation must be inflationary, this cannot be done directly.	x-2765-4
Instead, timestamping must be used.	x-2766-1
The initialization of the ¯ R odd and ¯ R even is simulated by timestamping each relation with the current content of R1 even R0 odd is done in a manner similar to the proofs of Chapter 14.	x-2766-2
We now exhibit a converse of Theorem 15.4.4, showing that any fixpoint query can essentially be simulated by a datalog¬ program with well-founded semantics.	x-2767-1
More precisely, the positive portion of the well-founded semantics yields the same facts as the fixpoint query.	x-2767-2
Example 15.4.6 illustrates the proof of this result.	x-2768-1
Theorem 15.4.5 Let q be a fixpoint query over input schema R. There exists a datalog¬ program P such that edb(P ) = R, P has an idb relation answer, and for each instance I over R, the positive portion of answer in P wf (I) coincides with q(I).	x-2769-1
Crux We will use the definition of fixpoint queries by iterations of positive first-order formulas.	x-2770-1
Let q be a fixpoint query.	x-2770-2
As discussed in Chapter 14, there exists a CALC formula ϕ(T ), positive in T , such that q is defined by µT (ϕ(T ))(u), where u is a vector of variables and constants.	x-2770-3
Consider the CALC formula ϕ(T ).	x-2770-4
As noted earlier in this section, there is an nr-datalog¬ program Pϕ with one answer relation R′ such that Pϕ is equivalent Negation in Datalog to ϕ(T ).	x-2770-5
Because ϕ(T ) is positive in T , along any path in the syntax tree of ϕ(T ) ending with atom T there is an even number of negations.	x-2770-6
This is also true of paths in GP .	x-2770-7
Consider the precedence graph GP of P each idb relation except T is used in the definition of exactly one other idb relation, and all idb relations are used eventually in the definition of the answer R′.	x-2771-1
In other words, for each idb relation R other than T , there is a unique path in GP from R to R′.	x-2771-2
Consider the ϕ paths from T to some idb relation R in Pϕ.	x-2771-3
Without loss of generality, we can assume that all paths have the same number of negations (otherwise, because all paths to T have an even number of negations, additional idb relations can be introduced to pad the paths with fewer negations, using rules that perform redundant double negations).	x-2771-4
Let the rank of an idb relation R in Pϕ be the number of negations on each path leading from T to R in GP .	x-2771-5
Now let P be the datalog¬ program obtained from Pϕ as follows:	x-2772-1
The purpose of replacing R′ by T is to cause program Pϕ to iterate, yielding µT (ϕ(T )).	x-2773-1
The last rule is added to perform the final selection and projection needed to obtain the answer µT (ϕ(T ))(u).	x-2774-1
Note that, in some sense, P is almost stratified, except for the fact that the result T is fed back into the program.	x-2774-2
Consider the alternating fixpoint sequence {Ii}i≥0 in the computation of P wf (I).	x-2775-1
Suppose R′ has rank q in Pϕ, and let R be an idb relation of Pϕ whose rank in Pϕ is r ≤ q.	x-2775-2
Intuitively, there is a close correspondence between the sequence {Ii}i≥0 and the iterations of ϕ, along the following lines: Each application of conseq P propagates the correct result from relations of rank r in Pϕ to relations of rank r + 1.	x-2776-1
There is one minor glitch, however: In the fixpoint computation, the edb relations are given, and even at the first iteration, their negation is taken to be their complement; in the alternating fixpoint computation, all negative literals, including those involving edb relations, are initially taken to be true.	x-2776-2
This results in a mismatch.	x-2776-3
To fix the problem, consider a variation of the alternating fixpoint computation of P wf (I) defined as follows: I0 Ii+1 = conseq P (Ii).	x-2776-4
Clearly, ⊥ ≺ I0 ≺ P wf (I).	x-2777-1
Then, by Proposition 15.3.10, I∗ = P wf (I).	x-2777-2
Now the following can be verified by induction for each idb relation R of rank r: For each i, (Iiq+r)1 contains exactly the facts of R true in Pϕ(ϕi(∅)).	x-2778-1
Intuitively, this is so because each application of conseq P propagates the correct result across one application of negation to an idb predicate.	x-2779-1
Because R′ has rank q, it takes q applications to simulate a complete application of Pϕ.	x-2779-2
In particular, it follows that for each i, (Iiq)1 contains in T the facts true in ϕi(∅).	x-2779-3
Thus (I∗)1 contains in T the facts true in µT (ϕ(T )).	x-2780-1
Finally answer is obtained by a simple selection and projection from T using the last rule in P and yields µT (ϕ(T ))(u).	x-2780-2
In the preceding theorem, the positive portion of answer for P wf (I) coincides with q(I).	x-2781-1
However, P wf (I) is not guaranteed to be total (i.e., it may contain unknown facts).	x-2781-2
Using a recent result (not demonstrated here), a program Q can be found such that Qwf always provides a total answer, and such that the positive facts of P wf and Qwf coincide on all inputs.	x-2782-1
Recall from Chapter 14 that datalog¬ with inflationary semantics also expresses precisely the fixpoint queries.	x-2783-1
Thus we have converged again, this time by the deductive database path, to the fixpoint queries.	x-2783-2
This bears witness, once more, to the naturalness of this class.	x-2783-3
In particular, the well-founded and inflationary semantics, although very different, have the same expressive power (modulo the difference between 3-valued and 2-valued models).	x-2783-4
Example 15.4.6 Consider the fixpoint query µ good(ϕ( good))(x), where ϕ( good) = ∀y(G(y, x) → good(y)).	x-2784-1
Recall that this query, also encountered in Chapter 14, computes the “good” nodes of the graph G (i.e., those that cannot be reached from a cycle).	x-2785-1
The nr-datalog¬ program Pϕ corresponding to one application of ϕ( good) is the one exhibited in Example 15.3.8(c): bad(x) ← G(y, x), ¬ good(y) R′(x) ← ¬ bad(x) Note that bad is negative in Pϕ and has rank one, and good is positive.	x-2785-2
The answer R′ has rank two.	x-2785-3
The program P is as follows: bad(x) good(x) Consider the input graph G = {b, c, c, b, c, d, a, d, a, e}.	x-2785-4
The consecutive values of ϕi(∅) are	x-2786-1
Thus µ good(ϕ( good))(x) yields the answer {a, e}.	x-2787-1
Consider now the alternating fixpoint sequence in the computation of P wf on the same input (only the positive facts of bad and good are listed, because G does not change and answer = good).	x-2787-2
Negation in Datalog bad good I0 I1 I2 I3 I4 I5 I6 Thus	x-2788-1
The relative expressive power of the various languages discussed in this chapter is summarized in Fig.	x-2789-1
15.3.	x-2789-2
The arrows indicate strict inclusion.	x-2789-3
For a view of these languages in a larger context, see also Figs.	x-2789-4
18.4 and 18.5 at the end of Part E.	x-2789-5
The Impact of Order Finally we look at the impact of order on the expressive power of the various datalog¬ semantics.	x-2790-1
As we will discuss at length in Chapter 17, the assumption that databases are ordered can have a dramatic impact on the expressive power of languages like fixpoint or while.	x-2790-2
The datalog¬ languages are no exception.	x-2790-3
The effect of order is spectacular.	x-2790-4
With this assumption, it turns out that semipositive datalog¬ is (almost) as powerful as stratified datalog¬ and datalog¬ with well-founded semantics.	x-2791-1
The “almost” comes from a well-founded semantics datalog¬ ≡ fixpoint semantics datalog¬ stratified datalog¬ semipositive datalog¬ datalog Figure 15.3: Relative expressive power of datalog(¬) languages technicality concerning the order: We also need to assume that the minimum and maximum constants are explicitly given.	x-2791-2
Surprisingly, these constants, which can be computed with a first order query if succ is given, cannot be computed with semipositive programs (see Exercise 15.29).	x-2791-3
The next lemma states that semipositive programs express the fixpoint queries on ordered databases with min and max (i.e., databases with a predicate succ providing a successor relation among all constants, and unary relations min and max containing the smallest and the largest constant).	x-2792-1
Lemma 15.4.7 The semipositive datalog¬ programs express precisely the fixpoint queries on ordered databases with min and max.	x-2793-1
Crux Let q be a fixpoint query over database schema R. Because q is a fixpoint query, there is a first-order formula ϕ(T ), positive in T , such that q is defined by µT (ϕ(T ))(u), where u is a vector of variables and constants.	x-2794-1
Because T is positive in ϕ(T ), we can assume that ϕ(T ) is in prenex normal form Q1x1Q2x2 .	x-2794-2
.	x-2794-3
.	x-2794-4
Qkxk(ψ), where ψ is a quantifier free formula in disjunctive normal form and T is not negated in ψ.	x-2794-5
We show by induction on k that there exists a semipositive datalog¬ program Pϕ with an idb relation answer ϕ defining µT (ϕ(T )) [the last selection and projection needed to obtain the final answer µT (ϕ(T ))(u) pose no problem].	x-2794-6
Suppose k = 0 (i.e., ϕ = ψ).	x-2794-7
Then Pϕ is the nr-datalog¬ program corresponding to ψ, where the answer relation is T .	x-2794-8
Because ψ is quantifier free and T is not negated in ψ, Pϕ is clearly semipositive.	x-2794-9
Next suppose the statement is true for some k ≥ 0, and let ϕ(T ) have quantifier depth k + 1.	x-2794-10
There are two cases: (i) ϕ = ∃xψ(x, v), where ψ has quantifier depth k. Then Pϕ contains the rules of Pψ, where T is replaced in heads of rules by a new predicate T ′ and one additional rule T (v) ← T ′(x, v).	x-2794-11
R′(x, v) ← T ′(x, v), min(x) R′(x′, v) ← R′(x, v), succ(x, x′), T ′(x′, v) T (v) where R′ is a new auxiliary predicate.	x-2795-1
Thus the program steps through all x’s using the successor relation succ, starting from the minimum constant.	x-2795-2
If the maximum constant is reached, then T ′(x, v) is satisfied for all x, and T (v) is inferred.	x-2795-3
This completes the induction.	x-2796-1
Negation in Datalog queries computable in time polynomial in the size of the database (i.e., qptime).	x-2797-1
Thus we obtain the following result.	x-2797-2
In comparing well-founded semantics with the others, we take the positive portion of the well-founded semantics as the answer.	x-2797-3
Theorem 15.4.8 Stratified datalog¬ and datalog¬ with well-founded semantics are equivalent on ordered databases and express exactly qptime.	x-2798-1
They are also equivalent to semipositive datalog¬ on ordered databases with min and max and express exactly qptime.	x-2798-2
Negation as Failure in Brief In our presentation of datalog in Chapter 12, we saw that the minimal model and least fixpoint semantics have an elegant proof-theoretic counterpart based on SLD resolution.	x-2799-1
One might naturally wonder if such a counterpart exists in the case of datalog¬.	x-2800-1
The answer is yes and no.	x-2800-2
Such a proof-theoretic approach has indeed been proposed and is called negation as failure.	x-2800-3
This was originally developed for logic programming and predates stratified and well-founded semantics.	x-2800-4
Unfortunately, the approach has two major drawbacks.	x-2800-5
The first is that it results in a proof-building procedure that does not always terminate.	x-2800-6
The second is that it is not the exact counterpart of any other existing semantics.	x-2800-7
The semantics that has been proposed as a possible match is “Clark’s completion,” but the match is not perfect and Clark’s completion has its own problems.	x-2801-1
We provide here only a brief and informal presentation of negation as failure and the related Clark’s completion.	x-2801-2
The idea behind negation as failure is simple.	x-2802-1
We would like to infer a negative fact resolution.	x-2802-2
Instead we have to use a weaker notion of negation by failure, which can be checked.	x-2802-3
This is done as follows.	x-2802-4
A fact ¬A is proven if all SLD derivations starting from the goal ← A are finite and none produces an SLD refutation for ← A.	x-2802-5
In other words, A finitely fails.	x-2802-6
This procedure applies to ground atoms A only.	x-2802-7
It gives rise to a proof procedure called SLDNF resolution.	x-2802-8
Briefly, SLDNF resolution extends SLD resolution as follows.	x-2802-9
Refutations of positive facts proceed as for SLD resolution.	x-2802-10
Whenever a negative ground goal ← ¬A has to be proven, SLD resolution is applied to ← A, and ¬A is proven if the SLD resolution finitely fails for ← A.	x-2802-11
The idea of SLDNF seems appealing as the proof-theoretic version of the closed world assumption.	x-2802-12
However, as illustrated next, it quickly leads to significant problems.	x-2802-13
Example 15.5.1 Consider the usual program P TC for transitive closure of a graph: T (x, y) ← G(x, y) T (x, y) ← G(x, z), T (z, y)	x-2803-1
Consider the instance I where G has edges {a, b, b, a, c, a}.	x-2804-1
Clearly, {a, c} is not in the transitive closure of G, and so not in T , by the usual datalog semantics.	x-2804-2
Suppose we wish to prove the fact ¬T (a, c), using negation as failure.	x-2804-3
We have to show that SLD resolution finitely fails on T (a, c), with the preceding program and input.	x-2804-4
Unfortunately, SLD resolution can enter a negative loop when applied to ← T (a, c).	x-2804-5
One obtains the following SLD derivation:	x-2804-6
Note that the last goal is the same as the first, so this can be extended to an infinite derivation.	x-2805-1
It follows that SLD resolution does not finitely fail on ← T (a, c), so SLDNF does not yield a proof of ¬T (a, c).	x-2805-2
Moreover, it has been shown that this does not depend on the particular program used to define transitive closure.	x-2805-3
In other words, there is no datalog¬ program that under SLDNF can prove the positive and negative facts true of the transitive closure of a graph.	x-2805-4
The preceding example shows that SLDNF can behave counterintuitively, even in some simple cases.	x-2806-1
The behavior is also incompatible with all the semantics for negation that we have discussed so far.	x-2806-2
Thus one cannot hope for a match between SLDNF and these semantics.	x-2806-3
Instead a semantics called Clark’s completion has been proposed as a candidate match for negation as failure.	x-2807-1
It works as follows.	x-2807-2
For a datalog¬ program P , the completion of P, comp(P), is constructed as follows.	x-2807-3
For each idb predicate R, each rule ρ : R(u) ← L1(v1), .	x-2807-4
.	x-2807-5
.	x-2807-6
, Ln(vn) defining R is rewritten so there is a uniform set of distinct variables in the rule head and so all free variables in the body are existentially quantified:	x-2807-7
l	x-2808-1
Intuitively, this states that ground atom R(w) is true iff it is supported by one of the rules defining R. Finally the completion of P is the set of completions of all idb predicates of P , along with the axioms of equality, if needed.	x-2809-1
Negation in Datalog The semantics of P is now defined by the following: A is true iff it is a logical consequence of comp(P ).	x-2810-1
A first problem now is that comp(P ) is not always consistent; in fact, its consistency is undecidable.	x-2810-2
What is the connection between SLDNF and Clark’s completion?	x-2810-3
Because SLDNF is consistent (it clearly cannot prove A and ¬A) and comp(P ) is not so always, SLDNF is not always complete with respect to comp(P ).	x-2810-4
For consistent comp(P ), it can be shown that SLDNF resolution is sound.	x-2810-5
However, additional conditions must be imposed on the datalog¬ programs for SLDNF resolution to be complete.	x-2810-6
Consider again the transitive closure program P TC and input instance I of Example 15.5.1.	x-2811-1
Then the completion of T is equivalent to T (x, y) ↔ G(x, y) ∨ ∃z(G(x, z) ∧ T (z, y)).	x-2811-2
Note that neither T (a, c) nor ¬T (a, c) are consequences of comp(P TC, I).	x-2812-1
In summary, negation as failure does not appear to provide a convincing proof-theoretic counterpart to the semantics we have considered.	x-2813-1
The search for more successful proof-theoretic approaches is an active research area.	x-2813-2
Other proposals are described briefly in the Bibliographic Notes.	x-2813-3
Bibliographic Notes The notion of a stratified program is extremely natural.	x-2814-1
Not surprisingly, it was proposed independently by quite a few investigators [CH85, ABW88, Lif88, VanG86].	x-2814-2
The independence of the semantics from a particular stratification (Theorem 15.2.10) was shown in	x-2814-3
Research on well-founded semantics, and the related notion of a 3-stable model, has its roots in investigations of stable and default model semantics.	x-2815-1
Although formulated somewhat differently, the notion of a stable/default model is equivalent to that of a total 3-stable model [Prz90].	x-2815-2
Stable model semantics was introduced in [GL88], and default model semantics was introduced in [BF87, BF88].	x-2815-3
Stable semantics is based on Moore’s autoepistemic logic [Moo85], and default semantics is based on Reiter’s default logic	x-2815-4
Several equivalent definitions of the well-founded semantics have been proposed.	x-2816-1
The definition used in this chapter comes from [Prz90].	x-2816-2
The alternating fixpoint computation we described is essentially the same as in [VanG89].	x-2816-3
Alternative procedures for computing the well-founded semantics are exhibited in [BF88, Prz89].	x-2816-4
Historically, the first definition of well-founded semantics was proposed in [VanGRS88, VanGRS91].	x-2816-5
This is described in Exercise 15.24.	x-2816-6
The fact that well-founded and stratified semantics agree on stratifiable datalog¬ programs (Theorem 15.3.11) was shown in [VanGRS88].	x-2817-1
Both the stratified and well-founded semantics were originally introduced for general logic programming, as well as the more restricted case of datalog.	x-2818-1
In the context of logic programming, both semantics have expressive power equivalent to the arithmetic hierarchy	x-2818-2
The result that datalog¬ with well-founded semantics expresses exactly the fixpoint Bibliographic Notes queries is shown in [VanG89].	x-2819-1
Citation [FKL87] proves that for every datalog¬ program P there is a total datalog¬ program Q such that the positive portions of P wf (I) and Qwf (I) coincide for every I.	x-2819-2
The fact that stratified datalog¬ is weaker than fixpoint, and therefore weaker than well-founded semantics, was shown in [Kol91], making use of earlier results from [Dal87] and [CH82].	x-2819-3
In particular, Lemma 15.4.1 is based on Lemma 3.9 in [CH82].	x-2819-4
The result that semipositive datalog¬ expresses qptime on ordered databases with min and max is due to [Pap85].	x-2820-1
The investigation of negation as failure was initiated in [Cla78], in connection with general logic programming.	x-2821-1
In particular, SLDNF resolution as well as Clark’s completion are introduced there.	x-2821-2
The fact that there is no datalog¬ program for which the positive and negative facts about the transitive closure of the graph can be proven by SLDNF resolution was shown in [Kun88].	x-2821-3
Other work related to Clark’s completion can be found in [She88, Llo87, Fit85, Kun87].	x-2821-4
Several variations of SLDNF resolutions have been proposed.	x-2822-1
SLS resolution is introduced in [Prz88] to deal with stratified programs.	x-2822-2
An exact match is achieved between stratified semantics and the proof procedure provided by SLS resolution.	x-2822-3
Although SLS resolution is effective in the context of (finite) databases, it is not so when applied to general logic programs, with function symbols.	x-2822-4
To deal with this shortcoming, several restrictions of SLS resolution have been proposed that are effective in the general framework [KT88, SI88].	x-2822-5
Several proof-theoretic approaches corresponding to the well-founded semantics have been proposed.	x-2823-1
SLS resolution is extended from stratified to arbitrary datalog¬ programs in [Prz88], under well-founded semantics.	x-2823-2
Independently, another extension of SLS resolution called global SLS resolution is proposed in [Ros89], with similar results.	x-2823-3
These proposals yield noneffective resolution procedures.	x-2823-4
An effective procedure is described in	x-2823-5
In [SZ90], an interesting connection between nondeterminism and stable models of a program (i.e., total 3-stable models; see also Exercise 15.20) is pointed out.	x-2824-1
Essentially, it is shown that the stable models of a datalog¬ program can be viewed as the result of a natural nondeterministic choice.	x-2824-2
This uses the choice construct introduced earlier in [KN88].	x-2824-3
Another use of nondeterminism is exhibited in [PY92], where an extension of well-founded semantics is provided, which involves the nondeterministic choice of a fixpoint of a datalog¬ program.	x-2824-4
This is called tie-breaking semantics.	x-2824-5
A discussion of nondeterminism in deductive databases is provided in [GPSZ91].	x-2824-6
There are a few prototypes (but no commercial system) implementing stratified datalog¬.	x-2825-1
The language LDL [NT89, BNR+87, NK88] implements, besides the stratified semantics for datalog¬, an extension to complex objects (see also Chapter 20).	x-2825-2
The implementation uses heuristics based on the magic set technique described in Chapter 13.	x-2825-3
The language NAIL!	x-2826-1
(Not Yet Another Implementation of Logic!	x-2826-2
), developed at Stanford, is another implementation of the stratified semantics, allowing function symbols and a set construct.	x-2826-3
The implementation of NAIL!	x-2826-4
[MUG86, Mor88] uses a battery of evaluation techniques, including magic sets.	x-2826-5
The language EKS [VBKL89], developed at Negation in Datalog ECRC (European Computer-Industry Research Center) in Munich, implements the stratified semantics and extensions allowing quantifiers in rule bodies, aggregate functions, and constraint specification.	x-2826-6
The CORAL system [RSS92, RSSS93] provides a database programming language that supports both imperative and deductive capabilities, including stratification.	x-2826-7
An implementation of well-founded semantics is described in [CW92].	x-2826-8
Nicole Bidoit’s survey on negation in databases [Bid91b], as well as her book on datalog [Bid91a], provided an invaluable source of information and inspired our presentation of the topic.	x-2827-1
Exercises Exercise 15.1	x-2828-1
Exercise 15.2 Consider the datalog¬ program P3 = {p ← ¬r; r ← ¬p; p ← ¬p, r}.	x-2829-1
Verify that TP has a least fixpoint, but T does not converge when starting on ∅.	x-2829-2
P3 Exercise 15.3	x-2830-1
Exercise 15.4 Prove Lemma 15.2.8.	x-2831-1
Exercise 15.5 Consider a database for the Parisian metro and bus lines, consisting of two relations Metro[ Station, Next-Station] and Bus[ Station, Next-Station].	x-2832-1
Write stratifiable datalog¬ programs to answer the following queries.	x-2832-2
Exercises Exercise 15.6 The semantics of stratifiable datalog¬ programs can be extended to infinite databases as follows.	x-2833-1
Let P be a stratifiable datalog¬ program and let σ = P 1 .	x-2833-2
.	x-2833-3
.	x-2833-4
P n be a stratification for P .	x-2833-5
For each (finite or infinite) instance I over edb(P ), σ (I) is defined similarly to the finite case.	x-2833-6
More precisely, consider the sequence I0 = I Ii = P i(Ii−1| edb(P i)) where j P i(Ii−1| edb(P i)) = ∪j>0T (I P i−1| edb(P i )).	x-2833-7
i Note that the definition is now noneffective because P i(Ii−1| edb(P i)) may be infinite.	x-2834-1
Consider a database consisting of one binary relation succ providing a successor relation on an infinite set of constants.	x-2835-1
Clearly, one can identify these constants with the positive integers.	x-2835-2
Exercise 15.7 Prove Theorem 15.2.2.	x-2836-1
Exercise 15.8	x-2837-1
Exercise 15.9 Let (A, <) be a partially ordered set.	x-2838-1
A listing a1, .	x-2838-2
.	x-2838-3
.	x-2838-4
, an of the elements in A is compatible with < iff for i < j it is not the case that aj < ai.	x-2838-5
Let σ ′, σ ′′ be listings of A compatible with <.	x-2838-6
Prove that one can obtain σ ′′ from σ ′ by a sequence of exchanges of adjacent elements al, am such that al < am and am < al.	x-2838-7
Exercise 15.10 Prove Lemma 15.2.9.	x-2839-1
Exercise 15.11 such that sch(P1) = sch(P2), $P ≡ $ , and there is a minimal model I of $ such that I is a P2 P1 supported model for P1, but not for P2.	x-2840-1
(In other words, the notion of supported model depends not only on $P , but also on the syntax of P .)	x-2840-2
Exercise 15.12 Prove part (b) of Proposition 15.2.11.	x-2841-1
Exercise 15.13 Prove Proposition 15.2.12.	x-2842-1
Negation in Datalog	x-2843-1
Exercise 15.15 Let α and β be propositional Boolean formulas (using ∧, ∨, ¬, →).	x-2844-1
Prove the following:	x-2844-2
Exercise 15.16 Prove Lemma 15.3.4.	x-2845-1
Exercise 15.17 Let P be a datalog¬ program.	x-2846-1
Recall the definition of positivized ground version of P given I, denoted pg(P , I), where I is a 3-valued instance.	x-2846-2
Prove the following: (a) If I is total, then pg(P , I) is total.	x-2846-3
I0 Ii+1 = pg(P , Ii)(⊥) = conseq P (Ii).	x-2847-1
Prove that I0 ≺ I2 · · · ≺ I2i ≺ I2i+2 ≺ · · · ≺ I2i+1 ≺ I2i−1 ≺ · · · ≺ I1.	x-2848-1
Exercise 15.18 Exhibit a datalog¬ program that yields the complement of the transitive closure under well-founded semantics.	x-2849-1
Exercise 15.19 Prove that for each datalog¬ program P and instance I over edb(P ), P wf (I) is a minimal 3-valued model of P whose restriction to edb(P ) equals I.	x-2850-1
Exercises Exercise 15.22 Give an example of a datalog¬ program P such that P is not stratified but P wf is total.	x-2851-1
program P is always total.	x-2852-1
That is, it is undecidable whether, for each instance I over wf edb(P ), P is total.	x-2852-2
I	x-2853-1
The immediate consequence operator TP of P is extended to operate on sets of (positive and negative) ground literals as follows.	x-2854-1
Let I be a set of ground literals.	x-2854-2
TP (I) consists of all literals A for which there is a ground rule of P , A ← L1, .	x-2854-3
.	x-2854-4
.	x-2854-5
, Lk, such that Li ∈ I for each i.	x-2854-6
Note that TP can produce an inconsistent set of literals, which therefore does not correspond to a 3-valued model.	x-2854-7
Now let I be a set of ground literals and J a set of positive ground literals.	x-2854-8
J is said to be an unfounded set of P with respect to I if for each A ∈ J and ground rule r of P with A in the head, at least one of the following holds:	x-2854-9
Intuitively, this means that if all atoms of I are assumed true and all atoms in J are assumed false, then no atom of J is true under one application of TP .	x-2855-1
Let the greatest unfounded set of P with respect to I be the union of all unfounded sets of P with respect to I, denoted UP (I).	x-2856-1
Next consider the operator WP on sets of ground literals defined by WP (I) = TP (I) ∪ ¬.UP (I).	x-2856-2
Prove the following:	x-2857-1
P P is the immediate consequence operator on sets of ground literals defined in Exercise 15.24.	x-2858-1
Furthermore, P (I) denotes the complement of P (I) [i.e., B(P , I) − P (I)].	x-2858-2
Consider the sequence of sets of negative facts defined by N0 Ni+1 = ¬.P (¬.P (Ni)).	x-2858-3
The intuition behind the definition is the following.	x-2859-1
N0 is an underestimate of the set of negative facts in the well-founded model.	x-2859-2
Then P (N) is an underestimate of the positive facts, and the negated complement ¬.P (N) is an overestimate of the negative facts.	x-2859-3
Using this overestimate, one can infer an overestimate of the positive facts, P (¬.P (N)).	x-2859-4
Therefore ¬.P (¬.P (N)) is now a new underestimate of the negative facts containing the previous underestimate.	x-2859-5
So {Ni}i≥0 is Negation in Datalog	x-2859-6
Exercise 15.26 Let P be a datalog¬ program.	x-2860-1
Let TP be the immediate consequence operator on sets of ground literals, defined in Exercise 15.24, and let ¯ TP be defined by ¯ TP (I) = I ∪ TP (I).	x-2860-2
Given a set I of ground literals, let P (I) denote the limit of the increasing sequence { ¯ T i (I)} P i>0.	x-2861-1
is maximally consistent with respect to P if it is maximal among the sets of negative literals consistent with P .	x-2862-1
Investigate the connection between maximal consistency, 3-stable models, and well-founded semantics:	x-2862-2
Exercise 15.27 Refer to the proof of Lemma 15.4.4.	x-2863-1
Exercise 15.28 Show that every query definable by stratified datalog¬ is a fixpoint query.	x-2864-1
Exercise 15.29 Consider an ordered database (i.e., with binary relation succ providing a successor relation on the constants).	x-2865-1
Prove that the minimum and maximum constants cannot be computed using a semipositive program.	x-2865-2
for i > 0.	x-2866-1
P A R T E Expressivenessand Complexity Various query languages were presented in Parts B and D. Simple languages like conjunctive queries were successively augmented with various constructs such as union, negation, and recursion.	x-2867-1
The primary motivation for defining increasingly powerful languages was the need to express useful queries not captured by the simpler languages.	x-2867-2
In the presentation, the process was primarily example driven.	x-2867-3
The following chapters present a more advanced and global perspective on query languages.	x-2867-4
In addition to their ability to express specific queries, we consider more broadly the capability of languages to express queries of a given complexity.	x-2867-5
This leads to establishing formal connections between languages and complexity classes of queries.	x-2867-6
This approach lies on the border between databases, complexity theory, and logic.	x-2867-7
It is related to characterizations of complexity classes in terms of various logics.	x-2867-8
The basic framework for the formal development is presented in Chapter 16, in which we discuss the notion of a query and produce a formal definition.	x-2868-1
It turns out that it is relatively easy to define languages expressing all queries.	x-2868-2
Such languages are called complete.	x-2868-3
However, the real challenge for the language designer is not simply to define increasingly powerful languages.	x-2868-4
Instead an important aspect of language design is to achieve a good balance between expressiveness and the complexity of evaluating queries.	x-2868-5
The ideal language would allow expression of most useful queries while guaranteeing that all queries expressible in the language can be evaluated with reasonable complexity.	x-2869-1
To formalize this, we raise the following basic question: How does one evaluate a query language with respect to expressiveness and complexity?	x-2869-2
In an attempt to answer this question, we discuss the issue of sizing up languages in Chapter 16.	x-2869-3
Chapter 17 considers some of the classes of queries discussed in Part B from the viewpoint of expressiveness and complexity.	x-2870-1
The focus is on the relational calculus of Chapter 5 and on its extensions fixpoint and while defined in Chapter 14.	x-2870-2
We show the connection of these languages to complexity classes.	x-2870-3
Several techniques for showing the nonexpressibility of queries are also presented, including games and 0-1 laws.	x-2870-4
Chapter 17 also explores the intriguing theoretical implications of one of the basic assumptions of the pure relational model—namely, that the underlying domain dom consists of uninterpreted, unordered elements.	x-2871-1
This assumption can be viewed as a metaphor for the data independence principle, because it implies using only logical properties of data as 415 Expressiveness and Complexity opposed to the underlying implementation (which would provide additional information, such as an order).	x-2871-2
Chapter 18 presents highly expressive (and complex) languages, all the way up to complete languages.	x-2872-1
In particular, we discuss constructs for value invention, which are similar to the object creation mechanisms encountered in object languages (see Chapter 21).	x-2872-2
For easy reference, the expressiveness and complexity of relational query languages are summarized at the end of Chapter 18.	x-2873-1
Do you ever worry about how hard it is to answer queries?	x-2874-1
Riccardo: Sure — my laptop can only do conjunctive queries.	x-2875-1
Sergio: I can do the while queries on my Sun.	x-2876-1
Vittorio: I don’t worry about it — I have a Cray in my office.	x-2877-1
This chapter lays the groundwork for the study of the complexity and expressiveness of query languages.	x-2878-1
First the notion of query is carefully reconsidered and formally defined.	x-2878-2
Then, the complexity of individual queries is considered.	x-2878-3
Finally definitions that allow comparison of query languages and complexity classes are developed.	x-2878-4
Queries The goal of Part E is to develop a general understanding of query languages and their capabilities.	x-2879-1
The first step is to formulate a precise definition of what constitutes a query.	x-2879-2
The focus is on a fairly high level of abstraction and thus on the mappings expressible by queries rather than on the syntax used to specify them.	x-2880-1
Thus, unlike Part B, in this part we use the term query primarily to refer to mappings from instances to instances rather than to syntactic objects.	x-2880-2
Although there are several correct definitions for the set of permissible queries, the one presented here is based on three fundamental assumptions: well-typedness, computability, and genericity.	x-2880-3
The first assumption involves the schemas of the input and the answer to a query.	x-2881-1
A query is over a particular database schema, say R. It takes as input an instance over R	x-2881-2
Because we are only interested in effective queries, we also make the natural assumption that query mappings are computable.	x-2882-1
Query computability is defined using classical models of computation, such as Turing machines (TM).	x-2882-2
The basic idea is that the query must be “implementable” by a TM.	x-2882-3
Thus there must exist a TM that, given as input a natural encoding of a database instance on the tape, produces an encoding of the output.	x-2882-4
The formalization of these notions requires some care and is done next.	x-2882-5
Sizing Up Languages P Q b c c b P[0#1][1#0]Q[10#10] Figure 16.1: The first question in developing the formalization is, How can input and output instances be represented on a TM tape that has finite alphabet when the underlying domain dom is infinite?	x-2883-1
We resolve this by using standard encodings for dom.	x-2883-2
As we shall see later on, although this permits us to use conventional complexity theory in our study of query language expressiveness, it also takes us a bit outside of the pure relational model.	x-2883-3
We focus on encodings of both dom and of subsets of dom, and we use the symbols 0	x-2884-1
We can now describe the encoding of instances.	x-2885-1
Suppose that a set d ⊆ dom, enumeration α for d, source schema R = {R1, .	x-2885-2
.	x-2885-3
.	x-2885-4
, Rm}, and target schema S are given.	x-2885-5
The encoding of instances of R uses the alphabet {0, 1, [, ], #} ∪ R ∪ {S}.	x-2885-6
An instance I over R with adom(I) ⊆ d is encoded relative to α as follows: 1. enc α(a1, .	x-2885-7
.	x-2885-8
.	x-2885-9
, ak) is [ enc α(a1)# .	x-2885-10
.	x-2885-11
.	x-2885-12
# enc α(ak)].	x-2885-13
Example 16.1.1 Let R = {P , Q}, I be the instance over R in Fig.	x-2886-1
16.1(a), and let α =	x-2886-2
Let α be a fixed enumeration of dom.	x-2887-1
In this case the encoding enc α described earlier is one-to-one on instances and thus has an inverse enc−1 when considered as a mapping α on instances.	x-2887-2
We are now ready to formalize the notion of computability relative to an encoding of dom.	x-2887-3
Definition 16.1.2 Let α be an enumeration of dom.	x-2888-1
A mapping q from inst(R) to inst(S) is computable relative to α if there exists a TM M such that for each instance I over R	x-2888-2
representation, the extra information consists primarily of the enumeration α of constants necessary to define enc α.	x-2889-1
In the pure relational model, this kind of information is not part of the database.	x-2889-2
Instead, the database is an abstraction of its internal (or TM) representation.	x-2889-3
This additional information can be viewed as noise associated with the internal representation and thus should not have any visible impact for the user at the conceptual level.	x-2890-1
This is captured by the data independence principle in databases, which postulates that a database provides an abstract interface that hides the internal representation of data.	x-2890-2
We can now state the intuition behind the third and last requirement of queries, which formalizes the data independence principle.	x-2891-1
Although computations performed on the internal representation may take advantage of all information provided at this level, it is explicitly prohibited, in the definition of a query, that the result depend on such information.	x-2891-2
The property that a query depends only on information provided by the input instance is called genericity and is formalized next.	x-2892-1
The idea is that the constants in the database have no properties other than the relationships with each other specified by the database.	x-2892-2
Definition 16.1.3 Let R and S be database schemas, and let C be a finite set of constants.	x-2893-1
A mapping q from inst(R) to inst(S) is C-generic iff for each I over R and each permutation ρ of dom that is the identity on C, ρ(q(I)) = q(ρ(I)).	x-2893-2
When C is empty, we simply say that the query is generic.	x-2893-3
Sizing Up Languages The previous definition is best visualized using the following commuting diagram: q I q(I) q	x-2894-1
In other words, a query is C-generic if it commutes with permutations (that leave C fixed).	x-2895-1
Genericity states that the query is insensitive to renaming of the constants in the database (using the permutation ρ).	x-2896-1
It uses only the relationships among constants provided by the database and is independent of any other information about the constants.	x-2896-2
The set C specifies the exceptional constants named explicitly in the query.	x-2896-3
These cannot be renamed without changing the effect of the query.	x-2896-4
Permutations ρ for which ρ(I) = I are of special interest.	x-2897-1
Such ρ are called automorphisms for I.	x-2897-2
If ρ is an automorphism for I and ρ(a) = b, this says intuitively that a and b cannot be distinguished using the structure of I.	x-2897-3
Let q be a generic query, I an instance, and ρ an automorphism for I.	x-2897-4
Then, by genericity, so ρ is also an automorphism for q(I).	x-2897-5
In particular, a generic query cannot distinguish between constants that are undistinguishable in the input (see Exercise 16.5).	x-2897-6
Of course, this is not the case if the query explicitly names some constants.	x-2897-7
We illustrate these various aspects of genericity in an example.	x-2898-1
Example 16.1.4 Consider a database over a binary relation G holding the edges of a directed graph.	x-2899-1
Let I be the instance {a, b, b, a, a, c, b, c}.	x-2899-2
Let σ be the CALC query	x-2900-1
Note that σ (I) = {a, b}.	x-2901-1
Let ρ be the permutation defined by ρ(a) = b, ρ(b) = c, and ρ(c) = d. Then ρ(I) = {b, c, c, b, b, d, c, d}.	x-2901-2
Genericity requires that σ (ρ(I)) =	x-2901-3
Note also that a and b are undistinguishable in I.	x-2902-1
Formally, the renaming ρ defined by ρ(a) = b, ρ(b) = a, and ρ(c) = c has the property that ρ(I) = I and thus is an automorphism of I.	x-2902-2
Let q be a generic query on G. By genericity of q, either a and b both belong to q(I), or neither does.	x-2902-3
Thus a generic query cannot distinguish between a and b.	x-2902-4
Of course, this is not true for C-generic queries (for C nonempty).	x-2902-5
For instance, let qb = π1(σ2=b(G)).	x-2902-6
Now qb is {b}-generic, and qb(I) = {a}.	x-2903-1
Thus qb distinguishes between a and b.	x-2903-2
It is easily verified that if a database mapping q is C-generic, then for each input instance I, adom(q(I)) ⊆ C ∪ adom(I) (see Exercise 16.1).	x-2904-1
In most cases we will ignore the issue of constants in queries because it is not central.	x-2905-1
Note that a C-generic query can be viewed as a generic query by including the constants in C in the input, using one relation for each constant.	x-2906-1
For instance, the {b}-generic query qb over G in Example 16.1.4 is reduced to a generic query q′ over {G, Rb}, where Rb = {b}, defined as follows: q′ = π1(σ2=3(G × Rb)).	x-2906-2
In the following, we will usually assume that queries have no constants unless explicitly stated.	x-2907-1
Suppose now that α and β are two enumerations of dom and that a generic mapping q from R to S is computed by a TM M using enc α.	x-2908-1
It is easily verified that the same query is computed by M if enc β is used in place of enc α (see Exercise 16.2).	x-2908-2
This permits us to adopt the following notion of computable, which is equivalent to “computable relative to enumeration α” in the case of generic queries.	x-2908-3
This definition has the advantage of relying on finite rather than infinite enumerations.	x-2908-4
Definition 16.1.5	x-2909-1
We are now ready to define queries formally.	x-2910-1
Definition 16.1.6 Let R be a database schema and S a relation schema.	x-2911-1
A query from R to S is a partial mapping from inst(R) to inst(S) that is generic and computable.	x-2911-2
Note that all queries discussed in previous chapters satisfy the preceding definition (modulo constants in queries).	x-2912-1
Queries and Query Languages We are usually interested in queries specified by the expressions (i.e., syntactic queries or programs) of a given query language.	x-2913-1
Given an expression E in query language L, the mapping between instances that E describes is called the effect of E. Depending on the language, there may be several alternative semantics (e.g., inflationary versus noninflationary) for defining the query expressed by an expression.	x-2913-2
A related issue concerns the specification of the output schema of an expression.	x-2913-3
In calculus-based languages, the output schema is unambiguously specified by the form of the expression.	x-2913-4
The situation is more ambiguous for other languages, such as datalog and while.	x-2913-5
Programs in these languages typically manipulate several relations and may not specify explicitly which is to be taken as the answer to the query.	x-2913-6
In such cases, the concepts of input, output, and temporary relations may become important.	x-2913-7
Thus, in addition to semantically significant input and output relations, the programs may use temporary relations whose content is immaterial outside the Sizing Up Languages computation.	x-2913-8
We will state explicitly which relations are temporary and which constitute the output whenever this is not clear from the context.	x-2913-9
We will discuss such languages in Chapter 18.	x-2914-1
Complexity of Queries We now develop a framework for measuring the complexity of queries.	x-2915-1
This is done by reference to TMs and classical complexity classes defined using the TM model.	x-2915-2
There are several ways to look at the complexity of queries.	x-2916-1
They differ in the parameters with respect to which the complexity is measured.	x-2916-2
The two main possibilities are as follows:	x-2916-3
Thus in the data complexity perspective, the complexity is with respect to the database input and the query is considered constant.	x-2917-1
Conversely, with expression complexity, the database input is fixed and the complexity is with respect to the size of the query expression.	x-2917-2
Clearly, the measures provide different information about the complexity of evaluating queries.	x-2918-1
The usual situation is that the size of the database input dominates by far the size of the query, and so data complexity is typically most relevant.	x-2918-2
This is the primary focus of Part E, and we use the term complexity to refer to data complexity unless otherwise stated.	x-2918-3
The complexity of queries is defined based on the recognition problem associated with the query.	x-2919-1
For a query q, the recognition problem is as follows: Given an instance I and a tuple u, determine if u belongs to the answer q(I).	x-2919-2
To be more precise, the recognition problem of a query q is the language	x-2919-3
The ( data) complexity of q is the (conventional) complexity of its recognition problem.	x-2920-1
Technically, the complexity is with respect to the size of the input [i.e., the length of the word enc α(I)# enc α(u)].	x-2921-1
Because for an instance I the size (number of tuples) in I is closely related to the length of enc α(I) (see Exercise 16.12), the size of I is usually taken as the measure of the input.	x-2921-2
For each Turing time or space complexity class c, one can define a corresponding complexity class of queries, denoted by qc .	x-2922-1
The class of queries qc consists of all queries whose recognition problem is in c. For example, the class qptime consists of all queries for which the recognition problem is in ptime.	x-2922-2
There is another way to define the complexity of queries that is based on the complexity of actually constructing the result of the query rather than the recognition problem for individual tuples.	x-2923-1
The two definitions are in most cases interchangeable (see Exercise 16.13).	x-2923-2
In particular, for complexity classes insensitive to a polynomial factor, the definitions are equivalent.	x-2923-3
In general, the definition based on constructing the result distinguishes between a query with a large answer and one with a small answer, which is irrelevant to the definition based on recognition.	x-2923-4
On the other hand, the definition based on constructing the result may not distinguish between easy and hard queries with large results.	x-2923-5
Example 16.2.1 Consider a database consisting of one binary relation G and the three queries cross, path, and self on G defined as follows: cross(G) = π1(G) × π2(G), path(G) = {x, y | x and y are connected by a path in G}, self (G) = G.	x-2924-1
Consider first cross and path.	x-2925-1
Both have potentially large answers, but cross is clearly easier than path, even though the time complexity of constructing the result is O(n2) for both cross and path.	x-2925-2
The time complexity of the recognition problem is O(n) for cross and O(n2) for path.	x-2925-3
Thus the measure based on constructing the result does not detect a difference between cross and path, whereas this is detected by the complexity of the recognition problem.	x-2925-4
Next consider cross and self .	x-2925-5
The time complexity of the recognition problem is in both cases O(n), but the complexity of computing the result is O(n) for self whereas it is O(n2) for cross.	x-2925-6
Thus the complexity of the recognition problem does not distinguish between cross and self , although cross can potentially generate a much larger answer.	x-2925-7
This difference is detected by the complexity of constructing the result.	x-2925-8
In Part E, we will use the definition of query complexity based on the associated recognition problem.	x-2926-1
Languages and Complexity In the previous section we studied a definition of the complexity of an individual query.	x-2927-1
To measure the complexity of a query language L, we need to establish a correspondence between	x-2928-1
Expressiveness with Respect to Complexity Classes The most straightforward connection between L and a class of queries qc is when L and qc are precisely the same.1 In this case, it is said that L expresses qc.	x-2929-1
In every case, each query in L has complexity c, and conversely L can express every query of complexity c.	x-2929-2
Sizing Up Languages Ideally, one would be able to perform complexity-tailored language design; that is, for a desired complexity c, one would design a language expressing precisely qc.	x-2930-1
Unfortunately, we will see that this is not always possible.	x-2930-2
In fact, there are no such results for the pure relational model for complexity classes of polynomial time and below, that are of most interest.	x-2930-3
We consider this phenomenon at length in the next chapter.	x-2930-4
Intuitively, the shapes of classes of queries of low complexity do not match those of classes of queries defined by any known language.	x-2930-5
Therefore we are led to consider a less straightforward way to match languages to complexity classes.	x-2930-6
Completeness with Respect to Complexity Classes Consider a language L that does not correspond precisely to any natural complexity class of queries.	x-2931-1
Nonetheless we would like to say something about the complexity of queries in L. For instance, we may wish to guarantee that all queries in L lie within some complexity class c, even though L may not express all of qc.	x-2931-2
For the bound to be meaningful, we would also like that c is, in some sense, a tight upper bound for the complexity of queries in L. In other words, L should be able to express at least some queries that are among the hardest in qc.	x-2931-3
The property of a problem being hardest in a complexity class c is captured, in complexity theory, by the notion of completeness of the problem in the class (see Chapter 2).	x-2931-4
By extension to a language, this leads to the following: Definition 16.3.1	x-2931-5
In some sense, completeness without expressiveness says something negative about the language L. L can express some queries that are as hard as any query in qc; on the other hand, there may be easy queries in qc that are not expressible in L. This may at first appear contradictory because L expresses some queries that are complete in c, and any problem in c can be reduced to the complete problem.	x-2932-1
However, there is no contradiction.	x-2932-2
The reduction of the “easy” query to the complete query may be computationally easy but nevertheless not expressible in L. Examples of this situation involve the familiar languages fixpoint and while.	x-2933-1
As will be shown in Section 17.3, these languages are complete in ptime and pspace, respectively.	x-2933-2
However, neither can express the simple parity query on a unary relation R: even(R) = true if |R| is even, and false otherwise.	x-2933-3
Bibliographic Notes Complexity and Genericity To conclude this chapter, we consider the delicate impact of genericity on complexity.	x-2934-1
The foregoing query even illustrates a fundamental phenomenon relating genericity to the complexity of queries.	x-2935-1
As stated earlier, even cannot be computed by fixpoint or by while, both of which are powerful languages.	x-2935-2
The difficulty in computing even is due to the lack of information about the elements of the set.	x-2935-3
Because the database only provides a set of undifferentiated elements, genericity implies that they are treated uniformly in queries.	x-2935-4
This rules out the straightforward solution of repeatedly extracting one arbitrary element from the set until the set is empty while keeping a binary counter: How does one specify the first element to be extracted?	x-2936-1
On the other hand, consider the problem of computing even with a TM.	x-2937-1
The additional information provided by the encoding of the input on the tape makes the problem trivial and allows a linear-time solution.	x-2937-2
This highlights the interesting fact that genericity may complicate the task of computing a query, whereas access to the internal representation may simplify this task considerably.	x-2938-1
Thus this suggests a trade-off between genericity and complexity.	x-2938-2
This can be formalized by defining complexity classes based on a computing device that is generic by definition in place of a TM.	x-2938-3
Such a device cannot take advantage of the representation of data in the same manner as a TM, and it treats data generically at all points in the computation.	x-2938-4
It can be shown that even is hard with respect to complexity measures based on such a device.	x-2938-5
The query even will be used repeatedly to illustrate various aspects of the complexity of queries.	x-2938-6
Bibliographic Notes The study of computable queries originated in the work of Chandra and Harel [CH80b, Cha81a, CH82].	x-2939-1
In addition to well-typed languages, they also considered languages defining queries with data-dependent output schemas.	x-2939-2
The data and expression complexity of queries were introduced and studied in [CH80a, CH82] and further investigated in	x-2939-3
The notion of genericity was formalized in [AU79, CH80b] with different terminology.	x-2940-1
The term C-genericity was first used in [HY84].	x-2941-1
Other notions related in spirit to genericity are studied in [Hul86].	x-2941-2
The definition of genericity is extended in [AK89] to object-oriented queries that can produce new constants in the result (arising from new object identifiers); see also [VandBGAG92, HY90].	x-2941-3
This is further discussed in Chapters 18 and 21.	x-2941-4
Sizing Up Languages complexity classes of queries and to investigate the trade-off between genericity and complexity.	x-2942-1
Informative discussions of the connection between query languages and complexity classes are provided in [Gur84, Gur88, Imm87b, Lei89a].	x-2943-1
Exercises Exercise 16.1 Let q be a C-generic mapping.	x-2944-1
Show that, for each input instance I, adom(q(I))	x-2944-2
Exercise 16.2 (Genericity) Let q be a generic database mapping from R to S.	x-2945-1
Prove that for each instance I over R, enc α ◦ M ◦ enc−1 =	x-2946-1
enc β ◦ M ◦ enc−1 Conclude that M computes q using enc β.	x-2947-1
Exercise 16.4 In many practical situations the underlying domains used (e.g., strings, integers) have some structure (e.g., an ordering relationship that is visible to both user and implementation).	x-2948-1
For each of the following, develop a natural definition for generic and exhibit a nongeneric query, if there is one.	x-2948-2
Exercise 16.5 Let q be a C-generic query, and let I be an input instance.	x-2949-1
Let ρ be an automorphism of I that is the identity on C, and let a, b be constants in I, such that ρ(a) = b.	x-2949-2
Show that a occurs in q(I) iff b occurs in q(I).	x-2949-3
The next several exercises use the following notions.	x-2950-1
Let R be a database schema.	x-2950-2
Let k be a positive integer and I an instance over R. 8I denotes the set of k-tuples that can be formed k using just constants in I.	x-2950-3
Define the following relation ≡I on 8I : u ≡I v iff there exists an k k k	x-2950-4
k Exercises Exercise 16.6	x-2951-1
k k	x-2952-1
k	x-2953-1
Exercise 16.8 Let k, n be integers, 0 < n < k, and I an instance over schema R.	x-2954-1
n k	x-2955-1
there is a CALC query q with no constants such that q(I) = J iff for each automorphism ρ of I, ρ(J ) = J .	x-2956-1
Sizing Up Languages Exercise 16.12	x-2957-1
Exercise 16.13	x-2958-1
Exercise 16.14	x-2959-1
I get it, now we’ll match languages to complexity classes.	x-2960-1
Sergio: It’s not that easy — data independence adds some spice.	x-2961-1
Riccardo: You can think of it as not having order.	x-2962-1
Vittorio: It’s a lot of fun, and we’ll play some games along the way.	x-2963-1
In Chapter 16, we laid the framework for studying the expressiveness and complexity of query languages.	x-2964-1
In this chapter, we evaluate three of the most important classes of languages discussed so far—CALC, fixpoint, and while—with respect to expressiveness and complexity.	x-2964-2
We show that CALC is in logspace and ac0, that fixpoint is complete in ptime, and that while is complete in pspace.1 We also investigate the impact of the presence of an ordering of the constants in the input.	x-2964-3
We first show that CALC can be evaluated in logspace.	x-2965-1
This complexity result partly explains the success of relational database systems: Relational queries can be evaluated efficiently.	x-2965-2
Furthermore, it implies that these queries are within nc and thus that they have a high potential of intrinsic parallelism (not yet fully exploited in actual systems).	x-2965-3
We prove that CALC queries can be evaluated in constant time in a particular (standard) model of parallel computation based on circuits.	x-2965-4
While looking at the expressive power of CALC and the other two languages, we study their limitations by examining queries that cannot be expressed in these languages.	x-2966-1
This leads us to introduce important tools that are useful in investigating the expressive power of query languages.	x-2967-1
We first present an elegant characterization of CALC based on Ehrenfeucht-Fraissé games.	x-2967-2
This is used to show limitations in the expressive power of CALC, such as the nonexpressibility of the transitive closure query on a graph.	x-2967-3
A second tool related to expressiveness, which applies to all languages discussed in this chapter, consists of proving 0-1 laws for languages.	x-2967-4
This powerful approach, based on probabilities, allows us to show that certain queries (such as even) are not expressible in while and thus not in fixpoint or CALC.	x-2967-5
First Order, Fixpoint, and While such as an ordering of the constants.	x-2968-1
For instance, the query even is easily expressible in while if an order is provided.	x-2968-2
This chapter concludes with two recent developments that shed further light on the interplay of order and expressiveness.	x-2969-1
The first shows that a while query on an unordered database can be reduced to a while query on an ordered database via a fixpoint query.	x-2969-2
The fixpoint query produces an ordered database from a given unordered one by grouping tuples into a sequence of blocks that are never split in the computation of the while query; the blocks can then be thought of as elements of an ordered database.	x-2969-3
This also allows us to clarify the connection between fixpoint and while: They are distinct, unless ptime = pspace.	x-2969-4
The second recent development considers nondeterminism as a means for overcoming limitations due to the absence of ordering of the domain.	x-2970-1
Several nondeterministic extensions of CALC, fixpoint, and while are shown.	x-2970-2
The impact of order is a constant theme throughout the discussion of expressive power.	x-2971-1
Complexity of First-Order Queries This section considers the complexity of first-order queries and shows that they are in qlogspace.	x-2972-1
This result is particularly significant given its implications about the parallel complexity of CALC and thus of relational languages in general.	x-2972-2
Indeed, logspace ⊆ nc.	x-2972-3
We begin by showing the connection between CALC and qlogspace.	x-2973-1
Theorem 17.1.1 CALC is included in qlogspace.	x-2974-1
Proof Let ϕ be a query in CALC over some database schema R. We will describe a TM Mϕ, depending on ϕ, that solves the recognition problem for ϕ and uses a work tape with length logarithmic in the size of the read-only input tape.	x-2975-1
Suppose that Mϕ is started with input enc α(I)# enc α(u) for some instance I over R, some enumeration α of the constants, and some tuple u over adom(I) whose arity is the same as that of the result of ϕ. Mϕ should accept the input iff u ∈ ϕ(I).	x-2976-1
We assume w.l.o.g.	x-2976-2
that ϕ is in prenex normal form.	x-2977-1
We show by induction on the number of quantifiers of ϕ that the computation can be performed using k · log(| enc α(I)# enc α(u)|) cells of the work tape, for some constant k.	x-2977-2
Basis.	x-2978-1
If ϕ has no quantifiers, then all the variables of ϕ are free.	x-2978-2
Let ν be the valuation mapping the free variables of ϕ to u. Mϕ must determine whether I |= ϕ[ν].	x-2978-3
To determine the truth value of each literal L under ν occurring in ϕ, one needs only scan the input tape looking for ν(L).	x-2978-4
This can be accomplished by considering each tuple of I in turn, comparing it with relevant portions of u.	x-2978-5
For each such tuple, the address of the beginning of the tuple should be stored on the tape along with the offset to the current location of the tuple being scanned.	x-2978-6
This can be accomplished within logarithmic space.	x-2978-7
Induction.	x-2979-1
Now suppose that each prenex normal form CALC formula with less than n quantifiers can be evaluated in logspace, and let ϕ be a prenex normal form formula with n quantifiers.	x-2979-2
Suppose ϕ is of the form ∃x ψ.	x-2979-3
(The case when ϕ is of the form ∀x ψ is similar.)	x-2979-4
Because nc is less than the length of the input, the number of cells needed is no more than log(| enc α(I)# enc α(u)|).	x-2980-1
The problem is now reduced to evaluating ψ for each value of x.	x-2980-2
By the induction hypothesis, this can be done using k · log(| enc α(I)# enc α(u)|) work tape cells for some k. Thus the entire computation takes (k + 1) log(| enc α(I)# enc α(u)|) work tape cells; which concludes the induction.	x-2981-1
Unfortunately, CALC does not express all of qlogspace.	x-2982-1
It will be shown in Section 17.3 that even, although clearly in qlogspace, is not a first-order query.	x-2982-2
We next consider informally the parallel complexity of CALC.	x-2983-1
We are concerned with two parallel complexity classes: nc and ac0.	x-2983-2
Intuitively, nc is the class of problems that can be solved using polynomially many processors in time polynomial in the logarithm of the input size; ac0 also allows polynomially many processors but only constant time.	x-2983-3
The formal definitions of nc and ac0 are based on a circuit model in which time corresponds to the depth of the circuit and the number of gates corresponds to its size.	x-2983-4
The circuits use and, or, and not gates and have unbounded fan-in.2 Thus ac0 is the class of problems definable using circuits where the depth is constant and the size polynomial in the input.	x-2983-5
The fact that the complexity of CALC is logspace implies that its parallel complexity is nc, because it is well known that logspace ⊆ nc.	x-2984-1
However, one can prove a tighter result, which says that the parallel complexity of CALC is in fact ac0.	x-2984-2
So only constant time is needed to evaluate CALC queries.	x-2984-3
More than any other known complexity result on CALC, this captures the fundamental intuition that first-order queries can be evaluated in 2 The fan-in is the number of wires going into a gate.	x-2984-4
First Order, Fixpoint, and While parallel very efficiently and that they represent, in some sense, primitive manipulations of relations.	x-2985-1
We sketch only the proof and leave the details for Exercise 17.2.	x-2986-1
Theorem 17.1.2 Every CALC query is in ac0.	x-2987-1
Crux Let us first provide an intuition of the result independent of the circuit model.	x-2988-1
We will use the relational algebra.	x-2988-2
We will argue that each of the operations π, σ, ×, −, ∪ can be performed in constant parallel time using only polynomially many processors.	x-2988-3
Let e be an expression in the algebra over some database schema R. Consider the following infinite space of processors.	x-2989-1
There is one processor for each pair f, u, where f is a subexpression of e and u is a tuple of the same arity as the result of f , using constants from dom.	x-2989-2
Let us denote one such processor by pf,u.	x-2989-3
Note that, in particular, for each relation name Q occurring in f and each u of the arity of Q, pQ,u is one of the processors.	x-2989-4
Each processor has two possible states, true or false, indicating whether u is in the result of f .	x-2990-1
It remains to show that each algebra operation takes constant time.	x-2991-1
Consider, for instance, cross product.	x-2991-2
Suppose f × g is a subexpression of e. To compute f × g, the processors pf,u and pg,v send the message true to processor p(f ×g),uv if their state is true.	x-2991-3
Processor p(f ×g),uv goes to state true when receiving two true messages.	x-2991-4
The other operations are similar.	x-2991-5
Thus e is evaluated in constant time in our informal model of parallel computation.	x-2991-6
To formalize the foregoing intuition using the circuit model, one must construct, for each n, a circuit Bn that, for each input of length n consisting of an encoding over the alphabet {0, 1} of an instance I and a tuple u, outputs 1 iff u ∈ e(I).	x-2992-1
The idea for constructing the circuit is similar to the informal construction in the previous paragraph except that processors are replaced by wires (edges in the graph representing the circuit) that carry either the value 1 or 0.	x-2992-2
Moreover, each Bn has polynomial size.	x-2992-3
Thus only wires that can become active for some input are included.	x-2992-4
Figure 17.1 represents fragments of circuits computing some relational operations.	x-2992-5
In the figure, f is the cross product of g and h (i.e., g × h); f ′ is the difference g − h; and f ′′ is the projection of h on the first coordinate.	x-2992-6
Observe that projection is the most tricky operation.	x-2992-7
In the figure, it is assumed that the active domain consists of four constants.	x-2992-8
Note also that because of projection, the circuits have unbounded fan-in.	x-2992-9
We leave the details of the construction of the circuits Bn to the reader (see Exercise 17.2).	x-2993-1
In particular, note that one must use a slightly more cumbersome encoding than that used for Turing machines because the alphabet is now restricted to {0, 1}.	x-2993-2
or not Figure 17.1: Some fragments of circuits One might naturally wonder if CALC expresses all queries in ac0.	x-2994-1
It turns out that there are queries in ac0 that are not first order.	x-2994-2
This is demonstrated in Section 17.4.	x-2994-3
Expressiveness of First-Order Queries We have seen that first-order queries have desirable properties with respect to complexity.	x-2995-1
However, there is a price to pay for this in terms of expressiveness: There are many useful queries that are not first order.	x-2996-1
Typical examples of such queries are even and transitive closure of a graph.	x-2996-2
This section presents an elegant technique based on a two-player game that can be used to prove that certain queries (including even and transitive closure) are not first order.	x-2996-3
Although the game we describe is geared toward first-order queries, games provide a general technique that is used in conjunction with many other languages.	x-2996-4
The connection between CALC sentences and games is, intuitively, the following.	x-2997-1
Consider as an example a CALC sentence of the form	x-2998-1
One can view the sentence as a statement about a game with two players, 1 and 2, who alternate in picking values for x1, x2, x3.	x-2999-1
The sentence says that Player 2 can always force a choice of values that makes ψ(x1, x2, x3) true.	x-2999-2
In other words, no matter which value Player 1 chooses for x1, Player 2 can pick an x2 such that, no matter which x3 is chosen next by Player 1, ψ(x1, x2, x3) is true.	x-2999-3
The actual game we use, called the Ehrenfeucht-Fraissé game, is slightly more involved, but is based on a similar intuition.	x-3000-1
It is played on two instances.	x-3000-2
Suppose that R is a database schema.	x-3000-3
Let I and J be instances over R, with disjoint sets of constants.	x-3000-4
Let r be First Order, Fixpoint, and While R( x, y) P( x, z) Figure 17.2:	x-3000-5
Let ai be the ith constant picked in I (respectively, bi in J).	x-3001-1
The set of pairs {(a1, b1),	x-3001-2
Duplicator wins the round {(a1, b1), .	x-3002-1
.	x-3002-2
.	x-3002-3
, (ar, br)} iff the mapping ai → bi is an isomorphism of the subinstances I/{a1, .	x-3002-4
.	x-3002-5
.	x-3002-6
, ar} and J/{b1, .	x-3002-7
.	x-3002-8
.	x-3002-9
, br}.	x-3002-10
Duplicator wins the game of length r associated with I and J if he or she has a winning strategy (i.e., Duplicator can always win any game of length r on I and J, no matter how Spoiler plays).	x-3003-1
This is denoted by I ≡r J.	x-3003-2
Note that the relation ≡r is an equivalence relation on instances over R (see Exercise 17.3).	x-3003-3
Intuitively, the equivalence I ≡r J says that I and J cannot be distinguished by looking at just r constants at a time in the two instances.	x-3004-1
Recall that the quantifier depth of a CALC formula is the maximum number of quantifiers in a path from the root to a leaf in the representation of the sentence as a tree.	x-3004-2
The main result of Ehrenfeucht-Fraissé games is that the ability to distinguish among instances using games of length r is equivalent to the ability to distinguish among instances using some CALC sentence of quantifier depth r.	x-3004-3
Example 17.2.1 Consider the sentence ∀x (∃y R(x, y) ∧ ∃z P (x, z)).	x-3005-1
Its syntax tree is represented in Fig.	x-3005-2
17.2.	x-3005-3
The sentence has quantifier depth 2.	x-3005-4
Note that, for a sentence in prenex normal form, the quantifier depth is simply the number of quantifiers in the formula.	x-3005-5
The main result of Ehrenfeucht-Fraissé games, stated in Theorem 17.2.2, is that if I and J are two instances such that Duplicator has a winning strategy for the game of length r on the two instances, then I and J cannot be distinguished by any CALC sentence of quantifier depth r. Before proving this theorem, we note that the converse of that result also holds.	x-3006-1
Thus if two instances are undistinguishable using sentences of quantifier depth r, then they are equivalent with respect to ≡r.	x-3006-2
Although interesting, this is of less use as a tool for proving expressibility results, and we leave it as a (nontrivial!)	x-3006-3
exercise.	x-3006-4
The main idea is to show that each equivalence class of ≡r is definable by a sentence of quantifier depth r (see Exercises 17.9 and 17.10).	x-3006-5
Theorem 17.2.2 Let I and J be two instances over a database schema R. If I ≡r J, then for each CALC sentence ϕ over R with quantifier depth r, I and J both satisfy ϕ or neither does.	x-3007-1
Crux Suppose that I |= ϕ and J |= ϕ for some ϕ of quantifier depth r. We prove that I ≡r J.	x-3008-1
We provide only a sketch of the proof in an example.	x-3008-2
Let ϕ be the sentence ∀x1 ∃x2 ∀x3 ψ(x1, x2, x3), where ψ has no quantifiers, and let I and J be two instances such that I |= ϕ, J |= ϕ.	x-3009-1
Then I |= ∀x1 ∃x2 ∀x3 ψ(x1, x2, x3) and J |= ∃x1 ∀x2 ∃x3 ¬ψ(x1, x2, x3).	x-3009-2
We will show that Spoiler can prevent Duplicator from winning by forcing the choice of constants a1, a2, a3 in I and b1, b2, b3 in J such that I |= ψ(a1, a2, a3) and J |=	x-3010-1
Spoiler starts by picking a constant b1 in J such that J |= ∀x2 ∃x3 ¬ψ(b1, x2, x3).	x-3011-1
Duplicator must respond by picking a constant a1 in I.	x-3012-1
Due to the universal quantification in ϕ, I |= ∃x2 ∀x3 ψ(a1, x2, x3), regardless of which a1 was picked.	x-3012-2
Next Spoiler picks a constant a2 in I such that I |= ∀x3 ψ(a1, a2, x3).	x-3012-3
Regardless of which constant b2 in J Duplicator picks, J |= ∃x3 ¬ψ(b1, b2, x3).	x-3013-1
Finally Spoiler picks b3 in J such that J |= ¬ψ(b1, b2, b3); Duplicator picks some a3 in I, and I |= ψ(a1, a2, a3).	x-3014-1
First Order, Fixpoint, and While B B 1 b b b 2 B 2 Figure 17.3: Two undistinguishable graphs Theorem 17.2.2 provides an important tool for proving that certain properties are not definable by CALC.	x-3015-1
It is sufficient to exhibit, for each r, two instances Ir and Jr such that Ir has the property, Jr does not, and Ir ≡r Jr.	x-3015-2
In the next proposition, we illustrate the use of this technique by showing that graph connectivity, and therefore transitive closure, is not expressible in CALC.	x-3015-3
Proposition 17.2.3 Let R be a database schema consisting of one binary relation.	x-3016-1
Then the query conn defined by conn(I) = true iff I is a connected graph is not expressible in CALC.	x-3016-2
Crux Suppose that there is a CALC sentence ϕ checking graph connectivity.	x-3017-1
Let r be the quantifier depth of ϕ.	x-3017-2
We exhibit a connected graph Ir and a disconnected graph Jr such that Ir ≡r Jr. Then, by Theorem 17.2.2, the two instances satisfy ϕ or none does, a contradiction.	x-3017-3
For a sufficiently large n (depending only on r; see Exercise 17.5), the graph Ir consists of a cycle B of 2n nodes and the graph Jr of two disjoint cycles B1 and B2 of n nodes each (see Fig.	x-3018-1
17.3).	x-3018-2
We outline the winning strategy for Duplicator.	x-3018-3
The main idea is simple: Two nodes a, a′ in Ir that are far apart behave in the same way as two nodes b, b′ in Jr that belong to different cycles.	x-3018-4
In particular, Spoiler cannot take advantage of the fact that a, a′	x-3018-5
For example, if Spoiler picks an element a1 in Ir, then Duplicator picks an arbitrary element b1, say in B1.	x-3019-1
Now if Spoiler picks an element b2 in B2, then Duplicator picks an element a2 in Ir far from a1.	x-3019-2
Next, if Spoiler picks a b3 in B1 close to b1, then Duplicator picks an element a3 in Ir close to a1.	x-3019-3
The graphs are sufficiently large that this can proceed for r moves with the resulting subgraphs isomorphic.	x-3019-4
The full proof requires a complete case analysis on the moves that Spoiler can make.	x-3019-5
The preceding technique can be used to show that many other properties are not expressible in CALC—for instance, even, 2-colorability of graphs, or Eulerian graphs (i.e., graphs for which there is a cycle that passes through each edge exactly once) (see Exercise 17.7).	x-3020-1
Fixpoint and While Queries That transitive closure is not expressible in CALC has been the driving force behind extending relational calculus and algebra with recursion.	x-3021-1
In this section we discuss the expressiveness and complexity of the two main extensions of these languages with recursion: the fixpoint and while queries.	x-3021-2
It is relatively easy to place an upper bound on the complexity of fixpoint and while queries.	x-3022-1
Recall that the main distinction between languages defining fixpoint queries and those defining while queries is that the first are inflationary and the second are not (see Chapter 14).	x-3022-2
It follows that fixpoint queries can be implemented in polynomial time and while queries in polynomial space.	x-3022-3
Moreover, these bounds are tight, as shown next.	x-3022-4
Theorem 17.3.1	x-3023-1
Crux The fact that each fixpoint query is in ptime follows immediately from the inflationary nature of languages defining the fixpoint queries and the fact that the total number of tuples that can be built from constants in a given instance is polynomial in the size of the instance (see Chapter 14).	x-3024-1
For while, inclusion in pspace follows similarly (see Exercise 17.11).	x-3024-2
The completeness follows from an important result that will be shown in Section 17.4.	x-3024-3
The result, Theorem 17.4.2, states that if an order on the constants of the domain is available, fixpoint expresses exactly qptime and while expresses exactly qpspace.	x-3024-4
The completeness then follows from the fact that there exist problems that are complete in ptime and problems that are complete in pspace (see Exercise 17.11).	x-3025-1
The Parity Query	x-3026-1
First Order, Fixpoint, and While Proposition 17.3.2 The query even is not a while query.	x-3027-1
Proof Let R be a unary relation.	x-3028-1
Suppose that there exists a while program w that computes the query even on input R. We can assume, w.l.o.g., that R contains a unary relation ans so that, on input I, w(I)( ans) = ∅ if |I| is even, and w(I) = I otherwise.	x-3028-2
Let R be the schema of w (so R contains R and ans).	x-3028-3
We will reach a contradiction by showing that the computation of w on a given input is essentially independent of its size.	x-3028-4
More precisely, for n large enough, the computations of w on all inputs of size greater than n will in some sense be identical.	x-3028-5
This contradicts the fact that ans should be empty at the end of some computations but not others.	x-3028-6
To show this, we need a short digression related to computations on unary relations.	x-3029-1
We assume here that w does not use constants, but the construction can be generalized to that case (see Exercise 17.14).	x-3030-1
Let I be an input instance and k an integer.	x-3030-2
We consider a partition of the set of k-tuples with entries in adom(I) into hyperplanes based on patterns of equalities and inequalities between components as follows.	x-3030-3
For each equivalence relation H≃(I) = {u1, .	x-3030-4
.	x-3030-5
.	x-3030-6
, uk | for each i, j ∈ [1, k], ui, uj ∈ adom(I) and ui = uj ⇔ i ≃ j }.	x-3030-7
For instance, let adom(I) = {a, b, c}, k = 3 and	x-3031-1
Then H≃(I) = {a, a, b, a, a, c, b, b, a, b, b, c, c, c, a, c, c, b}.	x-3032-1
Finally there are two 0-ary hyperplanes, denoted true and false, that evaluate to {} and {}, respectively.	x-3033-1
We will see that a while computation cannot distinguish between two k-tuples in the same hyperplane, and so intermediate relations of arity k will always consist of a union of hyperplanes.	x-3034-1
Now consider the while program w. We assume that the condition guarding each while loop has the form R = ∅ for some R ∈ R, and that in each assignment R := E, E involves a single application of some unary or binary algebra operator.	x-3035-1
We label the statements of the program so we can talk about the program state (i.e., the label) after some number of computation steps on input I.	x-3035-2
We include two labels in a while statement in the following manner: label1 while condition do label2 statement .	x-3035-3
Let N be the maximum arity of any relation in R. To conclude the proof, we will show by induction on the steps of the computation that there is a number bw such that for each input I with size ≥ N , w terminates on I after exactly bw steps.	x-3036-1
Furthermore, (*) for each step m ≤ bw, there exists a label jm and for each relation T of arity k a set ET ,m of equivalence relations over {1, .	x-3036-2
.	x-3036-3
.	x-3036-4
, k} such that for each input I of size greater than N	x-3036-5
To see that this yields the result, suppose that it is true.	x-3037-1
Then for each I with size ≥ N , w terminates with ans always empty or always nonempty, regardless of whether the size of I is even or odd (a contradiction).	x-3037-2
The claim follows from an inductive proof of (*).	x-3038-1
It is clear that this holds at the 0th step.	x-3038-2
At the start of the computation, all T are empty except for the input unary relation R, which contains all constants and so consists of the hyperplane H≃, where	x-3038-3
Let k, l be the arities of Q1, Q2, respectively, and for each ≃2 in EQ2,m−1, let	x-3039-1
For an arbitrary binary relation γ ⊆ [1, k + l] × [1, k + l], let γ ∗ denote the reflexive, symmetric, and transitive closure of γ .	x-3040-1
For ≃1, ≃2 in EQ1,m−1, EQ2,m−1, respectively, set First Order, Fixpoint, and While	x-3040-2
It is straightforward to verify that for each pair ≃1, ≃2 in EQ1,m−1, EQ2,m−1, respectively, and I with size ≥ N , H≃ (I) × H (I) = H	x-3041-1
Note that this uses the assumption that the size of I is greater than N , the maximum arity of relations in w. It follows that	x-3042-1
ET ,m =	x-3043-1
Thus (*2) also holds for T at step m, and the induction is completed.	x-3044-1
The hyperplane technique used in the preceding proof is based on the fact that in the context of a (sufficiently large) unary relation input, there are families of tuples (in this case the different hyperplanes) that “travel together” and hence that the intermediate and final results are unions of these families of tuples.	x-3045-1
Although there are other cases in which the technique of hyperplanes can be applied (see Exercise 17.15), in the general case the input is not a union of hyperplanes, and so the members of a hyperplane do not travel together.	x-3045-2
However, there is a generalization of hyperplanes based on automorphisms that yields the same effect.	x-3045-3
Recall that an automorphism of I is a one-to-one mapping ρ on adom(I) such that ρ(I) = I.	x-3045-4
For fixed I, consider the following equivalence relation ≡I on k k-tuples of adom(I): u ≡I v iff there exists an automorphism ρ of I such that ρ(u) = v.	x-3045-5
k when w is executed on input I.	x-3046-1
More precisely, suppose that J is an instance obtained at some point in the computation of w on input I.	x-3046-2
The genericity of while programs implies that if ρ is an automorphism of I, it is also an automorphism of J.	x-3046-3
Thus for each k-tuple u in some relation of J and each v such that u ≡I v, v also belongs to that relation.	x-3046-4
Thus each k relation in J of arity k is a union of equivalence classes of ≡I .	x-3046-5
The equivalence relation ≡I k k will be used in our development of 0-1 laws, presented next.	x-3046-6
We now develop a powerful tool that provides a uniform approach to resolving in the negative a large spectrum of expressibility problems.	x-3047-1
It is based on the probability that a property is true in instances of a given size.	x-3047-2
We shall prove a surprising fact: All properties expressible by a while query are “almost surely” true, or “almost surely” false.	x-3047-3
More precisely, we prove the result for while sentences: Definition 17.3.3	x-3047-4
Let q be a sentence over some schema R. For each n, let µn(q) denote the fraction of instances over R with entries in {1, .	x-3048-1
.	x-3048-2
.	x-3048-3
, n} that satisfy q.	x-3048-4
That is,	x-3048-5
Definition 17.3.4	x-3049-1
To simplify the discussion of 0-1 laws, we continue to focus exclusively on constant-free queries (see Exercise 17.19).	x-3050-1
We will show that CALC, fixpoint, and while sentences have 0-1 laws.	x-3051-1
This provides substantial insight into limitations of the expressive power of these languages and can be used to show that they cannot express a variety of properties.	x-3051-2
For example, it follows immediately that even is not expressible in either of these languages.	x-3051-3
Indeed, µn( even) is 1 if n is even and 0 if n is odd.	x-3051-4
Thus µn( even) does not converge, so even is not expressible in a language that has a 0-1 law.	x-3051-5
While 0-1 laws provide an elegant and powerful tool, they require the development of some nontrivial machinery.	x-3052-1
Interestingly, this is one of the rare occasions when we will need to consider infinite instances even though we aim to prove something about finite instances only.	x-3052-2
We start by proving that CALC has a 0-1 law and then extend the result to fixpoint and while.	x-3053-1
For simplicity, we consider only the case when the input to the query is a binary relation G (representing edges in a directed graph with no edges of the form a, a).	x-3053-2
It is straightforward to generalize the development to arbitrary inputs (see Exercise 17.19).	x-3053-3
We will use an infinite set A of CALC sentences called extension axioms, which refer to graphs.	x-3054-1
They say, intuitively, that every subgraph can be extended by one node in all possible ways.	x-3054-2
More precisely, A contains, for each k, all sentences of the form	x-3054-3
i=j i where connections(x1, .	x-3055-1
.	x-3055-2
.	x-3055-3
, xk; y) is some conjunction of literals containing, for each xi, one of G(xi, y) or ¬G(xi, y), and one of G(y, xi) or ¬G(y, xi).	x-3055-4
For example, for k = 3, one of the 26 extension axioms is G(x1, y) ∧ ¬G(y, x1) ∧ ¬G(x2, y) ∧ ¬G(y, x2) ∧ G(x3, y) ∧ G(y, x3))) specifying the pattern of connections represented in Fig.	x-3055-5
17.4.	x-3055-6
First Order, Fixpoint, and While y x 1 x 2 x 3 Figure 17.4:	x-3056-1
Note that A consists of an infinite set of sentences and that each finite subset of A is satisfied by some infinite instance.	x-3057-1
(The instance is obtained by starting from one node and repeatedly adding nodes required by the extension axioms in the subset.)	x-3057-2
Then by the compactness theorem there is an infinite instance satisfying all of A, and by the Löwenheim-Skolem theorem (see Chapter 2) there is a countably infinite instance R satisfying A.	x-3057-3
The following lemma shows that R is unique up to isomorphism.	x-3058-1
Lemma 17.3.5 If R and P are two countably infinite instances over G satisfying all sentences in A, then R and P are isomorphic.	x-3059-1
Proof Suppose that a1a2 .	x-3060-1
.	x-3060-2
.	x-3060-3
is an enumeration of all constants in R, and b1b2 .	x-3060-4
.	x-3060-5
.	x-3060-6
is an enumeration of those in P. We construct an isomorphism between R and P by alternatingly picking constants from R and from P. We construct sequences ai .	x-3060-7
.	x-3060-8
.	x-3060-9
a .	x-3060-10
.	x-3060-11
.	x-3060-12
and 1 ik bi .	x-3060-13
.	x-3060-14
.	x-3060-15
b .	x-3060-16
.	x-3060-17
.	x-3060-18
such that a → b is an isomorphism from R to P. The procedure for pick-1 ik ik ik ing the kth constants ai and b in these sequences is defined inductively as follows.	x-3060-19
For the k ik base case, let ai = a ik i1 ik been defined.	x-3060-20
If k is even, let ai be the first constant in a k+1 far in the sequence.	x-3060-21
Let σk be the sentence in A describing the way ai extends the sub-k+1 graph with nodes ai .	x-3060-22
.	x-3060-23
.	x-3060-24
a .	x-3060-25
Because P also satisfies σ ik k, there exists a constant b in P that extends the subgraph bi .	x-3060-26
.	x-3060-27
.	x-3060-28
b in the same manner.	x-3060-29
Let b ik ik+1 is reversed (i.e., it starts by choosing first a new constant from b1, b2, .	x-3060-30
.	x-3060-31
.	x-3060-32
).	x-3060-33
This back-and-forth procedure ensures that (1) all constants from both R and P occur eventually among the chosen constants, and (2) the mapping ai → b is an isomorphism.	x-3060-34
k ik Thus the foregoing proof shows that there exists a unique (up to isomorphism) countable graph R satisfying A.	x-3061-1
This graph, studied extensively by Rado [Rad64] and others, is usually referred to as the Rado graph.	x-3061-2
We can now prove the following crucial lemma.	x-3061-3
The key point is the equivalence between (a) and (c), called the transfer property: It relates satisfaction of a sentence by the Rado graph to the property of being almost surely true.	x-3062-1
Lemma 17.3.6 Let R be the Rado graph and σ a CALC sentence.	x-3063-1
The following are equivalent:	x-3063-2
Proof satisfying A but not σ .	x-3064-1
Because P satisfies A, P must be infinite.	x-3064-2
By the Lowënheim-Skolem theorem (see Chapter 2), we can assume that P is countable.	x-3064-3
But then, by Lemma 17.3.5, P is isomorphic to R. This is a contradiction, because R satisfies σ but P does not.	x-3064-4
Suppose this is the case and A implies σ .	x-3065-1
By the compactness theorem, σ is implied by some finite subset A′ of A.	x-3065-2
Because every sentence in A′ is almost surely true, the conjunction surely true.	x-3065-3
It remains to show that each sentence in A is almost surely true.	x-3066-1
Consider the following sentence σk in A:	x-3066-2
i=j i Then ¬σk is the sentence	x-3067-1
i=j	x-3068-1
i We will show the following property on the probability that an instance with n constants does not satisfy σk:	x-3069-1
Because limn→∞[n · (n − 1) · .	x-3070-1
.	x-3070-2
.	x-3070-3
· (n − k) · (1 − 1 )(n−k)] = 0, it follows that lim 22k n→∞ µn	x-3070-4
Let N be the number of instances with constants in {1, .	x-3071-1
.	x-3071-2
.	x-3071-3
, n}.	x-3071-4
To prove (**), observe the following:	x-3071-5
First Order, Fixpoint, and While	x-3072-1
i is (1 − 1 )n−k · N [because there are (n − k) ways of picking b distinct from 22k	x-3073-1
n · (n − 1) · .	x-3074-1
.	x-3074-2
.	x-3074-3
· (n − k) · (1 −	x-3074-4
is almost surely true.	x-3075-1
Then σ cannot be almost surely true (a contradiction).	x-3075-2
The 0-1 law for CALC follows immediately.	x-3076-1
Theorem 17.3.7 Each sentence in CALC is almost surely true or almost surely false.	x-3077-1
Proof Let σ be a CALC sentence.	x-3078-1
The Rado graph R satisfies either σ or ¬σ .	x-3078-2
By the transfer property [(a) ⇒ (c) in Lemma 17.3.6], σ is almost surely true or ¬σ is almost surely true.	x-3078-3
Thus σ is almost surely true or almost surely false.	x-3078-4
The 0-1 law for CALC can be extended to fixpoint and while.	x-3079-1
We prove it next for while (and therefore fixpoint).	x-3079-2
Once again the proof uses the Rado graph and extends the transfer property to the while sentences.	x-3079-3
Theorem 17.3.8 Every while sentence is almost surely true or almost surely false.	x-3080-1
Proof We use as a language for the while queries the partial fixpoint logic CALC+µ.	x-3081-1
The main idea of the proof is to show that every CALC+µ sentence that is defined on all instances is in fact equivalent almost surely to a CALC sentence, and so by the previous result is almost surely true or almost surely false.	x-3082-1
We show this for CALC+µ sentences.	x-3082-2
By Theorem 14.4.7, we can consider w.l.o.g.	x-3083-1
only sentences involving one application of the partial fixpoint operator µ.	x-3083-2
Thus consider a CALC+µ sentence ξ of the form ξ = ∃, x (µT (ϕ(T ))(,t)) over schema R, where distinct free variables in ,t.	x-3083-3
Essentially, a computation of a query ξ consists of iterating the CALC formula ϕ until convergence occurs (if ever).	x-3084-1
Consider the sequence {ϕi(I)}i>0, where I is an input.	x-3084-2
If I is finite, the sequence is periodic [i.e., there exist N and p such that, for each n ≥ N , ϕn(I) = ϕn+p(I)].	x-3084-3
If p = 1, then the sequence converges (it becomes constant at some point); otherwise it does not.	x-3084-4
Now consider the sequence {ϕi(R)}i>0, where R is the Rado graph.	x-3084-5
Because the set of constants involved is no longer finite, the sequence may or may not be periodic.	x-3084-6
A key point in our proof is the observation that the sequence {ϕi(R)}i>0 is indeed periodic, just as in the finite case.	x-3084-7
To see this, we use a technique similar to the hyperplane technique in the proof of Lemma 17.3.5.	x-3085-1
Let k be some integer.	x-3085-2
We argue next that for each k, there is a finite number of equivalence classes of k-tuples induced by automorphisms of R. For each pair u, v of k-tuples with entries in adom(R), let u ≡R v iff there exists an automorphism ρ of R such k that ρ(u) = v.	x-3085-3
Let u ≃R v if both the patterns of equality and the patterns of connection within u and k v are identical.	x-3086-1
More formally, for each u = a1, .	x-3086-2
.	x-3086-3
.	x-3086-4
, ak, v = b1, .	x-3086-5
.	x-3086-6
.	x-3086-7
, bk (where ai and bi are constants in R), u ≃R v if k	x-3086-8
We claim that u ≡R k v iff u ≃R k v.	x-3087-1
The “only if” part follows immediately from the definitions.	x-3088-1
For the “if” part, suppose that u ≃R v. To show that u ≡R v, we must build an automorphism ρ of R such that ρ(u) = v.	x-3088-2
k k This is done by a back-and-forth construction, as in Lemma 17.3.5, using the extension axioms satisfied by R (see Exercise 17.18).	x-3089-1
Because there are finitely many patterns of connection and equality among k vertexes, there are finitely many equivalence classes of ≃R, so of ≡R.	x-3090-1
Due to genericity of the while k k computation, each ϕi(R) is a union of such equivalence classes (see Exercise 16.6 in the previous chapter).	x-3090-2
Thus there must exist m, l, 0 ≤ m < l, such that ϕm(R) = ϕl(R).	x-3090-3
Let N = m and p = l − m. Then for each n ≥ N , ϕn(R) = ϕn+p(R).	x-3090-4
It follows that: (1) {ϕi(R)}i>0 is periodic.	x-3090-5
Using this fact, we show the following:	x-3091-1
Before proving these, we argue that (2) and (3) will imply the statement of the theorem.	x-3092-1
Suppose that (2) and (3) holds.	x-3093-1
Suppose also that σ is false in R. By Lemma 17.3.6, σ is almost surely false.	x-3093-2
Then µn(ξ ) ≤ µn(ξ ≡ σ ) + µn(σ ) and both µn(ξ ≡ σ ) and µn(σ ) First Order, Fixpoint, and While converge to 0, so limn→∞(µn(ξ )) = 0.	x-3093-3
Thus ξ is also almost surely false.	x-3093-4
By a similar argument, ξ is almost surely true if σ is true in R.	x-3093-5
We now prove (2).	x-3094-1
Let $ij be the CALC sentence stating that ϕi and ϕj are equivalent.	x-3094-2
Suppose {ϕi(R)}i>0 does not converge.	x-3095-1
Thus the period of the sequence is greater than 1, so there exist m, j, l, m < j < l, such that	x-3095-2
Thus R satisfies the CALC sentence	x-3096-1
Let I range over finite databases.	x-3097-1
Because ξ is defined on all finite inputs, {ϕi(I)}i≥0 converges.	x-3097-2
On the other hand, by the transfer property (Lemma 17.3.6), χ is almost surely true.	x-3097-3
It follows that the sequence {ϕi(I)}i>0 diverges almost surely.	x-3097-4
In particular, there exist finite I for which {ϕi(I)}i>0 diverges (a contradiction).	x-3097-5
The proof of (3) is similar.	x-3098-1
By (1) and (2), the sequence {ϕi(R)}i>0 becomes constant after finitely many iterations, say N .	x-3098-2
Then ξ is equivalent on R to the CALC sentence σ = x(ϕN (,t)).	x-3098-3
Suppose R satisfies ξ .	x-3098-4
Thus R satisfies σ .	x-3098-5
Furthermore, R satisfies $N(N+1) because {ϕi(R)}i>0 becomes constant at the Nth iteration.	x-3098-6
Thus R satisfies σ ∧ $N(N+1).	x-3098-7
By the transfer property for CALC, σ ∧ $N(N+1) is almost surely true.	x-3099-1
For each finite instance I where $N(N+1) holds, {ϕi(I)}i>0 converges after N iterations, so ξ is equivalent to σ .	x-3099-2
It follows that ξ is almost surely equivalent to σ .	x-3099-3
The case where R does not satisfy ξ is similar.	x-3099-4
Thus we have shown that while sentences have a 0-1 law.	x-3100-1
It follows immediately that many queries, including even, are not while sentences.	x-3100-2
The technique of 0-1 laws has been extended successfully to languages beyond while.	x-3100-3
Many languages that do not have 0-1 laws are also known, such as existential second-order logic (see Exercise 17.21).	x-3100-4
The precise border that separates languages that have 0-1 laws from those that do not has yet to be determined and remains an interesting and active area of research.	x-3100-5
The Impact of Order In this section, we consider in detail the impact of order on the expressive power of query languages.	x-3101-1
As mentioned at the beginning of this chapter, we view the assumption of order as, in some sense, suspending the data independence principle in a database.	x-3101-2
Because data independence is one of the main guiding principles of the pure relational model, it is important to understand its consequences in the expressiveness and complexity of query languages.	x-3101-3
P succ b c b b b d b c c d c d d b Figure 17.5: languages are known that express precisely the queries of those complexity classes.	x-3102-1
With order, there are numerous such results.	x-3102-2
We present two of the most prominent ones.	x-3102-3
We begin by making the notion of an ordered database more precise.	x-3103-1
A database is said to be ordered if it includes a designated binary relation succ that provides a successor relation on the constants occurring in the database.	x-3103-2
A query on an ordered database is a query whose input database schema contains succ and that ranges only over the ordered instances of the input database schema.	x-3103-3
Example 17.4.1 Consider the database schema R = {P , succ}, where P is ternary.	x-3104-1
An ordered instance of R is represented in Fig.	x-3104-2
17.5.	x-3104-3
According to succ, a is the first constant, b is the successor of a, c is the successor of b, and d is the successor of c. Thus a, b, c, d can be identified with the integers 1, 2, 3, 4, respectively.	x-3104-4
We now consider the power of fixpoint and while on ordered databases.	x-3105-1
In particular, we prove the fundamental result that fixpoint expresses precisely qptime on ordered databases, and while expresses precisely qpspace on ordered databases.	x-3105-2
This shows that order has a far-reaching impact on expressiveness, well beyond isolated cases such as the even query.	x-3105-3
More broadly, the characterization of qptime by fixpoint (with the order assumption) provides an elegant logical description of what have traditionally been considered the tractable problems.	x-3105-4
Beyond databases, this is significant to both logic and complexity theory.	x-3105-5
Theorem 17.4.2	x-3106-1
Proof Consider (a).	x-3107-1
We have already seen that fixpoint ⊆ qptime (see Exercise 17.11), and so it remains to show that all qptime queries on ordered databases are expressible in fixpoint.	x-3107-2
Let q be a query on a database with schema R that includes succ, such that q is First Order, Fixpoint, and While in qptime on the ordered instances of R. Thus there is a polynomial p and Turing machine M′ that, on input enc(I)# enc(u), terminates in time p(| enc(I)# enc(u)|) and accepts the input iff u ∈ q(I).	x-3107-3
(In this section, encodings of ordered instances are with respect to the enumeration of constants provided by succ; see also Chapter 16.)	x-3107-4
Because q(I) has size polynomial in I, a TM M can be constructed that runs in polynomial time and that, on input enc(I), produces as output enc(q(I)).	x-3107-5
We now describe the construction of a CALC+µ+ query qM that is equivalent to q on ordered instances of R.	x-3107-6
The fixpoint query qM we construct, when given ordered input I, will operate in three phases: (α) construct an encoding of I that can be used to simulate M; (β) simulate M; and (γ ) decode the output of M. A key point throughout the construction is that qM is inflationary, and so it must compute without ever deleting anything from a relation.	x-3108-1
Note that this restriction does not apply to (b), which simplifies the simulation in that case.	x-3108-2
We next describe the encoding used in the simulation of M. The encoding is centered around a relation that holds the different configurations reached by M.	x-3109-1
Representing a tape.	x-3110-1
Because the tape is infinite, we only represent the finite portion, polynomial in length, that is potentially used.	x-3110-2
We need a way to identify each cell of the tape.	x-3110-3
Let nc be the number of constants in I.	x-3110-4
Because M runs in polynomial time, there is some k such that M on input enc(I) takes time ≤ nk, and thus ≤ tape cells (see also c nkc Exercise 16.12 in the previous chapter).	x-3110-5
Consider the world of k-tuples with entries in the constants from I.	x-3110-6
Note that there are nk such tuples and that they can be lexicographically c ordered using succ.	x-3110-7
Thus each cell can be uniquely identified by a k-tuple of constants from I.	x-3110-8
One can define by a fixpoint query a 2k-ary relation succ k providing the successor relation on k-tuples, in the lexicographic order induced by succ (see Exercise 17.23a).	x-3110-9
The ordered k-tuples thus allow us to represent a sequence of cells and hence M’s tape.	x-3110-10
Representing all the configurations.	x-3111-1
Note that one cannot remove the tuples representing old configurations of M due to the inflationary nature of fixpoint computations.	x-3111-2
Thus one represents all the configurations in a single relation.	x-3111-3
To distinguish a particular configuration (e.g., that at time i, i ≤ nk), c k-columns are used as timestamp.	x-3111-4
Thus to keep track of the sequence of configurations in a computation of M, one can use a (2k + 2)-ary relation RM where	x-3111-5
Note that now we are dealing with a double encoding: The database is encoded on the tape, and then the tape is encoded back into RM.	x-3112-1
To illustrate this simple but potentially confusing situation, we consider an example.	x-3113-1
Let R = {P , succ}, and let I be the ordered instance of R represented in Fig.	x-3114-1
17.5.	x-3114-2
Then enc(I) is represented in Fig.	x-3114-3
17.6.	x-3114-4
We assume, without loss of generality, that symbols in the tape alphabet and the states of M are in dom.	x-3114-5
Parts of the first two configurations are represented in the relation shown in Fig.	x-3114-6
17.7.	x-3114-7
The representation assumes that k = 4, so the arity of the relation is 10.	x-3114-8
Because this is a single-volume book, only part of the relation is shown.	x-3114-9
More precisely, we show the first tuples from the representation of the P[1#0#10][1#1#11][10#0#11][11#1#0] succ[0#1][1#10][10#11] Figure 17.6: Encoding of I and u on a TM tape first two configurations.	x-3114-10
It is assumed that the original state is s and the head points to the first cell of the tape; and that in that state, the head moves to the right, changing P to 0, and the machine goes to state r. Observe that the timestamp for the first configuration is a, a, a, a, and a, a, a, b for the second.	x-3114-11
Observe also the numbering of tape cells: a, a, a, a, .	x-3114-12
.	x-3114-13
.	x-3114-14
, a, a, c, d, etc.	x-3114-15
We can now describe the three phases of the operation of qM more precisely: For a given ordered instance I, qM	x-3115-1
We sketch the construction of the fixpoint queries realizing (α) and (β) here, and we leave (γ ) as an exercise (17.23).	x-3116-1
Consider phase (α).	x-3117-1
Recall that each constant is encoded on the tape of M as the binary representation of its rank in the successor relation succ (e.g., c as 10).	x-3117-2
To perform the encoding of the initial configuration, it is useful first to construct an auxiliary relation that provides the encoding of each constant.	x-3117-3
Because there are nc constants, the code of each constant requires ≤ ⌈log(nc)⌉ bits, and thus less than nc bits.	x-3117-4
We can therefore use a ternary relation constant _ coding to record the encoding.	x-3117-5
A tuple x, y, z in that relation indicates that the kth bit of the encoding of constant x is z, where k is the rank of constant y in the succ relation.	x-3117-6
For instance, the relation constant _ coding corresponding to the succ in Fig.	x-3117-7
17.5 is represented in Fig.	x-3117-8
17.8.	x-3117-9
The tuples c, a, 1 and c, b, 0 indicate, for instance, that c is encoded as 10.	x-3117-10
It is easily seen that constant _ coding is definable from succ by a fixpoint query (see Exercise 17.23b).	x-3117-11
With relation constant _ coding constructed, the task of computing the encoding of I and u into RM is straightforward.	x-3118-1
We will illustrate this using again the example in Fig.	x-3118-2
17.5.	x-3118-3
To encode relation P , one steps through all 3-tuples of constants and checks if a tuple in P has been reached.	x-3118-4
To step through the 3-tuples, one first constructs the successor relation succ 3 on 3-tuples.	x-3118-5
The first tuple in P that is reached is b, a, c. Because this is the first tuple encoded, one first inserts into RM the identifying information for P (the first tuple in Fig.	x-3118-6
17.7).	x-3118-7
This proceeds, yielding the next tuples in Fig.	x-3118-8
17.7.	x-3118-9
The binary representation for each of b, a, c is obtained from relation constant _ coding.	x-3118-10
This proceeds by moving to the next 3-tuple.	x-3118-11
It is left to the reader to complete the details of the fixpoint query constructing RM (see Exercise 17.23c).	x-3118-12
Several additional relations have to be used for bookkeeping purposes.	x-3118-13
For instance, when stepping through the tuples in succ 3, one must keep track of the last tuple that has been processed.	x-3118-14
We next outline the construction for (β).	x-3119-1
One must simulate the computation of M starting from the initial configuration represented in RM.	x-3119-2
To construct a new configuration from the current one, one must simulate a move of M. This is repeated until M reaches First Order, Fixpoint, and While RM P s b c d b b b b c b d c c b c c c d	x-3119-3
b b b r b c b d b b b b b b b c b b d b c b c b b c c b c d	x-3120-1
Figure 17.7: Coding of part of the (first two) configurations CALC + µ+.	x-3121-1
Each step consists of defining the new configuration from the current one, timestamping it, and adding it to RM.	x-3121-2
This can be done with a CALC formula.	x-3121-3
For instance, suppose the current state of M is q, the content of the current cell is 0, and the corresponding move of M is to change 0 to 1, move right, and change states from q to r. Suppose also that constant _ coding b c c b d d b Figure 17.8: The relation constant _ coding corresponding to a,b,c,d t ′ is the next timestamp and , j ′ the next cell [i.e., succ k(,t, , t ′) and succ k(, j , , j ′)].	x-3121-4
The tuples describing the new configuration of M are t ′, ,i, x, y if ,i = , j , ,i = , j ′ and ,t, ,i, x, y ∈ RM; t ′, , j , 1, 0; t ′, , j ′, x, r if ,t, , j ′, x, 0 ∈ RM.	x-3122-1
In other words, (a) says that the cells other than the j th cell and the next cell remain unchanged; (b) says that the content of cell j changes from 0 to 1, and the head no longer points to the j th cell; finally, (c) says that the head points to the right adjacent cell, the new state is r, and the content of that cell is unchanged.	x-3123-1
Clearly, (a) through (c) can be expressed by a CALC formula (Exercise 17.23d).	x-3123-2
One such formula is needed for each move of M, and the formula corresponding to the finite set of possible moves is obtained by their disjunction.	x-3123-3
We have outlined queries that realize (α) and (β) (i.e., perform the encoding needed to run M and then simulate the run of M).	x-3124-1
Using these fixpoint queries and their analog for phase (γ ), it is now easy to construct the fixpoint query qM that carries out the complete computation of q.	x-3124-2
This completes the proof of (a).	x-3124-3
The construction for (b) is similar.	x-3125-1
The difference lies in the fact that a while computation need not be inflationary, unlike fixpoint computations.	x-3125-2
This simplifies the simulation.	x-3125-3
For instance, only the tuples corresponding to the current configuration of M are kept in RM (Exercise 17.24).	x-3126-1
First Order, Fixpoint, and While closure, one can obtain languages expressing qlogspace and qnlogspace on ordered databases.	x-3127-1
Theorem 17.4.2 implies that the presence of order results in increased expressive power for the fixpoint and while queries.	x-3128-1
For these languages, this is easily seen (for instance, even can be expressed by fixpoint when an order is provided).	x-3128-2
For weaker languages, the impact of order may be harder to see.	x-3128-3
For instance, it is not obvious whether the presence of order results in increased expressive power for CALC.	x-3128-4
The query even is of no immediate help, because it cannot be expressed by CALC even in the presence of order (Exercise 17.8).	x-3128-5
However, a more complicated query based on even can be used to show that CALC does indeed become more expressive with an order (Exercise 17.27).	x-3128-6
Because the CALC queries on ordered instances remain in ac0, this shows in particular that there are queries in ac0 that CALC cannot express.	x-3128-7
From Chaos to Order: A Normal Form for While We next discuss informally a normal form for the while queries that provides a bridge between computations without order and computations with order.	x-3129-1
This helps us understand the impact of order and the cost of computation without order.	x-3129-2
The normal form says, intuitively, that each while query on an unordered instance can be reduced to a while query over an ordered instance via a fixpoint query.	x-3130-1
More precisely, a while program in the normal form consists of two phases.	x-3130-2
The first is a fixpoint query that performs an analysis of the input.	x-3130-3
It computes an equivalence relation on tuples that is a congruence with respect to the rest of the computation, in that equivalent tuples are treated identically throughout the computation.	x-3130-4
Thus each equivalence class is treated as an indivisible block of tuples that is never split later in the computation.	x-3130-5
The fixpoint query outputs the equivalence classes in some order, so that each class can be thought of abstractly as an integer.	x-3130-6
The second phase consists of a while query that can be viewed as computing on an ordered database obtained by replacing each equivalence class produced in the analysis phase by its corresponding integer.	x-3130-7
The normal form also allows the clarification of the relationship between fixpoint and while.	x-3131-1
Because on ordered databases the two languages express qptime and qpspace, respectively, the languages are equivalent on ordered databases iff ptime = pspace.	x-3131-2
What about the relationship of these languages without the order assumption?	x-3131-3
It turns out that the normal form can be used to extend this result to the general case when no order is present.	x-3131-4
We do not describe the normal form in detail, but we provide some intuition on how a query on an unordered database reduces to a query on an ordered database.	x-3132-1
Consider a while program q and a particular instance.	x-3133-1
There are only finitely many CALC queries that are used in q, and the number of their variables is bounded by some integer, say k. To simplify, assume that the input instance consists of a single relation I of arity k and that all relations used in q also have arity k. We can further assume that all queries used in assignment statements are either conjunctive queries or the single algebra operations −, ∪, and that no relation name occurs twice in a query.	x-3133-2
For a query ϕ in q, ϕ(R1, .	x-3133-3
.	x-3133-4
.	x-3133-5
, Rn) indicates that R1, .	x-3133-6
.	x-3133-7
.	x-3133-8
, Rn are the relation names occurring in ϕ.	x-3133-9
Consider the set J of k-tuples formed with the constants from I .	x-3134-1
First we can distinguish between tuples based on their presence in (or absence from) I .	x-3134-2
This yields a first par- tition of J .	x-3134-3
Now using the conjunctive queries occurring in q, we can iteratively refine this partition in the following way: If for some conjunctive query ϕ(R1, .	x-3134-4
.	x-3134-5
.	x-3134-6
, Rn) occurring in q and some blocks B1, .	x-3134-7
.	x-3134-8
.	x-3134-9
, Bn of the current partition ϕ(B1, .	x-3134-10
.	x-3134-11
.	x-3134-12
, Bn) and ¬ϕ(B1, .	x-3134-13
.	x-3134-14
.	x-3134-15
, Bn) have nonempty intersection with some block B′ of the current partition, we refine the partition by splitting the block B′ into B′ ∩ ϕ(B1, .	x-3134-16
.	x-3134-17
.	x-3134-18
, Bn) and B′ ∩ ¬ϕ(B1, .	x-3134-19
.	x-3134-20
.	x-3134-21
, Bn).	x-3134-22
This is repeated until no further refinement occurs, yielding a final partition of J .	x-3134-23
Furthermore, the blocks can be numbered as they are produced, which provides an ordering J1, .	x-3134-24
.	x-3134-25
.	x-3134-26
, Jm of the blocks of the partition.	x-3134-27
The entire computation can be performed by a fixpoint query constructed from q.	x-3134-28
It is important to note that two tuples u, v in one block of the final partition cannot be separated by the computation of q on input I (i.e., at each step of this computation, each relation either contains both u and v or none).	x-3135-1
In other words, each relation contains a union of blocks of the final partition.	x-3135-2
Then one can reduce the original computation to an abstract computation q′ on the integers by replacing the ith block of the partition by integer i.	x-3135-3
Thus the original query q can be rewritten as the composition of a fixpoint query f followed by a while query q′ that essentially operates on an ordered input.	x-3135-4
Using this normal form, one can show the following: Theorem 17.4.3 While = fixpoint iff ptime = pspace.	x-3136-1
Crux The “only if” part follows from Theorem 17.4.2.	x-3137-1
The normal form is used for the	x-3137-2
Results such as Theorem 17.4.2 show that the presence of order can solve some of the problems of expressiveness of query languages.	x-3138-1
This can be interpreted as a trade-off between expressiveness and the data independence provided by the abstract interface to the database system.	x-3138-2
We conclude this section by considering an alternative to order for increasing expressive power.	x-3138-3
It is based on the use of nondeterminism.	x-3138-4
We will use the following terminology.	x-3139-1
A deterministic query is a classical query that always produces at most one output for each input instance.	x-3139-2
A nondeterministic query is a query that may have more than one possible outcome on a given input instance.	x-3139-3
Generally we assume that all possible outcomes are acceptable as answers to the query.	x-3139-4
For example, the query “Find one cinema showing Casablanca” is nondeterministic.	x-3139-5
Consider again the query even, which is not expressible by fixpoint or while.	x-3140-1
The query even is easily computed by fixpoint in the presence of order (see Exercise 17.25).	x-3140-2
Another way to circumvent the difficulty of computing even is to relax the determinism of the query language.	x-3140-3
If one could choose, whenever desired, an arbitrary element from the set, this would provide another way of enumerating the elements of the set and computing even.	x-3140-4
First Order, Fixpoint, and While R B R B R B R B R B b b b c c c b b b c b b b c b b b c I I1 I2 I3 I4 Figure 17.9: The drawback is that, with such a nondeterministic construct in the language, determinism of queries can no longer be guaranteed.	x-3141-1
The trade-offs based on order and nondeterminism are not unrelated, as it may seem at first.	x-3142-1
Suppose that an order is given.	x-3142-2
As argued earlier, this comes down to suspending the data independence principle and accessing the internal representation.	x-3142-3
In general, the computation may depend on the particular order accessed.	x-3142-4
Then at the conceptual level, where the order is not visible, the mapping defined by the query appears as nondeterministic.	x-3142-5
Different outcomes are possible for the same conceptual-level view of the input.	x-3142-6
Thus the trade-offs based on order and on relaxing determinism are intimately connected.	x-3142-7
To illustrate this, we exhibit nondeterministic versions of the while(+) and CALC+µ(+) queries.	x-3143-1
In both cases we obtain exactly the (deterministic and nondeterministic) queries computable in polynomial space (time).	x-3143-2
Analogous results can be shown for lower complexity classes of queries.	x-3143-3
Consider first the algebraic setting.	x-3144-1
We introduce a new operator called witness that provides the nondeterminism.	x-3144-2
To illustrate the use of this operator, consider the relation I in Fig.	x-3144-3
17.9.	x-3144-4
An application of witness B to I may lead to several results [i.e., witness B(I ) is either I1, I2, I3 or I4].	x-3144-5
Intuitively, for each x occurring in the A column, witness B selects some tuple x, y in I , thus choosing nondeterministically a B value y for x.	x-3144-6
More generally, for each relation J over some schema U = XY , X ∩ Y = ∅, witness Y (I ) selects one tuple , x, , y for each , x occurring in GX(J ).	x-3145-1
Observe that from this definition, witness U (J ) selects one tuple in J (if any).	x-3145-2
It is also possible to describe the semantics of the witness operator using functional dependencies: For each instance J over some schema XY , X ∩ Y = ∅, a possible result of witness Y (J ) is a maximal subinstance J ′ of J satisfying X → Y (i.e., such that the attributes in X form a key).	x-3146-1
The witness operator provides, more generally, a uniform way of obtaining nondeterministic counterparts for traditional deterministic languages.	x-3147-1
The extension of while(+) with witness is denoted by while(+)+W .	x-3148-1
Following is a useful example that shows that an arbitrary order can be constructed using the witness operator.	x-3148-2
Example 17.4.4 Consider an input instance over some unary relation schema R. The following while+W query defines all possible successor relations on the constants from R succ max b c d R succ max b c d d R succ B max c b d d b Figure 17.10: Some steps in the computation of an ordering the input (i.e., each run constructs some ordering of the constants from the input; we use the unnamed perspective): succ := witness 12(σ1=2(R × R)); max := π2( succ); R := R − (π1( succ) ∪ π2( succ)); while change do begin succ := succ ∪ witness 12( max × R); max := π2( succ) − π1( succ); R := R − max end The result is constructed in a binary relation succ.	x-3149-1
A unary relation max contains the current maximum element in succ.	x-3149-2
Some steps of a possible computation on input R = {a, b, c, d}	x-3149-3
This query can also be expressed in while++W .	x-3150-1
(See Exercise 17.31.)	x-3150-2
To continue with the nondeterministic languages, we next consider the language First Order, Fixpoint, and While CALC+µ(+).	x-3150-3
The nondeterminism is again provided by a logical operator called witness 4 and denoted W .	x-3150-4
Suppose ϕ(, x, , y) is a formula with free variables , x, , y.	x-3150-5
Intuitively, W , yϕ(, x, , y) indicates that one “witness” , yx is chosen for each , x satisfying ∃ , y ϕ(, x, , y).	x-3150-6
For example, if R consists of the relation I in Fig.	x-3151-1
17.9, the formula WyR(x, y) defines the possible answers I1, I2, I3, I4 in the same figure.	x-3151-2
[Thus WyR(x, y) is equivalent to witness B(R).]	x-3151-3
More precisely, for each formula ϕ(, x, , y) (where , x and , y are vectors of the variables that are free in ϕ), W , yϕ(, x, , y) is a formula (where the , y remain free) defining the set of relations I such that for some J defined by ϕ: I ⊆ J; and for each , x for which , x, , y is in J for some , y, there exists a unique , yx such that , x, , yx is in I.	x-3151-4
The extension of CALC+µ(+) with the witness operator is denoted by CALC+µ(+)+W .	x-3152-1
Following is a useful example that shows that an arbitrary order can be constructed using CALC+µ++W .	x-3152-2
Example 17.4.5 Consider the (unary) relation schema R of Example 17.4.4.	x-3153-1
The following CALC+µ++W query defines, on each instance I of R, all possible successor relations on the constants in I.	x-3153-2
(The output is empty if I contains fewer than two constants.)	x-3153-3
The query uses a binary relation schema succ, which is used to construct the successor relation iteratively.	x-3153-4
The query is µ+ succ(ϕ( succ))(x, y), where ϕ = ϕ1 ∨ ϕ2 and	x-3153-5
The formula ϕ1 initializes the iteration when succ is empty; ϕ2 adds to succ a tuple x, y, where y is an arbitrarily chosen element of I(R) not yet in succ and x is the current maximum element in succ.	x-3154-1
The ability of while++W and CALC+µ++W to define nondeterministically a successor relation on the constants suggests that the impact of nondeterminism on expressive power is similar to that of order.	x-3155-1
This is confirmed by the following result.	x-3155-2
Theorem 17.4.6 The set of deterministic queries that are expressed by while++W or CALC+µ++W is qptime.	x-3156-1
Proof It is easy to verify that each deterministic query expressed by while+ + W is in qptime.	x-3157-1
Conversely, let q be a query in qptime.	x-3157-2
By Theorem 17.4.2, there exists a while+ query w that expresses q if a successor relation succ on the constants is given.	x-3157-3
Then the while++W query expressing q consists of the following:	x-3157-4
Bibliographic Notes	x-3158-1
Note that Theorem 17.4.6 does not provide a language that expresses precisely qptime, because nondeterministic queries can also be expressed and it is undecidable if a while++W or CALC+µ++W query defines a deterministic query (Exercise 17.32).	x-3159-1
Instead the result shows the power of nondeterministic constructs and so points to a trade-off between expressive power and determinism.	x-3159-2
Bibliographic Notes The sequential data complexity of CALC was investigated by Vardi [Var82a], who showed that CALC is included in logspace.	x-3160-1
The parallel complexity of CALC, specifically the connection with ac0, was studied by Immerman [Imm87a].	x-3160-2
In [DV91], a database model for parallel computation is defined, and CALC is shown to coincide exactly with its restriction to constant time and polynomial size.	x-3160-3
This differs from ac0 in that the match is precise.	x-3160-4
Intuitively, this is due to the fact that the model in [DV91] is generic and does not assume an ordered encoding of the input.	x-3161-1
The first results on the expressiveness and complexity of fixpoint and while were obtained by Chandra and Harel, Vardi, and Immerman.	x-3162-1
In [CH80b] it is shown by a direct proof that fixpoint cannot express even.	x-3162-2
The result is extended to while in [Cha81a].	x-3162-3
The fundamental result that fixpoint expresses qptime on ordered instances was obtained independently by Immerman [Imm86] and Vardi [Var82a].	x-3163-1
The fact that while on ordered instances expresses qpspace is shown in [Var82a].	x-3163-2
Languages expressing complexity classes of queries below qptime are investigated in [Imm87b].	x-3164-1
They are based on augmenting CALC with operators providing limited recursion, such as various forms of transitive closure.	x-3164-2
The classes of queries expressed by the resulting languages on ordered databases include deterministic logspace, denoted logspace, nondeterministic logspace, denoted nlogspace, and symmetric logspace, denoted slogspace.	x-3164-3
There has been a long quest for a language expressing precisely qptime on arbitrary (unordered) databases.	x-3165-1
The problem is formalized in a general setting in [Gur88], where it is also conjectured that no such language exists.	x-3165-2
The issue is further investigated in	x-3165-3
In the absence of a language for qptime, there have been several proposals to extend the fixpoint queries to capture more of qptime.	x-3166-1
Recall that queries involving counting (such as even) are not in fixpoint.	x-3166-2
Therefore it is natural to consider extensions of fixpoint with counting constructs.	x-3166-3
An early proposal by Chandra [Cha81a] is to add a bounded looping construct of the form For |R| do, which iterates the body of the loop |R| times.	x-3166-4
Clearly, this construct allows us to express even.	x-3166-5
However, it has been shown that bounded looping is not sufficient to yield all of qptime, because tests |R1| = |R2| cannot be expressed (see [Cha88]).	x-3166-6
More recently, extensions of fixpoint with counting constructs have been considered and studied in [CFI89, GO93].	x-3166-7
They allow access to the cardinality of relations as well as limited integer manipulation.	x-3166-8
These languages are more powerful than fixpoint First Order, Fixpoint, and While but, as shown in [CFI89], still fall short of expressing all of qptime.	x-3166-9
Other results of this flavor are proven in [Daw93, Hel92].	x-3166-10
They show that extending fixpoint with a finite set of polynomial-time computable constructs of certain forms (generalized quantifiers acting much like oracles) cannot yield a language expressing exactly qptime (see Exercise 17.35 for a simplified version of this result).	x-3166-11
The normal form for while was proven in [AV91b, AV94].	x-3167-1
It was also shown there, using the normal form, that fixpoint and while are equivalent iff ptime = pspace.	x-3167-2
The cost of computing without an order is also investigated in [AV91b, AV94].	x-3167-3
This is formalized using an alternative model of computation called generic machine (GM).	x-3167-4
Unlike Turing machines, GMs do not require an ordered encoding of the input and use only the information provided by the input instance.	x-3167-5
Based on GM, generic complexity classes of queries are defined.	x-3167-6
For example, gen-ptime and gen-pspace are obtained by taking polynomial time and space restrictions of GM.	x-3167-7
As a typical result, it is shown that even is not in gen-pspace, which captures the intuition that this query is hard to compute without order.	x-3167-8
Another more restricted device, also operating without encodings, is the relational machine, also considered in [AV91b, AV94].	x-3167-9
There is a close match between complexity classes defined using this device, called relational complexity classes, and various languages.	x-3167-10
For example, relational polynomial time coincides with fixpoint and relational polynomial space with while.	x-3167-11
Further connections between languages and relational complexity classes are shown in [AVV92].	x-3167-12
Nondeterministic languages and their expressive power are investigated in [ASV90, AV91a, AV91c].	x-3168-1
The languages include nondeterministic extensions of CALC+µ+ and CALC+µ and of rule-based languages such as datalog¬.	x-3168-2
Strong connections between these languages are shown (see Exercise 17.33).	x-3168-3
Nondeterministic languages that can express all the qptime queries are exhibited.	x-3168-4
The Ehrenfeucht-Fraissé games are due to Ehrenfeucht [Ehr61] and Fraissé [Fra54].	x-3169-1
Since their work, extensions of the games have been proposed and related to various languages such as datalog [LM89], fragments of infinitary logic [KV90c], fixpoint queries, and second-order logic [Fag75, AF90, dR87].	x-3170-1
In [Imm82, CFI89], games are used to prove lower bounds on the number of variables needed to express certain graph properties.	x-3170-2
Typically, in the extensions of Ehrenfeucht-Fraissé games, choosing a constant in an instance is thought of as placing a pebble over that constant (the games are often referred to as pebble games).	x-3170-3
Like the Ehrenfeucht-Fraissé games, these are two-player games in which one player attempts to prove that the instances are not the same and the other attempts to prove the contrary by placing the pebbles such that the corresponding subinstances are isomorphic.	x-3170-4
The games differ in the rules for taking turns among players and instances, the number of pebbles placed in one move, whether the pebbles are colored, etc.	x-3170-5
In games corresponding to languages with recursion, players have more than one chance for achieving Exercises G[00#01][10#00][10#01][01#01]#[10] Figure 17.11: Encoding of an instance and tuple their objective by removing some of the pebbles and restarting the game.	x-3170-6
Our presentation of Ehrenfeucht-Fraissé games was inspired by Kolaitis’s excellent lecture notes [Kol83].	x-3170-7
The study of 0-1 laws was initiated by Fagin and Glebski˘i.	x-3171-1
The 0-1 law for CALC was proven in [Fag72, Fag76] and independently by Glebski˘i et al.	x-3171-2
[GKLT69].	x-3171-3
The 0-1 law for fixpoint was shown by Blass, Gurevich, and Kozen [BGK85] and Talanov and Knyazev [TK84].	x-3171-4
This was extended to while by Kolaitis and Vardi, who proved further extensions of 0-1 laws for certain fragments of second-order logic [KV87, KV90b] and for infinitary logic with finitely many variables [KV92], both of which subsume while.	x-3171-5
For instance, 0-1 laws were proven for existential second-order sentences ∃Q1 .	x-3172-1
.	x-3172-2
.	x-3172-3
∃Qkσ , where the Qi are relation variables and σ is a CALC formula in prenex form, whose quantifier portion has one of the shapes ∃∗∀∗ or ∃∗∀∃∗.	x-3172-4
It is known that arbitrary existential second-order sentences do not have a 0-1 law (see Exercise 17.21).	x-3172-5
Infinitary logic is an extension of CALC that allows infinite disjunctions and conjunctions.	x-3172-6
Kolaitis and Vardi proved that the language consisting of infinitary logic sentences that use only finitely many variables has a 0-1 law.	x-3172-7
Note that this language subsumes while (Exercise 17.22).	x-3172-8
Another aspect of 0-1 laws that has been studied involves the difficulty of deciding whether a sentence in a language that has a 0-1 law is almost surely true or whether it is almost surely false.	x-3172-9
For instance, Grandjean proved that the problem is pspace complete for CALC	x-3172-10
Fagin [Fag93] presents a survey of finite model theory including 0-1 laws that inspired our presentation of this topic.	x-3173-1
Exercises Exercise 17.1 Consider the CALC query on a database schema with one binary relation G: ϕ = {x | ∃y∀z(G(x, y) ∧ ¬G(z, x))}.	x-3174-1
Consider the instance I over G and tuple encoded on a Turing input tape, as shown in Fig.	x-3175-1
17.11.	x-3175-2
Describe in detail the computation of the Turing machine Mϕ, outlined in the proof of Theorem 17.1.1, on this input.	x-3176-1
Exercise 17.3 Prove that ≡r is an equivalence relation on instances.	x-3177-1
Exercise 17.4 Outline the crux of Theorem 17.2.2 for the case where	x-3178-1
First Order, Fixpoint, and While Exercise 17.6 Extend Proposition 17.2.3 by showing that connectivity of graphs is not first-order definable even if an order ≤ on the constants is provided.	x-3179-1
More precisely, let R be the database schema consisting of two binary relations G and ≤.	x-3179-2
Let I≤ be the family of instances I over R such that I(≤) provides a total order on the constants of I(G).	x-3179-3
Outline a proof that there is no CALC sentence σ such that, for each I ∈ I≤,	x-3179-4
The following two exercises lead to a proof of the converse of Theorem 17.2.2.	x-3180-1
It states that instances that are undistinguishable by CALC sentences of quantifier depth r are equivalent with respect to ≡r.	x-3180-2
This is shown by proving that each equivalence class of ≡r is definable by a special CALC sentence of quantifier depth r, called the r-type of the equivalence class.	x-3180-3
Intuitively, the r-type sentence describes all patterns that can be detected by playing games of length r on pairs of instances in the equivalence class.	x-3181-1
To define the r-types, one first defines formulas with m free variables, called (m, r)-types.	x-3182-1
ik i1 ik is in ϕ.	x-3183-1
Suppose the set of (m + 1, r)-types has been defined.	x-3183-2
Each set S of (m + 1, r)-types gives rise to one (m, r)-type defined by	x-3183-3
sentence of quantifier depth r. Hint: For a given equivalence class of ≡r, consider an instance in the class and the unique r-type satisfied by the instance.	x-3184-1
Exercise 17.11 Complete the proof of Theorem 17.3.1; specifically show that Exercises	x-3185-1
Exercise 17.12 In the proof of Proposition 17.3.2, the case of assignments of the form T := Q1 × Q2 was discussed.	x-3186-1
Describe the constructions needed for the other algebra operators.	x-3186-2
Point out where the assumption that the size of I is greater than N is used.	x-3186-3
Exercise 17.15 Recall the technique of hyperplanes used in the proof of Proposition 17.3.2.	x-3187-1
D × · · · × D (arity of R times).	x-3188-1
The cross-product instance of database D schema R over D is the instance IR for each R ∈ R. Let P D be a datalog¬ program with no constants, input schema R, and output schema S with arity k. Prove that there is an N > 0 and a set EP of equivalence relations over [1, k] such that for each set D ⊆ dom: if |D| ≥ N then	x-3188-2
P (IR D	x-3189-1
Exercise 17.16 In the proof of Lemma 17.3.6, prove more formally the bound on µn(¬σk).	x-3190-1
Prove that its limit is 0 when n goes to ∞.	x-3191-1
Exercise 17.17 Determine whether the following properties of graphs are almost surely true or whether they are almost surely false.	x-3192-1
Exercise 17.18 Prove that there is a finite number of equivalence classes of k-tuples induced by automorphisms of the Rado graph.	x-3193-1
Hint: Each class is completely characterized by the pattern of connection and equality among the coordinates of the k-tuple.	x-3193-2
To see this, show that for all tuples u and v satisfying this property, one can construct an automorphism ρ of the Rado graph such that ρ(u) = v. The automorphism is constructed using the extension axioms, similar to the proof of Lemma 17.3.5.	x-3193-3
Exercise 17.20 Prove or disprove: The properties expressible in fixpoint are exactly the ptime properties that have a 0-1 law.	x-3194-1
First Order, Fixpoint, and While Exercise 17.21 The language existential second-order logic, denoted (∃SO), consists of sentences of the form ∃Qi .	x-3195-1
.	x-3195-2
.	x-3195-3
∃Qkσ , where Qi are relations and σ is a first-order sentence using the relations Qi (among others).	x-3195-4
Show that ∃SO does not have a 0-1 law.	x-3195-5
Hint: Exhibit a property expressible in ∃SO that is neither almost surely true nor almost surely false.	x-3195-6
CALC that allows formulas with infinitely long conjunctions and disjunctions but using only a finite number of variables.	x-3196-1
Show that each while query can be expressed in Lω	x-3196-2
with a specific example, such as transitive closure.	x-3197-1
Exercise 17.23 The following refer to the proof of Theorem 17.4.2.	x-3198-1
Exercise 17.24 Spell out the differences in the proofs of (a) and (b) in Theorem 17.4.2.	x-3199-1
Exercise 17.25 Write a fixpoint query that computes the parity query even on ordered databases.	x-3200-1
Exercise 17.26 Consider queries of the form Does the diameter of G have property P?	x-3201-1
where P is an exptime property of the integers (i.e., a property that can be checked, for integer n, in time exponential in log n, or polynomial in n).	x-3202-1
Show that each query as above is a fixpoint query.	x-3202-2
T = {x | S(s, x)}.	x-3203-1
Consider the query q defined by q(I) = true iff I is a good input and |I(D)| is even.	x-3204-1
Exercises	x-3205-1
Explain the difficulty of proving (b) if a successor relation is used instead of ≤.	x-3206-1
Hint: For (a), use Ehrenfeucht-Fraissé games.	x-3207-1
Consider (b).	x-3207-2
To check that the input is good, check that (1) all singleton subsets of I(D) are represented, and (2) if T1 and T2 are represented, so is T1 ∪ T2.	x-3207-3
To check evenness of |I(D)| on good inputs, define first from ≤ a successor relation succ D on the constants in I(D); then check that there exists a subset T of I(D) consisting of the even constants according to succ D and that the last element in succ D is in T .	x-3207-4
Exercise 17.29 Show that	x-3208-1
Exercise 17.30 Write a CALC+µ++W formula defining the query even.	x-3209-1
Exercise 17.31 Express the query of Example 17.4.4 in while++W .	x-3210-1
First Order, Fixpoint, and While computes the query P − πA(Q).	x-3211-1
Prove that N-datalog¬∀ is equivalent to CALC+µ++W and while++W and expresses all nondeterministic queries computable in polynomial time.	x-3211-2
with a variation of the choice operator (see Bibliographic Notes) is introduced in [CGP93].	x-3212-1
Datalog= programs are extended by allowing atoms of the form choice(X,Y) in rules of bodies, where X and Y are disjoint sets of variables occurring in regular atoms of the rule.	x-3213-1
Several choice atoms can appear in one rule.	x-3213-2
The language obtained is called datalog=+ choice.	x-3213-3
The semantics is the following.	x-3213-4
The choice atoms render the immediate consequence operator of a datalog=+ choice program P nondeterministic.	x-3213-5
In each application of TP , a subset of the applicable valuations is chosen so that for each rule containing an occurrence choice(X,Y), the functional dependency X → Y holds.	x-3213-6
That is, one instantiation for the Y variables is chosen for each instantiation of the X variables.	x-3213-7
Moreover, the nondeterministic choices operated at each application of TP for a given occurrence of a choose atom extend the choices made in previous applications of TP for that atom.	x-3213-8
(Thus choose has a more global nature than the witness operator.)	x-3213-9
Although negation is not used in datalog=+ choice, it can be simulated.	x-3213-10
The following datalog=+ choice program computes in ¯ P the complement of a nonempty relation P with respect to a universal relation T of the same arity [CGP93]: TAG(X, 0) TAG(X, 1) COMP(X, I ) ← TAG(X, I ), choose(X, I ) P (X) The role of choose in the preceding program is simple.	x-3213-11
When first applied, it associates with each X in P the tag I = 0.	x-3213-12
At the second application, it chooses a tag of 0 or 1 for all tuples in T .	x-3213-13
However, tuples in P have already been tagged by 0 in the previous application of choose, so the tuples tagged by 1 are precisely those in the complement.	x-3213-14
Exercises	x-3214-1
Let while+(Q) be the extension of while+ allowing loops of the form while q(R1, .	x-3215-1
.	x-3215-2
.	x-3215-3
, Rn) do, where q ∈ Q and R1, .	x-3215-4
.	x-3215-5
.	x-3215-6
, Rn are relation variables compatible with the schema of q.	x-3215-7
Intuitively, this allows us to ask whether R1, .	x-3215-8
.	x-3215-9
.	x-3215-10
, Rn have property q.	x-3215-11
Clearly, while+(Q) generally has more power than while+.	x-3215-12
For example, the query even is trivially expressible in while+({ even}).	x-3215-13
One might wonder if there is choice of Q such that while+(Q) expresses exactly qptime.	x-3216-1
Let ptime[k] denote the set of properties whose time complexity is bounded by some polynomial of degree k. Show that, for each ptime property q, the properties of unary relations definable in while+({q}) are in ptime[k] for some k depending only on 1 q.	x-3217-1
Hint: Show that for each while+({q}) program there exist N > 0 and properties 1 q1, .	x-3217-2
.	x-3217-3
.	x-3217-4
, qm of integers where each qi(n) can be checked in time polynomial in n, such that the program is equivalent to a Boolean combination of tests n ≥ j, n = j, qi(n), where n is the size of the input, 0 ≤ j ≤ N and 1 ≤ i ≤ m. Use the hyperplane technique developed in the proof of Proposition 17.3.2.	x-3217-5
Languages I still cannot check if I have an even number of shoes.	x-3218-1
Riccardo: This will not stand!	x-3219-1
Sergio: We now provide languages that do just that.	x-3220-1
Vittorio: They can also express any query you can think of.	x-3221-1
In previous chapters, we studied a number of powerful query languages, such as the fixpoint and while queries.	x-3222-1
Nonetheless, there are queries that these languages cannot express.	x-3222-2
As pointed out in the introduction to Chapter 14, fixpoint lies within ptime, and while within pspace.	x-3222-3
The complexity bound implies that there are queries, of complexity higher than pspace, that are not expressible in the languages considered so far.	x-3222-4
Moreover, we showed simple, specific queries that are not in fixpoint or while, such as the query even.	x-3222-5
In this chapter, we exhibit several powerful languages that have no complexity bound on the queries they can express.	x-3223-1
We build up toward languages that are complete (i.e., they express all queries).	x-3223-2
Recall that the notion of query was made formal in Chapter 16.	x-3223-3
Basically, a query is a mapping from instances of a fixed input schema to instances of a fixed answer schema that is computable and generic.	x-3224-1
Recall that, as a consequence, answers to queries contain only constants from the input (except possibly for some fixed, finite set of new constants).	x-3224-2
We begin with a language that extends while by providing arbitrary computing power outside the database; this yields a language denoted while N , in the style of embedded relational languages like C+SQL.	x-3225-1
This would seem to provide the simplest cure for the computational limitations of the languages exhibited so far.	x-3225-2
There is no complexity bound on the queries while N can express.	x-3225-3
Surprisingly, we show that, nonetheless, while N is not complete.	x-3225-4
In fact, while N cannot express certain simple queries, including the infamous query even.	x-3225-5
Intuitively, while N is not complete because the external computation has limited interaction with the database.	x-3225-6
Complete languages are obtained by overcoming this limitation.	x-3225-7
Specifically, we present two ways to do this: (1) by extending while with the ability to create new values in the course of the computation, and (2) by extending while with an untyped version of relational algebra that allows relations of variable arity.	x-3225-8
For conciseness, in this chapter we do not pursue the simultaneous development of languages in the three paradigms—algebraic, logic, and deductive.	x-3226-1
Instead we choose to focus on the algebraic paradigm.	x-3226-2
However, analogous languages could be developed in the other paradigms (see Exercise 18.22).	x-3226-3
WhileN— while with Arithmetic The language while is the most powerful of the languages considered so far.	x-3227-1
We have seen that it lies within pspace.	x-3227-2
Thus it does not have full computing power.	x-3227-3
Clearly, a complete language must provide such power.	x-3227-4
In this section, we consider an extension of while that does provide full computing power outside the database.	x-3227-5
Nonetheless, we will show that the resulting language is not complete; it is important to understand why this is so before considering more exotic ways of augmenting languages.	x-3227-6
The extension of while that we consider allows us to perform, outside the database, arbitrary computations on the integers.	x-3228-1
Specifically, the following are added to the while language:	x-3228-2
The semantics is straightforward.	x-3229-1
All integer variables are initialized to zero.	x-3229-2
The semantics of the while change construct is not affected by the integer variables (i.e., the loop is executed as long as there is a change in the content of a relational variable).	x-3229-3
The resulting language is denoted by while N.	x-3230-1
Because the language while N can simulate an arbitrary number of counters, it is computationally complete on the integers (see Chapter 2).	x-3231-1
More precisely, the following holds: Fact For every computable function f (i1, .	x-3231-2
.	x-3231-3
.	x-3231-4
, ik) on integers, there exists a while N program wf that computes f (i1, .	x-3231-5
.	x-3231-6
.	x-3231-7
, ik) for every integer initialization of i1, .	x-3231-8
.	x-3231-9
.	x-3231-10
, ik.	x-3231-11
In particular, wf stops on input i1, .	x-3231-12
.	x-3231-13
.	x-3231-14
, ik iff f is defined on (i1, .	x-3231-15
.	x-3231-16
.	x-3231-17
, ik).	x-3231-18
In view of this fact, one can use in while N programs, whenever convenient, statements of the form n := f (i1, .	x-3232-1
.	x-3232-2
.	x-3232-3
, ik), where n, i1, .	x-3232-4
.	x-3232-5
.	x-3232-6
, ik are integer variables and f is a computable function on the integers.	x-3232-7
This is used in the following example.	x-3232-8
Example 18.1.1 Let G be a binary relation with attributes AB.	x-3233-1
Consider the query on the graph G: square(G) = ∅ if the diameter of G is a perfect square, and G otherwise.	x-3233-2
The following while N program computes square(G) (the output relation is answer; it is assumed that G = ∅): i := 0; T := G; Highly Expressive Languages while change do begin T := T ∪ πAB(δB→C(T ) ⊲⊳ δA→C(G)); increment(i); end; j := f (i); if j > 0 then answer := ∅.	x-3234-1
where f is the function such that f (x) = 1 if x is a perfect square and f (x) = 0 otherwise.	x-3235-1
It turns out that the preceding program can been expressed in while alone, and even fixpoint, without the need for arithmetic (see Exercise 18.2).	x-3236-1
However, this is clearly not the case in general.	x-3236-2
For instance, consider the while N program obtained by replacing f in the preceding program by some arbitrary computable function.	x-3236-3
Despite its considerable power, while N cannot express certain simple queries, such as even.	x-3237-1
There are several ways to show this, just as we did for while.	x-3237-2
Recall that, in Chapter 17, it was shown that while has a 0-1 law.	x-3237-3
It turns out that while N also has a 0-1 law, although proving this is beyond the scope of this book.	x-3237-4
Thus there are many queries, including even, that while N cannot express.	x-3237-5
One can also give a direct proof that even cannot be expressed by while N by extending straightforwardly the hyperplane technique used in the direct proof that while cannot express even (Proposition 17.3.2, see Exercise 18.3).	x-3237-6
Theorem 18.1.2 The language while N expresses all queries on ordered databases.	x-3238-1
Crux Let q be a query on an ordered database with schema R. Let I denote an input instance over R and α the enumeration of constants in I given by the relation succ.	x-3239-1
By the definition of query, there exists a Turing machine Mq that, given as input encα(I), produces as output encα(q(I)) (whenever q is defined on I).	x-3239-2
Because while N manipulates integers, we wish to encode I as an integer rather than a Turing machine tape.	x-3239-3
This can be done easily because each word over some finite alphabet with k symbols (with some arbitrary order among the symbols) can be viewed as an integer in base k. For any instance J, let enc∗α(J) denote the integer encoding of J obtained by viewing encα(J) as an integer.	x-3239-4
It is easy to see that there is a computable function fq on the integers such that fq(enc∗α(I)) = enc∗α(q(I)) whenever q is defined on I.	x-3239-5
Furthermore, because while N can express any computable function over the integers (see the preceding Fact), there exists a while N program wf (i) q that computes fq.	x-3239-6
It is left to show that while N can compute enc∗α(I) and can decode q(I) from enc∗α(q(I)).	x-3239-7
Recall that, in the proof of Theorem 17.4.2, it was shown that while can compute a relational representation of encα(I) and, conversely, it can decode q(I) from the representation of encα(q(I)).	x-3239-8
A slight modification of that construction can be used to S R b b c c c c Figure 18.1: show that while N can compute the desired integer encoding and decoding.	x-3239-9
Thus a while N program computes q in three phases:	x-3239-10
Whilenew — while with New Values Recall that, as discussed in the introduction to Chapter 14, while cannot go beyond pspace because (1) throughout the computation it uses only values from the input, and (2) it uses relations of fixed arity.	x-3240-1
The addition of integers as in while N is one way to break the space barrier.	x-3240-2
Another is to relax (1) or (2).	x-3240-3
Relaxing (1) is done by allowing the creation of new values not present in the input.	x-3240-4
Relaxing (2) yields an extension of while with untyped algebra (i.e., an algebra of relations with variable arities).	x-3240-5
In this and the next section, we describe two languages obtained by relaxing (1) and (2) and prove their completeness.	x-3240-6
We first present the extension of while denoted whilenew, which allows the creation of new values throughout the computation.	x-3241-1
The language while is modified as follows: (i) There is a new instruction R := new(S), where R and S are relational variables and arity(R) = arity(S) + 1;	x-3241-2
The semantics of (i) is as follows: Relation R is obtained by extending each tuple of S by one distinct new value from dom not occurring in the input, the current state, or in the program.	x-3242-1
For example, if the value of S is the relation in Fig.	x-3242-2
18.1, then R is of the form shown in that figure.	x-3242-3
The values α, β, γ are distinct new values1 in dom.	x-3242-4
The semantics of while R do s is that statement s is executed while R is nonempty.	x-3243-1
We could have used while change instead because each looping construct can simulate the other.	x-3244-1
However, in our context of value invention, it is practical to have the more direct control on loops provided by while R.	x-3244-2
Highly Expressive Languages Note that the new construct is, strictly speaking, nondeterministic.	x-3245-1
The new values are arbitrary, so several possible outcomes are possible depending on the choice of values.	x-3245-2
However, the different outcomes differ only in the choice of new values.	x-3246-1
This is formalized by the following: Lemma 18.2.1 Let w be a whilenew program with input schema R, and let R be a relation variable in w. Let I be an instance over R, and let J, J ′ be two possible values of R at the same point during the execution of w on I.	x-3246-2
Then there exists an isomorphism ρ from J to J ′ that is the identity on the constants occurring in I or w.	x-3246-3
The proof of Lemma 18.2.1 is done by a straightforward induction on the number of steps in a partial execution of w on I (Exercise 18.7).	x-3247-1
Recall that our definition of query requires that the answer be unique (i.e., the query must be deterministic).	x-3248-1
Therefore we must consider only whilenew programs whose answer never contains values introduced by the new statements.	x-3248-2
Such programs are called well-behaved whilenew programs.	x-3248-3
It is possible to give a syntactic restriction on whilenew programs that guarantees good behavior, can be checked, and yields a class of programs equivalent to all well-behaved whilenew programs (see Exercises 18.8 and 18.9).	x-3248-4
We wish to show that well-behaved whilenew programs can express all queries.	x-3249-1
First we have to make sure that well-behaved whilenew programs do in fact express queries.	x-3249-2
This is shown next.	x-3249-3
Lemma 18.2.2 Each well-behaved whilenew program with input schema R and output schema answer expresses a query from inst(R) to inst(answer).	x-3250-1
Proof We need to show that well-behaved whilenew programs define mappings from inst(R) to inst(answer) (i.e., they are deterministic with respect to the final answer).	x-3251-1
Computability and genericity are straightforward.	x-3251-2
Let w be a well-behaved whilenew program with input schema R and output answer.	x-3251-3
Let I, I ′ be two possible values of answer after the execution of w on an instance I of R. By Lemma 18.2.1, there exists an isomorphism ρ from I to I ′ that is the identity on values in I or w. Because w is well behaved, answer contains only values from I or w. Thus ρ is the identity and I = I ′.	x-3251-4
Note that although well-behaved programs are deterministic with respect to their final answer, they are not deterministic with respect to intermediate results that may contain new values.	x-3252-1
We next show that well-behaved whilenew programs express all queries.	x-3253-1
The basic idea is simple.	x-3253-2
Recall that while N is complete on ordered databases.	x-3253-3
That is, for each query q, there is a while N program w that, given an enumeration of the input values in a relation succ, computes q.	x-3253-4
If, given an input, we were able to construct such an enumeration, we could then simulate while N to compute any desired query.	x-3253-5
Because of genericity, we cannot hope to construct one such enumeration.	x-3253-6
However, constructing all enumerations of values in the input would not violate genericity.	x-3253-7
Both whilenew and the language with variable arities considered in the next section can compute arbitrary queries precisely in this fashion: They first compute all possible enumerations of the input values and then simulate a while N program on the ordered database corresponding to each enumeration.	x-3253-8
These computations yield the same result for all enumerations because queries are generic, so the result is independent of the particular enumeration used to encode the database (see Chapter 16).	x-3254-1
Before proving the result, we show how we can construct all the possible enumerations of the elements in the active domain of the input.	x-3255-1
Representation Let I be an instance over R. Let Success be the set of all binary relations defining a successor relation over adom(I).	x-3256-1
We can represent all the enumerations in Success with a 3-ary relation:	x-3256-2
succ = I × {αI }, I ∈ Success where {αI | I ∈ Success} is a set of distinct new values.	x-3257-1
[Each such αI is used to denote a particular enumeration of adom(I).]	x-3257-2
For example, Fig.	x-3257-3
18.2 represents an instance I and the corresponding succ.	x-3257-4
Computation of succ We now argue that there exists a whilenew program w that, given I, computes succ.	x-3258-1
Clearly, there is a whilenew program that, given I, produces a unary relation D containing all values in I.	x-3258-2
Following is a whilenew program w succ that computes the relation succ starting from D (using a query q explained next): I succ	x-3258-3
succ b b b b c c b c b c b c c c c c b c b c b c b b b b c c c b c b c b c b c c c b c c c c b b b c b c b c b c b b b c b Figure 18.2: succ Highly Expressive Languages succ := new(σ1=2(D × D)); while 8 do begin S := new(8);	x-3259-1
succ := x, y, α′	x-3260-1
end The intuition is that we construct in turn enumerations of subsets of size 2, 3, etc., until we obtain the enumerations of D. (To simplify, we assume that D contains more than two elements.)	x-3261-1
An enumeration of a subset of D consists of a successor (binary) relation over that subset.	x-3261-2
As mentioned earlier, the program associates a marking (invented value) with each such successor relation.	x-3261-3
During the computation, succ contains the successor relation of subsets of size i computed so far.	x-3262-1
A triple a, b, α indicates that b follows a in enumeration denoted α.	x-3262-2
The first instruction computes the enumerations of subsets of size 2 (i.e., the distinct pairs of elements of D) and marks them with new values.	x-3263-1
At each iteration, 8 indicates for each enumeration the elements that are missing in this enumeration.	x-3263-2
More precisely, relation 8 must contain the following set of triples:	x-3263-3
b does not occur in the successor relation corresponding to α	x-3264-1
The relational query q computes the set 8 given a particular relation succ.	x-3265-1
If 8 is not empty, for each α a new value α′ is created for each element missing in α (i.e., the enumeration α is extended in all possible ways with each of the missing elements).	x-3265-2
This yields as many new enumerations from each α as missing elements.	x-3265-3
This is iterated until 8 becomes empty, at which point all enumerations are complete.	x-3266-1
Note that if D contains n elements, the final result succ contains n!	x-3267-1
enumerations.	x-3267-2
Theorem 18.2.3 The well-behaved whilenew programs express all queries.	x-3268-1
Crux Let q be a query from inst(R) to inst( answer).	x-3269-1
Assume the query is generic (i.e., C-generic with C = ∅).	x-3269-2
The proof is easily modified for the case when the query is C-generic with C = ∅.	x-3269-3
It is sufficient to observe that for each while N program, there exists an equivalent well-behaved whilenew program.	x-3269-4
Suppose that (*) holds.	x-3270-1
Let w succ be the whilenew program computing succ from given I over R. By Theorem 18.1.2 and (*), there exists a whilenew program w( succ) that computes q using a successor relation succ.	x-3270-2
We construct another whilenew program w( succ) that computes q given I and succ.	x-3270-3
Intuitively, w( succ) is run in parallel for all possible enumerations succ provided by succ.	x-3270-4
All computations produce the same result and are placed in answer.	x-3270-5
The computations for different enumerations in succ are identified by the α marking the enumeration in succ.	x-3270-6
To this end, each relation R of arity k in w( succ) is replaced by a relation R of arity k + 1.	x-3270-7
The extended database relations are first initialized by statements of the form R := R × π3( succ).	x-3270-8
Next the instructions of w( succ) are modified as follows:	x-3270-9
Finally the instruction answer := π1..n( answer), where n = arity( answer), is appended at the end of the program.	x-3271-1
The following can be shown by induction on the steps of a partial execution of w( succ) on I (Exercise 18.10): marked with α coincides with the value of R at the same point in the computation when w( succ) is run on I and succ is the successor relation corresponding to α.	x-3271-2
In particular, at the end of the computation of w( succ) on I, answer = w(α)(I) × {α}, where α ranges over the enumeration markers.	x-3272-1
Because w(α)(I) = q(I) for each α, it follows that answer contains q(I) at the end of the computation.	x-3272-2
Thus query q is computable by a well-behaved whilenew program.	x-3272-3
Thus it remains to show (*).	x-3273-1
Integer variables are easily simulated as follows.	x-3273-2
An integer variable i is represented by a binary variable Ri.	x-3273-3
If i contains the integer n, then Ri contains a successor relation for n + 1 distinct new values:	x-3273-4
We showed that well-behaved whilenew programs are complete with respect to our definition of query.	x-3274-1
Recall that whilenew programs that are not well behaved can compute a different kind of query that we excluded deliberately, which contains new values in the answer.	x-3274-2
It turns out, however, that such queries arise naturally in the context of object-oriented databases, where new object identifiers appear in query results (see Chapter 21).	x-3274-3
This requires extending our definition of query.	x-3275-1
In particular, the query is nondeterministic but, as discussed earlier, the different answers differ only in the particular choice of new values.	x-3275-2
This leads to the following extended notion of query: Definition 18.2.4 Highly Expressive Languages b Figure 18.3:	x-3275-3
Let Q be a determinate query.	x-3276-1
If I, J ∈ Q and ρ is a one-to-one mapping on constants leaving I fixed, then I, ρ(J ) ∈ Q.	x-3276-2
The question arises whether whilenew remains complete with respect to this extended notion of query.	x-3277-1
Surprisingly, the answer is negative.	x-3277-2
Each whilenew query is determinate.	x-3277-3
However, we exhibit a simple determinate query that whilenew cannot express.	x-3277-4
Let q be the query with input schema R = {S}, where S is unary, and output G, where G is binary.	x-3277-5
Let q be defined as follows: For each input I over S, if I = {a, b} then q(I ) = {ψ0, ψ1, ψ1, ψ2, ψ2, ψ3, ψ3, ψ0, ψ0, b, ψ1, a, ψ2, b, ψ3, a} for some new elements ψ0, ψ1, ψ2, ψ3, and q(I ) = ∅ otherwise (Fig.	x-3277-6
18.3).	x-3277-7
Theorem 18.2.5 The query q is not expressible in whilenew.	x-3278-1
Proof The proof is by contradiction.	x-3279-1
Suppose w is a whilenew program expressing q.	x-3279-2
Consider the sequence of steps in the execution of w on an input I = {a, b}.	x-3280-1
We can assume without loss of generality that no invented value is ever deleted from the database (otherwise modify the program to keep all invented values in some new unary relation).	x-3280-2
For each invented value occurring in the computation, we define a trace that records how the value was invented and uniquely identifies it.	x-3280-3
More precisely, trace(α) is defined inductively as follows.	x-3280-4
If α is a constant, then trace(α) = α.	x-3280-5
Suppose α is a new value created at step i with a new statement associating it with tuple x1, .	x-3280-6
.	x-3280-7
.	x-3280-8
, xk.	x-3280-9
Then trace(α) = i, trace(x1), .	x-3280-10
.	x-3280-11
.	x-3280-12
, trace(xk).	x-3280-13
Clearly, one can extend trace to tuples and rela- tions in the natural manner.	x-3280-14
It is easily shown (Exercise 18.11) by induction on the number of steps in a partial execution of w on I that	x-3280-15
Consider now trace(q(I )) and the automorphism ρ of I [and therefore of trace(q(I ))] defined by ρ(a) = b, ρ(b) = a.	x-3281-1
Note that ρ2 = id (the identity) and ρ = ρ−1.	x-3281-2
Consider ρ( trace(ψ0)).	x-3281-3
Because ψ0, b ∈ q(I ), it follows that trace(ψ0), b ∈ trace(q(I )).	x-3281-4
Because ρ(b) = a, it further follows that ρ( trace(ψ0)), a ∈ trace(q(I )) so ρ( trace(ψ0)) is either trace(ψ1) or trace(ψ3).	x-3281-5
Suppose ρ( trace(ψ0)) = trace(ψ1) (the other case is similar).	x-3281-6
From the fact that ρ is an automorphism of trace(q(I )) it follows that ρ( trace(ψ3)) = trace(ψ0), ρ( trace(ψ2)) = trace(ψ3), and ρ( trace(ψ1)) = trace(ψ2).	x-3281-7
Consider now ρ2.	x-3281-8
First, because ρ2 = id, ρ2( trace(ψi)) = trace(ψi), 0 ≤ i ≤ 3.	x-3282-1
On the other hand, ρ2( trace(ψ0)) = ρ(ρ( trace(ψ0))) = ρ( trace(ψ1)) = trace(ψ2).	x-3282-2
This is a contradiction.	x-3282-3
Hence q cannot be computed by whilenew.	x-3283-1
The preceding example shows that the presence of new values in the answer raises interesting questions with regard to completeness.	x-3284-1
There exist languages that express all queries with invented values in answers (see Exercise 18.14 for a complex construct that leads to a determinate-complete language).	x-3284-2
Value invention is common in object-oriented languages, in the form of object creation constructs (see Chapter 21).	x-3284-3
Whileuty— while We briefly describe in this section an alternative complete language obtained by relaxing the fixed-arity requirement of the languages encountered so far.	x-3285-1
This relaxation is done using an untyped version of relational algebra instead of the familiar typed version.	x-3285-2
We will obtain a language allowing us to construct relations of variable, data-dependent arity in the course of the computation.	x-3285-3
Although strictly speaking they are not needed, we also allow integer variables and integer manipulation, as in while N. Intuitively, it is easy to see why this yields a complete language.	x-3285-4
Variable arities allow us to construct all enumerations of constants in the input, represented by sufficiently long tuples containing all constants.	x-3285-5
The ability to construct the enumerations and manipulate integers yields a complete language.	x-3285-6
The first step in defining the untyped version of while is to define an untyped version of relational algebra.	x-3286-1
This means that operations must be defined so that they work on relations of arbitrary, unknown arity.	x-3286-2
Expressions in the untyped algebra are built from relation variables and constants and can also use integer variables and constants.	x-3286-3
Let i, j be integer variables, and for each integer k, let ∅k denote the empty relation of arity k.	x-3286-4
Untyped algebra expressions are built up using the following operations:	x-3287-1
Highly Expressive Languages	x-3288-1
We may also consider an untyped version of tuple relational calculus (see Exercise 18.15).	x-3289-1
We can now define whileuty programs.	x-3290-1
They are concatenations of statements of the form	x-3290-2
Example 18.3.1 Following is a whileuty program that computes the arity of a nonempty relation R in the integer variable n: S0 := {}; S1 := S0 ∪ R; S2 := ¬S1; while S2 do begin n := n + 1; S0 := S0 × D; S1 := S0 ∪ R; S2 := ¬S1; end where D abbreviates an algebra expression computing the active domain [e.g., π11(R) ∪ whenever R and S0 have different arities, the result of S0 ∪ R is ∅0.	x-3291-1
This allows us to detect when the appropriate arity has been found.	x-3291-2
Remark 18.3.2 There is a much simpler set of constructs that yields the same power as whileuty.	x-3292-1
In general, programs are much harder to write in the resulting language, called QL, than in whileuty.	x-3292-2
One can show that the set of constructs of QL is minimal.	x-3292-3
The language QL is described next; it does not use integer variables.	x-3292-4
QL expressions are built from relational variables and constant relations as follows (D denotes the active domain):	x-3292-5
Programs are built by concatenations of assignment statements (R := e) and while statements ( while R do s).	x-3293-1
The semantics of the while is that the loop is iterated as long as R is nonempty.	x-3293-2
We leave it to the reader to check that QL is equivalent to whileuty (Exercise 18.17).	x-3294-1
We briefly describe the simulation of integers by QL.	x-3295-1
Let Z denote the constant 0-ary relation {}.	x-3295-2
We can have Z represent the integer 0 and Z ↑n represent the integer n. Then increment(n) is simulated by one application of ↑, and decrement(n) is simulated by one application of ↓.	x-3295-3
A test of the form x = 0 becomes e ↓= ∅, where e is the untyped algebra expression representing the value of x.	x-3295-4
Thus we can simulate arbitrary computations on the integers.	x-3295-5
Recall that our definition of query requires that both the input and output be instances over fixed schemas.	x-3296-1
On the other hand, in whileuty relation arities are variable, so in general the arity of the answer is data dependent.	x-3296-2
This is a problem analogous to the one we encountered with whilenew, which generally produces new values in the result.	x-3296-3
As in the case of whilenew, we can define semantic and syntactic restrictions on whileuty programs that guarantee that the programs compute queries.	x-3296-4
Call a whileuty program well behaved if its answer is always of the same arity regardless of the input.	x-3296-5
Unfortunately, it can be shown that it is undecidable if a whileuty program is well behaved (Exercise 18.19).	x-3296-6
However, there is a simple syntactic condition that guarantees good behavior and covers all well-behaved programs.	x-3296-7
A whileuty program with answer relation answer is syntactically well behaved if the last instruction of the program is of the form answer := πmn(R), where m, n are integer constants.	x-3296-8
Clearly, syntactic good behavior guarantees good behavior and can be checked.	x-3296-9
Furthermore, it is obvious that each well-behaved whileuty program is equivalent to some syntactically well-behaved program (Exercise 18.19).	x-3297-1
Highly Expressive Languages We now prove the completeness of well-behaved whileuty programs.	x-3298-1
Theorem 18.3.3 The well-behaved whileuty programs express all queries.	x-3299-1
Crux It is easily verified that all well-behaved whileuty programs define queries.	x-3300-1
The proof that every query can be expressed by a well-behaved whileuty program is similar to the proof of Theorem 18.2.3.	x-3300-2
Let q be a query with input schema R. We proceed in two steps: First construct all orderings of constants from the input.	x-3300-3
Next simulate the while N program computing q on the ordered database corresponding to each ordering.	x-3300-4
The main difference with whilenew lies in how the orderings are computed.	x-3300-5
In whileuty, we use the arbitrary arity to construct a relation R< containing sufficiently long tuples each of which provides an enumeration of all constants.	x-3300-6
This is done by the following whileuty program, where D stands for an algebra expression computing the active domain: R< := ∅0; C := D; arity C := 1; while C do begin R< := C; C := C × D; increment( arity C); for i := 1 to ( arity C − 1) do C := C ∩ ¬σi= arity(C)(C); end Clearly, the looping construct f or i := 1 to .	x-3300-7
.	x-3300-8
.	x-3300-9
can be easily simulated.	x-3300-10
If the size of D is n, the result of the program is the set of n-tuples with distinct entries in adom(D).	x-3300-11
Note that each such tuple t in R< provides a complete enumeration of the constants in D. Next one can easily construct a whileuty program that constructs, for each such tuple t in R<, the corresponding successor relation.	x-3300-12
More precisely, one can construct succ = succ t × {t}, t ∈R< where succ t = {t (i), t (i + 1) | 1 ≤ i < n} (see Fig.	x-3300-13
18.2 and Exercise 18.20).	x-3300-14
Untyped languages allow us to relax the restriction that the output schema is fixed.	x-3301-1
This may have a practical advantage because in some applications it may be necessary to have the output schema depend on the input data.	x-3302-1
However, in such cases one would likely prefer a richer type system rather than no typing at all.	x-3302-2
The overall results on the expressiveness and complexity of relational query languages are summarized in Figs.	x-3303-1
18.4 and 18.5.	x-3303-2
The main classes of queries and their inclusion structure are represented in Fig.	x-3303-3
18.4 (solid arrows indicate strict inclusion; the dotted arrow indicates strict inclusion if ptime = pspace).	x-3303-4
Languages expressing each class of queries are listed in Fig.	x-3303-5
18.5, which also contains information on complexity (first without assumptions, then with the assumption of an order on the database).	x-3303-6
In Fig.	x-3303-7
18.5, Bibliographic Notes While Fixpoint Stratified datalog¬ Semipositive datalog¬ First order Datalog Positive-existential Conjunctive queries Figure 18.4: Main classes of queries CALC(∃, ∧) denotes the conjunctive calculus and CALC(∃, ∧, ∨) denotes the positive-existential calculus.	x-3303-8
Bibliographic Notes The first complete language proposed was the language QL of Chandra and Harel [CH80b].	x-3304-1
Chandra also considered a language equivalent to while N, which he called LC [Cha81a].	x-3305-1
It was shown that LC cannot compute even.	x-3306-1
Several other primitives are considered in	x-3306-2
The languages considered in this chapter can be viewed as formalizing practical languages, such as C+SQL or O2C, used to develop database applications.	x-3307-1
These languages combine standard computation (C) with database computation (SQL in the relational world or O2 in the object-oriented world).	x-3307-2
In this direction, several computing devices were defined in [AV91b], and complexity-theoretic results are obtained using the devices.	x-3307-3
First an extension of Turing machines with a relational store, called relational machine, was shown to be equivalent to while N. A further extension of relational machines equivalent to whilenew and whileuty, called generic machine, was also defined.	x-3307-4
In the generic machine, Highly Expressive Languages Class of Complexity queries Languages Complexity with order conjunctive CALC(∃, ∧) SPJR algebra positive- CALC(∃, ∧, ∨) existential SPJUR algebra nr-datalog datalog datalog ptime ptime semipositive semipositive datalog¬ datalog¬ first order CALC nr-stratified datalog¬ stratified stratified datalog¬ datalog¬ fixpoint CALC+µ+ while+ datalog¬ (fixpoint and well-founded semantics) while CALC+µ while datalog¬¬ (fixpoint semantics) whileuty no bound no bound whilenew Figure 18.5: Languages and complexity parallelism is used to allow simultaneous computations with all possible successor relations.	x-3307-5
Queries with new values in their answers were first considered in [AK89], in the context of an object-oriented deductive language with object creation, called IQL.	x-3308-1
The notion of determinate query [VandBGAG92] is a recasting of the essentially equivalent notion of db transformation, formulated in [AK89].	x-3308-2
In [AK89], the query in Theorem 18.2.5 is also exhibited, and it is shown that IQL without duplicate elimination cannot express it.	x-3308-3
Because IQL is more powerful than whilenew, their result implies the result of Theorem 18.2.5.	x-3308-4
The issue of completeness of languages with object creation was further investigated in [AP92, VandBG92, VandBGAG92, VandBP95, DV91, DV93].	x-3308-5
Exercises Finally it is easy to see that each (determinate) query can be computed in some natural nondeterministic extension of whilenew (e.g., with the witness operator of Chapter 17)	x-3309-1
Exercises Exercise 18.1 Let G be a graph.	x-3310-1
Consider a query “Does the shortest path from a to b in G have property P?	x-3310-2
” where G is a graph, P is a recursive property of the integers, and a, b are two particular vertexes of the graph.	x-3310-3
Show that such a query can be expressed in while N.	x-3310-4
Exercise 18.2 Prove that the query in Example 18.1.1 can be expressed (a) in while; (b) in fixpoint.	x-3311-1
Exercise 18.3 Sketch a direct proof that even cannot be expressed by while N by extending the hyperplane technique used in the proof of Proposition 17.3.2.	x-3312-1
Exercise 18.5 Complete the proof of Theorem 18.1.2.	x-3313-1
Hint: Use new values to represent integers.	x-3314-1
Specifically, to represent the integers up to n, construct a relation succ int containing a successor relation on n new values.	x-3314-2
The value of rank i with respect to succ represents integer i.	x-3314-3
Hint: Again establish a correspondence between new values and integers.	x-3315-1
Then use Exercise 18.4.	x-3315-2
Exercise 18.7 Prove Lemma 18.2.1.	x-3316-1
Exercise 18.8 Prove that it is undecidable if a given whilenew program is well behaved.	x-3317-1
Highly Expressive Languages Bad(w), then S, arity(T ) + j ∈ Bad(w); j ∈ Bad(w), then S, j ∈ Bad(w);	x-3318-1
Exercise 18.10 Prove (*) in the proof of Theorem 18.2.3.	x-3319-1
Exercise 18.11 Prove (†) and (‡) in the proof of Theorem 18.2.5.	x-3320-1
Exercise 18.12 Consider the query q exhibited in the proof of Theorem 18.2.5.	x-3321-1
Let q2 be the query that, on input I = {a, b}, produces as answer two copies of q(I ).	x-3321-2
More precisely, for each ψi in q(I ), let ψ′ be a distinct new value.	x-3321-3
Let q′(I ) be obtained from q(I ) by replacing ψ i i by i	x-3321-4
whilenew with the following (determinate) choose construct.	x-3322-1
A program w may contain the instruction choose(R) for some unary relation R. On input I, when choose(R) is applied in a state J, the next state J′ is defined as follows:	x-3322-2
Show that whilechoose is determinate complete.	x-3323-1
new Exercise 18.15 One may consider an untyped version of tuple relational calculus.	x-3324-1
Untyped relations are used just like typed relations, except that terms of the form t (i) are allowed, where t is a tuple variable and i an integer variable.	x-3324-2
Equivalence of queries now means that the queries yield the same answers given the same relations and values for the integer variables.	x-3324-3
Show that untyped relational calculus and untyped relational algebra are equivalent.	x-3324-4
Exercise 18.16 Show that exij is not redundant in the untyped algebra.	x-3325-1
Exercises b b c c d b d b c c b d b d c c d d I J Figure 18.6:	x-3326-1
Exercise 18.18 Write a QL program computing the transitive closure of a binary relation.	x-3327-1
Exercise 18.20 Write a whileuty program that constructs the relation succ from R< in the proof of Theorem 18.3.3.	x-3328-1
Highly Expressive Languages has the same effect as the R := new(P ) instruction in whilenew.	x-3329-1
The resulting extension of datalog¬¬ is denoted datalog¬¬ .	x-3329-2
The programs are those that never new well-behaved datalog¬¬ new produce new values in the answer.	x-3329-3
Sketch a proof that well-behaved datalog¬¬ programs ex-new press all queries.	x-3329-4
P A R T F Finale Inthispart,weconsiderfouradvancedtopics.Twoofthem(incompleteinformationand dynamic aspects) have been studied for a while, but for some reason (perhaps their difficulty) they have never reached the maturity of more established areas such as dependency theory.	x-3330-1
Interest in the other two topics (complex values and object databases) is more recent, and our understanding of them is rudimentary.	x-3330-2
In all cases, no clear consensus has yet emerged.	x-3330-3
Our choice of material, as well as our presentation, are therefore unavoidably more subjective than in other parts of this book.	x-3330-4
However, the importance of these issues for practical systems, as well as the interesting theoretical issues they raise, led us to incorporate a discussion of them in this book.	x-3330-5
In Chapter 19, we address the issue of incomplete information.	x-3331-1
In many database applications, the knowledge of the real world is incomplete.	x-3331-2
It is crucial to be able to handle such incompleteness and, in particular, to be able to ask queries and perform updates.	x-3331-3
Chapter 19 surveys various models of incomplete databases, research directions, and some results.	x-3332-1
In Chapter 20, we present an extension of relations called complex values.	x-3333-1
These are obtained from atomic elements using tuple and set constructors.	x-3333-2
The richer structure allows us to overcome some limitations of the relational model in describing complex data.	x-3333-3
We generalize results obtained for the relational model; in particular, we present a calculus and an equivalent algebra.	x-3333-4
Chapter 21 looks at another way to enrich the relational model by introducing a number of features borrowed and adapted from object-oriented programming, such as objects, classes, and inheritance.	x-3334-1
In particular, objects consist of a structural part (a data reposi-tory) and a behavioral part (pieces of code).	x-3334-2
Thus the extended framework encompasses behavior, a notion conspicuously absent from relational databases.	x-3334-3
Chapter 22 deals with dynamic aspects.	x-3335-1
This is one of the less settled areas in databases, and it raises interesting and difficult questions.	x-3335-2
We skim through a variety of issues: languages and semantics for updates; updating views; updating incomplete information; and active and temporal databases.	x-3335-3
Somebody: What are we doing next?	x-3336-1
Who are we ?	x-3337-1
Who are you ?	x-3337-2
Somebody: We are you and the authors of the book, and I am one of them.	x-3338-1
This is an instance of incomplete information.	x-3338-2
Somebody: It’s not much, but we can still tell that surely one of us is Alice and that there are possibly up to three “Somebodies” speaking.	x-3339-1
In the previous parts, we have assumed that a database always records information that is completely known.	x-3340-1
Thus a database has consisted of a completely determined finite instance.	x-3340-2
In reality, we often must deal with incomplete information.	x-3340-3
This can be of many kinds.	x-3340-4
There can be missing information, as in “John bought a car but I don’t know which one.” In the case of John’s car, the information exists but we do not have it.	x-3340-5
In other cases, some attributes may be relevant only to some tuples and irrelevant to others.	x-3340-6
Alice is single, so the spouse field is irrelevant in her case.	x-3340-7
Furthermore, some information may be imprecise: “Heather lives in a large and cheap apartment,” where the values of large and cheap are fuzzy.	x-3340-8
Partial information may also arise when we cannot completely rely on the data because of possible inconsistencies (e.g., resulting from merging data from different sources).	x-3340-9
The study of knowledge is a fascinating topic that is outside the scope of this book.	x-3341-1
Clearly, there is a trade-off between the expressivity of the model for incomplete information used and the difficulty of answering queries.	x-3342-1
From the database perspective, we are primarily concerned with identifying this trade-off and understanding the limits of what is feasible in this context.	x-3342-2
The purpose of this chapter is to make a brief foray into this topic.	x-3342-3
We limit ourselves mostly to models and results of a clear database nature.	x-3343-1
We consider simple forms of incompleteness represented by null values.	x-3343-2
The main problem we examine is how to answer queries on such databases.	x-3343-3
In relation to this, we argue that for a representation system of incomplete information to be adequate in the context of a query language, it must also be capable of representing answers to queries.	x-3343-4
This leads to a desirable closure property of representations of incomplete information with respect to query languages.	x-3343-5
We observe the increase of complexity resulting from the use of nulls.	x-3343-6
We also consider briefly two approaches closer to knowledge bases.	x-3344-1
The first is based 487 Incomplete Information on the introduction of disjunctions in deductive databases, which also leads to a form of incompleteness.	x-3344-2
The second is concerned with the use of modalities.	x-3344-3
We briefly mention the language KL, which permits us to talk about knowledge of the world.	x-3344-4
Warm-Up	x-3345-1
We provide a mechanism for representing incomplete information using null values.	x-3346-1
The basic idea is to allow occurrences of variables in the tuples of the database.	x-3347-1
The different possible values of the variables yield the possible worlds.	x-3347-2
The simplest model that we consider is the Codd table (introduced by Codd), or table for short.	x-3348-1
A table is a relation with constants and variables, in which no variable occurs twice.	x-3348-2
More precisely, let U be a finite set of attributes.	x-3348-3
A table T over U is a finite set of free tuples over U such that each variable occurs at most once.	x-3348-4
An example of a table is given in Fig.	x-3348-5
19.1.	x-3348-6
The figure also illustrates an alternative representation (using @) that is more visual but that we do not adopt here because it is more difficult to generalize.	x-3348-7
The preceding definition easily extends to database schemas.	x-3349-1
A database table T over a database schema R is a mapping over R such that for each R in R, T(R) is a table over sort (R).	x-3349-2
For this generalization, we assume that the sets of variables appearing in each table are pairwise disjoint.	x-3349-3
Relationships between the variables can be stated through R B C R B C x y v Table T R B C R B C R B C R B C I1 I2 I3 I4 Figure 19.1: global conditions (which we will introduce in the next section).	x-3349-4
In this section, we will focus on single tables, which illustrate well the main issues.	x-3349-5
To specify the semantics of a table, we use the notion of valuation (see Chapter 4).	x-3350-1
The incomplete database represented by a table is defined as follows: rep(T ) = {ν(T ) | ν a valuation of the variables in T }.	x-3350-2
Consider the table T in Fig.	x-3351-1
19.1.	x-3351-2
Then I1, .	x-3351-3
.	x-3351-4
.	x-3351-5
, I4 all belong to rep(T ) (i.e., are possible worlds).	x-3351-6
The preceding definition assumes the Closed World Assumption (CWA) (see Chapter 2).	x-3352-1
This is because each tuple in an instance of ref (T ) must be justified by the presence of a particular free tuple in T .	x-3352-2
An alternative approach is to use the Open World Assumption (OWA).	x-3352-3
In that case, the incomplete database of T would include all instances that contain an instance of rep(T ).	x-3352-4
In general, the choice of CWA versus OWA does not substantially affect the results obtained for incomplete databases.	x-3352-5
We now have a simple way of representing incomplete information.	x-3353-1
What next?	x-3353-2
Naturally, we wish to be able to query the incomplete database.	x-3353-3
Exactly what this means is not clear at this point.	x-3353-4
We next look at this issue and argue that the simple model of tables has serious shortcomings with respect to queries.	x-3353-5
This will naturally lead to an extension of tables that models more complicated situations.	x-3353-6
Let us consider what querying an incomplete database might mean.	x-3354-1
Consider a table T	x-3354-2
This is, again, an incomplete database.	x-3355-1
The answer to q should be a representation of this incomplete database.	x-3355-2
More generally, consider some particular representation system (e.g., tables).	x-3356-1
Such a system involves a language for describing representations and a mapping rep that associates a set of instances with each representation.	x-3356-2
Suppose that we are interested in a particular query language L (e.g., relational algebra).	x-3356-3
We would always like to be capable of representing the result of a query in the same system.	x-3356-4
More precisely, for each representation T	x-3356-5
In other words, q(T ) represents the possible answers of q [i.e., {q(I ) | I ∈ rep(T )}].	x-3357-1
If some representation system τ has the property described for a query language L, we will say that τ is a strong representation system for L. Clearly, we are particularly interested in strong representation systems for relational algebra and we shall develop such a system later.	x-3358-1
Let us now return to tables.	x-3359-1
Unfortunately, we quickly run into trouble when asking queries against them, as the following example shows.	x-3359-2
Example 19.1.1 Consider T of Fig.	x-3360-1
19.1 and the algebraic query σA=3(T ).	x-3360-2
There is no table representing the possible answers to this query.	x-3360-3
A possible answer (e.g., for I1) is the empty relation, whereas there are nonempty possible answers (e.g., for I2).	x-3360-4
Suppose Incomplete Information that there exists a table T ′ representing the set of possible answers.	x-3360-5
Either T ′ is empty and σA=3(I2) is not in rep(T ′); or T ′ is nonempty and the empty relation is not in rep(T ′).	x-3360-6
This is a contradiction, so no such T ′ can exist.	x-3360-7
The problem lies in the weakness of the representation system of tables; we will consider richer representation systems that lead to a complete representation system for all of relational algebra.	x-3361-1
An alternative approach is to be less demanding; we consider this next and present the notion of weak representation systems.	x-3361-2
Weak Representation Systems To relax our expectations, we will no longer require that the answer to a query be a representation of the set of all possible answers.	x-3362-1
Instead we will ask which are the tuples that are surely in the answer (i.e., that belong to all possible answers).	x-3362-2
(Similarly, we may ask for the tuples that are possibly in the answer (i.e., that belong to some possible answer).	x-3362-3
We make this more precise next.	x-3363-1
For a table T and a query q, the set of sure facts, sure(q, T ), is defined as sure(q, T ) = ∩{q(I ) | I ∈ rep(T )}.	x-3364-1
Clearly, a tuple is in sure(q, T ) iff it is in the answer for every possible world.	x-3365-1
Observe that the sure tuples in a table T [i.e., the tuples in every possible world in rep(T )] can be computed easily by dropping all free tuples with variables.	x-3365-2
One could similarly define the set poss(q, T ) of possible facts.	x-3365-3
One might be tempted to require of a weak system just the ability to represent the set of tuples surely in the answer.	x-3366-1
However, the definition requires some care due to the following subtlety.	x-3366-2
Suppose T is the table in Fig.	x-3366-3
19.1 and q the query σA=2(R), for which sure(q, T ) = ∅.	x-3366-4
Consider now the query q′ = π AB(R) and the query q ◦ q′.	x-3366-5
Clearly, q′( sure(q, T )) = ∅; however, sure(q′(q( rep(T ))) = {2, 0}.	x-3367-1
So q ◦ q′ cannot be computed by first computing the tuples surely returned by q and then applying q′.	x-3367-2
This is rather unpleasant because generally it is desirable that the semantics of queries be compositional (i.e., the result of q ◦ q′ should be obtained by applying q′ to the result of q).	x-3367-3
The conclusion is that the answer to q should provide more information than just sure(q, T ); the incomplete database it specifies should be equivalent to q( rep(T )) with respect to its ability to compute the sure tuples of any query in the language applied to it.	x-3367-4
This notion of equivalence of two incomplete databases is formalized as follows.	x-3368-1
If L is a query language, we will say that two incomplete databases I, J are L equivalent, denoted I ≡L J , if for each q in L we have	x-3369-1
In other words, the two incomplete databases are undistinguishable if all we can ask for is the set of sure tuples in answers to queries in L.	x-3370-1
We can now define weak representation systems.	x-3371-1
Suppose L is a query language.	x-3371-2
A representation system is weak for L if for each representation T of an incomplete database, and each q in L, there exists a representation denoted q(T ) such that rep(q(T )) ≡L q( rep(T )).	x-3371-3
With the preceding definition, q(T ) does not provide precisely sure(q, T ) for tables T .	x-3372-1
However, note that sure(q, T ) can be obtained at the end simply by eliminating from the answer all rows with occurrences of variables.	x-3372-2
The next result indicates the power of tables as a weak representation system.	x-3373-1
Theorem 19.2.1 Tables form a weak representation system for selection-projection (SP)	x-3374-1
Crux It is easy to see that tables form a weak representation system for SP queries.	x-3375-1
Selections operate conservatively on tables.	x-3376-1
For example, for all valuations ν of the variables in t}.	x-3376-2
Projections operate like classical projections.	x-3377-1
For example, if T is again the table in Fig.	x-3377-2
19.1, then	x-3377-3
Let us show that tables are no longer a weak representation system if join or union are added to SP.	x-3378-1
Consider join first.	x-3378-2
So the query language is now SPJ.	x-3378-3
Let T be the table R B C x c x′ c′ where x, x′ are variables and a, a′, c, c′ are constants.	x-3378-4
Let q = π AC(R) ⊲⊳ πB(R).	x-3379-1
Suppose there is table W such that rep(W ) ≡ SPJ q( rep(T )), Incomplete Information C c c c′ c′ Therefore sure(q′, W ) must be the same.	x-3379-2
Because a′, c ∈ sure(q′, W ), for each valuation ν of variables in W there must exist tuples u, v ∈ W such that u(A) = a′, v(C) = c, ν(u)(B) = ν(v)(B).	x-3379-3
Let ν be a valuation such that ν(z) = ν(y) for all variables z, y, z = y.	x-3379-4
If u = v, then u(A) = a′ and u(C) = c so a′, c ∈ sure(π AC(R), W ).	x-3379-5
This cannot be because, clearly, a′, c ∈ sure(π AC(R), q( rep(T ))).	x-3379-6
So, u = v. Because ν(u)(B) = ν(v)(B) and W has no repeated variables, it follows that u(B) and v(B) equal some constant k. But then a′, k ∈ sure(π AB(R), W ), which again cannot be because one can easily verify that sure(π AB(R), q( rep(T ))) = ∅.	x-3379-7
The proof that tables do not provide a weak representation system for SPU follows similar lines.	x-3380-1
Just consider the table T R B x b	x-3380-2
Naive Tables The previous result shows the limitations of tables, even as weak representation systems.	x-3381-1
We next consider a first extension of tables that allows repetitions of variables.	x-3382-1
It will turn out that this will provide a weak representation system for a large subset of relational algebra.	x-3382-2
Theorem 19.2.2 Naive tables form a weak representation system for positive relational algebra.	x-3383-1
Crux Given a naive table T and a positive query q, the evaluation of q(T ) is extremely simple.	x-3384-1
The variables are treated as distinct new constants.	x-3384-2
The standard evaluation of q is then performed on the table.	x-3384-3
Note that incomplete information yields no extra cost in this case.	x-3384-4
We leave it to the reader to verify that this works.	x-3384-5
R B C x x v Figure 19.2: Naive tables yield a nice representation system for a rather large language.	x-3385-1
But the representation system is weak and the language does not cover all of relational algebra.	x-3385-2
We introduce in the next section a representation that is a strong system for relational algebra.	x-3385-3
Conditional Tables We have seen that Codd tables and naive tables are not rich enough to provide a strong representation system for relational algebra.	x-3386-1
To see what is missing, recall that when we attempt to represent the result of a selection on a table, we run into the problem that the presence or absence of certain tuples in a possible answer is conditioned by certain properties of the valuation.	x-3386-2
To capture this, we extend the representation with conditions on variables, which yields conditional tables.	x-3386-3
We will show that such tables form a strong representation system for relational algebra.	x-3386-4
If formula P is a condition, we say that a valuation ν satisfies P if its assignment of constants to variables makes the formula true.	x-3387-1
Conditions may be associated with table T in two ways: (1) A global condition PT is associated with the entire table T ; (2) a local condition ϕt is associated with one tuple t of table T .	x-3388-1
A conditional table ( c-table for short) is a triple (T , PT , ϕ), where	x-3388-2
For our purposes, the global conditions in c-tables could be distributed at the tuple level as local conditions.	x-3389-1
However, they are convenient as shorthand and when dependencies are considered.	x-3389-2
For brevity, we usually refer to a c-table (T , PT , ϕ) simply as T .	x-3390-1
A given c-table T represents a set of instances as follows (again adopting the CWA): Incomplete Information T′ B x ≠ 2, y ≠ 2 x y = 0 y x x ≠ y J J J J B B B B Figure 19.3: rep(T ) = {I | there is a valuation ν satisfying PT such that relation I consists exactly of those facts ν(t) for which ν satisfies ϕt}.	x-3390-2
Consider the table T ′ in Fig.	x-3391-1
19.3.	x-3391-2
Then J1, J2, J3, J4 are obtained by valuating x, y, z to (0,0,0), (0,1,0), (1,0,0), and (3,0,0), respectively.	x-3391-3
The next example illustrates the considerable power of the local conditions of c-tables, including the ability to capture disjunctive information.	x-3392-1
Example 19.3.1 Suppose we know that Sally is taking math or computer science (CS) Student Course Sally math Sally CS Sally x biology math physics Observe that there may be several c-table representations for the same incomplete database.	x-3393-1
Two representations T , T ′ are said to be equivalent, denoted T ≡ T ′, if rep(T ) = rep(T ′).	x-3393-2
Testing for equivalence of c-tables is not a trivial task.	x-3393-3
Just testing membership of an instance in rep(T ), apparently a simpler task, will be shown to be np-complete.	x-3393-4
To test equivalence of two c-tables T and T ′, one must show that for each valuation ν of the variables in T there exists a valuation ν′ for T ′ such that ν(T ) = ν′(T ′), and conversely.	x-3393-5
Fortunately, it can be shown that one need only consider valuations to a set C of constants containing all constants in T or T ′ and whose size is at most the number of variables in the two tables (Exercise 19.11).	x-3394-1
This shows that equivalence of c-tables is decidable.	x-3394-2
In particular, finding a minimal representation can be hard.	x-3395-1
This may affect the computation of the result of a query in various ways: The complexity of computing the answer may depend on the representation of the input; and one may require the result to be somewhat compact (e.g., not to contain tuples with unsatisfiable local conditions).	x-3395-2
It turns out that c-tables form a strong representation system for relational algebra.	x-3396-1
Theorem 19.3.2 For each c-table T over U and relational algebra query q over U , one can construct a c-table q(T ) such that rep(q(T )) = q( rep(T )).	x-3397-1
Crux The proof is straightforward and is left as an exercise (Exercise 19.13).	x-3398-1
The example in Fig.	x-3398-2
19.4 should clarify the construction.1 For projection, it suffices to project the columns of the table.	x-3398-3
Selection is performed by adding new conjuncts to the local conditions.	x-3398-4
Union is represented by the union of the two tables (after making sure that they use distinct sets of variables) and choosing the appropriate local conditions.	x-3398-5
Join and intersection involve considering all pairs of tuples from the two tables.	x-3398-6
For difference, we consider a tuple in the first table and add a huge conjunct stating that it does not match any tuple from the second table (disjunctions may be used as shorthand; they can be simulated using new variables, as illustrated in Example 19.3.1).	x-3398-7
To conclude this section, we consider (1) languages with recursion, and (2) dependencies.	x-3399-1
In both cases (and for related reasons) the aforementioned representation system behaves well.	x-3399-2
The presentation is by examples, but the formal results can be derived easily.	x-3399-3
Languages with Recursion Consider an incomplete database and a query involving fixpoint.	x-3400-1
For instance, consider the table in Fig.	x-3400-2
19.5.	x-3400-3
The representation tc(T ) of the answer to the transitive closure query tc is also given in the same figure.	x-3400-4
One can easily verify that rep( tc(T )) = tc( rep(T )).	x-3400-5
This can be generalized to arbitrary languages with iteration.	x-3401-1
For example, consider a c-table T and a relational algebra query q that we want to iterate until a fixpoint is reached.	x-3401-2
Incomplete Information T 1 B C T 2 B C x c y c y w T 3 B B C y y c T 1 ∪ T 2 B C T 1 T 3 A B C x c y c y c w T 1 – T 2 B C x c x c x c c Computing with c-tables Then we can construct the sequence of c-tables: q(T ), q2(T ), .	x-3402-1
.	x-3402-2
.	x-3402-3
, qi(T ), .	x-3402-4
.	x-3402-5
.	x-3402-6
.	x-3402-7
Suppose now that q is a positive query.	x-3403-1
We are guaranteed to reach a fixpoint on every single complete instance.	x-3403-2
However, this does not a priori imply that the sequence of representations {qi(T )}i>0 converges.	x-3403-3
Nonetheless, we can show that this is in fact the case.	x-3403-4
For some i, rep(qi(T )) = rep(qi+1(T )).	x-3403-5
T B t c(T ) B b b x c x c c d c d c x = b x d c c x = d d x = b Figure 19.5: Transitive closure of a table	x-3404-1
Thus to find the table representing the result, it suffices to compute the sequence	x-3405-1
Dependencies In Part B, we studied dependencies in the context of complete databases.	x-3406-1
We now reconsider dependencies in the context of incomplete information.	x-3406-2
Suppose we are given an incomplete database (i.e., a set I of complete databases) and are told, in addition, that some set $ of dependencies is satisfied.	x-3406-3
The question arises: How should we interpret the combined information provided by I and by $?	x-3406-4
The answer depends on our view of the information provided by an incomplete database.	x-3407-1
Dependencies should add to the information we have.	x-3407-2
But how do we compare incomplete databases with respect to information content?	x-3407-3
One common-sense approach, in line with our discussion so far, is that more information means reducing further the set of possible worlds.	x-3407-4
Thus an incomplete database I (i.e., a set of possible worlds) is more informative than J iff I ⊂ J .	x-3407-5
In this spirit, the natural use of dependencies would be to eliminate from I those possible worlds not satisfying $.	x-3407-6
This makes sense for egd’s (and in particular fd’s).	x-3407-7
Incomplete Information I1 I2 I3 J1 J2 B C B C B C B C B C b c e f g b c b c e f g b′ c′ e f ′ g′ g b h b′ c′ e f ′ g′ e f g′ b c′ e f g e f ′ g b′ c e f ′ g Figure 19.6: Incomplete databases and dependencies can be used to complete the instance by adding all missing tuples implied by the tgd’s in $.	x-3408-1
(See Exercise 19.18.)	x-3408-2
In fact, the chase can be used for both egd’s and tgd’s.	x-3409-1
In contrast to tgd’s, the effect of chasing with egd’s (and, in particular, fd’s) may be to eliminate possible worlds that violate them.	x-3409-2
Note that tuples added by tgd’s may lead to violations of egd’s.	x-3409-3
This suggests that an incomplete database I with a set $ of dependencies represents	x-3409-4
For example, consider Fig.	x-3410-1
19.6, which shows the incomplete database I = {I1, I2, I3}.	x-3410-2
Under this perspective, the incorporation of the dependencies $ = {A → this incomplete database leads to J = {J1, J2}.	x-3411-1
Suppose now that the incomplete database I is represented as a c-table T .	x-3412-1
Can the effect of a set $ of full dependencies on T be represented by another c-table T ′?	x-3412-2
The answer is yes, and T ′ is obtained by extending the chase to c-tables in the straightforward way.	x-3412-3
For example, a table T1 and its completion T2 by $ = {A → in Fig.	x-3412-4
19.7.	x-3412-5
The reader might want to check that chase$( rep(T1)) = rep(T2).	x-3412-6
T1 B C D T2 B C D b c d b c d x e y g x e y g b c b y g e c d Figure 19.7: c-tables and dependencies The Complexity of Nulls Conditional tables may appear to be a minor variation from the original model of complete relational databases.	x-3413-1
However, we see next that the use of nulls easily leads to intractability.	x-3413-2
This painfully highlights the trade-off between modeling power and resources.	x-3414-1
We consider some basic computational questions about incomplete information databases.	x-3415-1
Perhaps the simplest question is the possibility problem: “Given a set of possible worlds (specified, for instance, by a c-table) and a set of tuples, is there a possible world where these tuples are all true?” A second question is the certainty problem: “Given a set of possible worlds and a set of tuples, are these tuples all true in every possible world?” Natural variations of these problems involve queries: Is a given set of tuples possibly (or certainly) in the answer to query q?	x-3415-2
Consider a (c-) table T , a query q, a relation I , and a tuple t. Some typical questions include the following:	x-3416-1
Finally we may consider the following generalizations of the q-membership problem: (q-Containment) Is T contained in q(T ′) [i.e., rep(T ) ⊆ q( rep(T ′))]?	x-3417-1
The crucial difference between complete and incomplete information is the large number of possible valuations for the latter case.	x-3418-1
Because of the finite number of variables in a set of c-tables, only a finite number of valuations are nonisomorphic (see Exercise 19.10).	x-3418-2
However, the number of such valuations may grow exponentially in the input size.	x-3419-1
By simple reasoning about all valuations and by guessing particular valuations, we have some easy upper bounds.	x-3419-2
For a query q that can be evaluated in polynomial time on complete databases, deciding whether I ∈ q( rep(T )), or whether I is a set of possible answers, can be answered in np; checking whether q( rep(T )) = {I }, or if I is a set of certain tuples, is in co-np.	x-3419-3
To illustrate such complexity results, we demonstrate one lower bound concerning the q-membership problem for (Codd) tables.	x-3420-1
Proposition 19.4.1 There exists a positive existential query q such that checking, given a table T and a complete instance I , whether I ∈ q( rep(T )) is np-complete.	x-3421-1
Proof The proof is by reduction of graph 3-colorability.	x-3422-1
For simplicity, we use a query mapping a two-relation database into another two-relation database.	x-3422-2
(An easy modification of the proof shows that the result also holds for databases with one relation.	x-3422-3
In particular, Incomplete Information increase the arity of the largest relation, and use constants in the extra column to encode several relations into this one.)	x-3422-4
We will use (1) an input schema R with two relations R, S of arity 5 and 2, respectively; (2) an output schema R′ with two relations R′, S′ of arity 3 and 1, respectively; and (3) a positive existential query q from R to R′.	x-3423-1
The query q [returning, on each input I over R, two relations q1(I) and q2(I) over R′ and S′] is defined as follows: q1 = {x, z, z′ | ∃y([∃vw(R(x, y, v, w, z) ∨ R(v, w, x, y, z))] q2 = {z | ∃xyvw(R(x, y, v, w, z) ∧ S(y, w))}.	x-3423-2
For each input G = (V , E) to the graph 3-colorability problem, we construct a table T over the input schema R and an instance I′ over the output schema R′, such that G is 3-colorable iff I′ ∈ q( rep(T)).	x-3424-1
Without loss of generality, assume that G has no self-loops and that E is a binary relation, where we list each edge once with an arbitrary orientation.	x-3425-1
Let V = {ai | i ∈ [1..n]} and E = {(bj , cj ) | j ∈ [1..m]}.	x-3426-1
Let {xj | j ∈ [1..m]} and	x-3426-2
Intuitively, for each tuple in I(R), the second column contains the color of the vertex in the first column, and the fourth column contains the color of the vertex in the third column.	x-3427-1
The edges are numbered in the fifth column.	x-3428-1
The role of query q2 is to check whether this provides an assignment of the three colors {1, 2, 3} to vertexes such that the colors of the endpoints of each edge are distinct.	x-3428-2
Indeed, q2 returns the edges z for which the colors y, w of its endpoints are among {1, 2, 3}.	x-3428-3
So if q(I)(S′) = I′(S′), then all edges have color assignments among {1, 2, 3} to their endpoints.	x-3428-4
Next query q1 checks whether a vertex is assigned the same color consistently in all edges where it occurs.	x-3428-5
It returns the x, z, z′, where x is a vertex, z and z′ are edges, x occurs as an endpoint, and x has the same color assignment y in both z and z′.	x-3428-6
So if q1(I)(R′) = I′(R′), it follows that the color assignment is consistent everywhere for all vertexes.	x-3428-7
For example, consider the graph G given in Fig.	x-3429-1
19.8; the corresponding I′ and T defined by σ (xj ) = f (bj ) and σ (yj ) = f (cj ) for all j .	x-3429-2
It is easily seen that I′ = q(σ (T )).	x-3429-3
Moreover, it is straightforward to show that G is 3-colorable iff I′ is in q( rep(T)).	x-3430-1
Figure 19.8: Graph G T(R) T(S) I′(R′) I′(S′) x1 y1 x2 y2 x3 y3 x4 y4 x5 y5	x-3431-1
Figure 19.9: Encoding for the reduction of 3-colorability Other Approaches Incomplete information often arises naturally, even when the focus is on complete databases.	x-3432-1
For example, the information in a view is by nature incomplete, which in particular leads to problems when trying to update the view (as discussed in Chapter 22); and we already considered relations with nulls in the weak universal relations of Chapter 11.	x-3432-2
In this section, we briefly present some other aspects of incomplete information.	x-3433-1
We consider some alternative kinds of null values; we look at disjunctive deductive databases; we mention a language that allows us to address directly in queries the issue of incompleteness; and we briefly mention several situations in which incomplete information arises naturally, even when the database itself is complete.	x-3433-2
An additional approach to representing incomplete information, which stems from using explicit logical theories, will be presented in connection with the view update problem in Chapter 22.	x-3433-3
Incomplete Information Other Nulls in Brief So far we have focused on a specific kind of null value denoting values that are unknown.	x-3434-1
Other forms of nulls may be considered.	x-3435-1
We may consider, for instance, nonexisting nulls.	x-3435-2
For example, in the tuple representing a CEO, the field DirectManager has no meaning and therefore contains a nonexisting null.	x-3436-1
Nonexisting nulls are at the core of the weak universal model that we considered in Chapter 11.	x-3436-2
It may also be the case that we do not know for a specific field if a value exists.	x-3437-1
For example, if the database ignores the marital status of a particular person, the spouse field is either unknown or nonexisting.	x-3437-2
It is possible to develop a formal treatment of such no-information nulls.	x-3437-3
An incomplete database consists of a set of sets of tuples, where each set of tuples is closed under projection.	x-3437-4
This closure under projection indicates that if a tuple is known to be true, the projections of this tuple (although less informative) are also known to be true.	x-3437-5
(The reader may want to try, as a nontrivial exercise, to define tables formally with such nulls and obtain a closure theorem analogous to Theorem 19.3.2.)	x-3437-6
For each new form of null values, the game is to obtain some form of representation with clear semantics and try to obtain a closure theorem for some reasonable language (like we did for unknown nulls).	x-3437-7
In particular, we should focus on the most important algebraic operations for accessing data: projection and join.	x-3437-8
It is also possible to establish a lattice structure with the different kinds of nulls so that they can be used meaningfully in combination.	x-3437-9
Disjunctive Deductive Databases Disjunctive logic programming is an extension of standard logic programming with rules of the form	x-3438-1
In datalog, the answer to a query is a set of valuations.	x-3439-1
For instance, the answer to a query	x-3439-2
Disjunctions give rise to new problems of semantics for logic programs.	x-3440-1
Although in datalog each program has a unique minimal model, this is no longer the case for datalog with disjunctions.	x-3440-2
For instance, consider the database consisting of a single statement	x-3440-3
Definition 19.5.1 Let I, J be sets of minimal interpretations.	x-3441-1
Then J ⊑ I iff ∀I ∈ I (∃J ∈ J (J ⊆ I )).	x-3441-2
Consider the following immediate consequence operator.	x-3442-1
Let P be a datalog program with disjunctions, and let I be a set of minimal interpretations.	x-3442-2
A new set J of interpretations is obtained as follows.	x-3442-3
For each I in I, state P (I ) is the set of disjunctions of the form A1 ∨ · · · ∨ Ai that are immediate consequences of some facts in I using P .	x-3442-4
Then J is the set of of instances J such that for some I ∈ I, J is a model of state P (I ) containing I .	x-3442-5
Clearly, J is not a set of minimal interpretations.	x-3442-6
The immediate consequence of I, denoted TP (I), is the set of minimal interpretations in J .	x-3442-7
Now consider the sequence I0 = ∅ Ii = TP (Ii−1).	x-3442-8
It is easy to see that the sequence {Ii}i≥0 is nondecreasing with respect to the ordering ⊑, so it becomes constant at some point.	x-3443-1
The semantics of P is the limit of the sequence.	x-3443-2
When negation is introduced, the situation, as usual, becomes more complicated.	x-3444-1
However, it is possible to extend semantics, such as stratified and well founded, to disjunctive deductive databases.	x-3444-2
Overall, the major difficulty in handling disjunction is the combinatorial explosion it entails.	x-3445-1
For example, the fixpoint semantics of datalog with disjunctions may yield a set of interpretations exponential in the input.	x-3445-2
Logical Databases and KL The approach to null values adopted here is essentially a semantic approach, because the meaning of an incomplete database is a set of possible instances.	x-3446-1
One can also use a syntactic, proof-theoretic approach to modeling incomplete information.	x-3446-2
This is done by regarding the database as a set of sentences, which yields the logical database approach.	x-3446-3
Missing in both the semantic and syntactic approaches is the ability to make more refined statements about what the database knows.	x-3447-1
Such capabilities are particularly important in applications where the real world is slowly discovered through imprecise data.	x-3447-2
In such applications, it is general impossible to wait for a complete state to answer queries, and it is often desirable to provide the user with information about the current state of knowledge of the database.	x-3448-1
To overcome such limitations, we may use languages with modalities.	x-3449-1
We briefly mention one such language: KL.	x-3449-2
The language KL permits us to distinguish explicitly between the real world and the knowledge the database has of it.	x-3449-3
It uses the particular modal symbol K. Intuitively, whereas the sentence ϕ states the truth of ϕ in the real world, Kϕ states that the database knows that ϕ holds.	x-3449-4
For instance, the fact that the database knows neither that Alice is a student nor that Incomplete Information she is not is expressed by the statement	x-3450-1
The following KL statement says that there is a teacher who is unknown:	x-3451-1
This language allows the database to reason and answer queries about its own knowledge of the world.	x-3452-1
Incomplete Information in Complete Databases Incomplete information often arises naturally even when the focus is on complete databases.	x-3453-1
The following are several situations that naturally yield incomplete information:	x-3453-2
Bibliographic Notes It was accepted early on that database systems should handle incomplete information	x-3454-1
Much of the material presented in this chapter is from [IL84] (although it was presented there assuming the OWA), and we refer the reader to it for a detailed treatment.	x-3455-1
Bibliographic Notes Tables form the central topic of the monograph [Gra91].	x-3456-1
Examples in Section 19.1 are taken from there.	x-3456-2
The naive tables have been called “V-tables” and “e-tables” in [AG85, Gra84, IL84].	x-3456-3
The c-tables with local conditions are from [IL84]; they were augmented with global conditions in [Gra84].	x-3456-4
The fact that c-tables provide a strong representation system for relational algebra is shown in [IL84].	x-3456-5
That this strong representation property extends to query languages with fixpoint on positive queries is reported in [Gra91].	x-3456-6
Chasing is applied to c-tables in [Gra91].	x-3456-7
There are two main observations in the literature on certainty semantics.	x-3457-1
The first observation follows from the results of [IL84] (based on c-tables) and [Rei86, Var86b]	x-3457-2
Comprehensive data-complexity analysis of problems related to representing and querying databases with null values is provided in [IL84, Var86b, AKG91].	x-3458-1
The program complexity of evaluation is higher by an exponential than the data complexity [Cos83, Var82a].	x-3458-2
Such problems were first noted in [HLY80, MSY81] as part of the study of nulls in weak universal instances.	x-3458-3
Early investigations suggesting the use of orderings in the spirit of denotational semantics for capturing incomplete information include [Vas79, Bis81].	x-3459-1
The first paper to develop this approach is [BJO91], which focused on fd’s and universal relations.	x-3459-2
This has spawned several papers, including an extension to complex objects (see Chapter 20)	x-3459-3
The logical database approach has been largely influenced by the work of Reiter	x-3460-1
or 21.	x-3461-1
This approach is introduced in [INV91a, INV91b] in the context of complex objects; subsequent works include [Rou91, LW93a].	x-3461-2
One will find in [Lev84b, Lev84a] entry points to the interesting world of knowledge bases (from the viewpoint of incompleteness of information), including the language KL.	x-3462-1
A related, active area of research, called reasoning about knowledge, extends modal operators to talk about the knowledge of several agents about facts in the world or about each other’s knowledge.	x-3462-2
This may be useful in distributed databases, where sites may have different knowledge of the world.	x-3462-3
The semantics of such statements is in terms of an extension of the possible worlds semantics, based on Kripke structures.	x-3462-4
An introduction to reasoning about knowledge can be found in [Hal93, FHMV95].	x-3462-5
Finally, nonapplicable nulls are studied in [LL86]; open nulls are studied in [GZ88]; and weak instances with nonapplicable nulls are studied in [AB87b].	x-3463-1
Incomplete Information Exercises Exercise 19.1 Consider the c-table in Example 19.3.1.	x-3464-1
Give the c-tables for the answers to these queries: (1) Which students are taking Math?	x-3464-2
(2) Which students are not taking Math?	x-3464-3
(3) Which students are taking Biology?	x-3464-4
In each case, what are the sets of sure and possible tuples of the answer?	x-3464-5
Exercise 19.2 Consider the c-table T ′ in Fig.	x-3465-1
19.3.	x-3465-2
Show that each I in rep(T ′) has two tuples.	x-3465-3
Is T ′ equivalent to some 2-tuple c-table?	x-3466-1
Exercise 19.3 Consider the naive table in Fig.	x-3467-1
19.2.	x-3467-2
In the weak representation system described in Section 19.1, compute the naive tables for the answers to the queries σA=C(R), π AB(R) ⊲⊳ π AC(R).	x-3467-3
What are the tuples surely in the answers to these queries?	x-3467-4
Exercise 19.4	x-3468-1
Exercise 19.5 Let T be the Codd table in Fig.	x-3469-1
19.1.	x-3469-2
Compute strong representations of the results of the following queries, using c-tables: (a) σA=3(R); (b) q1 = δ BC→ AB(π BC(R)); (c) q1 ∪ π AB(R); (d) q1 ∩ π AB(R); (e) q1 − π AB(R); (f) q1 ⊲⊳ π BC(R).	x-3469-3
Exercise 19.6 Consider the c-table T4 = T1 ∪ T2 of Fig.	x-3470-1
19.4.	x-3470-2
Compute a strong representation of the transitive closure of T4.	x-3470-3
Exercise 19.7 Complete the proof that Codd tables are not a weak representation system with respect to SPU, in Theorem 19.2.1.	x-3471-1
Exercise 19.8 Example 19.1.1 shows that one cannot strongly represent the result of a selection on a table with another table.	x-3472-1
For which operations of relational algebra applied to tables is it possible to strongly represent the result?	x-3472-2
Exercise 19.9 Prove that naive tables are not a weak representation system for relational algebra.	x-3473-1
Exercise 19.10 Prove that, given a c-table T without constants, rep(T ) is the closure under isomorphism of a finite set of instances.	x-3474-1
Extend the result for the case with constants.	x-3474-2
Exercise 19.11 Provide an algorithm for testing equivalence of c-tables.	x-3475-1
Exercise 19.13 Prove Theorem 19.3.2.	x-3476-1
Exercise 19.14 Prove that for each c-table T1 and each set of fd’s and mvd’s, there exists a table T2 such that chase( rep(T1)) = rep(T2).	x-3477-1
Hint: Use the chase on c-tables.	x-3477-2
Exercises Exercise 19.16 Give algorithms to compute, for a c-table T and a relational algebra query q, the set of tuples sure(q, T ) surely in the answer and the set of tuples poss(q, T ) possibly in the answer.	x-3478-1
What is the complexity of your algorithms?	x-3478-2
Exercise 19.17 Let T be a c-table and q a positive existential query of the same arity as T .	x-3479-1
Show that the sequence qi(T ) converges [i.e., that for some i, qi(T ) ≡ qi+1(T )].	x-3480-1
Hint: Show that the sequence converges in at most m stages, where m = max{i | qi(I ) = qi+1(I ), I ∈ I}	x-3480-2
Exercise 19.18 Describe how to generalize the technique of chasing by full dependencies to apply to instances rather than tableau.	x-3481-1
If an egd can be applied and calls for two distinct constants to be identified, then the chase ends in failure.	x-3481-2
Show that for instance I , if the chase of I by succeeds, then chase(I, ) |= .	x-3481-3
Exercise 19.19 Show that for datalog programs with disjunctions in heads of rules, the sequence {Ii}i≥0 of Section 19.5 converges.	x-3482-1
What can be said about the limit in model-theoretic terms?	x-3482-2
sure(q)(I ) = ∩{J | J ∈ q(I )} poss(q)(I ) = ∪{J | J ∈ q(I )} Consider the language FO + W , where a program consists of a finite sequence of assignment statements of the form R := ϕ, where ϕ is a relational algebra expression or an application of W to a relation.	x-3483-1
Let sure( FO + W ) denote all deterministic queries that can be written as sure(q) for some FO + W query q, and similarly for poss( FO + W ).	x-3483-2
Prove that (a) poss( FO + W ) =np, and	x-3483-3
Complex values?	x-3484-1
Riccardo: We could have used a different title: nested relations, complex objects, structured objects .	x-3485-1
.	x-3485-2
.	x-3485-3
Vittorio:	x-3486-1
Sergio: In a nutshell, relations are nested within relations; something like Matriochka relations.	x-3487-1
Oh, yes.	x-3488-1
I love Matriochkas.	x-3488-2
Intuitively, complex values are relations in which the entries are not required to be atomic (as in the relational model) but are allowed to be themselves relations.	x-3489-1
The data structure in the relational model (the relation) can be viewed as the result of applying to atomic values two constructors: a tuple constructor to make tuples and a set constructor to make sets of tuples (relations).	x-3489-2
Complex values allow the application of the tuple and set constructor recursively.	x-3489-3
Thus they can be viewed as finite trees whose internal nodes indicate the use of the tuple and finite set constructors.	x-3489-4
Clearly, a relation is a special kind of complex value: a set of tuples of atomic values.	x-3489-5
Sort Complex Value dom Complex Values B C B C B C dom dom b e f E E E dom c d dom B C E b c d E e f Figure 20.1: Complex value	x-3490-1
We will see that, whereas it is simple to add the tuple constructor to the traditional relational data model, the set constructor requires a number of interesting new ideas.	x-3491-1
There are similarities between this set construct and the set constructs used in general-purpose programming languages such as Setl.	x-3491-2
In this chapter, we introduce complex values and present a many-sorted algebra and an equivalent calculus for complex values.	x-3492-1
The focus is on the use of the two constructors of complex values: tuples and (finite) sets.	x-3492-2
(Additional constructors, such as list, bags, and Complex Values Director Movies Title Forsythe Gwenn The Trouble with Harry MacLaine Hitchcock Hitchcock Hedren Taylor The Birds Pleshette Hitchcock Perkins Psycho Leigh Hitchcock Title Sylwan Cries and Whispers Thulin Ullman Bergman von Sydow Björnstrand The Seventh Seal Ekerot Poppe Figure 20.2: The CINEMA database revisited (with additional data shown) union, have also been incorporated into complex values but are not studied here.)	x-3492-3
After introducing the algebra and calculus, we present examples of these interesting languages.	x-3492-4
We then comment on the issues of expressive power and complexity and describe equivalent languages with fixpoint operators, as well as languages in the deductive paradigm.	x-3492-5
Finally we briefly examine a subset of the commercial query language O2SQL that provides an elegant SQL-style syntax for querying complex values.	x-3492-6
The theory described in this chapter serves as a starting point for object-oriented databases, which are considered in Chapter 21.	x-3493-1
However, key features of the object-oriented paradigm, such as objects and inheritance, are still missing in the complex value framework and are left for Chapter 21.	x-3493-2
Complex Value Databases Like the relational model, we will use relation names in relname, attributes in att, and constants in dom.	x-3494-1
The sorts are more complex than for the relational model.	x-3494-2
Their abstract syntax is given by where k ≥ 0 and B1, .	x-3494-3
.	x-3494-4
.	x-3494-5
, Bk are distinct attributes.	x-3494-6
Intuitively, an element of dom is a constant; an element of B1 : τ1, .	x-3494-7
.	x-3494-8
.	x-3494-9
, Bk : τk is a k-tuple with an element of sort τi in entry Bi for each i; and an element of sort {τ } is a finite set of elements of sort τ .	x-3494-10
Formally, the set of values of sort τ (i.e., the interpretation of τ ), denoted [τ] , is defined by	x-3495-1
Remark 20.1.1 For instance, consider the sort of that sort.	x-3496-1
This is yet again the value of Fig.	x-3496-2
20.1.	x-3496-3
It is customary to omit dom and for instance write this sort {A, B, C : {A, E : {}}}.	x-3496-4
Finally note that (because of the empty set) a complex value may belong to more than one sort.	x-3497-1
For instance, the value of Fig.	x-3497-2
20.1 is also of sort	x-3497-3
Relational algebra deals with sets of tuples.	x-3498-1
Similarly, complex value algebra deals with sets of complex values.	x-3498-2
This motivates the following definition of sorted relation (this Complex Values definition is frequently a source of confusion):	x-3498-3
We use the term relation for complex value relation.	x-3499-1
When we consider the classical relational model, we sometimes use the phrase flat relation to distinguish it from complex value relation.	x-3499-2
It should be clear that the flat relations that we have studied are special cases of complex value relations.	x-3499-3
We must be careful in distinguishing the sort of a complex value relation and the sort of the relation viewed as one complex value.	x-3500-1
For example, a complex value relation of sort A, B, C is a set of tuples over attributes ABC.	x-3500-2
At the same time, the entire relation can be viewed as one complex value of sort {A, B, C}.	x-3500-3
There is no contradiction between these two ways of viewing a relation.	x-3500-4
We now assume that the function sort (of Chapter 3) is from relname to the set of sorts.	x-3501-1
We also assume that for each sort, there is an infinite number of relations having that sort.	x-3501-2
Note that the sort of a relation is not necessarily a tuple sort (it can be a set sort).	x-3502-1
Thus relations do not always have attributes at the top level.	x-3502-2
Such relations whose sort is a set are essentially unary relations without attribute names.	x-3502-3
Example 20.1.2 To illustrate this definition, an instance J of {R1, R2, R3} where sort(R1) = sort(R3) = A : dom, B : {A1 : dom, A2 : dom} and sort(R2) = A : dom, A1 : dom, A2 : dom is shown in Fig.	x-3503-1
20.3.	x-3503-2
Variations To conclude this section, we briefly mention some variations of the complex value model.	x-3504-1
The principal one that has been considered is the nested relation model.	x-3505-1
For nested relations, set and tuple constructors are required to alternate (i.e., set of sets and tuple with a tuple component are prohibited).	x-3505-2
For instance, B B d 1 d 1 d 2 d d 3 d 4 d 1 d d d 2 d 5 d 6 d d 1 d 2 d d d 4 d 1 d 3 d 3 d 4 d 2 d 2 d 4 d 5 d 6 d d 3 d 4 d d d 6 d 1 d 3 d 2 d 4 d 2 d 1 d 3 d 2 d 4 J( R 1) J( R 2) J( R 3) Figure 20.3:	x-3505-3
The restriction imposed on the structure of nested relations is mostly cosmetic.	x-3506-1
A more fundamental constraint is imposed in so-called Verso-relations (V-relations).	x-3506-2
which is also essentially a set of sets.	x-3507-1
The V-relations are therefore much more limited data structures.	x-3507-2
(See Exercise 20.1.)	x-3507-3
They can be viewed essentially as flat relational instances.	x-3507-4
Complex Values The Algebra We now define a many-sorted algebra, denoted ALG cv (for c omplex values).	x-3508-1
Like relational algebra, ALG cv is a functional language based on a small set of operations.	x-3508-2
This section first presents a family of core operators of the algebra and then an extended family of operators that can be simulated by them.	x-3508-3
At the end of the section we introduce an important subset of ALG cv, denoted ALG cv−.	x-3508-4
The Core of ALG cv Let I, I1, I2, .	x-3509-1
.	x-3509-2
.	x-3509-3
be relations of sort τ, τ1, τ2, .	x-3509-4
.	x-3509-5
.	x-3509-6
respectively.	x-3509-7
It is important to keep in mind that a relation of sort τ is a set of values of sort τ .	x-3509-8
Basic set operations: If τ1 = τ2, then I1 ∩ I2, I1 ∪ I2, I1 − I2, are relations of sort τ1, and their values are defined in the obvious manner.	x-3510-1
Tuple operations: If I is a relation of sort τ = B1 : τ1, .	x-3511-1
.	x-3511-2
.	x-3511-3
, Bk : τk, then	x-3511-4
The selection condition γ is (with obvious restrictions on sorts) of the form Bi = d, Bi = Bj , Bi ∈ Bj or Bi = Bj .C, where d is a constant, and it is required in the last case that τj be a tuple sort with a C field.	x-3512-1
Then where |= is defined by	x-3512-2
Constructive operations powerset(I ) = {v | v ⊆ I }.	x-3513-1
tup _ create A	x-3514-1
Destructive operations	x-3515-1
We are now prepared to define the (core of the) language ALG cv.	x-3516-1
Let R be a database schema.	x-3516-2
A query returns a set of values of the same sort.	x-3516-3
By analogy with relations, a query of sort τ returns a set of values of sort τ .	x-3516-4
ALG cv queries and their answers are defined as follows.	x-3516-5
There are two base cases: Base values: For each relation name R in R, R is an algebraic query of sort sort(R).	x-3516-6
The answer to query R is I(R).	x-3516-7
Constant values: For each element a, {a} is a (constant) algebraic query of sort dom.	x-3517-1
The answer to query {a} is simply {a}.	x-3517-2
Other queries of ALG cv are obtained as follows.	x-3518-1
If q1, q2, .	x-3518-2
.	x-3518-3
.	x-3518-4
are queries, γ is a selection condition, and A1, .	x-3518-5
.	x-3518-6
.	x-3518-7
are attributes, q1 ∩ q2, q1 ∪ q2, q1 − q2, tup _ create A1,...,Ak 1, .	x-3518-8
.	x-3518-9
.	x-3518-10
, qk), powerset(q1), tup _ destroy(q1), set _ destroy(q1), set _ create(q1)	x-3518-11
To illustrate these definitions, we present two examples.	x-3519-1
We then consider other algebraic operators that are expressible in the algebra.	x-3519-2
In Section 20.4 we provide several more examples of algebraic queries.	x-3519-3
Example 20.2.1 Consider the instance J of Fig.	x-3520-1
20.3.	x-3520-2
Then one can find in Fig.	x-3520-3
20.4 J1 = [σA=d (R J2 = πB(J1), J3 = tup _ destroy(J2), J4 = set _ destroy(J3), J5 = powerset(J4), J6 = tup _ create C(J4).	x-3520-4
J5 = [ powerset( set _ destroy( tup _ destroy(πB(σA=d (R	x-3521-1
Complex Values B B d d 3 d d d 4 d 1 d 3 d 1 d 3 d 2 d 4 d 2 d 4 J 1 J 2 J 3 C d 1 d 3 d 2 d 4 d 1 d 3 d 1 d 3 C d d d 4 d 4 d 1 d 3 d 2 d 4 J 4 J 5 J 6 Figure 20.4: Example 20.2.2 In this example, we illustrate the destruction and construction of a complex value.	x-3522-1
Consider the relation I = {A : a, B : {b, c}, C : A : d, B : {e, f }}.	x-3522-2
Then	x-3523-1
We next reconstruct I from singleton sets: I = tup _ create A,B,C({a}, set _ create({b} ∪ {c}), tup _ create A,B({d}, set _ create({e} ∪ {f }))).	x-3524-1
There are infinite possibilities in the choice of algebraic operations for complex values.	x-3525-1
We chose to incorporate in the core algebra only a few basic operations to simplify the formal presentation and the proof of the equivalence between the algebra and calculus.	x-3526-1
However, making the core too reduced would complicate that proof.	x-3527-1
(For example, the operator set _ create can be expressed using the other operations but is convenient in the proof.)	x-3527-2
We now present several additional algebraic operations.	x-3527-3
It is important to note that all these operations can be expressed in complex value algebra.	x-3527-4
(In that sense, they can be viewed as macro operations.)	x-3527-5
Furthermore, all but the nest operator can be expressed without using the powerset operator.	x-3527-6
We first generalize constant queries.	x-3528-1
Complex constants: It is easy to see that the technique of Example 20.2.2 can be generalized.	x-3529-1
So instead of simply {a} for a atomic, we use as constant queries arbitrary complex value sets.	x-3529-2
We also generalize relational operations.	x-3530-1
Renaming: Renaming can be computed using the other operations, as illustrated in Section 20.4 (which presents examples of queries).	x-3531-1
Cross-product: For i in [1,2], let Ii be a relation of sort τi = Bi	x-3532-1
ji ji	x-3533-1
j j1 j2 j2 I1 × I2 = { B1 j x1 , B2 x2 j1 j2 j2 Bi I j i for i ∈ [1, 2] }.	x-3534-1
i ji It is easy to simulate cross-product using the operations of the algebra.	x-3535-1
This is also illustrated in Section 20.4.	x-3535-2
Join: This can be defined in the natural manner and can be simulated using cross-product, renaming, and selection.	x-3536-1
It should now be clear that complex value algebra subsumes relational algebra when applied to flat relations.	x-3537-1
We also have new set-oriented operations.	x-3537-2
Complex Values N-ary set _ create: We introduced tup _ create as an n-ary operation.	x-3538-1
We also allow n-ary set _ create with the meaning that set _ create(I1, .	x-3538-2
.	x-3538-3
.	x-3538-4
, In) ≡ set _ create(I1) ∪ · · · ∪ set _ create(In).	x-3538-5
Singleton: This operator transforms a set of values {a1, .	x-3539-1
.	x-3539-2
.	x-3539-3
, an} into a set {{a1}, .	x-3539-4
.	x-3539-5
.	x-3539-6
, {an}} of singletons.	x-3539-7
Nest, unnest: Less primitive interesting operations such as nest, unnest can be considered.	x-3540-1
For example, for J of Fig.	x-3541-1
20.3 we have unnest B(J(R1)) = J(R2) nest B=(A1A2)(J(R2)) = J(R3).	x-3541-2
More formally, suppose that we have R and S with sorts sort(R) = A1 : τ1, .	x-3542-1
.	x-3542-2
.	x-3542-3
, Ak : τk, B : {Ak+1 : τk+1, .	x-3542-4
.	x-3542-5
.	x-3542-6
, An : τn} sort(S) = A1 : τ1, .	x-3542-7
.	x-3542-8
.	x-3542-9
, Ak : τk, Ak+1 : τk+1, .	x-3542-10
.	x-3542-11
.	x-3542-12
, An : τn.	x-3542-13
Then for instances I of R and J of S, we have unnest B(I ) = {A1 : x1, .	x-3543-1
.	x-3543-2
.	x-3543-3
, An : xn | ∃y nest B=(Ak+1,...,An)(J ) = {A1 : x1, .	x-3543-4
.	x-3543-5
.	x-3543-6
, Ak : xk, B : y |	x-3543-7
Observe that unnest B( nest B=(A1A2)(J(R2))) = J(R2).	x-3544-1
nest B=(A1A2)( unnest B(J(R1))) "= J(R1).	x-3545-1
This is indeed not an isolated phenomenon.	x-3546-1
Unnest is in general the right inverse of nest ( nest B=α ◦ unnest B is the identity), whereas unnest is in general not information preserving (one-to-one) and so has no right inverse (see Exercise 20.8).	x-3546-2
Relational projection and selection were filtering operations in the sense that intuitively they scan a set and keep only certain elements, possibly modifying them in a uniform way.	x-3547-1
The filters in complex value algebra are more general.	x-3547-2
Of course, we shall allow Boolean expressions in selection conditions.	x-3547-3
More interestingly, we also allow set comparators in addition to ∈, such as ∋, ⊂, ⊆, ⊃, ⊇ and negations of these comparators (e.g.,	x-3547-4
Selection is a predicative filter in the sense that a predicate allows us to select some elements, leaving them unchanged.	x-3548-1
Other filters, such as projection, are map filters.	x-3548-2
They transform the elements.	x-3548-3
Clearly, one can combine both aspects and furthermore allow more complicated selection conditions or restructuring specifications.	x-3548-4
For instance, suppose I is	x-3548-5
We could use an operation that first filters all the values matching the pattern A : x, B : C : E : y, E′ : z, C′ : {x};	x-3549-1
This style of operations is standard in functional languages (e.g., apply-to-all in fp).	x-3550-1
Remark 20.2.3	x-3551-1
In the following sections, we (informally) call extended algebra the algebra consisting of the operations of ALG cv and allowing complex constants, renaming, cross-product, join, n-ary set _ create, singleton, nest, and unnest.	x-3552-1
The Calculus The calculus is modeled after a standard, first-order, many-sorted calculus.	x-3553-1
However, as we shall see, calculus variables may denote sets, so the calculus will permit quantification over sets (something normally considered to be a second-order feature).	x-3553-2
For complex value calculus, the separation between first and second order (and higher order as well) is somewhat blurred.	x-3553-3
As with the algebra, we first present a core calculus and then extend it.	x-3553-4
The issues of domain independence and safety are also addressed.	x-3553-5
For each sort, we assume the existence of a countably infinite set of variables of that sort.	x-3554-1
A variable is atomic if it ranges over the sort dom.	x-3554-2
Let R be a schema.	x-3554-3
A term is an atomic element, a variable, or an expression x.A, where x is a tuple variable and A is an attribute of x.	x-3554-4
We do not consider (yet) fancier terms.	x-3554-5
A positive literal is an expression of the form Complex Values R(t ), t = t ′, t ∈ t ′, or t ⊆ t ′, where R ∈ R, t, t′ are terms and the appropriate sort restrictions apply.1 Formulas are defined from atomic formulas using the standard connectives and quantifiers: ∧, ∨, ¬, ∀, ∃.	x-3554-6
The following example illustrates this calculus.	x-3555-1
Example 20.3.1 Consider the schema and the instance of Fig.	x-3556-1
20.3.	x-3556-2
We can verify that J(R2) is the answer on instance J to the query where the sorts of the variables are as follows: sort(x) = A, A1, A2, sort(y) = A, B : {A1, A2}, sort(u) = sort(v) = sort(w) = dom, sort(z′) = A1, A2, sort(z) = {A1, A2}.	x-3556-3
We could also have used an unsorted alphabet of variables and sorted them inside the formula, as in u : dom, v : dom, w : dom	x-3557-1
The key difference with relational calculus is the presence of the predicates ∈ and ⊆, which are interpreted as the standard set membership and inclusion.	x-3558-1
Another difference (of a more cosmetic nature) is that we allow only one free variable in relation atoms and in query formulas.	x-3558-2
This comes from the stronger sorts: A variable may represent an n-tuple.	x-3558-3
The answer to a query q on an instance I, denoted q(I), is defined as for the relational model.	x-3559-1
As in the relational case, we may define various interpretations, depending on the underlying domain of base values used.	x-3559-2
As with relational calculus, the basis for defining the semantics is the notion I satisfies ϕ for ν relative to d.	x-3559-3
Consider the definition of this notion in Section 5.3.	x-3560-1
Cases (a) through (g) remain valid for the complex object calculus.	x-3560-2
We have to consider two supplementary cases.	x-3560-3
Recall that for equality, we had case (b): I |=d ϕ[ν] if ϕ = (s = s′) and ν(s) = ν(s′).	x-3560-4
In the same spirit, we add I |=d ϕ[ν] if ϕ = (s ∈ s′) and ν(s) ∈ ν(s′) I |=d ϕ[ν] if ϕ = (s ⊆ s′) and ν(s) ⊆ ν(s′).	x-3561-1
This formally states that ∈ is interpreted as set membership and ⊆ as set inclusion (in the same sense that as = is interpreted as equality).	x-3562-1
The issues surrounding domain independence for relational calculus also arise with CALC cv.	x-3563-1
We develop a syntactic condition ensuring domain independence, but we also occasionally use an active domain interpretation.	x-3563-2
Extensions	x-3564-1
The standard abbreviations used for relational calculus, such as the logical connectives	x-3565-1
In the core calculus, only relation atoms of the form R(t) are permitted.	x-3566-1
Suppose that the sort of R is A1 : τ1, .	x-3566-2
.	x-3566-3
.	x-3566-4
, An : τn for some n. Then R(u1, .	x-3566-5
.	x-3566-6
.	x-3566-7
, un) is a shorthand for where y is a new variable.	x-3566-8
In particular, if R0 is a relation of sort (n = 0), observe that the only value of that sort is the empty tuple.	x-3566-9
Thus a variable y of that sort has only one possible value, namely .	x-3566-10
Thus for such y, we can use the following expression: R0( ) for	x-3566-11
Constructed Terms Next we allow constructed terms in the calculus such as x.A.C, B1 : a, B2 : y.	x-3567-1
More formally, if t1, .	x-3568-1
.	x-3568-2
.	x-3568-3
, tk are terms and B1, .	x-3568-4
.	x-3568-5
.	x-3568-6
, Bk are distinct attributes, then B1 : t1, .	x-3568-7
.	x-3568-8
.	x-3568-9
, Bk : tk is a term.	x-3568-10
Furthermore, if the ti are of the same sort, {t1, .	x-3568-11
.	x-3568-12
.	x-3568-13
, tk} is a term; Complex Values	x-3568-14
The use of constructed terms can be viewed as syntactic sugaring.	x-3569-1
For instance, suppose that the term {a, y} occurs in a formula ψ.	x-3569-2
Then ψ is equivalent to where ψ′ is obtained from ψ by replacing the term {a, y} by x (a fresh variable).	x-3569-3
Complex Terms We can also view relations as terms.	x-3570-1
For instance, if R is a relation of sort A, B, then R can be used in the language as a term of sort {A, B}.	x-3570-2
We may then consider literals such as x ∈ R, which is equivalent to R(x); or more complex ones such as S ∈ T , which essentially means	x-3570-3
The previous extension is based on the fact that a relation (in our context) can be viewed as a complex value.	x-3571-1
This is again due to the stronger sort system.	x-3571-2
Now the answer to a query q is also a complex value.	x-3571-3
This suggests considering the use of queries as terms of the language.	x-3571-4
We consider this now: A query q ≡ {y | ψ(y)} is a legal term that can be used in the calculus like any other term.	x-3571-5
More generally, we allow terms of the form where the free variables of ψ are y, y1, .	x-3571-6
.	x-3571-7
.	x-3571-8
, yn.	x-3571-9
Intuitively, we obtain queries by providing bindings for y1, .	x-3571-10
.	x-3571-11
.	x-3571-12
, yn.	x-3571-13
We will call such an expression a parameterized query and denote it q(y1, .	x-3571-14
.	x-3571-15
.	x-3571-16
, yn) (where y1, .	x-3571-17
.	x-3571-18
.	x-3571-19
, yn are the parameters).	x-3571-20
For instance, suppose that a formula liked(x, y) computes the films y that person x liked; and another one saw(x, y) computes those that x has seen.	x-3572-1
The set of persons who liked all the films that they saw is given by	x-3572-2
The following form of literals will play a particular role when we study safety for this calculus: x = {y | ψ (y, y1, .	x-3573-1
.	x-3573-2
.	x-3573-3
, yn)}, x′ ∈ {y | ψ (y, y1, .	x-3573-4
.	x-3573-5
.	x-3573-6
, yn)}, and x′′ ⊆ {y | ψ (y, y1, .	x-3573-7
.	x-3573-8
.	x-3573-9
, yn)}, where y is a free variable of ψ.	x-3573-10
Like the previous extensions, the parameterized queries can be viewed simply as syntactic sugaring.	x-3573-11
For instance, the three last formulas are, respectively, equivalent to	x-3573-12
In the following sections, we (informally) call extended calculus the calculus consisting of CALC cv extended with the abbreviations described earlier (such as constructed and complex terms and, notably, parameterized queries).	x-3574-1
Examples We illustrate the previous two sections with a series of examples.	x-3575-1
The queries in the examples apply to schema {R, S} with sort(R) = A : dom, A′ : dom, sort(S) = B : dom, B′ : {dom}.	x-3575-2
For each query, we give an algebraic and a calculus expression.	x-3576-1
Example 20.4.1 The union of R and a set of two constant tuples is given by or R ∪ {A : 3, A′ : 5, A : 0, A′ : 0}.	x-3577-1
Example 20.4.2 The selection of the tuples from S, where the first component is a member of the second component, is obtained with	x-3578-1
Example 20.4.3 The (classical) cross-product of R and S is the result of or Complex Values tup _ createAA′ BB′A′′B′′( tup _ destroy(πA(R)), tup _ destroy(πA′(R)), tup _ destroy(πB(S)), tup _ destroy(πB′(S)), R, S).	x-3579-1
Example 20.4.4 The join of R and S on A = B.	x-3580-1
This query is the composition of the cross-product of Example 20.4.3, with a selection.	x-3580-2
In Example 20.4.3, let the formula describing the cross-product be ϕ3 and let (R × S) be the algebraic expression.	x-3580-3
Then the (A = B) join of R and S is expressed by	x-3580-4
Example 20.4.5 The renaming of the attributes of R to A1, A2 is obtained in the calculus by with t of sort A1 : dom, A2 : dom.	x-3581-1
In the algebra, it is given by πA	x-3581-2
Example 20.4.6 Flattening S means producing a set of flat tuples, each of which contains the first component of a tuple of S and one of the elements of the second component.	x-3582-1
This is the unnest operation unnest B′(·) in the extended algebra, or in the calculus where t is of sort B, C. In the core algebra, this is slightly more complicated.	x-3583-1
We first obtain the set of values occurring in the B′ sets using E1 = tup _ create C( set _ destroy( tup _ destroy(πB′(S)))).	x-3583-2
We can next compute (E1 × S) (using the same technique as in Example 20.4.3).	x-3584-1
Then the desired query is given by	x-3584-2
Flattening can be extended to sorts with arbitrary nesting depth.	x-3585-1
Example 20.4.7 The next example is a selection using ⊆.	x-3586-1
Consider a relation T of sort C : {dom}, C′ : {dom}.	x-3586-2
We want to express the query in the algebra.	x-3586-3
We do this in stages: F1 = σC′′∈C(T × tup _ create C′′( set _ destroy( tup _ destroy(πC(T ))))), F2 = σC′′∈C′(F1), F3 = F1 − F2, F4 = T − πCC′(F3).	x-3586-4
Observe that	x-3587-1
Example 20.4.8 This example illustrates the use of nesting and of sets.	x-3588-1
Consider the algebraic query nest C=(A) ◦ nest C′=(A′) ◦ σC=C′ ◦ unnest C ◦ unnest C′(R).	x-3588-2
It is expressed in the calculus by	x-3589-1
Our last example highlights an important difference between the flat relational calculus and CALC cv.	x-3590-1
As shown in Proposition 17.2.3, the flat calculus cannot express the transitive closure of a binary relation.	x-3590-2
In contrast, the following CALC cv query does: where Complex Values	x-3590-3
Intuitively, the formula specifies the set of pairs y such that y belongs to each binary relation x containing R and transitively closed.	x-3591-1
This construction will be revisited in Section 20.6.	x-3591-2
Equivalence Theorems This section presents three results that compare the complex value algebra and calculus.	x-3592-1
First we establish the equivalence of the algebra and the domain-independent calculus.	x-3593-1
Next we develop a syntactic safeness condition for the calculus and show that it does not reduce expressive power.	x-3594-1
Finally we develop a natural syntactic condition on CALC cv that yields a subset equivalent to ALG cv−.	x-3594-2
Our first result is as follows: Theorem 20.5.1 The algebra and the domain independent calculus for complex values	x-3595-1
In the sketch of the proof, we present a simulation of the core algebra by the extended calculus and the analogous simulation in the opposite direction.	x-3596-1
An important component of this proof—namely, that the extended algebra (calculus) is no stronger than the core algebra (calculus)—is left for the reader (see Exercises 20.6, 20.7, 20.8, 20.10, and 20.11).	x-3596-2
From Algebra to Calculus We now show that for each algebra query, there is a domain-independent calculus query equivalent to it.	x-3597-1
Let q be a named algebra query.	x-3598-1
We construct a domain-independent query {x | ϕq} equivalent to q.	x-3598-2
The formula ϕq is constructed by induction on subexpressions of q.	x-3598-3
For a subexpression E of q, we define ϕE as follows:	x-3598-4
x.Ai = x.Aj if γ ≡ Ai = Aj ; x.Ai = a if γ ≡ Ai = a; x.Ai ∈ x.Aj if γ ≡ Ai ∈ Aj ; x.Ai = x.Aj .C if γ ≡ Ai = Aj .C.	x-3599-1
i ,...,A ik	x-3600-1
i1 ik ik E1 E1 E2 E1 E2	x-3601-1
E1 E2	x-3602-1
the field (of y).	x-3603-1
n)).	x-3604-1
We leave the verification of this construction to the reader (see Exercise 20.13).	x-3605-1
The domain independence of the obtained calculus query follows from the fact that algebra queries are domain independent.	x-3605-2
From Calculus to Algebra We now show that for each domain-independent query, there is a named algebra query equivalent to it.	x-3606-1
Let q = {x | ϕ} be a domain-independent query over R. As in the flat relational case, we assume without loss of generality that associated with each variable x occurring in q (and also variables used in the following proof) is a unique, distinct attribute Ax in att.	x-3607-1
We use the active domain interpretation for the query, denoted as before with a subscript adom.	x-3607-2
The crux of the proof is to construct, for each subformula ψ of ϕ, an algebra formula Eψ that has the property that for each input I, Eψ(I) = {y | ∃x1, .	x-3608-1
.	x-3608-2
.	x-3608-3
, xn(y = Ax : x n ∧ ψ (x1, .	x-3608-4
.	x-3608-5
.	x-3608-6
, xn))} adom(I), where x1, .	x-3608-7
.	x-3608-8
.	x-3608-9
, xn is a listing of free(ψ).	x-3608-10
This construction is accomplished in three stages.	x-3609-1
Computing the Active Domain The first step is to construct an algebra query E adom having sort dom such that on input instance I, E adom(I) = adom(q, I).	x-3610-1
The construction of E adom is slightly more intricate than the similar construction for the relational case.	x-3610-2
We prove by induction that for each sort τ , there exists an algebra operation Fτ that maps a set I of values of sort τ to adom(I ).	x-3610-3
This induction was not necessary in the flat case because the base relations had fixed depth.	x-3610-4
For the base case (i.e., τ = dom), it suffices to use for Fτ an identity operation (e.g., tup _ create A ◦ tup _ destroy).	x-3610-5
For the induction, the following cases occur: Complex Values FA	x-3610-6
Now consider the schema R. Then for each R in R, F sort(R) maps a relation I over R to adom(I ).	x-3611-1
Thus adom(q, I) can be computed with the query E adom = F sort(R1)(R1) ∪ · · · ∪ F sort(Rm)(Rm) ∪ {a1} ∪ · · · ∪ {ap}, where R1, .	x-3611-2
.	x-3611-3
.	x-3611-4
, Rm is the list of relations in R and a1, .	x-3611-5
.	x-3611-6
.	x-3611-7
, ap is the list of elements occurring in q.	x-3611-8
Constructing Complex Values In the second stage, we prove by induction that for each sort τ , there exists an algebra query Gτ that constructs the set of values I of sort τ such that adom(I ) ⊆ adom(q, I).	x-3612-1
For τ = dom, we can use E adom.	x-3612-2
For the induction, two cases occur:	x-3612-3
Last Stage We now describe the last stage, an inductive construction of the queries Eψ for subformulas ψ of ϕ.	x-3613-1
We assume without loss of generality that the logical connectives	x-3613-2
We also assume that relation atoms in ϕ do not contain constants or repeated variables.	x-3614-1
We only present the new case (the standard cases are left as Exercise 20.13).	x-3614-2
Let ψ be x ∈ y.	x-3614-3
Suppose that x is of sort τ , so y is of sort {τ }.	x-3615-1
The set of values of sort τ (or {τ }) within the active domain is returned by query Gτ , or G{τ}.	x-3615-2
The query x ∈Ay returns the desired result.	x-3615-3
Observe that with this construction, Eϕ returns a set of tuples with a single attribute Ax.	x-3616-1
The query q is equivalent to tup _ destroy(Eϕ).	x-3616-2
Safe Queries We now turn to the development of syntactic conditions, called safe range, that ensure domain independence.	x-3617-1
These conditions are reminiscent of those presented for relational calculus in Chapter 5.	x-3617-2
As we shall see, a variant of safe range, called strongly safe range, will yield a subset of CALC cv, denoted CALC cv−, that is equivalent to ALG cv−.	x-3617-3
We could define safe range on the core calculus.	x-3618-1
However, such a definition would be cumbersome.	x-3618-2
A much more elegant definition can be given using the extended calculus.	x-3618-3
In particular, we consider here the calculus augmented with (1) constructed terms and (2) parameterized queries.	x-3619-1
Recall that intuitively, if a formula is safe range, then each variable is bounded, in the sense that it is restricted by the formula to lie within the active domain of the query or the input.	x-3620-1
We now define the notions of safe formulas and safe terms.	x-3620-2
To give these definitions, we define the set of safe-range variables of a formula using the following procedure, which returns either the symbol ⊥ (which indicates that some quantified variable is not bounded) or the set of free variables that are bounded.	x-3620-3
In this discussion, we consider only formulas in which universal quantifiers do not occur.	x-3620-4
In the following procedure, if several rules are applicable, the one returning the largest set of safe-range variables (which always exists) is chosen.	x-3621-1
procedure safe-range (sr) input: a calculus formula ϕ output: a subset of the free variables of ϕ or ⊥.	x-3622-1
(In the following, for each Z, ⊥ ∪ Z =	x-3622-2
begin if for some parameterized query {x | ψ} occurring as a term in ϕ, x "∈ sr(ψ) then return ⊥ case ϕ of R(t ) then sr(ϕ) = free(t) ∪ free(ψ); t pred t ′ then sr(ϕ) = sr(ϕ1) − {x} else return ⊥ end; We say that a formula ϕ is safe if sr(ϕ) = free(ϕ); and a query q is safe if its associated formula is safe.	x-3623-1
It is important to understand how new sets are created in a safe manner.	x-3624-1
The next example illustrates two essential techniques for such creation.	x-3624-2
Complex Values Example 20.5.2 Let R be a relation of sort A, B.	x-3625-1
The powerset of R can be obtained in a safe manner with the query	x-3625-2
For {y | R(y)} is clearly a safe query (by the first case).	x-3626-1
Now letting t ≡ x, t′ ≡ {y | R(y)}, the formula is safe (by the third case).	x-3626-2
Now consider the nesting of the B column of R. It is achieved by the following query:	x-3627-1
Let t ≡ x, t′ ≡ z, {y | R(z, y)} and ψ ≡ ∃y′(R(z, y′)).	x-3628-1
First note that sr(R(z, y)) contains y, so the parameterized query {y | R(z, y)} can be used safely.	x-3628-2
Next the formula ψ is safe.	x-3628-3
Finally the only free variable in t′ is z, which is also free in ψ.	x-3628-4
Thus x is safe range (by the second case) and the query is safe.	x-3628-5
In contrast, as discussed in that section, the nested relation algebra ALG cv−, which uses the nest operator but not powerset, has complexity in ptime.	x-3629-1
Interestingly, there is a minor variation of the safe-range condition that yields a subset of the calculus equivalent to ALG cv−.	x-3629-2
Specifically, a formula is strongly safe range if it is safe range and the inclusion predicate does not occur in it.	x-3629-3
In the previous example, the nesting is strongly safe range whereas powerset is not.	x-3629-4
We now have the following: Theorem 20.5.3	x-3630-1
Crux Consider (a).	x-3631-1
By inspection of the construction in the proof that ALG cv ⊑ CALC cv, each algebra query is equivalent to a safe-range calculus query.	x-3631-2
Clearly, each safe-range calculus query is a domain-independent calculus query.	x-3631-3
We have already shown that each domain-independent calculus query is an algebra query.	x-3631-4
Now consider (b).	x-3632-1
Observe that in the proof that ALG cv ⊑ CALC cv, ⊆ is used only for powerset.	x-3632-2
Thus each query in ALG cv− is a strongly safe-range query.	x-3632-3
Now consider a strongly safe-range query; we construct an equivalent algebra query.	x-3632-4
We cannot use the construction from the proof of the equivalence theorem, because powerset is crucial for constructing complex domains.	x-3632-5
However, we can show that this can be avoided using the ranges of variables.	x-3632-6
(See Exercise 20.16.)	x-3632-7
More precisely, the brute force construction of the domain of variables using powerset is replaced by a careful construction based on the strongly safe-range restriction.	x-3632-8
The remainder of the proof stays unchanged.	x-3632-9
Because of part (b) of the previous result, we denote the strongly safe-range calculus by CALC cv−.	x-3633-1
Fixpoint and Deduction Example 20.4.9 suggests that the complex value algebra and calculus can simulate iteration.	x-3634-1
In this section, we examine iteration in the spirit of both fixpoint queries and datalog.	x-3634-2
In both cases, they do not increase the expressive power of the algebra or calculus.	x-3635-1
However, they allow us to express certain queries more efficiently.	x-3635-2
Fixpoint for Complex Values Languages with fixpoint semantics were considered in the context of the relational model to overcome limitations of relational algebra and calculus.	x-3636-1
In particular, we observed that transitive closure cannot be computed in relational calculus.	x-3636-2
However, as shown by Example 20.4.9, transitive closure can be expressed in the complex value algebra and calculus.	x-3636-3
Although transitive closure can be expressed in that manner, the use of powerset seems unnecessarily expensive.	x-3636-4
More precisely, it can be shown that any query in the complex value algebra and calculus that expresses transitive closure uses exponential space (assuming the straightforward evaluation of the query).	x-3636-5
In other words, the blowup caused by the powerset operator cannot be avoided.	x-3636-6
On the other hand, a fixpoint construct allows us to express transitive closure in polynomial space (and time).	x-3636-7
It is thus natural to develop fixpoint extensions of the calculus and algebra.	x-3636-8
We can provide inflationary and noninflationary extensions of the calculus with recursion.	x-3637-1
As in the relational case, an inflationary fixpoint operator µ+ allows the iteration of a T CALC cv formula ϕ(T ) up to a fixpoint.	x-3637-2
This essentially permits the inductive definition of relations, using calculus formulas.	x-3637-3
The calculus CALC cv augmented with the inflationary fixpoint operator is defined similarly to the flat case (Chapter 14) and yields CALC cv + µ+.	x-3637-4
We only consider the inflationary fixpoint operator.	x-3638-1
(Exercise 20.19 explores the noninflationary version.)	x-3638-2
Theorem 20.6.1 CALC cv + µ+ is equivalent to ALG cv and CALC cv.	x-3639-1
The proof of this theorem is left for Exercise 20.18.	x-3640-1
It involves simulating a fixpoint in a manner similar to Example 20.4.9.	x-3640-2
Before leaving the fixpoint extension, we show how powerset can be computed by iterating a ALG cv− formula to a fixpoint.	x-3641-1
(We will see later that powerset cannot be computed in ALG cv− alone.)	x-3641-2
Example 20.6.2 Consider a relation R of sort dom (i.e., a set of atomic elements).	x-3642-1
The powerset of R is computed by {x | µT (ϕ(T ))(x)}, where T is of sort {dom} and ϕ(T )(y) ≡ [y = ∅ ∨ ∃x′, y′(R(x′) ∧ T (y′) ∧ y = y′ ∪ {x′}.]	x-3642-2
Complex Values This formula is in fact equivalent to a query in ALG cv−.	x-3642-3
(See Exercise 20.15.)	x-3642-4
For example, suppose that R contains {2, 3, 4}.	x-3642-5
The iteration of ϕ yields J0 J1 J2 J3 J4	x-3642-6
Datalog for Complex Values We now briefly consider an extension of datalog to incorporate complex values.	x-3643-1
The basic result is that the extension is equivalent to the complex value algebra and calculus.	x-3643-2
We also consider a special grouping construct, which can be used for set construction in this context.	x-3643-3
In the datalog extension considered here, the predicates ⊆ and ∈ are permitted.	x-3644-1
A rule is safe range if each variable that appears in the head also appears in the body, and the body is safe (i.e., the conjunction of the literals of the body is a safe formula).	x-3644-2
We assume henceforth that rules are safe.	x-3644-3
Stratified negation will be used.	x-3644-4
The language is illustrated in the following example.	x-3644-5
Example 20.6.3 The input is a relation R of sort A, B : {C, C′}.	x-3645-1
Consider the query defining an idb relation T , which contains the tuples of R, with the B-component replaced by its transitive closure.	x-3645-2
Let us assume that we have a ternary relation ins, where ins(w, y, z) is interpreted as “z is obtained by inserting w into y.” We show later how to define this relation in the language.	x-3645-3
The program consists of the following rules: (r1) S(x, y) ← R(x, y) S(x, z) ← S(x, y), u ∈ y, v ∈ y, u.C′ = v.C, ins(u.C, v.C′, y, z) S′(x, z) ← S(x, z), S(x, z′), z ⊆ z′, z "= z′ T (x, z) ← S(x, z), ¬S′(x, z).	x-3645-4
The first two rules compute in S pairs corresponding to pairs from R, such that the second component of a pair contains the corresponding component from the pair in R and possibly additional elements derived by transitivity.	x-3646-1
Obviously, for each pair x, y of R, there is a pair x, z in S, such that z is the transitive closure of y, but there are other tuples as well.	x-3646-2
To answer the query, we need to select for each x the unique tuple x, z of S, where z is maximal.2 The third rule puts into S′ tuples x, z such that z is not maximal for that x.	x-3647-1
The last rule then selects those that are maximal, using negation.	x-3647-2
We now show the program that defines ins for some given sort τ (the variables are of sort {τ } except for w, which is of sort τ ): super(w, y, z) not- min- super(w, y, z) ← super(w, y, z), super(w, y, z′), z′ ⊆ z, z′ "= z ins(w, y, z)	x-3648-1
We note that although we used ⊆ in the example as a built-in predicate, it can be expressed using membership and stratified negation.	x-3649-1
The proof of the next result is omitted but can be reconstructed reasonably easily using the technique of Example 20.6.3.	x-3650-1
Theorem 20.6.4	x-3651-1
The preceding language relies heavily on negation to specify the new sets.	x-3652-1
We could consider more set-oriented constructs.	x-3652-2
An example is the grouping construct, which is closely related to the algebraic nest operation.	x-3652-3
For instance, in the language LDL, the rule: S(x, y) ← R(x, y) groups in S, for each x, all the y’s related to it in R (i.e., S is the result of the nesting of R on the second coordinate).	x-3652-4
The grouping construct can be used to simulate negation.	x-3653-1
Consider a query q whose input consists of two unary relations R, S not containing some particular element a and that computes R − S. Query q can be answered by the following LDL program: Temp(x, a) ← R(x) Temp(x, x) ← S(x) T (x, y) ← Temp(x, y) Res(x) Note that for an x in R − S, we derive T (x, {a}); but for x in R ∩ S, we derive T (x, {x, a}) "= T (x, {a}) because a is not in R.	x-3653-2
From the previous example, it is clear that programs with grouping need not be monotone.	x-3654-1
This gives rise to semantic problems similar to those of negation.	x-3654-2
One possiblity, adopted in LDL, is to define the semantics of programs with grouping analogously to stratification for negation.	x-3654-3
Complex Values Expressive Power and Complexity This section presents two results.	x-3655-1
First the expressive power and complexity of ALG cv/ CALC cv is established—it is the family of queries computable in hyperexponential time.	x-3655-2
Second, we consider the expressive power of ALG cv−/CALC cv− (i.e., in algebraic terms the expressive power of permitting the nest operator, but not powerset).	x-3656-1
Surprisingly, we show that the nest operator can be eliminated from ALG cv− queries with flat input/ouput.	x-3656-2
Complex Value Languages and Elementary Queries We now characterize the queries in ALG cv in terms of the set of computable queries in a certain complexity class.	x-3657-1
First the notion of computable query is extended to the complex value model in the straightforward manner.	x-3657-2
The complexity class of interest is the class of elementary queries, defined next.	x-3657-3
The hyperexponential functions hyp i for i in N are defined by 1. hyp 0(m) = m; and	x-3658-1
It turns out that a query is in ALG cv/CALC cv iff it is an elementary query.	x-3659-1
Theorem 20.7.1	x-3660-1
Crux It is trivial to see that each query in ALG cv/CALC cv is elementary.	x-3661-1
All operations can be evaluated in polynomial time in the size of their arguments except for powerset, which takes exponential time.	x-3661-2
Conversely, let q be of complexity hyp n. We show how to compute it in CALC cv.	x-3662-1
Suppose first that an enumeration of adom(I) is provided in some binary relation succ.	x-3663-1
Let X0 = adom(I ) and for each i, Xi = powerset(Xi−1).	x-3664-1
Observe that for each Xi, we can provide an enumeration as follows: First succ provides the enumeration for X0; and for each i, we define V <i U for U, V in Xi if there exists x in U − V such that each element larger than x (under <i−1) is in both or neither of U, V .	x-3664-2
Clearly, there exists a query in CALC cv+µ+ that constructs Xn and a binary relation representing <n.	x-3664-3
Now we view each element of Xn as an atomic element.	x-3665-1
The input instance together with Xn and the enumeration can be seen as an ordered database with size the order of hyp n. Query q is now polynomial in this new (much larger) instance.	x-3665-2
Finally we can easily 3 We are concerned exclusively with the data complexity.	x-3665-3
Observe that when considering the union of hyperexponential complexities, time and space coincide.	x-3665-4
extend to complex values the result from the flat case that CALC+µ+ can express qptime on ordered databases (Theorem 17.4.2).	x-3666-1
Thus CALC cv+µ+ can also express all qptime queries on ordered complex value databases, so q can be computed in CALC cv+µ+ using	x-3666-2
To conclude the proof, it remains to remove the restriction on the existence of an enumeration of the active domain.	x-3667-1
Let ϕ′ be the formula obtained from ϕ by replacing 1. succ by some fresh variable y (the sort of y is set of pairs); and 2. each literal succ(t, t′) by t, t′ ∈ y.	x-3667-2
Then q can be computed by	x-3668-1
where ψ is the CALC cv formula stating that y is the representation in a binary relation of an enumeration of the active domain.	x-3669-1
(Observe that it is easy to state in CALC cv that the content of a binary relation is an enumeration.)	x-3669-2
On the Power of the nest Operator The set-height of a complex sort is the maximum number of set constructors in any branch of the sort.	x-3670-1
We can exhibit hierarchies of classes of queries in CALC cv based on the set-height of the sorts of variables used in the query.	x-3670-2
For example, consider all queries that take as input a flat relational schema and produce as output a flat relation.	x-3670-3
Then for each n > 0, the family of CALC cv queries using variables that have sorts with set-height ≤ n is strictly weaker than the family of CALC cv queries using variables that have sorts with set-height ≤ n + 1.	x-3670-4
A similar hierarchy exists for ALG cv, based on the sorts of intermediate types used.	x-3670-5
Intuitively, these results follow from the use of the powerset operator, which essentially provides an additional exponential amount of scratch paper for each additional level of set nesting.	x-3670-6
The bottom of this hierarchy is simply relational calculus.	x-3671-1
Recall that ALG cv− can use the nest operator but not the powerset operator.	x-3671-2
It is thus natural to ask, Where do ALG cv−/ CALC cv− (assuming flat input and output) lie relative to the relational calculus and the first level of the hierarchy?	x-3671-3
Rather surprisingly, it turns out that the nest operator alone does not increase expressive power.	x-3671-4
Specifically, we show now that with flat input and output, ALG cv−/CALC cv− is equivalent to relational calculus.	x-3671-5
Theorem 20.7.2 Let ϕ be a CALC cv−/ALG cv− query over a relational database schema R with output of relational sort S. Then there exists a relational calculus query ϕ′ equivalent to ϕ.	x-3672-1
Crux The basic intuition underlying the proof is that with a flat input in CALC cv− or ALG cv−, each set constructed at an intermediate stage can be identified by a tuple of atomic Complex Values values.	x-3673-1
In terms of ALG cv−, the intuitive reason for this is that sets can be created only in two ways:	x-3673-2
Thus all created sets can be identified using some flat key of bounded length.	x-3674-1
The sets can then be simulated in the computation by their flat representations.	x-3674-2
The proof consists of	x-3674-3
The details of the proof are omitted.	x-3675-1
Observe that an immediate consequence of the previous result is that transitive closure or powerset are not expressible in ALG cv−.	x-3676-1
Remark 20.7.3 The previous results focus on relational queries.	x-3677-1
The same technique can be used for nonflat inputs.	x-3677-2
An arbitrary input I can be represented by a flat database If of size polynomial in the size of the input.	x-3677-3
Now an arbitrary ALG cv− query on I can be simulated by a relational query on If to yield a flat database representing the result.	x-3677-4
Finally the complex object result is constructed in polynomial time.	x-3677-5
This shows in particular that ALG cv− is in ptime.	x-3677-6
We conclude our discussion of languages for complex values with a brief survey of a fragment of the query language O2SQL supported by the commercial object-oriented database system O2 (see Chapter 21).	x-3678-1
This fragment provides an elegant syntax for accessing and constructing deeply nested complex values, and it has been incorporated into a recent in-dustrial standard for object-oriented databases.	x-3678-2
For the first example we recall the query	x-3679-1
Using the CINEMA database (Fig.	x-3680-1
3.1), this query can be expressed in O2SQL as element select tuple ( t.address, t.phone ) from t in Location where t.name = “Le Champo” The select- from- where clause has semantics analogous to those for SQL.	x-3680-2
Unlike SQL, the select part can specify an essentially arbitrary complex value, not just tuples.	x-3680-3
A select- from- where clause returns a set4; the keyword element here is a desetting operator that returns a runtime error if the set does not have exactly one element.	x-3680-4
The next example illustrates how O2SQL can work inside nested structures.	x-3681-1
Recall the complex value shown in Fig.	x-3681-2
20.2, which represents a portion of the CINEMA database.	x-3681-3
Let the full complex value be named Films.	x-3682-1
The following query returns all movies for which the director does not participate as an actor.	x-3682-2
select m.Title from f in Films m in f.Movies where f.Director not in select a from a in m.Actors O2SQL also provides a mechanism for collapsing nested sets.	x-3683-1
Again using the complex value Films of Fig.	x-3683-2
20.2, the following gives the set of all directors that have not acted in any Hitchcock film.	x-3683-3
select f.Director from f in Films where f.Director not in flatten select m.Actors from g in Films m in g.Movies where g.Director = “Hitchcock” Here the inner select- from- where clause returns a set of sets of actors.	x-3684-1
The keyword flatten has the effect of forming the union of these sets to yield a set of actors.	x-3684-2
We conclude with an illustration of how O2SQL can be used to construct a deeply nested complex value.	x-3685-1
The following query builds, from the complex value Films of Fig.	x-3685-2
20.2, a complex value of the same type that holds information about all movies for which the director does not serve as an actor.	x-3685-3
select tuple ( Director: f.Director, Movies: select tuple ( Title: m.Title, from a in m.Actors ) from m in f.Movies where f.Director not in m.Actors ) from f in Films	x-3686-1
Furthermore, we do not include the keyword unique in our queries, although technically it should be included to remove duplicates from answer sets.	x-3687-1
Complex Values Bibliographic Notes The original proposal for generalizing the relational model to allow entries in relations to be sets is often attributed to Makinouchi [Mak77].	x-3688-1
Our presentation is strongly influenced by [AB88].	x-3688-2
An extensive coverage of the field can be found in [Hul87].	x-3688-3
The nested relation model is studied in [JS82, TF86, RKS88].	x-3688-4
The V-relation model is studied in [BRS82, AB86, Ver89], and the essentially equivalent partition normal form (PNF) nested relation model is studied in [RKS88].	x-3688-5
The connection of the PNF nested relations with dependencies has also been studied (e.g., in [TF86, OY87]).	x-3688-6
References [DM86a, DM92] develop a while-like language that expresses all computable queries (in the sense of [CH80b]) over	x-3688-7
There have been many proposals of algebras.	x-3689-1
In general, the earlier ones have essentially the power of ALG cv− (due to obvious complexity considerations).	x-3689-2
The powerset operation was first proposed for the Logical Data Model of [KV84, KV93b].	x-3689-3
The calculus presented in this chapter is based on Jacobs’s calculus [Jac82].	x-3690-1
This original proposal allowed noncomputable queries [Var83].	x-3690-2
We use in this chapter a computable version of that calculus that is also used (with minor variations) in [KV84, KV93b, AB88, RKS88, Hul87].	x-3690-3
Parameterized queries are close to the commonly used mathematical concept of set comprehension.	x-3691-1
The equivalence of the algebra and the calculus has been shown in [AB88].	x-3692-1
An equivalence result for a more general model had been previously given in [KV84, KV93b].	x-3692-2
The equivalence result is preserved with oracles.	x-3692-3
In particular, it is shown in [AB88] that if the algebra and the calculus are extended with an identical set of oracles (i.e., sorted functions that are evaluated externally), the equivalence result still holds.	x-3692-4
The strongly safe-range calculus, and the equivalence of ALG cv− and CALC cv−, are based on [AB88].	x-3693-1
The fact that transitive closure can be computed in the calculus was noted in [AB88].	x-3694-1
The result that any algebra query computing transitive closure requires exponential space (with the straightforward evaluation model) was shown in [SP94].	x-3695-1
The equivalence between the calculus and various rule-based languages is from [AB88].	x-3695-2
In the rule-based paradigm, nesting can be expressed in many ways.	x-3695-3
A main difference between various proposals of logic programming with a set construct is in their approach to nesting: grouping in LDL [BNR+87], data functions in COL [AG91], and a form of universal quantification in [Kup87].	x-3695-4
In [Kup88], equivalence of various rule-based languages is proved.	x-3695-5
In [GG88], it is shown that various programming primitives are interchangeable: powerset, fixpoint, various iterators.	x-3695-6
The correspondence between ALG cv/CALC cv queries and elementary queries is studied in [HS93, KV93a].	x-3696-1
Hierarchies of classes of queries based on the level of set nesting are considered in [HS93, KV93a].	x-3696-2
Related work is presented in [Lie89a].	x-3696-3
Exact complexity characterizations are obtained with fixpoint, which is no longer redundant when the level of set nesting is bounded [GV91].	x-3696-4
Theorem 20.7.2 is from [PG88], which uses a proof based on a strongly safe calculus.	x-3697-1
Exercises The proof of Theorem 20.7.2 outlined in this chapter suggests a strong connection between ALG cv− and the V-relation model.	x-3698-1
Reference [BTBW92] introduces a rich family of languages for complex objects, extended to include lists and bags, that is based on structural recursion.	x-3699-1
One language in this family corresponds to the nested algebra presented in this chapter.	x-3699-2
Using this, an elegant family of generalizations of Theorem 20.7.2 is developed in [Won93].	x-3699-3
Exercises Exercise 20.1	x-3700-1
Furthermore, we impose the fd A → B (more precisely, the generalization of a functional dependency).	x-3701-1
(a) Prove that for each instance I of R, the size of I is bounded by a polynomial in adom(I ).	x-3701-2
(b) Show how the same information can be naturally represented using two flat relations.	x-3701-3
(One suffices with some coding.)	x-3701-4
(c) Formalize the notion of V-relation of Section 20.1	x-3701-5
Exercise 20.2 Consider a (flat) relation R of sort name age address car child _ name child _ age can be stored in a complex value relation of sort name, age, address, cars : {dom}, children : { child _ name, child _ age} Discuss the advantages of this alternative representation.	x-3702-1
(In particular, show that for the same data, the size of the instance in the second representation is smaller.	x-3702-2
Also consider update anomalies.)	x-3702-3
Exercise 20.3 Consider the value	x-3703-1
Show how to construct it in the core algebra from {a} and {b}.	x-3704-1
Exercise 20.4 Prove that for each complex value relation I , there exists a constant query in the core algebra returning I .	x-3705-1
Complex Values Exercise 20.5 Let R be a database schema consisting of a relation R of sort A : dom, B : A : {dom}, B : A : dom, C : ;	x-3706-1
Exercise 20.6 Prove that set _ create can be expressed using the other operations of the core algebra.	x-3707-1
Hint: Use powerset.	x-3707-2
Exercise 20.7 Formally define the following operations: (a) renaming, (b) singleton, (c) cross-product, and (d) join.	x-3708-1
In each case, prove that the operation is expressible in ALG cv.	x-3708-2
Which of these can be expressed without powerset?	x-3709-1
Exercise 20.8	x-3710-1
Exercise 20.9	x-3711-1
Then map C,q(I ) = {C : q(I1), C′ : J1, C : q(I2), C′ : J2, C : q(I3), C′ : J3}.	x-3712-1
Exercise 20.10 Show how to express in the core calculus.	x-3713-1
Exercise 20.11 The calculus is extended by allowing terms of the form z ∪ z′ and z − z′ for each set term z, z′ of identical sort.	x-3714-1
Prove that this does not modify the expressive power of the language.	x-3714-2
More generally, consider introducing in the calculus terms of the form q(t1, .	x-3714-3
.	x-3714-4
.	x-3714-5
, tn), where q is an n-ary algebraic operation and the ti are set terms of appropriate sort.	x-3714-6
Exercise 20.12 Give five queries on the CINEMA database expressed in ALG cv.	x-3715-1
Give the same queries in CALC cv.	x-3715-2
Exercises Exercise 20.13 Complete the proof that ALG cv ⊑ CALC cv for Theorem 20.5.1.	x-3716-1
Complete the proof of “Last Stage” for Theorem 20.5.1.	x-3716-2
Exercise 20.14 This exercise elaborates the simulation of CALC cv by ALG cv presented in the proof of Theorem 20.5.1.	x-3717-1
In particular, give the details of	x-3717-2
Exercise 20.15 Show that the query in Example 20.6.2 is strongly safe range (e.g., give a query in ALG cv− or CALC cv− equivalent to it).	x-3718-1
Exercise 20.16 Show that every strongly safe-range query is in ALG cv− [one direction of (b) of Theorem 20.5.3].	x-3719-1
Exercise 20.17 Sketch a program expressing the query even in CALC cv+µ+.	x-3720-1
Exercise 20.18 Prove that CALC cv+µ+ =ALG cv.	x-3721-1
Exercise 20.19 Define a while language based on ALG cv.	x-3722-1
Show that it does not have more power than ALG cv.	x-3722-2
Exercise 20.20 Consider a query q whose input consists of two relations blue, red of sort A, B (i.e., consists of two graphs).	x-3723-1
Query q returns a relation of sort A, B : {dom} with the following meaning.	x-3723-2
A tuple x, X is in the result if x is a vertex and X is the set of vertexes y such that there exists a path from x to y alternating blue and red edges.	x-3723-3
Prove in one line that q is expressible in ALG cv.	x-3723-4
Show how to express q in some complex value language of this chapter.	x-3723-5
Exercise 20.21 Generalize the construction of Example 20.6.2 to prove Theorem 20.6.1.	x-3724-1
Exercise 20.22 Datalog with stratified negation was shown to be weaker than datalog with inflationary negation.	x-3725-1
Is the situation similar for datalog cv with negation?	x-3725-2
Exercise 20.23 Exhibit a query that is not expressible in CALC cv− but is expressible in CALC cv, and one that is not expressible in CALC cv.	x-3726-1
Exercise 20.24 Give a relational calculus formula or algebra expression for the query in Example 20.4.8.	x-3727-1
Let whilecv be like while N N , except that the relational algebra expressions are in ALG cv.	x-3728-1
Prove that whilecv can express all queries from flat relations to flat relations.	x-3728-2
N Minkisi are complex objects clearly not the product of a momentary im-pulse.	x-3729-1
.	x-3729-2
.	x-3729-3
.	x-3729-4
To do justice to objects, a theory of them must be as complex as them.	x-3729-5
1 What is a Minkisi?	x-3729-6
Sergio: It is an African word that translates somewhat like “things that do things.” Vittorio: It is art, religion, and magic.	x-3730-1
Riccardo: Oh, this sounds to me very object oriented!	x-3731-1
Inthischapter,weprovideabriefintroductiontoobject-orienteddatabases(OODBs).A complete coverage of this new and exciting area is beyond the scope of this volume; we emphasize the new modeling features of OODBs and some of the preliminary theoretical research about them.	x-3732-1
On the one hand, we shall see that some of the most basic issues concerning OODBs, such as the design of query languages or the analysis of their expressive power, can be largely resolved using techniques already developed in connection with the relational and complex value models.	x-3732-2
On the other hand, the presence of new features (such as object identifiers) and methods brings about new questions and techniques.	x-3732-3
This chapter begins with an informal presentation of the underlying constructs of OODBs.	x-3733-1
Next a formal definition for a particular OODB model is presented.	x-3733-2
Two directions of theoretical research into OODBs are then discussed.	x-3733-3
First a family of languages 1 Reprinted with permission.	x-3733-4
Smithsonian Institution Press ©1993.	x-3733-5
for data access is presented, with an emphasis on how the languages interact with the novel modeling constructs (of particular interest is the impact of generalizing the notion of complete query language to accommodate the presence of object identifiers, OIDs).	x-3734-1
Next two languages for methods are described.	x-3734-2
The first is an imperative language allowing us to specify methods with side effects.2 The second language brings us to a functional perspective on methods and database languages and allows us to specify side-effect-free methods.	x-3734-3
In both cases, we present some results on type safety and expressive power.	x-3735-1
Checking type safety is generally undecidable; we identify a significant portion of the functional language, monadic method schemas, for which type safety is decidable.	x-3735-2
With respect to expressive power, the imperative language is complete in an extended sense formalized in this chapter.	x-3735-3
The functional language expresses precisely qptime on ordered inputs and so turns out to express the by-now-famous fixpoint queries.	x-3736-1
The chapter concludes with a brief survey of additional research issues raised by OODBs.	x-3736-2
Informal Presentation Object-oriented database models stem from a synthesis of three worlds: the complex value model, semantic database models, and object-oriented programming concepts.	x-3737-1
At the time of writing, there is not widespread agreement on a specific OODB model, nor even on what components are required to constitute an OODB model.	x-3737-2
In this section, we shall focus on seven important ingredients of OODB models:	x-3737-3
In this section, we describe and illustrate these interrelated notions informally; a more formal definition is presented in the following section.	x-3738-1
We will also briefly discuss alternatives.	x-3738-2
Object Databases create schema PariscopeSchema ; create base PariscopeBase; class Person type tuple ( name: string, citizenship: string, gender: string ); class Director inherit Person type tuple ( directs: set ( Movie ) ); class Actor inherit Person type tuple ( acts_in: { Movie }, class Actor _ Director inherit Director, Actor class Movie type tuple ( title: string, actors: set ( Actor ); director: Director ); class Theater type tuple ( name: string, address: string, phone: string ); name Pariscope: set ( tuple ( theater: Theater, time: string, price: integer, movie: Movie ) ); name Persons _ I _ like: set ( Person ); name Actors _ I _ like, Actors _ you _ like: set ( Actor ); name My _ favorite _ director : Director method get _ name in class Person : string return “Mr.” + self.name; else return “Ms.” + self.name } method get _ name in class Director : string method get _ name in class Actor _ Director : string problem arises if the person changes his or her name (e.g., as the result of marriage).	x-3739-1
When performing this update, conceptually there is a break in the continuity in the representation of the person.	x-3739-2
Furthermore, care must be taken to update all tuples (typically arising in a number of different relations) that refer to this person, to reflect the change of name.	x-3739-3
Following the spirit of semantic data models, OODB models permit the explicit representation of physical and conceptual objects through the use of object identifiers (OIDs).	x-3740-1
Conceptually, a unique OID is assigned to each object that is represented in the database, and this association between OID and object remains fixed, even as attributes of the object (such as name or age) change in value.	x-3741-1
The use of objects and OIDs permits OODBs to share information gracefully; a given object o is easily shared by many other objects simply by referencing the OID of o.	x-3741-2
This is especially important in the context of updates; for example, the name of a person object o need be changed in only one place even if o is shared by many parts of the database.	x-3741-3
In an OODB, a complex value is associated with each object.	x-3742-1
This complex value may involve printables and/or OIDs (i.e., references to the same or other objects).	x-3742-2
For example, each object in the class Movie in Fig.	x-3742-3
21.1 has an associated triple whose second coordinate contains a set of OIDs corresponding to actors.	x-3742-4
In this section, we focus on complex values constructed using the tuple and set construct.	x-3742-5
In practical OODB models, other constructs are also supported (including, for example, bags and lists).	x-3742-6
Some commercial OODBs are based on an extension of C++ that supports persistence; in these models essentially any C++ structure can serve as the value associated with an object.	x-3742-7
Objects that have complex values with the same type may be grouped into classes, as happens in semantic data models.	x-3743-1
In the running example, these include Person, Director, and Movie.	x-3743-2
Classes also serve as a natural focal point for associating some of the behavioral (or procedural) components of a database application.	x-3743-3
This is accomplished by associating with each class a family of methods for that class.	x-3743-4
Methods might be simple (e.g., producing the name of a person) or arbitrarily complex (e.g., displaying a representation of an object to a graphical interface or performing a stress analysis of a proposed wing design).	x-3743-5
In OODB models, there are two important implications of the statement that class c′ is a subclass of c. First it is required that the complex value type associated with c′ be a subtype (in the sense formally defined later) of the complex value type associated with c.	x-3744-1
Second it is required that if there is a method with name m associated with c, then there is also a method with name m associated with c′.	x-3745-1
In some cases, the implementation (i.e., the actual code) of m for c′ is identical to that for c; in this case the code of m for c′ need not Object Databases be explicitly specified because it is inherited from c. In other cases, the implementation of m for c′ is different from that for c; in which case we say that the implementation of m for c′ overrides the implementation of m for c. (See the different implementations for method get _ name in Fig.	x-3745-2
21.1.)	x-3745-3
The determination of what implementation is associated with a given method name and class is called method resolution.	x-3745-4
A method is invoked with respect to an object o, and the class to which o belongs determines which implementation is to be used.	x-3745-5
This policy is called dynamic binding.	x-3745-6
As we shall see, the interaction of method calls and dynamic binding in general makes type checking for OODB schemas undecidable.	x-3745-7
(It is undecidable to check whether such a schema would lead to a runtime type error; on the other hand, it is clearly possible to find decidable sufficient conditions that will guarantee that no such error can arise.)	x-3745-8
In the particular OODB model presented here, both values (in the style of complex values) and objects are supported.	x-3746-1
For example, in Fig.	x-3746-2
21.1 a persistent set of triples called Pariscope is supported (see also Fig.	x-3746-3
11.1).	x-3746-4
The introduction of values not directly associated with OIDs is a departure from the tradition of object-oriented programming, and not all OODBs in the literature support it.	x-3746-5
However, in databases the use of explicit values often simplifies the design and use of a schema.	x-3746-6
Their presence also facilitates expressing queries in a declarative manner.	x-3746-7
The important principle of encapsulation in object orientation stems from the field of abstract data types.	x-3747-1
Encapsulation is used to provide a sharp boundary between how information about objects is accessed by database users and how that information is actually stored and provided.	x-3747-2
The principle of encapsulation is most easily understood if we distinguish two categories of database use: dba mode, which refers to activities unique to database administrators (including primarily creating and modifying the database schema), and user mode, which refers to activities such as querying and updating the actual data in the database.	x-3747-3
Of course, some users may operate in both of these modes on different occasions.	x-3747-4
In general, application software is viewed as invoked from the user mode.	x-3747-5
Encapsulation requires that when in user mode, a user can access or modify information about a given object only by means of the methods defined for that object; he or she cannot directly examine or modify the complex value or the methods associated with the object.	x-3748-1
In particular, then, essentially all application software can access objects only through their methods.	x-3748-2
This has two important implications.	x-3748-3
First, as long as the same set of methods is supported, the underlying implementation of object methods, and even of the complex value representation of objects, can be changed without having to modify any application software.	x-3748-4
Second, the methods of an object often provide a focused and abstracted interface to the object, thus making it simpler for programmers to work with the objects.	x-3748-5
In object-oriented programming languages, it is typical to enforce encapsulation except in the special case of rewriting method implementations.	x-3749-1
In some OODB models, there is an important exception to this in connection with query languages.	x-3749-2
In particular, it is generally convenient to permit a query language to examine explicitly the complex values associated with objects.	x-3749-3
The reader with no previous exposure to object-oriented languages may now be utterly overwhelmed by the terminology.	x-3750-1
It might be helpful at this point to scan through a book or manual about an object-oriented programming language such as C++, or an OODB such	x-3750-2
Formal Definition of an OODB Model This section presents a formal definition of a particular OODB model, called the generic OODB model.	x-3751-1
(This model is strongly influenced by the IQL and O2 models.	x-3751-2
Many features are shared by most other OODB models.	x-3751-3
While presenting the model, we also discuss different choices made in other models.)	x-3751-4
The presentation essentially follows the preceding informal one, beginning with definitions for the types and class hierarchy and then introducing methods.	x-3751-5
It concludes with definitions of OODB schema and instance.	x-3751-6
Types and Class Hierarchy The formal definitions of object, type, and class hierarchy are intertwined.	x-3752-1
An object consists of a pair ( identifier, value).	x-3752-2
The identifiers are taken from a specific sort containing OIDs.	x-3752-3
The values are essentially standard complex values, except that OIDs may occur within them.	x-3752-4
Although some of the definitions on complex values and types are almost identical to those in Chapter 20, we include them here to make precise the differences from the object-oriented context.	x-3752-5
As we shall see, the class hierarchy obeys a natural restriction based on subtyping.	x-3752-6
To start, we assume a number of atomic types and their pairwise disjoint corresponding domains: integer, string, bool, float.	x-3753-1
The set dom of atomic values is the (disjoint) union of these domains; as before, the elements of dom are called constants.	x-3753-2
We also assume an infinite set obj = {o1, o2, .	x-3753-3
.	x-3753-4
.}	x-3753-5
of object identifiers (OIDs), a set class of class names, and a set att of attribute names.	x-3753-6
A special constant nil represents the undefined (i.e., null) value.	x-3753-7
Given a set O of OIDs, the family of values over O is defined so that (a) nil, each element of dom, and each element of O are values over O; and (b) if v1, .	x-3754-1
.	x-3754-2
.	x-3754-3
, vn are values over O, and A1, .	x-3754-4
.	x-3754-5
.	x-3754-6
, An distinct attributes names, the tuple [A1 : v1, .	x-3754-7
.	x-3754-8
.	x-3754-9
, An : vn] and the set {v1, .	x-3754-10
.	x-3754-11
.	x-3754-12
, vn} are values over O.	x-3754-13
The set of all values over O is denoted val(O).	x-3755-1
An object is a pair (o, v), where o is an OID and v a value.	x-3755-2
In general, object-oriented database models also include constructors other than tuple and set, such as list and bag; we do not consider them here.	x-3756-1
Example 21.2.1 Letting oid 7, oid 22, etc.	x-3757-1
denote OIDs, some examples of values are as follows: Object Databases schema.	x-3757-2
Types are defined with respect to a given set C of class names.	x-3758-1
The family of types over C is defined so that	x-3758-2
The set of types over C together with the special class name any are denoted types(C).	x-3759-1
Example 21.2.2 One may want to give a name to this type (e.g., Person _ type).	x-3760-1
Other examples of types (with names associated to them) include Director _ type = [ name : string, citizenship : string, gender : string, directs : { Movie}] Theater _ type Pariscope _ type = [ theater : Theater, time : string, price : integer, movie : Movie] Movie _ type In an OODB schema we associate with each class c a type σ (c), which dictates the type of objects in this class.	x-3760-2
In particular, for each object (o, v) in class c, v must have the exact structure described by σ (c).	x-3760-3
Recall from the informal description that an OODB schema includes an ISA hierarchy among the classes of the schema.	x-3761-1
The class hierarchy has three components: (1) a set of classes, (2) the types associated with these classes, and (3) a specification of the ISA relationships between the classes.	x-3761-2
Formally, a class hierarchy is a triple (C, σ, ≺), where C is a finite set of class names, σ a mapping from C to types(C), and ≺ a partial order on C.	x-3761-3
Informally, in a class hierarchy the type associated with a subclass should be a refinement of the type associated with its superclass.	x-3762-1
For example, a class Student is expected to refine the information on its superclass Person by providing additional attributes.	x-3762-2
To capture this notion, we use a subtyping relationship (≤) that specifies when one type refines another.	x-3762-3
Definition 21.2.3 Let (C, σ, ≺) be a class hierarchy.	x-3763-1
The subtyping relationship on types(C) is the smallest partial order ≤ over types(C) satisfying the following conditions: (a) if c ≺ c′, then c ≤ c′; i n : τ ′n	x-3763-2
By way of illustration, it is easily verified that Director _ type ≤ Person _ type Director _ type "≤ Movie _ type.	x-3764-1
Thus the schema obtained by adding the constraint Director ≺ Movie would not be well formed.	x-3765-1
Henceforth we consider only well-formed class hierarchies.	x-3766-1
Example 21.2.4 Consider the class hierarchy (C, σ, ≺) of the schema of Fig.	x-3767-1
21.1.	x-3767-2
The set of classes is C = { Person, Director, Actor, Actor _ Director, Theater, Movie} with Actor ≺ Person, Director ≺ Person, Actor _ Director ≺ Director, Actor _ Director ≺	x-3767-3
Object Databases The use of type names here is purely syntactic.	x-3768-1
We would obtain the same schema if we replaced, for instance, Person _ type with the value of this type.	x-3768-2
Observe that σ ( Director) ≤ σ ( Person) and σ ( Actor) ≤ σ ( Person), etc.	x-3769-1
The Structural Semantics of a Class Hierarchy We now describe how values can be associated with the classes and types of a class hierarchy.	x-3770-1
Because the values in an OODB instance may include OIDs, the semantics of classes and types must be defined simultaneously.	x-3770-2
The basis for these definitions is the notion of OID assignment, which assigns a set of OIDs to each class.	x-3770-3
Definition 21.2.5 Let (C, σ, ≺) be a (well-formed) class hierarchy.	x-3771-1
An OID assignment is a function π mapping each name in C to a disjoint finite set of OIDs.	x-3771-2
Given OID	x-3771-3
If π is an OID assignment, then π ∗(c′) ⊆ π ∗(c) whenever c′ ≺ c. This should be understood as a formalization of the fact that an object of a subclass c′ may be viewed also as an object of a superclass c of c′.	x-3772-1
From the perspective of typing, this suggests that operations that are type correct for members of c are also type correct for members of c′.	x-3772-2
Unlike the case for many semantic data models, the definition of OID assignment for OODB schemas implies that extensions of classes of an ISA hierarchy without common subclasses are necessarily disjoint.	x-3773-1
In particular, extensions of all leaf classes of the hierarchy are disjoint (see Exercise 21.2).	x-3773-2
This is a simplifying assumption that makes it easier to associate objects to classes.	x-3773-3
There is a unique class to whose disjoint extension each object belongs.	x-3773-4
The semantics for types is now defined relative to a class hierarchy (C, σ, ≺) and an OID assignment π .	x-3774-1
Let O = ∪{π(c) | c ∈ C}, and define π(any) = O.	x-3774-2
The disjoint interpretation of a type τ , denoted dom(τ ), is given by (a) for each atomic type τ , dom(τ ) is the usual interpretation of that type; (b) dom(any) is val(O);	x-3774-3
Remark 21.2.6 In the preceding interpretation, the type determines precisely the structure of a value of that type.	x-3775-1
It is interesting to replace (e) by dom([A1 : τ1, .	x-3775-2
.	x-3775-3
.	x-3775-4
, Ak : τk]) = vi ∈ dom(τi), i ∈ [1, k], vj ∈ val(O), j ∈ [k + 1, l]}.	x-3775-5
Under this alternative interpretation, for each τ, τ ′ in types(C), if τ ′ ≤ τ then dom(τ ′) ⊆ dom(τ ).	x-3776-1
This is why this is sometimes called the domain-inclusion semantics.	x-3776-2
From a data model viewpoint, this presents the disadvantage that in a correctly typed database instance, a tuple may have a field that is not even mentioned in the database schema.	x-3776-3
For this reason, we do not adopt the domain-inclusion semantics here.	x-3776-4
On the other hand, from a linguistic viewpoint it may be useful to adopt this more liberal semantics in languages to allow variables denoting tuples with more attributes than necessary.	x-3776-5
The final ingredient of the generic OODB model is methods.	x-3777-1
A method has three components:	x-3777-2
There is no problem in specifying the names and signatures of methods in an OODB schema.	x-3778-1
To specify the implementation of methods, a language for methods is needed.	x-3778-2
We do not consider specific languages in the generic OODB model.	x-3779-1
Therefore only names and signatures of methods are specified at the schema level in this model.	x-3779-2
In Section 21.4, we shall consider several languages for methods and shall therefore be able to add the implementation of methods to the schema.	x-3779-3
Without specifying the implementation of methods, the generic OODB model specifies their semantics (i.e., the effect of each method in the context of a given instance).	x-3780-1
This effect, which is a function over the domains of the types corresponding to the signature of the method, is therefore specified at the instance level.	x-3780-2
We assume the existence of an infinite set meth of method names.	x-3781-1
Let (C, σ, ≺) be a class hierarchy.	x-3781-2
For method name m, a signature of m is an expression of the form m : c × τ1 × · · · × τn−1 → τn, where c is a class name in C and each τi is a type over C. This signature is associated with the class c; we say that method m applies to objects of class c and to objects of classes that inherit m from c. It is common for the same method name to have different signatures in connection with different classes.	x-3781-3
(Some restrictions shall be specified later.)	x-3781-4
The notion of signature here generalizes the one typically found in Object Databases object-oriented programming languages, because we permit the τi’s to be types rather than only classes.	x-3781-5
It is easiest to describe the notions of overloading, method inheritance, and dynamic binding in terms of an example.	x-3782-1
Consider the methods defined in the schema of Fig.	x-3782-2
21.1.	x-3782-3
get _ name : Director → string get _ name : Actor _ Director → string Note that get _ name has different implementations for these classes; this is an example of overloading of a method name.	x-3783-1
Recall that Actor is a subclass of Person.	x-3784-1
According to the informal discussion, if get _ name applies to elements of Person, then it should also apply to members of Actor.	x-3784-2
Indeed, in the object-oriented paradigm, if a method m is defined for a class c but not for a subclass c′ of c (and it is not defined anywhere else along a path from c′ to c), then the definition of m for c′ is inherited from c. In particular, the signature of m on c′ is identical to the one of m for c, except that the first c is replaced by c′.	x-3785-1
The implementation of m for c′ is identical to that for c. In the schema of Fig.	x-3785-2
21.1, the signature of get _ name for Actor is get _ name : Actor → string	x-3785-3
Suppose that π is an OID assignment, that oid 25 is in the extension π ∗( Person) of Person, and that get _ name is called on oid 25.	x-3786-1
What implementation of get _ name will be used?	x-3786-2
In our OODB model we shall use dynamic binding (also called late binding, or value-dependent binding).	x-3786-3
This means that the specific implementation chosen for get _ name on oid 25 depends on the most specific class that oid 25 belongs to, that is, the class c such that oid 25 ∈ π(c).	x-3786-4
Under this discipline, the implementation used for get _ name depends on the type associated with the variable holding oid 25 at the point in program where get _ name is invoked.	x-3787-1
This can be determined at compile time, and so static binding is generally much cheaper than dynamic binding.	x-3788-1
In the language C++, the default is static binding, but dynamic binding can be obtained by using the keyword virtual when specifying the method.)	x-3788-2
Consider a call m(o, v1, .	x-3788-3
.	x-3788-4
.	x-3788-5
, vn−1) to method m. This is often termed a message, and o is termed the receiver.	x-3788-6
As described here, the implementation of m associated with this message depends exclusively on the class of o.	x-3788-7
To emphasize the importance of the receiver for finding the actual implementation, in some languages the message is denoted o → m[v1, .	x-3788-8
.	x-3788-9
.	x-3788-10
vn−1].	x-3788-11
In some object-oriented programming languages, such as CommonLoops (an object-oriented extension of LISP), the implementation depends on m c′ c′′ m c′′′ m c Figure 21.2: Unambiguous definition	x-3788-12
The set of methods applicable to an object is called the interface of the object.	x-3789-1
As noted in the informal description of OODB models, in most cases objects are accessed only via their interface; this philosophy is called encapsulation.	x-3789-2
Unambiguity: If c is a subclass of c′ and c′′ and there is a definition of m for c′ and c′′, then there is a definition of m for a subclass of c′ and c′′ that is either c itself, or a superclass of c. (See Fig.	x-3790-1
21.2.)	x-3790-2
Covariance 4 : If m : c × τ1 × · · · × τn → τ and m : c′ × τ ′ × · · · × τ ′ → τ ′ are two defi-1 m nitions and c ≺ c′, then n = m for each i, τi ≤ τ ′ and τ ≤ τ ′.	x-3791-1
i The first rule prevents ambiguity resulting from the presence of two method implementations both applicable for the same object.	x-3792-1
A primary motivation for the second rule is intuitive: We expect the argument and result types of a method on a subclass to be more refined than those of the method on a superclass.	x-3792-2
This also simplifies the writing of type-correct programs, although type checking leads to difficulties even in the presence of the covariance assumption (see Section 21.4).	x-3792-3
Database Schemas and Instances We conclude this section by presenting the definitions of schemas and instances in the generic OODB model.	x-3793-1
An important subtlety here will be the role of OIDs in instances 4 In type theory, contravariance is used instead.	x-3793-2
Contravariance is the proper notion when functions are passed as arguments, which is not the case here.	x-3793-3
Object Databases	x-3794-1
In many practical OODBs, it has been found convenient to allow storage of complex values that are not associated with any objects and that can be accessed directly using some name.	x-3795-1
This also allows us to subsume gracefully the capabilities of value-based models, such as relations and complex values.	x-3795-2
It also facilitates writing queries.	x-3795-3
To reflect this feature, we allow a similar mechanism in schemas and instances.	x-3795-4
Thus schemas may include a set of value names with associated types.	x-3795-5
Instances assign values of appropriate type to the names.	x-3795-6
Method implementations, external programming languages, and query languages may all use these names (to refer to their current values) or a class name (to refer to the set of objects currently residing in that class).	x-3795-7
In this manner, named values and class names are analogous to relation names in the relational model and to complex value relation names in the complex value model.	x-3795-8
In the schema of Fig.	x-3796-1
21.1, examples of named values are Pariscope (holding a set of triples); Persons _ I _ like, Actors _ I _ like, and Actors _ you _ like (referring to sets of person objects and actor objects; and, finally, My _ favorite _ director (referring to an individual object as opposed to a set).	x-3796-2
These names can be used explicitly in method implementations and in external query and programming languages.	x-3796-3
We now have the following: Definition 21.2.7	x-3797-1
Definition 21.2.8	x-3798-1
that is, µ(m : c × *	x-3799-1
Recall that a method m can occur with different signatures in the same schema.	x-3800-1
The mapping µ can assign different semantics to each signature of m. The function µ(m : c × *	x-3800-2
In the preceding definitions, the assignment of semantics to method signatures is included in the instance.	x-3801-1
As will be seen in Section 21.4, if method implementations are included in the schema, they induce the semantics of methods at the instance level (this is determined by the semantics of the particular programming language used in the implementation).	x-3801-2
Intuitively, it is generally assumed that elements of the atomic domains have universally understood meaning.	x-3802-1
In contrast, the actual OIDs used in an instance are not relevant.	x-3802-2
They serve essentially as placeholders; it is only their relationship with other OIDs and constants that matters.	x-3803-1
This arises in the practical perspective in two ways.	x-3803-2
First, in most practical systems, OIDs cannot be explicitly created, examined, or manipulated.	x-3803-3
Second, in some object-oriented systems, the actual OIDs used in a physical instance may change over the course of time (e.g., as a result of garbage collection or reclustering of objects).	x-3803-4
To capture this aspect of OIDs in the formal model, we introduce the notion of OID isomorphism.	x-3804-1
Two instances I, J are OID isomorphic, denoted I ≡ OID J, if there exists a bijection on dom ∪ obj that maps obj to obj, is the identity on dom, and transforms I into J.	x-3804-2
To be precise, the term object-oriented instance should refer to an equivalence class under OID isomorphism of instances as defined earlier.	x-3805-1
However, it is usually more convenient to work with representatives of these equivalence classes, so we follow that convention here.	x-3805-2
Remark 21.2.9 In the model just described, a class encompasses two aspects:	x-3806-1
It has been argued that one should not associate explicit class extensions with classes.	x-3807-1
To see the disadvantage of class extensions, consider object deletion.	x-3807-2
To be removed from the database, an object has to be deleted explicitly from its class extension.	x-3807-3
This is not convenient in some cases.	x-3807-4
For instance, suppose that the database contains a class Polygon and polygons are used only in figures.	x-3807-5
When a polygon is no longer used in any figure of the current database, it is no longer of interest and should be deleted.	x-3807-6
We would like this deletion to be implicit.	x-3807-7
(Otherwise the user of the database would have to search all possible places in which a reference to a polygon may occur to be able to delete a polygon.)	x-3807-8
To capture this, some OODBs use an integrity constraint, which states that Object Databases every object should be accessible from some named value.	x-3807-9
This integrity constraint is enforced by an automatic deletion of all objects that become unreachable from the named values.	x-3808-1
In the polygon example, this approach would allow defining the class Polygon, thus specifying the structure and methods proper to polygons.	x-3808-2
However, the members of class Polygon would only be those polygons that are currently relevant.	x-3809-1
Relevance is determined by membership in (or accessibility from) the named values (e.g., My-Figures, Your-Figures) that refer to polygons.	x-3809-2
From a technical viewpoint, this involves techniques such as garbage collection.	x-3809-3
In these OODBs, the set of objects in a class is not directly accessible.	x-3810-1
For this reason, the corresponding models are sometimes called models without class extension.	x-3810-2
Of course, it is always possible, given a schema, to compute the class extensions or to adapt object creation in a given class to maintain explicitly a named value containing that class extension.	x-3811-1
In these OODBs, the named values are also said to be roots of persistence, because the persistence of an object is dependent on its accessibility from these named values.	x-3811-2
Languages for OODB Queries This section briefly introduces several languages for querying OODBs.	x-3812-1
These queries are formulated against the database as a whole; unlike methods, they are not associated with specific classes.	x-3812-2
In the next section, we will consider languages intended to provide implementations for methods.	x-3812-3
In describing the OODB query languages, we emphasize how OODB features are incorporated into them.	x-3813-1
The first language is an extension of the calculus for complex values, which incorporates such object-oriented components as OIDs, different notions of equality, and method calls.	x-3813-2
The second is an extension of the while language, initially introduced in Chapter 14.	x-3813-3
Of primary interest here is the introduction of techniques for creating new OIDs as part of a query.	x-3813-4
At this point we examine the notion of completeness for OODB access languages.	x-3813-5
We also briefly look at a language introducing a logic-based approach to object creation.	x-3813-6
Finally, we mention a practical language, O2SQL.	x-3813-7
This is a variant of SQL for OODBs that provides elegant object-oriented features.	x-3813-8
The object-oriented calculus presented here is a straightforward generalization of the complex value calculus of Chapter 20, extended to incorporate objects, different notions of equality, and methods.	x-3814-1
Let (C, σ, ≺, M, G) be an OODB schema, and let us ignore the object-oriented features for a moment.	x-3815-1
Each name in G can be viewed as a complex value; it is straightforward to generalize the complex value calculus to operate on the values referred to by G. (The fact that in the complex value model all relations are sets whereas some names in G might refer to nonset values requires only a minor modification of the language.)	x-3815-2
Let us now consider objects.	x-3815-3
OIDs may be viewed as elements of a specific sort.	x-3815-4
If viewed in isolation from their associated values, this suggests that the only primitive available for comparing OIDs is equality.	x-3816-1
Recall from the schema of Fig.	x-3816-2
21.1 the names Actors _ I _ like and Actors _ you _ like.	x-3816-3
The query6 In the previous query, x ↑ denotes the value of x, in this case, a tuple with four fields.	x-3816-4
The dot notation (.)	x-3816-5
is used as before to obtain the value of specific fields.	x-3816-6
In query (21.1), we tested two objects for equality, essentially testing whether they had the same OID.	x-3817-1
Although it does not increase the expressive power of the language, it is customary to introduce an alternative test for equality, called value equality.	x-3817-2
This tests whether the values of two objects are equal regardless of whether their OIDs are distinct.	x-3817-3
To illustrate, consider the three objects having Actor _ type: ( oid 50, [ name : “Martin”, citizenship : “French”, gender : “male”, award : { }, acts _ in : { oid 33}]) Then oid 50 and oid 51 are value equal, whereas oid 50 and oid 52 are not.	x-3818-1
Yet another form of equality is deep equality.	x-3818-2
If oid 33 and oid 34 are value equal, then oid 50 and oid 52 are deep equal.	x-3818-3
Intuitively, two objects are deep equal if the (possibly infinite) trees obtained by recursively replacing each object by its value are equal.	x-3818-4
The infinite trees that we obtain are called the expansions.	x-3818-5
They present some regularity; they are regular trees (see Exercise 21.10).	x-3818-6
The notion of deep equality highlights a major difference between value-based and object-based models.	x-3819-1
In a value-based model (such as the relational or complex value 6 In this example, if name is a key for Actor, then one can easily obtain an equivalent query not using object equality; this may not be possible if there is no key for Actor.	x-3819-2
Object Databases models), the database can be thought of as a collection of (finite) trees.	x-3820-1
The connections between trees arise as a result of the contents of atomic fields.	x-3820-2
That is, they are implicit (e.g., the same string may appear twice).	x-3820-3
In the object-oriented world, a database instance can be thought of as graph.	x-3820-4
Paths in the database are more explicit.	x-3820-5
That is, one may view an ( oid, value) pair as a form of logical pointer and a path as a sequence of pointer dereferencing.	x-3820-6
This graph-based perspective leads naturally to a navigational form of data access (e.g., using a sequence such as o ↑ .	x-3821-1
director ↑ .	x-3821-2
citizenship to find the citizenship of the director of a given movie object o).	x-3821-3
This has led some to view object-oriented models as less declarative than value-based models such as the relational model.	x-3821-4
This is inaccurate, because declarativeness is more a property of access languages than models.	x-3821-5
Indeed, the calculus for OODBs described here illustrates that a highly declarative language can be developed for the OODB model.	x-3821-6
We conclude the discussion of the object-oriented calculus by incorporating methods.	x-3822-1
For this discussion, it is irrelevant how the methods are specified or evaluated; this evaluation is external to the query.	x-3822-2
The query simply uses the method invocations as oracles.	x-3822-3
Method resolution uses dynamic binding.	x-3822-4
The value of an expression of the form m(t1, .	x-3822-5
.	x-3822-6
.	x-3822-7
, tn) under a given variable assignment ν is obtained by evaluating (externally) the implementation of m for the class of ν(t1) on input ν(t1, .	x-3822-8
.	x-3822-9
.	x-3822-10
, tn).	x-3822-11
In this context, it is assumed that m has no side-effects.	x-3822-12
Although not defined formally here, the following illustrates the incorporation of methods into the calculus: If the set Persons_I_like contains Bergman and Liv Ullman, the answer would be The use of method names within the calculus raises a number of interesting typing and safety issues that will not be addressed here.	x-3822-13
Object Creation and Completeness Relational queries take relational instances as input and produce relational instances as output.	x-3823-1
The preceding calculus fails to provide the analogous capability because the output of a calculus query is a set of values or objects.	x-3823-2
Two features are needed for a query language to produce the full-fledged structural portion of an object-oriented instance: the ability to create OIDs, and the ability to populate a family of named values (rather than producing a single set).	x-3823-3
We first introduce an extension of the while language of Chapter 14 that incorporates both of these capabilities.	x-3824-1
This language leads naturally to a discussion of completeness of OODB access languages.	x-3824-2
After this we mention a second approach to object creation that stems from the perspective of logic programming.	x-3824-3
The extension of while introduced here is denoted while obj .	x-3825-1
It will create new OIDs in a manner reminiscent of how the language while new of Chapter 18 invented new constants.	x-3825-2
The language while obj incorporates object-oriented features such as dereferencing and method calls, as in the calculus.	x-3826-1
To illustrate, we present a while obj program that collects all actors reachable from an actor I like—Liv Ullman.	x-3826-2
In this query, v_ movies and v_ directors serve as variables, and reachable serves as a new name that will hold the output.	x-3826-3
reachable := {x | x ∈ Actors _I _ like ∧ x ↑ .	x-3827-1
name = “Liv Ullman”}; v_ movies := { }; v_ directors := { }; while change do begin reachable := reachable ∪ {x | ∃y(y ∈ v_ movies ∧ x ∈ y ↑ .	x-3827-2
actors)}; v_ directors := v_ directors v_ movies := v_ movies end; We now introduce object creation.	x-3827-3
The operator new works as follows.	x-3827-4
It takes as input a set of values (or objects) and produces one new OID for each value in the set.	x-3827-5
As a simple example, suppose that we want to objectify the quadruples in the named value Pariscope of the schema of Fig.	x-3827-6
21.1.	x-3827-7
This may be accomplished with the commands add _ class Pariscope _ obj type tuple ( theater : Theater, time : string, price : integer, movie : Movie); Pariscope _ obj := new( Pariscope) Of course, the new operator can be used in conjunction with arbitrary expressions that yield a set of values, not just a named value.	x-3827-8
The new operator used here is closely related to the new operator of the language while new of Chapter 18.	x-3828-1
Given that while obj has iteration and the ability to create new OIDs, it is natural to ask about the expressive power of this language.	x-3828-2
To set the stage, we introduce the following analogue of the notion of (computable) query, which mimics the one of Chapter 18.	x-3828-3
The definition focuses on the structural portion of the OODB model; methods are excluded from consideration.	x-3828-4
Definition 21.3.1 Let R and S be two OODB schemas with no method signatures.	x-3829-1
A determinate query is a relation Q from inst(R) to inst(S) such that (a) Q is computable; Q.	x-3829-2
Object Databases The essential difference between the preceding definition and the definition of determinate query in Chapter 18 is that here only OIDs can be created, not constants.	x-3830-1
Parts (c) and (d) of the definition ensure that a determinate query Q can be viewed as a function from OID equivalence classes of instances over R to OID equivalence classes of instances over S. So OIDs serve two purposes here: (1) They are used to compute in the same way that invented values were used to break the polynomial space barrier; and (2) they are now essential components of the data structure and in particular of the result.	x-3830-2
With respect to (2), an important aspect is that we are not concerned with the actual value of the OIDs, which motivates the use of the equivalence relation.	x-3830-3
(Two results are viewed as identical if they are the same up to the renaming of the OIDs.)	x-3830-4
Like whilenew, whileobj is not determinate complete.	x-3831-1
There is an elegant characterization of the determinate queries expressible in whileobj.	x-3831-2
This result, which we state next, uses a local characterization of input-output pairs of whileobj programs.	x-3831-3
That characterization is in the spirit of the notion of bp-completeness, relating input-output pairs of relational calculus queries (see Exercise 16.11).	x-3831-4
For each input-output pair I, J , the characterization of whileobj queries requires a simple connection between the automorphism group of I and that of J .	x-3831-5
For an instance K, let Aut(K) denote the set of automorphisms of K. For a pair of instances K, K′, Aut(K, K′) denotes the bijections on adom(K ∪ K′) that are automorphisms of both K and K′.	x-3831-6
Theorem 21.3.2	x-3832-1
The “only if” part of the theorem is proven by an extension of the trace technique developed in the proof of Theorem 18.2.5 (Exercise 21.14).	x-3833-1
The “if” part is considerably more complex and is based on a group-theoretic argument.	x-3833-2
Proposition 21.3.3 Query q (of Fig.	x-3834-1
21.3) is not expressible in whileobj.	x-3834-2
Proof Let I, J be the input-output pair of Fig.	x-3835-1
21.3.	x-3835-2
The proof is by contradiction.	x-3835-3
Suppose there is a whileobj query that produces J on input I .	x-3836-1
By Theorem 21.3.2, there is an extension homomorphism h from Aut(I ) to Aut(I, J ).	x-3836-2
Let µ be the automorphism of I exchanging a and b.	x-3836-3
Note that µ−1 = µ, so µ ◦ µ = idI .	x-3836-4
Consider h(µ)(ψ0).	x-3836-5
Clearly, h(µ)(ψ0) ∈ {ψ1, ψ3}.	x-3836-6
Suppose h(µ)(ψ0) = ψ1 (the other case is similar).	x-3836-7
Then clearly, b Figure 21.3: h(µ)(ψ1) = ψ2.	x-3836-8
Consider now h(µ ◦ µ)(ψ0).	x-3836-9
We have, on one hand, h(µ ◦ µ)(ψ0) = (h(µ) ◦ h(µ))(ψ0) h(µ ◦ µ)(ψ0) = h(idI )(ψ0) which is a contradiction because ψ0 "= ψ2.	x-3836-10
So q is not expressible in whileobj.	x-3836-11
It is possible to obtain a language expressing all determinate queries by adding to whileobj a choose operator that allows the selection (nondeterministically but in a determinate manner) of one object out of a set of objects that are isomorphic (see Exercise 18.14).	x-3837-1
However, this is a highly complex construct because it requires the ability to check for isomorphism of graphs.	x-3838-1
The search for simpler, local constructs that yield a determinate-complete language is an active area of research.	x-3838-2
We now briefly introduce an alternative approach for creating OIDs that stems from the perspective of datalog and logic programming.	x-3839-1
Suppose that a new OID is to be created for each pair t, m, where movie m is playing at theater t according to the current value of Pariscope.	x-3839-2
Consider the following dataloglike rule: Object Databases distinct pair of (t, m) values.	x-3839-3
Using the symbol ∃!	x-3839-4
to mean “exists a unique,” the following versions of (1) intuitively captures the semantics.	x-3839-5
This suggests that Skolem functions might be used.	x-3840-1
Specifically, let ftm be a function symbol associated with the predicate create _ tm _ object.	x-3840-2
We rewrite (2) as or, leaving off the universal quantifiers as traditional in datalog, 4. create _ tm _ object(ftm(t, m), t, m) ← Pariscope(t, s, m ) Under this approach, the Skolem terms resulting from rule (4) are to be interpreted as new, distinct OIDs.	x-3840-3
Under some formulations of the approach, syntactic objects such as ftm( oid 7, oid 22) (where oid 7 is the OID of some theater and oid 22 the OID of some movie) serve explicitly as OIDs.	x-3840-4
Under other formulations, such syntactic objects are viewed as placeholders during an intermediate stage of query evaluation and are (nondeterministically) replaced by distinct new OIDs in the final stage of query evaluation (see Exercise 21.13).	x-3840-5
The latter approach to OID creation, incorporated into complex value datalog extended to include also OID dereferencing, yields a language equivalent to while obj .	x-3841-1
As with while obj , this language is not determinate complete.	x-3841-2
We briefly illustrate some object-oriented features of the language O2SQL, which was introduced in Section 20.8.	x-3842-1
Several examples are presented there, that show how O2SQL can be used to access and construct deeply nested complex values.	x-3842-2
We now indicate how the use of objects and methods is incorporated into the language.	x-3842-3
It is interesting to note that methods and nested complex values are elegantly combined in this language, which has the appearance of SQL but is essentially based on the functional programming paradigm.	x-3842-4
For this example, we again assume the complex value Films of Fig.	x-3843-1
20.2, but we assume that Age is a method defined for the class Person (and thus for Director).	x-3843-2
select tuple (f.Director, f.Director.Age) from f in Films where f.Director not in flatten select m.Actors from g in Films, m in g.Movies where g.Director = “Hitchcock”	x-3844-1
Languages for Methods So far, we have used an abstraction of methods (their signature) and ignored their implementations.	x-3845-1
In this section, we present two abstract programming languages for specifying method implementations.	x-3845-2
Method implementations will be included in the specification of methods in OODB schemas.	x-3845-3
In studying these languages, we emphasize two important issues: type safety and expressive power.	x-3845-4
This focus largely motivates our choice of languages and the particular abstractions considered.	x-3845-5
The first language is an imperative programming language.	x-3846-1
The second, method schemas, is representative of a functional style of database access.	x-3846-2
In the first language, we will gather a number of features present in practical object-oriented database languages (e.g., side-effect, iteration, conditionals).	x-3846-3
We will see that with these features, we get (as could be expected) completeness, and we pay the obvious price for it: the undecidability of many questions, such as type safety.	x-3846-4
With method schemas, we focus on the essence of inheritance and methods.	x-3846-5
We voluntarily consider a limited language.	x-3846-6
We see that the undecidability of type safety is a consequence of recursion in method calls.	x-3846-7
(We obtain decidability in the restricted case of monadic methods.)	x-3846-8
With respect to expressiveness, we present a surprising characterization of qptime in terms of a simple language with methods.	x-3846-9
For both languages, we study type safety and expressive power.	x-3847-1
We begin by discussing briefly the meaning of these notions in our context, and then we present the two languages and the results.	x-3847-2
To evaluate the expressive power of OODB schemas using a particular language for method implementation, a common approach is to simulate relational queries and then ask what family of relational queries can be simulated.	x-3848-1
If OID creation is permitted, then all computable relational queries can be simulated using the imperative language.	x-3848-2
The expressive power of imperative methods without OID creation depends on the complex types permitted in OODB schemas.	x-3848-3
We also present a result for the expressive power of method schemas, showing that the family of method schemas using an ordered domain of atomic elements expresses exactly qptime.	x-3848-4
To consider the issue of type safety in a general context, we present the imperative (OODB) model, which incorporates imperative method implementations.	x-3849-1
This model simplifies the OODB model presented earlier by assuming that the type of each class is a tuple of values and OIDs.	x-3849-2
However, a schema in this model will include an assignment of implementations to method signatures.	x-3849-3
Object Databases The syntax for method implementations is par: u1, .	x-3850-1
.	x-3850-2
.	x-3850-3
, un; var: x1, .	x-3850-4
.	x-3850-5
.	x-3850-6
, xl; body: s1; .	x-3850-7
.	x-3850-8
.	x-3850-9
; sq; return x1 where the ui’s are parameters (n ≥ 1), the xj ’s are internal variables (l ≥ 1), and for each p ∈ [1, q], sp is a statement of one of the following forms (where w, y, z range over parameters and internal variables): Basic operations	x-3850-10
Class operations	x-3851-1
t t having forms from this list.	x-3852-1
Conditional	x-3853-1
It is assumed that all internal variables are initialized before used to some default value depending on their type.	x-3854-1
The intended semantics for the forms other than (viii) should be clear.	x-3854-2
(Here clear does not mean “easy to implement.” In particular, object deletion is complex because all references to this object have to be deleted.)	x-3854-3
The looping construct executes for each element of the extension (not disjoint extension) of class c. The execution of the loop is viewed as nondeterministic, in the sense that the particular ordering used for the elements of c is not guaranteed by the implementation.	x-3854-4
In general, we focus on OODB schemas in which different orders of execution of the loops yield OID-equivalent results (note, however, that this property is undecidable, so it must be ensured by the programmer).	x-3854-5
is an assignment of implementations to signatures.	x-3855-1
The notion of instance for this model is defined in the natural fashion.	x-3855-2
It is straightforward to develop operational semantics for this model, where the execution of a given method call might be successful, nonterminating, or aborted (as the result of a runtime type error) (Exercise 21.15a).	x-3856-1
Type Safety in the Imperative Model There are two ways that a runtime type error can	x-3857-1
Given a Turing machine M, it is easy to develop a schema S in this model that can simulate the operation of M on a suitable encoding of an input tape (Exercise 21.15c).	x-3858-1
This shows that such schemas are computationally powerful and implies the usual undecidability results.	x-3858-2
With regard to type safety, it is easy to verify the following (Exercise 21.16): Proposition 21.4.1 It is undecidable, given an imperative schema S, whether S is type safe.	x-3858-3
This remains true, even if in method implementations conditional statements and the new operator are prohibited and all methods are monadic (i.e., have only one argument).	x-3858-4
Reachability is also undecidable for imperative schemas.	x-3859-1
Expressive Power of the Imperative Model v ∈ I(Ri) there is exactly one object o in the extension of ci such that the value associated with o is *v and all other classes of S are empty.	x-3860-1
Following this spirit, it is straightforward to define what it means for a method call in schema S to simulate a relational query from R to relation schema R.	x-3860-2
We consider only schema S for which different orders of evaluation of the looping construct yield the same final result (i.e., generic mappings).	x-3861-1
We now have the following (see Exercise 21.20): Theorem 21.4.2 The family of generic queries corresponding to imperative schemas coincides with the family of all relational queries.	x-3861-2
The preceding result relies on the presence of the new operator.	x-3862-1
It is natural to ask about the expressive power of imperative schemas that do not support new.	x-3862-2
As discussed in Exercise 21.21, the expressive power depends on the complex types permitted for objects.	x-3862-3
Object Databases Note also that imperative schemas can express all determinate queries.	x-3863-1
This uses the nondeterminism of the for each construct.	x-3863-2
Naturally, nondeterministic queries that are not determinate can also be expressed.	x-3863-3
Method Schemas We now present an abstract model for side-effect-free methods, called method schemas.	x-3864-1
In this model, we focus almost exclusively on methods and their implementations.	x-3865-1
Two kinds of methods are distinguished: base and composite.	x-3865-2
The base methods do not have implementations: Their semantics is specified explicitly at the instance level.	x-3865-3
The implementations of composite methods consist of a composition of other methods.	x-3865-4
We now introduce method schemas.	x-3866-1
In the next definition, we make the simplifying assumption that there are no named values (only class names) in database schemas.	x-3866-2
In fact, data is only stored in base methods.	x-3866-3
In the following, σ[ ] denotes the type assignment σ[ ](c) = [ ] for every class c. Because the type assignment provides no information in method schemas (it is always σ[ ]), this assignment is not explicitly specified in the schemas.	x-3866-4
Definition 21.4.3	x-3867-1
The semantics of methods is defined in the obvious way.	x-3868-1
For instance, to compute m(o, o′), one computes first o1 = m2(o) and then o2 = m1(o, o′); the result is m1(o1, o2).	x-3868-2
The range of composite methods is left unspecified (it is any) because it is determined by the domain and the method implementation as a composition of methods.	x-3868-3
Because the range of composite methods is always any, we will sometimes only specify their domain.	x-3868-4
Let S = (C, ≺, M base, M comp, µ) be a method schema.	x-3869-1
An instance of S is a pair I = (π, ν), where π is an OID assignment for (C, ≺) and where ν assigns a semantics to the base methods.	x-3869-2
Note the difference from the imperative schemas of the previous section, where π together with the method implementations was sufficient to determine the semantics of methods.	x-3869-3
In contrast, the semantics of the base methods must be specified in instances of method schemas.	x-3869-4
Inheritance of method implementations for method schemas is defined slightly differently from that for the OODB model given earlier.	x-3870-1
Specifically, given an n-ary method m and invocation m(o1, .	x-3870-2
.	x-3870-3
.	x-3870-4
, on), where oi is in disjoint class ci for i ∈ [1, n], the implementation for m is inherited from the implementation of signature m : c′ , .	x-3870-5
.	x-3870-6
.	x-3870-7
, c′ → c′, where this 1 n is the unique signature that is pointwise least above c1, .	x-3870-8
.	x-3870-9
.	x-3870-10
, cn.	x-3870-11
[Otherwise m is undefined on input (o1, .	x-3870-12
.	x-3870-13
.	x-3870-14
, on).]	x-3870-15
Example 21.4.4 Consider the following monadic method schema.	x-3871-1
The classes in the schema are class c class c′ ≺ c The base method signatures are method m1 : c → c′ method m2 : c → c method m2 : c′ → c′ method m3 : c′ → c The composite method definitions are method m : c = m2(m2(m1(x))) method m′ : c = m3(m′(m2(x))) method m′ : c′ = m1(x) Note that m′ is recursive and that calls to m′ on elements in c′ break the recursion.	x-3871-2
Type Safety for Method Schemas	x-3872-1
The following example demonstrates that the schema of Example 21.4.4 is not type safe.	x-3873-1
Note how the interpretation ν for base methods can be viewed as an assignment of values for objects.	x-3873-2
Example 21.4.5 Recall the method schema of Example 21.4.4.	x-3874-1
An instance of this is I = (π, ν), where7	x-3874-2
Object Databases	x-3875-1
Consider the execution of m(p).	x-3876-1
This calls for the computation of m2(m2(m1(p))) = m2(m2(r)) = r. Thus the execution is successful.	x-3876-2
On the other hand, m′(p) leads to a runtime type error: m′(p) = m3(m′(m2(p))) = m3(m′(q)) = m3(m3(m′(m2(q)))) = m3(m3(m′(r))) = m3(m3(m1(r))) = m3(m3(r)) = m3(p), which is undefined and raises a runtime type error.	x-3876-3
Thus the schema is not type safe.	x-3876-4
It turns out that type safety of method schemas permitting polyadic methods is undecidable (Exercise 21.19).	x-3877-1
Interestingly, type safety is decidable for monadic method schemas.	x-3877-2
We now sketch the proof of this result.	x-3877-3
Theorem 21.4.6 It is decidable in polynomial time whether a monadic method schema is type safe.	x-3878-1
Crux Let S = (C, ≺, M base, M comp, µ) be a monadic method schema.	x-3879-1
We construct a context-free grammar (see Chapter 2) that captures possible executions of a method call over all instances of S. The grammar is GS = (Vn, Vt, A, P ), where the set Vt of terminals is the set of base method names (denoted N base) along with the symbols { error, ignore}, and the set Vn of nonterminals includes start symbol A and The set P of production rules includes	x-3879-2
c2, and c′ ≺ c2.	x-3880-1
(Note that c′ = c2 is just a particular case.)	x-3880-2
Given a successful execution of a method call m(o), it is easy to construct a word in L(GS) of the form m1 .	x-3881-1
.	x-3881-2
.	x-3881-3
mn, where the mi’s list the sequence of base methods called during the execution.	x-3881-4
On the other hand, if the execution of m(o) leads to a runtime error, a word of the form m1 .	x-3881-5
.	x-3881-6
.	x-3881-7
mi error .	x-3881-8
.	x-3881-9
.	x-3881-10
can be formed.	x-3881-11
The terminal ignore can be used in cases where	x-3881-12
It can be shown that S is type safe iff L(GS) ∩ N ∗ error V ∗ = ∅.	x-3882-1
base t Because it can be tested if the intersection of a context-free language with a regular language is empty, the preceding provides an algorithm for checking type safety.	x-3883-1
However, a modification of the grammar GS is needed to obtain the polynomial time test (see Exercise 21.18).	x-3883-2
Expressive Power of Method Schemas We now argue that method schemas (with or- der) simulate precisely the relational queries in qptime.	x-3884-1
The object-oriented features are not central here: The same result can be shown for functional data models without such features.	x-3884-2
Next we represent queries by composite methods.	x-3885-1
A query q is computed by method mq if mq(t) is true (not in zero) iff t is in the answer to query q.	x-3885-2
The following illustrates how to compute with this simple language.	x-3886-1
Example 21.4.7 Consider relation R with R = {R(1, 1), R(1, 2)}.	x-3887-1
The class zero is populated with the object 0 and the class elem with 1, 2.	x-3887-2
The base method pred is defined by pred(2) = 1, pred(0) = pred(1) = 0.	x-3887-3
The base method mR is defined by mR(1, 1) = mR(1, 2) = 1 and mR(x, y) = 0 otherwise.	x-3887-4
Object Databases Recall that each object in class elem is viewed as true and object 0 as false.	x-3888-1
We can code the Boolean function and as follows: for x, y in for x, y in elem, zero for x, y in for x, y in elem, elem	x-3888-2
The other standard Boolean functions can be coded similarly.	x-3889-1
We can code the intersection between two binary relations R and S with and(mR(x, y), mS(x, y)).	x-3889-2
As a last example, the projection of a binary relation R over the first coordinate can be coded by a method πR,1 defined by where m is given by for x, y in elem, zero m(x, y) ≡ mR(x, y) for x, y in elem, elem m(x, y) ≡ or(mR(x, y), m(x, pred(y))).	x-3889-3
We now state the following: Theorem 21.4.8 Method schemas over ordered databases express exactly qptime.	x-3890-1
Crux lexicographical ordering) of u.	x-3891-1
Indeed, we can simulate an arbitrary relational operation and more generally an arbitrary inflationary fixpoint.	x-3891-2
To see this, consider the transitive closure query.	x-3891-3
It is computed with a method tc defined (informally) as follows.	x-3891-4
Intuitively, a method tc(x, y) asks, “Is x, y in the transitive closure?” Execution of tc(x, y) first calls a method m1(x, y, N), whose intuitive meaning is “Is there a path of length N from x to y?” This will be computed by asking whether there is a path of length N − 1 (a recursive call to m1), etc.	x-3891-5
This can be generalized to a construction that simulates an arbitrary inflationary fixpoint query.	x-3891-6
Because the underlying domain is ordered, we have captured all qptime queries.	x-3891-7
The converse follows from the fact that there are only polynomially many possible method calls in the context of a given instance, and each method call in this model can be answered in qptime.	x-3891-8
Moreover, loops in method calls can be detected in polynomial time; calls giving rise to loops are assumed to output some designated special value.	x-3891-9
(See Exercise 21.25.)	x-3891-10
We have presented an object-oriented approach in the applicative programming style.	x-3892-1
There exists another important family of functional languages based on typed λ calculi.	x-3893-1
It is possible to consider database languages in this family as well.	x-3894-1
These calculi present	x-3894-2
Further Issues for OODBs	x-3895-1
This is not an exhaustive list of new features but a sample of some that are being studied: Views: Views are intended to increase the flexibility of database systems, and it is natural to extend the notion of relational view to the OODB framework.	x-3896-1
However, unlike relational views, OODB views might redefine the behavior of objects in addition to restructuring their associated types.	x-3896-2
There are also significant issues raised by the presence of OIDs.	x-3896-3
For example, to maintain incrementally a materialized view with created OIDs, the linkage between the base data and the created OIDs must be maintained.	x-3896-4
Furthermore, if the view is virtual, then how should virtual OIDs be specified and manipulated?	x-3897-1
Object roles: The same entity may be involved in several roles.	x-3898-1
For instance, a director may also be an actor.	x-3898-2
It is costly, if not infeasible, to forecast all cases in which this may happen.	x-3898-3
Although not as important in object-oriented programming, in OODBs it would be useful to permit the same object to live in several classes (a departure from the disjoint OID assignment from which we started) and at least conceptually maintain distinct repositories, one for each role.	x-3898-4
This feature is present in some semantic data models; in the object-oriented context, it raises a number of interesting typing issues.	x-3898-5
Schema design: Schema design techniques (e.g., based on dependencies and normal forms) have emerged for the relational model (see Chapter 11).	x-3899-1
Although the richer model in the OODB provides greater flexibility in selecting a schema, there is a concomitant need for richer tools to facilitate schema design.	x-3899-2
The scope of schema design is en-larged in the OODB context because of the interaction of methods within a schema and application software for the schema.	x-3899-3
Querying the schema: In many cases, information may be hidden in an OODB schema.	x-3900-1
Suppose, for example, that movies were assigned categories such as “drama,” “west-ern,” “suspense,” etc.	x-3901-1
In the relational model, this information would typically be represented using a new column in the Movies relation.	x-3901-2
A query such as “list all categories of movie that Bergman directed” is easily answered.	x-3901-3
In an OODB, the category information might be represented using different subclasses of the Movie class.	x-3901-4
Answering this query now requires the ability of the query language to return class names, a feature not present in most current systems.	x-3901-5
Object Databases Classification: A related problem concerns how, given an OODB schema, to classify new data for this schema.	x-3902-1
This may arise when constructing a view, when merging two databases, or when transforming a relational database into an OODB one by objectifying tuples.	x-3902-2
The issue of classification, also called taxonomic reasoning, has a long history in the field of knowledge representation in artificial intelligence, and some research in this direction has been performed for semantic and object-oriented databases.	x-3902-3
Incorporating deductive capabilities: The logic-programming paradigm has offered a tremendous enhancement of the relational model by providing an elegant and (in many cases) intuitively appealing framework for expressing a broad family of queries.	x-3903-1
For the past several years, researchers have been developing hybrids of the logic-programming and object-oriented paradigms.	x-3904-1
Although it is very different in some ways (because the OO paradigm has fundamentally imperative aspects), the perspective of logic programming provides alternative approaches to data access and object creation.	x-3904-2
Dynamic Issues The semantics of updates in relational systems is simple: Perform the update if the result complies with the dependencies of the schema.	x-3905-1
In an OODB, the issue is somewhat trickier.	x-3905-2
For instance, can we allow the deletion of an object if this object is referred to somewhere in the database (the dangling reference problem)?	x-3906-1
This is prohibited in some systems, whereas other systems will accept the deletion and just mark the object as dead.	x-3906-2
Semantically, this results in viewing all references to this object as nil.	x-3906-3
For example, how do we treat a reference to the manager of a department (that should be of type Employee) when he or she leaves the company and is turned into a “normal” person?	x-3907-1
Finally, as with the relational model, we need to consider evolution of the schema itself.	x-3908-1
The OODB context is much richer than the relational, because there are many more kinds of changes to consider: the class hierarchy, the type of a class, additions or deletions of methods, etc.	x-3908-2
Bibliographic Notes Bibliographic Notes Collections of papers on object-oriented databases can be found in [BDK92, KL89, ZM90].	x-3909-1
The main characteristics of object-oriented database systems are described in [ABD+89].	x-3910-1
Object-oriented databases are, of course, closely related to object-oriented programming languages.	x-3911-1
The first of these is Smalltalk [GR83], and C++ [Str91] is fast becoming the most widely used object-oriented programming language.	x-3911-2
Several commercial OODBs are essentially persistent versions of C++.	x-3911-3
Several object-oriented extensions of Lisp have been proposed; the article [B+86] introduces a rich extension called CommonLoops and surveys several others.	x-3911-4
There have been a number of approaches to provide a formal foundation [AK89, Bee90, HTY89, KLW93] for OODBs.	x-3912-1
We can also cite as precursors attempts to formalize semantic data models [AH87] and object-based models [KV84, HY84].	x-3912-2
Recent graph-oriented models, although they do not stress object orientation, are similar in spirit (e.g.,	x-3912-3
The generic OODB model used here is directly inspired from the IQL model [AK89]	x-3913-1
OIDs have been part of many data models.	x-3914-1
For example, they are called surrogates in	x-3914-2
Since [KV84], various languages for models with objects have been proposed in the various paradigms: calculus, algebra, rule based, or functional.	x-3915-1
Besides standard features found in database languages without objects, the new primitives are centered around object creation.	x-3915-2
Language-theoretic issues related to object creation were first considered in the context of IQL [AK89].	x-3915-3
Object creation is an essential component of IQL and is the main reason for the completeness of the language.	x-3915-4
The need for a primitive in the style of copy elimination to obtain determinate completeness was first noticed in [AK89].	x-3915-5
The IQL language is rule based with an inflationary fixpoint semantics in the style of datalog¬ of Chapter 14.	x-3915-6
The logic-based perspective on object creation based on Skolem was first informally discussed in [Mai86] and refined variously in [CW89a, HY90, KLW93, KW89].	x-3916-1
In particular, F-logic [KLW93] considers a different approach to inheritance.	x-3916-2
In our framework, the classification of objects is explicit; in particular, when an object is created, it is within an explicit class.	x-3916-3
In [KLW93], data organization is also specified by rules and thus may depend on the properties of the objects involved.	x-3916-4
For instance, reasoning about the hierarchy becomes part of the program.	x-3916-5
Object Databases Since then, object creation has been the center of much interesting research (e.g., [DV93, HS89b, HY92, VandBG92, VandBGAG92, VandB93]).	x-3917-1
The characterization of queries expressible in whileobj (Theorem 21.3.2) is from [VandBG92]; this extends a previous result from [AP92].	x-3917-2
The proof of Proposition 21.3.3 is also from [VandBGAG92].	x-3917-3
In [VandBGAG92, VandB93], it is argued that the notion of determinate query may not be the most appropriate one for the object-based context, and alternative notions, such as semide-terministic queries, are discussed.	x-3917-4
A tractable construct yielding a determinate-complete language is exhibited in [DV93].	x-3917-5
However, the construct proposed there is global in nature and is involved.	x-3917-6
The search for simpler and more natural local constructs continues.	x-3917-7
In particular, as indicated in Section 21.3, O2SQL [BCD89] retains the flavor of SQL but incorporates object orientation by adopting an elegant functional programming style.	x-3918-1
This approach has been advanced as a standard in [Cat94].	x-3918-2
Functional approaches to databases have been considered rather early but attracted only modest interest in the past [BFN82, Shi81].	x-3919-1
The functional approach has become more popular recently, both because of the success of object-oriented databases and due to recent results of complex objects and types emphasizing the functional models [BTBN92, BTBW92].	x-3919-2
The use of a typed functional language similar to λ calculus as a formalism to express queries is adapted from [HKM93].	x-3919-3
Characterizations of qptime in functional terms are from [HKM93, LM93].	x-3919-4
The work in [AKRW92, HKM93, HKR93] provides interesting bridges between (object-oriented) databases and well-developed themes in computer science: applicative program schemas [Cou90, Gre75] and typed λ calculi [Chu41, Bar84, Bar63].	x-3919-5
This chapter presented both imperative and functional perspectives on OODB methods.	x-3920-1
A different approach (based on rules and datalog with negation) has been used in	x-3920-2
Views for OODBs are considered in [AB91, Day89, HY90, KKS92, KLW93].	x-3921-1
The merging of OODBs is considered in [WHW90].	x-3921-2
Incremental maintenance of materialized object-oriented views is considered in [Cha94].	x-3921-3
The notion of object roles, or sharing objects between classes, is found in some semantic data models [AH87, HK87] and in recent research on OODBs [ABGO93, RS91].	x-3921-4
A query language that incorporates access to an OODB schema is presented in [KKS92].	x-3921-5
Classification has been central to the field of knowledge representation in artificial intelligence, based on the central notion of taxonomic reasoning (e.g., see [BGL85, MB92], which stem from the KL-ONE framework of	x-3921-6
Exercises Exercises Exercise 21.1 Construct an instance for the schema of Fig.	x-3922-1
21.1 that corresponds to the CINEMA instance of Chapter 3.	x-3922-2
Exercise 21.2 Suppose that the class Actor_Director were removed from the schema of Fig.	x-3923-1
21.1.	x-3923-2
Verify that in this case there is no OID assignment for the schema such that there is an actor who is also a director.	x-3923-3
Exercise 21.3 Design an OODB schema for a bibliography database with articles, book chapters, etc.	x-3924-1
Use inheritance where possible.	x-3924-2
Exercise 21.4 Exhibit a class hierarchy that is not well formed.	x-3925-1
Exercise 21.5	x-3926-1
Exercise 21.6 Show that testing whether I ≡ OID J is in np and at least at hard as the graph isomorphism problem (i.e., testing whether two graphs are isomorphic).	x-3927-1
Exercise 21.7 Give an algorithm for testing value equality.	x-3928-1
What is the data complexity of your algorithm?	x-3928-2
Exercise 21.8 In this exercise, we consider various forms of equality.	x-3929-1
Value equality as discussed in the text is denoted =1.	x-3929-2
Two objects o, o′ are 2-value equal, denoted o =2 o′, if replacing each object in ν(o) and ν(o′) by its value yields values that are equal.	x-3929-3
The relations =i for each i are defined similarly.	x-3929-4
Show that for each i, =i+1 refines =i.	x-3929-5
Let n be a positive integer.	x-3929-6
Give a schema and an instance over this schema such that for each i in [1, n], =i and =i+1 are different.	x-3930-1
Exercise 21.9 Design a database schema to represent information about persons, including males and females with names and husbands and wives.	x-3931-1
Exhibit a cyclic instance of the schema and an object o that has an infinite expansion.	x-3931-2
Describe the infinite tree representing the expansion of o.	x-3931-3
Exercise 21.11 In this exercise, we consider the schema S with a single class c that has type σ (c) = [A : c, B : string].	x-3932-1
Exhibit an instance I over S and two distinct objects in I that have the same expansion.	x-3932-2
Exhibit two distinct instances over S with the same set of object expansions.	x-3932-3
Exercise 21.12 Sketch an extension of the complex value algebra to provide an algebraic simulation of the calculus of Section 21.3.	x-3933-1
Give algebraic versions of the queries of that section.	x-3933-2
T (f1(x, y), x) ← S(x, y) T (f3(x, y), x) ← S(x, y) T (f2(x, y), x) ← S(x, y) T (f3(y, x), x) ← S(x, y) T (f1(x, y), y) ← S(x, y), S(y, x) T (f4(x, y), x) ← S(x, y), S(y, x) P Q Object Databases P2(J).	x-3934-1
Show that P ∼ exp Q does not hold.	x-3934-2
Show that P ∼ obs Q.	x-3935-1
invention if in each target relation at most one column can include nonatomic Skolem terms (OID).	x-3936-1
Give a decision procedure for testing whether two such programs are obscured equivalent.	x-3936-2
(Decidability of obscured equivalence of arbitrary nonrecursive datalog programs with Skolem terms in rule heads remains open.)	x-3936-3
Exercise 21.15	x-3937-1
Hint: Use a class c with associated type tuple(a : c, .	x-3938-1
.	x-3938-2
.	x-3938-3
), and let c′ ≺ c. Construct the implementation of method m on c so that on input o if the loop is to continue, then it creates a new object o′ in c, sets o.a = o′, and calls m on o′.	x-3938-4
To terminate the loop, create o′ in c′, and define m on c′ appropriately.	x-3938-5
Exercise 21.16 Prove Proposition 21.4.1.	x-3939-1
Hint: Use a reduction from the PCP problem, similar in spirit to the one used in the proof of Theorem 6.3.1.	x-3939-2
The effect of conditionals can be simulated by putting objects in different classes and using dynamic binding.	x-3939-3
Exercise 21.17 Describe how monadic method schemas can be simulated in the imperative model.	x-3940-1
Exercise 21.18	x-3941-1
Exercises	x-3942-1
Exercise 21.19	x-3943-1
Exercise 21.20	x-3944-1
Exercise 21.22	x-3945-1
is simulated?	x-3946-1
Exercise 21.23 Show how to encode or, not, and equal using method schemas.	x-3947-1
Exercise 21.24 Show how to encode pred i and the join operation using method schemas.	x-3948-1
k	x-3949-1
How come we’ve waited so long to talk about something so important?	x-3950-1
Riccardo: Talking about change is hard.	x-3951-1
Sergio: We’re only starting to get a grip on it.	x-3952-1
Vittorio:	x-3953-1
However, the persistence, size, and long life cycle of a database lead to perspectives somewhat different from those found in programming languages.	x-3954-1
In this chapter, we briefly examine some of these differences and sketch some of the directions that have been explored in this area.	x-3954-2
Although it is central to databases, this area has received far less attention from the theoretical research community than other topics addressed in this book.	x-3954-3
The discussion in this chapter is intended primarily to give an overview of the important issues raised concerning the dynamic aspects of databases.	x-3955-1
It therefore emphasizes examples and intuitions much more than results and proofs.	x-3955-2
This chapter begins by examining database update languages, including a simple language that corresponds to the update capabilities of practical languages such as SQL, and more complex ones expressed within a logic-based framework.	x-3956-1
Next optimization and semantic properties of transactions built from simple update commands are considered, including a discussion of the interaction of transactions and static integrity constraints.	x-3956-2
The impact of updates in richer contexts is then considered.	x-3957-1
In connection with views, we examine the issue of how to propagate updates incrementally from base data to views and the much more challenging issue of propagating an update on a view back to the base data.	x-3957-2
Next updates for incomplete information databases are considered.	x-3957-3
This includes both the conditional tables studied in Chapter 19 and more general frameworks in which databases are represented using logical theories.	x-3957-4
The emerging field of active databases is then briefly presented.	x-3958-1
These incorporate mechanisms for automatically responding to changes in the environment or the database, and they often use a rule-based paradigm of specifying the responses.	x-3958-2
This chapter concludes with a brief discussion of temporal databases, which support the explicit representation of the time dimension and thus historical information.	x-3959-1
Dynamic Aspects Update Languages Before embarking on a brief excursion into update languages, we should answer the following natural question: Why are update languages necessary?	x-3960-1
Could we not use query languages to specify updates?	x-3960-2
The difference between query and update languages is subtle but important.	x-3961-1
To specify an update, we could indeed define the new database as the answer to a query posed against the old database.	x-3961-2
However, this misses an essential characteristic of updates: Most often, they involve small changes to the current database.	x-3961-3
Query languages are not naturally suited to speak explicitly about change.	x-3961-4
In contrast, update languages use as building blocks simple statements expressing change, such as insertions, deletions, and modifications of tuples in the database.	x-3961-5
In this section, we outline several formal update languages and point to some theoretical issues that arise in this context.	x-3962-1
Insert-Delete-Modify Transactions We begin with a simple procedural language to specify insertions, deletions, and modifications.	x-3963-1
Most commercial relational systems provide at least these update capabilities.	x-3963-2
To simplify the presentation, we suppose that the database consists of a single relation schema R. Everything can be extended to the multirelational case.	x-3964-1
An insertion is an expression ins(t), where t is a tuple over att(R).	x-3964-2
This inserts the tuple t into R. [We assume set-based semantics, under which ins(t) has no effect if t is already present in R.] A deletion removes from R all tuples satisfying some stated set of conditions.	x-3964-3
More precisely, a condition is an (in)equality of the form A = c or A "= c, where A ∈ att(R) and c is a constant.	x-3964-4
A deletion is an expression del(C), where C is a finite set of conditions.	x-3964-5
This removes from R all tuples satisfying each condition in C. Finally, a modification is an expression mod(C → C′), where C, C′ are sets of conditions, with C′ containing only equalities A = c. This selects all tuples in R satisfying C and then, for each such tuple and each A = c in C′, sets the value of A to c. An update over R is an insertion, deletion, or modification over R. An IDM transaction (for insert, delete, modify) over R is a finite sequence of updates over R. This is illustrated next.	x-3965-1
Example 22.1.1 Consider the relation schema Employee with attributes N (Name), D del({D = parts, R = manager}); mod({D = sales, R = manager} → {D = parts}); ins( Moe, sales, manager) The same update can be expressed in SQL as follows: delete from Employee where D = “parts” and R = “manager”; update Employee set D = “parts” where D = “sales” and R = “manager”; insert into Employee values “Moe”,“sales”,“manager” mod(C → C′); del(C′) ins(t ); mod(C → C′) where t satisfies C and {t′} = mod(C → C′)({t}) del(C3); mod(C1 → C3); mod(C2 → C1); mod(C3 → C2)	x-3966-1
We can define criteria for the optimization of IDM transactions along two main lines: Syntactic: We can take into account the length of the transaction as well as the kind of operations involved (for example, it may be reasonable to assume that insertions are simpler than modifications).	x-3967-1
Semantic: This can be based on the number of tuple operations actually performed when the transaction is applied.	x-3968-1
Various definitions are possible based on the preceeding criteria.	x-3969-1
It can be shown that there exists a polynomial-time algorithm that optimizes IDM transactions, with respect to a reasonable definition based on syntactic and semantic criteria.	x-3969-2
The syntactic criteria involve the number of insertions, deletions, and modifications.	x-3969-3
The semantic criteria are based on the number of tuples touched at runtime by the transaction.	x-3969-4
We omit the details here.	x-3969-5
Example 22.1.2 Consider the IDM transaction over a relational schema R of sort AB: mod({A "= 0, B = 1} → {B = 2}); ins(0, 1); ins(3, 2); mod({A = 0, B = 1} → {B = 2}); mod({A "= 0, B = 0} → {B = 1}); mod({A = 0, B = 0} → {B = 1}); mod({A "= 0, B = 2} → {B = 0}); mod({A = 0, B = 2} → {B = 0}); del({A "= 0, B = 0}).	x-3970-1
Dynamic Aspects del({A "= 0, B = 1}); del({A "= 0, B = 2}); mod({A = 0, B = 1} → {B = 2}); mod({B = 0} → {B = 1}); mod({A = 0, B = 2} → {B = 0}); ins(0, 0).	x-3971-1
Thus the six modifications, one deletion, and two insertions of the original transaction were replaced by three modifications, two deletions, and one insertion.	x-3972-1
mod(C → C′); del(C′) ⇒ del(C); del(C′).	x-3973-1
It can be shown that such a set of simplification rules can be used to optimize a restricted set of IDM transactions that satisfy a syntactic acyclicity condition.	x-3974-1
For the other transactions, applications of the simplification rules yield a simpler, but not necessarily optimal, transaction.	x-3974-2
The simplification rules have the advantage that they are local and can be easily applied even online, whereas the complete optimization algorithm is global and has to know the entire transaction in advance.	x-3974-3
Rule-Based Update Languages The IDM transactions provide a simple update language of limited power.	x-3975-1
This can be extended in many ways.	x-3975-2
One possibility is to build another procedural language based on tuple insertions, deletions, and modifications, which includes relation variables and an iterative construct.	x-3975-3
Another, which we illustrate next, is to use a rule-based approach.	x-3975-4
For example, consider the language datalog¬¬ described in Chapter 17, with its fixpoint semantics.	x-3976-1
Recall that rules allow for both positive and negative atoms in heads of rules; consistently with the fixpoint semantics, the positive atoms can be viewed as insertions of facts and the negative atoms as deletions of facts.	x-3976-2
For example, the following program removes all cycles of length one or two from the graph G:	x-3976-3
In the usual fixpoint semantics, rules are fired in parallel with all possible instantiations for the variables.	x-3977-1
This yields a deterministic semantics.	x-3977-2
Some practical rule-based update languages take an alternative approach, which yields a nondeterministic semantics: The rules are fired one instantiation at a time.	x-3977-3
With this semantics, the preceeding program provides some orientation of the graph G. Note that generally there is no way to obtain an orientation of a graph deterministically, because a nondeterministic choice of edges to be removed may be needed.	x-3977-4
in Chapter 18.	x-3978-1
This can be done in the manner described in Exercise 18.22.	x-3978-2
The same language with nondeterministic semantics can be shown to express all nondeterministic updates.	x-3978-3
The aforementioned languages yield a bottom-up evaluation procedure.	x-3979-1
The body of the rule is first checked, and then the actions in the head are executed.	x-3979-2
Another possibility is to adopt a top-down approach, in the spirit of the assert in Prolog.	x-3979-3
Here the actions to be taken are specified in rule bodies.	x-3979-4
A good example of this approach is provided by Dynamic Logic Programming (DLP).	x-3979-5
Interestingly, this language allows us to test hypothetical conditions of the form “Would ϕ hold if t was inserted?” This, and the connection of DLP with Prolog, is illustrated next.	x-3979-6
Example 22.1.3 Consider a database schema with relations ES of sort Emp,Sal (employees and their salaries), ED of sort Emp,Dep (employees and their departments), and DA of sort Dep,Avg (average salary in each department).	x-3980-1
Suppose that an update is intended to hire John in the toys department with a salary of 200K, under the condition that the average salary of the department stays below 50K.	x-3981-1
In the language DLP, this update is expressed by hire( emp 1, sal 1, dep 1) ←	x-3981-2
Testing a condition under the assumption of an update is a form of hypothetical reasoning.	x-3982-1
It is interesting to contrast the semantics of DLP with that of Prolog.	x-3983-1
Consider the following Prolog program:	x-3983-2
In this program, the insertions into ES and ED will be performed even if the conditions are not satisfied afterward.	x-3984-1
(The reader familiar with Prolog is encouraged to write a program that has the desired semantics.)	x-3984-2
Updates concern not only instances of a fixed schema.	x-3985-1
Sometimes the schema itself needs to be changed (e.g., by adding an attribute).	x-3985-2
Some practical update languages include constructs for schema change.	x-3985-3
The main problem to be resolved is how the existing data can be fit to the new schema.	x-3985-4
In deductive databases, some relations are defined using rules.	x-3986-1
Occasionally these definitions may have to be changed, leading to updates of the “rule base.” There are languages that can be used to specify such updates.	x-3986-2
Dynamic Aspects Transactional Schemas Typically, database systems restrict the kinds of updates that users can perform.	x-3987-1
There are three main ways of doing this:	x-3987-2
Object-oriented databases essentially embrace option (b); updates are performed only by methods specified at the schema level, and it is assumed that these will not violate the constraints (see Chapter 21).	x-3988-1
Both options (a) and (b) are present in the relational model.	x-3988-2
Several commercial systems can recognize and abort on violation of simple constraints (typically key and simple inclusion dependencies).	x-3989-1
However, maintenance of more complex constraints is left to the application software.	x-3989-2
Option (c) is supported by the emerging field of active databases, which is discussed in the following section.	x-3989-3
We now briefly explore some issues related to approach (b) in connection with the relational model.	x-3990-1
To illustrate the issues, we use simple procedures based on IDM transactions.	x-3990-2
The procedures we use are parameterized IDM transactions, obtained by allowing variables in addition to constants in conditions of IDM transactions.	x-3990-3
The variables are used as parameters.	x-3990-4
A database schema R together with a finite set of parameterized IDM transactions over R is called an IDM transactional schema.	x-3990-5
Example 22.2.1 Consider a database schema R with two relations, TA (Teaching Assis-tant) of sort Name, Course, and PHD (Ph.D. student) of sort Name, Address.	x-3991-1
The following IDM-parameterized transactions allow the hiring and firing of TAs (subscripts indicate the relation to which each update applies): hire( x, y, z) = delTA( Name = x); insTA(x, y) delPHD( Name = x); insPHD(x, z) fire( x) The pair T = R, { hire, fire} is an IDM transactional schema.	x-3991-2
Note in this simple example that once a name n is incorporated into the PHD relation, it can never be removed.	x-3991-3
Clearly, we could similarly define transactional schemas in conjunction with any update language.	x-3992-1
Suppose T is an IDM transactional schema.	x-3993-1
To apply the parameterized transactions, values must be supplied to the variables.	x-3993-2
A transaction obtained by replacing the variables of a parameterized transaction t in T by constants is a call to t. The only updates allowed by an IDM transactional schema are performed by calls to its parameterized transactions.	x-3993-3
The set of instances that can be generated by such calls (starting from the empty instance) is denoted Gen(T).	x-3994-1
Transactional schemas offer an approach for constraint enforcement, essentially by preventing updates that violate them.	x-3995-1
So it is important to understand to what extent they can do so.	x-3995-2
First we need to clarify the issue.	x-3995-3
Suppose T is an IDM transactional schema and is a set of constraints over a database schema R; Sat() denotes all instances over R satisfying .	x-3995-4
If T is to replace , we would expect the following properties to hold:	x-3995-5
Thus T is sound and complete with respect to iff it generates precisely the instances satisfying .	x-3996-1
Example 22.2.2 Consider again the IDM transactional schema T in Example 22.2.1.	x-3997-1
Let be the following constraints: TA : Name PHD : Name → Address TA[ Name] It is easily seen that T in Example 22.2.1 is sound and complete with respect to .	x-3997-2
That is, Gen(T) = Sat() (Exercise 22.7).	x-3997-3
This example also highlights a limitation in the notion of completeness: It can be seen that there are pairs I and J of instances in Sat() where I cannot be transformed into J using T. In other words, there are valid database states I and J such that when in state I, J is never reachable.	x-3998-1
Such forbidden transitions are also a means of enriching the model, because we can view them as temporal constraints on the database evolution.	x-3998-2
We will return to temporal constraints later in this chapter.	x-3998-3
Of course, the ability of transaction schemas to replace constraints depends on the update language used.	x-3999-1
For IDM transactional schemas, we can show the following (Exercise 22.8): Theorem 22.2.3 For each database schema R and set of fd’s and acyclic inclusion dependencies over R, there exists an IDM transactional schema T that is sound and complete with respect to .	x-3999-2
Thus IDM transactional schemas are capable of replacing a significant set of constraints.	x-4000-1
The kind of difficulty that arises with more general constraints is illustrated next.	x-4000-2
Example 22.2.4 Consider a relation R of sort ABC and the following set of constraints: Dynamic Aspects	x-4001-1
It is easy to check that, for each relation satisfying the constraints, the number of constants in the relation is a perfect square (n2, n ≥ 0).	x-4002-1
Thus there are unbounded gaps between instances in Sat().	x-4002-2
There is no IDM transactional schema T such that Sat() = Gen(T), because the gaps cannot be crossed using calls to parameterized transactions with a bounded number of parameters.	x-4002-3
Moreover, this problem is not specific to IDM transactional schemas; it arises with any language in which procedures can only introduce a bounded number of new constants into the database at each call.	x-4002-4
Updating Views and Deductive Databases We now turn to the impact of updates on views.	x-4003-1
Views are an important aspect of databases.	x-4003-2
The interplay between views and updates is intricate.	x-4004-1
We can mention in particular two important issues.	x-4004-2
One is the view maintenance problem: A view has been materialized and the problem is to maintain it incrementally when the database is updated.	x-4004-3
An important variation of this is in the context of deductive databases when the view consists of idb relations.	x-4004-4
The other is known as the view update problem: Given a view and an update against a view, the problem is to translate the update into a corresponding update against the base data.	x-4004-5
This section considers these two issues in turn.	x-4004-6
View Maintenance Suppose that a base schema B and view schema V are given along with a (total) view mapping f : Inst(B) → Inst(V).	x-4005-1
Suppose further that a materialized view is to be maintained	x-4005-2
For this discussion, an update for a schema R is considered to be a mapping from Inst(R) to Inst(R).	x-4006-1
If constraints are present, it is assumed that an update cannot map to instances violating the constraints.	x-4006-2
The updates considered here might be based on IDM transactions or might be more general.	x-4006-3
We shall often speak of “the” update µ that maps v I V I′ V f f I B I′ B Figure 22.1: Relationship of views and updates instance I to instance I′, and by this we shall mean the set of insertions and deletions that need to be made to I to obtain I′.	x-4006-4
Suppose that the base database B is holding IB and that update µ maps this to I′ (see B Fig.	x-4007-1
22.1).	x-4007-2
A naive way to keep the view up to date is to simply compute f (I′ ).	x-4007-3
However, B I′ is typically large relative to the difference between I B V and I′V for more efficient ways to find the update ν that maps IV to I′ = f (µ(I V B )).	x-4007-4
This is the view maintenance problem.	x-4007-5
There are generally two main components to solutions of the view maintenance problem.	x-4008-1
The first involves developing algorithms to test whether an update to the base data can affect the view.	x-4008-2
Given such an algorithm, an update is said to be irrelevant if the algorithm certifies that the update cannot affect the view, and it is said to be relevant otherwise.	x-4008-3
Example 22.3.1 Let the base database schema be B = (R[AB], S[BC]), and consider the following views: V1 = (R ⊲⊳ σC>50S) V2 = πAR V3 = R ⊲⊳ S V4 = πAC(R ⊲⊳ S).	x-4009-1
Inserting b, 20 into S cannot affect views V1 or V2.	x-4010-1
On the other hand, whether or not this insertion affects V3 or V4 depends on the data already present in the database.	x-4010-2
Various algorithms have been developed for determining relevance with varying degrees of precision.	x-4011-1
A useful technique involves maintaining auxiliary information, as illustrated next.	x-4011-2
Example 22.3.2 Recall view V2 of Example 22.3.1, and suppose that R currently holds Dynamic Aspects R B Deleting a, 20 has no impact on the view, whereas deleting a′, 80 has the effect of deleting a′ from the view.	x-4012-1
One way to monitor this is to maintain a count on the number of distinct ways that a value can arise; if this count ever reaches 0, then the value should be deleted from the view.	x-4012-2
The other main component of solutions to the view maintenance problem concerns the development of incremental evaluation algorithms.	x-4013-1
This is closely related to the seminaive algorithm for evaluating datalog programs (see Chapter 13).	x-4013-2
Example 22.3.3 Recall view V3 from Example 22.3.1, and let I+ and I+ denote sets R S of tuples that are to be inserted into R and S, respectively.	x-4014-1
It is easily verified that (R ∪ I+) ⊲⊳ (S ∪ I+) = (R ⊲⊳ S) ∪ (R ⊲⊳ I+) ∪ (I+ ⊲⊳ S) ∪ (I+ ⊲⊳ I+).	x-4014-2
R S S R R S Thus the new join can be found by performing three (typically smaller) joins followed by some unions.	x-4015-1
It is relatively straightforward to develop incremental evaluation expressions, such as in the preceeding example, for all of the relational algebra operators (see Exercise 22.13).	x-4016-1
In some cases, these expressions can be refined by using information about constraints, such as key and functional dependencies, on the base data.	x-4017-1
Incremental Update of Deductive Views The view maintenance problem has also been studied in connection with views constructed with (stratified) datalog(¬).	x-4018-1
In general, the techniques used are analogous to those discussed earlier but are generalized to incorporate recursion.	x-4018-2
In the context of stratified datalog¬, various heuristics have been adapted from the field of belief revision for incrementally maintaining supports (i.e., auxiliary information that holds the justifications for the presence of a fact in the materialized output of the program).	x-4018-3
Example 22.3.4 Consider a binary relation G[AB] and the usual datalog program P that computes the transitive closure of G in T [AB].	x-4019-1
Suppose that I is an instance of G, and J is P (I ).	x-4019-2
Suppose that tuple a, b is inserted into I .	x-4019-3
Then a tuple a′, b′ will be inserted into J iff one of the following occurs:	x-4019-4
The preceeding conditions can clearly be specified by a first-order query.	x-4020-1
It easily follows that P is FOID (see Exercise 22.21).	x-4020-2
Several variations of FOIDs have been studied.	x-4021-1
These include FOIDs with auxiliary relations (i.e., that permit the maintenance of derived relations not in the original datalog program) and FOIDs that support incremental updates for sets of insertions and/or deletions.	x-4021-2
FOIDs have been found for a number of restricted classes of datalog programs.	x-4021-3
However, it remains open whether there is a datalog program that is not FOID with auxiliary relations.	x-4022-1
Basic Issues in View Update The view update problem is essentially the inverse of the view maintenance problem.	x-4023-1
Referring again to Fig.	x-4024-1
22.1, the problem now is, Given IB, IV , and update ν on IV , find an update µ so that the diagram commutes.	x-4024-2
The first obvious problem here is the potential for ambiguity.	x-4025-1
Example 22.3.5 Recall the view V2 of Example 22.3.1.	x-4026-1
Suppose that the base value of R is {a, b} (and the base value of S is ∅).	x-4026-2
Thus the view holds {a}.	x-4026-3
Now consider an update ν to the view that inserts a′.	x-4026-4
Some possible choices for µ include (a) Insert a′, b into R.	x-4026-5
Possibility (d) seems undesirable, because it affects a tuple in a base relation that is, intuitively speaking, independent of the view update.	x-4027-1
Possibilities (a) and (b) seem more appealing than (c), but (c) cannot be ruled out.	x-4027-2
In any case, it is clear that there are a large number of updates µ that correspond to ν.	x-4027-3
The fundamental problem, then, is how to select one update µ to the base data given that many possibilities may exist.	x-4028-1
One approach to resolving the ambiguity involves examining the intended semantics of the database and the view.	x-4028-2
Dynamic Aspects Example 22.3.6 Consider a schema Employee[ Name, Department, Team_position], which records an employee’s department and the position he or she plays in the corporate baseball league.	x-4029-1
It is assumed that Name is a key.	x-4029-2
The value “no” indicates that the employee does not play in the league.	x-4029-3
It is assumed that Name is a key.	x-4029-4
Consider the views defined by Sales Baseball = π Employee, Team _ position(σ Team _ position"=“no”( Employee)) Typically, if tuple “Joe”, “Sales”, “shortstop” is deleted from the Sales view, then this tuple should also be deleted from the underlying Employee relation.	x-4029-5
In contrast, if tuple “Joe”, “shortstop” is deleted from the Baseball view, it is typically most natural to replace the underlying tuple “Joe”, d, “shortstop” in Employee by “Joe”, d, “no” (i.e., to remove Joe from the baseball league rather than forcing him out of the company).	x-4029-6
Example 22.3.7 Recall the view V4 of Example 22.3.1, and suppose that the base data is R B S B C c c′ In this case the view contains {a, c, a, c′, a′, c, a′, c′}.	x-4030-1
Suppose that the user requests that a, c be deleted.	x-4031-1
Typically, this deletion is mapped into one or more deletions against the base data.	x-4031-2
However, deleting R(a, 20) results in a side-effect (namely, the deletion of a, c′ from the view).	x-4031-3
Deletion of S(20, c) also yields a side-effect.	x-4031-4
Formal issues surrounding such side-effects of view updates are largely unexplored.	x-4032-1
Complements of Views We now turn to a more abstract formulation of the view update problem.	x-4033-1
Although it is relatively narrow, it provides an interesting perspective.	x-4033-2
In this framework, a view over a base schema B is defined to be a (total) function f from Inst(B) into some set.	x-4034-1
In practice this set is typically Inst(V) for some view schema V; however, this is not required for this development.	x-4034-2
[The proof of Theorem 22.3.10, which presents a completeness result, uses a view whose range is not Inst(V) for any schema V.]	x-4034-3
Two views f, g are equivalent, denoted f ≡ g, if f ≤ g and g ≤ f .	x-4035-1
This is an equivalence relation on views.	x-4035-2
In the following, the focus is primarily on the equivalence classes under ≡.	x-4035-3
Let ⊤ denote the view that is simply the identity, and let ⊥ denote a view that maps every base instance to ∅.	x-4035-4
It is clear that (the equivalence classes represented by)	x-4035-5
Example 22.3.8	x-4036-1
It turns out that there are other complements of f , but they cannot be expressed using the relational algebra (see Exercise 22.25).	x-4037-1
g2 = π Name, Total _ pay( Employee).	x-4038-1
Both g1 and g2 are complements of f .	x-4039-1
Thus each view has at least one complement (namely, ⊤) and may have more than one minimal complement.	x-4040-1
In some cases, complements can be used to resolve ambiguity in the view update problem in the following way.	x-4041-1
Suppose that view f has complement g, and suppose that IV = f (IB) and update ν on IV are given.	x-4041-2
An update µ is a g- translation of ν if f (µ(IB)) = ν(f (IB)) and g(µ(IB)) = g(IB) (see Fig.	x-4041-3
22.2).	x-4041-4
Intuitively, a g-translation Dynamic Aspects v I B I′ B Figure 22.2: Properties of a g-translation µ of view update ν on view f	x-4041-5
Example 22.3.9 to the view, there is no g-translation of ν.	x-4042-1
Then µ1 is the g1-translation of ν, and µ2 is the g2-translation of ν.	x-4043-1
Finally, we state a result showing that a restricted class of view updates can be translated into base updates using complementary views.	x-4044-1
To this end, we focus on updates of a schema R that are total functions from Inst(R) to Inst(R).	x-4044-2
A family U of updates on R is said to be complete if such that µ′(µ(I)) = I.	x-4044-3
Intuitively, condition (b) says that a user can always undo an update just made.	x-4045-1
It is certainly natural to focus on complete sets of updates.	x-4045-2
Let base schema B and view f be given, and let Uf be a family of updates on the view.	x-4046-1
Let UB denote the family of all updates on the base schema.	x-4046-2
A translator for Uf is a mapping t : Uf → UB such that for each base instance IB and update ν ∈ Uf , f (t (ν)(IB)) = ν(f (IB)).	x-4046-3
Clearly, solving the view update problem consists of coming up with a translator.	x-4046-4
If g is a complement for f , then a translator t is a g- translator if t (ν) is a g-translation of ν for each ν ∈ Uf .	x-4047-1
We can now state the following (see Exercise 22.26): Theorem 22.3.10 Let base schema B and view f be given, and let Uf be a complete set of updates on the view.	x-4048-1
Suppose that t is a translator for Uf .	x-4048-2
Then there is a complement g of f such that t is a g-translator for Uf .	x-4048-3
Thus to find a translator for a complete set of view updates, it is sufficient to specify an appropriate complementary view g and take the corresponding g-translator.	x-4049-1
The theorem says that one can find such g if a translator exists at all.	x-4049-2
The preceeding framework provides an abstract, elegant perspective on the view update problem.	x-4050-1
Forming bridges to the more concrete frameworks in which views are defined by specific languages (e.g., relational algebra) remains largely unexplored.	x-4050-2
Updating Incomplete Information In a sense, an update to a view is an incompletely specified update whose completion must be determined or selected.	x-4051-1
In this section, we consider more general settings for studying updates and incomplete information.	x-4051-2
First we return to the conditional tables of Chapter 19 and show a system for updating such databases.	x-4052-1
We then introduce formulations of incomplete information that use theories (i.e., sets of propositional or first-order sentences) to represent the (partial) knowledge about the world.	x-4052-2
Among other benefits, this approach offers an interesting alternative to resolving the view update problem.	x-4052-3
This section concludes by comparing these approaches to belief revision.	x-4052-4
Updating Conditional Tables The problems posed by updating a c-table are similar to those raised by queries.	x-4053-1
A representation T specifies a set of possible worlds rep(T ).	x-4053-2
Given an update u, the possible outcomes of the update are u( rep(T )) = {u(I) | I ∈ rep(T )}.	x-4053-3
Let us consider c-tables and simple insertions, deletions, and modifications, as in the language of IDM transactions.	x-4054-1
We know from Chapter 19 that c-tables form a strong representation system for relational algebra; and it is easily seen that IDM transactions can be expressed in the algebra (see Exercise 22.3).	x-4054-2
It follows that c-tables are a strong representation system for IDM transactions.	x-4054-3
In other words, for each c-table T and IDM transaction t, there exists a c-table t(T ) such that rep(t(T )) = t ( rep(T )).	x-4054-4
Dynamic Aspects Example 22.4.1 Consider the c-table in Example 19.3.1.	x-4055-1
Insertions ins(t) are straightforward: t is simply inserted in the table.	x-4055-2
Consider the deletion d = del({ Student = Sally, Course = Physics}).	x-4055-3
The c-table t(T ) representing the result of the deletion is Student Course Sally Math Sally CS Sally x Biology Math Physics Consider again the original c-table T in Example 19.3.1 and the modification m = mod({ Student = Sally, Course = Music} → { Course = Physics}).	x-4055-4
The c-table m(T ) representing the result of the modification is Student Course Sally Math Sally CS Sally Physics Sally x Biology Math Physics In the context of incomplete information, it is natural to consider updates that themselves have partial information.	x-4056-1
For c-tables, it seems appropriate to define updates with the same kind of incomplete information, using tuples with variables subject to conditions.	x-4056-2
We can define extensions of insertions, deletions, and modifications in this manner.	x-4057-1
It can be shown that c-tables remain a strong representation system for such updates.	x-4057-2
Representing Databases Using Logical Theories Conditional tables provide a stylized, restricted framework for representing incomplete information and are closed under a certain class of updates.	x-4058-1
We now turn to more general frameworks for representing and updating incomplete information.	x-4058-2
These are based on representing databases as logical theories.	x-4058-3
Given a logical theory T (i.e., set of sentences), the set of models of T is denoted by Mod(T).	x-4059-1
In our context, each model corresponds to a different possible instance.	x-4059-2
If	x-4059-3
In general, these approaches use the open world assumption (OWA).	x-4060-1
Recall from Chapter 2 that under the closed world assumption (CWA), a fact is viewed as false unless it can be proved from explicitly stated facts or sentences.	x-4060-2
In contrast, under the OWA if a fact is not implied or contradicted by the underlying theory, then the fact may be true or false.	x-4060-3
Model-Based Approaches to Updating Theories One natural approach to updating a logical theory T is model based; it focuses on how proposed updates affect the elements of Mod(T).	x-4061-1
Given an update u and instance I, let u(I) denote the set of possible instances that could result from applying u to I.	x-4061-2
We use a set for the result to accommodate the case in which u itself involves incomplete information.	x-4061-3
Now let T be a theory and u an update.	x-4062-1
Under the model-based approach, the result u(T) of applying u to T should be a theory T′ such that Mod(T′) = ∪{u(I) | I ∈ Mod(T)}.	x-4062-2
Example 22.4.2 then updating this model yields the single model {q}.	x-4063-1
Thus the result of applying	x-4063-2
Thus the result of applying the update to T′ is {¬p}.	x-4064-1
The approach to updating c-tables presented earlier falls within the model-based paradigm (see Exercise 22.14).	x-4065-1
A family of richer model-based frameworks that supports null values and disjunctive updates has also been developed.	x-4065-2
An interesting dimension of variation in this approach concerns how permissive or restrictive a given update semantics is.	x-4065-3
This essentially amounts to considering how many models are associated with u(I) for given update u and instance I.	x-4066-1
As a simple example, consider starting with an empty database I∅ and the update [ insert (p ∨ q)].	x-4066-2
Under a restrictive semantics, only {p} and {q} Dynamic Aspects	x-4066-3
Formula-Based Approaches to Updating Theories	x-4067-1
We consider two forms of update: [ insert ϕ] and [ delete ϕ], where ϕ is a sentence (i.e., no free variables).	x-4068-1
Given theory T, a theory T′ accomplishes the update [ insert ϕ] for T if ϕ ∈ T′, and it accomplishes [ delete ϕ] for T if1 ϕ "∈ T′∗.	x-4068-2
Observe that there is a difference between [ insert ¬ϕ] and [ delete ϕ]: In the former case ¬ϕ is true for all models of T′, whereas in the latter case ϕ may hold in some model of T′.	x-4068-3
In general, we are interested in accomplishing an update for T with minimal impact on T. Given theory T, we define a partial order ≤T on theories with respect to the degree of change from T. In particular, we define T′ ≤T T′′ if T − T′ ⊂ T − T′′, or if T − T′ = T − T′′ and T′ − T ⊆ T′′ − T. Intuitively, T′ ≤T T′′ if T′ has fewer deletions (from T) than T′′, or both T′ and T′′ have the same deletions but T′ has no more insertions than T′′.	x-4069-1
Intuitively, we are interested in theories T′ that accomplish a given update u for T and are minimal under ≤T.	x-4070-1
We say that such theories T′ accomplish u for T minimally.	x-4070-2
The following characterizes such theories (see Exercise 22.15): Proposition 22.4.3 Let T, T′ be theories and ϕ a sentence.	x-4070-3
Then	x-4070-4
that is consistent with ϕ.	x-4071-1
Thus T′ accomplishes [ delete ϕ] for T minimally iff T′ ∪ ¬ϕ accomplishes [ insert ¬ϕ] for T minimally.	x-4072-1
The following example shows that equivalent but distinct theories can be affected differently by updates.	x-4073-1
Example 22.4.4	x-4074-1
It is easily verified that Mod({Ti | i ∈ [1, n]}) = ∪{ Mod(Ti) | i ∈ [1, n]}.	x-4075-1
Of course, there is a great likelihood of a combinatorial explosion if the disjunction operator is applied repeatedly.	x-4075-2
We now explore a mechanism for giving priority to some sentences in a theory over other sentences.	x-4076-1
Let n ≥ 0 be fixed.	x-4076-2
A tagged sentence is a pair (i, ϕ), where i ∈ [0, n] and ϕ is a sentence.	x-4076-3
A tagged theory is a set of tagged sentences.	x-4076-4
Given tagged theory T and i ∈ [1, n], Ti denotes {ϕ | (i, ϕ) ∈ T}.	x-4076-5
The partial order for comparing theories is extended in the following natural fashion.	x-4077-1
Given tagged theories T, T′ and T′′, define T′ ≤T T′′ if for some i ∈ [1, n] we have Tj − T′ = T j j − T′′ j , for each j ∈ [1, i − 1] Ti − T′ ⊂ T i i − T′′ i or we have Tj − T′ = T j j − T′′ j , for each j ∈ [1, n] T′ − T ⊂ T′′ − T.	x-4078-1
Intuitively, T′ ≤T T′′ if the deletions of T′ and T′′ agree up to some level i and then T′ has fewer deletions at level i; or if the deletions match and T′ has fewer insertions.	x-4079-1
In this manner, higher priority is given to the sentences having lower numbers.	x-4079-2
Dynamic Aspects Example 22.4.5 Consider a relation R[ ABC] that satisfies the functional dependency A → B, and consider the instance R B C b c b c′ b′ c′′ b′ c′′′ We now construct a tagged theory T to represent this situation and show how changing a B value of a tuple is accomplished.	x-4080-1
We assume three tag values and describe the contents of T0, T1, and T2 in turn.	x-4081-1
T0 holds the functional dependency and the unique name axiom (see Chapter 2).	x-4081-2
That is, (0, ∀x, y, y′, z, z′(R(x, y, z) ∧ R(x, y′, z′) → y = y′)), Finally, T2 holds Consider now the update u = [ insert ϕ], where ϕ = ∃yR(a, b′′, y).	x-4081-3
Intuitively, this insertion should replace all a, b pairs occurring in πABR by a, b′′.	x-4081-4
More formally, it is easy to verify that the unique tagged theory (up to choice of i) that accomplishes u is (see Exercise 22.17) Thus the choice of sentences and tags included in the theory can influence the result of an update.	x-4081-5
The approach of tagged theories can also be used to develop a framework for accomplishing view updates.	x-4082-1
The underlying database and the view are represented using a tagged theory, and highest priority is given to ensuring that the complement of the view remains fixed.	x-4082-2
Exercise 22.18 explores a simple example of this approach.	x-4082-3
In the approach described here, a set of theories is combined using the disjunction operator.	x-4083-1
In this case, multiple deletions can lead to an exponential blowup in the size of the underlying theory, and performing insertions is np-hard (see Exercise 22.19).	x-4083-2
This provided one motivation for developing a generalization of the approach, in which families of theories, called flocks, are used to represent a database with incomplete information.	x-4083-3
Update versus Revision The idea of representing knowledge using theories is not unique to the field of databases.	x-4084-1
The field of belief revision takes this approach and considers the issue of revising a knowledge base.	x-4085-1
Here we briefly compare the approaches to updating database theories described earlier with those found in belief revision.	x-4085-2
It is clear from postulate (R3) that the formula-based approaches to updating database theories do not qualify as belief revision systems.	x-4086-1
The relationship of the formula-based approaches and belief revision is largely unexplored.	x-4086-2
If a new fact ϕ is to be inserted, this is a modification (and, it is hoped, improvement) of our knowledge about the state of the world, but the world itself is considered to remain unchanged.	x-4087-1
In contrast, in the model-based approaches, the theory T is used to identify a set of worlds that are possible given the limited information currently available.	x-4087-2
If a fact ϕ is inserted, this is understood to mean that the world itself has been modified.	x-4087-3
Thus T is modified to identify a different set of possible worlds.	x-4087-4
Example 22.4.6 Suppose that the world of interest is a room with a table in it.	x-4088-1
There is an abacus and a (hand-held, electronic) calculator in the room.	x-4088-2
Let proposition a mean that Dynamic Aspects the abacus is on the table, and let proposition c mean that the calculator is on the table.	x-4088-3
Finally, let T be (a ∧ ¬c) ∨ (¬a ∧ c).	x-4089-1
From the perspective of belief revision, T indicates that according to our current knowledge, either the abacus or the calculator is on the table, but not both.	x-4090-1
Suppose that we are informed that the calculator is on the table (i.e., [ insert c]).	x-4090-2
This is viewed as additional knowledge about the unchanging world.	x-4090-3
Combining T with c, we obtain the new theory T1 = ((a ∧ ¬c) ∨ (¬a ∧ c)) ∧ c ≡ (¬a ∧ c).	x-4090-4
[Note that this outcome is required by postulate (R2).]	x-4090-5
From the model-based perspective, T indicates that either the world is {a} or it is {c}.	x-4090-6
The request [ insert c] is understood to mean that the world has been modified so that c has become true.	x-4091-1
This can be envisioned in terms of having a robot enter the room and place the calculator on the table (if it isn’t already there) without reporting on the status of anything except that the robot has been successful.	x-4091-2
As a result, the world {a} is replaced by {a, c}, and the world {c} is replaced by itself.	x-4091-3
The resulting theory is T2 = c (which is interpreted under the OWA).	x-4091-4
This is strictly weaker than (R2).	x-4092-1
Other postulates enforce the intuition that the effect of an update on a possible model is independent of the other possible models of a theory, maintaining satisfiability and relationships between the effects of different updates.	x-4092-2
Suppliers Sname Prices Part Sname Price The Depot nail The Depot Builder’s Mart bolt The Depot bolt Builder’s Mart nut Builder’s Mart Figure 22.3: Sample instance for active database examples straint maintenance, incremental update of materialized views, mapping view updates to the base data, and supporting database interoperability.	x-4093-1
Rules and Rule Application There are three distinguishing components in an active database: (1) a subsystem for monitoring events, (2) a set of rules, often called a rule base, and (3) a semantics for rule application, typically called an execution model.	x-4094-1
Rules typically have the following so-called ECA form: on event if condition then action.	x-4095-1
Depending on the system and application, the event may range over external phenomena and/or over internal events (such as a method call or inserting a tuple to a relation).	x-4096-1
Events may be atomic or composite, where these are built up from atomic events using, say, regular expressions or a process algebra.	x-4096-2
Events may be essentially Boolean or may return a tuple of values that indicate what triggered the event.	x-4096-3
Conditions typically involve parameters passed in by the events, and the contents of the database.	x-4097-1
As will be described shortly, several systems permit conditions to look at more than one version of the database state (e.g., corresponding to the state before the event and the state after the event).	x-4097-2
In some systems, events are not explicitly specified; essentially any change to the database makes the event true and leads to testing of all rule conditions.	x-4097-3
In principle, the action may be a call to an arbitrary routine.	x-4098-1
In many cases in relational systems, the action will involve a sequence of insertions, deletions, and modifications; and in object-oriented systems it will involve one or more method calls.	x-4098-2
Note that this may in turn trigger other rules.	x-4098-3
The remainder of this discussion focuses on the relational model.	x-4099-1
A short example is given, followed by a brief discussion of execution models.	x-4099-2
Example 22.5.1 Suppose that the Inventory database includes the following relations: Suppliers[ Sname, Address] Prices[ Part, Sname, Price] Dynamic Aspects Suppliers and the parts they supply are represented in Suppliers and Prices, respectively.	x-4100-1
It is assumed that Sname is a key of Suppliers and Part, Sname is a key of Prices.	x-4100-2
An example instance is shown in Fig.	x-4100-3
22.3.	x-4100-4
We now list some example rules.	x-4101-1
These rules are written in a pidgin language that uses tuple variables.	x-4101-2
The variable T ranges over sets of tuples and is used to pass them from the condition to the action.	x-4101-3
As detailed shortly, both (r1) considered in isolation and the set (r2.a) .	x-4101-4
.	x-4101-5
.	x-4101-6
(r2.d) taken together can be used to enforce the inclusion dependency Prices[ Sname] ⊆ Suppliers[ Sname].	x-4101-7
on true if Prices(p) and p. Sname ∈ π Sname( Suppliers) then Prices := Prices − {p} on delete Sname(s) if T := σ Sname= s. Sname( Prices) is not empty then Prices := Prices − T on modify Sname(s) if old( s).	x-4102-1
Sname = new( s).	x-4102-2
Sname and T = σ Sname= old( s).	x-4102-3
Sname( Prices) then set p. Sname = new( s).	x-4102-4
Sname for each p in Prices where p ∈ T on insert Prices(p) if p. Sname ∈ π Sname( Suppliers) then issue supplier_warning(p) on modify Prices(p) if new( p).	x-4102-5
Sname ∈ π Sname( Suppliers) then issue supplier_warning( new(p)) Consider rule (r1).	x-4102-6
If ever a state arises that violates the inclusion dependency, then the rule deletes violating tuples from the Prices relation.	x-4102-7
The event of (r1) is always true; in principle the database must check the condition whenever an update is made.	x-4102-8
It is easy to see in this case that such checking need only be done if the relations Supplies or Prices are updated, and so the event “on Supplies or Prices is updated” could be incorporated into (r1).	x-4102-9
Although this does not change the effect of the rule, it provides a hint to the system about how to implement it efficiently.	x-4102-10
Rules (r2.a) .	x-4103-1
.	x-4103-2
.	x-4103-3
(r2.d) form an alternative mechanism for enforcing the inclusion dependency.	x-4103-4
In this case, the cause of the dependency violation determines the reaction of the system.	x-4103-5
Here a deletion from (r2.a) or modification (r2.b) to Suppliers will result in deletions from or modifications to Prices.	x-4103-6
In (r2.b), variable s ranges over tuples that have been modified, old(s) refers to the original value of the tuple, and new(s) refers to the modified value.	x-4103-7
On the other hand, changes to Prices that cause a violation [rules (r2.c) and	x-4103-8
Execution Models Until now, we have considered rules essentially in isolation from each other.	x-4104-1
A fundamental issue concerns the choice of an execution model, which specifies how and when rules will be applied.	x-4104-2
As will be seen, a wide variety of execution models are possible.	x-4104-3
The true semantics of a rule base stems both from the rules themselves and from the execution model for applying them.	x-4104-4
We assume for this discussion that there is only one user of the system, or that a concurrency control protocol is enforced that hides the effect of other users.	x-4105-1
Suppose that a user transaction t = c1; .	x-4106-1
.	x-4106-2
.	x-4106-3
; cn is issued, where each of the ci’s is an atomic command.	x-4106-4
In the absence of active database rules, application of t will yield a sequence I0, I1, .	x-4106-5
.	x-4106-6
.	x-4106-7
, In of database states, starting with the original state I0 and where each state Ii+1 is the result of applying ci+1 to state Ii.	x-4106-8
If rules are present, then a different sequence of states might arise.	x-4106-9
One dimension of variation between execution models concerns when rules are fired.	x-4107-1
Under immediate firing, a rule is essentially fired as soon as its event and condition become true; under deferred firing, rule application is delayed until after the state In is reached; and under concurrent firing, a separate process is spawned for the rule action and is executed concurrently with other processes.	x-4108-1
In the most general execution models, each rule is assigned its own coupling mode (i.e., immediate, deferred, or concurrent), which may be further refined by associating a coupling mode between event and condition testing and between condition testing and action execution.	x-4108-2
We now examine the semantics of immediate and deferred firing in more detail.	x-4109-1
We assume for this discussion that the event of each rule is simply true.	x-4109-2
To illustrate immediate firing, suppose that a rule r with action d1; .	x-4110-1
.	x-4110-2
.	x-4110-3
; dm is triggered (i.e., its condition has become true) in state I1 of the preceeding sequence of states.	x-4110-4
Then the sequence of databases states might start with I0, I1, I′1, I′2, .	x-4110-5
.	x-4110-6
.	x-4110-7
, I′m, .	x-4110-8
.	x-4110-9
.	x-4110-10
, where I′ is the result of applying d is the result of applying d	x-4110-11
j +1 to I′j m c2 would be applied.	x-4111-1
The semantics of intermediate rule firing is in fact more complex, for two reasons.	x-4111-2
First, another rule might be triggered during the execution of the action of the first triggered rule.	x-4111-3
In general, this calls for a recursive style of rule application, where the command sequences of each triggered rule are placed onto a stack.	x-4111-4
Second, several rules might be triggered at the same time.	x-4111-5
One approach in Dynamic Aspects this case is to assume that the rules are ordered and that rules triggered simultaneously are considered in that order.	x-4111-6
Another approach is to fire simultaneously-triggered rules concurrently; essentially this has the effect of firing them in a nondeterministic order.	x-4111-7
In the case of deferred firing, the full user transaction is completed before any rules are fired, and each rule action is executed in its entirety before another rule action is initiated.	x-4112-1
This gives rise to a sequence of states having the form I orig, I user, I2, I3, .	x-4113-1
.	x-4113-2
.	x-4113-3
, I curr, where now I orig is the original state, I user is the result of applying the user-requested transaction, and the states I2, I3, .	x-4113-4
.	x-4113-5
.	x-4113-6
, I curr are the results of applying the actions of fired rules.	x-4113-7
The sequence shown here might be extended if additional rules are to be fired.	x-4113-8
Several intricacies arise.	x-4114-1
As before, the order of rule firing must be considered if multiple rules are triggered at a given state.	x-4114-2
Recall the (r2) rules of Example 22.5.1, whose events where based on transitions between some former state and some latter state.	x-4114-3
What states should be used?	x-4114-4
It is natural to use I curr as the latter state.	x-4114-5
With regard to the former state, some systems advocate using I orig, whereas other systems support the use of one of the intermediate states (where the choice may depend on a complex condition).	x-4114-6
Suppose that two rules r and r′ are triggered at some state I curr = Ii and that r is fired first to reach state Ii+1.	x-4115-1
The event and/or condition of r′ may no longer be true.	x-4115-2
This raises the question, Should r′ be fired?	x-4115-3
A consensus has not emerged in the literature.	x-4115-4
The while languages studied in Part E can serve as the kernel of an active database.	x-4116-1
These languages do not use events; restrict rule actions to insertions, deletions, and value creation; and examine only the current state in a rule firing sequence.	x-4117-1
If value creation is supported, then these languages are complete for database mappings and so in some sense can simulate all active databases.	x-4117-2
However, richer rules and execution models permit the possibility of developing rule bases that enforce a desired set of policies in a more intuitive fashion than a while program.	x-4117-3
It should be clear that whatever execution model and form for rules is selected, most questions about the behavior of an active database are undecidable.	x-4118-1
It is thus interesting to consider more restricted execution models that behave in predictable ways.	x-4118-2
We now present one such execution model, called the accumulating model; this forms a portion of the execution model of AP5, a main-memory active database system that has been used in research for over a decade.	x-4118-3
To describe the accumulating execution model, we first introduce the notion of a delta.	x-4119-1
Let R = {R1, .	x-4120-1
.	x-4120-2
.	x-4120-3
, Rn} be a database schema.	x-4120-4
An atomic update over R is an expression of the form +Ri(t) or −Ri(t), where i ∈ [1, n] and t is a tuple having the arity of Ri.	x-4120-5
A delta over R is a finite set of atomic updates over R that does not contain both +R(t) and −R(t) for any R and t or the special value fail.	x-4120-6
(Modifies could also be incorporated into deltas, but we do not consider that here.)	x-4120-7
A delta not containing the value fail is consistent.	x-4120-8
For delta , we define	x-4120-9
Given instance I and consistent delta over R, the result of applying to I is apply(I, ) = (I ∪ +) − − = (I − −) ∪ +.	x-4121-1
Finally, the merge of two consistent deltas 1, 2 is defined by 1 ∪ 2 if this is consistent fail otherwise.	x-4122-1
The accumulating execution model uses deferred rule firing.	x-4123-1
Each rule action is viewed as producing a consistent delta.	x-4123-2
The user-requested transaction is also considered to be the delta 0.	x-4123-3
Thus a sequence of states I orig = I0, I user = I1, I2, I3, .	x-4123-4
.	x-4123-5
.	x-4123-6
, I curr is produced, where I user = apply(I orig, 0) and, more generally, Ii+1 = apply(Ii, i) for some i produced by a rule firing.	x-4123-7
i	x-4124-1
Suppose that we are now in state I curr with delta curr.	x-4125-1
We assume that rule conditions can access only I orig and curr.	x-4125-2
(If the rule conditions have the power of, for example, the relational calculus, this means they can in effect access I curr.)	x-4125-3
Given rule r, state I, and delta , the effect of r on I and , denoted effect(r, I, ), is the delta corresponding to the firing of r on I and , if the condition of r is satisfied, and is ∅ otherwise.	x-4125-4
Execution proceeds as follows.	x-4126-1
The sequence ′ , ′ , .	x-4126-2
.	x-4126-3
.	x-4126-4
is constructed sequentially.	x-4126-5
terminates successfully.	x-4127-1
Otherwise a rule r with condition satisfied by I orig and ′ is i Dynamic Aspects selected nondeterministically.	x-4127-2
If ′ & effect(r, I orig, ′ ) is fail, then execution terminates i i with an abort; otherwise set ′	x-4127-3
i+1 i i	x-4128-1
It is also natural to ask, Does the order of rule firing affect the outcome?	x-4129-1
In general, the answer is yes.	x-4129-2
We now develop a semantic condition on rules that ensures independence of rule firing order.	x-4129-3
A rule r is monotonic if for each instance I and pair 1 ⊆ 2 of deltas, effect(r, I, 1) ⊆ effect(r, I, 2).	x-4129-4
The following can now be shown (see Exercise 22.23): Theorem 22.5.2 If each rule in a rule base is monotonic, then the outcome of the	x-4129-5
Monitoring Events and Conditions In Example 22.5.1, the events that triggered rules were primitive, in the sense that each one corresponded to an atomic occurrence of some phenomenon.	x-4130-1
There has been recent interest in developing languages for specifying and recognizing composite events, which might involve the occurrence of several primitive events.	x-4130-2
For example, composite event specification is supported by the ODE system, a recently released prototype object-oriented active database system.	x-4130-3
The ODE system supports a rich language for specifying composite events, which has essentially the power of regular expressions (see also Section 22.6 for examples of composite events specified by regular expressions).	x-4130-4
An implementation technique based on finite state automata has been developed for recognizing composite events specified in this language.	x-4130-5
Other formalisms can also be used for specifying composite events (e.g., using Petri nets or temporal logics).	x-4131-1
There appears to be a trade-off between the expressiveness of triggers in rules and conditions.	x-4131-2
For example, some Petri-net-based languages for composite events can be simulated using additional relations and rules based on simple events.	x-4131-3
The details of such trade-offs are largely unexplored.	x-4131-4
Temporal Databases and Constraints Classical databases model static aspects of data.	x-4132-1
Thus the information in the database consists of data currently true in the world.	x-4132-2
However, in many applications, information about the history of data is just as important as static information.	x-4132-3
When history is taken into account, queries can ask about the evolution of data through time; and constraints may restrict the way changes occur.	x-4132-4
We briefly discuss these two aspects.	x-4132-5
Temporal Databases Suppose we are interested in a database over some schema R. Thus we wish to model and query information about the content of the database through time.	x-4133-1
Conceptually, we can associate to each time t the state It of the database at time t. Thus the database appears as a sequence of states— snapshots—indexed by some time domain.	x-4133-2
Two basic questions come up immediately:	x-4133-3
Clearly, using valid time requires including time as a first-class citizen in the data model.	x-4134-1
In many applications transaction time might be hidden and dealt with by the system; however, in time-critical applications, such as air-traffic control or monitoring a power plant, transaction time may be important and made explicit.	x-4134-2
A particular database may use valid time, transaction time, or both.	x-4134-3
In our discussion, we will consider valid time only.	x-4134-4
In databases, time is usually taken to be discrete, with some fixed granularity for the time unit.	x-4135-1
However, several distinct time domains with different granularities are often used (e.g., years, months, days, hours, etc.).	x-4135-2
The time domain is usually equipped with a total order and sometimes with arithmetic operations.	x-4135-3
A temporal variable now may be used to refer to the present time.	x-4135-4
To query a temporal database, relational languages must be extended to take into account the time coordinate.	x-4136-1
To say that a tuple u is in relation R at time t, we could simply extend R with one temporal coordinate and write R(u, t).	x-4136-2
Then we could use CALC or ALG on the extended relations.	x-4136-3
This is illustrated next.	x-4136-4
Example 22.6.1 Consider the CINEMA database, indexed by a time domain consisting of dates of the form month/day/year.	x-4137-1
The query is expressed in CALC by	x-4137-2
The query is expressed by since(t, m) ∧ ∀t ′′( since(t ′′, m) → t ≤ t ′′)]}, where Dynamic Aspects since(t, m) = ∀t ′[t ≤ t′ ≤ now → ∃s′( Pariscope(“La Pagode”, m, s′, t′))].	x-4138-1
Classical logics augmented with a temporal coordinate have been studied extensively, mostly geared toward specification and verification of concurrent programs.	x-4139-1
Such logics are usually referred to as temporal logics.	x-4139-2
There is a wealth of mathematical machinery developed around temporal logics; unfortunately, little of it seems to apply directly to databases.	x-4139-3
Example 22.6.2 Figure 22.4 is a representation of temporal information about Pariscope using attribute timestamps with nested relations.	x-4140-1
It would also be natural to represent this using a semantic or object-oriented model.	x-4140-2
The same information can be represented by timestamping at the tuple level, as follows: Pariscope Theater Title Schedule La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Sleeper La Pagode Psycho La Pagode Psycho La Pagode Psycho Kinopanorama Sleeper Kinopanorama Sleeper In this representation, the time intervals are more fragmented.	x-4141-1
This may have some drawbacks.	x-4141-2
For example, retrieving the information about when “Sleeper” was playing at La Pagode (using a selection and projection) yields time intervals that are more fragmented than needed.	x-4141-3
To obtain a more concise representation of the answer, we must merge some of these intervals.	x-4141-4
Note also the difference between the timestamps and the attribute Schedule, which also conveys some temporal information.	x-4142-1
The value of Schedule is user defined, and the database may not know that this is temporal information.	x-4142-2
Thus from the point of view of Pariscope Theater Title Schedule Sleeper La Pagode Psycho Kinopanorama Sleeper Figure 22.4: the temporal database, the value of Schedule is treated just like any other nontemporal value in the database.	x-4142-3
Much of the research in temporal databases has been devoted to finding extensions of SQL and other relational languages suitable for temporal queries.	x-4143-1
Most proposals assume some representation based on tuple timestamping by intervals and introduce intuitive linguistic constructs to compare and manipulate these temporal intervals.	x-4143-2
Sometimes this is done without explicit reference to time, in the spirit of modal operators in temporal logic.	x-4143-3
One such operator is illustrated next.	x-4144-1
Example 22.6.3 Several temporal extensions of SQL use a when clause to express a temporal condition.	x-4145-1
For example, consider the query on the CINEMA database: This can be expressed using the when clause as follows: Dynamic Aspects select t1.	x-4145-2
theater, t2.	x-4145-3
theater from Pariscope t1 t2 where t1.	x-4145-4
title = t2.	x-4145-5
title and t1.	x-4145-6
schedule = t2.	x-4145-7
schedule when t1.	x-4145-8
interval overlaps t2.	x-4145-9
interval The when clause is true for tuples t1, t2 iff the intervals indicating their validity have nonempty intersection.	x-4145-10
Other Boolean tests on intervals include before, after, during, follows, precedes, etc., with the obvious semantics.	x-4145-11
The expressive power of such constructs is not always well elucidated in the literature, beyond the fact that they can clearly be expressed in CALC.	x-4145-12
A review of the many constructs proposed in the literature on temporal databases is beyond the scope of this book.	x-4145-13
For the time being, it appears that a single well-accepted temporal language is far from emerging, although there are several major prototypes.	x-4145-14
Temporal Deductive Databases	x-4146-1
Example 22.6.4 We first illustrate the use of rules in the specification of an infinite temporal database.	x-4147-1
The database holds information on a professor’s schedule—more precisely, the times she meets her two Ph.D. students.	x-4147-2
The facts meets- first( Emma, 0), follows( Emma, John), follows( John, Emma) say that the professor’s first meeting is with Emma, and then John and Emma take turns.	x-4147-3
Consider the rules meets(x, t ) meets(y, t + 1) ← meets(x, t), follows(x, y) The rules define the following infinite sequence of facts providing the professor’s schedule: meets( Emma, 0) meets( John, 1) meets( Emma, 2) meets( John, 3)	x-4148-1
The answer (given in the unary relation until) is defined by the following stratified program: date(x, y, t ) ← Pariscope(x, y, s, t ) until(t ) date(“La Pagode”, “Sleeper”, t) until(t ) The expressiveness of several datalog-like temporal languages and the complexity of query evaluation using such languages are active areas of research.	x-4149-1
Temporal Constraints Classical constraints in relational databases are static: They speak about properties of the data seen at some moment in time.	x-4150-1
This does not allow modeling the behavior of data.	x-4150-2
Temporal (or dynamic) constraints place restrictions on how the data changes in time.	x-4151-1
They can arise in the context of classical databases as well as in temporal databases.	x-4151-2
In temporal databases, we can specify restrictions on the sequence of time-indexed instances using temporal logics (extensions of CALC, or modal logics).	x-4151-3
These are essentially Boolean (yes/no) temporal queries.	x-4151-4
For example, we might require that “La Pagode” not be a first-run theater (i.e., every movie shown there must have been shown in some other theater at some earlier time).	x-4151-5
An important question is how to enforce such constraints efficiently.	x-4151-6
A step in this direction is suggested by the following example.	x-4151-7
Example 22.6.5 Suppose that Pariscope is extended with a time domain ranging over days, as in Example 22.6.1.	x-4152-1
The constraint that “La Pagode” is not a first-run theater can be expressed in CALC as Before[ Title], which holds all movie titles that have been shown in the past at a theater other than “La Pagode.” Note that the size of Shown_Before is bounded by the number of titles that have occurred through the history of the database but is independent of how long the database has been in existence.	x-4152-2
(Of course, if a new title is introduced each day, then Shown_Before will have size comparable to the full history.)	x-4152-3
Dynamic Aspects	x-4153-1
For classical databases, in which no history is kept, temporal constraints can only involve transitions from the current instance to the next; this gives rise to a subset of temporal constraints, called transition constraints For instance, a transition constraint can state that “salaries do not decrease” or that	x-4154-1
Besides CALC, transition constraints may be stated in various other ways, including	x-4155-1
Restrictions on updates—say, by transactional schemas—also induce temporal constraints.	x-4156-1
For instance, consider again the transactional schema in Example 22.2.1.	x-4156-2
It can be verified that all possible sequences of instances obtained by calls to the transactions of that schema satisfy the temporal constraint: The following less desirable temporal constraint is also satisfied: Overall, the connection between canned updates and temporal constraints remains largely unexplored.	x-4156-3
hire[(transfer) + (promote + ǫ)(raise)]∗[(retire) + (fire)] Thus an employee is first hired, receives some number of promotions and raises, may be transferred, and finally either retires or is fired.	x-4157-1
Everybody who is promoted must also Bibliographic Notes receive a raise, but raises may be received even without promotion.	x-4157-2
Such constraints appear to be particularly well suited to object-oriented databases, in which events can naturally be associated with method invocations.	x-4157-3
Some active databases (Section 22.5) can also enforce constraints on sequences of events.	x-4157-4
Bibliographic Notes The properties of IDM transactions were formally studied in [AV88b].	x-4158-1
The sound and complete axiomatization for IDM transactions is provided in [KV91].	x-4158-2
The results on simplification rules are also presented there.	x-4158-3
The language datalog¬¬ and other rule-based and imperative update languages are studied in [AV88c].	x-4158-4
Dynamic Logic Programming is discussed in [MW88b].	x-4158-5
In particular, Example 22.1.3 is from there.	x-4158-6
The language LDL, including its update capabilities, is presented in [NT89].	x-4158-7
IDM transactional schemas are investigated in [AV89].	x-4159-1
Transactional schemas based on more powerful languages are discussed in [AV87, AV88a].	x-4159-2
Patterns of object migration in object-oriented databases are studied in [Su92], using results on IDM transactional schemas.	x-4159-3
A simple update language is shown there to express the family of migration patterns characterized by regular languages; richer families of patterns are obtained by permitting conditionals in this language.	x-4159-4
One of the earliest works on the view maintenance problem is [BC79], which focuses on determining whether an update is relevant or not.	x-4160-1
References [KP81, HK89] study the maintenance of derived data in the context of semantic data models, and [SI84] studies the maintenance of a universal relation formed from an acyclic database family.	x-4160-2
Additional works that use the approach of incremental evaluation include [BLT86, GKM92, Pai84, QW91].	x-4160-3
Heuristics for maintaining the materialized output of a stratified datalog¬ program are developed in [AP87b, Küc91].	x-4160-4
A comprehensive approach, which handles views defined using the stratified datalog and aggregate operators, is developed in [GMS93].	x-4160-5
Reference [Cha94] addresses the issue of incremental update to materialized views in the presence of OIDs.	x-4161-1
Testing for relevance of updates in connection with view maintenance is related to the problem of incremental maintenance of integrity constraints.	x-4162-1
References [BBC80, HMN84] develop general techniques for this problem, and approaches for deductive databases include [BDM88, LST87, Nic82].	x-4162-2
The issue of first-order incremental definability of datalog programs was first raised in [DS92] and [DS93].	x-4163-1
Additional research in this area includes [DT92, DST94].	x-4163-2
A more general perspective on these kinds of problems is presented in [PI94].	x-4163-3
The other practical approach is to perform a careful analysis of the syntax and semantics of a view definition to determine a unique or a small set of update translation(s) that satisfy a family of natural properties.	x-4164-1
This approach is pioneered in [DB82] and further developed in [Kel85, Kel86].	x-4164-2
Example 22.3.6 is inspired by [Kel86].	x-4164-3
Reference [Kel82] considers the issue of unavoidable side-effects from view updates.	x-4164-4
The discussion of view complements and Theorem 22.3.10 is from [BS81].	x-4165-1
Reference Dynamic Aspects	x-4165-2
The semantics of updates on incomplete databases is investigated in [AG85] and	x-4166-1
The idea of representing a database as a logical theory, as opposed to a set of atomic facts, has roots in [Kow81, NG78, Rei84].	x-4167-1
A survey of approaches to updating logical theories, which articulates the distinction between model-based and formula-based approaches, is [Win88].	x-4167-2
Reference [Win86] develops a model-based approach for updating theories that extends the framework of [Rei84].	x-4167-3
Complexity and expressiveness issues related to this approach are studied in [GMR92, Win86].	x-4167-4
A model-based approach has recently been applied in connection with supporting object migration in object-oriented databases in [MMW94].	x-4167-5
References on belief revision include [AGM85], where the AGM postulates are developed, and [Gär88, Mak85].	x-4168-1
The contrast between belief revision and knowledge update was articulated informally in [KW85] and formally in [KM91a], where postulates for updating theories under the model-based perspective were developed; see also [GMR92, KM91b].	x-4168-2
The discussion in this chapter is inspired by [KM91a].	x-4169-1
Exercises The accumulating execution model forms part of the semantics of the AP5 active database model [Coh86, Coh89] (see also [HJ91a]).	x-4170-1
Theorem 22.5.2 is from [ZH90], which goes on to present syntactic conditions on rules that ensure the Church-Rosser property for rule bases that are not necessarily monotonic.	x-4170-2
There is a vast amount of literature on temporal databases.	x-4171-1
The volume [TCG+93] provides a survey of current research in the area.	x-4171-2
In particular, several temporal extensions of SQL can be found there.	x-4171-3
Bibliographies on temporal databases are provided in	x-4171-4
Specification of transition constraints by pre- and postconditions is studied in [CCF82, CF84].	x-4172-1
Transition constraints based on a dynamic version of functional dependencies are investigated in [Via87], where the interaction between static and dynamic fd’s is discussed.	x-4172-2
Constraints of a computational flavor on sequences of objects ( object histories) are considered in [Gin93].	x-4173-1
Temporal constraints specified by regular languages of events (where the events refer to object migration in object-oriented databases) are studied in [Su92].	x-4173-2
References [Cho92a, LS87] develop the approach of “history-less” checking of temporal constraints, as illustrated in Example 22.6.5.	x-4174-1
This technique is applied to testing real-time temporal constraints in [Cho92b], providing one approach to monitoring complex events in an active database system.	x-4174-2
Temporal databases are intimately related to temporal logic.	x-4175-1
Informative overviews of temporal logic can be found in [Eme91, Gal87].	x-4175-2
Exercises Exercise 22.1 Show that there are updates expressible by IDM transactions that are not expressible by ID transactions (i.e., transactions with just insertions and deletions).	x-4176-1
Exercise 22.2 Prove the soundness of the equivalence axioms Dynamic Aspects mod(C → C′) del(C′) ≡ del(C) del(C′) ins(t ) mod(C → C′) where t satisfies C and {t′} = mod(C → C′)({t}) del(C3) mod(C1 → C3) mod(C2 → C1) mod(C3 → C2)	x-4177-1
Exercise 22.3 Show that, for each IDM transaction, there exists a CALC query defining the same result but that the converse is false.	x-4178-1
Characterize the portion of CALC (or ALG) expressible by IDM transactions.	x-4178-2
Exercise 22.4 transaction of the form td; tm; ti, where td is a sequence of deletions, tm is a sequence of modifications, and ti is a sequence of insertions.	x-4179-1
Exercise 22.7 Recall the transaction schema T of Example 22.2.1 and the set of constraints in Example 22.2.2.	x-4180-1
Exercises	x-4181-1
that completely empties the database to make a change involving only one student.)	x-4182-1
Exercise 22.8	x-4182-2
Exercise 22.9 Prove the statements in Example 22.2.4.	x-4183-1
Exercise 22.13	x-4184-1
Exercise 22.14 Recast c-tables in terms of first-order theories.	x-4185-1
Observe that the approach to updating c-tables is model based.	x-4185-2
Given a theory T corresponding to a c-table and an update, describe how to change T in accordance with the update.	x-4185-3
Hint: To represent c-tables using a theory, you will need to use variations of the equality, extension, unique name, and closure axioms mentioned at the end of Chapter 2.	x-4185-4
Exercise 22.15 Prove Proposition 22.4.3.	x-4186-1
Exercise 22.16 T′′ − T and T − T′ ⊆ T − T′′.	x-4187-1
Thus T is like ≤T, except that insertions are given priority over deletions.	x-4187-2
Let T be a closed theory, ϕ a sentence not in T, and T′ a closed theory that accomplishes	x-4188-1
Exercise 22.17	x-4189-1
Exercise 22.18 B, and let I be the instance of Example 22.4.5.	x-4190-1
Dynamic Aspects Consider the view f over S[AB] defined by πAB(R).	x-4191-1
A complement of this view is πAC(R).	x-4191-2
The idea of keeping this complement unchanged while updating the view is captured by the sentences Let T0 be that set of sentences.	x-4191-3
Let T1 include the functional dependency and the unique name axioms.	x-4191-4
Finally, let T2 include the four atoms of I. Verify that there is a unique tagged theory that accomplishes the view update [ insert S(a, b′′)] with minimal change.	x-4191-5
Exercise 22.19	x-4192-1
Exercise 22.20	x-4193-1
R(z) ← R(x), S(x, y, z) R(z) ← R(y), S(x, y, z) R(x) ← T (x)	x-4194-1
Prove that there is a FOID with auxiliary relations for R. Hint: Define a new derived relation Q that holds paths of nodes with value true.	x-4195-1
where the only idb predicate occurring in the body (if any) is Rn.	x-4196-1
Show that each regular chain program is FOID with auxiliary relations.	x-4196-2
In particular, describe an algorithm that produces, for each regular chain program defining a predicate R, a first-order query with auxiliary relations that incrementally evaluates the program.	x-4196-3
Exercise 22.22 Specify in detail an active database execution model based on immediate rule firing.	x-4197-1
Exercise 22.23	x-4198-1
Exercises	x-4199-1
R that the accumulating semantics is more expressive than the alternative semantics.	x-4200-1
Hint: It is possible that curr may have “redundant” elements, e.g., an update +R(t), where R(t) ∈ I orig.	x-4200-2
Such redundant elements are not accessible to the alternative semantics.	x-4201-1
Exercise 22.25 Consider a base schema B = {R[AB]} and a view f = πAR, as in Example 22.3.8(b).	x-4202-1
Exercise 22.26	x-4203-1
Bibliography	x-4204-1
Symp.	x-4205-1
on Principles of Database Systems, pages 79–86, 1987.	x-4205-2
Technical Report, INRIA, 1983.	x-4206-1
Bibliography	x-4207-1
Trans.	x-4208-1
on Database Systems, 4(3):297–314, 1979.	x-4208-2
Morgan Kaufmann, Inc., Los Altos, CA, 1988.	x-4209-1
Journal of Symbolic Logic, 55(1):113–150, 1990.	x-4210-1
Conf.	x-4211-1
on Very Large Data Bases, pages 1–12, 1985.	x-4211-2
on Database Systems, 16(1):1–30, 1991.	x-4212-1
Symp.	x-4213-1
on the Management of Data, pages 143–153, 1988.	x-4213-2
IEEE Conf.	x-4214-1
on Logic in Computer Science, 1991.	x-4214-2
Bibliography SIGMOD Symp.	x-4215-1
on the Management of Data, pages 32–41, 1993.	x-4215-2
on Principles of Database Systems, pages 1–9, 1982.	x-4216-1
Workshop WG 91, pages 63–74.	x-4217-1
Springer-Verlag, Berlin, 1992.	x-4217-2
Convergence of sideways query evaluation.	x-4218-1
In Proc.	x-4218-2
ACM Symp.	x-4218-3
on Principles of Database Systems, pages 24–30, 1986.	x-4218-4
Congress, pages 580–583.	x-4219-1
North Holland, Amsterdam, 1974.	x-4219-2
on Principles of Programming Languages, pages 110–117, 1979.	x-4220-1
J. ACM, 36(4):758–789, October 1989.	x-4221-1
Bibliography	x-4222-1
SIGACT Symp.	x-4223-1
on the Theory of Computing, pages 209–219, 1991.	x-4223-2
Springer-Verlag, Berlin, LNCS 64, 1978.	x-4224-1
Mylopoulos, editors, On Knowledge Base Management Systems—Integrating Database and AI Systems, pages 165–178.	x-4225-1
Springer-Verlag, Berlin, 1986.	x-4225-2
Bibliography	x-4226-1
on Database Systems, 4(3):368–382, September 1979.	x-4227-1
Benjamin/Cummings Publishing Co., Menlo Park, CA, 1993.	x-4228-1
Information and Computation.	x-4229-1
Properties of acyclic database schemes.	x-4230-1
In Proc.	x-4230-2
ACM SIGACT Symp.	x-4230-3
on the Theory of Computing, pages 355–362, 1981.	x-4230-4
Bibliography	x-4231-1
Information and Control, 67:70–90, 1985.	x-4232-1
Theoretical Computer Science, 10:93–105, 1980.	x-4233-1
on Very Large Data Bases, pages 337–349, 1991.	x-4234-1
query optimizer.	x-4235-1
In Proc.	x-4235-2
ACM SIGMOD Symp.	x-4235-3
on the Management of Data, pages 287–296, 1993.	x-4235-4
Bibliography	x-4236-1
on Database Systems, 17:385–422, 1993.	x-4237-1
Bibliography	x-4238-1
In Proc.	x-4239-1
of Intl.	x-4239-2
Workshop on Database Programming Languages, pages 9–19.	x-4239-3
Morgan Kaufmann, Inc., Los Altos, CA, 1992.	x-4239-4
Technical Report, Department of Computer Science, Hebrew University of Jerusalem, 1980.	x-4240-1
Technical Report, Department of Computer Science, Hebrew University of Jerusalem, August 1980.	x-4241-1
Conf.	x-4242-1
on Algorithms, Languages and Programming, pages 73–85, 1981.	x-4242-2
Springer-Verlag, Berlin, LNCS 115.	x-4242-3
SIAM J. on Computing, 13(1):76–98, 1984.	x-4243-1
Symp.	x-4244-1
on the Management of Data, pages 225–236, 1990.	x-4244-2
Bibliography their interaction with functional dependencies.	x-4245-1
Journal of Computer and System Sciences, 28(1):29–59, 1984.	x-4245-2
on Foundations of Computer Science, pages 333–347, 1980.	x-4246-1
In H. Gallaire, J. Minker, and J.-M. Nicolas, editors, Advances in Database Theory, vol.	x-4247-1
1, pages 235–260.	x-4247-2
Plenum Press, New York, 1981.	x-4247-3
Ph.D. thesis, University of Southern California, Los Angeles, 1994.	x-4248-1
Conf.	x-4249-1
on Data Engineering, 1992.	x-4249-2
Bibliography Research, vol.	x-4250-1
3: The Theory of Databases, pages 164–185.	x-4250-2
JAI Press, Inc., Greenwich, CT, 1986.	x-4250-3
Journal of Computer and System Sciences, 32(2):203–233, 1986.	x-4251-1
SIGMOD Symp.	x-4252-1
on the Management of Data, 1993.	x-4252-2
Theoretical Computer Science, 116(1):95–116, 1993.	x-4253-1
A preliminary version was published in the Proceedings of the Third International Conference on Database Theory, Springer-Verlag, Berlin, LNCS 470, 1990.	x-4253-2
on Database Systems, 4(4):397–434, 1979.	x-4254-1
Bibliography	x-4255-1
on the Management of Data, pages 225–234, 1989.	x-4256-1
The algres project.	x-4257-1
In Proc.	x-4257-2
of Intl.	x-4257-3
Conf.	x-4257-4
on Extending Data Base Technology.	x-4257-5
Springer-Verlag, Berlin, 1988.	x-4257-6
Conf.	x-4258-1
on Theory of Relational Databases, Pennsylvania State University, June 1981.	x-4258-2
Symp.	x-4259-1
on Principles of Database Systems, pages 55–66, 1992.	x-4259-2
Symp.	x-4260-1
on Principles of Database Systems, pages 59–70, 1993.	x-4260-2
Bibliography	x-4261-1
In Proc.	x-4262-1
of the Joint Intl.	x-4262-2
Conf.	x-4262-3
and Symp.	x-4262-4
on Logic Programming, pages 589–606, 1992.	x-4262-5
Trans.	x-4263-1
on Database Systems, 3(3):201–222, 1978.	x-4263-2
Technical Report, ONERA–CERT, Toulouse, 1982.	x-4264-1
of Intl.	x-4265-1
Conf.	x-4265-2
on Very Large Data Bases, pages 113–122, 1991.	x-4265-3
Bibliography	x-4266-1
In Proc.	x-4267-1
ACM Symp.	x-4267-2
on Principles of Database Systems, pages 81–90, 1992.	x-4267-3
Math.	x-4268-1
Logik und Grundlagen d. Math.	x-4268-2
, 33:47–63, 1987.	x-4268-3
In Proc.	x-4269-1
of Intl.	x-4269-2
Workshop on Database Programming Languages, 1993.	x-4269-3
Technical Report, Department of Computer Science, University of Melbourne, Australia, 1993.	x-4270-1
To appear in Annals of Mathematics and Artificial Intelligence.	x-4271-1
Symp.	x-4272-1
on Principles of Database Systems, pages 265–275, 1993.	x-4272-2
In Proc.	x-4273-1
of the Symposium on Logic Programming, 1987.	x-4273-2
Symp.	x-4274-1
on Principles of Database Systems, pages 267–278, 1994.	x-4274-2
Bibliography	x-4275-1
Trans.	x-4276-1
on Database Systems, 2:262–278, 1977.	x-4276-2
on the Management of Data, pages 153–160, 1979.	x-4277-1
Trans.	x-4278-1
on Database Systems, 6(3):387–415, 1981.	x-4278-2
Press, Cambridge, MA, 1995.	x-4279-1
Bibliography	x-4280-1
JAI Press, Inc., Greenwich, CT, 1986.	x-4281-1
SIAM J. on Computing, 12(1):36–59, 1983.	x-4282-1
Symp.	x-4283-1
on the Management of Data, pages 160–172, 1987.	x-4283-2
Bibliography constructs to the nested relational algebra.	x-4284-1
In Proc.	x-4284-2
ACM SIGMOD Symp.	x-4284-3
on the Management of Data, pages 225–232, 1988.	x-4284-4
Workshop on Deductive Databases, 1992.	x-4285-1
on Logic Programming, pages 1070–1080, 1988.	x-4286-1
Bibliography problems for database logic programs.	x-4287-1
In Proc.	x-4287-2
IEEE Conf.	x-4287-3
on Logic in Computer Science, pages 106–115, 1987.	x-4287-4
J. ACM, 33(1):105–129, 1986.	x-4288-1
on Principles of Database Systems, pages 58–69, 1987.	x-4289-1
Journal of Computer and System Sciences, 28(1):60–79, 1984.	x-4290-1
Technique et Science Informatiques, 6(5), 1987.	x-4291-1
Bibliography	x-4292-1
on the Management of Data, pages 358–366, 1989.	x-4293-1
Williams, editors, Encyclopedia of Computer Science and Technology, Vol.	x-4294-1
27 (Supplement 12).	x-4294-2
Marcel Dekker, New York, 1993.	x-4295-1
Bibliography	x-4296-1
February 24, 1992.	x-4297-1
on Principles of Database Systems, pages 244–252, 1993.	x-4298-1
Springer-Verlag, Berlin, LNCS 504, 1991.	x-4299-1
Inf.	x-4300-1
Proc.	x-4300-2
Letters, 10(1):14–19, 1980.	x-4300-3
on Principles of Database Systems, pages 347–359, March 1989.	x-4301-1
Bibliography	x-4302-1
Technical Report RJ 9023 (80483), IBM Almaden Research, October 1992.	x-4303-1
Bibliography	x-4304-1
Workshop on Database Programming Languages, pages 416–428, 1991.	x-4305-1
Bibliography	x-4306-1
To appear in Springer-Verlag, Berlin, editor, Proc.	x-4307-1
2nd Conference on Theoretical Aspects of Computer Software (TACS), 1994.	x-4307-2
Symp.	x-4308-1
on Principles of Database Systems, pages 299–313, Nashville, 1990.	x-4308-2
SIGMOD Symp.	x-4309-1
on the Management of Data, pages 393–402, 1992.	x-4309-2
Conf.	x-4310-1
on Database Theory, 1986.	x-4310-2
on Data and Knowledge Bases, pages 416–424.	x-4311-1
Morgan Kaufmann, Inc., Los Altos, CA, 1988.	x-4311-2
Bibliography	x-4312-1
on Principles of Database Systems, pages 231–239, 1988.	x-4313-1
SIGMOD Symp.	x-4314-1
on the Management of Data, pages 143–148, 1984.	x-4314-2
Bibliography	x-4315-1
In Proc.	x-4316-1
ACM Symp.	x-4316-2
on Principles of Database Systems, pages 61–71, 1990.	x-4316-3
Theoretical Computer Science, 116:33–58, 1993.	x-4317-1
Technical Report CMU-CS-89-212, Carnegie-Mellon University, 1989.	x-4318-1
Springer-Verlag, Berlin, 1984.	x-4319-1
Springer-Verlag, Berlin, 1991.	x-4320-1
Bibliography	x-4321-1
Trans.	x-4322-1
on Database Systems, 4(3):262–296, 1979.	x-4322-2
Joint Conf.	x-4323-1
on Artificial Intelligence, pages 173–177, 1985.	x-4323-2
MIT Press, Cambridge, MA, 1992.	x-4324-1
SIGMOD Symp.	x-4325-1
on the Management of Data, pages 424–434, 1988.	x-4325-2
Bibliography	x-4326-1
Workshop on Database Programming Languages, pages 97–114, 1993.	x-4327-1
of Intl.	x-4328-1
Conf.	x-4328-2
on Database Theory, 1986.	x-4328-3
Natl.	x-4329-1
Conf.	x-4329-2
on Artificial Intelligence, 1992.	x-4329-3
Information and Control, 56:154–173, 1983.	x-4330-1
Symp.	x-4331-1
on Principles of Database Systems, pages 58–69, 1983.	x-4331-2
Bibliography	x-4332-1
In Proc.	x-4333-1
of Intl.	x-4333-2
Conf.	x-4333-3
on Very Large Data Bases, pages 34–42, 1983.	x-4333-4
Symp.	x-4334-1
on Principles of Database Systems, pages 245–250, 1985.	x-4334-2
Logic Programming, 1990.	x-4335-1
Bibliography	x-4336-1
Benjamin/Cummings Publishing Co., Menlo Park, CA, 1988.	x-4337-1
on Principles of Database Systems, pages 267–279, 1986.	x-4338-1
Symp.	x-4339-1
on Principles of Database Systems, 1988.	x-4339-2
on Principles of Database Systems, pages 227–236, 1987.	x-4340-1
on Database Systems, 12(1):111–136, 1987.	x-4341-1
Bibliography	x-4342-1
Information Sciences, 47:339–372, 1989.	x-4343-1
Symp.	x-4344-1
on Principles of Database Systems, 1994.	x-4344-2
Fundamenta Informaticae, XIII:445–463, 1990.	x-4345-1
Bibliography	x-4346-1
IEEE Trans.	x-4347-1
on Knowledge and Data Engineering, 3:337–341, 1991.	x-4347-2
Logic Programming, 11:189–216, 1991.	x-4348-1
See also Proc.	x-4348-2
Joint Symp.	x-4348-3
and Intl.	x-4348-4
Conf.	x-4348-5
on Logic Programming, 1988.	x-4348-6
Technical Report RJ1220, IBM Res.	x-4349-1
Lab, San Jose, CA, 1975.	x-4349-2
Springer-Verlag, Berlin, 1984.	x-4350-1
Bibliography	x-4351-1
SIGMOD Symp.	x-4352-1
on the Management of Data, pages 71–81, 1979.	x-4352-2
In Proc.	x-4353-1
of Intl.	x-4353-2
Conf.	x-4353-3
on Very Large Data Bases, 1992.	x-4353-4
Symp.	x-4354-1
on the Management of Data, pages 108–120, 1981.	x-4354-2
Bibliography	x-4355-1
Conf.	x-4356-1
on Management of Data (ICMOD), Milan, Italy, 1978.	x-4356-2
on Principles of Database Systems, pages 237–249, 1987.	x-4357-1
Bibliography	x-4358-1
In Proc.	x-4359-1
ACM Symp.	x-4359-2
on Principles of Database Systems, pages 160–172, 1986.	x-4359-3
Symp.	x-4360-1
on Principles of Database Systems, pages 160–172, 1989.	x-4360-2
Theoretical Computer Science, 62:187–220, 1988.	x-4361-1
Technical Report CS-89-42, Computer Science Department, Brown University, 1989.	x-4362-1
Bibliography	x-4363-1
SIGMOD Symp.	x-4364-1
on the Management of Data, pages 155–165, 1986.	x-4364-2
Bibliography completeness of object-creating query languages.	x-4365-1
In IEEE Conf.	x-4365-2
on Foundations of Computer Science, pages 372–379, 1992.	x-4365-3
Symp.	x-4366-1
on Principles of Database Systems, pages 1–11, 1989.	x-4366-2
Trans.	x-4367-1
on Database Systems, 16:235–278, 1991.	x-4367-2
on the Theory of Computing, pages 137–146, 1982.	x-4368-1
Symp.	x-4369-1
on Principles of Database Systems, pages 252–266, 1986.	x-4369-2
thesis, University of Toronto, 1980.	x-4370-1
Bibliography	x-4371-1
In Proc.	x-4372-1
ACM SIGMOD Symp.	x-4372-2
on the Management of Data, pages 259–264, 1990.	x-4372-3
Computer, 25(3):38–49, March 1992.	x-4373-1
Symp.	x-4374-1
on Principles of Database Systems, pages 224–234, 1986.	x-4374-2
Res.	x-4375-1
and Develop.	x-4375-2
, 19:71–77, 1975.	x-4375-3
Bibliography	x-4376-1
on Database Systems, 1(3):223–241, 1976.	x-4377-1
thesis, University of California at Los Angeles, 1976.	x-4378-1
Technical Report UCLA-Eng-7669, Department of Computer Science.	x-4378-2
on Database Systems, 7:489–499, 1982.	x-4379-1
Morgan Kaufmann, Inc., Los Altos, CA, 1990.	x-4380-1
Index Page numbers in italics indicate the location of definitions of terms.	x-4381-1
composite event, 606 condition, 601 in query language, 155 coupling mode, 603 ECA, 601 event, 601 execution model, 601, 603–606 concurrent firing, 603 deferred firing, 603, 604 complex value, 514, 519 immediate firing, 603–604 conjunctive, 52–61 rule, 601 cylindric, 96, 103 rule base, 601 named conjunctive, 56–59, 57 vs. expert system, 600 nested relation, 519 relational, 28, 35, 36, 64, 70, 71, interpretation, 79 preservation, 249 named, 71 unnamed, 71 of relational calculus, 74, 79 translation into calculus, 80 vs. domain independence, 79 SPC, 52–56, 54 SPCU, 62, 222 vs. dependencies, 137 SPJR, 56–59, 57 distributed databases, 136 SPJRU, 62 hypergraph, 36, 132 SPJU, 492 inclusion dependencies, 208–210, 211 typed restricted SPJ, 64, 67 join, 105, 126, 128–135, 136 unnamed conjunctive, 52–56, 52 join dependency, 169, 182–183, 186 unsorted, 103 Index for full typed dependencies, 227–228 Gentzen-style for jd’s, 186 IDM transaction for, 581 for inds, 193–195, 211 k-ary, 202, 204 proof using, 167 nonlinear version, 314 provable using, 167 sound, 167 deletion, 162, 254 for typed embedded dependencies, 226, 235 insertion, 162 for uinds, 210, 215 modification, 162 for uinds and fds, 210 update, 162 vs. fds and inds, 192, 202–207, 211 vs. fds and sort set dependencies, 213 vs. finite implication, 226 vs. jd’s, 169, 171, 186 B(P , I), 280 B(PI), 387 B-tree, 107 bag, 92, 136 of instance, 32 in SQL, 145, 155 of relation name, 31 BCNF, 250, 251– 252 of tuple, 32 belief revision, 588, 599 for typed dependencies, 233 Berge-acyclic, 131, 137 Bernays-Schönfinkel class, 219 Binary Data Model, 264 binary relation, 10 body of rule, 39, 41, 276 constraint, 112 bottom-up datalog evaluation, 324–335 equality, 217 vs. top-down, 311, 327, 336 ground, 34 bound coordinate in datalog evaluation, 318 relation, 112, 217 bound variable occurrence, 23, 45, 75 boundedness, 285, 304 Boyce-Codd normal form (BCNF), 250, 251–252, in relational model, 30 BP-completeness, 428, 560 in semantic data model, 243 buffering of main memory, 106, 107 C-genericity, 419–420 C+SQL, 466 c-table, 493 vs. inference rule, 167 update, 593–594 CALC adom, 79, 80, 100 CALCdi, 79, 80 CALCsr, 81, 86, 100 for algebraic dependencies, 231, 235 CALC+µ, 348–352, 349 complete, 167 normal form, 368 for fd’s, 166, 168, 186 simultaneous induction, 351 for fd’s and mvd’s, 172–173, 186 CALC+µ+, 352–354, 353 finite, 202 normal form, 368 Index CALC+µ(+) + W , 456 well formed, 549 CALC adom, 79 classification, 572, 575 CALCdi, 79 clause, 288 CALCsr, 85 Closed World Assumption (CWA), 27, 283, 489, CALCcv, 519 CALCcv−, 528 clustering, 107 calculus CNF, 83 complex value, 519, 523 co-r.e., 16 conjunctive, 44–47, 45 Codd, 64 domain, 39, 74 Codd-table for OODBs, 557 query, 488 positive existential, 68, 91 update, 593–594 relational, 28, 35, 36, 39, 64, 70, 73–91 COL, 538 tuple, 39, 74, 101 compactness theorem, 25 calculus formula, 74–75 complement of views, 591–593 parse tree, 83 complement operator, 103, 104 Cartesian product, 52 complete axiomatization, 167 chain program, 303 complete lattice, 286 chase(T , t, ), 176 completeness, 18 chase, 43, 159, 163, 173–185, 186, 220, 263, 497 object-oriented language, 560–561, 560, 574 Church-Rosser, 183–185 of a query language, 466 complexity, 176, 190 relational, 96, 147, 150, 151 fd rule, 175 update language, 583 generalized to embedded dependencies, 223–225 of whileN , 468 generalized to full dependencies, 220 of while new, 470–473 incomplete database, 498 of while uty, 478 ind rule, 208 completion in Query-Subquery (QSQ), 318 completion of program, 407 jd rule, 175 complex constant, 517 complex value, 508–541, 542, 543, 545 query optimization, 163, 177–180 calculus, 519, 523 of tableau queries, 173, 186 datalog, 532, 533 tgd-rule, 223 elementary query, 534 uniquely determined, 176 Equivalence Theorem, 526–531 vs. datalog, 186 fixpoint, 531–532 vs. resolution and paramodulation, 186 instance, 512 chase homomorphism, 184 relation, 512 chasing sequence, 175 safe-range, 528 infinite, 208, 223, 225 schema, 512 terminal, 175 semantic data model, 243 vs. dependency satisfaction, 175 sort, 511 choice operator, 458 strongly-safe-range, 530 Church-Rosser property, 175, 176 term, 519 chase, 183–185 complex value model, 97, 548 CINEMA example, 31 complexity, 13–20 circumscription vs. fixpoint operators, 354 data vs. expression, 122 Clark’s completion.	x-4382-1
See datalog¬, negation as of query languages, 136 failure.	x-4382-2
composition of tableaux, 226–227 class, 543, 545, 547 composition of queries, 37, 48–52 in semantic data model, 243 conjunctive queries, 64 class extension, 556 conjunctive queries with union, 64 class hierarchy, 549 conjunctive query program, 49 Index composition of queries (continued) with union, 36, 37, 38, 61–64 functional paradigm, 50 unnamed algebra, 52–56, 52 imperative paradigm, 50 vs. expert systems, 135 relational algebra queries, 71 yes-no, 42 connectivity query, not first-order, 436, 460 computability, 13–20 conseq P , 389 condensation, 136 consistent condition box in QBE, 150 globally, 128, 136 conditional table.	x-4383-1
See c-table.	x-4383-2
pairwise, 128, 136 conjunction, 44 constant in relational model, 30 flatten, 83 constraint, 186 inequalities over rationals, 96, 98 polyadic, 46 integrity, 28, 185, 236 conjunctive calculus, 64 vs. dependency, 157 with disjunction, 91 polynomial inequalities, 96 with equality, 48 temporal, 611–613 equivalence of formulas, 46 transition, 612 normal form, 46–47 vs. first-order logic, 186, 234 rewrite rule, 46 constraint atom, 112 semantics, 45 constraint database, 36, 71, 94–96, 97–98 with union, 81 constraint programming, 97 conjunctive normal form (CNF), 21, 83 constraint query language, 94–96, 97–98 conjunctive query, 36, 37–64 containment conjunctive queries, 105, 118 with arithmetic, 105 decidability, 117 calculus, 44–47, 45, 64 differences of SPCU queries, 140 normal form, 46–47 first-order queries composition, 48–52, 50 undecidability, 125 containment, 105 queries, 115 complexity, 121–122 tableau queries, complexity of, 121–122 containment of queries with disjunction, 61–64 relative to dependencies, 175, 177 equality, 47–48, 50 relative to family of instances, 174 equivalence, 47, 82, 105 context-free grammar, 19 Equivalence Theorem, 60 context-free language, 20 evaluation, 56 continuous operator, 286 Homomorphism Theorem, 105, 115–118, 117, conventional perspective on relations, 32, 33 CORAL, 337 logic-based perspectives, 40–48 cost model for query evaluation, 106, 108–110 count, 91, 92, 154 monotonic, 42 counter machine, 15 named algebra, 56–59, 57 counting vs. relational calculus, 154 optimization, 36, 56, 105 counting technique, 327, 331–335, 336, 341 in practical systems, 105–115 covariance, 553 using chase, 163 cover, 254 using dependencies, 163 minimal, 257 program, 49 create in SQL, 145 range restricted, with equality, 41, 48, 65 cross product, 52, 54 rule-based, 39, 40–42, 41 physical implementation, 108 satisfiable, 42 in SQL, 144 vs. equi-join, 108 static analysis, 105, 115–122 vs. join, 58 tableau, 43–44, 43 cumulative assignment, 346 Index CWA.	x-4384-1
See Closed World Assumption.	x-4384-2
cylindric algebra vs. relational algebra, 96, 103 dangling reference, 999, 572 data complexity, 122, 422–423 bottom-up, 312–316, 324–335 data definition language (DDL), 4, 28 bound coordinate, 318 data function, 306 connected atom, 338 data independence principle, 4, 9 counting, 327, 331–335, 336, 341 data integrity, 162 direct evaluation, vs. pre-compilation, 317 data manipulation language (DML), 4, 28 Earley Deduction, 335 data model.	x-4385-1
See database model.	x-4385-2
extension tables, 335 data storage, 106 factoring, 337 database access functional paradigm, 571 free coordinate, 318 database instance, 29 generalizations to logic programming, 336 conventional perspective, 32 generalized supplementary magic set rewriting, logic-programming perspective, 32 database logic, 97 incremental, 337 database management system, 3 Iterative Query-Subquery (QSQI), 339 database model, 4, 7, 28 left-to-right, 318 complex value, 508–541 magic set rewriting, vs. QSQ, 311, 324–335, directory, 97 Entity-Relationship (ER), 242 memo-ing, 335 functional, 574 naive, 312 Functional Data Model, 264 original magic set rewriting, 340 generic semantic model (GSM), 242 parallel, 337 hierarchy, 28, 97 pre-compilation, vs. direct evaluation, 317 IFO, 242 Query-Subquery (QSQ), 311, 317–324, 335, Logical Data Model (LDM), 97 network, 28, 97 rectified subgoal, 328, 330–331, 336 object-oriented, 28; See object-oriented database.	x-4386-1
Recursive Query-Subquery (QSQR), 323–324, relational, 28–34 semantic, 28, 207, 242–250 relevant fact, 317 database schema, 29, 31 rule-goal graph, 335 with dependencies, 241, 251 seminaive, basic algorithm, improved datalog, 39, 273–310 bottom-up, 312–316, 324–335 sideways information passing, 318, 336, vs. top-down, 311, 327, 336 boundedness, 285, 304, 309 sip graph, 340 vs. first-order, 306 SLD-AL, 335 chain program, 303, 305, 309 stratification, 337 clause, 288 supplementary relation, 319–320 definite, 288 top-down, 316–324 empty, 288 extensional database (ebb), 279 goal, 288 extensional relation, 277 ground, 288 extensional schema, 277 unit, 288 immediate consequence operator, 282, 375 complex value, 532, 533 intensional database (idb), 279 containment, 301–304 intensional relation, 277 uniform, 304, 305, 309 intensional schema, 277 least fixpoint semantics, 276, 282–286 evaluation, 112, 311–337 Knaster-Tarski’s Theorem, 286 Index datalog (continued) syntax, 276 linear program, 305, 316 top-down vs. bottom-up, 311, 327, 336 linear rule, 316 magic set rewriting, 311, 324–335, 336 vs. logic programming, 35, 278, 298 generalized supplementary, 325, 336 datalog¬, 308, 309, 355–360, 357, 374–414 original, 340 default model semantics, 408 vs. QSQ, 324 inflationary semantics, 356 minimum model semantics, 275, 278–282 locally stratified, 411 Herbrand interpretation, 282 negation as failure, 406–408 Herbrand model, 282 Clark’s completion, 406 monadic programs, 305 finite failure, 406 negative literal, 288 SLDNF resolution, 406 nonrecursive noninflationary semantics, 357 with negation, 70, 72–73 nonrecursive, 70, 72–73 normal form, 68 range-restricted, 372 nonrecursive (nr) program, 62 rule algebra, 359, 373 optimization, 36, 112, 311–337 semipositive program, 377 parallel evaluation, 337 on ordered databases, 406 positive literal, 288 vs. fixpoint, 405 precedence graph, 315 SLB-resolution, 400 program, 276 stable model semantics, 408, 413 proof tree, 286 vs. choice, 409 proof-theoretic semantics, 275, 286–300 stratified, 374 prototype systems, 337 stratified semantics, 377–385 query, 317 independence of stratification, 382 Query-Subquery (QSQ), 311, 317–324, 335 on infinite databases, 411 on ordered databases, 406 completion, 318 precedence graph, 379 Iterative (QSQI), 339 SLS resolution, 409 Recursive (QSQR), 323–324 stratifiable program, 379 template, 319–320 stratification, 378 vs. magic set rewriting, 324 stratification mapping, 378 rule, 276 vs. Fermat’s Last Theorem, 411 body, 276 vs. fixpoint queries, 400 head, 276 supported model, 384, 411 instantiation, 277 tie-breaking semantics, 409 satisfiability, 300–301 update language, 582 semipositive, 379 valid model semantics, 409 sirup, 305, 309 well-founded, 374 SLD-resolution, 289–298 well-founded semantics, 385–397, 413 completeness, 297 datalog¬, 400 derivation, 290 most general unifier (mgu), 293 refutation, 290 global SLS-resolution, 409 resolvent, 289, 295 greatest unfounded set, 413 selection rule, 298 on ordered databases, 406 SLD-derivation, 295 total instance, 387 SLD-refutation, 295 total program, 395 soundness, 296 unfounded set, 413 unifier, 293 vs. default, 412 SLD-tree, 298, 317 vs. fixpoint queries, 400, 401 stratified evaluation, 337 vs. stable, 412 Index datalog¬¬ , 483 general, 234 new DB2, 155 generalized dependency constraints, 234 DBASE IV, 152, 155 generalized mutual, 234 dbms.	x-4387-1
3 implication DDL, 28; See data definition language.	x-4387-2
in view, 221 decidability, 16 implication of, 160, 164, 193, 197 of implication for full dependencies, 220, 234 implicational (id), 233 declarative vs. procedural, 35, 53 implied, 234 decomposition, 162, 251–259, 252, 265–266 inclusion (ind), 161, 192–211, 193, 218, 250 dependency preserving, 254 key-based, 250, 260 typed, 213 lossless join, 253 unary (uind), 210–211 mapping, 253 inference rule, 166, 172, 193, 227, 231 multi-way join, 106, 114–115 ground, 203 reconstruction mapping, 254 join (jd), 161, 169–173, 170, 218 vs. synthesis, 258, 265 key, 157, 163–169, 163, 267 DedGin, 337 logical implication of, 160, 164 deductive database, 8 finite, 197 disjunctive, 502 unrestricted, 197 deductive object-oriented database, 572, 574, 575 multivalued (mvd), 161, 169–173, 170, 186, 218 deductive temporal query language, 610 mutual, 233 deep equality, 557, 575 named vs. unnamed perspectives, 159 default logic, 408 order, 234 definite clause, 288 partition, 234 definite query, 97 projected join, 233 delete in SQL, 149 deletion, 580 satisfaction, 160 implicit, 556 satisfaction by tableau, 175 deletion anomaly, 162, 254 satisfaction family, 174 dense linear order, 96, 98 dependency, 157 single-head vs. multi-head, 217 sort set, 191, 213, 234 subset, 233 tagged, 164, 221, 241 capturing semantics, 159–163 template, 233, 236 classification, 218 transitive, 234 conditional table, 497 trivial, 220 tuple-generating (tgd), 217–228 typed, 159 dynamic, 234 vs. untyped, 192, 217 embedded, 192, 217, 233 unirelational, 217 embedded implicational (eid), 233 embedded join (ejd), 218, 233 embedded multivalued (emvd), 218, 220, 233 vs. first-order logic, 159, 234 equality-generating (egd), 217–228 vs. integrity constraint, 157 extended transitive, 234 vs. tableaux, 218, 234 faithful, 232, 233, 239 dependency basis, 172 finiteness, 306 dependency preserving decomposition, 254 full, 217 dependent class, 246 functional (fd), 28, 159, 163–169, 163, 186, 218, dereferencing, 557, 558 derivation, 290 Index derived data, 246 DOOD.	x-4388-1
See deductive object-oriented database.	x-4388-2
determinate-completeness, 474, 561, 574 duplicate elimination, 107 determinate query, 474, 559 distinct, 107 diameter, 12 duplicate tuples, 144 diff, 88 dynamic aspect of object-oriented database, 572 difference, 33, 36, 68 dynamic binding, 543, 546, 552 in relational algebra, 71 dynamic choice operator, 464 Dynamic Logic Programming (DLP), 583, 613 in SQL, 146 vs. negation, 70 direct product, 232, 238 ear of hypergraph, 130 directory model, 97 Earley Deduction, 335 disjunction, 38 edb, 42, 49, 277 in conjunctive queries, 37, 38, 61, 64 edge of hypergraph, 130 flatten, 83 egd, 217–228 in selection formulas, 62 Ehrenfeucht-Fraissé games, 433–437, 460 disjunctive deductive database, 502 eid, 233 disjunctive normal form (DNF), 21, 83 ejd, 218 disk, 106 EKS, 410 distinct in SQL, 107, 145, 154 elementary functions, 18 distributed database elementary query, 534 query optimization, 128 embedded dependency, 192, 217 division in relational algebra, 99 embedded implicational dependency (eid), 233 DML, 4, 28 embedded join dependency (ejd), 218 DNF, 83 embedded multivalued dependency (emvd), 218, dom, 30, 72 Dom(·), 30 embedding of tableau, 43 domain empty clause, 288 emvd, 218, 220, 233 in relational model, 29, 30 enc α,, 418 scalar, 153 encapsulation, 543, 546, 553 time, 607 entity, 543 underlying, 74 Entity-Relationship (ER) model, 242, 264 domain calculus, 74 equality atom, 217 vs. tuple calculus, 39 equality-generating dependency (egd), 217–228 Domain Closure axiom, 26 domain independence, 70, 74, 75–77, 79, 81–97 equi-join, 55, 108 physical implementation, 107–108 complex value, 526 in SQL, 144 vs. natural join, 57 equivalence with functions, 97 calculus formulas, 82 with order, 97 conjunctive calculus formulas, 46 practical query languages, 153 conjunctive queries, 47, 60, 64, 82, 105 relational calculus, 81 decidability, 118 syntactic restrictions, 81–91 conjunctive queries with union, 63 undecidability, 97, 125 differences of SPCU queries, 140 vs. active domain semantics, 79 finite and unrestricted implicaton for full domain-inclusion semantics, 551 dependencies, 220, 234 domain-key normal form, 265 first-order languages, 36, 80, 96 dominance of query languages (⊑), 47 first-order queries, 74 Index undecidability, 125 fd rule in chasing, 175 of full typed and algebraic dependencies, 231 fd-schema, 251 of hypergraph properties, 132 field, real closed, 97 nr-datalog¬ and relational algebras, 73 file systems, 3 queries, 37 filter, 518 relative to dependencies, 176, 177 finitary power set, 10 query languages, 47 finite interpretation, 26 relational algebras, 71 finite logical implication, 197–202, 219 SPC and SPJR algebras, 60 vs. unrestricted, 197 equivalence class, 10 finite model theory, 123, 197 equivalence relation, 10 finite representation of infinite database, 93–96, 97 Equivalence Theorem finite-state automata, 13 conjunctive query languages, 60 finitely implies, 198 conjunctive query languages with union, 63 finiteness dependency, 306 first-order languages, 80 first normal form, 265 ER model, 242 first-order incremental definability, 588, 613 ESQL, 368, 370 first-order language, 70–98 evaluable query, 97 Equivalence Theorem, 80 evaluation of conjunctive queries, 56 vs. SQL, 147–149, 155 datalog, 112, 311–337 first-order logic, 22, 35 evaluation plan, 107, 108, 110, 135 vs. conjunctive queries, 40 generating, 110–111 vs. constraints, 234 parameterized, 135 vs. dependencies, 159, 234 exact cover problem, 121 vs. integrity constraints, 186 existential quantification, 44 vs. relational calculus, 77, 105, 123, 136 flatten, 83 first-order predicate calculus, 22, 35 vs. universal, 74 first-order queries, 70–98, 70 Exodus equivalence, 74 expressiveness, 433–437 expert system vs. conjunctive queries, 135 Ehrenfeucht-Fraissé games, 433–437, 460 expression complexity, 122, 422–423, 463 on ordered databases, 462 expressive power of object-oriented database, 569, logspace complexity, 430–431 parallel complexity, 431–433 extended relational theory, 26 static analysis, 105, 122–126 extension axioms, 26 extension tables, 335 fixpoint extensional database edb, 42, 49, 279 complex value, 531–532 extensional relation, 42, 48, 277 datalog, 276 incomplete database, 495 semantics of datalog¬, 390 F-logic, 574 fixpoint of an operator, 283 fact, 32 fixpoint queries, 342, 367 factoring, 337 on ordered databases, 447 faithful dependency, 232, 233, 239 ptime complexity, 437 vs. typed, 233 vs. while queries, 453 fd, 28, 159, 160, 163–169, 163, 186, 218.	x-4389-1
See flatten, 524 functional dependency FOID, 588 fd closure format model, 539 formula, 22 of set of attributes, 165 conjunctive calculus, 45 of set of fd’s, 165 conjunctive normal form (CNF), 83 Index formula (continued) GP , 379 disjunctive normal form (DNF), 83 Galileo, 264 interpretable, 77 game-of-life, 343 matrix of, 82 garbage collection, 556 prenex normal form (PNF), 82 Gauss-Seidel algorithm, 335 relational calculus, 74–75 generalized instance, 95 generalized SPC algebra, 55 fourth normal form (4NF), 252, 252, 259 generalized SPJR algebra, 59 Foxpro, 152 generalized tuple, 94, 95 FQL, 264 generic OODB model, 547–556 free(·), 45, 75 generic semantic model (GSM), 242–250 free coordinate genericity, 103, 419–421, 419, 425 in datalog evaluation, 318 globally consistent join, 128, 136, 261 free tuple, 33 GLUE-NAIL, 337 free variable occurrence, 23, 45, 75 goal clause, 288 fsa.	x-4389-2
See finite-state automata.	x-4389-3
Gödel Completeness Theorem, 123, 136 full dependency, 217 graph, 11 full reducer, 129, 136 graphical query language, 150–153 full tuple generating dependency, 218 Graphlog, 369, 370 full typed dependencies ground, 22 ground atom, 34 function-based perspective on tuples, 32 ground clause, 288 Functional Data Model, 264 ground inference rule, 203 functional dependency (fd), 28, 163–169, 163, 186, group by in SQL, 154 grouping, 533 GSM, 242–250 GYO algorithm, 130, 136 with mvd’s, 172–173 GYO reduction, 141 vs. ind’s, 192, 202–207, 211 closure, 165 hash index, 107 cover, 254 head of rule, 39, 41, 276 Heraclitus, 614 dynamic, 615 Herbrand interpretations, 23 independent of ind’s, 250 Herbrand model logical implication datalog, 282 with ind’s, 192, 199–202 hierarchy model, 28, 97 linear time, 165 homomorphism, 12 satisfies, 163 of tableau queries, 117, 127, 136 saturated set, 188 Homomorphism Theorem, 37, 105, 115–118, 117, Horn clause, 279 vs. decomposition, 164, 171 hyp, 18 vs. join dependency, 171, 178 hyperedge, 130 vs. multivalued dependency, 171 hypergraph, 130 vs. propositional logic, 186, 189 vs. semantic data model, 249–253 vs. unrestricted implication, 199 connected, 132 vs. propositional logic, 189 cyclic, 132 functional paradigm, 569 of database schema, 130 functional query language, 569 ear, 130 edge, 130 GYO algorithm, 130 Index path, 132 implicational dependency (id), 233 reduced, 130 implies.	x-4390-1
See implication.	x-4390-2
hyperplane, 438 finitely, 198 without restriction, 198 inclusion dependency (ind), 161, 192–211, 193, 218, I1, I1/2, I0, 387 I∗, I∗, I∗, 391 idb, 42, 49, 277 vs. implication, 210 IDM transaction, 580–582, 613, 615–617 vs. fd’s, 192, 202–207, 211 condition, 580 deletion, 615 independent of fd’s, 250 insertion, 615 key-based, 250, 260 modification, 615 logical implication, 192, 195–197 optimization, 581 with fd’s, 192, 199–202 parallelization, 616 repeats-permitted, 212 schedule, 616 restricted classes, 192 serializability, 616 satisfies, 193 simplification rules, 582 typed, 211 IDM transactional schema, 584, 613, 617 vs. referential integrity, 211 vs. constraints, 585–586 vs. semantic data model, 207 completeness, 617 vs. unrestricted implication, 199 soundness, 617 incomplete database, 487–507 vs. fd’s, 585 c-table, 493 vs. inclusion dependencies, 585, 617 update, 593–594 vs. jd’s, 617 complexity, 499 IFO, 242, 264 fixpoint, 495 ILOG, 576 logical theory, 594–600 image of calculus query, 78 immediate consequence operator, 282 table, 488 imperative method, 564–566, 573 incomplete information implementation cross product, 108 incremental update.	x-4391-1
See first-order incremental equi-join, 107–108 definability.	x-4391-2
multi-way join, 111–115 ind, 161; See inclusion dependency.	x-4392-1
physical, 106–108 ind-rule in chasing, 208 projection, 107 independent component, 265 relational algebra, 107–108 indexing, 106, 107 selection, 107 inequality atom implication in selections, 69 inequality in constraint databases, 96 closed under, 204 inference rule, 24, 158 closed under k-ary, 204 ground, 202, 203 of dependencies, 158, 160, 164, 195 schema, 202 in view, 221 substitution, 167 of fd’s and ind’s, 192 inference rules finite, 197–199, 226 for fd’s and mvd’s, 172–173, 186 finite vs. unrestricted, 202, 219, 234 for functional dependency, 166–168, 186 of functional dependencies, 186 for inclusion dependency, 193–195 of ind’s, 192, 195–197 proof using, 167 for two-element instances, 189 provable using, 167 unrestricted, 197–199 for unary inds, 210, 215 vs. fd’s and ind’s, 199–202 vs. algorithm for testing implication, 166 Index inference rules (continued) IQL, 573 vs. axiom, 167 irreflexive, 11 infinitary logic, 458, 459, 462 ISA, 543, 545 infinite database, 97 semantic data model, 245 finite representation, 36, 93–96, 97 isomorphic tableau queries, 120 infinite tree, 575 isomorphism, 12 inflationary datalog¬, 356 OID, 555 inflationary fixpoint logic (CALC+µ+), 352, iterate, 518 Iterative QSQ (QSQI), 339 inflationary fixpoint operator (µ+), 353 information capacity relative, 265, 268–269 Jacobi algorithm, 335 INGRES, 34, 111, 155 jd, 161, 169–173, 218.	x-4393-1
See join dependency distributed, 135 jd rule, in chasing, 175 query optimizer, 114–115, 127, 135, 137 join, 55,57 inheritance, 546, 552, 553, 567, 573–575, 577 semantic data model, 245 input schema of query, 37 complex value, 517 insert in SQL, 149 decomposition, 106, 114 insertion, 580 equi-join, 55, 57, 108 insertion anomaly, 162 implementation, 111–115 instance left-to-right evaluation, 112 complex value, 512 lossless, 164, 253 database, 29 multi-way, 106, 108, 135 conventional perspective, 32 natural, 56, 57, 169 logic-programming perspective, 32 vs. equi-join, 57 generalized, 95 pairwise consistent, 128, 136 GSM, 245 physical implementation, 107–108 object-oriented database, 554, 555 semi-join, 128, 135 relation in SQL, 144 conventional perspective, 32 tuple substitution, 115, 135 logic-programming perspective, 32 vs. cross product, 58 relativized, 77 vs. intersection, 58 semantic data model, 245 vs. tableau, 64 unrestricted, 197 join decomposition, 114–115 instantiation, 277 join dependency (jd), 161, 169–173, 170, 218 integrity constraint, 6, 28, 157, 186 vs. first-order logic, 186, 234 intended model, 279 intensional database (id6), 42, 49, 279 complexity of implication, 169 intensional relation, 42, 48, 277 interpretable formula, 77 embedded, 233 interpretation, 23 Gentzen-style axiomatization, 186 n-ary, 170 natural, 78 projected, 233 relativized, 74, 77–78 satisfies, 170 unrestricted, 78 vs. axiomatization, 171, 186 intersection, 33 vs. functional dependency, 169, 171, 178 in relational algebra, 71 vs. multi-valued dependency, 170, 182 vs. natural join, 169 in SQL, 146 vs. SPJR algebra, 181 vs. join, 58 vs. unrestricted implication, 199 invented value, 469 Index join detachment, 114, 135 of ind’s, 192, 195–197 join tree, 130, 136 of mvd’s,172–173 unrestricted, 197–199 logical level of three-level architecture, 106 k-ary axiomatization, 202, 204 logical theory and updates, 594 key, 257, 543 logspace complexity of first-order queries, 430–431 in semantic data model, 247 lossless join, 164, 253 key dependency, 163 Löwenheim-Skolem theorem, 25 simple, 267 vs. functional dependency, 161 key-based inclusion dependency, 250, 260 magic set rewriting, 311, 324–335 KL, 503 generalized supplementary, 325, 336 Knaster-Tarski’s Theorem, 286 original, 340 vs. QSQ, 324, 327 main-memory buffering, 106, 107 lambda-calculus, 574 many-sorted query language, 153–154 language (formal), 13–20 map, 540 late binding, 552 map filter, 518 LDL, 337, 409, 533, 538, 613 materizialized view, 51 update language, 583 mathematical logic, 20–27 left-to-right evaluation matrix of formula, 82 datalog, 318 maximum in SQL, 154 join, 112 memo-ing, 335 linear bounded Turing machine, 196 message, 552 linear datalog, 305, 316 method, 543, 551 linear programming, 97 languages, 563–571 Lisp, 573 method resolution, 546, 552 literal, 21 method schema, 563, 566–571 in nr-datalog¬ rule, 72 monadic, 543, 563, 565, 567, 568, 577 local stratification, 411 polyadic, 567, 568, 577 logic.	x-4393-2
See mathematical logic.	x-4393-3
mgu, 295 temporal, 612, 619 Microsoft Access, 36, 143, 150, 152–153, 155 three-valued, 389–391 minimal cover, 257 logic programming, 97 minimal tableau query, 118 constraints, 97 minimization of tableau queries, 105, 119, 136 object-oriented database, 572 minimum in SQL, 154 vs. datalog, 35 minimum model, 275 logic-programming perspective on relations, 32, 33 modal operator, 503 Logical Data Model (LDM), 97 model, 24 logical database, 503 database, 28 logical implication, 21 datalog, 279 relational, 28–34 closed under, 204 semantic data, 243, 245–253, 267 closed under k-ary, 204 modification, 580 of dependencies, 160, 164, 193 modification anomaly, 162 in view, 221 modified RANF, 88 of fd’s, 165, 186 modus ponens, 24 of fd’s and ind’s, 192 monadic datalog program, 305 finite, 197–199 monadic method schema, 543, 563, 565, 567, 568, vs. unrestricted, 202, 219, 234 full dependencies monoid, 199 complexity, 221 monotone operator, 283 Index monotonic query, 42 negation, 36 monotonicity in Microsoft Access, 153 pushing, 83 in QBE, 150 most general unifier (mgu), 293 in selections, 68 multi-head dependency, 217 in SQL, 143 multi-way join stratified, 49 decomposition, 114–115 vs. set difference, 70 detachment, 114, 135 Negation as Failure, 27, 406 implementation, 106, 108, 111–115, 135 negative literal, 288 left-to-right evaluation, 112 nest, 518 tuple substitution, 115, 135 nested loop implementation of join, 107, 108 multiset, 92, 136, 145 nested relation, 512 multivalued dependency (mvd), 161, 169–173, 170, nested SQL query, 143, 146–147 network model, 28, 97 new, 559 dependency basis, 172 NF2.	x-4394-1
See nested relation.	x-4394-2
embedded, 218, 220, 233 no-information null, 502 original definition, 189 non-existing null, 502 satisfies, 170 nondeterminism, 15 semantics of negation, 409 vs. functional dependency, 171 nondeterministic query.	x-4395-1
See query, nondeterministic.	x-4395-2
vs. join dependency, 170 noninflationary datalog¬, 357 vs. propositional logic, 189 nonrecursive (nr) datalog mutual recursion, 315 with negation, 70, 72–73 mvd, See multivalued dependency.	x-4396-1
program, 72 nonrecursive datalog program, 62 normal form, 158 N-datalog¬(¬), 463 Boyce-Codd (BCNF), 250, 251 N1NF.	x-4397-1
See nested relation.	x-4397-2
decomposition algorithm, 255 NAIL!, 337, 409 conjunctive (CNF), 83 naive evaluation conjunctive calculus, 46–47 of datalog, 312 disjunctive (DNF), 83 of SPC query, 109 domain-key, 265 naive table, 492 first, 265 named perspective, 31, 32 fourth (4NF), 252, 252, 259 nr-datalog, 68 projection, 57 prenex (PNF), 82 relational algebra, 71 project-join (PJ/NF), 265, 267 selection, 57 relational algebra (RANF), 86, 97 SPJR algebra, 56–59, 57 relational schema, 251–259, 265 tuple, 32 safe-range (SRNF), 83 vs. unnamed perspective, 32 SPC algebra, 55 named value, 554, 556 SPCU algebra, 62 root of persistence, 556 SPJR algebra, 59 natural interpretation, 78 SPJRU algebra, 62 natural join, 56, 57, 169 third (3NF), 257 polyadic, 58 decomposition algorithm, 257 vs. equi-join, 57 synthesis algorithm, 257 vs. join dependency, 169 now, 607 natural semantics of relational calculus, 78, 79 np, 18 nc, 96, 431 np-complete, 105, 121, 122, 127 Index np-hard, 121 dynamic binding, 543, 546, 552 npspace, 18 encapsulation, 543, 546, 553 nr-datalog, 62 expansion of value, 558 normal form, 68 formal definition, 547–555 nr-datalog¬, 70, 72–73 generic OODB model, 547–556 ILDG, 580 with equality, 72, 73 imperative methods, 564–566, 573 equivalence to first-order languages, 80 expressive power, 565–566, 577 literal, 72 inheritance, 546, 552, 553, 567, 573–575, 577 program, 72 instance, 554, 555 query, 73 IQL, 573 range restricted, 72 ISA, 543, 545 with equality, 72 languages for methods, 563–571 rule, 72 late binding, 552 semantics, 72 logic programming, 572, 574 translation into SQL, 147–149 message, 552 method, 551 NU-Prolog, 337 signature, 551 null value, 488 well formed, 553 method resolution, 546, 552 method schema, 563, 566–571 O2, 562, 573 expressive power, 569–571 O2SQL, 510, 536–537, 562 monadic, 543, 563, 565, 567, 568, 577 obj, 547 polyadic, 567, 568, 577 object, 246, 543, 545, 547, 573 named value, 554, 556 object creation, 573; See object-oriented database, object, 543, 545, 547, 573 object creation.	x-4398-1
object creation, 558–562, 573, 574 object equality, 557 object equality, 557 object history, 615 object identifier, 543, 545, 547 object identifier (OID), 473, 543, 545–547 object migration, 572 semantic data model, 243 OID assignment, 550 object migration, 572, 613, 615 OID isomorphism, 555, 560 object-oriented data model, 28, 245, 477, 546 overriding, 546 object-oriented database, 8, 242, 473, 542–578 parallelism, 573 calculus, 557–558 query semi-deterministic, 574 class, 545 query language, 556–563 class hierarchy, 549 querying schema, 572 well formed, 549 reachability, 565 classification, 572, 575 receiver, 552 completeness, 560–561, 560, 574 role, 571 complex value, 545 schema, 554 consistency, See, object-oriented database, type schema design, 571 safety specialization, 545 context-dependent binding, 552 static binding, 552 covariance, 553 subtyping relationship, 549 dangling reference, 999, 572 type, 548 dba mode, 546 disjoint interpretation, 550 deductive, 575 semantics, 550 deep equality, 557, 575 type safety, 563, 565, 567, 573 dereferencing, 557, 558, 559 user mode, 546 determinate query, 559 value, 547 domain-inclusion semantics, 551 value equality, 557 dynamic aspect, 572 value-dependent binding, 552 Index object-oriented database (continued) not in while, 437 view, 571 partial fixpoint logic (CALC+µ), 348, 349–352 object-oriented programming languages, 573 partial fixpoint operator (µ), 349 object-orienteddatabase partial order, 11 consistency.	x-4399-1
See object-oriented database,type partially ordered set, 11 safety.	x-4399-2
path in hypergraph, 132 ODE, 615 PCP, 16 OID permutation, 13 physical implementation, 106–108 cross product, 108 semantic data model, 243 equi-join, 107–108 OODB, 242; See object-oriented database.	x-4400-1
projection, 107 Open World Assumption (OWA), 489, 497, 595 relational algebra, 107–108 operator selection, 107 continuous, 286 physical level monotone, 283 of three-level architecture, 106 OPS5, 369, 370 physical model of relational database, 106–107 optimization PNF, 82 conjunctive queries, 36, 105 polyadic using chase, 163 conjunction, 46, 75, 83 using dependencies, 163 disjunction, 75, 83 datalog, 36, 112, 311–337 existential quantification, 83 natural join, 58 in practical systems, 105, 106–115 polyadic method schema, 567, 568, 577 relational algebra, 106 polynomial inequalities constraint, 96, 97 transaction, 581 positive existential calculus, 91, 97 using chase, 177–180 decidability, 99 or-sets, 505 positive literal, 288 ORACLE, 34, 155 positive selection formula, 67 ordered database, 397, 447 poss(T ), 490 output schema of query, 37 Post Correspondence Problem (PCP), 16 overriding, 546 OWA, 489, 497, 595 POSTGRES, 153, 600 powerset, 514 precedence graph P (I), 280, 378, 383, 387 in datalog evaluation, 315 pg(P , I), 389 in datalog¬, 379 P wf , 390 negative edge, 380 page fetch, 107 positive edge, 380 page size, 106 predicate, 277 paging protocol, 106 prenex normal form (PNF), 82 pairwise consistent join, 128, 136 procedural vs. declarative, 35, 53 Paradox, 152, 155 product parallel complexity Cartesian, 52 classes of circuits, 431 cross, 52, 54, 58, 108, 144 of first-order queries, 431–433 direct, 235, 240 parameterized IDM transaction, 584 production rule system, 369 call, 584 program schema, 574 parametrized query, 522 project-join expression paramodulation vs. chase, 186 extended, 229 parity query project-join normal form (PJ/NF), 267 not first-order, 460 project-join query, flat, 126 Index projection, 52 conjunctive, 36, 37–64 conjunctive calculus, 44–47 named perspective, 57 containment relative to dependencies, 37, 177 physical implementation, 107 definite, 97 pushing, 109 determinate, 474 in SQL, 144 equivalence, 37 unnamed perspective, 54 relative to dependencies, 176, 177 proof, 24 first-order, 70 using inference rules, 167 genericity, 419–421, 419, 425 proof tree, 286 C-genericity, 419–420 propositional calculus, 21 input schema, 37 propositional logic, 21 with invented values, 469 vs. fd’s and mvd’s, 186, 189 monotonic, 42 pspace, 17 nondeterministic, 453–457 pspace complexity CALC+µ(+) + W , 456 of while queries, 437 choice operator, 458 pspace-complete, 196 dynamic choice operator, 464 PI, 286 N-datalog¬(¬), 463 ptime, 17 while(+) + W , 454, 456 ptime complexity witness operator, 454–456 of fixpoint queries, 437 nr-datalog¬, 73 pure universal relation assumption (URA), 126, 130, optimization, 36, 105–115, 112, 313–339 output schema, 37 pushing parametrized, 522 negation, 83 project-join, flat, 126 projection, 109 relational calculus, 75 selection, 109, 335 satisfiable, 42 schema query, 572 semi-deterministic, 574 q adom, 79 statistical properties, 106 qd(·), 78 tableau, 43–44, 43 qnat(·), 78 union-of-tableaux, 139 qc, 422 untyped, 475 QL, 477 vs. implementation, 110 qptime, 406, 422 vs. query mapping, 37 QSQ, 311, 317–324, 335 vs. update, 28 well-typedness, 417 completion, 318 yes-no, 42 Iterative (QSQI), 339 query composition, 37 Recursive (QSQR), 323–324 query decomposition, 114–115 query evaluation template, 319–320 cost model, 106, 108–110 vs. magic set rewriting, 324, 327 naive, 109 QSQI, 339 in practical systems, 106–115 QSQR, 323–324 query evaluation plan, 107, 108, 110, 135 Quel, 74, 112, 155 generating, 110–111 query, 421 parameterized, 135 complexity, 422–423 query language data complexity, 422–423 expression complexity, 422–423, 463 with arithmetic, 153, 154 composition, 48–52, 71 computability, 417–421 BP-completeness, 428 Index query language (continued) query tree, 108–110, 108 completeness, 466 Query-By-Example (QBE), 36, 40, 43, 143, completeness in a class, 424 conjunctive queries, 36, 37–64 condition box, 150 with union, 36, 37, 38 constraint, 94–98 declarative, 29, 558 negation, 150 vs. procedural, 35, 53 relationally complete, 151 determinate-completeness, 474 view definition, 151 disjunction, 37, 38 vs. tableau queries, 150 dominated by (⊑), 47 Query-Subquery (QSQ), 311, 317–324, 335 embedded, 466 C+SQL, 466 completion, 318 whileN , 467 Iterative (QSQI), 339 equivalence (≡), 47 Recursive (QSQR), 323–324 expressive power, 106, 427 graphical, 150–153 template, 319–320 inflationary semantics, 342–344 vs. magic set rewriting, 324, 327 many-sorted, 153–154 navigational, 558 noninflationary semantics, 342–344 R[·], 31 object-oriented, 556–563 r.e.. See recursively enumerable.	x-4401-1
practical, 143–155 Rado graph, 442, 461 relational algebra, 28, 35, 36 RANF, 86, 97 relational calculus, 28, 35, 36 set-at-a-time, 35 modified, 88 static analysis, 36, 105, 122–126, 306–311 range restricted temporal, 606–613 three paradigms, 35–36 calculus query, 97 Query Management Facility (QMF), 155 calculus variable, 83, 84 query mapping vs. query, 37 conjunctive query, with equality, 41, 48 query optimization, 36, 105 formula, 102 cost model, 106, 108–110 nr-datalog¬, 72 distributed database, 128 with equality, 65, 72 evaluation plan, 107, 108, 110–111, 135 rule, 41 range separable query, 97 in INGRES, 114–115 rank, 402 join detachment, 114, 135 RDL, 369, 370 local vs. global, 115, 117 real closed field, 96, 97 receiver, 552 in practical systems, 106–115 reconstruction mapping, 254 program transformation, 108 rectangle, representation, 95 query rewriting, 108–110 rectified subgoal in datalog evaluation, 328, query tree, 108–110, 108 recursive (formal) language, 16 rewrite rule, 110 Recursive QSQ (QSQR), 323–324 in System R, 112–114 recursively enumerable, 16 by tableau minimization, 118–120 reduced hypergraph, 130 tuple substitution, 115, 135 redundancy and update anomalies, 162 using chase, 163, 177–180 referential integrity constraint vs. inclusion using dependencies, 163 dependency, 161, 213 query rewriting, 108–110 reflexive relation, 10 Index refutation, 290 regular language, 14 base formula, 74 regular tree, 558, 575 conjunctive, 45 relation conjunctive normal form (CNF), 83 complex value, 512 extended, 229 disjunctive normal form (DNF), 83 extensional, 42, 48 domain calculus, 39, 74 intensional, 42, 48 domain independence, 70, 74, 75–77, 79, 81–97 relation (instance), 29 equivalence to first-order languages, 80 conventional perspective, 32 evaluable query, 97 logic-programming perspective, 32, 33 formula, 74–75 over empty attribute set, 32 equivalence, 82 unrestricted, 197 parse tree, 83 relation atom, 112, 217 image of query, 78 relation schema, 31 inequalities constraint, 96, 97 with dependencies, 241 natural semantics, 78, 79 relational algebra, 28, 35, 36, 70, 71, 81 negation, 70–71 polynomial inequalities constraint, 96 with bags, 136 positive existential, 68, 91, 97 complement operator, 103, 104 prenex normal form (PNF), 82 composition, 71 query, 75 conjunctive, 52–61 division, 99 range restricted range separable query, 97 equivalence to first-order languages, 80 equivalences, 106 formula, 102 implementation, 106, 107–108 query, 97, 102 variable, 83, 84 named, 64, 71 relational algebra normal form (RANF), 86, 97 named conjunctive, 56–59 relativized interpretation, 74, 77–78 optimization, 106, 126 rewrite rule, 82 in practical systems, 105, 106–115 for RANF, 86–87 physical implementation, 106–115 for SRNF, 83 safe DRC query, 97 semi-join, 128, 135 safe query, 64, 97 SPC, 52–56, 108, 118 safe-range, 81, 85, 83–85, 97 SPCU, 62, 97, 136 normal form (SRNF), 83 SPJR, 56,–59, 118 safety, 70, 75–77 vs. join dependency, 181 SPJRU, 62 semantics, relativized, 77 translation into calculus, 80 simulation of PCP, 123 typed restricted SPJ, 156 static analysis, 105, 122–126 syntax, 74 unnamed, 71 translation into algebra, 97 unnamed conjunctive, 52–56 unrestricted, 103 safe-range case, 81, 86–91 untyped algebra, 475 tuple calculus, 39, 74, 101 relational algebra normal form (RANF), 86, 97 unrestricted semantics, 78 modified, 88 unsafe, 75 relational calculus, 28, 35, 36, 64, 70, 73–91, 85 vs. first-order logic, 77, 105, 123, 136 vs. select-from-where clause, 145 relational completeness, 96 Index relational completeness (continued) update language, 582 QBE, 151 rule-based conjunctive query, 39, 40–42, 41 SQL, 147 with equality, 48 vs. Turing computability, 96 semantics, 41 relational model, 28–34 with union, 62 relative information capacity, 265, 268–269, 539 rule-goal graph, 335 relativized instance, 77 running intersection property, 141 relativized interpretation, 74, 77–78 relevant fact, 317 relname, 31 safe, 64 renaming DRC query, 97 query, 97 complex value, 517, 524 safe-range, 85 operator, 57, 58 SPJR algebra, 57 complex value, 528 rep(T ), 489 normal form (SRNF), 83 repeat restricted tableau query, 67 query, 97 representation system relational calculus, 81, 83–85 strong, 489 weak, 490 safety, 70, 75–77 representative instance, 263 in SQL, 153 resolution, 186, 552 Same-Generation (SG) vs. chase, 186 program, 331 resolution theorem proving, 136 query, 331 resolvent, 289, 294 Variant (SGV), 339 RETE, 600 sampling in query optimization, 111 Reverse-Same-Generation (RSG) sat(R, ), sat( ), 174 program, 312 satisfaction, 24 query, 317 conjunctive calculus formula, 46 revision vs. update, 599–600 relative to a domain, 77 rewrite rule satisfaction family, 174, 186, 222 conjunctive calculus, 46 satisfiability normal form vs. query optimization, 110 for optimization, 108, 110 datalog, 300 relational calculus, 82 SRNF, 83 sound, 56 SPC algebra, 55–56, 110 satisfiable formula, 21 SPJR algebra, 110 satisfiable query, 42 SRNF to RANF, 86–87 satisfiable SPC algebra, 56 rewriting, query, 108–110 satisfiable SPJR algebra, 59 role, 571 satisfy root of persistence, 556 dependency, 160 rule, 41 by tableau, 175 functional dependency, 163 inclusion dependency, 193 body, 39, 41 join dependency, 170 head, 39, 41 multivalued dependency, 170 nr-datalog¬, 72 saturated set, 188 range restricted, 72 scalar domain, 153 semantics, 72 schema range-restricted, 41 complex value, 512 semantics, 41 database, 29, 31 Index object-oriented database, 554 nr-datalog¬ rule, 72 query, 572 relational calculus relation, 31 schema design natural, 78, 79 decomposition, 162, 251–259, 252 unrestricted, 78 object-oriented database, 571 rule-based conjunctive query, 41 synthesis, 257–258 SPC algebra, 54 SDD-1, 135 SPJR algebra, 58 select-from-where clause, 112, 144 tableau query, 43 vs. projection, 144 semi-deterministic query, 574 vs. relational calculus, 145 semi-join, 128, 135 selection, 52, 57 program, 129 constant based, 66 seminaive datalog evaluation, 312–316, 335 named perspective, 57 basic algorithm, 315 physical implementation, 107 improved algorithm, 316 positive conjunctive, 55, 58 semipositive datalog, 377 pushing, 109, 335 sentence, 23 in SQL, 144 Sequel, 144 unnamed perspective, 53 set comprehension, 538 selection formula set constructor, 508, 509 set difference, 68 disjunction, 62 in relational algebra, 71 inequality atom, 69 with negation, 68 vs. negation, 70 positive, 67 set membership, 514 positive conjunctive, 55, 58, 108 set-at-a-time, 35 selection rule, 298 set _ create, 515 Semantic Binary Data Model, 264 set _ destroy, 515 semantic data model, 28, 157, 192, 240, 242–250, sideways information passing, 111, 112–114 in datalog evaluation, 318, 336, 340 graph, 113, 340 strategy, 113 multi-valued, 243 signature, method, 551 single-valued, 243 simple key dependency, 267 class, 243 simple tableau query, 140 complex value, 243 simultaneous induction, 351 derived data, 246 single rule programs (sirups), 305, 309 Entity-Relationship (ER), 242 single-head dependency, 217 singleton, 518 generic (GSM), 242 sip graph, 113, 340 inheritance, 245 sip strategy, 113 instance, 245 sirup, 305–309 ISA, 245 SLD datalog evaluation, 289–298 object identifier (OID), 243 SLD-AL, 335 printable class, 243 SLD-resolution, 295; See datalog, SLD-resolution.	x-4402-1
datalog¬, 406 SLD-tree, 298, 317 subclass, 243 SLDNF resolution, 406 vs. inclusion dependencies, 207, 251–253 SLS resolution, 409 semantics sort conjunctive calculus, 45 complex value, 511 conjunctive query, 41 of instance, 32 nr-datalog¬ program, 72 of relation name, 31 Index sort (continued) group by, 154 of tuple, 32 insert, 149 sort(·), 31 sort set dependency, 191 nested query, 143–147 vs. axiomatization with fds, 213 in personal computer DBMSs, 152 sort-merge implementation of join, 108 relationally complete, 147, 150 sound axiomatization, 167 safety, 153 spatial database, 95 scalar types, 145 SPC algebra, 52–56, 54, 108 select, 144 base query, 54 set operators, 146 generalized, 55 simulation of nr-datalog¬, 147–149 intersection, 55, 69 translation to algebra, 112 normal form, 55 update, 149 rewrite rule, 55–56, 110 update language, 580 satisfiable, 56 views, 149 unary singleton constant, 54 vs. cross product, 144 with union, 62 vs. first-order queries, 147–149, 155 vs. SPJR algebra, 60 vs. relational calculus, 145 vs. tableau queries, 118 vs. Sequel, 144 SPCU algebra, 62, 97 where, 144 SRNF, 83 stable model, 408, 413 normal form, 62 stage(P , I), 285 specialization, 545 Starburst, 368, 370 SPJ algebra, static analysis typed restricted, 64, 67 conjunctive queries, 105, 115–122 SPJR algebra, 56–59, 57 datalog queries, 306–311 base query, 58 first-order queries, 105, 122–126 generalized, 59 of queries, 36 natural join, 56 relational calculus, 105, 122–126 normal form, 59 static binding, 552 renaming, 57 stored data, statistical properties, 106 rewrite rule, 110 stratified datalog¬, 378 satisfiable, 59 stratified negation, 49 unary singleton constant, 58 stratified semantics, 377–385.	x-4403-1
See datalog¬, with union, 62 stratified semantics vs. join dependency, 181 stream of tuples, 106, 135 vs. SPC algebra, 60 strongly-safe-range vs. tableau queries, 118 complex value, 530 SPJRU algebra, 62 structured object.	x-4403-2
See complex value.	x-4403-3
normal form, 62 Structured Query Language (SQL), 143.	x-4404-1
See SQL SQL, 2–3, 36, 70, 74, 112, 143–150, 155, 336, 370, subclass, 545 semantic data model, 243 bags, 145, 155 subquery in datalog evaluation, 318 contains, 146 substitution, 24, 116 count, 154 vs. valuation, 116 create, 145 subsumption, 136 delete, 149 subtyping relationship, 549 distinct, 145, 154 succ, 397 sum, 91, 92 duplicate tuples, 144 in SQL, 154 from, 144 summary of tableau query, 43 Index superkey, 257 Tarski’s Algebraization Theorem, 96 supplementary relation, 319–320 Taxis, 264 supported model, 384, 411 taxonomic reasoning, 572, 575 sure(T ), 490 template dependency, 233, 236 surrogate, 247, 573 temporal constraint, 611–613 Sybase, 155 history-less checking, 615 symmetric, 10 temporal database, 95, 606–613 synthesis, 257–258 query language, 607–611 vs. decomposition, 258, 265 deductive, 610 System R, 111 TSQL, 609 query optimizer, 112, 113–114, 122, 127, 135, representation, 608–609 temporal CALC, 607 temporal constraint, 611–613 on events, 612, 615 TP , 375 object histories, 615 table, 488–500; See Codd-table, naive table, c-table.	x-4404-2
object migration, 613 tableau, 43 vs. transactional schemas, 612 complexity, 121–122 time domain, 607 composition, 226–227 now, 607 embedding, 43 transaction time, 607 typed, 44 transition constraint, 612 vs. dependencies, 218, 234 dynamic fd’s, 615 vs. join, 64 pre/post conditions, 615 tableau minimization, 105, 118–120, 136 valid time, 607 temporal logic, 608, 615 vs. condensation, 136 temporal query language, 607–611 vs. local optimization, 117 term, 22, 34 vs. number of joins, 118 complex value, 519 vs. resolution theorem proving, 136 tgd, 217–228 tableau query, 43–44, 43 tgd-rule in chasing, 223 chasing, 173, 186 third normal form (3NF), 257 complexity, 111–122 composition, 226 containment, 121–122 difference, 64 with equality, 48 of an fd, 181 three-level architecture, 3 homomorphism, 117, 127, 136 logical level, 106 isomorphic, 120 physical level, 106 of a jd, 181 minimal, 118 TI Open Object-Oriented Data Base, 135 minimization, 119 timestamp, 401 repeat restricted, 67 top-down datalog evaluation, 316–324 semantics, 43 vs. bottom-up, 311, 327, 336 simple, 140 topological sort, 11 summary, 43 total instance, 387 typed, 64, 121, 136 total order, 11 union-of-tableaux query, 63, 64, 139 total program, 395 vs. dependencies, 64 TP , 283 vs. QBE, 150 transaction time, 607 vs. SPC algebra, 118 transactional schema, 584–586, 584, 617 vs. SPJR algebra, 118 Gen(T), 585 tagged dependency, 164, 221, 241 IDM transactional schema, 584, 613, 617 Index transactional schema (continued) of implication for embedded dependencies, 220, parameterized IDM transaction, 584 vs. constraints, 585–586 of implication for emvds, 220 completeness, 585 of implication of fds and inds, 199, 211 soundness, 585 underlying domain, 74 vs. methods, 584 unfounded set, 413 vs. temporal constraints, 612 unification, 293 transformation rule.See rewrite rule.	x-4405-1
uniform containment, 304 transition constraint, 612 union, 33, 37, 38 transitive, 10 in conjunctive queries, 61–64 transitive closure query in Microsoft Access, 153 generalized, 310 in relational algebra, 71 not first-order, 436 in rule-based conjunctive queries, 62 tree, 12 in SQL, 146 truth assignment, 21 union-of-tableaux query, 63, 64, 139 TSQL, 609 unique name axioms, 26 tup _ create, 514 unique role assumption, 261 tup _ destroy, 515 unirelational dependency, 217 tuple, 29 unit clause, 288 free, 33 universal quantification generalized, 94, 95 removing, 83 named perspective, 32 with placeholders, 94 vs. existential quantification, 74 unnamed perspective, 32 universal relation tuple calculus, 74, 101 vs. domain calculus, 39 pure, 126, 130, 242, 252 tuple generating dependency (tgd) weak, 261–264, 262 full, 218 interface, 266 tuple rewriting, 107 scheme assumption (URSA), 260 tuple substitution, 115, 135 unique role assumption, 261 tuple-generating dependency (tgd), 217–228 universe, 23 Turing machine, 15 universe of discourse, 77 linear bounded, 196 Unix, 155 two-element instances unknown value, 488 vs. fd’s and mvd’s, 189 unnamed perspective two-way automata, 15 on relations, 32 type in object-oriented database, 548 projection, 54 type safety, 563, 565, 567, 573 relational algebra, 71 typed dependency, 159 selection, 53 vs. faithful, 233 SPC algebra, 52–56, 54 vs. untyped, 217 tuple, 32 typed inclusion dependency, 211 vs. named perspective, 32 typed restricted SPJ algebra, 64, 67, 156 unnest, 518 typed tableau, 44 unrestricted instance, 197 query, 64, 121, 136 unrestricted interpretation, 78 types(C), 548 unrestricted logical implication, 197–202, 219 vs. finite, 197 vs. functional dependency, 199 unary inclusion dependency (uind), 207, 210–211 vs. inclusion dependency, 199 undecidability vs. join dependency, 199 of properties of datalog queries, 306, 308 unrestricted relational algebra, 103 of properties of first-order queries, 105, 122–126 unrestricted semantics of relational calculus, 78 untyped dependency, 192 Index vs. typed, 217 in QBE, 151 untyped relational algebra, 475 update in SQL, 149 in SQL, 149–150 update, 586, 589–593 statistical properties, 106 complement of views, 591–593 vs. revision, 599–600 virtual, 51 vs. query, 28 update in SQL, 149 update anomalies, 162, 241 weak instance, 262 weak universal model, 502 weak universal relation assumption (URA), 261– update language, 580–583 completeness, 583 well-formed formula IDM transaction, 580–582, 615–617 conjunctive calculus, 45 deletion, 615 relational calculus, 74–75 insertion, 615 well-founded semantics, 385–397 modification, 615 where in SQL vs. selection, 144 rule-based, 582–583 while, 344–346, 345 datalog¬¬, 582 while queries, 342, 367 Dynamic Logic Programming (DLP), 583, 613 normal form, 452–453 LDL, 583 on ordered databases, 447 SQL, 580 pspace complexity, 437 URA, 126, 130, 137 vs. fixpoint queries, 453 pure, 242, 252 while+, 346, 346–347 weak, 261–264, 262 while(+) + W , 456 URSA, 260 while(+)+W , 454 user view.	x-4406-1
See view.	x-4406-2
whileN , 467 completeness on ordered databases, 468 whilenew, 469 V-relation, 513 completeness, 470–473 val(O), 547 not determinate-complete, 474 valid, 21 well-behaved, 470 valid model semantics, 409 while obj , 559 valid time, 607 whileuty, 475 valuation, 41 completeness, 478 well-behaved, 477 of tableau, 43 witness operator, 454–456 vs. substitution, 116 word problem for monoids, 199 value equality, 557 var, 33, 41 variable, 33 yes-no query, 42 bound occurrence, 45, 75 free occurrence, 45, 75 variable assignment, 24 for CALC, 441–444 variable substitution for while, 444–446 rewrite rule, 46, 83 view, 4 complement, 583 maintenance, 586–588, 586 materialized, 51 object-oriented database, 571	x-4407-1
Document Outline	x-4408-1
The Main Principles Functionalities Complexity and Diversity Past and Future Ties with This Book Bibliographic Notes Some Basics Languages, Computability, and Complexity Basics from Logic The Structure of the Relational Model Named versus Unnamed Perspectives Conventional versus Logic Programming Perspectives Notation Bibliographic Notes Getting Started Logic-Based Perspectives Query Composition and Views Bibliographic Notes	x-4409-1
