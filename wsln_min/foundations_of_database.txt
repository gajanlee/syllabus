Contents
Preface
vii
PART A
ANTECHAMBER
1
1
Database Systems
3
1.1
The Main Principles
3
1.2
Functionalities
5
1.3
Complexity and Diversity
7
1.4
Past and Future
7
1.5
Ties with This Book
8
Bibliographic Notes
9
2
Theoretical Background
10
2.1
Some Basics
10
2.2
Languages, Computability, and Complexity
13
2.3
Basics from Logic
20
3
The Relational Model
28
3.1
The Structure of the Relational Model
29
3.2
Named versus Unnamed Perspectives
31
3.3
Conventional versus Logic Programming Perspectives
32
3.4
Notation
34
Bibliographic Notes
34
xiii


xiv
Contents
PART B
BASICS: RELATIONAL QUERY LANGUAGES
35
4
Conjunctive Queries
37
4.1
Getting Started
38
4.2
Logic-Based Perspectives
40
4.3
Query Composition and Views
48
4.4
Algebraic Perspectives
52
4.5
Adding Union
61
Bibliographic Notes
64
Exercises
65
5
Adding Negation: Algebra and Calculus
70
5.1
The Relational Algebras
71
5.2
Nonrecursive Datalog with Negation
72
5.3
The Relational Calculus
73
5.4
Syntactic Restrictions for Domain Independence
81
5.5
Aggregate Functions
91
5.6
Digression: Finite Representations of Infinite Databases
93
Bibliographic Notes
96
Exercises
98
6
Static Analysis and Optimization
105
6.1
Issues in Practical Query Optimization
106
6.2
Global Optimization
115
6.3
Static Analysis of the Relational Calculus
122
6.4
Computing with Acyclic Joins
126
Bibliographic Notes
134
Exercises
136
7
Notes on Practical Languages
142
7.1
SQL: The Structured Query Language
142
7.2
Query-by-Example and Microsoft Access
149
7.3
Confronting the Real World
152
Bibliographic Notes
154
Exercises
154
PART C
CONSTRAINTS
157
8
Functional and Join Dependency
159
8.1
Motivation
159
8.2
Functional and Key Dependencies
163
8.3
Join and Multivalued Dependencies
169


Contents
xv
8.4
The Chase
173
Bibliographic Notes
185
Exercises
186
9
Inclusion Dependency
192
9.1
Inclusion Dependency in Isolation
192
9.2
Finite versus Infinite Implication
197
9.3
Nonaxiomatizability of fd’s + ind’s
202
9.4
Restricted Kinds of Inclusion Dependency
207
Bibliographic Notes
211
Exercises
211
10
A Larger Perspective
216
10.1
A Unifying Framework
217
10.2
The Chase Revisited
220
10.3
Axiomatization
226
10.4
An Algebraic Perspective
228
Bibliographic Notes
233
Exercises
235
11
Design and Dependencies
240
11.1
Semantic Data Models
242
11.2
Normal Forms
251
11.3
Universal Relation Assumption
260
Bibliographic Notes
264
Exercises
266
PART D
DATALOG AND RECURSION
271
12
Datalog
273
12.1
Syntax of Datalog
276
12.2
Model-Theoretic Semantics
278
12.3
Fixpoint Semantics
282
12.4
Proof-Theoretic Approach
286
12.5
Static Program Analysis
300
Bibliographic Notes
304
Exercises
306
13
Evaluation of Datalog
311
13.1
Seminaive Evaluation
312
13.2
Top-Down Techniques
316
13.3
Magic
324


xvi
Contents
13.4
Two Improvements
327
Bibliographic Notes
335
Exercises
337
14
Recursion and Negation
342
14.1
Algebra + While
344
14.2
Calculus + Fixpoint
347
14.3
Datalog with Negation
355
14.4
Equivalence
360
14.5
Recursion in Practical Languages
368
Bibliographic Notes
369
Exercises
370
15
Negation in Datalog
374
15.1
The Basic Problem
374
15.2
Stratified Semantics
377
15.3
Well-Founded Semantics
385
15.4
Expressive Power
397
15.5
Negation as Failure in Brief
406
Bibliographic Notes
408
Exercises
410
PART E
EXPRESSIVENESS AND COMPLEXITY
415
16
Sizing Up Languages
417
16.1
Queries
417
16.2
Complexity of Queries
422
16.3
Languages and Complexity
423
Bibliographic Notes
425
Exercises
426
17
First Order, Fixpoint, and While
429
17.1
Complexity of First-Order Queries
430
17.2
Expressiveness of First-Order Queries
433
17.3
Fixpoint and While Queries
437
17.4
The Impact of Order
446
Bibliographic Notes
457
Exercises
459
18
Highly Expressive Languages
466
18.1
WhileN— while with Arithmetic
467
18.2
Whilenew — while with New Values
469


Contents
xvii
18.3
Whileuty—An Untyped Extension of while
475
Bibliographic Notes
479
Exercises
481
PART F
FINALE
485
19
Incomplete Information
487
19.1
Warm-Up
488
19.2
Weak Representation Systems
490
19.3
Conditional Tables
493
19.4
The Complexity of Nulls
499
19.5
Other Approaches
501
Bibliographic Notes
504
Exercises
506
20
Complex Values
508
20.1
Complex Value Databases
511
20.2
The Algebra
514
20.3
The Calculus
519
20.4
Examples
523
20.5
Equivalence Theorems
526
20.6
Fixpoint and Deduction
531
20.7
Expressive Power and Complexity
534
20.8
A Practical Query Language for Complex Values
536
Bibliographic Notes
538
Exercises
539
21
Object Databases
542
21.1
Informal Presentation
543
21.2
Formal Definition of an OODB Model
547
21.3
Languages for OODB Queries
556
21.4
Languages for Methods
563
21.5
Further Issues for OODBs
571
Bibliographic Notes
573
Exercises
575
22
Dynamic Aspects
579
22.1
Update Languages
580
22.2
Transactional Schemas
584
22.3
Updating Views and Deductive Databases
586
22.4
Updating Incomplete Information
593
22.5
Active Databases
600


xviii
Contents
22.6
Temporal Databases and Constraints
606
Bibliographic Notes
613
Exercises
615
Bibliography
621
Symbol Index
659
Index
661


1 DatabaseSystems
Alice:
I thought this was a theory book.

Vittorio:
Yes, but good theory needs the big picture.

Sergio:
Besides, what will you tell your grandfather when he asks what you study?

Riccardo:
You can’t tell him that you’re studying the fundamental implications of genericity in database queries.

Computers are now used in almost all aspects of human activity. One of their main uses is to manage information, which in some cases involves simply holding data for future retrieval and in other cases serving as the backbone for managing the life cycle of complex financial or engineering processes. A large amount of data stored in a computer is called a database. The basic software that supports the management of this data is called a database management system (dbms). The dbms is typically accompanied by a large and evergrowing body of application software that accesses and modifies the stored information. The primary focus in this book is to present part of the theory underlying the design and use of these systems. This preliminary chapter briefly reviews the field of database systems to indicate the larger context that has led to this theory.

1.1
The Main Principles
Database systems can be viewed as mediators between human beings who want to use data and physical devices that hold it (see Fig. 1.1). Early database management was based on explicit usage of file systems and customized application software. Gradually, principles and mechanisms were developed that insulated database users from the details of the physical implementation. In the late 1960s, the first major step in this direction was the development of three-level architecture. This architecture separated database functionalities into physical, logical, and external levels. (See Fig. 1.2. The three views represent various ways of looking at the database: multirelations, universal relation interface, and graphical interface.)

The separation of the logical definition of data from its physical implementation is central to the field of databases. One of the major research directions in the field has been the development and study of abstract, human-oriented models and interfaces for specifying the structure of stored data and for manipulating it. These models permit the user to concentrate on a logical representation of data that resembles his or her vision of the reality modeled by the data much more closely than the physical representation.

3
4
Database Systems
DBMS
Figure 1.1:
Database as mediator between humans and data
Several logical data models have been developed, including the hierarchical, network, relational, and object oriented. These include primarily a data definition language (DDL) for specifying the structural aspects of the data and a data manipulation language (DML) for accessing and updating it. The separation of the logical from the physical has resulted in an extraordinary increase in database usability and programmer productivity.

Another benefit of this separation is that many aspects of the physical implementation may be changed without having to modify the abstract vision of the database. This substantially reduces the need to change existing application programs or retrain users.

The separation of the logical and physical levels of a database system is usually called the data independence principle. This is arguably the most important distinction between file systems and database systems.

The second separation in the architecture, between external and logical levels, is also important. It permits different perspectives, or views, on the database that are tailored to specific needs. Views hide irrelevant information and restructure data that is retained. Such views may be simple, as in the case of automatic teller machines, or highly intricate, as in the case of computer-aided design systems.

A major issue connected with both separations in the architecture is the trade-off between human convenience and reasonable performance. For example, the separation between logical and physical means that the system must compile queries and updates directed to the logical representation into “real” programs. Indeed, the use of the relational model became widespread only when query optimization techniques made it feasible. More generally, as the field of physical database optimization has matured, logical models have become increasingly remote from physical storage. Developments in hardware (e.g., large and fast memories) are also influencing the field a great deal by continually changing the limits of feasibility.

1.2 Functionalities
5
External Level
View 1
View 2
View 3
Logical Level
Physical Level
Figure 1.2:
Three-level architecture of database systems
1.2
Functionalities
Modern dbms’s include a broad array of functionalities, ranging from the very physical to the relatively abstract. Some functionalities, such as database recovery, can largely be ignored by almost all users. Others (even among the most physical ones, such as indexing) are presented to application programmers in abstracted ways.

The primary functionalities of dbms’s are as follows:
Secondary storage management: The goal of dbms’s is the management of large amounts of shared data. By large we mean that the data is too big to fit in main memory. Thus an essential task of these systems is the management of secondary storage, which involves an array of techniques such as indexing, clustering, and resource allocation.

Persistence: Data should be persistent (i.e., it should survive the termination of a particular database application so that it may be reused later). This is a clear divergence from standard programming, in which a data structure must be coded in a file to live beyond the execution of an application. Persistent programming languages (e.g., persistent C++) are now emerging to overcome this limitation of programming languages.

6
Database Systems
Concurrency control: Data is shared. The system must support simultaneous access to shared information in a harmonious environment that controls access conflicts and presents a coherent database state to each user. This has led to important notions such as transaction and serializability and to techniques such as two-phase locking that ensure serializability.

Data protection: The database is an invaluable source of information that must be protected against human and application program errors, computer failures, and human mis-use. Integrity checking mechanisms focus on preventing inconsistencies in the stored data resulting, for example, from faulty update requests. Database recovery and back-up protocols guard against hardware failures, primarily by maintaining snapshots of previous database states and logs of transactions in progress. Finally, security control mechanisms prevent classes of users from accessing and/or changing sensitive information.

Human-machine interface: This involves a wide variety of features, generally revolving around the logical representation of data. Most concretely, this encompasses DDLs and DMLs, including both those having a traditional linear format and the emerging visual interfaces incorporated in so-called fourth-generation languages. Graphically based tools for database installation and design are popular.

Distribution: In many applications, information resides in distinct locations. Even within a local enterprise, it is common to find interrelated information spread across several databases, either for historical reasons or to keep each database within manageable size. These databases may be supported by different systems (interoperability) and based on distinct models (heterogeneity). The task of providing transparent access to multiple systems is a major research topic of the 1990s.

Compilation and optimization: A major task of database systems is the translation of the requests against the external and logical levels into executable programs. This usually involves one or more compilation steps and intensive optimization so that performance is not degraded by the convenience of using more friendly interfaces.

Some of these features concern primarily the physical data level: concurrency control, recovery, and secondary storage management. Others, such as optimization, are spread across the three levels.

Database theory and more generally, database models have focused primarily on the description of data and on querying facilities. The support for designing application software, which often constitutes a large component of databases in the field, has generally been overlooked by the database research community. In relational systems applications can be written in C and extended with embedded SQL (the standard relational query language) commands for accessing the database. Unfortunately there is a significant distance between the paradigms of C and SQL. The same can be said to a certain extent about fourth-generation languages. Modern approaches to improving application programmer productivity, such as object-oriented or active databases, are being investigated.



1.4 Past and Future
7
1.3
Complexity and Diversity
In addition to supporting diverse functionalities, the field of databases must address a broad variety of uses, styles, and physical platforms. Examples of this variety include the following:
Applications: Financial, personnel, inventory, sales, engineering design, manufacturing control, personal information, etc.

Users: Application programmers and software, customer service representatives, secre-taries, database administrators (dba’s), computer gurus, other databases, expert systems, etc.

Access modes: Linear and graphical data manipulation languages, special purpose graphical interfaces, data entry, report generation, etc.

Logical models: The most prominent of these are the network, hierarchical, relational, and object-oriented models; and there are variations in each model as implemented by various vendors.

Platforms: Variations in host programming languages, computing hardware and operating systems, secondary storage devices (including conventional disks, optical disks, tape), networks, etc.

Both the quality and quantity of variety compounds the complexity of modern dbms’s, which attempt to support as much diversity as possible.

Another factor contributing to the complexity of database systems is their longevity.

Although some databases are used by a single person or a handful of users for a year or less, many organizations are using databases implemented over a decade ago. Over the years, layers of application software with intricate interdependencies have been developed for these “legacy” systems. It is difficult to modernize or replace these databases because of the tremendous volume of application software that uses them on a routine basis.

1.4
Past and Future
After the advent of the three-level architecture, the field of databases has become increasingly abstract, moving away from physical storage devices toward human models of information organization. Early dbms’s were based on the network and hierarchical models.

Both provide some logical organization of data (in graphs and trees), but these representations closely mirror the physical storage of the data. Furthermore, the DMLs for these are primitive because they focus primarily on navigation through the physically stored data.

In the 1970s, Codd’s relational model revolutionized the field. In this model, humans view the data as organized in relations (tables), and more “declarative” languages are provided for data access. Indexes and other mechanisms for maintaining the interconnection between data are largely hidden from users. The approach became increasingly accepted as implementation and optimization techniques could provide reasonable response times in spite of the distance between logical and physical data organization. The relational model also provided the initial basis for the development of a mathematical investigation of databases, largely because it bridges the gap between data modeling and mathematical logic.



8
Database Systems
Historically dbms’s were biased toward business applications, and the relational model best fitted the needs. However, the requirements for the management of large, shared amounts of data were also felt in a variety of fields, such as computer-aided design and expert systems. These new applications require more in terms of structures (more complex than relations), control (more dynamic environments), and intelligence (incorporation of knowledge). They have generated research and developments at the border of other fields.

Perhaps the most important developments are the following:
Object-oriented databases: These have come from the merging of database technology, object-oriented languages (e.g., C++), and artificial intelligence (via semantic models).

In addition to providing richer logical data structures, they permit the incorporation of behavioral information into the database schema. This leads to better interfaces and a more modular perspective on application software; and, in particular, it improves the programmer’s productivity.

Deductive and active databases: These originated from the fusion of database technology and, respectively, logic programming (e.g., Prolog) and production-rule systems (e.g., OPS5). The hope is to provide mechanisms that support an abstract view of some aspects of information processing analogous to the abstract view of data provided by logical data models. This processing is generally represented in the form of rules and separated from the control mechanism used for applying the rules.

These two directions are catalysts for significant new developments in the database field.

1.5
Ties with This Book
Over the past two decades, database theory has pursued primarily two directions. The principal one, which is the focus of this book, concerns those topics that can meaningfully be discussed within the logical and external layers. The other, which has a different flavor and is not discussed in this book, is the elegant theory of concurrency control.

The majority of this book is devoted to the study of the relational model. In particular, relational query languages and language primitives such as recursion are studied in depth.

The theory of dependencies, which provides the formal foundation of integrity constraints, is also covered. In the last part of the book, we consider more recent topics whose theory is generally less well developed, including object-oriented databases and behavioral aspects of databases.

By its nature, theoretical investigation requires the careful articulation of all assumptions. This leads to a focus on abstract, simplified models of much more complex practical situations. For example, one focus in the early part of this book is on conjunctive queries.

These form the core of the select-from-where clause of the standard language in database systems, SQL, and are perhaps the most important class of queries from a practical standpoint. However, the conjunctive queries ignore important practical components of SQL, such as arithmetic operations.

Speaking more generally, database theory has focused rather narrowly on specific areas that are amenable to theoretical investigation. Considerable effort has been directed toward the expressive power and complexity of both query languages and dependencies, in which close ties with mathematical logic and complexity theory could be exploited. On the
Bibliographic Notes
9
other hand, little theory has emerged in connection with physical query optimization, in which it is much more difficult to isolate a small handful of crucial features upon which a meaningful theoretical investigation can be based. Other fundamental topics are only now receiving attention in database theory (e.g., the behavioral aspects of databases).

Theoretical research in computer science is driven both by the practical phenomena that it is modeling and by aesthetic and mathematical rigor. Although practical motivations are touched on, this text dwells primarily on the mathematical view of databases and presents many concepts and techniques that have not yet found their place in practical systems. For instance, in connection with query optimization, little is said about the heuristics that play such an important role in current database systems. However, the homomorphism theorem for conjunctive queries is presented in detail; this elegant result highlights the essential nature of conjunctive queries. The text also provides a framework for analyzing a broad range of abstract query languages, many of which are either motivated by, or have influenced, the development of practical languages.

As we shall see, the data independence principle has fundamental consequences for database theory. Indeed, much of the specificity of database theory, and particularly of the theory of query languages, is due to this principle.

With respect to the larger field of database systems, we hope this book will serve a dual purpose: (1) to explain to database system practitioners some of the underlying principles and characteristics of the systems they use or build, and (2) to arouse the curiosity of theoreticians reading this book to learn how database systems are actually created.

Bibliographic Notes
There are many books on database systems, including [Dat86, EN89, KS91, Sto88, Ull88, Ull89b, DA83, Vos91]. A (now old) bibliography on databases is given in [Kam81]. A good introduction to the field may be found in [KS91], whereas [Ull88, Ull89b] provides a more in-depth presentation.

The relational model is introduced in [Cod70]. The first text on the logical level of database theory is [Mai83]. More recent texts on the subject include [PBGG89], which focuses on aspects of relational database theory; [Tha91], which covers portions of dependency theory; and [Ull88, Ull89b], which covers both practical and theoretical aspects of the field. The reader is also referred to the excellent survey of relational database theory in [Kan88], which forms a chapter of the Handbook of Theoretical Computer Science
[Lee91].

Database concurrency control is presented in [Pap86, BHG87]. Deductive databases are covered in [Bid91a, CGT90]. Collections of papers on this topic can be found in
[Min88a]. Collections of papers on object-oriented databases are in [BDK92, KL89, ZM90]. Surveys on database topics include query optimization [JK84a, Gra93], deductive databases [GMN84, Min88b, BR88a], semantic database models [HK87, PM88], database programming languages [AB87a], aspects of heterogeneous databases [BLN86, SL90], and active databases [HW92, Sto92]. A forthcoming book on active database systems is
[DW94].

2 TheoreticalBackground
Alice:
Will we ever get to the real stuff?

Vittorio:
Cine nu cunoa¸ste lema, nu cunoa¸ste teorema.

Riccardo:
What is Vittorio talking about?

Sergio:
This is an old Romanian saying that means, “He who doesn’t know the lemma doesn’t know the teorema .”
Alice:
I see.

Thischaptergivesabriefreviewofthemaintheoreticaltoolsandresultsthatareusedin this volume. It is assumed that the reader has a degree of maturity and familiarity with mathematics and theoretical computer science. The review begins with some basics from set theory, including graphs, trees, and lattices. Then, several topics from automata and complexity theory are discussed, including finite state automata, Turing machines, computability and complexity theories, and context-free languages. Finally basic mathematical logic is surveyed, and some remarks are made concerning the specializing assumptions typically made in database theory.

2.1
Some Basics
This section discusses notions concerning binary relations, partially ordered sets, graphs and trees, isomorphisms and automorphisms, permutations, and some elements of lattice theory.

A binary relation over a (finite or infinite) set S is a subset R of S × S, the cross-product of S with itself. We sometimes write R(x, y) or xRy to denote that (x, y) ∈ R.

For example, if Z is a set, then inclusion (⊆) is a binary relation over the power set P(Z) of Z and also over the finitary power set Pfin(Z) of Z (i.e., the set of all finite subsets of Z). Viewed as sets, the binary relation ≤ on the set N of nonnegative integers properly contains the relation < on N.

We also have occasion to study n-ary relations over a set S; these are subsets of Sn, the cross-product of S with itself n times. Indeed, these provide one of the starting points of the relational model.

A binary relation R over S is reflexive if (x, x) ∈ R for each x ∈ S; it is symmetric if (x, y) ∈ R implies that (y, x) ∈ R for each x, y ∈ S; and it is transitive if (x, y) ∈ R and (y, z) ∈ R implies that (x, z) ∈ R for each x, y, z ∈ S. A binary relation that is reflexive, symmetric, and transitive is called an equivalence relation. In this case, we associate to each x ∈ S the equivalence class [x]R = {y ∈ S | (x, y) ∈ R}.

10
2.1 Some Basics
11
An example of an equivalence relation on N is modulo for some positive integer n, where (i, j ) ∈ modn if the absolute value |i − j | of the difference of i and j is divisible by n.

A partition of a nonempty set S is a family of sets {Si | i ∈ I } such that (1) ∪i∈I Si = S, (2) Si ∩ Sj = ∅ for i = j , and (3) Si = ∅ for i ∈ I . If R is an equivalence relation on S, then the family of equivalence classes over R is a partition of S.

Let E and E′ be equivalence relations on a nonempty set S. E is a refinement of E′
if E ⊆ E′. In this case, for each x ∈ S we have [x]E ⊆ [x]E′, and, more precisely, each equivalence class of E′ is a disjoint union of one or more equivalence classes of E.

A binary relation R over S is irreflexive if (x, x) ∈ R for each x ∈ S.

A binary relation R is antisymmetric if (y, x) ∈ R whenever x = y and (x, y) ∈ R.

A partial order of S is a binary relation R over S that is reflexive, antisymmetric, and transitive. In this case, we call the ordered pair (S, R) a partially ordered set. A total order is a partial order R over S such that for each x, y ∈ S, either (x, y) ∈ R or (y, x) ∈ R.

For any set Z, the relation ⊆ over P(Z) is a partially ordered set. If the cardinality |Z|
of Z is greater than 1, then this is not a total order. ≤ on N is a total order.

If (S, R) is a partially ordered set, then a topological sort of S (relative to R) is a binary relation R′ on S that is a total order such that R′ ⊇ R. Intuitively, R′ is compatible with R
in the sense that xRy implies xR′y.

Let R be a binary relation over S, and P be a set of properties of binary relations. The P- closure of R is the smallest binary relation R′ such that R′ ⊇ R and R′ satisfies all of the properties in P (if a unique binary relation having this specification exists). For example, it is common to form the transitive closure of a binary relation or the reflexive and transitive closure of a binary relation. In many cases, a closure can be constructed using a recursive procedure. For example, given binary relation R, the transitive closure R+ of R can be obtained as follows:
1. If (x, y) ∈ R then (x, y) ∈ R+;
2. If (x, y) ∈ R+ and (y, z) ∈ R+ then (x, z) ∈ R+; and
3. Nothing is in R+ unless it follows from conditions (1) and (2).

For an arbitrary binary relation R, the reflexive, symmetric, and transitive closure of R
exists and is an equivalence relation.

There is a close relationship between binary relations and graphs. The definitions and notation for graphs presented here have been targeted for their application in this book. A ( directed) graph is a pair G = (V , E), where V is a finite set of vertexes and E ⊆ V × V . In some cases, we define a graph by presenting a set E of edges; in this case, it is understood that the vertex set is the set of endpoints of elements of E.

A directed path in G is a nonempty sequence p = (v0, . . . , vn) of vertexes such that (vi, vi+1) ∈ E for each i ∈ [0, n − 1]. This path is from v0 to vn and has length n.

An undirected path in G is a nonempty sequence p = (v0, . . . , vn) of vertexes such that (vi, vi+1) ∈ E or (vi+1, vi) ∈ E for each i ∈ [0, n − 1]. A (directed or undirected) path is proper if vi = vj for each i = j . A ( directed or undirected) cycle is a (directed or undirected, respectively) path v0, . . . , vn such that vn = v0 and n > 0. A directed cycle is proper if v0, . . . , vn−1 is a proper path. An undirected cycle is proper if v0, . . . , vn−1 is a proper


12
Theoretical Background
path and n > 2. If G has a cycle from v, then G has a proper cycle from v. A graph G = (V , E) is acyclic if it has no cycles or, equivalently, if the transitive closure of E
is irreflexive.

Any binary relation over a finite set can be viewed as a graph. For any finite set Z, the graph (P(Z), ⊆) is acyclic. An interesting directed graph is (M, L), where M is the set of metro stations in Paris and (s1, s2) ∈ L if there is a train in the system that goes from s1 to s2 without stopping in between. Another directed graph is (M, L′), where (s1, s2) ∈ L′ if there is a train that goes from s1 to s2, possibly with intermediate stops.

Let G = (V , E) be a graph. Two vertexes u, v are connected if there is an undirected path in G from u to v, and they are strongly connected if there are directed paths from u to v and from v to u. Connectedness and strong connectedness are equivalence relations on V . A ( strongly) connected component of G is an equivalence class of V under (strong) connectedness. A graph is (strongly) connected if it has exactly one (strongly) connected component.

The graph (M, L) of Parisian metro stations and nonstop links between them is strongly connected. The graph ({a, b, c, d, e}, {(a, b), (b, a), (b, c), (c, d), (d, e), (e, c)}) is connected but not strongly connected.

The distance d(a, b) of two nodes a, b in a graph is the length of the shortest path connecting a to b [d(a, b) = ∞ if a is not connected to b]. The diameter of a graph G is the maximum finite distance between two nodes in G.

A tree is a graph that has exactly one vertex with no in-edges, called the root, and no undirected cycles. For each vertex v of a tree there is a unique proper path from the root to v. A leaf of a tree is a vertex with no outedges. A tree is connected, but it is not strongly connected if it has more than one vertex. A forest is a graph that consists of a set of trees.

Given a forest, removal of one edge increases the number of connected components by exactly one.

An example of a tree is the set of all descendants of a particular person, where (p, p′) is an edge if p′ is the child of p.

In general, we shall focus on directed graphs, but there will be occasions to use undirected graphs. An undirected graph is a pair G = (V , E), where V is a finite set of vertexes and E is a set of two-element subsets of V , again called edges. The notions of path and connected generalize to undirected graphs in the natural fashion.

An example of an undirected graph is the set of all persons with an edge {p, p′} if p is married to p′. As defined earlier, a tree T = (V , E) is a directed graph. We sometimes view T as an undirected graph.

We shall have occasions to label the vertexes or edges of a (directed or undirected) graph. For example, a labeling of the vertexes of a graph G = (V , E) with label set L is a function λ : V → L.

Let G = (V , E) and G′ = (V ′, E′) be two directed graphs. A function h : V → V ′ is a homomorphism from G to G′ if for each pair u, v ∈ V , (u, v) ∈ E implies (h(u), h(v)) ∈
E′. The function h is an isomorphism from G to G′ if h is a one-one onto mapping from V to V ′, h is a homomorphism from G to G′, and h−1 is a homomorphism from G′ to G.

An automorphism on G is an isomorphism from G to G. Although we have defined these terms for directed graphs, they generalize in the natural fashion to other data and algebraic structures, such as relations, algebraic groups, etc.

2.2 Languages, Computability, and Complexity
13
Consider the graph G = ({a, b, c, d, e}, {(a, b), (b, a), (b, c), (b, d), (b, e), (c, d), (d, e), (e, c)}). There are three automorphisms on G: (1) the identity; (2) the function that maps c to d, d to e, e to c and leaves a, b fixed; and (3) the function that maps c to e, d to c, e to d and leaves a, b fixed.

Let S be a set. A permutation of S is a one-one onto function ρ : S → S. Suppose that x1, . . . , xn is an arbitrary, fixed listing of the elements of S (without repeats). Then there is a natural one-one correspondence between permutations ρ on S and listings xi , . . . , x 1
in
of elements of S without repeats. A permutation ρ′ is derived from permutation ρ by an exchange if the listings corresponding to ρ and ρ′ agree everywhere except at some positions i and i + 1, where the values are exchanged. Given two permutations ρ and ρ′, ρ′ can be derived from ρ using a finite sequence of exchanges.

2.2
Languages, Computability, and Complexity
This area provides one of the foundations of theoretical computer science. A general reference for this area is [LP81]. References on automata theory and languages include, for instance, the chapters [BB91, Per91] of [Lee91] and the books [Gin66, Har78]. References on complexity include the chapter [Joh91] of [Lee91] and the books [GJ79, Pap94].

Let # be a finite set called an alphabet. A word over alphabet # is a finite sequence a1 . . . an, where ai ∈ #, 1 ≤ i ≤ n, n ≥ 0. The length of w = a1 . . . an, denoted |w|, is n.

The empty word (n = 0) is denoted by ǫ. The concatenation of two words u = a1 . . . an and v = b1 . . . bk is the word a1 . . . anb1 . . . bk, denoted uv. The concatenation of u with itself n times is denoted un. The set of all words over # is denoted by #∗. A language over # is a subset of #∗. For example, if # = {a, b}, then {anbn | n ≥ 0} is a language over #. The concatenation of two languages L and K is LK = {uv | u ∈ L, v ∈ K}. L concatenated with itself n times is denoted Ln, and L∗ = n≥0 Ln.

Finite Automata
In databases, one can model various phenomena using words over some finite alphabet.

For example, sequences of database events form words over some alphabet of events. More generally, everything is mapped internally to a sequence of bits, which is nothing but a word over alphabet {0, 1}. The notion of computable query is also formalized using a low-level representation of a database as a word.

An important type of computation over words involves acceptance. The objective is to accept precisely the words that belong to some language of interest. The simplest form of acceptance is done using finite-state automata (fsa). Intuitively, fsa process words by scanning the word and remembering only a bounded amount of information about what has already been scanned. This is formalized by computation allowing a finite set of states and transitions among the states, driven by the input. Formally, an fsa M over alphabet #
is a 5-tuple S, #, δ, s0, F , where
• S is a finite set of states;
• δ, the transition function, is a mapping from S × # to S;
14
Theoretical Background
• s0 is a particular state of S, called the start state;
• F is a subset of S called the accepting states.

An fsa S, #, δ, s0, F works as follows. The given input word w = a1 . . . an is read one symbol at a time, from left to right. This can be visualized as a tape on which the input word is written and an fsa with a head that reads symbols from the tape one at a time. The fsa starts in state s0. One move in state s consists of reading the current symbol a in w, moving to a new state δ(s, a), and moving the head to the next symbol on the right. If the fsa is in an accepting state after the last symbol in w has been read, w is accepted. Otherwise it is rejected. The language accepted by an fsa M is denoted L(M).

For example, let M be the fsa
δ
0
1
{even,odd}, {0, 1}, δ, even, {even},
with
even
even
odd
odd
odd
even
The language accepted by M is
L(M) = {w | w has an even number of occurrences of 1}.

A language accepted by some fsa is called a regular language. Not all languages are regular. For example, the language {anbn | n ≥ 0} is not regular. Intuitively, this is so because no fsa can remember the number of a’s scanned in order to compare it to the number of b’s, if this number is large enough, due to the boundedness of the memory.

This property is formalized by the so-called pumping lemma for regular languages.

As seen, one way to specify regular languages is by writing an fsa accepting them.

An alternative, which is often more convenient, is to specify the shape of the words in the language using so-called regular expressions. A regular expression over # is written using the symbols in # and the operations concatenation, ∗ and +. (The operation + stands for union.) For example, the foregoing language L(M) can be specified by the regular expression ((0∗10∗)2)∗ + 0∗. To see how regular languages can model things of interest to databases, think of employees who can be affected by the following events: hire, transfer, quit, fire, retire.

Throughout his or her career, an employee is first hired, can be transferred any number of times, and eventually quits, retires, or is fired. The language whose words are allowable sequences of such events can be specified by a regular expression as hire (transfer)∗ (quit
+ fire + retire). One of the nicest features of regular languages is that they have a dual characterization using fsa and regular expressions. Indeed, Kleene’s theorem says that a language L is regular iff it can be specified by a regular expression.

There are several important variations of fsa that do not change their accepting power.

The first allows scanning the input back and forth any number of times, yielding two-way
2.2 Languages, Computability, and Complexity
15
automata. The second is nondeterminism. A nondeterministic fsa allows several possible next states in a given move. Thus several computations are possible on a given input.

A word is accepted if there is at least one computation that ends in an accepting state.

Nondeterministic fsa (nfsa) accept the same set of languages as fsa. However, the number of states in the equivalent deterministic fsa may be exponential in the number of states of the nondeterministic one. Thus nondeterminism can be viewed as a convenience allowing much more succinct specification of some regular languages.

Turing Machines and Computability
Turing machines (TMs) provide the classical formalization of computation. They are also used to develop classical complexity theory. Turing machines are like fsa, except that symbols can also be overwritten rather than just read, the head can move in either direction, and the amount of tape available is infinite. Thus a move of a TM consists of reading the current tape symbol, overwriting the symbol with a new one from a specified finite tape alphabet, moving the head left or right, and changing state. Like an fsa, a TM can be viewed as an acceptor. The language accepted by a TM M, denoted L(M), consists of the words w such that, on input w, M halts in an accepting state. Alternatively, one can view TM as a generator of words. The TM starts on empty input. To indicate that some word of interest has been generated, the TM goes into some specified state and then continues. Typically, this is a nonterminating computation generating an infinite language.

The set of words so generated by some TM M is denoted G(M). Finally, TMs can also be viewed as computing a function from input to output. A TM M computes a partial mapping f from #∗ to #∗ if for each w ∈ #∗: (1) if w is in the domain of f , then M
halts on input w with the tape containing the word f (w); (2) otherwise M does not halt on input w.

A function f from #∗ to #∗ is computable iff there exists some TM computing it.

Church’s thesis states that any function computable by some reasonable computing device is also computable in the aforementioned sense. So the definition of computability by TMs is robust. In particular, it is insensitive to many variations in the definition of TM, such as allowing multiple tapes. A particularly important variation allows for nondeterminism, similar to nondeterministic fsa. In a nondeterministic TM (NTM), there can be a choice of moves at each step. Thus an NTM has several possible computations on a given input (of which some may be terminating and others not). A word w is accepted by an NTM M if there exists at least one computation of M on w halting in an accepting state.

Another useful variation of the Turing machine is the counter machine. Instead of a tape, the counter machine has two stacks on which elements can be pushed or popped.

The machine can only test for emptiness of each stack. Counter machines can also define all computable functions. An essentially equivalent and useful formulation of this fact is that the language with integer variables i, j, . . . , two instructions increment(i) and decrement(i), and a looping construct while i > 0 do, can define all computable functions on the integers.

Of course, we are often interested in functions on domains other than words—integers are one example. To talk about the computability of such functions on other domains, one goes through an encoding in which each element d of the domain is represented as a word
16
Theoretical Background
enc(d) on some fixed, finite alphabet. Given that encoding, it is said that f is computable if the function enc(f ) mapping enc(d) to enc(f (d)) is computable. This often works without problems, but occasionally it raises tricky issues that are discussed in a few places of this book (particularly in Part E).

It can be shown that a language is L(M) for some acceptor TM M iff it is G(M) for some generator TM M. A language is recursively enumerable (r.e.) iff it is L(M) [or G(M)] for some TM M. L being r.e. means that there is an algorithm that is guaranteed to say eventually yes on input w if w ∈ L but may run forever if w ∈ L (if it stops, it says no).

Thus one can never know for sure if a word is not in L.

Informally, saying that L is recursive means that there is an algorithm that always decides in finite time whether a given word is in L. If L = L(M) and M always halts, L is recursive. A language whose complement is r.e. is called co-r.e. The following useful facts can be shown:
1. If L is r.e. and co-r.e., then it is recursive.

2. L is r.e. iff it is the domain of a computable function.

3. L is r.e. iff it is the range of a computable function.

4. L is recursive iff it is the range of a computable nondecreasing function.1
As is the case for computability, the notion of recursive is used in many contexts that do not explicitly involve languages. Suppose we are interested in some class of objects called thing-a-ma-jigs. Among these, we want to distinguish widgets, which are those thing-a-ma-jigs with some desirable property. It is said that it is decidable if a given thing-a-ma-jig is a widget if there is an algorithm that, given a thing-a-ma-jig, decides in finite time whether the given thing-a-ma-jig is a widget. Otherwise the property is undecidable.

Formally, thing-a-ma-jigs are encoded as words over some finite alphabet. The property of being a widget is decidable iff the language of words encoding widgets is recursive.

We mention a few classical undecidable problems. The halting problem asks if a given TM M halts on a specified input w. This problem is undecidable (i.e., there is no algorithm that, given the description of M and the input w, decides in finite time if M halts on w).

More generally it can be shown that, in some precise sense, all nontrivial questions about TMs are undecidable (this is formalized by Rice’s theorem). A more concrete undecidable problem, which is useful in proofs, is the Post correspondence problem (PCP). The input to the PCP consists of two lists
u1, . . . , un;
v1, . . . , vn;
of words over some alphabet # with at least two symbols. A solution to the PCP is a sequence of indexes i1, . . . , ik, 1 ≤ ij ≤ n, such that
ui . . . u = v . . . v .

1
ik
i1
ik
1 f is nondecreasing if |f (w)| ≥ |w| for each w.

2.2 Languages, Computability, and Complexity
17
The question of interest is whether there is a solution to the PCP. For example, consider the input to the PCP problem:
u1
u2
u3
u4
v1
v2
v3
v4
aba
bbb
aab
bb
a
aaa
abab
babba.

For this input, the PCP has the solution 1, 4, 3, 1; because
u1u4u3u1 = ababbaababa = v1v4v3v1.

Now consider the input consisting of just u1, u2, u3 and v1, v2, v3. An easy case analysis shows that there is no solution to the PCP for this input. In general, it has been shown that it is undecidable whether, for a given input, there exists a solution to the PCP.

The PCP is particularly useful for proving the undecidability of other problems. The proof technique consists of reducing the PCP to the problem of interest. For example, suppose we are interested in the question of whether a given thing-a-ma-jig is a widget.

The reduction of the PCP to the widget problem consists of finding a computable mapping f that, given an input i to the PCP, produces a thing-a-ma-jig f (i) such that f (i) is a widget iff the PCP has a solution for i. If one can find such a reduction, this shows that it is undecidable if a given thing-a-ma-jig is a widget. Indeed, if this were decidable then one could find an algorithm for the PCP: Given an input i to the PCP, first construct the thing-a-ma-jig f (i), and then apply the algorithm deciding if f (i) is a widget. Because we know that the PCP is undecidable, the property of being a widget cannot be decidable. Of course, any other known undecidable problem can be used in place of the PCP.

A few other important undecidable problems are mentioned in the review of context-free grammars.

Complexity
Suppose a particular problem is solvable. Of course, this does not mean the problem has a practical solution, because it may be prohibitively expensive to solve it. Complexity theory studies the difficulty of problems. Difficulty is measured relative to some resources of interest, usually time and space. Again the usual model of reference is the TM. Suppose L is a recursive language, accepted by a TM M that always halts. Let f be a function on positive integers. M is said to use time bounded by f if on every input w, M halts in at most f (|w|) steps. M uses space bounded by f if the amount of tape used by M on every input w is at most f (|w|). The set of recursive languages accepted by TMs using time (space) bounded by f is denoted TIME(f ) (SPACE(f )). Let F be a set of functions on positive integers.

Then TIME(F ) =
TIME(f ), and SPACE(F ) =
SPACE(f ). A particularly
f ∈F
f ∈F
important class of bounding functions is the polynomials Poly. For this class, the following notation has emerged: TIME( Poly) is denoted ptime, and SPACE( Poly) is denoted pspace.

Membership in the class ptime is often regarded as synonymous to tractability (although, of course, this is not reasonable in all situations, and a case-by-case judgment should be made). Besides the polynomials, it is of interest to consider lower bounds, like logarithmic space. However, because the input itself takes more than logarithmic space to write down, a
18
Theoretical Background
separation of the input tape from the tape used throughout the computation must be made.

Thus the input is given on a read-only tape, and a separate worktape is added. Now let logspace consist of the recursive languages L that are accepted by some such TM using on input w an amount of worktape bounded by c × log(|w|) for some constant c.

Another class of time-bounding functions we shall use is the so-called elementary functions. They consist of the set of functions
hyp 0(n) = n
Hyp = { hyp |
i
i ≥ 0},
where
hyp i+1(n) = 2 hyp i(n).

The elementary languages are those in TIME( Hyp).

Nondeterministic TMs can be used to define complexity classes as well. An NTM
uses time bounded by f if all computations on input w halt after at most f (|w|) steps. It uses space bounded by f if all computations on input w use at most f (|w|) space (note that termination is not required). The set of recursive languages accepted by some NTM
using time bounded by a polynomial is denoted np, and space bounded by a polynomial is denoted by npspace. Are nondeterministic classes different from their deterministic counterparts? For polynomial space, Savitch’s theorem settles the question by showing that pspace = npspace (the theorem actually applies to a much more general class of space bounds). For time, things are more complicated. Indeed, the question of whether ptime equals np is the most famous open problem in complexity theory. It is generally conjectured that the two classes are distinct.

The following inclusions hold among the complexity classes described: logspace ⊆ ptime ⊆ np ⊆ pspace ⊂ TIME( Hyp) = SPACE( Hyp).

All nonstrict inclusions are conjectured to be strict.

Complexity classes of languages can be extended, in the same spirit, to complexity classes of computable functions. Here we look at the resources needed to compute the function rather than just accepting or rejecting the input word.

Consider some complexity class, say C = TIME(F ). Such a class contains all problems that can be solved in time bounded by some function in F . This is an upper bound, so C clearly contains some easy and some hard problems. How can the hard problems be distinguished from the easy ones? This is captured by the notion of completeness of a problem in a complexity class. The idea is as follows: A language K in C is complete in C if solving it allows solving all other problems in C, also within C. This is formalized by the notion of reduction. Let L and K be languages in C. L is reducible to K if there is a computable mapping f such that for each w, w ∈ L iff f (w) ∈ K. The definition of reducibility so far guarantees that solving K allows solving L. How about the complexity?

Clearly, if the reduction f is hard then we do not have an acceptance algorithm in C.

Therefore the complexity of f must be bounded. It might be tempting to use C as the bound. However, this allows all the work of solving L within the reduction, which really makes K irrelevant. Therefore the definition of completeness in a class C requires that the complexity of the reduction function be lower than that for C. More formally, a recursive
2.2 Languages, Computability, and Complexity
19
language is complete in C by C′ reductions if for each L ∈ C there is a function f in C′
reducing L to K. The class C′ is often understood for some of the main classes C. The conventions we will use are summarized in the following table:
Type of Completeness
Type of Reduction
p completeness
logspace reductions
np completeness
ptime reductions
pspace completeness
ptime reductions
Note that to prove that a problem L is complete in C by C′ reductions, it is sufficient to exhibit another problem K that is known to be complete in C by C′ reductions, and a C′
reduction from K to L. Because the C′-reducibility relation is transitive for all customarily used C′, it then follows that L is itself C complete by C′ reductions. We mention next a few problems that are complete in various classes.

One of the best-known np-complete problems is the so-called 3-satisfiability (3-SAT) problem. The input is a propositional formula in conjunctive normal form, in which each conjunct has at most three literals. For example, such an input might be (¬x1 ∨ ¬x4 ∨ ¬x2) ∧ (x1 ∨ x2 ∨ x4) ∧ (¬x4 ∨ x3 ∨ ¬x1).

The question is whether the formula is satisfiable. For example, the preceding formula is satisfied with the truth assignment ξ(x1) = ξ(x2) = false, ξ(x3) = ξ(x4) = true. (See Section 2.3 for the definitions of propositional formula and related notions.) A useful pspace-complete problem is the following. The input is a quantified propositional formula (all variables are quantified). The question is whether the formula is true.

For example, an input to the problem is
∃x1∀x2∀x3∃x4[(¬x1 ∨ ¬x4 ∨ ¬x2) ∧ (x1 ∨ x2 ∨ x4) ∧ (¬x4 ∨ x3 ∨ ¬x1)].

A number of well-known games, such as GO, have been shown to be pspace complete.

For ptime completeness, one can use a natural problem related to context-free grammars (defined next). The input is a context-free grammar G and the question is whether L(G) is empty.

Context-Free Grammars
We have discussed specification of languages using two kinds of acceptors: fsa and TM.

Context-free grammars (CFGs) provide different approach to specifying a language that emphasizes the generation of the words in the language rather than acceptance. (Nonetheless, this can be turned into an accepting mechanism by parsing.) A CFG is a 4-tuple N, #, S, P , where
• N is a finite set of nonterminal symbols;
• # is a finite alphabet of terminal symbols, disjoint from N ;
20
Theoretical Background
• S is a distinguished symbol of N , called the start symbol;
• P is a finite set of productions of the form ξ → w, where ξ ∈ N and w ∈ (N ∪ #)∗.

A CFG G = N, #, S, P defines a language L(G) consisting of all words in #∗ that can be derived from S by repeated applications of the productions. An application of the production ξ → w to a word v containing ξ consists of replacing one occurrence of ξ by w. If u is obtained by applying a production to some word v, this is denoted by u ⇒ v, and the transitive closure of ⇒ is denoted ∗
⇒. Thus L(G) = {w | w ∈ #∗, S ∗
⇒ w}. A language
is called context free if it is L(G) for some CFG G. For example, consider the grammar
{S}, {a, b}, S, P , where P consists of the two productions
S → ǫ,
S → aSb.

Then L(G) is the language {anbn | n ≥ 0}. For example the following is a derivation of a2b2:
S ⇒ aSb ⇒ a2Sb2 ⇒ a2b2.

The specification power of CFGs lies between that of fsa’s and that of TMs. First, all regular languages are context free and all context-free languages are recursive. The language {anbn | n ≥ 0} is context free but not regular. An example of a recursive language that is not context free is {anbncn | n ≥ 0}. The proof uses an extension to context-free languages of the pumping lemma for regular languages. We also use a similar technique in some of the proofs.

The most common use of CFGs in the area of databases is to view certain objects as CFGs and use known (un)decidability properties about CFGs. Some questions about CFGs known to be decidable are (1) emptiness [is L(G) empty?] and (2) finiteness [is L(G) finite?]. Some undecidable questions are (3) containment [is it true that L(G1) ⊆ L(G2)?]
and (4) equality [is it true that L(G1) = L(G2)?].

2.3
Basics from Logic
The field of mathematical logic is a main foundation for database theory. It serves as the basis for languages for queries, deductive databases, and constraints. We briefly review the basic notions and notations of mathematical logic and then mention some key differences between this logic in general and the specializations usually considered in database theory.

The reader is referred to [EFT84, End72] for comprehensive introductions to mathematical logic, and to the chapter [Apt91] in [Lee91] and [Llo87] for treatments of Herbrand models and logic programming.

Although some previous knowledge of logic would help the reader understand the content of this book, the material is generally self-contained.



2.3 Basics from Logic
21
Propositional Logic
We begin with the propositional calculus. For this we assume an infinite set of propositional variables, typically denoted p, q, r, . . . , possibly with subscripts. We also permit the special propositional constants true and false. ( Well-formed) propositional formulas are constructed from the propositional variables and constants, using the unary connective negation (¬) and the binary connectives disjunction (∨), conjunction (∧), implication (→), and equivalence (↔). For example, p, (p ∧ (¬q)) and ((p ∨ q) → p) are well-formed propositional formulas. We generally omit parentheses if not needed for understanding a formula.

A truth assignment for a set V of propositional variables is a function ξ : V →
{ true, false}. The truth value ϕ[ξ ] of a propositional formula ϕ under truth assignment ξ
for the variables occurring in ϕ is defined by induction on the structure of ϕ in the natural manner. For example,
• true[ξ ] = true;
• if ϕ = p for some variable p, then ϕ[ξ ] = ξ(p);
• if ϕ = (¬ψ) then ϕ[ξ ] = true iff ψ[ξ ] = false;
• (ψ1 ∨ ψ2)[ξ ] = true iff at least one of ψ1[ξ ] = true or ψ2[ξ ] = true.

If ϕ[ξ ] = true we say that ϕ[ξ ] is true and that ϕ is true under ξ (and similarly for false).

A formula ϕ is satisfiable if there is at least one truth assignment that makes it true, and it is unsatisfiable otherwise. It is valid if each truth assignment for the variables in ϕ
makes it true. The formula (p ∨ q) is satisfiable but not valid; the formula (p ∧ (¬p)) is unsatisfiable; and the formula (p ∨ (¬p)) is valid.

A formula ϕ logically implies formula ψ (or ψ is a logical consequence of ϕ), denoted ϕ |= ψ if for each truth assignment ξ , if ϕ[ξ ] is true, then ψ[ξ ] is true. Formulas ϕ and ψ
are ( logically) equivalent, denoted ϕ ≡ ψ, if ϕ |= ψ and ψ |= ϕ.

For example, (p ∧ (p → q)) |= q. Many equivalences for propositional formulas are well known. For example,
(ϕ1 → ϕ2) ≡ ((¬ϕ1) ∨ ϕ2);
¬(ϕ1 ∨ ϕ2) ≡ (¬ϕ1 ∧ ¬ϕ2);
(ϕ1 ∨ ϕ2) ∧ ϕ3 ≡ (ϕ1 ∧ ϕ3) ∨ (ϕ2 ∧ ϕ3);
ϕ1 ∧ ¬ϕ2 ≡ ϕ1 ∧ (ϕ1 ∧ ¬ϕ2);
(ϕ1 ∨ (ϕ2 ∨ ϕ3)) ≡ ((ϕ1 ∨ ϕ2) ∨ ϕ3).

Observe that the last equivalence permits us to view ∨ as a polyadic connective. (The same holds for ∧.)

A literal is a formula of the form p or ¬p (or true or false) for some propositional variable p. A propositional formula is in conjunctive normal form (CNF) if it has the form ψ1 ∧ · · · ∧ ψn, where each formula ψi is a disjunction of literals. Disjunctive normal form (DNF) is defined analogously. It is known that if ϕ is a propositional formula, then there is some formula ψ equivalent to ϕ that is in CNF (respectively DNF). Note that if ϕ is in CNF (or DNF), then a shortest equivalent formula ψ in DNF (respectively CNF) may have a length exponential in the length of ϕ.

22
Theoretical Background
First-Order Logic
We now turn to first-order predicate calculus. We indicate the main intuitions and concepts underlying first-order logic and describe the primary specializations typically made for database theory. Precise definitions of needed portions of first-order logic are included in Chapters 4 and 5.

First-order logic generalizes propositional logic in several ways. Intuitively, propositional variables are replaced by predicate symbols that range over n-ary relations over an underlying set. Variables are used in first-order logic to range over elements of an abstract set, called the universe of discourse. This is realized using the quantifiers ∃ and ∀. In addition, function symbols are incorporated into the model. The most important definitions used to formalize first-order logic are first-order language, interpretation, logical implication, and provability.

Each first-order language L includes a set of variables, the propositional connectives, the quantifiers ∃ and ∀, and punctuation symbols “)”, “(”, and “,”. The variation in first-order languages stems from the symbols they include to represent constants, predicates, and functions. More formally, a first-order language includes
(a) a (possibly empty) set of constant symbols;
(b) for each n ≥ 0 a (possibly empty) set of n -ary predicate symbols; (c) for each n ≥ 1 a (possibly empty) set of n -ary function symbols.

In some cases, we also include
(d) the equality symbol ≈, which serves as a binary predicate symbol, and the propositional constants true and false. It is common to focus on languages that are finite, except for the set of variables.

A familiar first-order language is the language LN of the nonnegative integers, with (a) constant symbol 0;
(b) binary predicate symbol ≤;
(c) binary function symbols +, ×, and unary S (successor);
and the equality symbol.

Let L be a first-order language. Terms of L are built in the natural fashion from constants, variables, and the function symbols. An atom is either true, false, or an expression of the form R(t1, . . . , tn), where R is an n-ary predicate symbol and t1, . . . , tn are terms. Atoms correspond to the propositional variables of propositional logic. If the equality symbol is included, then atoms include expressions of the form t1 ≈ t2. The family of ( well-formed predicate calculus) formulas over L is defined recursively starting with atoms, using the Boolean connectives, and using the quantifiers as follows: If ϕ is a formula and x a variable, then (∃xϕ) and (∀xϕ) are formulas. As with the propositional case, parentheses are omitted when understood from the context. In addition, ∨ and ∧ are viewed as polyadic connectives. A term or formula is ground if it involves no variables.

Some examples of formulas in LN are as follows:
2.3 Basics from Logic
23
∀x(0 ≤ x),
¬(x ≈ S(x)),
¬∃x(∀y(y ≤ x)),
∀y∀z(x ≈ y × z → (y ≈ S(0) ∨ z ≈ S(0))).

(For some binary predicates and functions, we use infix notation.)

The notion of the scope of quantifiers and of free and bound occurrences of variables in formulas is now defined using recursion on the structure. Each variable occurrence in an atom is free. If ϕ is (ψ1 ∨ ψ2), then an occurrence of variable x in ϕ is free if it is free as an occurrence of ψ1 or ψ2; and this is extended to the other propositional connectives. If ϕ
is ∃yψ, then an occurrence of variable x = y is free in ϕ if the corresponding occurrence is free in ψ. Each occurrence of y is bound in ϕ. In addition, each occurrence of y in ϕ that is free in ψ is said to be in the scope of ∃y at the beginning of ϕ. A sentence is a well-formed formula that has no free variable occurrences.

Until now we have not given a meaning to the symbols of a first-order language and thereby to first-order formulas. This is accomplished with the notion of interpretation, which corresponds to the truth assignments of the propositional case. Each interpretation is just one of the many possible ways to give meaning to a language.

An interpretation of a first-order language L is a 4-tuple I = (U, C, P, F ) where U
is a nonempty set of abstract elements called the universe ( of discourse), and C, P, and F
give meanings to the sets of constant symbols, predicate symbols, and function symbols.

For example, C is a function from the constant symbols into U , and P maps each n-ary predicate symbol p into an n-ary relation over U (i.e., a subset of U n). It is possible for two distinct constant symbols to map to the same element of U .

When the equality symbol denoted ≈ is included, the meaning associated with it is restricted so that it enjoys properties usually associated with equality. Two equivalent mechanisms for accomplishing this are described next.

Let I be an interpretation for language L. As a notational shorthand, if c is a constant symbol in L, we use cI to denote the element of the universe associated with c by I. This is extended in the natural way to ground terms and atoms.

The usual interpretation for the language LN is IN, where the universe is N; 0 is mapped to the number 0; ≤ is mapped to the usual less than or equal relation; S is mapped to successor; and + and × are mapped to addition and multiplication. In such cases, we have, for example, [S(S(0) + 0))]IN ≈ 2.

As a second example related to logic programming, we mention the family of Herbrand interpretations of LN. Each of these shares the same universe and the same mappings for the constant and function symbols. An assignment of a universe, and for the constant and function symbols, is called a preinterpretation. In the Herbrand preinterpretation for LN, the universe, denoted UL , is the set containing 0 and all terms that can be constructed N
from this using the function symbols of the language. This is a little confusing because the terms now play a dual role—as terms constructed from components of the language L, and as elements of the universe UL . The mapping C maps the constant symbol 0 to 0 (consid-N
ered as an element of UL ). Given a term t in U , the function F(S) maps t to the term S(t).

N
Given terms t1 and t2, the function F(+) maps the pair (t1, t2) to the term +(t1, t2), and the function F (×) is defined analogously.

The set of ground atoms of LN (i.e., the set of atoms that do not contain variables) is sometimes called the Herbrand base of LN. There is a natural one-one correspondence


24
Theoretical Background
between interpretations of LN that extend the Herbrand preinterpretation and subsets of the Herbrand base of LN. One Herbrand interpretation of particular interest is the one that mimics the usual interpretation. In particular, this interpretation maps ≤ to the set
{
I
I
(t
N
N
1, t2) | (t
, t
) ∈ ≤IN}.

1
2
We now turn to the notion of satisfaction of a formula by an interpretation. The definition is recursive on the structure of formulas; as a result we need the notion of variable assignment to accommodate variables occurring free in formulas. Let L be a language and I an interpretation of L with universe U . A variable assignment for formula ϕ is a partial function µ : variables of L → U whose domain includes all variables free in ϕ. For terms t, t I,µ denotes the meaning given to t by I, using µ to interpret the free variables. In addition, if µ is a variable assignment, x is a variable, and u ∈ U , then µ[x/u] denotes the variable assignment that is identical to µ, except that it maps x to u. We write I |= ϕ[µ] to indicate that I satisfies ϕ under µ. This is defined recursively on the structure of formulas in the natural fashion. To indicate the flavor of the definition, we note that I |= p(t1, . . . , tn)[µ] if I,µ
I,µ
(t
, . . . , t
1
n
) ∈ pI; I |= ∃xψ[µ] if there is some u ∈ U such that I |= ψ[µ[x/u]]; and I |= ∀xψ[µ] if for each u ∈ U , I |= ψ[µ[x/u]]. The Boolean connectives are interpreted in the usual manner. If ϕ is a sentence, then no variable assignment needs to be specified.

For example, IN |= ∀x∃y(¬(x ≈ y) ∨ x ≤ y); IN |= S(0) ≤ 0; and IN |= ∀y∀z(x ≈ y × z → (y ≈ S(0) ∨ z ≈ S(0)))[µ]
iff µ(x) is 1 or a prime number.

An interpretation I is a model of a set 7 of sentences if I satisfies each formula in 7.

The set 7 is satisfiable if it has a model.

Logical implication and equivalence are now defined analogously to the propositional case. Sentence ϕ logically implies sentence ψ, denoted ϕ |= ψ, if each interpretation that satisfies ϕ also satisfies ψ. There are many straightforward equivalences [e.g., ¬(¬ϕ) ≡ ϕ
and ¬∀xϕ ≡ ∃x¬ϕ]. Logical implication is generalized to sets of sentences in the natural manner.

It is known that logical implication, considered as a decision problem, is not recursive.

One of the fundamental results of mathematical logic is the development of effective procedures for determining logical equivalence. These are based on the notion of proofs, and they provide one way to show that logical implication is r.e. One style of proof, attributed to Hilbert, identifies a family of inference rules and a family of axioms. An example of an inference rule is modus ponens, which states that from formulas ϕ and ϕ → ψ we may conclude ψ. Examples of axioms are all tautologies of propositional logic
[e.g., ¬(ϕ ∨ ψ) ↔ (¬ϕ ∧ ¬ψ) for all formulas ϕ and ψ], and substitution (i.e., ∀xϕ →
ϕx, where
denotes the formula obtained by simultaneously
t
t is an arbitrary term and ϕxt
replacing all occurrences of x free in ϕ by t). Given a family of inference rules and axioms, a proof that set 7 of sentences implies sentence ϕ is a finite sequence ψ0, ψ1, . . . , ψn = ϕ, where for each i, either ψi is an axiom, or a member of 7, or it follows from one or more of the previous ψj ’s using an inference rule. In this case we write 7 ⊢ ϕ.

The soundness and completeness theorem of Gödel shows that (using modus ponens and a specific set of axioms) 7 |= ϕ iff 7 ⊢ ϕ. This important link between |= and ⊢
permits the transfer of results obtained in model theory, which focuses primarily on in-
2.3 Basics from Logic
25
terpretations and models, and proof theory, which focuses primarily on proofs. Notably, a central issue in the study of relational database dependencies (see Part C) has been the search for sound and complete proof systems for subsets of first-order logic that correspond to natural families of constraints.

The model-theoretic and proof-theoretic perspectives lead to two equivalent ways of incorporating equality into first-order languages. Under the model-theoretic approach, the equality predicate ≈ is given the meaning {(u, u) | u ∈ U } (i.e., normal equality). Under the proof-theoretic approach, a set of equality axioms EQL is constructed that express the intended meaning of ≈. For example, EQL includes the sentences ∀x, y, z(x ≈ y ∧ y ≈
z → x ≈ z) and ∀x, y(x ≈ y → (R(x) ↔ R(y)) for each unary predicate symbol R.

Another important result from mathematical logic is the compactness theorem, which can be demonstrated using Gödel’s soundness and completeness result. There are two common ways of stating this. The first is that given a (possibly infinite) set of sentences 7, if 7 |= ϕ then there is a finite 7′ ⊆ 7 such that 7′ |= ϕ. The second is that if each finite subset of 7 is satisfiable, then 7 is satisfiable.

Note that although the compactness theorem guarantees that the 7 in the preceding paragraph has a model, that model is not necessarily finite. Indeed, 7 may only have infinite models. It is of some solace that, among those infinite models, there is surely at least one that is countable (i.e., whose elements can be enumerated: a1, a2, . . .). This technically useful result is the Löwenheim-Skolem theorem.

To illustrate the compactness theorem, we show that there is no set 9 of sentences defining the notion of connectedness in directed graphs. For this we use the language L
with two constant symbols, a and b, and one binary relation symbol R, which corresponds to the edges of a directed graph. In addition, because we are working with general first-order logic, both finite and infinite graphs may arise. Suppose now that 9 is a set of sentences that states that a and b are connected (i.e., that there is a directed path from a to b in R). Let # = {σi | i > 0}, where σi states “a and b are at least i edges apart from each other.” For example, σ3 might be expressed as
¬R(a, b) ∧ ¬∃x1(R(a, x1) ∧ R(x1, b)).

It is clear that each finite subset of 9 ∪ # is satisfiable. By the compactness theorem (second statement), this implies that 9 ∪ # is satisfiable, so it has a model (say, I). In I, there is no directed path between (the elements of the universe identified by) a and b, and so I |= 9. This is a contradiction.

Specializations to Database Theory
We close by mentioning the primary differences between the general field of mathematical logic and the specializations made in the study of database theory. The most obvious specialization is that database theory has not generally focused on the use of functions on data values, and as a result it generally omits function symbols from the first-order languages used. The two other fundamental specializations are the focus on finite models and the special use of constant symbols.

An interpretation is finite if its universe of discourse is finite. Because most databases
26
Theoretical Background
are finite, most of database theory is focused exclusively on finite interpretations. This is closely related to the field of finite model theory in mathematics.

The notion of logical implication for finite interpretations, usually denoted |=fin, is not equivalent to the usual logical implication |=. This is most easily seen by considering the compactness theorem. Let 7 = {σi | i > 0}, where σi states that there are at least i distinct elements in the universe of discourse. Then by compactness, 7 |= false, but by the definition of finite interpretation, 7 |=fin false.

Another way to show that |= and |=fin are distinct uses computability theory. It is known that |= is r.e. but not recursive, and it is easily seen that |=fin is co-r.e. Thus if they were equal, |= would be recursive, a contradiction.

The final specialization of database theory concerns assumptions made about the universe of discourse and the use of constant symbols. Indeed, throughout most of this book we use a fixed, countably infinite set of constants, denoted dom (for domain elements).

Furthermore, the focus is almost exclusively on finite Herbrand interpretations over dom.

In particular, for distinct constants c and c′, all interpretations that are considered satisfy
¬c ≈ c′.

Most proofs in database theory involving the first-order predicate calculus are based on model theory, primarily because of the emphasis on finite models and because the link between |=fin and ⊢ does not hold. It is thus informative to identify a mechanism for using traditional proof-theoretic techniques within the context of database theory. For this discussion, consider a first-order language with set dom of constant symbols and predicate symbols R1, . . . , Rn. As will be seen in Chapter 3, a database instance is a finite Herbrand interpretation I of this language. Following [Rei84], a family #I of sentences is associated with I. This family includes the axioms of equality (mentioned earlier) and Atoms: Ri($
a) for each $
a in RI.

i
Extension axioms: ∀$
x(Ri($
x) ↔ ($
x ≈ $
a1 ∨ · · · ∨ $
x ≈ $
am)), where $
a1, . . . , $am is a listing of
all elements of RI, and we are abusing notation by letting ≈ range over vectors of i
terms.

Unique Name axioms: ¬c ≈ c′ for each distinct pair c, c′ of constants occurring in I.

Domain Closure axiom: ∀x(x ≈ c1 ∨ · · · ∨ x ≈ cn), where c1, . . . , cn is a listing of all constants occurring in I.

A set of sentences obtained in this manner is termed an extended relational theory.

The first two sets of sentences of an extended relational theory express the specific contents of the relations (predicate symbols) of I. Importantly, the Extension sentences ensure that for any (not necessarily Herbrand) interpretation J satisfying #I, an n-tuple is in RJ iff it equals one of the n-tuples in RI. The Unique Name axiom ensures that no pair of i
i
distinct constants is mapped to the same element in the universe of J , and the Domain Closure axiom ensures that each element of the universe of J equals some constant occurring in I. For all intents and purposes, then, any interpretation J that models #I is isomorphic to I, modulo condensing under equivalence classes induced by ≈J . Importantly, the following link with conventional logical implication now holds: For any set Ŵ of sentences, I |= Ŵ iff #I ∪ Ŵ is satisfiable. The perspective obtained through this connection with clas-
2.3 Basics from Logic
27
sical logic is useful when attempting to extend the conventional relational model (e.g., to incorporate so-called incomplete information, as discussed in Chapter 19).

The Extension axioms correspond to the intuition that a tuple $
a is in relation R only
if it is explicitly included in R by the database instance. A more general formulation of this intuition is given by the closed world assumption (CWA) [Rei78]. In its most general formulation, the CWA is an inference rule that is used in proof-theoretic contexts. Given a set # of sentences describing a (possibly nonconventional) database instance, the CWA states that one can infer a negated atom R($
a) if # ⊢ R($
a) [i.e., if one cannot prove R($
a)
from # using conventional first-order logic]. In the case where # is an extended relational theory this gives no added information, but in other contexts (such as deductive databases) it does. The CWA is related in spirit to the negation as failure rule of [Cla78].

3 TheRelationalModel
Alice:
What is a relation?

Vittorio:
You studied that in math a long time ago.

Sergio:
It is just a table.

Riccardo:
But we have several ways of viewing it.

A databasemodel providesthemeansforspecifyingparticulardatastructures,forcon-straining the data sets associated with these structures, and for manipulating the data.

The specification of structure and constraints is done using a data definition language (DDL), and the specification of manipulation is done using a data manipulation language (DML). The most prominent structures that have been used for databases to date are graphs in the network, semantic, and object-oriented models; trees in the hierarchical model; and relations in the relational model.

DMLs provide two fundamental capabilities: querying to support the extraction of data from the current database; and updating to support the modification of the database state.

There is a rich theory on the topic of querying relational databases that includes several languages based on widely different paradigms. This theory is the focus of Parts B, D, and E, and portions of Part F of this book. The theory of database updates has received considerably less attention and is touched on in Part F.

The term relational model is actually rather vague. As introduced in Codd’s seminal article, this term refers to a specific data model with relations as data structures, an algebra for specifying queries, and no mechanisms for expressing updates or constraints.

Subsequent articles by Codd introduced a second query language based on the predicate calculus of first-order logic, showed this to be equivalent to the algebra, and introduced the first integrity constraints for the relational model—namely, functional dependencies. Soon thereafter, researchers in database systems implemented languages based on the algebra and calculus, extended to include update operators and to include practically motivated features such as arithmetic operators, aggregate operators, and sorting capabilities. Researchers in database theory developed a number of variations on the algebra and calculus with varying expressive power and adapted the paradigm of logic programming to provide a third approach to querying relational databases. The story of integrity constraints for the relational model is similar: A rich theory of constraints has emerged, and two distinct but equivalent perspectives have been developed that encompass almost all of the constraints that have been investigated formally. The term relational model has thus come to refer to the broad class of database models that have relations as the data structure and that incorporate some or all of the query capabilities, update capabilities, and integrity constraints 28
3.1 The Structure of the Relational Model
29
mentioned earlier. In this book we are concerned primarily with the relational model in this broad sense.

Relations are simple data structures. As a result, it is easy to understand the conceptual underpinnings of the relational model, thus making relational databases accessible to a broad audience of end users. A second advantage of this simplicity is that clean yet powerful declarative languages can be used to manipulate relations. By declarative, we mean that a query/program is specified in a high-level manner and that an efficient execution of the program does not have to follow exactly its specification. Thus the important practical issues of compilation and optimization of queries had to be overcome to make relational databases a reality.

Because of its simplicity, the relational model has provided an excellent framework for the first generation of theoretical research into the properties of databases. Fundamental aspects of data manipulation and integrity constraints have been exposed and studied in a context in which the peculiarities of the data model itself have relatively little impact. This research provides a strong foundation for the study of other database models, first because many theoretical issues pertinent to other models can be addressed effectively within the relational model, and second because it provides a variety of tools, techniques, and research directions that can be used to understand the other models more deeply.

In this short chapter, we present formal definitions for the data structure of the relational model. Theoretical research on the model has grown out of three different perspectives, one corresponding most closely to the natural usage of relations in databases, another stemming from mathematical logic, and the third stemming from logic programming. Because each of these provides important intuitive and notational benefits, we introduce notation that encompasses the different but equivalent formulations reflecting each of them.

3.1
The Structure of the Relational Model
An example of a relational database is shown in Fig. 3.11. Intuitively, the data is represented in tables in which each row gives data about a specific object or set of objects, and rows with uniform structure and intended meaning are grouped into tables. Updates consist of transformations of the tables by addition, removal, or modification of rows. Queries allow the extraction of information from the tables. A fundamental feature of virtually all relational query languages is that the result of a query is also a table or collection of tables.

We introduce now some informal terminology to provide the intuition behind the formal definitions that follow. Each table is called a relation and it has a name (e.g., Movies). The columns also have names, called attributes (e.g, Title). Each line in a table is a tuple (or record). The entries of tuples are taken from sets of constants, called domains, that include, for example, the sets of integers, strings, and Boolean values. Finally we distinguish between the database schema, which specifies the structure of the database; and the database instance, which specifies its actual content. This is analogous to the standard distinction between type and value found in programming languages (e.g., an 1 Pariscope is a weekly publication that lists the cultural events occurring in Paris and environs.

30
The Relational Model
Movies
Title
Director
Actor
The Trouble with Harry
Hitchcock
Gwenn
The Trouble with Harry
Hitchcock
Forsythe
The Trouble with Harry
Hitchcock
MacLaine
The Trouble with Harry
Hitchcock
Hitchcock
· · ·
· · ·
· · ·
Cries and Whispers
Bergman
Andersson
Cries and Whispers
Bergman
Sylwan
Cries and Whispers
Bergman
Thulin
Cries and Whispers
Bergman
Ullman
Location
Theater
Address
Phone Number
Gaumont Opéra
31 bd. des Italiens
47 42 60 33
Saint André des Arts
30 rue Saint André des Arts
43 26 48 18
Le Champo
51 rue des Ecoles
43 54 51 60
· · ·
· · ·
· · ·
Georges V
144 av. des Champs-Elysées
45 62 41 46
Les 7 Montparnassiens
98 bd. du Montparnasse
43 20 32 20
Pariscope
Theater
Title
Schedule
Gaumont Opéra
Cries and Whispers
20:30
Saint André des Arts
The Trouble with Harry
20:15
Georges V
Cries and Whispers
22:15
· · ·
· · ·
· · ·
Les 7 Montparnassiens
Cries and Whispers
20:45
Figure 3.1:
The CINEMA database
identifier X might have type record A : int, B : bool endrecord and value record A : 5, B : true endrecord).

We now embark on the formal definitions. We assume that a countably infinite set att of attributes is fixed. For a technical reason that shall become apparent shortly, we assume that there is a total order ≤att on att. When a set U of attributes is listed, it is assumed that the elements of U are written according to ≤att unless otherwise specified.

For most of the theoretical development, it suffices to use the same domain of values for all of the attributes. Thus we now fix a countably infinite set dom (disjoint from att), called the underlying domain. A constant is an element of dom. When different attributes should have distinct domains, we assume a mapping Dom on att, where Dom(A) is a set called the domain of A.

3.2 Named versus Unnamed Perspectives
31
We assume a countably infinite set relname of relation names disjoint from the previous sets. In practice, the structure of a table is given by a relation name and a set of attributes. To simplify the notation in the theoretical treatment, we now associate a sort (i.e., finite set of attributes) to each relation name. (An analogous approach is usually taken in logic.) In particular, we assume that there is a function sort from relname to Pfin(att) (the finitary powerset of att; i.e., the family of finite subsets of att). It is assumed that sort has the property that for each (possibly empty) finite set U of attributes, sort−1(U ) is infinite. This allows us to use as many relation names of a given sort as desired. The sort of a relation name is simply sort(R). The arity of a relation name R is arity(R) = | sort(R)|.

A relation schema is now simply a relation name R. We sometimes write this as R[U ]
to indicate that sort(R) = U , or R[n], to indicate that arity(R) = n. A database schema is a nonempty finite set R of relation names. This might be written R = {R1[U1], . . . , Rn[Un]}
to indicate the relation schemas in R.

For example, the database schema CINEMA for the database shown in Fig. 3.1 is defined by
CINEMA = { Movies, Location, Pariscope}
where relation names Movies, Location, and Pariscope have the following sorts: sort( Movies)
= { Title, Director, Actor}
sort( Location) = { Theater, Address, Phone Number}
sort( Pariscope) = { Theater, Title, Schedule}.

We often omit commas and set brackets in sets of attributes. For example, we may write sort( Pariscope) = Theater Title Schedule.

The formalism that has emerged for the relational model is somewhat eclectic, because it is intimately connected with several other areas that have their own terminology, such as logic and logic programming. Because the slightly different formalisms are well entrenched, we do not attempt to replace them with a single, unified notation. Instead we will allow the coexistence of the different notations; the reader should have no difficulty dealing with the minor variations.

Thus there will be two forks in the road that lead to different but largely equivalent formulations of the relational model. The first fork in the road to defining the relational model is of a philosophical nature. Are the attribute names associated with different relation columns important?

3.2
Named versus Unnamed Perspectives
Under the named perspective, these attributes are viewed as an explicit part of a database schema and may be used (e.g., by query languages and dependencies). Under the unnamed
32
The Relational Model
perspective, the specific attributes in the sort of a relation name are ignored, and only the arity of a relation schema is available (e.g., to query languages).

In the named perspective, it is natural to view tuples as functions. More precisely, a tuple over a (possibly empty) finite set U of attributes (or over a relation schema R[U ]) is a total mapping u from U to dom. In this case, the sort of u is U , and it has arity |U |.

Tuples may be written in a linear syntax using angle brackets—for example, A : 5, B : 3.

(In general, the order used in the linear syntax will correspond to ≤att, although that is not necessary.) The unique tuple over ∅ is denoted .

Suppose that u is a tuple over U . As usual in mathematics, the value of u on an attribute A in U is denoted u(A). This is extended so that for V ⊆ U , u[V ] denotes the tuple v over V such that v(A) = u(A) for each A ∈ V (i.e., u[V ] = u|V , the restriction of the function u to V ).

With the unnamed perspective, it is more natural to view a tuple as an element of a Cartesian product. More precisely, a tuple is an ordered n-tuple (n ≥ 0) of constants (i.e., an element of the Cartesian product domn). The arity of a tuple is the number of coordinates that it has. Tuples in this context are also written with angle brackets (e.g., 5, 3). The ith coordinate of a tuple u is denoted u(i). If relation name R has arity n, then a tuple over R
is a tuple with arity arity(R).

Because of the total order ≤att, there is a natural correspondence between the named and unnamed perspectives. A tuple A1 : a1, A2 : a2 (defined as a function) can be viewed (assuming A1 ≤att A2) as an ordered tuple with (A1 : a1) as a first component and (A2 : a2) as a second one. Ignoring the names, this tuple may simply be viewed as the ordered tuple a1, a2. Conversely, the ordered tuple t = a1, a2 may be interpreted as a function over the set {1, 2} of integers with t (i) = ai for each i. This correspondence will allow us to blur the distinction between the two perspectives and move freely from one to the other when convenient.

3.3
Conventional versus Logic Programming Perspectives
We now come to the second fork in the road to defining the relational model. This fork concerns how relation and database instances are viewed, and it is essentially independent of the perspective taken on tuples. Under the conventional perspective, a relation or relation instance of (or over) a relation schema R[U ] (or over a finite set U of attributes) is a (possibly empty) finite set I of tuples with sort U . In this case, I has sort U and arity
|U |. Note that there are two instances over the empty set of attributes: {} and {}.

Continuing with the conventional perspective, a database instance of database schema R is a mapping I with domain R, such that I(R) is a relation over R for each R ∈ R.

The other perspective for defining instances stems from logic programming. This perspective is used primarily with the ordered-tuple perspective on tuples, and so we focus on that here. Let R be a relation with arity n. A fact over R is an expression of the form R(a1, . . . , an), where ai ∈ dom for i ∈ [1, n]. If u = a1, . . . , an, we sometimes write R(u) for R(a1, . . . , an). Under the logic-programming perspective, a relation ( instance) over R is a finite set of facts over R. For a database schema R, a database instance is a finite set I that is the union of relation instances over R, for R ∈ R. This perspective on
3.3 Conventional versus Logic Programming Perspectives 33
instances is convenient when working with languages stemming from logic programming, and it permits us to write database instances in a convenient linear form.

The two perspectives provide alternative ways of describing essentially the same data.

For instance, assuming that sort(R) = AB and sort(S) = A, we have the following four representations of the same database:
Named and Conventional
I (R) = {f1, f2, f3}
f1(A) = a
f1(B) = b
f2(A) = c
f2(B) = b
f3(A) = a
f3(A) = a
I (S) = {g}
g(A) = d
Unnamed and Conventional
I (R) = {a, b, c, b, a, a}
I (S) = {d}
Named and Logic Programming
{R(A : a, B : b), R(A : c, B : b), R(A : a, B : a), S(A : d)}
Unnamed and Logic Programming
{R(a, b), R(c, b), R(a, a), S(d)}.

Because relations can be viewed as sets, it is natural to consider, given relations of the same sort, the standard set operations union (∪), intersection (∩), and difference (−) and the standard set comparators ⊂, ⊆, =, and =. With the logic-programming perspective on instances, we may also use these operations and comparators on database instances.

Essentially all topics in the theory of relational database can be studied using a fixed choice for the two forks. However, there are some cases in which one perspective is much more natural than the other or is technically much more convenient. For example, in a context in which there is more than one relation, the named perspective permits easy and natural specification of correspondences between columns of different relations whereas the unnamed perspective does not. As will be seen in Chapter 4, this leads to different but equivalent sets of natural primitive algebra operators for the two perspectives. A related example concerns those topics that involve the association of distinct domains to different relation columns; again the named perspective is more convenient. In addition, although relational dependency theory can be developed for the unnamed perspective, the motivation is much more natural when presented in the named perspective. Thus during the course of this book the choice of perspective during a particular discussion will be motivated primarily by the intuitive or technical convenience offered by one or the other.

In this book, we will need an infinite set var of variables that will be used to range over elements of dom. We generalize the notion of tuple to permit variables in coordinate positions: a free tuple over U or R[U ] is (under the named perspective) a function u from U to var ∪ dom. An atom over R is an expression R(e1, . . . , en), where n = arity(R) and
34
The Relational Model
ei is term (i.e., ei ∈ var ∪ dom for each i ∈ [1, n]). Following the terminology of logic and logic programming, we sometimes refer to a fact as a ground atom.

3.4
Notation
We generally use the following symbols, possibly with subscripts:
Constants
a, b, c
Variables
x, y
Sets of variables
X, Y
Terms
e
Attributes
A, B, C
Sets of attributes
U, V , W
Relation names (schemas)
R, S; R[U ], S[V ]
Database schemas
R, S
Tuples
t, s
Free tuples
u, v, w
Facts
R(a1, . . . , an), R(t)
Atoms
R(e1, . . . , en), R(u)
Relation instances
I, J
Database instances
I, J
Bibliographic Notes
The relational model is founded on mathematical logic (in particular, predicate calculus). It is one of the rare cases in which substantial theoretical development preceded the implementation of systems. The first proposal to use predicate calculus as a query language can be traced back to Kuhns [Kuh67]. The relational model itself was introduced by Codd [Cod70]. There are numerous commercial database systems based on the relational model. They include IBM’s DBZ, [A+76], INGRES [SWKH76], and ORACLE [Ora89], Informix, and Sybase.

Other data models have been proposed and implemented besides the relational model.

The most prominent ones preceding the relational model are the hierarchical and network models. These and other models are described in the books [Nij76, TL82]. More recently, various models extending the relational model have been proposed. They include semantic models (see the survey [HK87]) and object-oriented models (see the position paper
[ABD+89]). In this book we focus primarily on the relational model in a broad sense. Some formal aspects of other models are considered in Part F.

4 ConjunctiveQueries
Alice:
Shall we start asking queries?

Sergio:
Very simple ones for the time being.

Riccardo:
But the system will answer them fast.

Vittorio:
And there is some nice theory.

In this chapter we embark on the study of queries for relational databases, a rich topic that spans a good part of this book. This chapter focuses on a limited but extremely natural and commonly arising class of queries called conjunctive queries. Five equivalent versions of this query family are presented here: one from each of the calculus and datalog paradigms, two from the algebra paradigm, and a final one that has a more visual form.

In the context of conjunctive queries, the three nonalgebraic versions can be viewed as minor syntactic variants of each other; but these similarities diminish as the languages are generalized to incorporate negation and/or recursion. This chapter also discusses query composition and its interaction with user views, and it extends conjunctive queries in a straightforward manner to incorporate union (or disjunction).

The conjunctive queries enjoy several desirable properties, including, for example, decidability of equivalence and containment. These results will be presented in Chapter 6, in which a basic tool, the Homomorphism Theorem, is developed. Most of these results extend to conjunctive queries with union.

In the formal framework that we have developed in this book, we distinguish between a query, which is a syntactic object, and a query mapping, which is the function defined by a query interpreted under a specified semantics. However, we often blur these two concepts when the meaning is clear from the context. In the relational model, query mappings generally have as domain the family of all instances of a specified relation or database schema, called the input schema; and they have as range the family of instances of an output schema, which might be a database schema or a relation schema. In the latter case, the relation name may be specified as part of the syntax of the query or by the context, or it may be irrelevant to the discussion and thus not specified at all. We generally say that a query (mapping) is from (or over) its input schema to its output schema. Finally, two queries q1 and q2 over R are equivalent, denoted q1 ≡ q2, if they have the same output schema and q1(I) = q2(I) for each instance I over R.

This chapter begins with an informal discussion that introduces a family of simple queries and illustrates one approach to expressing them formally. Three versions of conjunctive queries are then introduced, and all of them have a basis in logic. Then a brief 37
38
Conjunctive Queries
(4.1)
Who is the director of “Cries and Whispers”?

(4.2)
Which theaters feature “Cries and Whispers”?

(4.3)
What are the address and phone number of the Le Champo?

(4.4)
List the names and addresses of theaters featuring a Bergman film.

(4.5)
Is a film directed by Bergman playing in Paris?

(4.6)
List the pairs of persons such that the first directed the second in a movie, and vice versa.

(4.7)
List the names of directors who have acted in a movie they directed.

(4.8)
List pairs of actors that acted in the same movie.

(4.9)
On any input produce “Apocalypse Now”, “Coppola” as the answer.

(4.10)
Where can I see “Annie Hall” or “Manhattan”?

(4.11)
What are the films with Allen as actor or director?

(4.12)
What films with Allen as actor or director are currently featured at the Concorde?

(4.13)
List all movies that were directed by Hitchcock or that are currently playing at the Rex.

(4.14)
List all actors and director of the movie “Apocalypse Now.”
Figure 4.1:
Examples of conjunctive queries, some of which require union
digression is made to consider query composition and database views. The algebraic perspectives on conjunctive queries are then given, along with the theorem showing the equivalence of all five approaches to conjunctive queries. Finally, various forms of union and disjunction are added to the conjunctive queries.

4.1
Getting Started
To present the intuition of conjunctive queries, consider again the CINEMA database of Chapter 3. The following correspond to conjunctive queries:
(4.1)
Who is the director of “Cries and Whispers”?

(4.2)
Which theaters feature “Cries and Whispers”?

(4.3)
What are the address and phone number of the Le Champo?

These and other queries used in this section are gathered in Fig. 4.1. Each of the queries just given calls for extracting information from a single relation. In contrast, queries (4.4) through (4.7) involve more than one relation.

In queries (4.1–4.4 and 4.6–4.9), the database is asked to find values or tuples of values for which a certain pattern of data holds in the database, and in query (4.5) the database is asked whether a certain pattern of data holds. We shall see that the patterns can be described simply in terms of the existence of tuples that are connected to each other by equality of some of their coordinates. On the other hand, queries (4.10) through (4.14) cannot be expressed in this manner unless some form of disjunction or union is incorporated.

4.1 Getting Started
39
Example 4.1.1
Consider query (4.4). Intuitively, we express this query by stating that if there are tuples r1, r2, r3 respectively in relations
Movies, Pariscope, Location such that
the Director in r1 is “Bergman”
and the Titles in tuple r1 and r2 are the same
and the Theaters in tuple r2 and r3 are the same
then we want the Theater and Address coordinates from tuple r3.

In this formulation we essentially use variables that range over tuples. Although this is the basis of the so-called ( relational) tuple calculus (see Exercise 5.23 in the next chapter), the focus of most theoretical investigations has been on the domain calculus, which uses variables that range over constants rather than tuples. This also reflects the convention followed in the predicate calculus of first-order logic. Thus we reformulate the preceding query as
if there are tuples xti, “Bergman”, xac, xth, xti, xs, and xth, xad, xp, respectively, in relations Movies, Pariscope, and Location then include the tuple Theater : xth, Address : xad in the answer, where xti, xac, . . . are variables. Note that the equalities specified in the first formulation are achieved implicitly in the second formulation through multiple occurrences of variables.

The translation of this into the syntax of rule-based conjunctive queries is now obtained by
ans(xth, xad) ← Movies(xti, “Bergman”, xac), Pariscope(xth, xti, xs), Location(xth, xad, xp)
where ans (for “answer”) is a relation over { Theater, Address}. The atom to the left of the
← is called the rule head, and the set of atoms to the right is called the body.

The preceding rule may be abbreviated as
ans(xth, xad) ← Movies(xti, “Bergman”, _), Pariscope(xth, xti, _), Location(xth, xad, _)
where _ is used to replace all variables that occur exactly once in the rule. Such variables are sometimes called anonymous.

In general, a rule-based conjunctive query is a single rule that has the form illustrated in the preceding example. The semantics associated with rule-based conjunctive queries ensures that their interpretation corresponds to the more informal expressions given in the preceding example. Rule-based conjunctive queries can be viewed as the basic building block for datalog, a query language based on logic programming that provides an elegant syntax for expressing recursion.

A second paradigm for the conjunctive queries has a more visual form and uses tables with variables and constants. Although we present a more succinct formalism for this
40
Conjunctive Queries
Movies
Title
Director
Actor
_The Seventh Seal
Bergman
Pariscope
Theater
Title
Schedule
_Rex
_The Seventh Seal
Location
Theater
Address
Phone number
P._Rex
P._1 bd. Poissonnière
Figure 4.2:
A query in QBE
paradigm later in this chapter, we illustrate it in Fig. 4.2 with a query presented in the syntax of the language Query-By-Example (QBE) (see also Chapter 7). The identifiers starting with a _ designate variables, and P. indicates what to output. Following the convention established for QBE, variable names are chosen to reflect typical values that they might take. Note that the coordinate entries left blank correspond, in terms of the rule given previously, to distinct variables that occur exactly once in the body and do not occur in the head (i.e., to anonymous variables).

The third version of conjunctive queries studied in this chapter is a restriction of the predicate calculus; as will be seen, the term conjunctive query stems from this version. The fourth and fifth versions are algebraic in nature, one for the unnamed perspective and the other for the named perspective.

4.2
Logic-Based Perspectives
In this section we introduce and study three versions of the conjunctive queries, all stemming from mathematical logic. After showing the equivalence of the three resulting query languages, we extend them by incorporating a capability to express equality explicity, thereby yielding a slightly more powerful family of languages.

Rule-Based Conjunctive Queries
The rule-based version of conjunctive queries is now presented formally. As will be seen later, the rule-based paradigm is well suited for specifying queries from database schemas to database schemas. However, to facilitate the comparison between the different variants of the conjunctive queries, we focus first on rule-based queries whose targets are relation schemas. We adopt the convention of using the name ans to refer to the name of the target relation if the name itself is unimportant (as is often the case with relational queries).

4.2 Logic-Based Perspectives
41
Definition 4.2.1
Let R be a database schema. A rule-based conjunctive query over R
is an expression of the form
ans(u) ← R1(u1), . . . , Rn(un)
where n ≥ 0, R1, . . . , Rn are relation names in R; ans is a relation name not in R; and u, u1, . . . , un are free tuples (i.e., may use either variables or constants). Recall that if v = x1, . . . , xm, then ‘R(v)’ is a shorthand for ‘R(x1, . . . , xm)’. In addition, the tuples u, u1, . . . , un must have the appropriate arities (i.e., u must have arity of ans, and ui must have the arity of Ri for each i ∈ [1, n]). Finally, each variable occurring in u must also occur at least once in u1, . . . , un. The set of variables occurring in q is denoted var(q).

Rule-based conjunctive queries are often more simply called rules. In the preceding rule, the subexpression R1(u1), . . . , Rn(un) is the body of the rule, and ‘ ans(u)’ is the head. The rule here is required by the definition to be range restricted (i.e., each variable occurring in the head must also occur in the body). Although this restriction is followed in most of the languages based on the use of rules, it will be relaxed in Chapter 18.

Intuitively, a rule may be thought of as a tool for deducing new facts. If one can find values for the variables of the rule such that the body holds, then one may deduce the head fact. This concept of “values for the variables in the rules” is captured by the notion of “valuation.” Formally, given a finite subset V of var, a valuation ν over V is a total function ν from V to the set dom of constants. This is extended to be identity on dom and then extended to map free tuples to tuples in the natural fashion.

We now define the semantics for rule-based conjunctive queries. Let q be the query given earlier, and let I be an instance of R. The image of I under q is q(I) = {ν(u) | ν is a valuation over var(q) and ν(ui) ∈ I(Ri), for each i ∈ [1, n]}.

The active domain of a database instance I, denoted adom(I), is the set of all constants occurring in I, and the active domain adom(I ) of relation instance I is defined analogously.

In addition, the set of constants occurring in a query q is denoted adom(q). We use adom(q, I) as an abbreviation for adom(q) ∪ adom(I).

Let q be a rule and I an input instance for q. Because q is range restricted, it is easily verified that adom(q(I)) ⊆ adom(q, I) (see Exercise 4.2). In other words, q(I) contains only constants occurring in q or in I. In particular, q(I) is finite, and so it is an instance.

A straightforward algorithm for evaluating a rule q is to consider systematically all valuations with domain the set of variables occurring in q, and range the set of all constants occurring in the input or q. More efficient algorithms may be achieved, both by performing symbolic manipulations of the query and by using auxiliary data structures such as indexes.

Such improvements are considered in Chapter 6.

Returning to the intuition, under the usual perspective a fundamental difference between the head and body of a rule R0 ← R1, . . . , Rn is that body relations are viewed as being stored, whereas the head relation is not. Thus, referring to the rule given earlier, the values of relations R1, . . . , Rn are known because they are provided by the input instance
42
Conjunctive Queries
I. In other words, we are given the extension of R1, . . . , Rn; for this reason they are called extensional relations. In contrast, relation R0 is not stored and its value is computed on request by the query; the rule gives only the “intension” or definition of R0. For this reason we refer to R0 as an intensional relation. In some cases, the database instance associated with R1, . . . , Rn is called the extensional database (edb), and the rule itself is referred to as the intensional database (idb). Also, the defined relation is sometimes referred to as an idb relation.

We now present the first theoretical property of conjunctive queries. A query q over R
is monotonic if for each I, J over R, I ⊆ J implies that q(I) ⊆ q(J). A query q is satisfiable if there is some input I such that q(I) is nonempty.

Proposition 4.2.2
Conjunctive queries are monotonic and satisfiable.

Proof
Let q be the rule-based conjunctive query
ans(u) ← R1(u1), . . . , Rn(un).

For monotonicity, let I ⊆ J, and suppose that t ∈ q(I). Then for some valuation ν over var(q), ν(ui) ∈ I(Ri) for each i ∈ [1, n], and t = ν(u). Because I ⊆ J, ν(ui) ∈ J(Ri) for each i, and so t ∈ q(J).

For satisfiability, let d be the set of constants occurring in q, and let a ∈ dom be new.

Define I over the relation schemas R of the rule body so that I(R) = (d ∪ {a}) arity(R)
[i.e., the set of all tuples formed from (d ∪ {a}) having arity arity(R)]. Finally, let ν map each variable in q to a. Then ν(ui) ∈ I(Ri) for i ∈ [1, n], and so ν(u) ∈ q(I). Thus q is satisfiable.

The monotonicity of the conjunctive queries points to limitations in their expressive power. Indeed, one can easily exhibit queries that are nonmonotonic and therefore not conjunctive queries. For instance, the query “Which theaters in New York show only Woody Allen films?” is nonmonotonic.

We close this subsection by indicating how rule-based conjunctive queries can be used to express yes-no queries. For example, consider the query
(4.5)
Is there a film directed by Bergman playing in Paris?

To provide an answer, we assume that relation name ans has arity 0. Then applying the rule ans() ← Movies(x, “Bergman”, y), Pariscope(z, x, w) returns the relation {} if the answer is yes, and returns {} if the answer is no.

4.2 Logic-Based Perspectives
43
Tableau Queries
If we blur the difference between a variable and a constant, the body of a conjunctive query can be seen as an instance. This leads to a formulation of conjunctive queries called
“tableau”, which is closest to the visual form provided by QBE.

Definition 4.2.3
The notion of tableau over a schema R (R) is defined exactly as was the notion of instance over R (R), except that both variables and constants may occur. A tableau query is simply a pair (T, u) [or (T , u)] where T is a tableau and each variable in u also occurs in T. The free tuple u is called the summary of the tableau query.

The summary tuple u in a tableau query (T, u) represents the tuples included in the answer to the query. Thus the answer consists of all tuples u for which the pattern described by T is found in the database.

Example 4.2.4
Let T be the tableau
Movies
Title
Director
Actor
xti
“Bergman”
xac
Pariscope
Theater
Title
Schedule
xth
xti
xs
Location
Theater
Address
Phone Number
xth
xad
xp
The tableau query (T, Theater : xth, Address : xad) expresses query (4.4). If the unnamed perspective on tuples is used, then the names of the attributes are not included in u.

The notion of valuation is extended in the natural fashion to map tableaux1 to instances. An embedding of tableau T into instance I is a valuation ν for the variables occurring in T such that ν(T) ⊆ I. The semantics for tableau queries is essentially the same as for rule-based conjunctive queries: The output of (T, u) on input I consists of all tuples ν(u) where ν is an embedding of T into I.

Aside from the fact that tableau queries do not indicate a relation name for the answer, they are syntactically close to the rule-based conjunctive queries. Furthermore, the alternative perspective provided by tableaux lends itself to the development of several natural results. Perhaps the most compelling of these arises in the context of the chase (see 1 One tableau, two tableaux.

44
Conjunctive Queries
Chapter 8), which provides an elegant characterization of two conjunctive queries yielding identical results when the inputs satisfy certain dependencies.

A family of restricted tableaux called typed have been used to develop a number of theoretical results. A tableau query q = (T , u) under the named perspective, where T is over relation schema R and sort(u) ⊆ sort(R), is typed if no variable of T or t is associated with two distinct attributes in q. Intuitively, the term ‘typed’ is used because it is impossible for entries from different attributes to be compared. The connection between typed tableaux and conjunctive queries in the algebraic paradigm is examined in Exercises 4.19 and 4.20. Additional results concerning complexity issues around typed tableau queries are considered in Exercises 6.16 and 6.21 in Chapter 6. Typed tableaux also arise in connection with data dependencies, as studied in Part C.

Conjunctive Calculus
The third formalism for expressing conjunctive queries stems from predicate calculus. (A review of predicate calculus is provided in Chapter 2, but the presentation of the calculus in this and the following chapter is self-contained.)

We begin by presenting conjunctive calculus queries that can be viewed as syntactic variants of rule-based conjunctive queries. They involve simple use of conjunction and existential quantification. As will be seen, the full conjunctive calculus, defined later, allows unrestricted use of conjunction and existential quantification. This provides more flexibility in the syntax but, as will be seen, does not increase expressive power.

Consider the conjunctive query
ans(e1, . . . , em) ← R1(u1), . . . , Rn(un).

A conjunctive calculus query that has the same semantics is
{e1, . . . , em | ∃x1, . . . , xk(R1(u1) ∧ · · · ∧ Rn(un))},
where x1, . . . , xk are all the variables occurring in the body and not the head. The symbol ∧ denotes conjunction (i.e., “and”), and ∃ denotes existential quantification (intuitively,
∃x . . . denotes “there exists an x such that . . .”). The term ‘conjunctive query’ stems from the presence of conjunctions in the syntax.

Example 4.2.5
In the calculus paradigm, query (4.4) can be expressed as follows:
{xth, xad | ∃xti ∃xac ∃xs ∃xp ( Movies(xti, “Bergman”, xac)
Pariscope(xth, xti, xs)
Location(xth, xad, xp))}.

Note that some but not all of the existentially quantified variables play the role of anonymous variables, in the sense mentioned in Example 4.1.1.

The syntax used here can be viewed as a hybrid of the usual set-theoretic notation,
4.2 Logic-Based Perspectives
45
used to indicate the form of the query output, and predicate calculus, used to indicate what should be included in the output. As discussed in Chapter 2, the semantics associated with calculus formulas is a restricted version of the conventional semantics found in first-order logic.

We now turn to the formal definition of the syntax and semantics of the (full) conjunctive calculus.

Definition 4.2.6
Let R be a database schema. A ( well-formed) formula over R for the conjunctive calculus is an expression having one of the following forms: (a) an atom over R;
(b) (ϕ ∧ ψ), where ϕ and ψ are formulas over R; or
(c) ∃xϕ, where x is a variable and ϕ is a formula over R.

In formulas we permit the abbreviation of ∃x1 . . . ∃xn by ∃x1, . . . , xn.

The usual notion of “free” and “bound” occurrences of variables is now defined. An occurrence of variable x in formula ϕ is free if
(i) ϕ is an atom; or
(ii) ϕ = (ψ ∧ ξ ) and the occurrence of x is free in ψ or ξ ; or
(iii) ϕ = ∃yψ, x and y are distinct variables, and the occurrence of x is free in ψ.

An occurrence of x in ϕ is bound if it is not free. The set of free variables in ϕ, denoted free(ϕ), is the set of all variables that have at least one free occurrence in ϕ.

Definition 4.2.7
A conjunctive calculus query over database schema R is an expression of the form
{e1, . . . , em | ϕ},
where ϕ is a conjunctive calculus formula, e1, . . . , em is a free tuple, and the set of variables occurring in e1, . . . , em is exactly free(ϕ). If the named perspective is being used, then attributes can be associated with output tuples by specifying a relation name R
of arity m. The notation
{e1, . . . , em : A1 . . . Am | ϕ}
can be used to indicate the sort of the output explicitly.

To define the semantics of conjunctive calculus queries, it is convenient to introduce some notation. Recall that for finite set V ⊂ var, a valuation over V is a total function ν
from V to dom. This valuation will sometimes be viewed as a syntactic expression of the form
{x1/a1, . . . , xn/an},
46
Conjunctive Queries
where x1, . . . , xn is a listing of V and ai = ν(xi) for each i ∈ [1, n]. This may also be interpreted as a set. For example, if x is not in the domain of ν and c ∈ dom, then ν ∪ {x/c}
denotes the valuation with domain V ∪ {x} that is identical to ν on V and maps x to c.

Now let R be a database schema, ϕ a conjunctive calculus formula over R, and ν a valuation over free(ϕ). Then I satisfies ϕ under ν, denoted I |= ϕ[ν], if (a) ϕ = R(u) is an atom and ν(u) ∈ I(R); or
(b) ϕ = (ψ ∧ ξ ) and2 I |= ψ[ν| free(ψ)] and I |= ξ [ν| free(ξ)]; or (c) ϕ = ∃xψ and for some c ∈ dom, I |= ψ[ν ∪ {x/c}].

Finally, let q = {e1, . . . , em | ϕ} be a conjunctive calculus query over R. For an instance I over R, the image of I under q is q(I) = {ν(e1, . . . , en) | I |= ϕ[ν] and ν is a valuation over free(ϕ)}.

The active domain of a formula ϕ, denoted adom(ϕ), is the set of constants occurring in ϕ; and as with queries q, we use adom(ϕ, I) to abbreviate adom(ϕ) ∪ adom(I). An easy induction on conjunctive calculus formulas shows that if I |= ϕ[ν], then the range of ν is contained in adom(I) (see Exercise 4.3). This implies, in turn, that to evaluate a conjunctive calculus query, one need only consider valuations with range contained in adom(ϕ, I) and, hence, only a finite number of them. This pleasant state of affairs will no longer hold when disjunction or negation is incorporated into the calculus (see Section 4.5 and Chapter 5).

Conjunctive calculus formulas ϕ and ψ over R are equivalent if they have the same free variables and, for each I over R and valuation ν over free(ϕ) = free(ψ), I |= ϕ[ν]
iff I |= ψ[ν]. It is easily verified that if ϕ and ψ are equivalent, and if 9′ is the result of replacing an occurrence of ϕ by ψ in conjunctive calculus formula 9, then 9 and 9′ are equivalent (see Exercise 4.4).

It is easily verified that for all conjunctive calculus formulas ϕ, ψ, and ξ , (ϕ ∧ ψ) is equivalent to (ψ ∧ ϕ), and (ϕ ∧ (ψ ∧ ξ )) is equivalent to ((ϕ ∧ ψ) ∧ ξ ). For this reason, we may view conjunction as a polyadic connective rather than just binary.

We next show that conjunctive calculus queries, which allow unrestricted nesting of ∃ and ∧, are no more powerful than the simple conjunctive queries first exhibited, which correspond straightforwardly to rules. Thus the simpler conjunctive queries provide a normal form for the full conjunctive calculus. Formally, a conjunctive calculus query q = {u | ϕ} is in normal form if ϕ has the form
∃x1, . . . , xm(R1(u1) ∧ · · · ∧ Rn(un)).

Consider now the two rewrite (or transformation) rules for conjunctive calculus queries: Variable substitution: replace subformula
∃x ψ by ∃y ψxy,
2 ν|V for variable set V denotes the restriction of ν to V .

4.2 Logic-Based Perspectives
47
if y does not occur in ψ, where ψx denotes the formula obtained by replacing all free y
occurrences of x by y in ψ.

Merge-exists: replace subformula
(∃y1, . . . , ynψ ∧ ∃z1, . . . , zmξ ) by ∃y1, . . . , yn, z1, . . . , zm(ψ ∧ ξ ) if {y1, . . . , yn} and {z1, . . . , zm} are disjoint, none of {y1, . . . , yn} occur (free or bound) in ξ , and none of {z1, . . . , zm} occur (free or bound) in ψ.

It is easily verified (see Exercise 4.4) that (1) application of these transformation rules to a conjunctive calculus formula yields an equivalent formula, and (2) these rules can be used to transform any conjunctive calculus formula into an equivalent formula in normal form.

It follows that:
Lemma 4.2.8
Each conjunctive calculus query is equivalent to a conjunctive calculus query in normal form.

We now introduce formal notation for comparing the expressive power of query languages. Let Q1 and Q2 be two query languages (with associated semantics). Then Q1 is dominated by Q2 (or, Q1 is weaker than Q2), denoted Q1 ⊑ Q2, if for each query q1 in Q1
there is a query q2 in Q2 such that q1 ≡ q2. Q1 and Q2 are equivalent, denoted Q1 ≡ Q2, if Q1 ⊑ Q2 and Q2 ⊑ Q1.

Because of the close correspondence between rule-based conjunctive queries, tableau queries, and conjunctive calculus queries in normal form, the following is easily verified (see Exercise 4.15).

Proposition 4.2.9
The rule-based conjunctive queries, the tableau queries, and the
conjunctive calculus are equivalent.

Although straightforward, the preceding result is important because it is the first of many that show equivalence between the expressive power of different query languages.

Some of these results will be surprising because of the high contrast between the languages.

Incorporating Equality
We close this section by considering a simple variation of the conjunctive queries presented earlier, obtained by adding the capability of explicitly expressing equality between variables and/or constants. For example, query (4.4) can be expressed as ans(xth, xad) ← Movies(xti, xd, xac), xd = “Bergman”, Pariscope(xth, xti, xs), Location(xth, xad, xp)
and query (4.6) can be expressed as
ans(y1, y2) ← Movies(x1, y1, z1), Movies(x2, y2, z2), y1 = z2, y2 = z1.

48
Conjunctive Queries
It would appear that explicit equalities like the foregoing can be expressed by conjunctive queries without equalities by using multiple occurrences of the same variable or constant. Although this is basically true, two problems arise. First, unrestricted rules with equality may yield infinite answers. For example, in the rule
ans(x, y) ← R(x), y = z
y and z are not tied to relation R, and there are infinitely many valuations satisfying the body of the rule. To ensure finite answers, it is necessary to introduce an appropriate notion of range restriction. Informally, an unrestricted rule with equality is range restricted if the equalities require that each variable in the body be equal to some constant or some variable occurring in an atom R(ui); Exercise 4.5 explores the notion of range restriction in more detail. A rule-based conjunctive query with equality is a range-restricted rule with equality.

A second problem that arises is that the equalities in a rule with equality may cause the query to be unsatisfiable. (In contrast, recall that rules without equality are always satisfiable; see Proposition 4.2.2.) Consider the following query, in which R is a unary relation and a, b are distinct constants.

ans(x) ← R(x), x = a, x = b.

The equalities present in this query require that a = b, which is impossible. Thus there is no valuation satisfying the body of the rule, and the query yields the empty relation on all inputs. We use q∅:R,R (or q∅ if R and R are understood) to denote the query that maps all inputs over R to the empty relation over R. Finally, note that one can easily check if the equalities in a conjunctive query with equality are unsatisfiable (and hence if the query is equivalent to q∅). This is done by computing the transitive closure of the equalities in the query and checking that no two distinct constants are required to be equal. Each satisfiable rule with equality is equivalent to a rule without equality (see Exercise 4.5c).

One can incorporate equality into tableau queries in a similar manner by adding separately a set of required equalities. Once again, no expressive power is gained if the query is satisfiable. Incorporating equality into the conjunctive calculus is considered in Exercise 4.6.

4.3
Query Composition and Views
We now present a digression that introduces the important notion of query composition and describe its relationship to database views. A main result here is that the rule-based conjunctive queries with equality are closed under composition.

Consider a database R = {R1, . . . , Rn}. Suppose that we have a query q (in any of the preceding formalisms). Conceptually, this can be used to define a relation with new relation name S1, which can be used in subsequent queries as any ordinary relation from R. In particular, we can use S1 in the definition of a new relation S2, and so on. In this context, we could call each of S1, S2, . . . intensional (in contrast with the extensional relations of R).

This perspective on query composition is expressed most conveniently within the rule-
4.3 Query Composition and Views
49
based paradigm. Specifically, a conjunctive query program (with or without equality) is a sequence P of rules having the form
S1(u1) ← body 1
S2(u2) ← body 2
...

Sm(um) ← body m,
where each Si is distinct and not in R; and for each i ∈ [1, m], the only relation names that may occur in body i are R1, . . . , Rn and S1, . . . , Si−1. An instance I over R and the program P can be viewed as defining values for all of S1, . . . , Sm in the following way: For each i ∈ [1, m], [P (I)](Si) = qi([P (I)]), where qi is the ith rule and defines relation Si in terms of I and the previous Sj ’s. If P is viewed as defining a single output relation, then this output is [P (I)](Sm). Analogous to rule-based conjunctive queries, the relations in R
are called edb relations, and the relations occurring in rule heads are called idb relations.

Example 4.3.1
Let R = {Q, R} and consider the conjunctive query program
S1(x, z) ← Q(x, y), R(y, z, w)
S2(x, y, z) ← S1(x, w), R(w, y, v), S1(v, z)
S3(x, z) ← S2(x, u, v), Q(v, z).

Figure 4.3 shows an example instance I for R and the values that are associated to S1, S2, S3
by P (I).

It is easily verified that the effect of the first two rules of P on S2 is equivalent to the effect of the rule
S2(x, y, z) ← Q(x1, y1), R(y1, z1, w1), x = x1, w = z1,
R(w, y, v), Q(x2, y2), R(y2, z2, w2), v = x2, z = z2.

Alternatively, expressed without equality, it is equivalent to
S2(x, y, z) ← Q(x, y1), R(y1, w, w1), R(w, y, v), Q(v, y2), R(y2, z, w2).

Note how variables are renamed to prevent undesired “cross-talk” between the different rule bodies that are combined to form this rule. The effect of P on S3 can also be expressed using a single rule without equality (see Exercise 4.7).

It is straightforward to verify that if a permutation P ′ of P (i.e., a listing of the elements of P in a possibly different order) satisfies the restriction that relation names in a rule body must be in a previous rule head, then P ′ will define the same mapping as P . This kind of consideration will arise in a richer context when stratified negation is considered in Chapter 15.

50
Conjunctive Queries
Q
R
S1
S2
S3
1
2
1
1
1
1
3
1
1
1
1
2
2
1
2
3
1
2
1
1
1
3
2
2
2
2
3
1
2
2
3
2
1
1
4
4
1
2
1
3
Figure 4.3:
Application of a conjunctive query program
Example 4.3.2
Consider the following program P :
T (a, x) ← R(x)
S(x) ← T (b, x).

Clearly, P always defines the empty relation S, so it is not equivalent to any rule-based conjunctive query without equality. Intuitively, the use of the constants a and b in P masks the use of equalities, which in this case are contradictory and yield an unsatisfiable query.

Based on the previous examples, the following is easily verified (see Exercise 4.7).

Theorem 4.3.3 (Closure under Composition)
If conjunctive query program P defines
final relation S, then there is a conjunctive query q, possibly with equality, such that on all input instances I, q(I) = [P (I)](S). Furthermore, if P is satisfiable, then q can be expressed without equality.

The notion of programs is based on the rule-based formalism of the conjunctive queries. In the other versions introduced previously and later in this chapter, the notation does not conveniently include a mechanism for specifying names for the output of intermediate queries. For the other formalisms we use a slightly more elaborate notation that permits the specification of these names. In particular, all of the formalisms are compatible with a functional, purely expression-based paradigm:
let
S1 = q1
in
let
S2 = q2
in
...

let
Sm−1 = qm−1
in
qm
and with an imperative paradigm in which the intermediate query values are assigned to relation variables:
4.3 Query Composition and Views
51
S1 := q1;
S2 := q2;
...

Sm−1 := qm−1;
Sm := qm.

It is clear from Proposition 4.2.9 and Theorem 4.3.3 that the conjunctive calculus and tableau queries with equality are both closed under composition.

Composition and User Views
Recall that the top level of the three-level architecture for databases (see Chapter 1) consists of user views (i.e., versions of the data that are restructured and possibly restricted images of the database as represented at the middle level). In many cases these views are specified as queries (or query programs). These may be materialized (i.e., a physical copy of the view is stored and maintained) or virtual (i.e., relevant information about the view is computed as needed). In the latter case, queries against the view generate composed queries against the underlying database, as illustrated by the following example.

Example 4.3.4
Consider the view over schema { Marilyn, Champo-info} defined by the following two rules:
Marilyn(xt) ← Movies(xt, xd, “Monroe”)
Champo- info(xt, xs, xp) ← Pariscope(“Le Champo”, xt, xs), Location(“Le Champo”, xa, xp).

The conjunctive query “What titles in Marilyn are featured at the Le Champo at 21:00?”
can be expressed against the view as
ans(xt) ← Marilyn(xt), Champo- info(xt, “21:00”, xp).

Assuming that the view is virtual, evaluation of this query is accomplished by considering the composition of the query with the view definition. This composition can be rewritten as
ans(xt) ← Movies(xt, xd, “Monroe”),
Pariscope(“Le Champo”, xt, “21:00”)
Location(“Le Champo”, xa, xp).

An alternative expression specifying both view and query now follows. (Expressions from the algebraic versions of the conjunctive queries could also be used here.)

52
Conjunctive Queries
Marilyn := {xt | ∃xd( Movies(xt, xd, “Monroe”))};
Champo- info := {xt, xs, xp | ∃xa( Location(“Le Champo”, xt, xs)
∧ Location(“Le Champo”, xa, xp)};
ans := {xt | Marilyn(xt) ∧ ∃xp( Champo- info(xt, “21:00”, xp))}.

This example illustrates the case in which a query is evaluated over a single view; evaluation of the query involves a two-layer composition of queries. If a series of nested views is defined, then query evaluation can involve query compositions having two or more layers.

4.4
Algebraic Perspectives
The use of algebra operators provides a distinctly different perspective on the conjunctive queries. There are two distinct algebras associated with the conjunctive queries, and they stem, respectively, from the named, ordered-tuple perspective and the unnamed, function-based perspective. After presenting the two algebras, their equivalence with the conjunctive queries is discussed.

The Unnamed Perspective: The SPC Algebra
The algebraic paradigm for relational queries is based on a family of unary and binary operators on relation instances. Although their application must satisfy some typing constraints, they are polymorphic in the sense that each of these operators can be applied to instances of an infinite number of arities or sorts. For example, as suggested in Chapter 3, the union operator can take as input any two relation instances having the same sort.

Three primitive algebra operators form the unnamed conjunctive algebra: selection, projection, and cross-product (or Cartesian product). This algebra is more often referred to as the SPC algebra, based on the first letters of the three operators that form it. (This convention will be used to specify other algebras as well.) An example is given before the formal definition of these operators.

Example 4.4.1
We show how query (4.4) can be built up using the three primitive
operators. First we use selection to extract the tuples of Movies that have Bergman as director.

I1 := σ2=“Bergman”( Movies)
Next a family of “wide” (six columns wide, in fact) tuples is created by taking the cross-product of I1 and Pariscope.

I2 := I1 × Pariscope
4.4 Algebraic Perspectives
53
Another selection is performed to focus on the members of I2 that have first and fifth columns equal.

I3 := σ1=5(I2)
In effect, the cross-product followed by this selection finds a matching of tuples from I1
and Pariscope that agree on the Title coordinates.

At this point we are interested only in the theaters where these films are playing, so we use projection to discard the unneeded columns, yielding a unary relation.

I4 := π4(I3)
Finally, this is paired with Location and projected on the Theater and Address columns to yield the answer.

I5 := π2,3(σ1=2(I4 × Location))
The development just given uses SPC expressions in the context of a simple imperative language with assignment. In the pure SPC algebra, this query is expressed as π2,3(σ1=2(π4(σ1=5(σ2=“Bergman”( Movies) × Pariscope)) × Location)).

Another query that yields the same result is
π4,8(σ4=7(σ1=5(σ2=“Bergman”( Movies × Pariscope × Location)))).

This corresponds closely to the conjunctive calculus query of Example 4.2.5.

Although the algebraic operators have a procedural feel to them, algebraic queries are used by most relational database systems as high-level specifications of desired output.

Their actual implementation is usually quite different from the original form of the query, as will be discussed in Section 6.1.

We now formally define the three operators forming the SPC algebra.

Selection: This can be viewed as a “horizontal” operator. The two primitive forms are σj=a and σj=k, where j, k are positive integers and a ∈ dom. [In practice, we usually surround constants with quotes (“ ”).] The operator σj=a takes as input any relation instance I with arity ≥ j and returns as output an instance of the same arity. In particular,
σj=a(I ) = {t ∈ I | t (j ) = a}.

The operator σj=k for positive integers j, k is defined analogously for inputs with arity
≥ max{j, k}. This is sometimes called atomic selection; generalizations of selection will be defined later.

54
Conjunctive Queries
Projection: This “vertical” operator can be used to delete and/or permute columns of a relation. The general form of this operator is πj
, where j
1,...,jn
1, . . . , jn is a possibly
empty sequence of positive integers (the empty sequence is written [ ]), possibly with repeats. This operator takes as input any relation instance with arity ≥ max{j1, . . . , jn}
(where the max of ∅ is 0) and returns an instance with arity n. In particular, πj
(I ) = {t (j
1,...,jn
1), . . . , t (jn) | t ∈ I }.

Cross-product ( or Cartesian product) : This operator provides the capability for combining relations. It takes as inputs a pair of relations having arbitrary arities n and m and returns a relation with arity n + m. In particular, if arity(I ) = n and arity(J ) = m, then
I × J = {t (1), . . . , t (n), s(1), . . . , s(m) | t ∈ I and s ∈ J }.

Cross-product is associative and noncommutative and has the nonempty 0-ary relation
{} as left and right identity. Because it is associative, we sometimes view cross-product as a polyadic operator and write, for example, I1 × · · · × In.

We extend the cross-product operator to tuples in the natural fashion—that is u × v is a tuple with arity = arity(u) + arity(v).

The SPC algebra is the family of well-formed expressions containing relation names and one-element unary constants and closed under the application of the selection, projection, and cross-product operators just defined. Each expression is considered to be defined over a given database schema and has an associated output arity. We now give the formal, inductive definition.

Let R be a database schema. The base SPC ( algebra) queries and output arities are Input relation: Expression R; with arity equal to arity(R).

Unary singleton constant: Expression {a}, where a ∈ dom; with arity equal to 1.

The family of SPC ( algebra) queries contains all base SPC queries and, for SPC queries q1, q2 with arities α1, α2, respectively,
Selection: σj=a(q1) and σj=k(q1) whenever j, k ≤ α1 and a ∈ dom; these have arity α1.

Projection: πj
(q
1,...,jn
1), where j1, . . . , jn ≤ α1; this has arity n.

Cross product: q1 × q2; this has arity α1 + α2.

In practice, we sometimes use brackets to surround algebraic queries, such as [R×
σ1=a(S)](I). In addition, parentheses may be dropped if no ambiguity results.

The semantics of these queries is defined in the natural manner (see Exercise 4.8).

The SPC algebra includes unsatisfiable queries, such as σ1=a(σ1=b(R)), where arity(R) ≥ 1 and a = b. This is equivalent to q∅.

As explored in Exercise 4.22, permitting as base SPC queries constant queries that are not unary (i.e., expressions of the form {a1, . . . , an}) yields expressive power greater than the rule-based conjunctive queries with equality. This is also true of selection formulas in which disjunction is permitted. As will be seen in Section 4.5, these capabilities
4.4 Algebraic Perspectives
55
are subsumed by including an explicit union operator into the SPC algebra. Permitting negation in selection formulas also extends the expressive power of the SPC algebra (see Exercise 4.27b).

Before leaving SPC algebra, we mention three operators that can be simulated by the primitive ones. The first is intersection (∩), which is easily simulated (see Exercise 4.28).

The other two operators involve generalizations of the selection and cross-product operators. The resulting algebra is called the generalized SPC algebra. We shall introduce a normal form for generalized SPC algebra expressions.

The first operator is a generalization of selection to permit the specification of multiple conditions. A positive conjunctive selection formula is a conjunction F = γ1 ∧ · · · ∧ γn (n ≥ 1), where each conjunct γi has the form j = a or j = k for positive integers j, k and a ∈ dom; and a positive conjunctive selection operator is an expression of the form σF , where F is a positive conjunctive selection formula. The intended typing and semantics for these operators is clear, as is the fact that they can be simulated by a composition of selections as defined earlier.

The second operator, called equi-join, is a binary operator that combines cross-product and selection. A (well-formed) equi-join operator is an expression of the form ⊲⊳F where F = γ1 ∧ · · · ∧ γn (n ≥ 1) is a conjunction such that each conjunct γi has the form j = k.

An equi-join operator ⊲⊳F can be applied to any pair I, J of relation instances, where the arity(I ) ≥ the maximum integer occurring on the left-hand side of any equality in F , and arity(J ) ≥ the maximum integer occurring on the right-hand side of any equality in F .

Given an equi-join expression I ⊲⊳F J , let F ′ be the result of replacing each condition j = k in F by j = arity(I ) + k. Then the semantics of I ⊲⊳F J is given by σF ′(I × J ). As with cross-product, equi-join is also defined for pairs of tuples, with an undefined output if the tuples do not satisfy the conditions specified.

We now develop a normal form for SPC algebra. We stress that this normal form is useful for theoretical purposes and, in general, represents a costly way to compute the answer of a given query (see Chapter 6).

An SPC algebra expression is in normal form if it has the form πj
({a
1,...,jn
1} × · · · × {am} × σF (R1 × · · · × Rk)),
where n ≥ 0; m ≥ 0; a1, . . . , am ∈ dom; {1, . . . , m} ⊆ {j1, . . . , jn}; R1, . . . , Rk are relation names (repeats permitted); and F is a positive conjunctive selection formula.

Proposition 4.4.2
For each (generalized) SPC query q there is a generalized SPC query q′ in normal form such that q ≡ q′.

The proof of this proposition (see Exercise 4.12) is based on repeated application of the following eight equivalence-preserving SPC algebra rewrite rules (or transformations).

Merge-select: replace σF (σF ′(q)) by σF ∧F ′(q).

Merge-project: replace π$(π (q)) by π (q), where l
for each term l
j
$k
$l
i = kji
i in $
l.

Push-select-through-project: replace σF (π$(q)) by π (σ
j
$j
F ′(q )), where F ′ is obtained from
F by replacing all coordinate values i by ji.

56
Conjunctive Queries
Push-select-through-singleton: replace σ1=j (a × q) by a × σ(j−1)=a(q).

Associate-cross: replace ((q1 × · · · × qn) × q) by (q1 × · · · qn × q), and replace (q × (q1 ×
· · · qn)) by (q × q1 × · · · qn).

Commute-cross: replace (q × q′) by π$j $j′(q′ × q), where $j = arity(q′) + 1, . . . , arity(q′) +
arity(q), and $
j ′ = 1, . . . , arity(q′).

Push-cross-through-select: replace (σF (q) × q′) by σF (q × q′), and replace (q × σF (q′)) by σF′(q × q′), where F ′ is obtained from F by replacing all coordinate values i by i + arity(q).

Push-cross-through-project: replace (π$(q) × q′) by π (q × q′), and replace (q × π (q′)) j
$j
$j
by π $j′(q × q′), where $j′ is obtained from $j by replacing all coordinate values i by i + arity(q).

For a set S of rewrite rules and algebra expressions q, q′, write q →S q′, or simply q → q′ if S is understood from the context, if q′ is the result of replacing a subexpression of q according to one of the rules in S. Let ∗
→S denote the reflexive, transitive closure
of →S.

A family S of rewrite rules is sound if q →S q′ implies q ≡ q′. If S is sound, then clearly q ∗
→S q′ implies q ≡ q′.

It is easily verified that the foregoing set of rewrite rules is sound and that for each SPC
query q there is a normal form SPC query q′ such that q′ is in normal form, and q ∗
→ q′
(see Exercise 4.12).

In Section 6.1, we describe an approach to optimizing the evaluation of conjunctive queries using rewrite rules. For example, in that context, the merge-select and merge-project transformations are helpful, as are the inverses of the push-cross-through-select and push-cross-through-project.

Finally, note that an SPC query may require, as the result of transitivity, the equality of two distinct constants. Thus there are unsatisfiable SPC queries equivalent to q∅. This is analogous to the logic-based conjunctive queries with equality. It is clear, using the normal form, that one can check whether an SPC query is q∅ by examining the selection formula F . The set of SPC queries that are not equivalent to q∅ forms the satisfiable SPC algebra.

The Named Perspective: The SPJR Algebra
In Example 4.4.1, the relation I3 was constructed using selection and cross-product by the expression σ1=5(I1 × Pariscope). As is often the case, the columns used in this selection are labeled by the same attribute. In the context of the named perspective on tuples, this suggests a natural variant of the cross-product operator (and of the equi-join operator) that is called natural join and is denoted by ⊲⊳. Informally, the natural join requires the tuples that are concatenated to agree on the common attributes.

4.4 Algebraic Perspectives
57
Example 4.4.3
The natural join of Movies and Pariscope is
Movies ⊲⊳ Pariscope
= {u with sort Title Director Actor Theater Schedule |
for some v ∈ Movies and w ∈ Pariscope,
u[ Title Director Actor] = v and u[ Theater Title Schedule] = w}
= π1,2,3,4,6( Movies ⊲⊳1=2 Pariscope)
(assuming that the sort of the last expression corresponds to that of the previous expression). More generally, using the natural analog of projection and selection for the named perspective, query (4.4) can be expressed as
π Theater, Address((σ Director=“Bergman′′( Movies) ⊲⊳ Pariscope) ⊲⊳ Location).

As suggested by the preceding example, natural join can be used in the named context to replace certain equi-joins arising in the unnamed context. However, a problem arises if two relations sharing an attribute A are to be joined but without forcing equality on the A coordinates, or if a join is to be formed based on the equality of attributes not sharing the same name. For example, consider the query
(4.8)
List pairs of actors that acted in the same movie.

To answer this, one would like to join the Movies relation with itself but matching only on the Title column. This will be achieved by first creating a copy Movies′ of Movies in which the attribute Director has been renamed to Director′ and Actor to Actor′; joining this with Movies; and finally projecting onto the Actor and Actor′ columns. Renaming is also needed for query (4.6) (see Exercise 4.11).

The named conjunctive algebra has four primitive operators: selection, essentially as before; projection, now with repeats not permitted; ( natural) join; and renaming. It is thus referred to as the SPJR algebra. As with the SPC algebra, we define the individual operators and then indicate how they are combined to form a typed, polymorphic algebra. In each case, we indicate the sorts of input and output. If a relation name is needed for the output, then it is assumed to be chosen to have the correct sort.

Selection: The selection operators have the form σA=a and σA=B, where A, B ∈ att and a ∈ dom. These operators apply to any instance I with A ∈ sort(I ) [respectively, A, B ∈ sort(I )] and are defined in analogy to the unnamed selection, yielding an output with the same sort as the input.

Projection: The projection operator has the form πA
, n ≥ 0 (repeats not permitted)
1,...,An
and operates on all inputs having sort containing {A1, . . . , An}, producing output with sort {A1, . . . , An}.

( Natural) join: This operator, denoted ⊲⊳, takes arbitrary inputs I and J having sorts V and
58
Conjunctive Queries
W , respectively, and produces an output with sort equal to V ∪ W . In particular, I ⊲⊳ J = {t over V ∪ W | for some v ∈ I and w ∈ J,
t [V ] = v and t[W ] = w}.

When sort(I ) = sort(J ), then I ⊲⊳ J = I ∩ J , and when sort(I ) ∩ sort(J ) = ∅, then I ⊲⊳ J is the cross-product of I and J . The join operator is associative, commutative, and has the nonempty 0-ary relation {} as left and right identity. Because it is associative, we sometimes view join as a polyadic operator and write, for example, I1 ⊲⊳ · · · ⊲⊳ In.

As with cross-product and equi-join, natural join is extended to operate on pairs of tuples, with an undefined result if the tuples do not match on the appropriate attributes.

Renaming: An attribute renaming for a finite set U of attributes is a one-one mapping from U to att. An attribute renaming f for U can be described by specifying the set of pairs (A, f (A)), where f (A) = A; this is usually written as A1A2 . . . An → B1B2 . . . Bn to indicate that f (Ai) = Bi for each i ∈ [1, n] (n ≥ 0). A renaming operator for inputs over U is an expression δf , where f is an attribute renaming for U ; this maps to outputs over f [U ]. In particular, for I over U ,
δf (I ) = {v over f [U ] | for some u ∈ I, v(f (A)) = u(A) for each A ∈ U }.

Example 4.4.4
Let I, J be the two relations, respectively over R, S, given in Fig. 4.4.

Then I ⊲⊳ J , σA=1(I ), δBC→B′A(J ), and πA(I ) are also shown there. Let K be the one-tuple relation A : 1, C : 9. Then πA,B(I ⊲⊳ K) coincides with σA=1(I ) and J ⊲⊳ K =
{A : 1, B : 8, C : 9}.

The base SPJR algebra queries are:
Input relation: Expression R; with sort equal to sort(R).

Unary singleton constant: Expression {A : a}, where a ∈ dom; with sort A.

The remainder of the syntax and semantics of the SPJR algebra is now defined in analogy to those of the SPC algebra (see Exercise 4.8).

Example 4.4.5
Consider again Fig. 4.4. Let I be the instance over {R, S} such that I(R) = I and I(S) = J . Then [R] is a query and the answer to that query, denoted R(I), is just I . Figure 4.4 also gives the values of S(I), [R ⊲⊳ S](I), [σA=1(R)](I),
[δBC→B′A(S)](I), and [πA(R)](I). Let KA = {A : 1} and KC = {C : 9}. Then [KA]
and [KC] are constant queries, and [KA ⊲⊳ KC] is a query that evaluates (on all inputs) to the relation K of Example 4.4.4.

As with the SPC algebra, we introduce a natural generalization of the selection operator for the SPJR algebra. In particular, the notions of positive conjunctive selection formula and positive conjunctive selection operator are defined for the context in complete
4.4 Algebraic Perspectives
59
R
A
B
S
B
C
[R ⊲⊳ S]
A
B
C
1
2
2
3
1
2
3
4
2
2
5
1
2
5
6
6
6
4
4
2
3
7
7
8
9
4
2
5
1
7
6
6
4
1
6
1
6
4
[σA=1(R)]
A
B
[δBC→B′A(S)]
B′
A
[πA(R)]
A
1
2
2
3
1
1
7
2
5
4
1
6
6
4
6
8
9
7
Figure 4.4:
Examples of SPJR operators
analogy to the unnamed case. Including this operator yields the generalized SPJR algebra.

A normal form result analogous to that for the SPC algebra is now developed. In particular, an SPJR algebra expression is in normal form if it has the form πB
({A
(R
(R
1,...,Bn
1 : a1} ⊲⊳ · · · ⊲⊳ {Am : am} ⊲⊳ σF (δf1
1) ⊲⊳ · · · ⊲⊳ δfk
k))),
where n ≥ 0; m ≥ 0; a1, . . . , am ∈ dom; each of A1, . . . , Am occurs in B1, . . . , Bn; the Ai’s are distinct; R1, . . . , Rk are relation names (repeats permitted); δf is a renaming j
operator for sort(Rj ) for each j ∈ [1, k] and no Ai’s occur in any δf (R
j
j ); the sorts
of δf (R
(R
1
1), . . . , δfk
k) are pairwise disjoint; and F is a positive conjunctive selection formula. The following is easily verified (see Exercise 4.12).

Proposition 4.4.6
For each (generalized) SPJR query q, there is a generalized SPJR
query q′ in normal form such that q ≡ q′.

The set of SPJR queries not equivalent to q∅ forms the satisfiable SPJR algebra.

Equivalence Theorem
We now turn to the main result of the chapter, showing the equivalence of the various formalisms introduced so far for expressing conjunctive queries. As shown earlier, the three logic-based versions of the conjunctive queries are equivalent. We now show that the SPC
and SPJR algebras are also equivalent to each other and then obtain the equivalence of the algebraic languages and the three logic-based languages.

60
Conjunctive Queries
Lemma 4.4.7
The SPC and SPJR algebras are equivalent.

Crux
We prove the inclusion SPC algebra ⊑ SPJR algebra; the converse is similar (see Exercise 4.14). Let q be the following normal form SPC query:
πj
({a
1,...,jn
1} × · · · × {am} × σF (R1 × · · · × Rk)).

We now describe an SPJR query q′ that is equivalent to q; q′ has the following form: πA
({A
(R
(R
j ,...,A
1 : a1} ⊲⊳ · · · ⊲⊳ {Am : am} ⊲⊳ σG(δf
1) ⊲⊳ · · · ⊲⊳ δf
k))).

1
jn
1
k
We use the renaming functions so that the attributes of δf (R
t
t ) are As , . . . , As′, where
s, . . . , s′ are the coordinate positions of Rt in the expression R1 × · · · × Rk and modify F
into G accordingly. In a little more detail, for each r ∈ [1, k] let β(t) = m + #t arity(R
s=0
s ),
and let Am+1, . . . , Aβ(k) be new attributes. For each t ∈ [1, k], choose δf so that it maps t
the ith attribute of Rt to the attribute Aβ(t−1)+i. To define G, first define the function γ from coordinate positions to attribute names so that γ (j ) = Am+j , extend γ to be the identity on constants, and extend it further in the natural manner to map unnamed selection formulas to named selection formulas. Finally, set G = γ (F ). It is now straightforward to verify that q′ ≡ q.

It follows immediately from the preceding lemma that the satisfiable SPC algebra and the satisfiable SPJR algebra are equivalent.

The equivalence between the two algebraic languages and the three logic-based languages holds with a minor caveat involving the empty query q∅. As noted earlier, the SPC
and SPJR algebras can express q∅, whereas the logic-based languages cannot, unless extended with equality. Hence the equivalence result is stated for the satisfiable SPC and SPJR algebras.

Theorem 4.3.3 (i.e., the closure of the rule-based conjunctive queries under composition) is used in the proof of this result. The closures of the SPC and SPJR algebras under composition are, of course, immediate.

Theorem 4.4.8
(Equivalence Theorem) The rule-based conjunctive queries, tableau queries, conjunctive calculus queries, satisfiable SPC algebra, and satisfiable SPJR algebra are equivalent.

Proof
The proof can be accomplished using the following steps:
(i) satisfiable SPC algebra ⊑ rule-based conjunctive queries; and
(ii) rule-based conjunctive queries ⊑ satisfiable SPC algebra.

We briefly consider how steps (i) and (ii) might be demonstrated; the details are left to the reader (Exercise 4.15). For (i), it is sufficient to show that each of the SPC algebra operations can be simulated by a rule. Indeed, then the inclusion follows from the fact that rule-based conjunctive queries are closed under composition by Theorem 4.3.3 and that
4.5 Adding Union
61
satisfiable rules with equality can be expressed as rules without equality. The simulation of algebra operations by rules is as follows:
1. P × Q, where P and Q are not constant relations, corresponds to ans($
x, $
y) ←
P ($
x), Q($
y), where $
x and $
y contain no repeating variables; in the case when P
(Q) are constant relations, $
x ($
y) are the corresponding constant tuples.

2. σF (R) corresponds to ans($x) ← R(σF ($y)), where $y consists of distinct variables, σF ($
y) denotes the vector of variables and constants obtained by merging variables of $
y with other variables or with constants according to the (satisfiable) selection formula F , and $
x consists of the distinct variables in σF ($
y).

3. πj
(R) corresponds to ans(x . . . x ) ← R(x
1...jn
j1
jn
1 . . . xm), where x1, . . . , xm are
distinct variables.

Next consider step (ii). Let ans($
x) ← R1($
x1), . . . , Rn($
xn) be a rule. There is an equiv-
alent SPC algebra query in normal form that involves the cross-product of R1, . . . , Rn, a selection reflecting the constants and repeating variables occurring in $
x1, . . . , $
xn, a fur-
ther cross-product with constant relations corresponding to the constants in $
x, and finally
a projection extracting the coordinates corresponding to $
x.

An alternative approach to showing step (i) of the preceding theorem is explored in Exercise 4.18.

4.5
Adding Union
As indicated by their name, conjunctive queries are focused on selecting data based on a conjunction of conditions. Indeed, each atom added to a rule potentially adds a further restriction to the tuples produced by the rule. In this section we consider a natural mechanism for adding a disjunctive capability to the conjunctive queries. Specifically, we add a union operator to the SPC and SPJR algebras, and we add natural analogs of it to the rule-based and tableau-based paradigms. Incorporating union into the conjunctive calculus raises some technical difficulties that are resolved in Chapter 5. This section also considers the evaluation of queries with union and introduces a more restricted mechanism for incorporating a disjunctive capability.

We begin with some examples.

Example 4.5.1
Consider the following query:
(4.10)
Where can I see “Annie Hall” or “Manhattan”?

Although this cannot be expressed as a conjunctive query (see Exercise 4.22), it is easily expressed if union is added to the SPJR algebra:
π Theater(σ Title=“Annie Hall”( Pariscope) ∪ σ Title=“Manhattan”( Pariscope)).

62
Conjunctive Queries
An alternative formulation of this uses an extended selection operator that permits disjunctions in the selection condition:
π Theater(σ Title=“Annie Hall”∨ Title=“Manhattan”( Pariscope)).

As a final algebraic alternative, this can be expressed in the original SPJR algebra but permitting nonsingleton constant relations as base expressions:
π Theater( Pariscope ⊲⊳ { Title: “Annie Hall”, Title: “Manhattan”}).

The rule-based formalism can accommodate this query by permitting more than one rule with the same relation name in the head and taking the union of their outputs as the answer: ans(xt) ← Pariscope(xt, “Annie Hall”, xs)
ans(xt) ← Pariscope(xt, “Manhattan”, xs).

Consider now the following query:
(4.11)
What are the films with Allen as actor or director?

This query can be expressed using any of the preceding formalisms, except for the SPJR
algebra extended with nonsingleton constant relations as base expressions (see Exercise 4.22).

Let I1, I2 be two relations with the same arity. As standard in mathematics, I1 ∪ I2
is the relation having this arity and containing the union of the two sets of tuples. The definition of the SPCU algebra is obtained by extending the definition of the SPC algebra to include the union operator. The SPJRU algebra is obtained in the same fashion, except that union can only be applied to expressions having the same sort.

The SPCU and SPJRU algebras can be generalized by extending the selection operator (and join, in the case of SPC) as before. We can then define normal forms for both algebras, which are expressions consisting of one or more normal form SPC (SPJR) expressions combined using a polyadic union operator (see Exercise 4.23). As suggested by the previous example, disjunction can also be incorporated into selection formulas with no increase in expressive power (see Exercise 4.22).

Turning now to rule-based conjunctive queries, the simplest way to incorporate the capability of union is to consider sets of rules all having the same relation name in the head. These queries are evaluated by taking the union of the output of the individual rules.

This can be generalized without increasing the expressive power by incorporating something analogous to query composition. A nonrecursive datalog program ( nr-datalog program) over schema R is a set of rules
4.5 Adding Union
63
S1 ← body 1
S2 ← body 2
...

Sm ← body m,
where no relation name in R occurs in a rule head; the same relation name may appear in more than one rule head; and there is some ordering r1, . . . , rm of the rules so that the relation name in the head of ri does not occur in the body of a rule rj whenever j ≤ i.

The term ‘nonrecursive’ is used because recursion is not permitted. A simple example of a recursive rule is
ancestor(x, z) ← parent(x, y), ancestor(y, z).

A fixpoint operator is used to give the semantics for programs involving such rules. Recursion is the principal topic of Part D.

As in the case of rule-based conjunctive query programs, the query is evaluated on input I by evaluating each rule in (one of) the order(s) satisfying the foregoing property and forming unions whenever two rules have the same relation name in their heads. Equality atoms can be added to these queries, as they were for the rule-based conjunctive queries.

In general, a nonrecursive datalog program P over R is viewed as having a database schema as target. Program P can also be viewed as mapping from R to a single relation (see Exercise 4.24).

Turning to tableau queries, a union of tableaux query over schema R (or R) is an expression of the form ({T1, . . . , Tn}, u), where n ≥ 1 and (Ti, u) is a tableau query over R for each i ∈ [1, n]. The semantics of these queries is obtained by evaluating the queries (Ti, u) independently and then taking the union of their results. Equality is incorporated into these queries by permitting each of the queries (Ti, u) to have equality.

We can now state (see Exercise 4.25) the following:
Theorem 4.5.2
The following have equivalent expressive power:
1. the nonrecursive datalog programs (with single relation target), 2. the SPCU queries,
3. the SPJRU queries.

The union of tableau queries is weaker than the aforementioned languages with union.

This is essentially because the definition of union of tableau queries does not allow separate summary rows for each tableau in the union. With just one summary row, the nonrecursive datalog query
ans(a) ←
ans(b) ←
cannot be expressed as a union of tableaux query.

64
Conjunctive Queries
As with conjunctive queries, it is easy to show that the conjunctive queries with union and equality are closed under composition.

Union and the Conjunctive Calculus
At first glance, it would appear that the power of union can be added to the conjunctive calculus simply by permitting disjunction (denoted ∨) along with conjunction as a binary connective for formulas. This approach, however, can have serious consequences.

Example 4.5.3
Consider the following “query”:
q = {x, y, z | R(x, y) ∨ R(y, z)}.

Speaking intuitively, the “answer” of q on nonempty instance I will be (using a slight abuse of notation)
q(I ) = (I × dom) ∪ (dom × I ).

This is an infinite set of tuples and thus not an instance according to the formal definition.

Informally, the query q of the previous example is not “safe.” This notion is one of the central topics that needs to be resolved when using the first-order predicate calculus as a relational query language, and it is studied in Chapter 5. We return there to the issue of adding union to the conjunctive calculus (see also Exercise 4.26).

Bibliographic Notes
Codd’s pioneering article [Cod70] on the relational model introduces the first relational query language, a named algebra. The predicate calculus was adapted to the relational model in [Cod72b], where it was shown to be essentially equivalent to the algebra. The conjunctive queries, in the calculus paradigm, were first introduced in [CM77]. Their equivalence with the SPC algebra is also shown there.

Typed tableau queries appeared as a two-dimensional representation of a subset of the conjunctive queries in [ASU79b] along with a proof that all typed restricted SPJ algebra expressions over one relation can be expressed using them. A precursor to the typed tableau queries is found in [ABU79], which uses a technique related to tableaux to analyze the join operator. [ASU79a, ASSU81, CV81] continued the investigation of typed tableau queries;
[SY80] extends tableau queries to include union and a limited form of difference; and
[Klu88] extends them to include inequalities and order-based comparators. Tableau queries have also played an important role in dependency theory; this will be discussed in Part C.

Many of the results in this chapter (including, for example, the equivalence of the SPC
and SPJR algebras and closure of conjunctive queries under composition) are essentially part of the folklore.

Exercises
65
Exercises
Exercise 4.1
Express queries (4.1–4.3) and (4.5–4.9) as (a) rule-based conjunctive queries, (b) conjunctive calculus queries, (c) tableau queries, (d) SPC expressions, and (e) SPJR expressions.

Exercise 4.2
Let R be a database schema and q a rule.

(a) Prove that q(I) is finite for each instance I over R.

(b) Show an upper bound, given instance I of R and output arity for conjunctive query q, for the number of tuples that can occur in q(I). Show that this bound can be achieved.

Exercise 4.3
Let R be a database schema and I an instance of R.

(a) Suppose that ϕ is a conjunctive calculus formula over R and ν is a valuation for free(ϕ). Prove that I |= ϕ[ν] implies that the image of ν is contained in adom(I).

(b) Prove that if q is a conjunctive calculus query over R, then only a finite number of valuations need to be considered when evaluating q(I). (Note: The presence of existential quantifiers may have an impact on the set of valuations that need to be considered.)

Exercise 4.4
(a) Let ϕ and ψ be equivalent conjunctive calculus formulas, and suppose that 9′ is the result of replacing an occurrence of ϕ by ψ in conjunctive calculus formula 9. Prove that 9 and 9′ are equivalent.

(b) Prove that the application of the rewrite rules rename and merge-exists to a conjunctive calculus formula yields an equivalent formula.

(c) Prove that these rules can be used to transform any conjunctive calculus formula into an equivalent formula in normal form.

Exercise 4.5
(a) Formally define the syntax and semantics of rule-based conjunctive queries with equality and conjunctive calculus queries with equality.

(b) As noted in the text, logic-based conjunctive queries with equality can generally yield infinite answers if not properly restricted. Give a definition for range-restricted rule-based and conjunctive calculus queries with equality that ensures that queries satisfying this condition always yield a finite answer.

(c) Prove for each rule-based conjunctive query with equality q that either q ≡ q∅ or q ≡ q′ for some rule-based conjunctive query q′ without equality. Give a polynomial time algorithm that decides whether q ≡ q∅, and if not, constructs an equivalent rule-based conjunctive query q′.

(d) Prove that each rule-based conjunctive query with equality but no constants is equivalent to a rule-based conjunctive query without equality.

Exercise 4.6
Extend the syntax of the conjunctive calculus to include equality. Give a syntactic condition that ensures that the answer to a query q on I involves only constants from adom(q, I) and such that the answer can be obtained by considering only valuations whose range is contained in adom(q, I).

Exercise 4.7
Give a proof of Theorem 4.3.3.

66
Conjunctive Queries
Exercise 4.8
(a) Give a formal definition for the semantics of the SPC algebra.

(b) Give a formal definition for the syntax and semantics of the SPJR algebra.

Exercise 4.9
Consider the algebra consisting of all SPJR queries in which constants do not occur.

(a) Define a normal form for this algebra.

(b) Is this algebra closed under composition?

(c) Is this algebra equivalent to the rule-based conjunctive queries without constants or equality?

Exercise 4.10
Under the named perspective, a selection operator is constant based if it has the form σA=a, where A ∈ att and a ∈ dom. Prove or disprove: Each SPJR algebra expression is equivalent to an SPJR algebra expression all of whose selection operators are constant based.

Exercise 4.11
Prove that queries (4.6 and 4.8) cannot be expressed using the SPJ algebra (i.e., that renaming is needed).

Exercise 4.12
(a) Prove that the set of SPC transformations presented after the statement of Proposition 4.4.2 is sound (i.e., preserves equivalence).

(b) Prove Proposition 4.4.2.

(c) Prove that each SPJR query is equivalent to one in normal form. In particular, exhibit a set of equivalence-preserving SPJR algebra transformations used to demonstrate this result.

Exercise 4.13
(a) Prove that the nonempty 0-ary relation is the left and right identity for cross product and for natural join.

(b) Prove that for a fixed relation schema S, there is an identity for union for relations over S. What if S is not fixed?

(c) Let S be a relational schema. For the binary operations α ∈ {⊲⊳, ∪}, does there exist a relation I such that I αJ = I for each relation J over S?

Exercise 4.14
Complete the proof of Lemma 4.4.7 by showing the inclusion SPJR algebra ⊑
SPC algebra.

Exercise 4.15
(a) Prove Proposition 4.2.9.

(b) Complete the proof of Theorem 4.4.8.

Exercise 4.16
Consider the problem of defining restricted versions of the SPC and SPJR
algebras that are equivalent to the rule-based conjunctive queries without equality. Find natural restricted versions, or explain why they do not exist.

Exercise 4.17
Let q be a tableau query and q′ the SPC query corresponding to it via the translation sketched in Theorem 4.4.8. If q has r rows and q′ has j joins of database (nonconstant) relations, show that j = r − 1.

Exercises
67
♠ Exercise 4.18
(a) Develop an inductive algorithm that translates a satisfiable SPC query q into a tableau query by associating a tableau query to each subquery of q.

(b) Do the same for SPJR queries.

(c) Show that if q is a satisfiable SPC (SPRJ) query with n joins (not counting joins involving constant relations), then the tableau of the corresponding tableau query has n + 1 rows.

♠ Exercise 4.19 [ASU79b] This exercise examines the connection between typed tableaux and a subset of the SPJ algebra. A typed restricted SPJ algebra expression over R is an SPJR algebra expression that uses only [R] as base expressions and only constant-based selection (i.e., having the form σA=a for constant a), projection, and (natural) join as operators.

(a) Describe a natural algorithm that maps typed restricted SPJ queries q over R into equivalent typed tableau queries q′ = (T , u) over R, where |T | = (the number of join operations in q) + 1.

(b) Show that q = ({x, y1, x1, y1, x1, y}, x, y) is not the image of any typed restricted SPJ query under the algorithm of part (a).

⋆ (c) [ASSU81] Prove that the tableau query q of part (b) is not equivalent to any typed restricted SPJ algebra expression.

Exercise 4.20
[ASU79b] A typed tableau query q = (T , u) with T over relation R is repeat restricted if
1. If A ∈ sort(u), then no variable in πA(T ) − {u(A)} occurs more than once in T .

2. If A ∈ sort(u), then at most one variable in πA(T ) occurs more than once in T .

Prove that if q = (T , u) is a typed repeat-restricted tableau query over R, then there is a typed restricted SPJ query q′ such that the image of q′ under the algorithm of Exercise 4.19 part (a) is q.

Exercise 4.21
Extend Proposition 4.2.2 to include disjunction (i.e., union).

Exercise 4.22
The following query is used in this exercise:
(4.15)
Produce a binary relation that includes all tuples t, “excellent” where t is a movie directed by Allen, and all tuples t, “superb” where t is a movie directed by Hitchcock.

(a) Show that none of queries (4.10–4.15) can be expressed using the SPC or SPJR
algebras.

A positive selection formula for the SPC and SPJR algebras is a selection formula as before, except that disjunction can be used in addition to conjunction. Define the S+PC algebra to be the SPC algebra extended to permit arbitrary positive selection operators; and define the S+PJR
algebra analogously.

(b) Determine which of queries (4.10–4.15) can be expressed using the S+PJR algebra.

Define the SPC-1* algebra to be the SPC algebra, except that nonsingleton unary constant relations can be used as base queries; and define the SPC-n* algebra to be the SPC algebra,
68
Conjunctive Queries
except that nonsingleton constant relations of arbitrary arity can be used as base queries. Define the SPJR-1∗ and SPJR- n∗ algebras analogously.

(c) Determine which of queries (4.10–4.15) can be expressed using the SPJR-1∗ and SPJR-n∗ algebras.

(d) Determine the relative expressive powers of the S+PC, SPC-1∗, SPC-n∗, and SPCU
algebras.

Exercise 4.23
Give precise definitions for normal forms for the SPCU and SPJRU algebras, and prove that all expressions from these algebras have an equivalent in normal form.

Exercise 4.24
An nr-datalog program P is in normal form if all relation names in rule heads are identical. Prove that each nonrecursive datalog query with single relation target has an equivalent in normal form.

Exercise 4.25
Prove Theorem 4.5.2.

⋆ Exercise 4.26 Recall the discussion in Section 4.5 about disjunction in the conjunctive calculus.

(a) Consider the query q = {x|ϕ(x)}, where
ϕ(x) ≡ R(x) ∧ ∃y, z(S(y, x) ∨ S(x, z)).

Let I be an instance over {R, S}. Using the natural extension of the notion of satisfies to disjunction, show for each subformula of ϕ with form ∃ωψ, and each valuation ν
over free(∃ωψ) with range contained in adom(I) that: there exists c ∈ dom such that I |= ψ[ν ∪ {w/c}] iff there exists c ∈ adom(I) such that I |= ψ[ν ∪ {w/c}]. Conclude that this query can be evaluated by considering only valuations whose range is contained in adom(I).

(b) The positive existential ( relational) calculus is the relational calculus query language in which query formulas are constructed using ∧, ∨, ∃. Define a condition on positive existential calculus queries that guarantees that the answer involves only constants from adom(q, I) and such that the answer can be obtained by considering only valuations whose range is contained in adom(q, I). Extend the restriction for the case when equality is allowed in the calculus.

(c) Prove that the family of restricted positive existential calculus queries defined in the previous part has expressive power equivalent to the rule-based conjunctive queries with union and that this result still holds if equality is added to both families of queries.

Exercise 4.27
(a) Consider as an additional algebraic operation, the difference. The semantics of q − q′ is given by [q − q′](I) = q(I) − q′(I). Show that the difference cannot be simulated in the SPCU or SPJRU algebras. ( Hint: Use the monotonicity property of these algebras.)

(b) Negation can be added to (generalized) selection formulas in the natural way—that is, if γ is a selection formula, then so is (¬γ ). Give a precise definition for the syntax and semantics of selection with negation. Prove that the SPCU algebra cannot simulate selections of the form σ¬1=2(R) or σ¬1=a(R).

Exercises
69
Exercise 4.28
Show that intersection can be expressed in the SPC algebra.

⋆ Exercise 4.29
(a) Prove that there is no redundant operation in the set χ = {σ, π, ×, ∪} of unnamed algebra operators (i.e., for each operator α in the set, exhibit a schema and an algebraic query q over that schema such that q cannot be expressed with χ − {α}).

(b) Prove the analogous result for the set of named operators {σ, π, ⊲⊳, δ, ∪}.

Exercise 4.30
An inequality atom is an expression of the form x = y or x = a, where x, y are variables and a is a constant. Assuming that the underlying domain has a total order, a comparison atom is an expression of the form xθy, xθ a, or aθ x, where θ ranges over <, ≤, >, and ≥.

(a) Show that the family of rule-based conjunctive queries with equality and inequality strictly dominates the family of rule-based conjunctive queries with equality.

(b) Assuming that the underlying domain has a total order, describe the relationships between the expressive powers of the family of rule-based conjunctive queries with equality; the family of rule-based conjunctive queries with equality and inequality; the family of rule-based conjunctive queries with equality and comparison atoms; and the family of rule-based conjunctive queries with equality, inequality, and comparison atoms.

(c) Develop analogous extensions and results for tableau queries, the conjunctive calculus, and SPC and SPJR algebras.

⋆ Exercise 4.31 For some films, we may not want to store any actor name. Add to the domain a constant ⊥ meaning unknown information. Propose an extension of the SPJR queries to handle unknown information (see Chapter 19).

5 AddingNegation:Algebra
and Calculus
Alice:
Conjunctive queries are great. But what if I want to see a movie that doesn’t feature Woody Allen?

Vittorio:
We have to introduce negation.

Sergio:
It is basically easy.

Riccardo:
But the calculus is a little feisty.

Asindicatedinthepreviouschapter,theconjunctivequeries,evenifextendedbyunion, cannot express queries such as the following:
(5.1)
What are the Hitchcock movies in which Hitchcock did not play?

(5.2)
What movies are featured at the Gaumont Opera but not at the Gaumont les Halles?

(5.3)
List those movies for which all actors of the movie have acted under Hitchcock’s direction.

This chapter explores how negation can be added to all forms of the conjunctive queries (except for the tableau queries) to provide the power needed to express such queries. This yields languages in the various paradigms that have the same expressive power. They include relational algebra, relational calculus, and nonrecursive datalog with negation. The class of queries they express is often referred to as the first-order queries because relational calculus is essentially first-order predicate calculus without function symbols. These languages are of fundamental importance in database systems. They provide adequate power for many applications and at the same time can be implemented with reasonable efficiency.

They constitute the basis for the standard commercial relational languages, such as SQL.

In the case of the algebras, negation is added using the set difference operator, yielding the language(s) generally referred to as relational algebra (Section 5.1). In the case of the rule-based paradigm, we consider negative literals in the bodies of rules, which are interpreted as the absence of the corresponding facts; this yields nonrecursive datalog¬
(Section 5.2).

Adding negation in the calculus paradigm raises some serious problems that require effort and care to resolve satisfactorily. In the development in this chapter, we proceed in two stages. First (Section 5.3) we introduce the calculus, illustrate the problematic issues of
“safety” and domain independence, and develop some simple solutions for them. We also show the equivalence between the algebra and the calculus at this point. The material in this section provides a working knowledge of the calculus that is adequate for understanding the study of its extensions in Parts D and E. The second stage in our study of the calculus 70
5.1 The Relational Algebras
71
(Section 5.4) focuses on the important problem of finding syntactic restrictions on the calculus that ensure domain independence.

The chapter concludes with brief digressions concerning how aggregate functions can be incorporated into the algebra and calculus (Section 5.5), and concerning the emerging area of constraint databases, which provide a natural mechanism for representing and manipulating infinite databases in a finite manner (Section 5.6).

From the theoretical perspective, the most important aspects of this chapter include the demonstration of the equivalence of the algebra and calculus (including a relatively direct transformation of calculus queries into equivalent algebra ones) and the application of the classical proof technique of structural induction used on both calculus formulas and algebra expressions.

5.1
The Relational Algebras
Incorporating the difference operator, denoted ‘−’, into the algebras is straightforward. As with union and intersection, this can only be applied to expressions that have the same sort, in the named case, or arity, in the unnamed case.

Example 5.1.1
In the named algebra, query (5.1) is expressed by
π Title σ Director=“Hitchcock”( Movies) − π Title σ Actor=“Hitchcock”( Movies).

The unnamed relational algebra is obtained by adding the difference operator to the SPCU algebra. It is conventional also to permit the intersection operator, denoted ‘∩’ in this algebra, because it is simulated easily using cross-product, select, and project or using difference (see Exercise 5.4). Because union is present, nonsingleton constant relations may be used in this algebra. Finally, the selection operator can be extended to permit negation (see Exercise 5.4).

The named relational algebra is obtained in an analogous fashion, and similar generalizations can be developed.

As shown in Exercise 5.5, the family of unnamed algebra operators {σ, π, ×, ∪, −} is nonredundant, and the same is true for the named algebra operators {σ, π, ⊲⊳, δ, ∪, −}. It is easily verified that the algebras are not monotonic, nor are all algebra queries satisfiable (see Exercise 5.6). In addition, the following is easily verified (see Exercise 5.7): Proposition 5.1.2
The unnamed and named relational algebras have equivalent
expressive power.

The notion of composition of relational algebra queries can be defined in analogy to the composition of conjunctive queries described in the previous chapter. It is easily verified that the relational algebras, and hence the other equivalent languages presented in this chapter, are closed under composition.

72
Adding Negation: Algebra and Calculus
5.2
Nonrecursive Datalog with Negation
To obtain a rule-based language with expressive power equivalent to the relational algebra, we extend nonrecursive datalog programs by permitting negative literals in rule bodies.

This yields the nonrecursive datalog with negation also denoted nonrecursive datalog¬
and nr-datalog¬.

A nonrecursive datalog¬ ( nr-datalog¬) rule is a rule of the form q :
S(u) ← L1, . . . , Ln,
where S is a relation name, u is a free tuple of appropriate arity, and each Li is a literal [i.e., an expression of the form R(v) or ¬R(v), where R is a relation name and v is a free tuple of appropriate arity and where S does not occur in the body]. This rule is range restricted if each variable x occurring in the rule occurs in at least one literal of the form R(v) in the rule body. Unless otherwise specified, all datalog¬ rules considered are assumed to be range restricted.

To give the semantics of the foregoing rule q, let R be a relation schema that includes all of the relation names occurring in the body of the rule q, and let I be an instance of R.

Then the image of I under q is
q(I) = {ν(u) | ν is a valuation and for each i ∈ [1, n],
ν(ui) ∈ I(Ri), if Li = Ri(ui), and
ν(ui) ∈ I(Ri), if Li = ¬Ri(ui)}.

In general, this image can be expressed as a difference q1 − q2, where q1 is an SPC query and q2 is an SPCU query (see Exercise 5.9).

Equality may be incorporated by permitting literals of the form s = t and s = t for terms s and t. The notion of range restriction in this context is defined as it was for rule-based conjunctive queries with equality. The semantics are defined in the natural manner.

To obtain the full expressive power of the relational algebras, we must consider sets of nr-datalog¬ rules; these are analogous to the nr-datalog programs introduced in the previous chapter. A nonrecursive datalog¬ program (with or without equality) over schema R is a sequence
S1 ← body1
S2 ← body2
...

Sm ← bodym
of nr-datalog¬ rules, where no relation name in R occurs in a rule head; the same relation name may appear in more than one rule head; and there is some ordering r1, . . . , rm of the rules so that the relation name in the head of a rule ri does not occur in the body of a rule rj whenever j ≤ i. The semantics of these programs are entirely analogous to
5.3 The Relational Calculus
73
the semantics of nr-datalog programs. An nr-datalog¬ query is a query defined by some nr-datalog¬ program with a specified target relation.

Example 5.2.1
Assume that each movie in Movies has one director. Query (5.1) is answered by
ans( x) ← Movies(x, “Hitchcock”, z),
¬ Movies(x, “Hitchcock”, “Hitchcock”).

Query (5.3) is answered by
Hitch- actor(z) ← Movies(x, “Hitchcock”, z)
not- ans(x) ← Movies(x, y, z), ¬ Hitch- actor(z) ans(x) ← Movies(x, y, z), ¬ not- ans(x).

Care must be taken when forming nr-datalog¬ programs. Consider, for example, the following program, which forms a kind of merging of the first two rules of the previous program. (Intuitively, the first rule is a combination of the first two rules of the preceding program, using variable renaming in the spirit of Example 4.3.1.)

bad-not-ans(x) ← Movies(x, y, z), ¬ Movies(x′, “Hitchcock”, z), Movies(x′, “Hitchcock”, z′),
ans(x) ← Movies(x, y, z), ¬ bad-not-ans(x)
Rather than expressing query (5.3), it expresses the following:
(5.3′)
(Assuming that all movies have only one director) list those movies for which all actors of the movie acted in all of Hitchcock’s movies.

It is easily verified that each nr-datalog¬ program with equality can be simulated by an nr-datalog¬ program not using equality (see Exercise 5.10). Furthermore (see Exercise 5.11), the following holds:
Proposition 5.2.2
The relational algebras and the family of nr-datalog¬ programs that have single relation output have equivalent expressive power.

5.3
The Relational Calculus
Adding negation in the calculus paradigm yields an extremely flexible query language, which is essentially the predicate calculus of first-order logic (without function symbols).

However, this flexibility brings with it a nontrivial cost: If used without restriction, the calculus can easily express queries whose “answers” are infinite. Much of the theoretical development in this and the following section is focused on different approaches to make
74
Adding Negation: Algebra and Calculus
the calculus “safe” (i.e., to prevent this and related problems). Although considerable effort is required, it is a relatively small price to pay for the flexibility obtained.

This section first extends the syntax of the conjunctive calculus to the full calculus.

Then some intuitive examples are presented that illustrate how some calculus queries can violate the principle of “domain independence.” A variety of approaches have been developed to resolve this problem based on the use of both semantic and syntactic restrictions.

This section focuses on semantic restrictions. The first step in understanding these is a somewhat technical definition based on “relativized interpretation” for the semantics of (arbitrary) calculus queries; the semantics are defined relative to different “underlying domains” (i.e., subsets of dom). This permits us to give a formal definition of domain independence and leads to a family of different semantics for a given query.

The section closes by presenting the equivalence of the calculus under two of the semantics with the algebra. This effectively closes the issue of expressive power of the calculus, at least from a semantic point of view. One of the semantics for the calculus presented here is the “active domain” semantics; this is particularly convenient in the development of theoretical results concerning the expressive power of a variety of languages presented in Parts D and E.

As noted in Chapter 4, the calculus presented in this chapter is sometimes called the domain calculus because the variables range over elements of the underlying domain of values. Exercise 5.23 presents the tuple calculus, whose variables range over tuples, and its equivalence with the domain calculus and the algebra. The tuple calculus and its variants are often used in practice. For example, the practical languages SQL and Quel can be viewed as using tuple variables.

Well-Formed Formulas, Revisited
We obtain the relational calculus from the conjunctive calculus with equality by adding negation (¬), disjunction (∨), and universal quantification (∀). (Explicit equality is needed to obtain the full expressive power of the algebras; see Exercise 5.12.) As will be seen, both disjunction and universal quantification can be viewed as consequences of adding negation, because ϕ ∨ ψ ≡ ¬(¬ϕ ∧ ¬ψ) and ∀xϕ ≡¬∃x¬ϕ.

The formal definition of the syntax of the relational calculus is a straightforward extension of that for the conjunctive calculus given in the previous chapter. We include the full definition here for the reader’s convenience. A term is a constant or a variable. For a given input schema R, the base formulas include, as before, atoms over R and equality (inequality) atoms of the form e = e′ (e = e′) for terms e, e′. The ( well-formed) formulas of the relational calculus over R include the base formulas and formulas of the form (a) (ϕ ∧ ψ), where ϕ and ψ are formulas over R;
(b) (ϕ ∨ ψ), where ϕ and ψ are formulas over R;
(c) ¬ϕ, where ϕ is a formula over R;
(d) ∃xϕ, where x is a variable and ϕ a formula over R;
(e) ∀xϕ, where x is a variable and ϕ a formula over R.

As with conjunctive calculus,
5.3 The Relational Calculus
75
∃x1, x2, . . . , xmϕ abbreviates ∃x1∃x2 . . . ∃xmϕ, and
∀x1, x2, . . . , xmϕ abbreviates∀x1∀x2 . . . ∀xmϕ.

It is sometimes convenient to view the binary connectives ∧ and ∨ as polyadic connectives.

In some contexts, e = e′ is viewed as an abbreviation of ¬(e = e′).

It is often convenient to include two additional logical connectives, implies (→) and is equivalent to (↔). We view these as syntactic abbreviations as follows: ϕ → ψ ≡ ¬ϕ ∨ ψ
ϕ ↔ ψ ≡ (ϕ ∧ ψ ) ∨ (¬ϕ ∧ ¬ψ ).

The notions of free and bound occurrences of variables in a formula, and of free(ϕ) for formula ϕ, are defined analogously to their definition for the conjunctive calculus. In addition, the notion of relational calculus query is defined, in analogy to the notion of conjunctive calculus query, to be an expression of the form
{e1, . . . , em : A1, . . . , Am | ϕ}, in the named perspective,
{e1, . . . , em | ϕ}, in the unnamed perspective,
or if the sort is understood from the context,
where e1, . . . , em are terms, repeats permitted, and where the set of variables occurring in e1, . . . , em is exactly free(ϕ).

Example 5.3.1
Suppose that each movie has just one director. Query (5.1) can be expressed in the relational calculus as
{xt | ∃xa Movies(xt, “Hitchcock”, xa) ∧
¬ Movies(xt, “Hitchcock”, “Hitchcock”)}.

Query (5.3) is expressed by
{xt | ∃xd, xa Movies(xt, xd, xa) ∧
∀ya (∃yd Movies(xt, yd, ya)
→ ∃zt Movies(zt, “Hitchock”, ya))}.

The first conjunct ensures that the variable xt ranges over titles in the current value of Movies, and the second conjunct enforces the condition on actors of the movie identified by xt.

“Unsafe” Queries
Before presenting the alternative semantics for the relational calculus, we present an intuitive indication of the kinds of problems that arise if the conventional definitions from predicate calculus are adapted directly to the current context.

76
Adding Negation: Algebra and Calculus
The fundamental problems of using the calculus are illustrated by the following expressions:
( unsafe-1)
{x | ¬ Movies(“Cries and Whispers”, “Bergman”, x)}
( unsafe-2)
{x, y | Movies(“Cries and Whispers”, “Bergman”, x)
∨ Movies(y, “Bergman”, “Ullman”)}.

If the usual semantics of predicate calculus are adapted directly to this context, then the query ( unsafe-1) produces all tuples a where a ∈ dom and “Cries and Whispers”,
“Bergman”, a is not in the input. Because all input instances are by definition finite, the query yields an infinite set on all input instances. The same is true of query ( unsafe-2), even though it does not use explicit negation.

An intuitively appealing approach to resolving this problem is to view the different relation columns as typed and to insist that variables occurring in a given column range over only values of the appropriate type. For example, this would imply that the answer to query ( unsafe-1) is restricted to the set of actors. This approach is not entirely satisfactory because query answers now depend on the domains of the types. For example, different answers are obtained if the type Actor includes all and only the current actors [i.e., persons occurring in π Actor( Movies)] or includes all current and potential actors. This illustrates that query ( unsafe-1) is not independent of the underlying domain within which the query is interpreted (i.e., it is not “domain independent”). The same is true of query ( unsafe-2).

Even if the underlying domain is finite, users will typically not know the exact contents of the domains used for each variable. In this case it would be disturbing to have the result of a user query depend on information not directly under the user’s control. This is another argument for permitting only domain-independent queries.

A related but more subtle problem arises with regard to the interpretation of quantified variables. Consider the query
( unsafe-3)
{x | ∀yR(x, y)}.

The answer to this query is necessarily finite because it is a subset of π1(R). However, the query is not domain independent. To see why, note that if y is assumed to range over all of dom, then the answer is always the empty relation. On the other hand, if the underlying domain of interpretation is finite, it is possible that the answer will be nonempty. (This occurs, for example, if the domain is {1, . . . , 5}, and the input for R is {3, 1, . . . 3, 5}.) So again, this query depends on the underlying domain(s) being used (for the different variables) and is not under the user’s control.

There is a further difficulty of a more practical nature raised by query ( unsafe-3).

Specifically, if the intuitively appealing semantics of the predicate calculus are used, then the naive approach to evaluating quantifiers leads to the execution of potentially infinite procedures. Although the proper answer to such queries can be computed in a finite manner (see Theorem 5.6.1), this is technically intricate.

The following example indicates how easy it is to form an unsafe query mistakenly in practice.

5.3 The Relational Calculus
77
Example 5.3.2
Recall the calculus query answering query (5.3) in Example 5.3.1. Suppose that the first conjunct of that query is omitted to obtain the following:
{xt | ∀ya(∃yd Movies(xt, yd, ya)
→ ∃zt Movies(zt, “Hitchcock”, ya))}.

This query returns all titles of movies that have the specified property and also all elements of dom not occurring in π Title( Movies). Even if xt were restricted to range over the set of actual and potential movie titles, it would not be domain independent.

Relativized Interpretations
We now return to the formal development. As the first step, we present a definition that will permit us to talk about calculus queries in connection with different underlying domains.

Under the conventional semantics associated with predicate calculus, quantified variables range over all elements of the underlying domain, in our case, dom. For our purposes, however, we generalize this notion to permit explicit specification of the underlying domain to use (i.e., over which variables may range).

A relativized instance over schema R is a pair (d, I), where I is an instance over R and adom(I) ⊆ d ⊆ dom. A calculus formula ϕ is interpretable over (d, I) if adom(ϕ) ⊆ d. In this case, if ν is a valuation over free(ϕ) with range contained in d, then I satisfies ϕ for ν
relative to d, denoted I |=d ϕ[ν], if (a) ϕ = R(u) is an atom and ν(u) ∈ I(R);
(b) ϕ = (s = s′) is an equality atom and ν(s) = ν(s′);
(c) ϕ = (ψ ∧ ξ ) and1 I |=d ψ[ν| free(ψ)] and I |=d ξ [ν| free(ξ)]; (d) ϕ = (ψ ∨ ξ ) and I |=d ψ[ν| free(ψ)] or I |=d ξ [ν| free(ξ)]; (e) ϕ = ¬ψ and I |=d ψ[ν] (i.e., I |=d ψ[ν] does not hold); (f) ϕ = ∃xψ and for some c ∈ d, I |=d ψ[ν ∪ {x/c}]; or (g) ϕ = ∀xψ and for each c ∈ d, I |=d ψ[ν ∪ {x/c}].

The notion of “satisfies . . . relative to” just presented is equivalent to the usual notion of satisfaction found in first-order logic, where the set d plays the role of the universe of discourse in first-order logic. In practical database settings it is most natural to assume that the underlying universe is dom; for this reason we use specialized terminology here.

Recall that for a query q and input instance I, we denote adom(q) ∪ adom(I) by adom(q, I), and the notation adom(ϕ, I) for formula ϕ is defined analogously.

We can now define the relativized semantics for the calculus. Let R be a schema, q = {e1, . . . , en | ϕ} a calculus query over R, and (d, I) a relativized instance over R. Then 1 ν|V for variable set V denotes the restriction of ν to V .

78
Adding Negation: Algebra and Calculus
the image of I under q relative to d is qd(I) = {ν(e1, . . . , en) | I |=d ϕ[ν], ν is a valuation over free(ϕ) with range ⊆ d}.

Note that if d is infinite, then this image may be an infinite set of tuples.

As a minor generalization, for arbitrary d ⊆ dom, the image of q on I relative to d is defined by2
qd(I) = qd∪ adom(q, I)(I).

Example 5.3.3
Consider the query
q = {x | R(x) ∧ ∃y(¬R(y) ∧ ∀z(R(z) ∨ z = y))}
Then
qdom(I ) = {} for any instance I over R
q{1,2,3,4}(J1) = {} for J1 = {1, 2} over R
q{1,2,3,4}(J2) = J2 for J2 = {1, 2, 3} over R
q{1,2,3,4}(J3) = {} for J3 = {1, 2, 3, 4} over R
q{1,2,3,4}(J4) = J4 for J4 = {1, 2, 3, 5} over R.

This illustrates that under an interpretation relative to a set d, a calculus query q on input I may be affected by |d − adom(q, I)|.

It is important to note that the semantics of algebra and datalog¬ queries q evaluated on instance I are independent of whether dom or some subset d satisfying adom(q, I) ⊆
d ⊆ dom is used as the underlying domain.

The Natural and Active Domain Semantics for Calculus Queries
The relativized semantics for calculus formulas immediately yields two important semantics for calculus queries. The first of these corresponds most closely to the conventional interpretation of predicate calculus and is thus perhaps the intuitively most natural semantics for the calculus.

Definition 5.3.4
For calculus query q and input instance I, the natural (or unrestricted) interpretation of q on I, denoted qnat(I), is qdom(I) if this is finite and is undefined otherwise.

2 Unlike the convention of first-order logic, interpretations over an empty underlying domain are permitted; this arises only with empty instances.

5.3 The Relational Calculus
79
The second interpretation is based on restricting quantified variables to range over the active domain of the query and the input. Although this interpretation is unnatural from the practical perspective, it has the advantage that the output is always defined (i.e., finite). It is also a convenient semantics for certain theoretical developments.

Definition 5.3.5
For calculus query q and input instance I, the active domain interpretation of q on I, denoted q adom(I), is q adom(q, I)(I). The family of mappings obtained from calculus queries under the active domain interpretation is denoted CALC adom.

Example 5.3.6
Recall query ( unsafe-2). Under the natural interpretation on input the instance I shown in Chapter 3, this query yields the undefined result. On the other hand, under the active domain interpretation this yields as output (written informally) ({actors in “Cries and Whispers”} × adom(I)) ∪ ( adom(I) × {movies by Bergman featuring Ullman}), which is finite and defined.

Domain Independence
As noted earlier, there are two difficulties with the natural interpretation of the calculus from a practical point of view: (1) it is easy to write queries with undefined output, and (2) even if the output is defined, the naive approach to computing it may involve consideration of quantifiers ranging over an infinite set. The active domain interpretation solves these problems but generally makes the answer dependent on information (the active domain) not readily available to users. One approach to resolving this situation is to restrict attention to the class of queries that yield the same output on all possible underlying domains.

Definition 5.3.7
A calculus query q is domain independent if for each input instance I, and each pair d, d′ ⊆ dom, qd(I) = qd′(I). If q is domain independent, then the image of q on input instance I, denoted simply q(I), is qdom(I) [or equivalently, q adom(I)]. The family of mappings obtained from domain-independent calculus queries is denoted CALCdi.

In particular, if q is domain independent, then the output according to the natural interpretation can be obtained by computing the active domain interpretation. Thus, Lemma 5.3.8
CALCdi ⊑ CALC adom.

Example 5.3.9
The two calculus queries of Example 5.3.1 are domain independent, and the query of Example 5.3.2 is not (see Exercise 5.15).

Equivalence of Algebra and Calculus
We now demonstrate the equivalence of the various languages introduced so far in this chapter.

80
Adding Negation: Algebra and Calculus
Theorem 5.3.10 (Equivalence Theorem)
The domain-independent calculus, the calcu-
lus under active domain semantics, the relational algebras, and the family of nr-datalog¬
programs that have single-relation output have equivalent expressive power.

Proposition 5.2.2 shows that nr-datalog¬ and the algebras have equivalent expressive power. In addition, Lemma 5.3.8 shows that CALCdi ⊑ CALC adom. To complete the proof, we demonstrate that
(i) algebra ⊑ CALCdi (Lemma 5.3.11)
(ii) CALC adom ⊑ algebra (Lemma 5.3.12).

Lemma 5.3.11
For each unnamed algebra query, there is an equivalent domain-independent calculus query.

Proof
Let q be an unnamed algebra query with arity n. We construct a domain-independent query q′ = {x1, . . . , xn | ϕq} that is equivalent to q. The formula ϕq is constructed using an induction on subexpressions of q. In particular, for subexpression E of q, we define ϕE according to the following cases:
(a) E is R for some R ∈ R: ϕE is R(x1, . . . , x arity(R)).

(b) E is {u1, . . . , um}, where each uj is a tuple of arity α: ϕE is (x1 = u1(1) ∧ · · · ∧ xα = u1(α)) ∨ · · · ∨ (x1 = um(1) ∧ · · · ∧ xα = um(α)).

(c) E is σF (E1): ϕE is ϕE ∧ ψ
1
F , where ψF is the formula obtained from F by
replacing each coordinate identifier i by variable xi.

(d) E is πi
(E
1,...,in
1): ϕE is
∃yi , . . . , y ((x
∧ · · · ∧ x
) ∧ ∃y . . . ∃y ϕ (y
1
in
1 = yi1
n = yin
j1
jl E1
1, . . . , y arity(E1))),
where j1, . . . , jl is a listing of [1, arity(E1)] − {i1, . . . , in}.

(e) E is E1 × E2: ϕE is ϕE ∧ ϕ (x
1
E2
arity(E1)+1, . . . , x arity(E1)+ arity(E2)).

(f) E is E1 ∪ E2: ϕE is ϕE ∨ ϕ .

1
E2
(g) E is E1 − E2: ϕE is ϕE ∧ ¬ϕ .

1
E2
We leave verification of this construction and the properties of q′ to the reader (see Exercise 5.13a).

Lemma 5.3.12
For each calculus query q, there is a query in the unnamed algebra that is equivalent to q under the active domain interpretation.

Crux
Let q = {x1, . . . , xn | ϕ} be a calculus query over R. It is straightforward to develop a unary algebra query E adom such that for each input instance I,
5.4 Syntactic Restrictions for Domain Independence 81
E adom(I) = {a | a ∈ adom(q, I)}.

Next an inductive construction is performed. To each subformula ψ(y1, . . . , ym) of ϕ this associates an algebra expression Eψ with the property that (abusing notation slightly)
{y1, . . . , ym | ψ} adom(q, I)(I) = Eψ(I) ∩ ( adom(q, I))m.

[This may be different from using the active domain semantics on ψ, because we may have adom(ψ, I) ⊂ adom(q, I).] It is clear that Eϕ is equivalent to q under the active domain semantics.

We now illustrate a few cases of the construction of expressions Eψ and leave the rest for the reader (see Exercise 5.13b). Suppose that ψ is a subformula of ϕ. Then Eψ is constructed in the following manner:
(a) ψ(y1, . . . , ym) is R(t1, . . . , tl), where each ti is a constant or in $y: Then Eψ ≡
π$(σ
k
F (R)), where $
k and F are chosen in accordance with $
y and $t.

(b) ψ(y1, y2) is y1 = y2: Eψ is σ1=2(E adom × E adom).

(c) ψ(y1, y2, y3) is ψ′(y1, y2) ∨ ψ′′(y2, y3): Eψ is (Eψ′ × E adom) ∪ (E adom × Eψ′′).

(d) ψ(y1, . . . , ym) is ¬ψ′(y1, . . . , ym): Eψ is (E adom × · · · × E adom) − Eψ′.

5.4
Syntactic Restrictions for Domain Independence
As seen in the preceding section, to obtain the natural semantics for calculus queries, it is desirable to focus on domain independent queries. However, as will be seen in the following chapter (Section 6.3), it is undecidable whether a given calculus query is domain independent. This has led researchers to develop syntactic conditions that ensure domain independence, and many such conditions have been proposed.

Several criteria affect the development of these conditions, including their generality, their simplicity, and the ease with which queries satisfying the conditions can be translated into the relational algebra or other lower-level representations. We present one such condition here, called “safe range,” that is relatively simple but that illustrates the flavor and theoretical properties of many of these conditions. It will serve as a vehicle to illustrate one approach to translating these restricted queries into the algebra. Other examples are explored in Exercises 5.25 and 5.26; translations of these into the algebra are considerably more involved.

This section begins with a brief digression concerning equivalence preserving rewrite rules for the calculus. Next the family CALCsr of safe-range queries is introduced. It is shown easily that the algebra ⊑ CALCsr. A rather involved construction is then presented for transforming safe-range queries into the algebra. The section concludes by defining a variant of the calculus that is equivalent to the conjunctive queries with union.

82
Adding Negation: Algebra and Calculus
1
ϕ ∧ ψ
↔
ψ ∧ ϕ
2
ψ1 ∧ · · · ∧ ψn ∧ (ψn+1 ∧ ψn+2)
↔
ψ1 ∧ · · · ∧ ψn ∧ ψn+1 ∧ ψn+2
3
ϕ ∨ ψ
↔
ψ ∨ ϕ
4
ψ1 ∨ · · · ∨ ψn ∨ (ψn+1 ∨ ψn+2)
↔
ψ1 ∨ · · · ∨ ψn ∨ ψn+1 ∨ ψn+2
5
¬(ϕ ∧ ψ)
↔
(¬ϕ) ∨ (¬ψ )
6
¬(ϕ ∨ ψ)
↔
(¬ϕ) ∧ (¬ψ )
7
¬(¬ϕ)
↔
ϕ
8
∃xϕ
↔
¬∀x¬ϕ
9
∀xϕ
↔
¬∃x¬ϕ
10
¬∃xϕ
↔
∀x¬ϕ
11
¬∀xϕ
↔
∃x¬ϕ
12
∃xϕ ∧ ψ
↔
∃x(ϕ ∧ ψ) (x not free in ψ)
13
∀xϕ ∧ ψ
↔
∀x(ϕ ∧ ψ) (x not free in ψ)
14
∃xϕ ∨ ψ
↔
∃x(ϕ ∨ ψ) (x not free in ψ)
15
∀xϕ ∨ ψ
↔
∀x(ϕ ∨ ψ) (x not free in ψ)
16
∃xϕ
↔
∃yϕx (
y
y not free in ϕ)
17
∀xϕ
↔
∀yϕx (
y
y not free in ϕ)
Figure 5.1:
Equivalence-preserving rewrite rules for calculus formulas
Equivalence-Preserving Rewrite Rules
We now digress for a moment to present a family of rewrite rules for the calculus. These preserve equivalence regardless of the underlying domain used to evaluate calculus queries.

Several of these rules will be used in the transformation of safe-range queries into the algebra.

Calculus formulas ϕ, ψ over schema R are equivalent, denoted ϕ ≡ ψ, if for each I over R, d ⊆ dom, and valuation ν with range ⊆ d I |=d∪ adom(ϕ, I) ϕ[ν] if and only if I |=d∪ adom(ψ, I) ψ[ν].

(It is verified easily that this generalizes the notion of equivalence for conjunctive calculus formulas.)

Figure 5.1 shows a number of equivalence-preserving rewrite rules for calculus formulas. It is straightforward to verify that if ψ transforms to ψ′ by a rewrite rule and if ϕ′
is the result of replacing an occurrence of subformula ψ of ϕ by formula ψ′, then ϕ′ ≡ ϕ
(see Exercise 5.14).

Note that, assuming x ∈ free(ψ) and y ∈ free(ϕ),
∃xϕ ∧ ∀yψ ≡ ∃x∀y(ϕ ∧ ψ) ≡ ∀y∃x(ϕ ∧ ψ).

Example 5.4.1
Recall from Chapter 2 that a formula ϕ is in prenex normal form (PNF) if it has the form %1x1 . . . %nxnψ, where each %i is either ∀ or ∃, and no quantifiers occur in ψ. In this case, ψ is called the matrix of formula ϕ.

5.4 Syntactic Restrictions for Domain Independence 83
A formula ψ without quantifiers or connectives → or ↔ is in conjunctive normal form (CNF) if it has the form ξ1 ∧ · · · ∧ ξm (m ≥ 1), where each conjunct ξj has the form L1 ∨ · · · ∨ Lk (k ≥ 1) and where each Ll is a literal (i.e., atom or negated atom). Similarly, a formula ψ without quantifiers or connectives → or ↔ is in disjunctive normal form (DNF) if it has the form ξ1 ∨ · · · ∨ ξm, where each disjunct ξj has the form L1 ∧ · · · ∧ Lk where each Ll is a literal (i.e., atom or negated atom).

It is easily verified (see Exercise 5.14) that the rewrite rules can be used to transform an arbitrary calculus formula into an equivalent formula that is in PNF with a CNF matrix, and into an equivalent formula that is in PNF with a DNF matrix.

Safe-Range Queries
The notion of safe range is presented now in three stages, involving (1) a normal form called SRNF, (2) a mechanism for determining how variables are “range restricted” by subformulas, and (3) specification of a required global property of the formula.

During this development, it is sometimes useful to speak of calculus formulas in terms of their parse trees. For example, we will say that the formula (R(x) ∧ ∃y(S(y, z)) ∧
¬T (x, z)) has ‘and’ or ∧ as a root (which has an atom, an ∃, and a ¬ as children).

The normalization of formulas puts them into a form more easily analyzed for safety without substantially changing their syntactic structure. The following equivalence-preserving rewrite rules are used to place a formula into safe-range normal form (SRNF): Variable substitution: This is from Section 4.2. It is applied until no distinct pair of quantifiers binds the same variable and no variable occurs both free and bound.

Remove universal quantifiers: Replace subformula ∀$
xψ by ¬∃$
x¬ψ . (This and the next
condition can be relaxed; see Example 5.4.5.)

Remove implications: Replace ψ → ξ by ¬ψ ∨ ξ , and similarly for ↔.

Push negations: Replace
(i) ¬¬ψ by ψ
(ii) ¬(ψ1 ∨ · · · ∨ ψn) by (¬ψ1 ∧ · · · ∧ ¬ψn)
(iii) ¬(ψ1 ∧ · · · ∧ ψn) by (¬ψ1 ∨ · · · ∨ ¬ψn)
so that the child of each negation is either an atom or an existentially quantified formula.

Flatten ‘and’s, ‘or’s, and existential quantifiers: This is done so that no child of an ‘and’
is an ‘and,’ and similarly for ‘or’ and existential quantifiers.

The SRNF formula resulting from applying these rules to ϕ is denoted SRNF(ϕ). A formula ϕ (query {$
e | ϕ}) is in SRNF if SRNF(ϕ) = ϕ.

Example 5.4.2
The first calculus query of Example 5.3.1 is in SRNF. The second calculus query is not in SRNF; the corresponding SRNF query is
84
Adding Negation: Algebra and Calculus
{xt | ∃xd, xa Movies(xt, xd, xa)∧
¬∃ya(∃yd Movies(xt, yd, ya)
∧ ¬∃zt Movies(zt, “Hitchcock”, ya))}.

Transforming the query of Example 5.3.2 into SRNF yields
{xt | ¬∃ya(∃yd Movies(xt, yd, ya)
∧ ¬∃zt Movies(zt, “Hitchcock”, ya))}.

We now present a syntactic condition on SRNF formulas that ensures that each variable is “range restricted,” in the sense that its possible values all lie within the active domain of the formula or the input. If a quantified variable is not range restricted, or if one of the free variables is not range restricted, then the associated query is rejected. To make the definition, we first define the set of range-restricted variables of an SRNF formula using the following procedure, which returns either the symbol ⊥, indicating that some quantified variable is not range restricted, or the set of free variables that is range restricted.

Algorithm 5.4.3 (Range restriction (rr))
Input: a calculus formula ϕ in SRNF
Output: a subset of the free variables of ϕ or3 ⊥
begin
case ϕ of
R(e1, . . . , en) : rr(ϕ) = the set of variables in {e1, . . . , en}; x = a or a = x : rr(ϕ) = {x};
ϕ1 ∧ ϕ2 : rr(ϕ) = rr(ϕ1) ∪ rr(ϕ2);
rr(ψ)
if {x, y} ∩ rr(ψ) = ∅,
ϕ1 ∧ x = y : rr(ϕ) =
rr(ψ ) ∪ {x, y}
otherwise;
ϕ1 ∨ ϕ2 : rr(ϕ) = rr(ϕ1) ∩ rr(ϕ2);
¬ϕ1 : rr(ϕ) = ∅;
∃$
xϕ1 : if $
x ⊆ rr(ϕ1)
then rr(ϕ) = rr(ϕ1) − $x
else return ⊥
end case
end
3 In the following, for each Z, ⊥ ∪ Z = ⊥ ∩ Z = ⊥ − Z = Z − ⊥ = ⊥. In addition, we show the case of binary ‘and’s, etc., but we mean this to include polyadic ‘and’s, etc. Furthermore, we sometimes use ‘$
x’ to denote the set of variables occurring in $
x.

5.4 Syntactic Restrictions for Domain Independence 85
Intuitively, the occurrence of a variable x in a base relation or in an atom of the form x = a restricts that variable. This restriction is propagated through ∧, possibly lost in ∨, and always lost in ¬. In addition, each quantified variable must be restricted by the subformula it occurs in.

A calculus query {u | ϕ} is safe range if rr(SRNF(ϕ)) = free(ϕ). The family of safe-range queries is denoted by CALCsr.

Example 5.4.4
Recall Examples 5.3.1 and 5.4.2. The first query of Example 5.3.1 is safe range. The first query of Example 5.4.2 is also safe range. However, the second query of Example 5.4.2 is not because the free variable xt is not range restricted by the formula.

Before continuing, we explore a generalization of the notion of safe range to permit universal quantification.

Example 5.4.5
Suppose that formula ϕ has a subformula of the form
ψ ≡∀$
x(ψ1($
x) → ψ2($
y)),
where $
x and $
y might overlap. Transforming into SRNF (and assuming that the parent of ψ
is not ¬), we obtain
ψ ′ ≡¬∃$
x(ψ1($
x) ∧ ¬ψ2($
y)).

Now rr(ψ′) is defined iff
(a) rr(ψ1) = $x, and
(b) rr(ψ2) is defined.

In this case, rr(ψ′) = ∅. This is illustrated by the second query of Example 5.3.1, that was transformed into SRNF in Example 5.4.2.

Thus SRNF can be extended to permit subformulas that have the form of ψ without materially affecting the development.

The calculus query constructed in the proof of Lemma 5.3.11 is in fact safe range. It thus follows that the algebra ⊑ CALCsr.

As shown in the following each safe range query is domain independent (Theorem 5.4.6). For this reason, if q is safe range we generally use the natural interpretation to evaluate it; we may also use the active domain interpretation.

The development here implies that all of CALCsr, CALCdi, and CALC adom are equivalent. When the particular choice is irrelevant to the discussion, we use the term relational calculus to refer to any of these three equivalent query languages.

86
Adding Negation: Algebra and Calculus
From Safe Range to the Algebra
We now present the main result of this section (namely, the translation of safe-range queries into the named algebra). Speaking loosely, this translation is relatively direct in the sense that the algebra query E constructed for calculus query q largely follows the structure of q. As a result, evaluation of E will in most cases be more efficient than using the algebra query that is constructed for q by the proof of Lemma 5.3.12.

Examples of the construction used are presented after the formal argument.

Theorem 5.4.6
CALCsr ≡ the relational algebra. Furthermore, each safe-range query is domain independent.

The proof of this theorem involves several steps. As seen earlier, the algebra ⊑
CALCsr. To prove the other direction, we develop a translation from safe-range queries into the named algebra. Because the algebra is domain independent, this will also imply the second sentence of the theorem.

To begin, let ϕ be a safe-range formula in SRNF. An occurrence of a subformula ψ in ϕ is self-contained if its root is ∧ or if
(i) ψ = ψ1 ∨ · · · ∨ ψn and rr(ψ) = rr(ψ1) = · · · = rr(ψn) = free(ψ); (ii) ψ = ∃$
xψ1 and rr(ψ) = free(ψ1); or
(iii) ψ = ¬ψ1 and rr(ψ) = free(ψ1).

A safe-range, SRNF formula ϕ is in4 relational algebra normal form (RANF) if each subformula of ϕ is self-contained.

Intuitively, if ψ is a self-contained subformula of ϕ that does not have ∧ as a root, then all free variables in ψ are range restricted within ψ. As we shall see, if ϕ is in RANF, this permits construction of an equivalent relational algebra query Eϕ using an induction from leaf to root.

We now develop an algorithm RANF-ALG that transforms safe-range SRNF formulas into RANF. It is based on the following rewrite rules:
(R1) Push-into-or: Consider the subformula
ψ = ψ1 ∧ · · · ∧ ψn ∧ ξ,
where
ξ = ξ1 ∨ · · · ∨ ξm.

Suppose that rr(ψ) = free(ψ), but rr(ξ1 ∨ · · · ∨ ξm) = free(ξ1 ∨ · · · ∨ ξm). Nondeterministically choose a subset i1, . . . , ik of 1, . . . , n such that ξ ′ = (ξ1 ∧ ψi ∧ · · · ∧ ψ ) ∨ · · · ∨ (ξ
∧ · · · ∧ ψ )
1
ik
m ∧ ψi1
ik
4 This is a variation of the notion of RANF used elsewhere in the literature; see Bibliographic Notes.

5.4 Syntactic Restrictions for Domain Independence 87
satisfies rr(ξ ′) = free(ξ ′). (One choice of i1, . . . , ik is to use all of 1, . . . , n; this necessarily yields a formula ξ ′ with this property.) Letting {j1, . . . , jl} = {1, . . . , n} −
{i1, . . . , ik}, set
ψ ′ = SRNF(ψj ∧ · · · ∧ ψ ∧ ξ ′).

1
jl
The application of SRNF to ξ ′ only has the effect of possibly renaming quantified variables5 and of flattening the roots of subformulas ξp ∧ ψi ∧ · · · ∧ ψ , where ξ
1
ik
p
has root ∧; analogous remarks apply. The rewrite rule is to replace subformula ψ by ψ ′ and possibly apply SRNF to flatten an ∨, if both l = 0 and the parent of ψ is ∨.

(R2) Push-into-quantifier: Suppose that
ψ = ψ1 ∧ · · · ∧ ψn ∧ ∃$
xξ,
where rr(ψ) = free(ψ), but rr(ξ ) = free(ξ ). Then replace ψ by ψ ′ = SRNF(ψj ∧ · · · ∧ ψ ∧ ∃$
xξ ′),
1
jl
where
ξ ′ = ψi ∧ · · · ∧ ψ ∧ ξ
1
ik
and where rr(ξ ′) = free(ξ ′) and {j1, . . . , jl} = {1, . . . , n} − {i1, . . . , ik}. The rewrite rule is to replace ψ by ψ′ and possibly apply SRNF to flatten an ∃.

(R3) Push-into-negated-quantifier: Suppose that
ψ = ψ1 ∧ · · · ∧ ψn ∧ ¬∃$
xξ,
where rr(ψ) = free(ψ), but rr(ξ ) = free(ξ ). Then replace ψ by ψ ′ = SRNF(ψ1 ∧ · · · ∧ ψn ∧ ¬∃$
xξ ′),
where
ξ ′ = ψi ∧ · · · ∧ ψ ∧ ξ
1
ik
and where rr(ξ ′) = free(ξ ′) and {i1, . . . , ik} ⊆ {1, . . . , n}. That ψ′ is equivalent to ψ
follows from the observation that the propositional formulas p ∧ q ∧ ¬r and p ∧ q ∧
¬(p ∧ r) are equivalent. The rewrite rule is to replace ψ by ψ′.

The algorithm RANF-ALG for applying these rewrite rules is essentially top-down and recursive. We sketch the algorithm now (see Exercise 5.19).

5 It is assumed that under SRNF renamed variables are chosen so that they do not occur in the full formula under consideration.

88
Adding Negation: Algebra and Calculus
Algorithm 5.4.7 (Relational Algebra Normal Form (RANF-ALG)) Input: a safe-range calculus formula ϕ in SRNF
Output: a RANF formula ϕ′ = RANF(ϕ) equivalent to ϕ
begin
while some subformula ψ (with its conjuncts possibly reordered) of ϕ satisfies the premise of R1, R2, or R3
do
case R1: (left as exercise)
R2: (left as exercise)
R3: Let ψ = ψ1 ∧ · · · ∧ ψn ∧ ¬∃$xξ
and ψi , . . . , ψ satisfy the conditions of R3;
1
ik
α := RANF(ψ1 ∧ · · · ∧ ψn);
β := RANF(SRNF(ψi ∧ · · · ∧ ψ ∧ ξ ));
1
ik
ψ ′ := α ∧ ¬∃$
xβ;
ϕ := result of replacing ψ by ψ ′ in ϕ;
end case
end while
end
The proof that these rewrite rules can be used to transform a safe-range SRNF formula into a RANF formula has two steps (see Exercise 5.19). First, a case analysis can be used to show that if safe-range ϕ in SRNF is not in RANF, then one of the rewrite rules (R1, R2, R3) can be applied. Second, it is shown that Algorithm 5.4.7 terminates.

This is accomplished by showing that (1) each successfully completed call to RANF-ALG
reduces the number of non-self-contained subformulas, and (2) if a call to RANF-ALG on ψ invokes other calls to RANF-ALG, the input to these recursive calls has fewer non-self-contained subformulas than does ψ.

We now turn to the transformation of RANF formulas into equivalent relational algebra queries. We abuse notation somewhat and assume that each variable is also an attribute.

(Alternatively, a one-one mapping var- to- att : var → att could be used.) In general, given a RANF formula ϕ with free variables x1, . . . , xn, we shall construct a named algebra expression Eϕ over attributes x1, . . . , xn such that for each input instance I, Eϕ(I) =
{x1, . . . , xn | ϕ}(I). (The special case of queries {e1, . . . , en | ϕ}, where some of the ei are constants, is handled by performing a join with the constants at the end of the construction.) A formula ϕ is in modified relational algebra normal form (modified RANF) if it is RANF, except that each polyadic ‘and’ is ordered and transformed into binary ‘and’s, so that atoms x = y (x = y) are after conjuncts that restrict one (both) of the variables involved and so that each free variable in a conjunct of the form ¬ξ occurs in some preceding conjunct. It is straightforward to verify that each RANF formula can be placed into modified RANF. Note that each subformula of a modified RANF formula is self-contained.

Let RANF formula ϕ be fixed. The construction of Eϕ is inductive, from leaf to root, and is sketched in the following algorithm. The special operator diff, on inputs R and S
where att(S) ⊂ att(R), is defined by
5.4 Syntactic Restrictions for Domain Independence 89
R diff S = R − (R ⊲⊳ S).

(Many details of this transformation, such as the construction of renaming function f , projection list $
k, and selection formula F in the first entry of the case statement, are left to the reader; see Example 5.4.9 and Exercise 5.19.)

Algorithm 5.4.8 (Translation into the Algebra)
Input: a formula ϕ in modified RANF
Output: an algebra query Eϕ equivalent to ϕ
begin
case ϕ of
R($
e)
δf (π$(σ
k
F (R)))
x = a
{x : a}
ψ ∧ ξ
if ξ is x = x, then Eψ
if ξ is x = y (with x, y distinct), then
σx=y(Eψ), if {x, y} ⊆ free(ψ)
σx=y(Eψ ⊲⊳ δx→yEψ), if x ∈ free(ψ) and y ∈ free(ψ)
σx=y(Eψ ⊲⊳ δy→xEψ), if y ∈ free(ψ) and x ∈ free(ψ)
if ξ is x = y, then σx=y(Eψ)
if ξ = ¬ξ ′, then
Eψ diff Eξ′, if free(ξ ′) ⊂ free(ψ)
Eψ − Eξ′, if free(ξ ′) = free(ψ)
otherwise, Eψ ⊲⊳ Eξ
¬ψ
{} − Eψ
(in the case that ¬ψ does not have ‘and’ as parent)
ψ1 ∨ · · · ∨ ψn
Eψ ∪ · · · ∪ E
1
ψn
∃x1, . . . , xnψ(x1, . . . , xn, y1, . . . , ym)
πy
(E
1,...,ym
ψ )
end case
end
Finally, let q = {x1, . . . , xn | ϕ} be safe range. Because the transformations used for SRNF and RANF are equivalence preserving, without loss of generality we can assume that ϕ is in modified RANF. To conclude the proof of Theorem 5.4.6, it must be shown that q and Eϕ are equivalent. In fact, it can be shown that for each instance I and each d satisfying adom(q, I) ⊆ d ⊆ dom,
qd(I) = Eϕ(I).

90
Adding Negation: Algebra and Calculus
This will also yield that q is domain independent.

Let I and d be fixed. A straightforward induction can be used to show that for each subformula ψ(y1, . . . , ym) of ϕ and each variable assignment ν with range d, I |=d ψ[ν] ⇔ ν(y1), . . . , ν(ym) ∈ Eψ(I)
(see Exercise 5.19.) This completes the proof of Theorem 5.4.6.

Example 5.4.9
(a) Consider the query
q1 = {a, x, y : A1A2A3 | ∃z(P (x, y, z) ∨ [R(x, y)∧
([S(z) ∧ ¬T (x, z)] ∨ [T (y, z)])])}.

The formula of q1 is in SRNF. Transformation into RANF yields
∃z(P (x, y, z) ∨ [R(x, y) ∧ S(z) ∧ ¬T (x, z)] ∨ [R(x, y) ∧ T (y, z)]).

Assuming the schemas P [B1B2B3], R[C1C2], S[D], and T [F1F2], transformation of this into the algebra yields
E = πx,y(δB1B2B3→xyz(P )
∪ ((δC1C2→xy(R) ⊲⊳ δD→z(S)) diff δF1F2→yz(T ))
∪ (δC1C2→xy(R) ⊲⊳ δF1F2→yz(T ))).

Finally, an algebra query equivalent to q1 is
{A1 : a} ⊲⊳ δxy→A
(E).

2A3
(b) Consider the query
q2 = {x | ∃y[R(x, y) ∧ ∀z(S(z, a) → T (y, z))
∧ ∃v, w(¬T (v, w) ∧ w = b ∧ v = x)]}.

Transforming to SRNF, we have
∃y[R(x, y) ∧ ¬∃z(S(z, a) ∧ ¬T (y, z)) ∧ ∃v, w(¬T (v, w) ∧ w = b ∧ v = x)].

Transforming to RANF and reordering the conjunctions, we obtain
∃y[∃v, w(R(x, y)∧w = b∧v = x ∧¬T (v, w))∧¬∃z(R(x, y)∧S(z, a)∧¬T (y, z))].

Assuming schemas R[A1, A2], S[B1, B2], and T [C1, C2], the equivalent algebra query is obtained using the program
5.5 Aggregate Functions
91
E1 := (δA1A2→xy(R) ⊲⊳ {w : b});
E2 := (σv=x(E1 ⊲⊳ δx→v(E1))) diff δC1C2→vw(T );
E3 := πx,y(E2);
E4 := πx,y(δA
(σ
1A2→xy (R) ⊲⊳ δB1→z(πB1
B2=a(S))) diff δC1C2→yz(T ));
E5 := πx(E3 − E4).

The Positive Existential Calculus
In Chapter 4, disjunction was incorporated into the rule-based conjunctive queries, and union was incorporated into the tableau, SPC, and SPJR queries. Incorporating disjunction into the conjunctive calculus was more troublesome because of the possibility of infinite “answers.” We now apply the tools developed earlier in this chapter to remedy this situation.

A positive existential ( calculus) query is a domain-independent calculus query q =
{e1, . . . , en | ϕ}, possibly with equality, in which the only logical connectives are ∧, ∨, and ∃. It is decidable whether a query q with these logical connectives is domain independent; and if so, q is equivalent to a safe-range query using only these connectives (see Exercise 5.16). The following is easily verified.

Theorem 5.4.10
The positive existential calculus is equivalent to the family of conjunctive queries with union.

5.5
Aggregate Functions
In practical query languages, the underlying domain is many-sorted, with sorts such as boolean, string, integer, or real. These languages allow the use of comparators such as ≤
between database entries in an ordered sort and “aggregate” functions such as sum, count, or average on numeric sorts. In this section, aggregate operators are briefly considered.

In the next section, a novel approach for incorporating arithmetic constraints into the relational model will be addressed.

Aggregate operators operate on collections of domain elements. The next example illustrates how these are used.

Example 5.5.1
Consider a relation Sales[ Theater, Title, Date, Attendance], where a tuple th, ti, d, a indicates that on date d a total of a people attended showings of movie ti at theater th. We assume that { Theater, Title, Date} is a key, i.e., that two distinct tuples cannot share the same values on these three attributes. Two queries involving aggregate functions are
(5.4)
For each theater, list the total number of movies that have been shown there.

(5.5)
For each theater and movie, list the total attendance.

92
Adding Negation: Algebra and Calculus
Informally, the first query might be expressed in a pidgin language as
{ th,c | th is a theater occurring in Sales
and c = |π Title(σ Theater=th( Sales))|}
and the second as
{ th, ti, s | th, ti is a theater-title pair appearing in Sales and s is the sum that includes each occurrence of each a-value in σ Theater= th∧ Title=ti( Sales)}
A subtlety here is that this second query cannot be expressed simply as
{ th, ti, s | th, ti is a theater-title pair appearing in Sales and s = #{a ∈ π Attendance(σ Theater= th∧ Title= ti( Sales))}}
since a value a has to be counted as many times as it occurs in the selection. This suggests that a more natural setting for studying aggregate functions would explicitly include bags (or multisets, i.e., collections in which duplicates are permitted) and not just sets, a somewhat radical departure from the model we have used so far.

The two queries can be expressed as follows using aggregate functions in an algebraic language:
π Theater; count( Title)( Sales)
π Theater, Title; sum( Attendance)( Sales).

We now briefly present a more formal development. To simplify, the formalism is based on the unnamed perspective, and we assume that dom = N, i.e., the set of nonnegative integers. We stay within the relational model although as noted in the preceding example, a richer data model with bags would be more natural. Indeed, the complex value model that will be studied in Chapter 20 provides a more appropriate context for considering aggregate functions.

We shall adopt a somewhat abstract view of aggregate operators. An aggregate function f is defined to be a family of functions f1, f2, . . . such that for each j ≥ 1 and each relation schema S with arity(S) ≥ j , fj : Inst(S) → N. For instance, for the sum aggregate function, we will have sum1 to sum the first column and, in general, sumi to sum the ith one. As in the case of sum, we want the fi to depend only on the content of the column to which they are applied, where the “content” includes not only the set of elements in the column, but also the number of their occurrences (so, columns are viewed as bags). This requirement is captured by the following uniformity property imposed on each aggregate function f :
Suppose that the ith column of I and the j th of J are identical, i.e., for each a, there are as many occurrences of a in the ith column of I and in the j th column of J . Then fi(I ) = fj (J ).

5.6 Digression: Finite Representations of Infinite Databases 93
All of the commonly arising aggregate functions satisfy this uniformity property. The uniformity condition is also used when translating calculus queries with aggregates into the algebra with aggregates.

We next illustrate how aggregate functions can be incorporated into the algebra and calculus (we do not discuss how this is done for nr-datalog¬, since it is similar to the algebra.) Aggregate functions are added to the algebra using an extended projection operation.

Specifically, the projection function for aggregate function f on relation instance I is defined as follows:
πj
, . . . , a , f
(I )) | a
1,...,jm;f (k)(I ) = {aj1
jm
k(σj1=aj ∧···∧j
1, . . . , an ∈ I }.

1
m=ajm
Note that the aggregate function fk is applied separately to each group of tuples in I corresponding to a different possible value for the columns j1, . . . , jm.

Turning to the calculus, we begin with an example. Query (5.5) can be expressed in the extended calculus as
{ th, ti, s | ∃d1, a1( Sales( th, ti, d1, a1)
∧ s = sum2{d2, a2 | Sales( th, ti, d2, a2)})}
where sum2 is the aggregate function summing the second column of a relation. Note that the subexpression {d2, a2 | Sales( th, ti, d2, a2)} has free variables th and ti that do not occur in the target of the subexpression. Intuitively, different assignments for these variables will yield different values for the subexpression.

More formally, aggregate functions are incorporated into the calculus by permitting aggregate terms that have the form fj {$
x | ψ }, where f is an aggregate function, j ≤
arity($
x) and ψ is a calculus formula (possibly with aggregate terms). When defining the extended calculus, care must be taken to guarantee that aggregate terms do not recursively depend on each other. This can be accomplished with a suitable generalization of safe range. This generalization will also ensure that free variables occurring in an aggregate term are range restricted by a subformula containing it. It is straightforward to define the semantics of the generalized safe-range calculus with aggregate functions. One can then show that the extensions of the algebra and safe-range calculus with the same set of aggregate functions have the same expressive power.

5.6
Digression: Finite Representations of Infinite Databases
Until now we have considered only finite instances of relational databases. As we have seen, this introduced significant difficulty in connection with domain independence of calculus queries. It is also restrictive in connection with some application areas that involve temporal or geometric data. For example, it would be convenient to think of a rectangle in the real plane as an infinite set of points, even if it can be represented easily in some finite manner.

In this short section we briefly describe some recent and advanced material that uses logic to permit the finite representation of infinite databases. We begin by presenting an alternative approach to resolving the problem of safety, that permits queries to have answers
94
Adding Negation: Algebra and Calculus
that are infinite but finitely representable. We then introduce a promising generalization of the relational model that uses constraints to represent infinite databases, and we describe how query processing can be performed against these in an efficient manner.

An Alternative Resolution to the Problem of Safety
As indicated earlier, much of the research on safety has been directed at syntactic restrictions to ensure domain independence. An alternative approach is to use the natural interpretation, even if the resulting answer is infinite. As it turns out, the answers to such queries are recursive and have a finite representation.

For this result, we shall use a finite set d ⊂ dom, which corresponds intuitively to the active domain of a query and input database; and a set C = {c1, . . . , cm} of m distinct “new”
symbols, which will serve as placeholders for elements of dom − d. Speaking intuitively, the elements of C sometimes act as elements of dom, and so it is not appropriate to view them as simple variables.

A tuple with placeholders is a tuple t = t1, . . . , tn, where each ti is in d ∪ C. The semantics of such t relative to d are
semd(t) = {ρ(t) | ρ is a one-one mapping from d ∪ C
that leaves d fixed and maps C into dom − d}.

The following theorem, stated without proof, characterizes the result of applying an arbitrary calculus query using the natural semantics.

Theorem 5.6.1
Let q = {e1, . . . , en | ϕ} be an arbitrary calculus query, such that each quantifier in ϕ quantifies a distinct variable that is not free in ϕ. Let C = {c1, . . . , cm} be a set of m distinct “new” symbols not occurring in dom, but viewed as domain elements, where m is the number of distinct variables in ϕ. Then for each input instance I, qdom(I) = ∪{ semadom(q, I)(t) | t ∈ q adom(q, I)∪C(I)}.

This shows that if we apply a calculus query (under the natural semantics) to a finite database, then the result is recursive, even if infinite. But is the set of infinite databases described in this manner closed under the application of calculus queries? The affirmative answer is provided by an elegant generalization of the relational model presented next (see Exercise 5.31).

Constraint Query Languages
The following generalization of the relational model seems useful to a variety of new applications. The starting point is to consider infinite databases with finite representations based on the use of constraints. To begin we define a generalized n-tuple as a conjunction of constraints over n variables. The constraints typically include =, =, ≤, etc. In some sense, such a constraint can be viewed as a finite representation of a (possibly infinite) set of (normal) n-tuples (i.e., the valuations of the variables that satisfy the constraint).

5.6 Digression: Finite Representations of Infinite Databases 95
Example 5.6.2
Consider the representation of rectangles in the plane. Suppose first that rectangles are given using 5-tuples (n, x1, y1, x2, y2), where n is the name of the rectangle, (x1, y1) are the coordinates of the lower left corner, and (x2, y2) are the coordinates of the upper right. The set of points u, v in such a rectangle delimited by x1, y1, x2, y2 is given by the constraint
x1 ≤ u ≤ x2 ∧ y1 ≤ v ≤ y2.

Now the names of intersecting rectangles from a relation R are given by
{n1, n2 | ∃ x1, y1, x2, y2, x′1, y′1, x′2, y′2, u, v
(R(n1, x1, y1, x2, y2) ∧ (x1 ≤ u ≤ x2 ∧ y1 ≤ v ≤ y2)∧
R(n2, x′
≤
∧
≤
1, y′1, x′2, y′2) ∧ (x′1
u ≤ x′2
y′1
v ≤ y′2))}.

This is essentially within the framework of the relational model presented so far, except that we are using an infinite base relation ≤. There is a level of indirection between the representation of a rectangle (a, x1, y1, x2, y2) and the actual set of points that it contains.

In the following constraint formalism, a named rectangle can be represented by a
“generalized tuple” (i.e., a constraint). For instance, the rectangle of name a with corners (0.5, 1.0) and (1.5, 5.5) is represented by the constraint
z1 = a ∧ 0.5 ≤ z2 ∧ z2 ≤ 1.5 ∧ 1.0 ≤ z3 ∧ z3 ≤ 5.5.

This should be viewed as a finite syntactic representation of an infinite set of triples. A triple z1, z2, z3 satisfying this constraint indicates that the point of coordinates (z2, z3) is in a rectangle with name z1.

One can see a number of uses in allowing constraints in the language. First, constraints arise naturally for domains concerning measures (price, distance, time, etc.). The introduction of time has already been studied in the active area of temporal databases (see Section 22.6). In other applications such as spatial databases, geometry plays an essential role and fits nicely in the realm of constraint query languages.

One can clearly obtain different languages by considering various domains and various forms of constraints. Relational calculus, relational algebra, or some other relational languages can be extended with, for instance, the theory of real closed fields or the theory of dense orders without endpoints. Of course, a requirement is the decidability of the resulting language.

Assuming some notion of constraints (to be formalized soon), we now define somewhat more precisely the constraint languages and then illustrate them with two examples.

Definition 5.6.3
A generalized n -tuple is a finite conjunction of constraints over variables x1, . . . , xn. A generalized instance of arity n is a finite set of generalized n-tuples (the corresponding formula is the disjunction of the constraints).

96
Adding Negation: Algebra and Calculus
Suppose that I is a generalized instance. We refer to I as a syntactic database and to the set of conventional tuples represented by I as the semantic database.

We now present two applications of this approach, one in connection with the reals and the other with the rationals.

We assume now that the constants are interpreted over a real closed field (e.g., the reals). The constraints are polynomial inequality constraints [i.e., inequalities of the form p(x1, . . . , xn) ≥ 0, where p is a polynomial]. Two 3-tuples in this context are (3.56 × x2 +
1
4.0 × x2 ≥ 0) ∧ (x3 − x1 ≥ 0)
(x1 + x2 + x3 ≥ 0).

One can evaluate queries algebraically bottom-up (i.e., at each step of the computation, the result is still a generalized instance). This is a straightforward consequence of Tarski’s decision procedure for the theory of real closed fields. A difficulty resides in projection (i.e., quantifier elimination). The procedure for projection is extremely costly in the size of the query. However, for a fixed query, the complexity in the size of the syntactic database is reasonable (in nc).

We assume now that the constants are interpreted over a countably infinite set with a binary relation ≤ that is a dense order (e.g., the rationals). The constraints are of the form xθy or xθ c, where x, y are variables, c is a constant, and θ is among ≤, <, =. An example of a 3-tuple is
(x1 ≤ x2) ∧ (x2 < x3).

Here again, a bottom-up algebraic evaluation is feasible. Indeed, evaluation is in ac0
in the size of the syntactic database (for a fixed query).

In the remainder of this book, we consider standard databases and not generalized ones.

Bibliographic Notes
One of the first investigations of using predicate calculus to query relational database structures is [Kuh67], although the work by Codd [Cod70, Cod72b] played a tremendous role in bringing attention to the relational model and to the relational algebra and calculus. In particular, [Cod72b] introduced the equivalence of the calculus and algebra to the database community. That paper coined the phrase relational completeness to describe the expressive power of relational query languages: Any language able to simulate the algebra is called relationally complete. We have not emphasized that phrase here because subsequent research has suggested that a more natural notion of completeness can be described in terms of Turing computability (see Chapter 16).

Actually, a version of the result on the equivalence of the calculus and algebra was known much earlier to the logic community (see [CT48, TT52]) and is used to show Tarski’s algebraization theorem (e.g., see [HMT71]). The relation between relational algebras and cylindric algebras is studied in [IL84] (see Exercise 5.36). The development of algebras equivalent to various calculus languages has been a fertile area for database theory.

One such result presented in this chapter is the equivalence of the positive existential cal-
Bibliographic Notes
97
culus and the SPCU algebra [CH82]; analogous results have also been developed for the relational calculus extended with aggregate operators [Klu82], the complex value model
[AB88] (studied in Chapter 20), the Logical Data Model [KV84], the directory model
[DM86a, DM92], and formalizations of the hierarchy and network models using database logic [Jac82].

Notions related to domain independence are found as early as [Low15] in the logic community; in the database community the first paper on this topic appears to be [Kuh67], which introduced the notion of definite queries. The notion of domain independence used here is from [Fag82b, Mak81]; the notions of definite and domain independent were proved equivalent in [ND82]. A large number of classes of domain-independent formulas have been investigated. These include the safe [Ull82b], safe DRC [Ull88], range separable
[Cod72b], allowed [Top87] (Exercise 5.25), range restricted [Nic82] (Exercise 5.26), and evaluable [Dem82] formulas. An additional investigation of domain independence for the calculus is found in [ND82]. Surveys on domain independence and various examples of these classes can be found in [Kif88, VanGT91]. The focus of [VanGT91] is the general problem of practical translations from calculus to algebra queries; in particular, it provides a translation from the set of evaluable formulas into the algebra. It is also shown there that the notions of evaluable and range restricted are equivalent. These are the most general syntactic conditions in the literature that ensure domain independence. The fact that domain independence is undecidable was first observed in [DiP69]; this is detailed in Chapter 6.

Domain independence also arises in the context of dependencies [Fag82b, Mak81] and datalog [Dec86, Top87, RBS87, TS88]. The issue of extending domain independence to incorporate functions (e.g., arithmetic functions, or user-defined functions) is considered in [AB88, Top91, EHJ93]. The issue of extending domain independence to incorporate freely interpreted functions (such as arise in logic programming) is addressed in [Kif88].

Syntactic conditions on (recursive) datalog programs with arithmetic that ensure safety are developed in [RBS87, KRS88a, KRS88b, SV89]. Issues of safety in the presence of function or order symbols are also considered in [AH91]. Aggregate functions were first incorporated into the relational algebra and calculus in [Klu82]; see also [AB88].

The notion of safe range presented here is richer than safe, safe DRC, and range separable and weaker than allowed, evaluable, and range restricted. It follows the spirit of the definition of allowed presented in [VanGT91] and safe range in [AB88]. The transformations of the safe-range calculus to the algebra presented here follows the more general transformations in [VanGT91, EHJ93]. The notion of “relational algebra normal form”
used in those works is more general than the notion by that name used here.

Query languages have mostly been considered for finite databases. An exception is
[HH93]. Theorem 5.6.1 is due to [AGSS86]. An alternative proof and extension of this result is developed in [HS94].

Programming with constraints has been studied for some time in topic areas ranging from linear programming to AI to logic programming. Although the declarative spirit of both constraint programming and database query languages leads to a natural marriage, it is only recently that the combination of the two paradigms has been studied seriously
[KKR90]. This was probably a consequence of the success of constraints in the field of logic programming (see, e.g., [JL87] and [Lel87, Coh90] for surveys). Our presentation was influenced by [KKR90] (calculii for closed real fields with polynomial inequalities and for dense order with inequalities are studied there) as well as by [KG94] (an algebra
98
Adding Negation: Algebra and Calculus
for constraint databases with dense order and inequalities is featured there). Recent works on constraint database languages can be found in [Kup93, GS94].

Exercises
Exercise 5.1
Express queries (5.2 and 5.3) in (1) the relational algebras, (2) nonrecursive datalog¬, and (3) domain-independent relational calculus.

Exercise 5.2
Express the following queries against the CINEMA database in (1) the relational algebras, (2) nonrecursive datalog¬, and (3) domain-independent relational calculus.

(a) Find the actors cast in at least one movie by Kurosawa.

(b) Find the actors cast in every movie by Kurosawa.

(c) Find the actors cast only in movies by Kurosawa.

(d) Find all pairs of actors who act together in at least one movie.

(e) Find all pairs of actors cast in exactly the same movies.

(f) Find the directors such that every actor is cast in one of his or her films.

(Assume that each film has exactly one director.)

Exercise 5.3
Prove or disprove (assuming X ⊆ sort(P ) = sort(Q)): (a) πX(P ∪ Q) = πX(P ) ∪ πX(Q);
(b) πX(P ∩ Q) = πX(P ) ∩ πX(Q).

Exercise 5.4
(a) Give formal definitions for the syntax and semantics of the unnamed and named relational algebras.

(b) Show that in the unnamed algebra ∩ can be simulated using (1) the difference operator −; (2) the operators ×, π, σ .

(c) Give a formal definition for the syntax and semantics of selection operators in the unnamed algebra that permit conjunction, disjunction, and negation in their formulas.

Show that these selection operators can be simulated using atomic selection operators, union, intersect, and difference.

⋆ (d) Show that the SPCU algebra, in which selection operators with negation in the formulas are permitted, cannot simulate the difference operator.

⋆ (e) Formulate and prove results analogous to those of parts (b), (c), and (d) for the named algebra.

Exercise 5.5
(a) Prove that the unnamed algebra operators {σ, π, ×, ∪, −} are nonredundant.

(b) State and prove the analogous result for the named algebra.

Exercise 5.6
(a) Exhibit a relational algebra query that is not monotonic.

(b) Exhibit a relational algebra query that is not satisfiable.

Exercises
99
Exercise 5.7
Prove Proposition 5.1.2 (i.e., that the unnamed and named relational algebras have equivalent expressive power).

Exercise 5.8
(Division) The division operator, denoted ÷, is added to the named algebra as follows. For instances I and J with sort(J ) ⊆ sort(I ), the value of I ÷ J is the set of tuples r ∈ π sort(I)− sort(J )(I ) such that ({r} ⊲⊳ J ) ⊆ I . Use the division to express algebraically the query, “Which theater is featuring all of Hitchcock’s movies?”. Describe how nr-datalog¬ can be used to simulate division. Describe how the named algebra can simulate division. Is division a monotonic operation?

Exercise 5.9
Show that the semantics of each nr-datalog¬ rule can be described as a difference q1 − q2, where q1 is an SPJR query and q2 is an SPJRU query.

Exercise 5.10
Verify that each nr-datalog¬ program with equality can be simulated by one without equality.

Exercise 5.11
Prove Proposition 5.2.2. Hint: Use the proof of Theorem 4.4.8 and the fact that the relational algebra is closed under composition.

⋆ Exercise 5.12 Prove that the domain-independent relational calculus without equality is strictly weaker than the domain-independent relational calculus. Hint: Suppose that calculus query q without equality is equivalent to {x | R(x) ∧ x = a}. Show that q can be translated into an algebra query q′ that is constructed without using a constant base relation and such that all selections are on base relation expressions. Argue that on each input relation I over R, each subexpression of q′ evaluates to either I n for some n ≥ 0, or to the empty relation for some n ≥ 0.

Exercise 5.13
(a) Complete the proof of Lemma 5.3.11.

(b) Complete the proof of Lemma 5.3.12.

Exercise 5.14
(a) Prove that the rewrite rules of Figure 5.1 preserve equivalence.

(b) Prove that these rewrite rules can be used to transform an arbitrary calculus formula into an equivalent formula in PNF with CNF matrix. State which rewrite rules are needed.

(c) Do the same as (b), but for DNF matrix.

(d) Prove that the rewrite rules of Figure 5.1 are not complete in the sense that there are calculus formulas ϕ and ψ such that (1) ϕ ≡ ψ, but (2) there is no sequence of applications of the rewrite rules that transforms ϕ into ψ.

Exercise 5.15
Verify the claims of Example 5.3.9.

Exercise 5.16
(a) Show that each positive existential query is equivalent to one whose formula is in PNF with either CNF or DNF matrix and that they can be expressed in the form
{e1, . . . , en | ψ1 ∨ · · · ∨ ψm}, where each ψj is a conjunctive calculus formula with free(ψj ) = the set of variables occurring in e1, . . . , en. Note that this formula is safe range.

100
Adding Negation: Algebra and Calculus
(b) Show that it is decidable, given a relational calculus query q (possibly with equality) whose only logical connectives are ∧, ∨, and ∃, whether q is domain independent.

(c) Prove Theorem 5.4.10.

Exercise 5.17
Use the construction of the proof of Theorem 5.4.6 to transform the following into the algebra.

(a) { | ∃x(R(x) ∧ ∃y(S(x, y) ∧ ¬∃z(T (x, y, a))))}
(b) {w, x, y, z | (R(w, x, y) ∨ R(w, x, z)) ∧ (R(y, z, w) ∨ R(y, z, x))}
Exercise 5.18
For each of the following queries, indicate whether it is domain independent and/or safe range. If it is not domain independent, give examples of different domains yielding different answers on the same input; and if it is safe range, translate it into the algebra.

(a) {x, y | ∃z[T (x, z) ∧ ∃wT (w, x, y)] ∧ x = y}
(b) {x, y | [x = a ∨ ∃z(R(y, z))] ∧ S(y)}
(c) {x, y | [x = a ∨ ∃z(R(y, z))] ∧ S(y) ∧ T (x)}
(d) {x | ∀y(R(y) → S(x, y))}
(e) { | ∃x∀y(R(y) → S(x, y))}
(f) {x, y | ∃zT (x, y, z) ∧ ∃u, v([(R(u) ∨ S(u, v)) ∧ R(v)]
→ [∃w(T (x, w, v) ∧ T (u, v, y))])}
⋆ Exercise 5.19 Consider the proof of Theorem 5.4.6.

(a) Give the missing parts of Algorithm 5.4.7.

(b) Show that Algorithm 5.4.7 is correct and terminates on all input.

(c) Give the missing parts of Algorithm 5.4.8 and verify its correctness.

(d) Given q = {x1, . . . , xn | ϕ} with ϕ in modified RANF, show for each instance I and each d satisfying adom(q, I) ⊆ d ⊆ dom that qd(I) = Eϕ(I).

Exercise 5.20
Consider the proof of Theorem 5.4.6.

(a) Present examples illustrating how the nondeterministic choices in these rewrite rules can be used to help optimize the algebra query finally produced by the construction of the proof of this lemma. (Refer to Chapter 6 for a general discussion of optimization.) (b) Consider a generalization of rules (R1) and (R2) that permits using a set of indexes
{j1, . . . , jl} ⊆ {1, . . . , n} − {i1, . . . , ik}. What are the advantages of this generalization? What restrictions must be imposed to ensure that Algorithm 5.4.8 remains correct?

Exercise 5.21
Develop a direct proof that CALC adom ⊑ CALCsr. Hint: Given calculus query q, first build a formula ξ adom(x) such that I |= ξ adom(x)[ν] iff ν(x) ∈ adom(q, I). Now perform an induction on subformulas.

⋆ Exercise 5.22 [Coh86] Let R have arity n. Define the gen( erator) operator so that for instance I of R, indexes 1 ≤ i1 < · · · < ik ≤ n, and constants a1, . . . , ak, gen i
(I ) = π
(σ
(I )),
1:a1,...,ik:ak
j1,...,jl
i1=a1∧···∧ik=ak
where {j1, . . . , jl} is a listing in order of (some or all) indexes in {1, . . . , n} − {i1, . . . , ik}. Note that the special case of gen 1:b
(I ) can be viewed as a test of b
1,...,n:bn
1, . . . , bn ∈ I ; and gen[ ](I )
Exercises
101
is a test of whether I is nonempty. In some research in AI, the primitive mechanism for accessing relations is based on generators that are viewed as producing a stream of tuples as output. For example, the query {x, y, z | R(x, y) ∧ S(y, z)} can be computed using the algorithm for each tuple x, y generated by gen 1:x,2:y(R)
for each value z generated by gen 1:y(S)
output x, y, z
end for each
end for each
Develop an algorithm for translating calculus queries into programs using generators.

Describe syntactic restrictions on the calculus that ensure that your algorithm succeeds.

♠ Exercise 5.23 [Cod72b] (Tuple calculus.) We use a set tvar of sorted tuple variables. The tuple calculus is defined as follows. If t is a tuple variable and A is an attribute in the sort of t, t.A is a term. A constant is also a term. The atomic formulas are either of the form R(t) with the appropriate constraint on sorts, or e = e′, where e, e′ are terms. Formulas are constructed as in the standard relational calculus. For example, query (5.1) is expressed by the tuple calculus query
{t: title | ∃s: title, director, actor[ Movie( s) ∧ t. title = s. title
∧ s.director = “Hitchcock”]
∧ ¬∃u: title, director, actor[ Movie( u) ∧ u. title = s. title
∧ u.actor = “Hitchcock”]}.

Give a formal definition for the syntax of the tuple calculus and for the relativized interpretation, active domain, and domain-independent semantics. Develop an analog of safe range. Prove the equivalence of conventional calculus and tuple calculus under all of these semantics.

Exercise 5.24
Prove that the relational calculus and the family of nr-datalog¬ programs with single-relation output have equivalent expressive power by using direct simulations between the two families.

♠ Exercise 5.25 [Top87] Let R be a database schema, and define the binary relation gen( erates) on variables and formulas as follows:
gen(x, ϕ)
if ϕ = R(u) for some R ∈ R and x ∈ free(ϕ)
gen(x, ¬ϕ)
if gen(x, pushnot(¬ϕ))
gen(x, ∃yϕ)
if x, y are distinct and gen(x, ϕ)
gen(x, ∀yϕ)
if x, y are distinct and gen(x, ϕ)
gen(x, ϕ ∨ ψ)
if gen(x, ϕ) and gen(x, ψ)
gen(x, ϕ ∧ ψ)
if gen(x, ϕ) or gen(x, ψ),
where pushnot(¬ϕ) is defined in the natural manner to be the result of pushing the negation into the next highest level logical connective (with consecutive negations cancelling each other) unless ϕ is an atom (using the rewrite rules 5, 6, 7, 10, and 11 from Fig. 5.1). A formula ϕ is allowed
(i) if x ∈ free(ϕ) then gen(x, ϕ);
(ii) if for each subformula ∃yψ of ϕ, gen(y, ψ) holds; and
102
Adding Negation: Algebra and Calculus
(iii) if for each subformula ∀yψ of ϕ, gen(y, ¬ψ) holds.

A calculus query is allowed if its formula is allowed.

(a) Exhibit a query that is allowed but not safe range.

⋆ (b) Prove that each allowed query is domain independent.

In [VanGT91, EHJ93] a translation of allowed formulas into the algebra is presented.)

⋆ Exercise 5.26 [Nic82] The notion of “range-restricted” queries, which ensures domain independence, is based on properties of the normal form equivalents of queries. Let q = {
x | ϕ} be
a calculus query, and let ϕ DNF =
%y(D1 ∨ · · · ∨ Dn) be the result of transforming ϕ into PNF
with DNF matrix using the rewrite rules of Fig. 5.1; and similarly let ϕ CNF =
%z(C1 ∧ · · · ∧ Cm)
be the result of transforming ϕ into PNF with CNF matrix. The query q is range restricted if (i) each free variable x in ϕ occurs in a positive literal (other than x = y) in every Di; (ii) each existentially quantified variable x in ϕ DNF occurs in a positive literal (other than x = y) in every Di where x occurs; and
(iii) each universally quantified variable x in ϕ CNF occurs in a negative literal (other than x = y) in every Cj where x occurs.

Prove that range-restricted queries are domain independent. (In [VanGT91] a translation of the range-restricted queries into the algebra is presented.)

Exercise 5.27
[VanGT91] Suppose that R[ Product, Part] holds project numbers and the parts that are used to make them, and S[ Supplier, Part] holds supplier names and the parts that they supply. Consider the queries
q1 = {x | ∀y(R(100, y) → S(x, y))}
q2 = { | ∃x∀y(R(100, y) → S(x, y))}
(a) Prove that q1 is not domain independent.

(b) Prove that q2 is not allowed (Exercise 5.25) but it is range restricted (Exercise 5.26) and hence domain independent.

(c) Find an algebra query q′ equivalent to q2.

Exercise 5.28
[Klu82] Consider a database schema with relations Dept[ Name, Head, College], Faculty[ Name, Dname], and Grad[ Name, MajorProf , GrantAmt], and the query For each department in the Letters and Science College, compute the total graduate student support for each of the department’s faculty members, and produce as output a relation that includes all pairs d, a where d is a department in the Letters and Science College, and a is the average graduate student support per faculty member in d.

Write algebra and calculus queries that express this query.

Exercise 5.29
We consider constraint databases involving polynomial inequalities over the reals. Let I1 = {(9x2 + 4x
1
2 ≥ 0)} be a generalized instance over AB , where x1 ranges over A and x2 ranges over B, and let I2 = {(x3 − x1 ≥ 0)} over AC. Express πBC(I1 ⊲⊳ I2) as a generalized instance.

⋆ Exercise 5.30 Recall Theorem 5.6.1.

Exercises
103
(a) Let finite d ⊂ dom be fixed, C be a set of new symbols, and t be a tuple with placeholders. Describe a generalized tuple (in the sense of constraint databases) t′
whose semantics are equal to semd(t).

(b) Show that the family of databases representable by sets of tuples with placeholders is closed under the relational calculus.

♠ Exercise 5.31 Prove Theorem 5.6.1.

Exercise 5.32
[Mai80] (Unrestricted algebra) For this exercise we permit relations to be finite or infinite. Consider the complement operator c defined on instances I of arity n by I c =
domn − I . (The analogous operator is defined for the named algebra.) Prove that the calculus under the natural interpretation is equivalent to the algebra with operators {σ, π, ×, ∪,c }.

⋆ Exercise 5.33 A total mapping τ from instances over R to instances over S is C-generic for C ⊆ dom, iff for each bijection ρ over dom that is the identity on C, τ and ρ commute. That is, τ(ρ(I)) = ρ(τ(I)) for each instance I of R. The mapping τ is generic if it is C-generic for some finite C ⊆ dom. Prove that each relational algebra query is generic—in particular, that each algebra query q is adom(q)-generic.

♠ Exercise 5.34 Let R be a unary relation name. A hyperplane query over R is a query of the form σF (R × · · · × R) (with 0 or more occurrences of R), where F is a conjunction of atoms of the form i = j , i = j , i = a, or i = a (for indexes i, j and constant a). A formula F of this form is called a hyperplane formula. A hyperplane-union query over R is a query of the form σF (R × · · · × R), where F is a disjunction of hyperplane formulas; a formula of this form is called a hyperplane-union formula.

(a) Show that if q is an algebra query over R, then there is an n ≥ 0 and a hyperplane-union query q′ such that for all instances I over R, if |I | ≥ n and adom(I ) ∩
adom(q) = ∅, then q(I ) = q′(I ).

The query even is defined over R as follows: even(I ) = {} (i.e., yes) if |I | is even; and even(I ) = {} (i.e., no) otherwise.

(b) Prove that there is no algebra query q over R such that q ≡ even.

Exercise 5.35
[CH80b] (Unsorted algebra) An h-relation (for heterogeneous relation) is a finite set of tuples not necessarily of the same arity.

(a) Design an algebra for h-relations that is at least as expressive as relational algebra.

⋆ (b) Show that the algebra in (a) can be chosen to have the additional property that if q is a query in this algebra taking standard relational input and producing standard relational output, then there is a standard algebra query q′ such that q′ ≡ q.

♠ Exercise 5.36 [IL84] (Cylindric algebra) Let n be a positive integer, R[A1, . . . , An] a relation schema, and C a (possibly infinite) set of constants. Recall that a Boolean algebra is a 6-tuple (B, ∨, ∧,
, ⊥, ⊤), where B is a set containing ⊥ and ⊤; ∨, ∧ are binary operations on B; and is a unary operation on B such that for all x, y, z ∈ B:
(a) x ∨ y = y ∨ x;
(b) x ∧ y = y ∧ x;
(c) x ∨ (y ∧ z) = (x ∨ y) ∧ (x ∨ z);
(d) x ∧ (y ∨ z) = (x ∧ y) ∨ (x ∧ z);
104
Adding Negation: Algebra and Calculus
(e) x ∧ ⊥ = ⊥;
(f) x ∨ ⊤ = ⊤;
(g) x ∧ x = ⊥;
(h) x ∨ x = ⊤; and
(i) ⊥ = ⊤.

For a Boolean algebra, define x ≤ y to mean x ∧ y = x.

(a) Show that RC, ∪, ∩,c , ∅, Cn is a Boolean algebra where RC is the set of all (possibly infinite) R-relations over constants in C and c denotes the unary complement operator, defined so that I c = Cn − I . In addition, show that I ≤ J iff I ⊆ J .

Let the diagonals dij be defined by the statement, “for each i, j , dij = σA (Cn)”; and let the
i =Aj
ith cylinder Ci be defined for each I by the statement, “CiI is the relation over RC defined by CiI = {t | πA
(t ) ∈ π
(I ) and t (A
1...Ai−1Ai+1...An
A1...Ai−1Ai+1...An
i ) ∈ C}.”
(b) Show the following properties of cylindric algebras: (1) Ci∅ = ∅; (2) x ≤ Cix; (3) Ci(x ∩ Ciy) = Cix ∩ Ciy; (4) CiCj x = Cj Cix; (5) dii = Cn; (6) if i = j and i = k, then djk = Ci(dji ∩ dik); (7) if i = j , then Ci(dij ∩ x) ∩ Ci(dij ∩ x) = ∅.

(c) Let h be the mapping from any (possibly infinite) relation S with sort(S) ⊂ A1 . . . An with entries in C to a relation over R obtained by extending each tuple in S to A1 . . . An in all possible ways with values in C. Prove that (1) h(R1 ⊲⊳ R2) = h(R1) ∩
h(R2) and (2) if A1 ∈ sort(R), then h(πA (R)) = C
1
1h(R1).

6 StaticAnalysisand
Optimization
Alice:
Do you guys mean real optimization?

Riccardo:
Well, most of the time it’s local maneuvering.

Vittorio:
But sometimes we go beyond incremental reform . . .

Sergio:
. . . with provably global results.

This chapter examines the conjunctive and first-order queries from the perspective of static analysis (in the sense of programming languages). It is shown that many properties of conjunctive queries (e.g., equivalence, containment) are decidable although they are not decidable for first-order queries. Static analysis techniques are also applied here in connection with query optimization (i.e., transforming queries expressed in a high-level, largely declarative language into equivalent queries or machine instruction programs that are arguably more efficient than a naive execution of the initial query).

To provide background, this chapter begins with a survey of practical optimization techniques for the conjunctive queries. The majority of practically oriented research and development on query optimization has been focused on variants of the conjunctive queries, possibly extended with arithmetic operators and comparators. Because of the myriad factors that play a role in query evaluation, most practically successful techniques rely heavily on heuristics.

Next the chapter presents the elegant and important Homomorphism Theorem, which characterizes containment and equivalence between conjunctive queries. This leads to the notion of tableau “minimization”: For each tableau query there is a unique (up to isomorphism) equivalent tableau query with the smallest number of rows. This provides a theoretical notion of true optimality for conjunctive queries. It is also shown that deciding these properties and minimizing conjunctive queries is np-complete in the size of the input queries.

Undecidability results are then presented for the first-order queries. Although related to undecidability results for conventional first-order logic, the proof techniques used here are necessarily different because all instances considered are finite by definition. The undecidability results imply that there is no hope of developing an algorithm that performs optimization of first-order queries that is complete. Only limited optimization of first-order queries involving difference is provided in most systems.

The chapter closes by returning to a specialized subset of the conjunctive queries based on acyclic joins. These have been shown to enjoy several interesting properties, some yielding insight into more efficient query processing.

Chapter 13 in Part D examines techniques for optimizing datalog queries.

105
106
Static Analysis and Optimization
6.1
Issues in Practical Query Optimization
Query optimization is one of the central topics of database systems. A myriad of factors play a role in this area, including storage and indexing techniques, page sizes and paging protocols, the underlying operating system, statistical properties of the stored data, statistical properties of anticipated queries and updates, implementations of specific operators, and the expressive power of the query languages used, to name a few. Query optimization can be performed at all levels of the three-level database architecture. At the physical level, this work focuses on, for example, access techniques, statistical properties of stored data, and buffer management. At a more logical level, algebraic equivalences are used to rewrite queries into forms that can be implemented more efficiently.

We begin now with a discussion of rudimentary considerations that affect query processing (including the usual cost measurements) and basic methods for accessing relations and implementing algebraic operators. Next an optimization approach based on algebraic equivalences is described; this is used to replace a given algebraic expression by an equivalent one that can typically be computed more quickly. This leads to the important notion of query evaluation plans and how they are used in modern systems to represent and choose among many alternative implementations of a query. We then examine intricate techniques for implementing multiway joins based on different orderings of binary joins and on join decomposition.

The discussion presented in this section only scratches the surface of the rich body of systems-oriented research and development on query optimizers, indicating only a handful of the most important factors that are involved. Nothing will be said about several factors, such as the impact of negation in queries, main-memory buffering strategies, and the implications of different environments (such as distributed, object oriented, real time, large main memory, and secondary memories other than conventional disks). In part due to the intricacy and number of interrelated factors involved, little of the fundamental theoretical research on query optimization has found its way into practice. As the field is maturing, salient aspects of query optimization are becoming isolated; this may provide some of the foothold needed for significant theoretical work to emerge and be applied.

The Physical Model
The usual assumption of relational databases is that the current database state is so large that it must be stored in secondary memory (e.g., on disk). Manipulation of the stored data, including the application of algebraic operators, requires making copies in primary memory of portions of the stored data and storing intermediate and final results again in secondary memory. By far the major time expense in query processing, for a single-processor system, is the number of disk pages that must be swapped in and out of primary memory. In the case of distributed systems, the communication costs typically dominate all others and become an important focus of optimization.

Viewed a little more abstractly, the physical level of relational query implementation involves three basic activities: (1) generating streams of tuples, (2) manipulating streams
6.1 Issues in Practical Query Optimization
107
of tuples (e.g., to perform projections), and (3) combining streams of tuples (e.g., to perform joins, unions, and intersections). Indexing methods, including primarily B-trees and hash indexes, can be used to reduce significantly the size of some streams. Although not discussed here, it is important to consider the cost of maintaining indexes and clusterings as updates to the database occur.

Main-memory buffering techniques (including the partitioning of main memory into segments and paging policies such as deleting pages based on policies of least recent use and most recent use) can significantly impact the number of page I/Os used.

Speaking broadly, an evaluation plan (or access plan) for a query, a stored database state, and a collection of existing indexes and other data structures is a specification of a sequence of operations that will compute the answer to the query. The term evaluation plan is used most often to refer to specifications that are at a low physical level but may sometimes be used for higher-level specifications. As we shall see, query optimizers typically develop several evaluation plans and then choose one for execution.

Implementation of Algebraic Operators
To illustrate the basic building blocks from which evaluation plans are constructed, we now describe basic implementation techniques for some of the relational operators.

Selection can be realized in a straightforward manner by a scan of the argument relation and can thus be achieved in linear time. Access structures such as B-tree indexes or hash tables can be used to reduce the search time needed to find the selected tuples. In the case of selections with single tuple output, this permits evaluation within essentially constant time (e.g., two or three page fetches). For larger outputs, the selection may take two or three page fetches per output tuple; this can be improved significantly if the input relation is clustered (i.e., stored so that all tuples with a given attribute value are on the same or contiguous disk pages).

Projection is a bit more complex because it actually calls for two essentially different operations: tuple rewriting and duplicate elimination. The tuple rewriting is typically accomplished by bringing tuples into primary memory and then rewriting them with coordinate values permuted and removed as called for. This may yield a listing of tuples that contains duplicates. If a pure relational algebra projection is to be implemented, then these duplicates must be removed. One strategy for this involves sorting the list of tuples and then removing duplicates; this takes time on the order of n log n. Another approach that is faster in some cases uses a hash function that incorporates all coordinate values of a tuple.

Because of the potential expense incurred by duplicate elimination, most practical relational languages permit duplicates in intermediate and final results. An explicit command (e.g., distinct) that calls for duplicate elimination is typically provided. Even in languages that support a pure algebra, it may be more efficient to leave duplicates in intermediate results and perform duplicate elimination once as a final step.

The equi-join is typically much more expensive than selection or projection because two relations are involved. The following naive nested loop implementation of ⊲⊳F will take time on the order of the product n1 × n2 of the sizes of the input relations I1, I2:
108
Static Analysis and Optimization
J := ∅;
for each u in I1
for each v in I2
if u and v are joinable then J := J ∪ {u ⊲⊳F v}.

Typically this can be improved by using the sort-merge algorithm, which independently sorts both inputs according to the join attributes and then performs a simultaneous scan of both relations, outputting join tuples as discovered. This reduces the running time to the order of max(n1 log n1 + n2 log n2, size of output).

In many cases a more efficient implementation of join can be accomplished by a variant of the foregoing nested loop algorithm that uses indexes. In particular, replace the inner loop by indexed retrievals to tuples of I2 that match the tuple of I1 under consideration.

Assuming that a small number of tuples of I2 match a given tuple of I1, this computes the join in time proportional to the size of I1. We shall consider implementations of multiway joins later in this section and again in Section 6.4. Additional techniques have been developed for implementing richer joins that include testing, e.g., relationships based on order (≤).

Cross-product in isolation is perhaps the most expensive algebra operation: The output necessarily has size the product of the sizes of the two inputs. In practice this arises only rarely; it is much more common that selection conditions on the cross-product can be used to transform it into some form of join.

Query Trees and Query Rewriting
Alternative query evaluation plans are usually generated by rewriting (i.e., by local transformation rules). This can be viewed as a specialized case of program transformation. Two kinds of transformations are typically used in query optimization: one that maps from the higher-level language (e.g., the algebra) into the physical language, and others that stay within the same language but lead to alternative, equivalent implementations of a given construct.

We present shortly a family of rewriting rules that illustrates the general flavor of this component of query optimizers (see Fig. 6.2). Unlike true optimizers, however, the rules presented here focus exclusively on the algebra. Later we examine the larger issue of how rules such as these are used to find optimal and near-optimal evaluation plans.

We shall use the SPC algebra, generalized by permitting positive conjunctive selection and equi-join. A central concept used is that of query tree, which is essentially the parse tree of an algebraic expression. Consider again Query (4.4), expressed here as a rule: ans(xth, xad) ← Movies(xti, “Bergman”, xac), Pariscope(xth, xti, xs), Location(xth, xad, xp).

A naive translation into the generalized SPC algebra yields
q1 = π4,8σ2=“Bergman”(( Movies ⊲⊳1=2 Pariscope) ⊲⊳4=1 Location).

6.1 Issues in Practical Query Optimization
109
π2,3
1=1
π
π
1,2
2
π4,8
σ2=“Bergman”
1=2
Location
4=1
π
π
1
1,2
σ2=“Bergman”
1=2
Location
Pariscope
Movies
Pariscope
Movies
(a)
(b)
Figure 6.1:
Two query trees for Query (4.4) from Chapter 4
The query tree of this expression is shown in Fig. 6.1(a).

To provide a rough idea of how evaluation costs might be estimated, suppose now that Movies has 10,000 tuples, with about 5 tuples per movie; Pariscope has about 200 tuples, and Location has about 100 tuples. Suppose further that in each relation there are about 50
tuples per page and that no indexes are available.

Under a naive evaluation of q1, an intermediate result would be produced for each internal node of q1’s query tree. In this example, then, the join of Movies and Pariscope would produce about 200 × 5 = 1000 tuples, which (being about twice as wide as the input tuples) will occupy about 40 pages. The second equi-join will yield about 1000 tuples that fit 18 to a page, thus occupying about 55 pages. Assuming that there are four Bergman films playing in one or two theaters each, the final answer will contain about six tuples.

The total number of page fetches performed here is about 206 for reading the input relations (assuming that no indexes are available) and 95 for working with the intermediate relations.

Additional page fetches might be required by the join operations performed.

Consider now the query q2 whose query tree is illustrated in Fig. 6.1(b). It is easily verified that this is equivalent to q1. Intuitively, q2 was formed from q1 by “pushing”
selections and projections as far “down” the tree as possible; this generally reduces the size of intermediate results and thus of computing with them.

110
Static Analysis and Optimization
In this example, assuming that all (i.e., about 20) of Bergman’s films are in Movies, the selection on Movies will yield about 100 tuples; when projected these will fit onto a single page. Joining with Pariscope will yield about six tuples, and the final join with Location will again yield six tuples. Thus only one page is needed to hold the intermediate results constructed during this evaluation, a considerable savings over the 95 pages needed by the previous one.

It is often beneficial to combine several algebraic operators into a single implemented operation. As a general rule of thumb, it is typical to materialize the inputs of each equi-join. The equi-join itself and all unary operations directly above it in the query tree are performed before output. The dashed ovals of Fig. 6.1(b) illustrate a natural grouping that can be used for this tree. In practical systems, the implementation and grouping of operators is typically considered in much finer detail.

The use of different query trees and, more generally, different evaluation plans can yield dramatically different costs in the evaluation of equivalent queries. Does this mean that the user will have to be extremely careful in expressing queries? The beauty of query optimization is that the answer is a resounding no. The user may choose any representation of a query, and the system will be responsible for generating several equivalent evaluation plans and choosing the least expensive one. For this reason, even though the relational algebra is conceptually procedural, it is implemented as an essentially declarative language.

In the case of the algebra, the generation of evaluation plans is typically based on the existence of rules for transforming algebraic expressions into equivalent ones. We have already seen rewrite rules in the context of transforming SPC and SPJR expressions into normal form (see Propositions 4.4.2 and 4.4.6). A different set of rules is useful in the present context due to the focus on optimizing the execution time and space requirements.

In Fig. 6.2 we present a family of representative rewrite rules (three with inverses) that can be used for performing the transformations needed for optimization at the logical level.

In these rules we view cross-product as a special case of equi-join in which the selection formula is empty. Because of their similarity to the rules used for the normal form results, several of the rules are shown only in abstract form; detailed formulation of these, as well as verification of their soundness, is left for the reader (see Exercise 6.1). We also include the following rule:
Simplify-identities: replace π1,..., arity(q)q by q; replace σi=iq by q; replace q × {} by q; replace q × {} by {}; and replace q ⊲⊳1=1∧···∧ arity(q)= arity( q)q by q.

Generating and Choosing between Evaluation Plans
As suggested in Fig. 6.2, in most cases the transformations should be performed in a certain direction. For example, the fifth rule suggests that it is always desirable to push selections through joins. However, situations can arise in which pushing a selection through a join is in fact much more costly than performing it second (see Exercise 6.2). The broad variety of factors that influence the time needed to execute a given query evaluation plan make it virtually impossible to find an optimal one using purely analytic techniques. For this reason, modern optimizers typically adopt the following pragmatic strategy: (1) generate a possibly large number of alternative evaluation plans; (2) estimate the costs of executing
6.1 Issues in Practical Query Optimization
111
σF (σF ′(q))
↔
σF ∧F ′(q)
π(π (q))
↔
π (q)
j
k
l
σF (π(q))
↔
π (σ
l
l F ′(q))
q1 ⊲⊳ q2
↔
q2 ⊲⊳ q1
σF (q1 ⊲⊳G q2)
→
σF (q1) ⊲⊳G q2
σF (q1 ⊲⊳G q2)
→
q1 ⊲⊳G σF ′(q2)
σF (q1 ⊲⊳G q2)
→
q1 ⊲⊳G′ q2
π(q
(q
l
1 ⊲⊳G q2)
→
πl 1) ⊲⊳G′ q2
π(q
(q
l
1 ⊲⊳G q2)
→
q1 ⊲⊳G′ πk 2)
Figure 6.2:
Rewriting rules for SPC algebra
them; and (3) select the one of lowest cost. The database system then executes the selected evaluation plan.

In early work, the transformation rules used and the method for evaluation plan generation were essentially intermixed. Motivated in part by the desire to make database systems extensible, more recent proposals have isolated the transformation rules from the algorithms for generating evaluation plans. This has the advantages of exposing the semantics of evaluation plan generation and making it easier to incorporate new kinds of information into the framework.

A representative system for generating evaluation plans was developed in connection with the Exodus database toolkit. In this system, techniques from AI are used and, a set of transformation rules is assumed. During processing, a set of partial evaluation plans is maintained along with a set of possible locations where rules can be applied. Heuristics are used to determine which transformation to apply next, so that an exhaustive search through all possible evaluation plans can be avoided while still having a good chance of finding an optimal or near-optimal evaluation plan. Several of the heuristics include weighting factors that can be tuned, either automatically or by the dba, to reflect experience gained while using the optimizer.

Early work on estimating the cost of evaluation plans was based essentially on
“thought experiments” similar to those used earlier in this chapter. These analyses use factors including the size of relations, their expected statistical properties, selectivity factors of joins and selections, and existing indexes. In the context of large queries involving multiple joins, however, it is difficult if not impossible to predict the sizes of intermediate results based only on statistical properties. This provides one motivation for recent research on using random and background sampling to estimate the size of subquery answers, which can provide more reliable estimates of the overall cost of an evaluation plan.

Sideways Information Passing
We close this section by considering two practical approaches to implementing multiway joins as they arise in practical query languages.

Much of the early research on practical query optimization was performed in connection with the System R and INGRES systems. The basic building block of the query
112
Static Analysis and Optimization
languages used in these systems (SQL and Quel, respectively) takes the form of “select-from-where” clauses or blocks. For example, as detailed further in Chapter 7, Query (4.4) can be expressed in SQL as
select
Theater, Address
from
Movies, Location, Pariscope
where
Director = “Bergman”
and Movies.Title = Pariscope.Title
and Pariscope.Theater = Location.Theater.

This can be translated into the algebra as a join between the three relations of the from part, using join condition given by the where and projecting onto the columns mentioned in the select. Thus a typical select-from-where block can be expressed by an SPC query as π(σ
j
F (R1 × · · · × Rn)).

With such expressions, the System R query optimizer pushes selections that affect a single relation into the join and then considers evaluation plans based on left-to-right joins that have the form
(. . . (Ri ⊲⊳ R ) ⊲⊳ · · · ⊲⊳ R )
1
i2
in
using different orderings Ri , . . . , R . We now present a heuristic based on “sideways in-1
in
formation passing,” which is used in the System R optimizer for eliminating some possible orderings from consideration. Interestingly, this heuristic has also played an important role in developing evaluation techniques for recursive datalog queries, as discussed in Chapter 13.

To describe the heuristic, we rewrite the preceding SPC query as a (generalized) rule that has the form
(∗)
ans(u) ← R1(u1), . . . , Rn(un), C1, . . . , Cm,
where all equalities of the selection condition F are incorporated by using constants and equating variables in the free tuples u1, . . . , un, and the expressions C1, . . . , Cm are conditions in the selection condition F not captured in that way. (This might include, e.g., inequalities and conditions based on order.) We shall call the Ri(ui)’s relation atoms and the Cj ’s constraint atoms.

Example 6.1.1
Consider the rule
ans(z) ← P (a, v), Q(b, w, x), R(v, w, y), S(x, y, z), v ≤ x, where a, b denote constants. A common assumption in this case is that there are few values for v such that P (a, v) is satisfied. This in turn suggests that there will be few triples (v, w, y) satisfying P (a, v) ∧ R(v, w, y). Continuing by transitivity, then, we also expect there to be few 5-tuples (v, w, y, x, z) that satisfy the join of this with S(x, y, z).

6.1 Issues in Practical Query Optimization
113
R( v, w, y)
P( a, v)
Q( b, w, x)
S( x, y, z)
6-3.eps
Figure 6.3:
A sip graph
More generally, the sideways information passing graph, or sip graph, of a rule ρ that has the form (∗) just shown has vertexes the set of relation atoms of a rule, and includes an undirected edge between atoms Ri(ui), Rj (uj ) if ui and uj have at least one variable in common. Furthermore, each node with a constant appearing is specially marked. The sip graph for the rule of Example 6.1.1 is shown in Fig. 6.3.

Let us assume that the sip graph for a rule ρ is connected. In this case, a sideways information passing strategy ( sip strategy) for ρ is an ordering A1, . . . , An of the atoms in the rule, such that for each j > 1, either
(a) a constant occurs in Aj ;
(b) Aj is a relational atom and there is at least one i < j such that {Ai, Aj } is an edge of the sip graph of (ρ); or
(c) Aj is a constraint atom and each variable occurring in Aj occurs in some atom Ai for i < j .

Example 6.1.2
A representative sample of the several sip strategies for the rule of Example 6.1.1 is as follows:
P (a, v), Q(b, w, x), v ≤ x, R(v, w, y), S(x, y, z)
P (a, v), R(v, w, y), S(x, y, z), v ≤ x, Q(b, w, x)
Q(b, w, x), R(v, w, y), P (a, v), S(x, y, z), v ≤ x.

A sip strategy for the case in which the sip graph of rule ρ is not connected is a set of sip strategies, one for each connected component of the sip graph. (Incorporation of constraint atoms whose variables lie in distinct components is left for the reader.) The System R optimizer focuses primarily on joins that have connected sip graphs, and it considers only those join orderings that correspond to sip strategies. In some cases a more efficient evaluation plan can be obtained if an arbitrary tree of binary joins is permitted; see Exercise 6.5. While generating sip strategies the System R optimizer also considers
114
Static Analysis and Optimization
alternative implementations for the binary joins involved and records information about the orderings that the partial results would have if computed. An additional logical-level technique used in System R is illustrated in the following example.

Example 6.1.3
Let us consider again the rule
ans(z) ← P (a, v), R(v, w, y), S(x, y, z), v ≤ x, Q(b, w, x).

Suppose that a left-to-right join is performed according to the sip strategy shown. At different intermediate stages certain variables can be “forgotten,” because they are not used in the answer, nor are they used in subsequent joins. In particular, after the third atom the variable y can be projected out, after the fourth atom v can be projected out, and after the fifth atom w and x can be projected out. It is straightforward to formulate a general policy for when to project out unneeded variables (see Exercise 6.4).

Query Decomposition: Join Detachment and Tuple Substitution
We now briefly discuss the two main techniques used in the original INGRES system for evaluating join expressions. Both are based on decomposing multiway joins into smaller ones.

While again focusing on SPC queries of the form
π(σ
j
F (R1 × · · · × Rn))
for this discussion, we use a slightly different notation. In particular, tuple variables rather than domain variables are used. We consider expressions of the form (∗∗)
ans(s) ← R1(s1), . . . , Rn(sn), C1, . . . , Cm, T ,
where s, s1, . . . , sn are tuple variables; C1, . . . , Cn are Boolean conditions referring to coordinates of the variables s1, . . . , sn (e.g., s1.3 = s4.1 ∨ s2.4 = a); and T is a target condition that gives a value for each coordinate of the target variable s. It is generally assumed that none of C1, . . . , Cn has ∧ as its parent connective.

A condition Cj is called single variable if it refers to only one of the variables si. At any point in the processing it is possible to apply one or more single-variable conditions to some Ri, thereby constructing an intermediate relation R′ that can be used in place of R
i
i .

In the INGRES optimizer, this is typically combined with other steps.

Join detachment is useful for separating a query into two separate queries, where the second refers to the first. Consider a query that has the specialized form ans(t ) ← P1(p1), . . . , Pm(pm), C1, . . . , Ck, T ,
(†)
Q(q),
R1(r1), . . . , Rn(rn), D1, . . . , Dl,
6.2 Global Optimization
115
where conditions C1, . . . , Ck, T refer only to variables t, p1, . . . , pm, q and D1, . . . , Dl refer only to q, r1, . . . , rn. It is easily verified that this is equivalent to the sequence temp(q) ← Q(q), R1(r1), . . . , Rn(rn), D1, . . . , Dl
ans(t ) ← P1(p1), . . . , Pm(pm), temp(q), C1, . . . , Ck, T .

In this example, variable q acts as a “pivot” around which the detachment is performed.

More general forms of join detachment can be developed in which a set of variables serves as the pivot (see Exercise 6.6).

Tuple substitution chooses one of the underlying relations Rj and breaks the n-variable join into a set of (n − 1)-variable joins, one for each tuple in Rj . Consider again a query of form (∗∗) just shown. The tuple substitution of this on Ri is given by the “program”
for each r inRi do
ans(s) +← R1(s1), . . . , Ri−1(si−1), Ri+1(si+1), . . . , Rn(sn), (C1, . . . , Cm, T )[si/r].

Here we use +← to indicate that ans is to accumulate the values stemming from all tuples r in (the value of) Ri; furthermore, r is substituted for si in all of the conditions.

There is an obvious trade-off here between reducing the number of variables in the join and the number of tuples in Ri. In the INGRES optimizer, each of the Ri’s is considered as a candidate for forming the tuple substitution. During this process single-variable conditions may be applied to the Ri’s to decrease their size.

6.2
Global Optimization
The techniques for creating evaluation plans presented in the previous section are essentially local in their operation: They focus on clusters of contiguous nodes in a query tree. In this section we develop an approach to the global optimization of conjunctive queries. This allows a transformation of an algebra query that removes several joins in a single step, a capability not provided by the techniques of the previous section. The global optimization technique is based on an elegant Homomorphism Theorem.

The Homomorphism Theorem
For two queries q1, q2 over the same schema R, q1 is contained in q2, denoted q1 ⊆
q2, if for each I over R, q1(I) ⊆ q2(I). Clearly, q1 ≡ q2 iff q1 ⊆ q2 and q2 ⊆ q1. The Homomorphism Theorem provides a characterization for containment and equivalence of conjunctive queries.

We focus here on the tableau formalism for conjunctive queries, although the rule-based formalism could be used equally well. In addition, although the results hold for tableau queries over database schemas involving more than one relation, the examples presented focus on queries over a single relation.

Recall the notion of valuation—a mapping from variables to constants extended to be the identity on constants and generalized to free tuples and tableaux in the natural fashion.

116
Static Analysis and Optimization
R
A
B
R
A
B
R
A
B
R
A
B
x
y
x
y
x
y
1
1
x
y 1
x
x
x
y
1
y 1
1
y 1
x 1
y
x
y
x
y
1
1
2
x
y
x
y
x
y
2
2
x
y
2
x
y
q 0 = ( T 0, 〈 x, y〉)
q 1 = ( T 1, 〈 x, y〉)
q 2 = ( T 2, 〈 x, y〉)
q ω = ( T ω, 〈 x, y〉)
(a)
(b)
(c)
(d)
Figure 6.4:
Tableau queries used to illustrate the Homomorphism Theorem
Valuations are used in the definition of the semantics of tableau queries. More generally, a substitution is a mapping from variables to variables and constants, which is extended to be the identity on constants and generalized to free tuples and tableaux in the natural fashion.

As will be seen, substitutions play a central role in the Homomorphism Theorem.

We begin the discussion with two examples. The first presents several simple examples of the Homomorphism Theorem in action.

Example 6.2.1
Consider the four tableau queries shown in Fig. 6.4. By using the Homomorphism Theorem, it can be shown that q0 ⊆ q1 ⊆ q2 ⊆ qω.

To illustrate the flavor of the proof of the Homomorphism Theorem, we argue informally that q1 ⊆ q2. Note that there is substitution θ such that θ(T2) ⊆ T1 and θ(x, y) =
x, y [e.g., let θ(x1) = θ(x2) = x1 and θ(y1) = θ(y2) = y1]. Now suppose that I is an instance over AB and that t ∈ q1(I ). Then there is a valuation ν such that ν(T1) ⊆ I and ν(x, y) = t . It follows that θ ◦ ν is a valuation that embeds T2 into I with θ ◦ ν(x, y) =
t , whence t ∈ q2(I ).

Intuitively, the existence of a substitution embedding the tableau of q2 into the tableau of q1 and mapping the summary of q2 to the summary of q1 implies that q1 is more restrictive than q2 (or more correctly, no less restrictive than q2.) Surprisingly, the Homomorphism Theorem states that this is also a necessary condition for containment (i.e., if q ⊆ q′, then q is more restrictive than q′ in this sense).

The second example illustrates a limitation of the techniques discussed in the previous section.

Example 6.2.2
Consider the two tableau queries shown in Fig. 6.5. It can be shown that q ≡ q′ but that q′ cannot be obtained from q using the rewrite rules of the previous section (see Exercise 6.3) or the other optimization techniques presented there.

6.2 Global Optimization
117
R
A
B
R
A
B
x
x
x
x
x
y 1
x
y 1
y 2
…
…
y
y
n–1
n
y
x
n
x
q = ( T, u)
q′ = ( T′ , u)
(a)
(b)
Figure 6.5:
Pair of equivalent tableau queries
Let q = (T, u) and q′ = (T′, u′) be two tableau queries over the same schema R. A homomorphism from q′ to q is a substitution θ such that θ (T′) ⊆ T and θ (u′) = u.

Theorem 6.2.3 (Homomorphism Theorem)
Let q = (T, u) and q′ = (T′, u′) be tab-
leau queries over the same schema R. Then q ⊆ q′ iff there exists a homomorphism from (T′, u′) to (T, u).

Proof
Suppose first that there exists a homomorphism θ from q′ to q. Let I be an instance over R. To see that q(I) ⊆ q′(I), suppose that w ∈ q(I). Then there is a valuation ν that embeds T into I such that ν(u) = w. It is clear that θ ◦ ν embeds T′ into I and θ ◦ ν(u′) = w, whence w ∈ q′(I) as desired.

For the opposite inclusion, suppose that q ⊆ q′ [i.e., that (T, u) ⊆ (T′, u′)]. Speaking intuitively, we complete the proof by applying both q and q′ to the “instance” T. Because q will yield the free tuple u, q′ also yields u (i.e., there is an embedding θ of T′ into T that maps u′ to u). To make this argument formal, we construct an instance IT that is isomorphic to T.

Let V be the set of variables occurring in T. For each x ∈ V , let ax be a new distinct constant not occurring in T or T′. Let µ be the valuation mapping each x to ax, and let IT = µ(T). Because µ is a bijection from V to µ(V ), and because µ(V ) has empty intersection with the constants occurring in T, the inverse µ−1 of µ is well defined on adom(IT).

It is clear that µ(u) ∈ q(IT), and so by assumption, µ(u) ∈ q′(IT). Thus there is a valuation ν that embeds T′ into IT such that ν(u′) = µ(u). It is now easily verified that ν ◦ µ−1 is a homomorphism from q′ to q.

Permitting a slight abuse of notation, we have the following (see Exercise 6.8).

Corollary 6.2.4
For tableau queries q = (T, u) and q′ = (T′, u′), q ⊆ q′ iff u ∈ q′(T).

118
Static Analysis and Optimization
We also have
Corollary 6.2.5
Tableau queries q, q′ over schema R are equivalent iff there are homomorphisms from q to q′ and from q′ to q.

In particular, if q = (T, u) and q′ = (T′, u′) are equivalent, then u and u′ are identical up to one-one renaming of variables.

Only one direction of the preceding characterization holds if the underlying domain is finite (see Exercise 6.12). In addition, the direct generalization of the theorem to tableau queries with equality does not hold (see Exercise 6.9).

Query Optimization by Tableau Minimization
Although the Homomorphism Theorem yields a decision procedure for containment and equivalence between conjunctive queries, it does not immediately provide a mechanism, given a query q, to find an “optimal” query equivalent to q. The theorem is now applied to obtain just such a mechanism.

We note first that there are simple algorithms for translating tableau queries into (satisfiable) SPC queries and vice versa. More specifically, given a tableau query, the corresponding generalized SPC query has the form π(σ
j
F (R1 × · · · × Rk)), where each
component Ri corresponds to a distinct row of the tableau. For the opposite direction, one algorithm for translating SPC queries into tableau queries is first to translate into the normal form for generalized SPC queries and then into a tableau query. A more direct approach that inductively builds tableau queries corresponding to subexpressions of an SPC query can also be developed (see Exercise 4.18). Analogous remarks apply to SPJR queries.

The goal of the optimization presented here is to minimize the number of rows in the tableau. Because the number of rows in a tableau query is one more than the number of joins in the SPC (SPJR) query corresponding to that tableau (see Exercise 4.18c), the tableau minimization procedure provides a way to minimize the number of joins in SPC
and SPJR queries.

Surprisingly, we show that an optimal tableau query equivalent to tableau query q can be obtained simply by eliminating some rows from the tableau of q.

We say that a tableau query (T, u) is minimal if there is no query (S, v) equivalent to (T, u) with |S| < |T| (i.e., where S has strictly fewer rows than T).

We can now demonstrate the following.

Theorem 6.2.6
Let q = (T, u) be a tableau query. Then there is a subset T′ of T such that q′ = (T′, u) is a minimal tableau query and q′ ≡ q.

Proof
Let (S, v) be a minimal tableau that is equivalent to q. By Corollary 6.2.5, there are homomorphisms θ from q to (S, v) and λ from (S, v) to q. Let T′ = θ ◦ λ(S). It is straightforward to verify that (T′, u) ≡ q and |T′| ≤ |S|. By minimality of (S, v), it follows that |T′| = |S|, and (T′, u) is minimal.

Example 6.2.7 illustrates how one might minimize a tableau by hand.

6.2 Global Optimization
119
R
A
B
C
u1
x2
y1
z
u2
x
y1
z1
u3
x1
y
z1
u4
x
y2
z2
u5
x2
y2
z
u
x
y
z
Figure 6.6:
The tableau (T , u)
Example 6.2.7
Let R be a relation schema of sort ABC and (T , u) the tableau over R
in Fig. 6.6. To minimize (T , u), we wish to detect which rows of T can be eliminated.

Consider u1. Suppose there is a homomorphism θ from (T , u) onto itself that eliminates u1 [i.e., u1 ∈ θ (T )]. Because any homomorphism on (T , u) is the identity on u, θ (z) = z.

Thus θ (u1) must be u5. But then θ(y1) = y2, and θ(u2) ∈ {u4, u5}. In particular, θ(z1) ∈
{z2, z}. Because u3 involves z1, it follows that θ(u3) = u3 and θ(y) = y. But the last inequality is impossible because y is in u so θ (y) = y. It follows that row u1 cannot be eliminated and is in the minimal tableau. Similar arguments show that u2 and u3 cannot be eliminated. However, u4 and u5 can be eliminated using θ(y2) = y1, θ(z2) = z1 (and identity everywhere else). The preceding argument emphasizes the global nature of tableau minimization.

The preceding theorem suggests an improvement over the optimization strategies described in Section 6.1. Specifically, given a (satisfiable) conjunctive query q, the following steps can be used:
1. Translate q into a tableau query.

2. Minimize the number of rows in the tableau of this query.

3. Translate the result into a generalized SPC expression.

4. Apply the optimization techniques of Section 6.1.

As illustrated by Examples 6.2.2, 6.2.7, and 6.2.8, this approach has the advantage of performing global optimizations that typical query rewriting systems cannot achieve.

Example 6.2.8
Consider the relation schema R of sort ABC and the SPJR query q
over R:
πAB(σB=5(R)) ⊲⊳ πBC(πAB(R) ⊲⊳ πAC(σB=5(R))).

120
Static Analysis and Optimization
R
A
B
C
x
5
z1
x1
5
z2
x1
5
z
u
x
5
z
Figure 6.7:
Tableau equivalent to q
The tableau (T , u) corresponding to it is that of Fig. 6.7. To minimize (T , u), we wish to find a homomorphism that ”folds” T onto a subtableau with minimal number of rows. (If desired, this can be done in several stages, each of which eliminates one or more rows.) Note that the first row cannot be eliminated because every homomorphism is the identity on u and therefore on x. A similar observation holds for the third row. However, the second row can be eliminated using the homomorphism that maps z2 to z and is the identity everywhere else. Thus the minimal tableau equivalent to (T , u) consists of the first and third rows of T . An SPJR query equivalent to the minimized tableau is πAB(σB=5(R)) ⊲⊳ πBC(σB=5(R)).

Thus the optimization procedure resulted in saving one join operation.

Before leaving minimal tableau queries, we present a result that describes a strong correspondence between equivalent minimal tableau queries. Two tableau queries (T, u), (T′, u′) are isomorphic if there is a one-one substitution θ that maps variables to variables such that θ ((T, u)) = (T′, u′). In other words, (T , u) and (T ′, u′) are the same up to renaming of variables. The proof of this result is left to the reader (see Exercise 6.11).

Proposition 6.2.9
Let q = (T, u) and q′ = (T′, u′) be minimal and equivalent. Then q and q′ are isomorphic.

Complexity of Tableau Decision Problems
The following theorem shows that determining containment and equivalence between tableau queries is np-complete and tableau query minimization is np-hard.

Theorem 6.2.10
The following problems, given tableau queries q, q′, are np-complete: (a) Is q ⊆ q′?

(b) Is q ≡ q′?

(c) Suppose that the tableau of q is obtained by deleting free tuples of the tableau of q′. Is q ≡ q′ in this case?

6.2 Global Optimization
121
These results remain true if q, q′ are restricted to be single-relation typed tableau queries that have no constants.

Proof
The proof is based on a reduction from the “exact cover” problem to the different tableau problems. The exact cover problem is to decide, given a set X = {x1, . . . , xn} and a collection S = {S1, . . . , Sm} of subsets of X such that ∪S = X, whether there is an exact cover of X by S (i.e., a subset S′ of S such that each member of X occurs in exactly one member of S′). The exact cover problem is known to be np-complete.

We now sketch a polynomial transformation from instances E = (X, S) of the exact cover problem to pairs qE, q′ of typed tableau queries. This construction is then applied E
in various ways to obtain the np-completeness results. The construction is illustrated in Fig. 6.8.

Let E = (X, S) be an instance of the exact cover problem, where X = {x1, . . . , xn} and S = {S1, . . . , Sm}. Let A1, . . . , An, B1, . . . , Bm be a listing of distinct attributes, and let R
be chosen to have this set as its sort. Both qE and q′ are over relation R, and both queries E
have as summary t = A1 : a1, . . . , An : an, where a1, . . . , an are distinct variables.

Let b1, . . . , bm be an additional set of m distinct variables. The tableau TE of qE has n tuples, each corresponding to a different element of X. The tuple for xi has ai for attribute Ai; bj for attribute Bj for each j such that xi ∈ Sj ; and a new, distinct variable for all other attributes.

Let c1, . . . , cm be an additional set of m distinct variables. The tableau T ′ of q′ has m E
E
tuples, each corresponding to a different element of S. The tuple for Sj has ai for attribute Ai for each i such that xi ∈ Sj ; cj′ for attribute Bj′ for each j ′ such that j ′ = j ; and a new, distinct variable for all other attributes.

To illustrate the construction, let E = (X, S) be an instance of the exact cover problem, where X = {x1, x2, x3, x4} and S = {S1, S2, S3} where
S1 = {x1, x3}
S2 = {x2, x3, x4}
S3 = {x2, x4}.

The tableau queries qξ and q′ corresponding to (X, S) are shown in Fig. 6.8. (Here the ξ
blank entries indicate distinct, new variables.) Note that ξ = (X, S) is satisfiable, and q′ ⊆ q
ξ
ξ .

More generally, it is straightforward to verify that for a given instance ξ = (X, S) of the exact cover problem, X has an exact cover in S iff q′ ⊆ q
ξ
ξ . Verification of this, and of
parts (b) and (c) of the theorem, is left for Exercise 6.16.

A subclass of the typed tableau queries for which containment and equivalence is decidable in polynomial time is considered in Exercise 6.21.

Although an np-completeness result often suggests intractability, this conclusion may not be warranted in connection with the aforementioned result. The complexity there is measured relative to the size of the query rather than in terms of the underlying stored
122
Static Analysis and Optimization
R
A 1 A 2 A 3 A 4 B 1 B 2 B 3
R
A 1 A 2 A 3 A 4 B 1 B 2 B 3
a 1
b 1
a 1
a
c
3
2
c 3
a 2
b 2 b 3
a 2 a 3 a
c
4
1
c 3
a 3
b 1 b 2
a
a
c
2
4
1
c 2
a 4
b 2 b 3
a 1 a 2 a 3 a 4
a 1 a 2 a 3 a 4
q ξ
q′ξ
(a)
(b)
Figure 6.8:
Tableau queries corresponding to an exact cover
data. Given an n-way join, the System R optimizer may potentially consider n! evaluation strategies based on different orderings of the n relations; this may be exponential in the size of the query. In many cases, the search for a minimal tableau (or optimal left-to-right join) may be justified because the data is so much larger than the initial query. More generally, in Part D we shall examine both “data complexity” and “expression complexity,” where the former focuses on complexity relative to the size of the data and the latter relative to the size of queries.

6.3
Static Analysis of the Relational Calculus
We now demonstrate that the decidability results for conjunctive queries demonstrated in the previous section do not hold when negation is incorporated (i.e., do not hold for the first-order queries). In particular, we present a general technique for proving the undecidability of problems involving static analysis of first-order queries and demonstrate the undecidability of three such problems.

We begin by focusing on the basic property of satisfiability. Recall that a query q is satisfiable if there is some input I such that q(I) is nonempty. All conjunctive queries are satisfiable (Proposition 4.2.2), and if equality is incorporated then satisfiability is not guaranteed but it is decidable (Exercise 4.5). This no longer holds for the calculus.

To prove this result, we use a reduction of the Post Correspondence Problem (PCP) (see Chapter 2) to the satisfiability problem. The reduction is most easily described in terms of the calculus; of course, it can also be established using the algebras or nr-datalog¬.

At first glance, it would appear that the result follows trivially from the analogous result for first-order logic (i.e., the undecidability of satisfiability of first-order sentences).

There is, however, an important difference. In conventional first-order logic (see Chapter 2), both finite and infinite interpretations are considered. Satisfiability of first-order sentences is co-recursively enumerable (co-r.e.) but not recursive. This follows from Gödel’s Completeness Theorem. In contrast, in the context of first-order queries, only finite instances are considered legal. This brings us into the realm of finite model theory. As will
6.3 Static Analysis of the Relational Calculus 123
be shown, satisfiability of first-order queries is recursively enumerable (r.e.) but not recursive. (We shall revisit the contrast between conventional first-order logic and the database perspective, i.e., finite model theory, in Chapters 9 and 10.)

Theorem 6.3.1
Satisfiability of relational calculus queries is r.e. but not recursive.

Proof
To see that the problem is r.e., imagine a procedure that, when given query q over R as input, generates all instances I over R and tests q(I) = ∅ until a nonempty answer is found.

To show that satisfiability is not recursive, we reduce the PCP to the satisfiability problem. In particular, we show that if there were an algorithm for solving satisfiability, then it could be used to construct an algorithm that solves the PCP.

Let P = (u1, . . . , un; v1, . . . , vn) be an instance of the PCP (i.e., a pair of sequences of nonempty words over alphabet {0,1}). We describe now a (domain independent) calculus query qP = { | ϕP} with the property that qP is satisfiable iff P has a solution.

We shall use a relation schema R having relations ENC(ODING) with sort [A, B, C, D, E] and SYNCH(RONIZATION) with sort [F, G]. The query qP shall use constants
{0, 1, $, c1, . . . , cn, d1, . . . , dn}. (The use of multiple relations and constants is largely a convenience; the result can be demonstrated using a single ternary relation and no constants. See Exercise 6.19.)

To illustrate the construction of the algorithm, consider the following instance of the PCP:
u1 = 011, u2 = 011, u3 = 0; v1 = 0, v2 = 11, v3 = 01100.

Note that s = (1, 2, 3, 2) is a solution of this instance. That is, u1u2u3u2 = 0110110011 = v1v2v3v2.

Figure 6.9 shows an input instance Is over R which encodes this solution and satisfies the query qP constructed shortly.

In the relation ENC of this figure, the first two columns form a cycle, so that the 10
tuples can be viewed as a sequence rather than a set. The third column holds a listing of the word w = 0110110011 that witnesses the solution to P ; the fourth column describes which words of sequence (u1, . . . , un) are used to obtain w; and the fifth column describes which words of sequence (v1, . . . , vn) are used. The relation SYNCH is used to synchronize the two representations of w by listing the pairs corresponding to the beginnings of new u-words and v-words.

The formula ϕP constructed now includes subformulas to test whether the various conditions just enumerated hold on an input instance. In particular, ϕ = ϕ ENC- key ∧ ϕ cycle ∧ ϕ SYNCH- keys ∧ ϕu- encode ∧ ϕv- encode ∧ ϕu-v- synch, where, speaking informally,
124
Static Analysis and Optimization
ENC
A
B
C
D
E
SYNCH
F
G
$
a1
0
c1
d1
$
$
a1
a2
1
c1
d2
a3
a1
a2
a3
1
c1
d2
a6
a3
a3
a4
0
c2
d3
a7
a8
a4
a5
1
c2
d3
a5
a6
1
c2
d3
a6
a7
0
c3
d3
a7
a8
0
c2
d3
a8
a9
1
c2
d2
a9
$
1
c2
d2
Figure 6.9:
Encoding of a solution to PCP
ϕ ENC-key : states that the first column of ENC is a key; that is, each value occurring in the A column occurs in exactly one tuple of ENC.

ϕcycle : states that constant $ occurs in a cycle with length > 1 in the first two columns of ENC. (There may be other cycles, which can be ignored.)

ϕ SYNCH-keys : states that both the first and second columns of SYNCH are keys.

ϕu-encode : states that for each value x occurring in the first column of SYNCH, if tuple x1, y1, z1, ci, dj is in ENC, then there are at least |u
1
i | − 1 additional tuples in ENC
“after” this tuple, all with value ci in the fourth coordinate, and if these tuples are x2, y2, z2, ci, dj , . . . , x

2
k, yk, zk, ci , djk
then z1 . . . zk = ui; none of x2, . . . , xk occurs in the first column of SYNCH; and if yk = $, then the A value “after” xk occurs in the first column of SYNCH.

ϕv-encode : is analogous to ϕu-encode.

ϕu-v-synch : states that (1) $, $ is in SYNCH; (2) if a tuple x, y is in SYNCH, then the associated u-word and v-word have the same index; and (3) if a tuple x, y is in SYNCH, and either x or y are not the “maximum” A value occurring in F or G, then there exists a tuple x′, y′ in SYNCH, where x′ is the first A value “after” x occurring in F and y′ is the first A value “after” y occurring in G. Finding the A values “after”
x and y is done as in ϕu-encode.

The constructions of these formulas are relatively straightforward; we give two of them here and leave the others for the reader (see Exercise 6.19). In particular, we let ψ (x, y) = ∃p, q, r ENC(x, y, p, q, r)
and set
6.3 Static Analysis of the Relational Calculus 125
ϕ cycle = ∃x(ψ(x, $) ∧ ¬(x = $)) ∧ ∃y(ψ($, y) ∧ ¬(y = $))∧
∀x((∃yψ(x, y)) → (∃zψ(z, x)))∧
∀x((∃yψ(y, x)) → (∃zψ(x, z)))∧
∀x, y1, y2(ψ(y1, x) ∧ ψ(y2, x) → y1 = y2).

If ENC satisfies ϕENC−key ∧ ϕcycle, then the first two coordinates of ENC hold one or more disjoint cycles, exactly one of which contains the value $.

Parts (1) and (2) of ϕu-v-synch are realized by the formula
SYNCH($, $)∧
∀x, y( SYNCH(x, y) →
∃s, p, r, t, p′, q(( ENC(x, s, p, c1, r) ∧ ENC(y, t, p′, q, d1))∨
( ENC(x, s, p, c2, r) ∧ ENC(y, t, p′, q, d2))∨
...

( ENC(x, s, p, cn, r) ∧ ENC(y, t, p′, q, dn)))).

Verifying that the query qP is satisfiable if and only if P has a solution is left to the reader (see Exercise 6.19).

The preceding theorem can be applied to derive other important undecidability results.

Corollary 6.3.2
(a) Equivalence and containment of relational calculus queries are co-r.e. and not recursive.

(b) Domain independence of a relational calculus query is co-r.e. and not recursive.

Proof
It is easily verified that the two problems of part (a) and the problem of part (b) are co-r.e. (see Exercise 6.20). The proofs of undecidability are by reduction from the satisfiability problem. For equivalence, suppose that there were an algorithm for deciding equivalence between relational calculus queries. Then the satisfiability problem can be solved as follows: For each query q = {x1, . . . , xn | ϕ}, this is unsatisfiable if and only if it is equivalent to the empty query q∅. This demonstrates that equivalence is not decidable.

The undecidability of containment also follows from this.

For domain independence, let ψ be a sentence whose truth value depends on the underlying domain. Then {x1, . . . , xn | ϕ ∧ ψ} is domain independent if and only if ϕ is unsatisfiable.

The preceding techniques can also be used to show that “true” optimization cannot be performed for the first-order queries (see Exercise 6.20d).

126
Static Analysis and Optimization
6.4
Computing with Acyclic Joins
We now present a family of interesting theoretical results on the problem of computing the projection of a join. In the general case, if both the data set and the join expression are allowed to vary, then the time needed to evaluate such expressions appears to be exponential.

The measure of complexity here is a combination of both “data” and “expression” complexity, and is somewhat non-standard; see Part D. Interestingly, there is a special class of joins, called acyclic, for which this evaluation is polynomial. A number of interesting properties of acyclic joins are also presented.

For this section we use the named perspective and focus exclusively on flat project-join queries of the form
q = πX(R1 ⊲⊳ · · · ⊲⊳ Rn)
involving projection and natural join. For this discussion we assume that R = R1, . . . , Rn is a fixed database schema, and we use I = (I1, . . . , In) to refer to instances over it.

One of the historical motivations for studying this problem stems from the pure universal relation assumption ( pure URA). An instance I = (I1, . . . , In) over schema R satisfies the pure URA if I = (πR (I ), . . . , π (I )) for some “universal” instance I over ∪n R
1
Rn
j =1
j .

If I satisfies the pure URA, then I can be stored, and queries against the corresponding instance I can be answered using joins of components in I. The URA will be considered in more depth in Chapter 11.

Worst-Case Results
We begin with an example.

Example 6.4.1
Let n > 0 and consider the relations Ri[AiAi+1], i ∈ [1, n − 1], as shown in Fig. 6.10(a). It is easily seen that the natural join of R1, . . . , Rn−1 is exponential in n and thus exponential in the size of the input query and data.

Now suppose that n is odd. Let Rn be as in Fig. 6.10(b), and consider the natural join of R1, . . . , Rn. This is empty. On the other hand, the join of any i of these for i < n has size exponential in i. It follows that the algorithms of the System R and INGRES optimizers take time exponential in the size of the input and output to evaluate this query.

The following result implies that it is unlikely that there is an algorithm for computing projections of joins in time polynomial in the size of the query and the data.

Theorem 6.4.2
It is np-complete to decide, given project-join expression q0 over R, instance I of R, and tuple t, whether t ∈ q0(I). This remains true if q0 and I are restricted so that |q0(I)| ≤ 1.

Proof
The problem is easily seen to be in np. For the converse, recall from Theorem 6.2.10(a) that the problem of tableau containment is np-complete, even for single-
6.4 Computing with Acyclic Joins
127
Ri
Ai
Ai+1
Rn
An
A1
0
a
0
a
0
b
0
b
1
a
1
a
1
b
1
b
a
0
a
0
a
1
a
1
b
0
b
0
b
1
b
1
(a)
(b)
Figure 6.10:
Relations to illustrate join sizes
relation typed tableaux having no constants. We reduce this to the current problem. Let q = (T , u) and q′ = (T ′, u′) be two typed constant-free tableau queries over the same relation schema. Recall from the Homomorphism Theorem that q ⊆ q′ iff there is a homomorphism of q′ to q, which holds iff u ∈ q′(T ).

Assume that the sets of variables occurring in q and in q′ are disjoint. Without loss of generality, we view each variable occurring in q to be a constant. For each variable x occurring in q′, let Ax be a distinct attribute. For free tuple v = (x1, . . . , xn) in T ′, let Iv over Ax , . . . , A
be a copy of T , where the ith attribute is renamed to A . Letting
1
xn
xi
u′ = u′ , . . . , u′ , it is straightforward to verify that
1
m
q′(T ) = πA ,...,A (⊲⊳{Iv | v ∈ T ′}).

u′
u′
1
m
In particular, u ∈ q′(T ) iff u is in this projected join.

To see the last sentence of the theorem, let u = u1, . . . , um and use the query πA ,...,A (⊲⊳{Iv | v ∈ T ′} ⊲⊳ {A : u1, . . . , A
: um}).

u′
u′
u′
u′m
1
m
1
Theorem 6.2.10(a) considers complexity relative to the size of queries. As applied in the foregoing result, however, the queries of Theorem 6.2.10(a) form the basis for constructing a database instance {Iv | v ∈ T ′}. In contrast with the earlier theorem, the preceding result suggests that computing projections of joins is intractable relative to the size of the query, the stored data, and the output.

Acyclic Joins
In Example 6.4.1, we may ask what is the fundamental difference between R1 ⊲⊳ · · · ⊲⊳
Rn−1 and R1 ⊲⊳ · · · ⊲⊳ Rn? One answer is that the relation schemas of the latter join form a cycle, whereas the relation schemas of the former do not.

We now develop a formal notion of acyclicity for joins and four properties equivalent
128
Static Analysis and Optimization
to it. All of these are expressed most naturally in the context of the named perspective for the relational model. In addition, the notion of acyclicity is sometimes applied to database schemas R= {R1, . . . , Rn} because of the natural correspondence between the schema R
and the join R1 ⊲⊳ · · · ⊲⊳ Rn.

We begin by describing four interesting properties that are equivalent to acyclicity.

Let R = {R1, . . . , Rn} be a database schema, where each relation schema has a different sort. An instance I of R is said to be pairwise consistent if for each pair j, k ∈ [1, n], πR (I
j
j ⊲⊳ Ik) = Ij . Intuitively, this means that no tuple of Ij is “dangling” or “lost” after joining with Ik. Instance I is globally consistent if for each j ∈ [1, n], πR (⊲⊳I) = I j
j (i.e.,
no tuple of Ij is dangling relative to the full join). Pairwise consistency can be checked in ptime, but checking global consistency is np-complete (Exercise 6.25). The first property that is equivalent to acyclicity is:
Property (1): Each instance I that is pairwise consistent is globally consistent.

Note that the instance for schema {R1, . . . , Rn−1} of Example 6.4.1 is both pairwise and globally consistent, whereas the instance for {R1, . . . , Rn} is pairwise but not globally consistent.

The second property we consider is motivated by query processing in a distributed environment. Suppose that each relation of I is stored at a different site, that the join ⊲⊳I is to be computed, and that communication costs are to be minimized. A very naive algorithm to compute the join is to send each of the Ij to a specific site and then form the join. In the general case this may cause the shipment of many unneeded tuples because they are dangling in the full join.

The semi-join operator can be used to alleviate this problem. Given instances I, J over R, S, then semi-join of I and J is
I ⊲< J = πR(I ⊲⊳ J ).

It is easily verified that I ⊲⊳ J = (I ⊲< J ) ⊲⊳ J = (J ⊲< I ) ⊲⊳ I . Furthermore there are many cases in which computing the join in one of these ways can reduce data transmission costs if I and J are at different nodes of a distributed database (see Exercise 6.24).

Suppose now that R satisfies Property (1). Given an instance I distributed across the network, one can imagine replacing each relation Ij by its semi-join with other relations of I. If done cleverly, this might be done with communication cost polynomial in the size of I, with the result of the replacements satisfying pairwise consistency. Given Property (1), all relations can now be shipped to a common site, safe in the knowledge that no dangling tuples have been shipped.

More generally, a semi-join program for R is a sequence of commands Ri := R ⊲< R ;
1
i1
j1
Ri := R ⊲< R ;
2
i2
j2
...

Ri := R ⊲< R ;
p
ip
jp
6.4 Computing with Acyclic Joins
129
R1
A
B
C
R2
B
C
D
E
R3
B
C
D
G
R4
C
D
E
F
0
3
2
3
2
1
0
3
2
1
4
2
1
1
4
0
1
2
1
2
3
0
1
2
3
2
2
3
0
1
3
1
2
1
3
1
0
1
3
1
0
3
1
0
2
1
1
3
1
3
1
1
3
1
0
3
Figure 6.11:
Instance for Example 6.4.3
(In practice, the original values of Ri would not be overwritten; rather, a scratch copy j
would be made.) This is a full reducer for R if for each instance I over R, applying this program yields an instance I′ that is globally consistent.

Example 6.4.3
Let R = {ABC, BCDE, BCDG, CDEF } = {R1, R2, R3, R4} and con-
sider the instance I of R shown in Fig. 6.11. I is not globally consistent; nor is it pairwise consistent.

A full reducer for this schema is
R2 := R2 ⊲< R1;
R2 := R2 ⊲< R4;
R3 := R3 ⊲< R2;
R2 := R2 ⊲< R3;
R4 := R4 ⊲< R2;
R1 := R1 ⊲< R2;
Note that application of this program to I has the effect of removing the first tuple from each relation.

We can now state the second property:
Property (2): R has a full reducer.

It can be shown that the schema {R1, . . . , Rn−1} of Example 6.4.1 has a full reducer, but {R1, . . . , Rn} does not (see Exercise 6.26).

The next property provides a way to view a schema as a tree with certain properties.

A join tree of a schema R is an undirected tree T = (R, E) such that (i) each edge (R, R′) is labeled by the set of attributes R ∩ R′; and (ii) for every pair R, R′ of distinct nodes, for each A ∈ R ∩ R′, each edge along the unique path between R and R′ includes label A.

Property (3): R has a join tree.

For example, two join trees of the schema R of Figure 6.11 are T1 = (R, {(R1, R2), (R2, R3), (R2, R4)}) and T2 = (R, {(R1, R3), (R3, R2), (R2, R4)}). (The edge labels are not shown.)

130
Static Analysis and Optimization
A
A
B
F
B
C
C
D
E
R 1[ AB], R 2[ BC], R 3[ AC]
S 1[ ABC], S 2[ CDE], S 3[ AFE], S 4[ ACE]
(a)
(b)
A
B
D
C
T 1[ ABC], T 2[ BCD], T 3[ ABD], T 4[ ACD]
(c)
Figure 6.12:
Three schemas and their hypergraphs
The fourth property we consider focuses entirely on the database schema R and is based on a simple algorithm, called the GYO algorithm.1 This is most easily described in terms of the hypergraph corresponding to R. A hypergraph is a pair F = (V , F ), where V is a set of vertexes and F is family of distinct nonempty subsets of V , called edges (or hyperedges). The hypergraph of schema R is the pair (U, R), where U = ∪R. In what follows, we often refer to a database schema R as a hypergraph. Three schemas and their hypergraphs are shown in Fig. 6.12.

A hypergraph is reduced if there is no pair f, f ′ of distinct edges with f a proper subset of f ′. The reduction of F = (V , F ) is (V , F − {f ∈ F | ∃f ′ ∈ F with f ⊂ f ′}).

Suppose that R is a schema and I over R satisfies the pure URA. If Rj ⊂ Rk, then Ij =
1 This is so named in honor of M. Graham and the team C. T. Yu and M. Z. Ozsoyoglu, who independently came to essentially this algorithm.

6.4 Computing with Acyclic Joins
131
πR (I
j
k), and thus Ij holds redundant information. It is thus natural in this context to assume that R, viewed as a hypergraph, is reduced.

An ear of hypergraph F = (V , F ) is an edge f ∈ F such that for some distinct f ′ ∈ F , no vertex of f − f ′ is in any other edge or, equivalently, such that f ∩ (∪(F − {f })) ⊆ f ′.

In this case, f ′ is called a witness that f is an ear. As a special case, if there is an edge f of F that intersects no other edge, then f is also considered an ear.

For example, in the hypergraph of Fig. 6.12(b), edge ABC is an ear, with witness ACE.

On the other hand, the hypergraph of Fig. 6.12(a) has no ears.

We now have
Algorithm 6.4.4 (GYO Algorithm)
Input: Hypergraph F = (V , F )
Output: A hypergraph involving a subset of edges of F
Do until F has no ears:
1. Nondeterministically choose an ear f of F .

2. Set F := (V ′, F − {f }), where V ′ = ∪(F − {f }).

The output of the GYO algorithm is always reduced.

A hypergraph is empty if it is (∅, ∅). In Fig. 6.12, it is easily verified that the output of the GYO algorithm is empty for part (b), but that parts (a) and (c) have no ears and so equal their output under the algorithm. The output of the GYO algorithm is independent of the order of steps taken (see Exercise 6.28).

We now state the following:
Property (4): The output of the GYO algorithm on R is empty.

Speaking informally, Example 6.4.1 suggests that an absence of cycles yields Properties (1) to (4), whereas the presence of a cycle makes these properties fail. This led researchers in the late 1970s to search for a notion of acyclicity for hypergraphs that both generalized the usual notion of acyclicity for conventional undirected graphs and was equivalent to one or more of the aforementioned properties. For example, the conventional notion of hypergraph acyclicity from graph theory is due to C. Berge; but it turns out that this condition is necessary but not sufficient for the four properties (see Exercise 6.32).

We now define the notion of acyclicity that was found to be equivalent to the four aforementioned properties. Let F = (V , F ) be a hypergraph. A path in F from vertex v to vertex v′ is a sequence of k ≥ 1 edges f1, . . . , fk such that
(i) v ∈ f1;
(ii) v′ ∈ fk;
(iii) fi ∩ fi+1 = ∅ for i ∈ [1, k − 1].

Two vertexes are connected in F if there is a path between them. The notions of connected pair of edges, connected component, and connected hypergraph are now defined in the usual manner.

Now let F = (V , F ) be a hypergraph, and U ⊆ V . The restriction of F to U , denoted F |U , is the result of forming the reduction of (U, {f ∩ U | f ∈ F } − {∅}).

132
Static Analysis and Optimization
Let F = (V , F ) be a reduced hypergraph, let f, f ′ be distinct edges, and let g =
f ∩ f ′. Then g is an articulation set of F if the number of connected components of F |V −g is greater than the number of connected components of F . (This generalizes the notion of articulation point for ordinary graphs.)

Finally, a reduced hypergraph F = (V , F ) is acyclic if for each U ⊆ V , if F |U is connected and has more than one edge then it has an articulation set; it is cyclic otherwise.

A hypergraph is acyclic if its reduction is.

Note that if F = (V , F ) is an acyclic hypergraph, then so is F |U for each U ⊆ V .

Property (5): The hypergraph corresponding to R is acyclic.

We now present the theorem stating the equivalence of these five properties. Additional equivalent properties are presented in Exercise 6.31 and in Chapter 8, where the relationship of acyclicity with dependencies is explored.

Theorem 6.4.5
Properties (1) through (5) are equivalent.

Proof
We sketch here arguments that (4) ⇒ (2) ⇒ (1) ⇒ (5) ⇒ (4). The equivalence of (3) and (4) is left as Exercise 6.30(a).

We assume in this proof that the hypergraphs considered are connected; generalization to the disconnected case is straightforward.

(4) ⇒ (2): Suppose now that the output of the GYO algorithm on R = {R1, . . . , Rn} is empty. Let S1, . . . , Sn be an ordering of R corresponding to a sequence of ear removals stemming from an execution of the GYO algorithm, and let Ti be a witness for Si for i ∈ [1, n − 1]. An induction on n (“from the inside out”) shows that the following is a full reducer (see Exercise 6.30a):
T1 := T1 ⊲< S1;
T2 := T2 ⊲< S2;
...

Tn−1 := Tn−1 ⊲< Sn−1;
Sn−1 := Sn−1 ⊲< Tn−1;
...

S2 := S2 ⊲< T2;
S1 := S1 ⊲< T1;
(2) ⇒ (1): Suppose that R has a full reducer, and let I be a pairwise consistent instance of R. Application of the full reducer to I yields an instance I′ that is globally consistent.

But by pairwise consistency, each step of the full reducer leaves I unchanged. It follows that I = I′ is globally consistent.

(1) ⇒ (5): This is proved by contradiction. Suppose that there is a hypergraph that satisfies Property (1) but violates the definition of acyclic. Let R = {R1, . . . , Rn} be such a hypergraph where n is minimal among such hypergraphs and where the size of U = ∪R is minimal among such hypergraphs with n edges.

6.4 Computing with Acyclic Joins
133
I
A1
A2
. . .

Ap
B1
. . .

Bq
1
0
. . .

0
1
. . .

1
0
1
. . .

0
2
. . .

2
..

.

.

.

.

.

.

.

..

..

..

..

..

..

0
0
. . .

1
p
. . .

p
Figure 6.13:
Instance for proof of Theorem 6.4.5
It follows easily from the minimality conditions that R is reduced. In addition, by minimality no vertex (attribute) in U is in only one edge (relation schema).

Consider now the schema R′ = {R2 − R1, . . . , Rn − R1}. Two cases arise: Case 1: R′ is connected. Suppose that R1 = {A1, . . . , Ap} and U − R1 = {B1 . . . , Bq}.

Consider the instance I over U shown in Fig. 6.13. Define I = {I1, . . . , In} so that Ij = πR (I ) for j ∈ [2, n], and
j
I1 = πR (I ) ∪ {0, 0, . . . , 0}.

1
Using the facts that R′ is connected and that each vertex of R occurs in at least two edges, it is straightforward to verify that I is pairwise consistent but not globally consistent, which is a contradiction (see Exercise 6.30b).

Case 2: R′ is not connected. Choose a connected component of R′ and let {S1, . . . , Sk} be the set of edges of R − {R1} involved in that connected component. Let S = ∪k S
i=1 i and let
R′ = R
1
1 ∩ S. Two subcases arise:
Subcase 2.a: R′ ⊆ S
∩ S
1
j for some j ∈ [1, k]. If this holds, then R′1
j is an articulation
set for R, which is a contradiction (see Exercise 6.30b).

Subcase 2.b: R′ ⊆ S
} is a reduced
1
j for each j ∈ [1, k]. In this case R′′ = {S1, . . . , Sk, R′1
hypergraph with fewer edges than R. In addition, it can be verified that this hypergraph satisfies Property (1) (see Exercise 6.30b). By minimality of n, this implies that R′′ is acyclic. Because it is connected and has at least two edges, it has an articulation set. Two nested subcases arise:
Subcase 2.b.i: Si ∩ Sj is an articulation pair for some i, j . We argue in this case that Si ∩ Sj is an articulation pair for R. To see this, let x ∈ R′ − (S
1
i ∩ Sj ) and let y be a vertex
in some other component of R′′|S−{S
, . . . , R is a path in R from
i ∩Sj }. Suppose that Ri1
il
y to x. Let Ri be the first edge in this path that is not in {S
p
1, . . . , Sk}. By the choice of
{S1, . . . , Sk}, Ri = R
p
1. It follows that there is a path from y to x in R′′|S−{Si∩Sj }, which is a contradiction. We conclude that R has an articulation pair, contradicting the initial assumption in this proof.

Subcase 2.b.ii: R′ ∩ S
1
i is an articulation pair for some i. In this case R1 ∩ Si is an
articulation pair for R (see Exercise 6.30b), again yielding a contradiction to the initial assumption of the proof.

134
Static Analysis and Optimization
(5) ⇒ (4): We first show inductively that each connected reduced acyclic hypergraph F with at least two edges has at least two ears. For the case in which F has two edges, this result is immediate. Suppose now that F = (V , F ) is connected, reduced, and acyclic, with
|F | > 2. Let h = f ∩ f ′ be an articulation set of F. Let G be a connected component of F |V −h. By the inductive hypothesis, this has at least two ears. Let g be an ear of G that is different from f − h and different from f ′ − h. Let g′ be an edge of F such that g = g′ − h.

It is easily verified that g′ is an ear of F (see Exercise 6.30b). Because F |V −h has more than two connected components, it follows that F has at least two ears.

Finally, suppose that F = (V , F ) is acyclic. If there is only one edge, then the GYO
algorithm yields the empty hypergraph. Suppose that it has more than one edge. If F is not reduced, the GYO algorithm can be applied to reduce it. If F is reduced, then by the preceding argument F has an ear, say f . Then a step of the algorithm can be applied to yield F |∪(F−{f }). This is again acyclic. An easy induction now yields the result.

Recall from Theorem 6.4.2 that computing projections of arbitrary joins is probably intractable if both query and data size are considered. The following shows that this is not the case when the join is acyclic.

Corollary 6.4.6
If R is acyclic, then for each instance I over R, the expression πX(⊲⊳I) can be computed in time polynomial in the size of IR, the input, and the output.

Proof
Because the computation for each connected component of R can be performed separately, we assume without loss of generality that R is connected. Let R=(R1, . . . , Rn) and I = (I1, . . . , In). First apply a full reducer to I to obtain I′ = (I ′, . . . , I ′
1
n). This takes
time polynomial in the size of the query and the input; the result is globally consistent; and
⊲⊳ II = ⊲⊳ II′.

Because R is acyclic, by Theorem 6.4.5 there is a join tree T for R. Choose a root for T , say R1. For each subtree Tk of T with root Rk = R1, let Xk = X ∩ (∪{R | R ∈ Tk}), and Zk = Rk∩ (the parent of Rk). Let Jk = I ′ for k ∈ [1, n]. Inductively remove nodes R
k
k
and replace instances Jk from leaf to root of T as follows: Delete node Rk with parent Rm by replacing Jm with Jm ⊲⊳ πX
J
kZk
k. A straightforward induction shows that immediately
before nonleaf node Rk is deleted, then Jk = πX
(⊲⊳
I ′). It follows that at the end
kRk
Rl∈Tk l
of this process the answer is πXJ1 and that at each intermediate stage each instance Jk has size bounded by |I ′| · |π
k
X(⊲⊳IIk)| (see Exercise 6.33).

Bibliographic Notes
An extensive discussion of issues in query optimization is presented in [Gra93]. Other references include [JK84a, KS91, Ull89b]. Query optimization for distributed databases is surveyed in [YC84]. Algorithms for binary joins are surveyed in [ME92].

The paper [SAC+79] describes query optimization in System/R, including a discussion of generating and analyzing multiple evaluation plans and a thorough discussion of accessing tuples from a single relation, as from a projection and selection. System/R is the precursor of IBM’s DB2 database management system. The optimizer for INGRES introduces query decomposition, including both join detachment and tuple substitution [WY76, SWKH76].

Bibliographic Notes
135
The use of semi-joins in query optimization was first introduced in INGRES [WY76, SWKH76] and used for distributed databases in [BC81, BG81]. Research on optimizing buffer management policies includes [FNS91, INSS92, NCS91, Sto81]. Other system optimizers include those for Exodus [GD87], distributed INGRES [ESW78], SDD-1
[BGW+81], and the TI Open Object-Oriented Data Base [BMG93].

[B+88] presents the unifying perspective that physical query implementation can be viewed as generation, manipulation, and merging of streams of tuples and develops a very flexible toolkit for constructing dbms’s. A formal model incorporating streams, sets, and parallelism is presented in [PSV92].

The recent work [IK90] focuses on finding optimal and near-optimal evaluation plans for n-way joins, where n is in the hundreds, using simulated annealing and other techniques. Perhaps most interesting about this work are characterizations of the space of evaluation plans (e.g., properties of evaluation plan cost in relation to natural metrics on this space).

Early research on generation and selection of query evaluation plans is found in
[SAC+79, SWKH76]. Treatments that separate plan generation from transformation rules include [Fre87, GD87, Loh88]. More recent research has proposed mechanisms for generating parameterized evaluation plans; these can be generated at compile time but permit the incorporation of run-time information [GW89, INSS92]. An extensive listing of references to the literature on estimating the costs of evaluation plans is presented in [SLRD93]. This article introduces an estimation technique based on the computation of series functions that approximates the distribution of values and uses regression analysis to estimate the output sizes of select-join queries.

Many forward-chaining expert systems in AI also face the problem of evaluating what amounts to conjunctive queries. The most common technique for evaluating conjunctive queries in this context is based on a sequential generate-and-test algorithm. The paper
[SG85] presents algorithms that yield optimal and near-optimal orderings under this approach to evaluation.

The technique of tableau query minimization was first developed in connection with database queries in [CM77], including the Homomorphism Theorem (Theorem 6.2.3) and Theorem 6.2.6. Theorem 6.2.10 is also due to [CM77]; the proofs sketched in the exercises are due to [SY80] and [ASU79b]. Refinements of this result (e.g., to subclasses of typed tableau queries) are presented in [ASU79b, ASU79a].

The notion of tableau homomorphism is a special case of the notion of subsumption used in resolution theorem proving [CL73]. That work focuses on clauses (i.e., disjunctions of positive and negative literals), and permits function symbols. A clause C = (L1 ∨ · · · ∨
Ln) subsumes a clause D = (M1 ∨ · · · ∨ Mk) if there is a substitution σ such that Cσ
is a subclause of D. A generalized version of tableau minimization, called condensation, also arises in this connection. A condensation of a clause C = (L1 ∨ · · · ∨ Ln) is a clause C′ = (Li ∨ · · · ∨ L ) with m minimal such that C′ = Cθ for some substitution θ . As 1
im
observed in [Joy76], condensations are unique up to variable substitution.

Reference [SY80] studies restricted usage of difference with SPCU queries, for which several positive results can be obtained (e.g., decidability of containment; see Exercise 6.22).

The undecidability results for the relational calculus derive from results in [DiP69]
(see also [Var81]). The assumption in this chapter that relations be finite is essential. For
136
Static Analysis and Optimization
instance, the test for containment is co-r.e. in our context whereas it is r.e. when possibly infinite structures are considered. (This is by reduction to the validity of a formula in first-order predicate logic with equality using the Gödel Completeness Theorem.

The complexity of query languages is studied in [CH82, Var82a] and is considered in Part E of this volume.

As discussed in Chapter 7, practical query languages typically produce bags (also called multisets; i.e., collections whose members may occur more than once). The problem of containment and equivalence of conjunctive queries under the bag semantics is considered in [CV93]. It remains open whether containment is decidable, but it is p
D -hard. On
2
the other hand, two conjunctive queries are equivalent under the bag semantics iff they are isomorphic.

Acyclic joins enjoyed a flurry of activity in the database research community in the late 1970s and early 1980s. As noted in [Mal86], the same concept has been studied in the field of statistics, beginning with [Goo70, Hab70]. An early motivation for their study in databases stemmed from distributed query processing; the notions of join tree and full reducers are from [BC81, BG81]; see also [GS82, GS84, SS86]. The original GYO algorithm was developed in [YO79] and [Gra79]; we use here a variant due to
[FMU82]. The notion of globally consistent is studied in [BR80, HLY80, Ris82, Var82b]; see also [Hul83]. Example 6.4.1 is taken from [Ull89b]. The paper [BFM+81] introduced the notion of acyclicity presented here and observed the equivalence to acyclicity of several previously studied properties, including those of having a full reducer and pairwise consistency implying global consistency; this work is reported in journal form in
[BFMY83].

A linear-time test for acyclicity is developed in [TY84]. Theorem 6.4.2 and Corollary 6.4.6 are due to [Yan81].

The notion of Berge acyclic is due to [Ber76a]. [Fag83] investigates several notions of acyclicity, including the notion studied in this chapter and Berge acyclicity. Further investigation of these alternative notions of acyclicity is presented in [ADM85, DM86b, GR86]. Early attempts to develop a notion of acyclic that captured desirable database characteristics include [Zan76, Gra79].

The relationship of acyclicity with dependencies is considered in Chapter 8.

Many variations of the universal relation assumption arose in the late 1970s and early 1980s. We return to this topic in Chapter 11; surveys of these notions include [AP82, Ull82a, MRW86].

Exercises
Exercise 6.1
(a) Give detailed definitions for the rewrite rules proposed in Section 6.1. In other words, provide the conditions under which they preserve equivalence.

(b) Give the step-by-step description of how the query tree of Fig. 6.1(a) can be transformed into the query tree of Fig. 6.1(b) using these rewrite rules.

Exercises
137
Exercise 6.2
Consider the transformation σF (q1 ⊲⊳G q2) → σF (q1) ⊲⊳G q2 of Fig. 6.2. Describe a query q and database instance for which applying this transformation yields a query whose direct implementation is dramatically more expensive than that of q.

Exercise 6.3
(a) Write generalized SPC queries equivalent to the two tableau queries of Example 6.2.2.

(b) Show that the optimization of this example cannot be achieved using the rewrite rules or multiway join techniques of System/R or INGRES discussed in Section 6.1.

(c) Generate an example analogous to that of Example 6.2.2 that shows that even for typed tableau queries, the rewrite rules of Section 6.1 cannot achieve the optimizations of the Homomorphism Theorem.

Exercise 6.4
Present an algorithm that identifies when variables can be projected out during a left-to-right join of a sip strategy.

Exercise 6.5
Describe a generalization of sip strategies that permits evaluation of multiway joins according to an arbitrary binary tree rather than using only left-to-right join processing.

Give an example in which this yields an evaluation plan more efficient than any left-to-right join.

Exercise 6.6
Consider query expressions that have the form (†) mentioned in the discussion of join detachment in Section 6.1.

(a) Describe how the possibility of applying join detachment depends on how equalities are expressed in the conditions (e.g., Is there a difference between using conditions ‘x.1 = y.1, y.1 = z.1’ versus ‘x.1 = z.1, z.1 = y.1’?). Describe a technique for eliminating this dependence.

(b) Develop a generalization of join detachment in which a set of variables serves as the pivot.

Exercise 6.7
[WY76]
(a) Describe some heuristics for choosing the atom Ri(si) for forming a tuple substitution. These may be in the context of using tuple substitution and join detachment for the resulting subqueries, or they may be in a more general context.

(b) Develop a query optimization algorithm based on applying single-variable conditions, join detachment, and tuple substitution.

Exercise 6.8
Prove Corollary 6.2.4.

Exercise 6.9
(a) State the direct generalization of Theorem 6.2.3 for tableau queries with equality, and show that it does not hold.

(b) State and prove a correct generalization of Theorem 6.2.3 that handles tableau queries with equality.

Exercise 6.10
For queries q, q′, write q ⊂ q′ to denote that q ⊆ q′ and q ≡ q′. The meaning of q ⊃ q′ is defined analogously.

138
Static Analysis and Optimization
(a) Exhibit an infinite set {q0, q1, q2, . . .} of typed tableau queries involving no constants over a single relation with the property that q0 ⊂ q1 ⊂ q2 ⊂ . . . .

(b) Exhibit an infinite set {q′ , q′ , q′ , . . .} of (possibly nontyped) tableau queries involv-0
1
2
ing no constants over a single relation such that q′ ⊆ q′ and q′ ⊆ q′ for each pair i
j
j
i
i = j .

(c) Exhibit an infinite set {q′′, q′′, q′′, . . .} of (possibly nontyped) tableau queries involv-0
1
2
ing no constants over a single relation with the property that q′′ ⊃ q′′ ⊃ q′′ ⊃ . . . .

0
1
2
(d) Do parts (b) and (c) for typed tableau queries that may contain constants.

⋆ (e) [FUMY83] Do parts (b) and (c) for typed tableau queries that contain no constants.

Exercise 6.11
[CM77] Prove Proposition 6.2.9.

Exercise 6.12
(a) Prove that if the underlying domain dom is finite, then only one direction of the statement of Theorem 6.2.3 holds.

(b) Let n > 1 be arbitrary. Exhibit a pair of tableau queries q, q′ such that under the assumption that dom has n elements, q ⊆ q′, but there is no homomorphism from q′
to q. In addition, do this using typed tableau queries.

(c) Show for arbitrary n > 1 that Theorem 6.2.6 and Proposition 6.2.9 do not hold if dom has n elements.

Exercise 6.13
Let R be a relation schema of sort ABC. For each of the following SPJR queries over R, construct an equivalent tableau (see Exercise 4.19), minimize the tableau, and construct from the minimized tableau an equivalent SPJR query with minimal number of joins.

(a) πAC[πAB(R) ⊲⊳ πBC(R)] ⊲⊳ πA[πAC(R) ⊲⊳ πCB(R)]
(b) πAC[πAB(R) ⊲⊳ πBC(R)] ⊲⊳ πAB(σB=8(R)) ⊲⊳ πBC(σA=5(R))
(c) πAB(σC=1(R)) ⊲⊳ πBC(R) ⊲⊳ πAB[σC=1(πAC(R)) ⊲⊳ πCB(R)]
♠ Exercise 6.14 [SY80]
(a) Give a decision procedure for determining whether one union of tableaux query is contained in another one. Hint: Let the queries be q = ({T1, . . . , Tn}, u) and q′ = ({S1, . . . , Sm}, v); and prove that q ⊆ q′ iff for each i ∈ [1, n] there is some j ∈ [1, m] such that (Ti, u) ⊆ (Sj , v). (The case of queries equivalent to q∅ must be handled separately.)

A union of tableaux query ({T1, . . . , Tn}, u) is nonredundant if there is no distinct pair i, j such that (Ti, u) ⊆ (Tj , u).

(b) Prove that if ({T1, . . . , Tn}, u) and ({S1, . . . , Sm}, v) are nonredundant and equivalent, then n = m; for each i ∈ [1, n] there is a j ∈ [1, n] such that (Ti, u) ≡ (Sj , v); and for each j ∈ [1, n] there is a i ∈ [1, n] such that (Sj , v) ≡ (Ti, u).

(c) Prove that for each union of tableaux query q there is a unique (up to renaming) equivalent union of tableaux query that has a minimal total number of atoms.

Exercise 6.15
Exhibit a pair of typed restricted SPJ algebra queries q1, q2 over a relation R
and having no constants, such that there is no conjunctive query equivalent to q1 ∪ q2. Hint: Use tableau techniques.

Exercises
139
♠ Exercise 6.16 [SY80]
(a) Complete the proof of part (a) of Theorem 6.2.10.

(b) Prove parts (b) and (c) of that theorem. Hint: Given ξ and qξ = (Tξ , t) and q′ =
ξ
(T ′, t ) as in the proof of part (a), set q′′ = (T
, t ). Show that ξ is satisfiable iff
ξ
ξ
ξ ∪ T ′
ξ
q′′ ≡ q′ .

ξ
ξ
(c) Prove that it is np-hard to determine, given a pair q, q′ of typed tableau queries over the same relation schema, whether q is minimal and equivalent to q′. Conclude that optimizing conjunctive queries, in the sense of finding an equivalent with minimal number of atoms, is np-hard.

Exercise 6.17
[ASU79b] Prove Theorem 6.2.10 using a reduction from 3-SAT (see Chapter 2) rather than from the exact cover problem.

Exercise 6.18
[ASU79b]
(a) Prove that determining containment between two typed SPJ queries of the form πX(⊲⊳n (π R)) is np-complete. Hint: Use Exercise 6.16.

i=1
Xi
(b) Prove that the problem of finding, given an SPJ query q of the form πX(⊲⊳ni=1
(πX R)), an SPJ query q′ equivalent to q that has the minimal number of join i
operations among all such queries is np-hard.

Exercise 6.19
(a) Complete the proof of Theorem 6.3.1.

(b) Describe how to modify that proof so that qP uses no constants.

(c) Describe how to modify the proof so that no constants and only one ternary relation is used. Hint: Speaking intuitively, a tuple t = a1, . . . , a5 of ENC can be simulated as a set of tuples {bt, b1, a1, . . . , bt, b5, a5}, where bt is a value not used elsewhere and b1, . . . , b5 are values established to serve as integers 1, . . . , 5.

(d) Describe how, given instance P of the PCP, to construct an nr-datalog¬ program that is satisfiable iff P has a solution.

Exercise 6.20
This exercise develops further undecidability results for the relational calculus.

(a) Prove that containment and equivalence of range-safe calculus queries are co-r.e.

(b) Prove that domain independence of calculus queries is co-r.e. Hint: Theorem 5.6.1 is useful here.

(c) Prove that containment of safe-range calculus queries is undecidable.

(d) Show that there is no algorithm that always halts and on input calculus query q gives an equivalent query q′ of minimum length. Conclude that “complete” optimization of the relational calculus is impossible. Hint: If there were such an algorithm, then it would map each unsatisfiable query to a query with formula (of form) ¬(a = b).

♠ Exercise 6.21 [ASU79a, ASU79b] In a typed tableau query (T , u), a summary variable is a variable occurring in u. A repeated nonsummary variable for attribute A is a nonsummary variable in πA(T ) that occurs more than once in T . A typed tableau query is simple if for each attribute A, there is a repeated nonsummary variable in πA(T ), then no other constant or variable in πA(T ) occurs more than once πA(T ). Many natural typed restricted SPJ queries translate into simple tableau queries.

140
Static Analysis and Optimization
(a) Show that the tableau query over R[ABCD] corresponding to
πAC(πAB(R) ⊲⊳ πBC(R)) ⊲⊳ (πAB(R) ⊲⊳ πBD(R))
is not simple.

(b) Exhibit a simple tableau query that is not the result of transforming a typed restricted SPJ query under the algorithm of Exercise 4.19.

(c) Prove that if (T , u) is simple, T ′ ⊆ T , and (T ′, u) is a tableau query, then (T ′, u) is simple.

(d) Develop an O(n4) algorithm that, on input a simple tableau query q, produces a minimal tableau query equivalent to q.

(e) Develop an O(n3) algorithm that, given simple tableau queries q, q′, determines whether q ≡ q′.

(f) Prove that testing containment for simple tableau queries is np-complete.

♠ Exercise 6.22 [SY80] Characterize containment and equivalence between queries of the form q1 − q2, where q1, q2 are SPCU queries. Hint: First develop characterizations for the case in which q1, q2 are SPC queries.

Exercise 6.23
Recall from Exercise 5.9 that an arbitrary nonrecursive datalog¬ rule can be described as a difference q1 − q2, where q1 is an SPC query and q2 is an SPCU query.

(a) Show that Exercise 5.9 cannot be strengthened so that q2 is an SPC query.

(b) Show that containment between pairs of nonrecursive datalog¬ rules is decidable.

Hint: Use Exercise 6.22.

(c) Recall that for each nr-datalog program P with a single-relation target there is an equivalent nr-datalog program P ′ such that all rule heads have the same relation name (see Exercise 4.24). Prove that the analogous result does not hold for nr-datalog¬
programs.

Exercise 6.24
(a) Verify that I ⊲⊳ J = (I ⊲< J ) ⊲⊳ J .

(b) Analyze the transmission costs incurred by the left-hand and right-hand sides of this equation, and describe conditions under which one is more efficient than the other.

Exercise 6.25
[HLY80] Prove that the problem of deciding, given instance I of database schema R, whether I is globally consistent is np-complete.

Exercise 6.26
Prove the following without using Theorem 6.4.5.

(a) The database schema R = {AB, BC, CA} has no full reducer.

(b) For arbitrary n > 1, the schema {R1, . . . , Rn−1} of Example 6.4.1 has a full reducer.

(c) For arbitrary (odd or even) n > 1, the schema {R1, . . . , Rn} of Example 6.4.1 has no full reducer.

Exercise 6.27
(a) Draw the hypergraph of the schema of Example 6.4.3.

(b) Draw the hypergraph of Fig. 6.12(b) in a fashion that suggests it to be acyclic.

Exercises
141
Exercise 6.28
Prove that the output of Algorithm 6.4.4 is independent of the nondeterministic choices.

Exercise 6.29
As originally introduced, the GYO algorithm involved the following steps: Nondeterministically perform either step,
until neither can be applied
1. If v ∈ V is in exactly one edge f ∈ F
then F := (V − {v}, (F − {f } ∪ {f − {v}}) − {∅}).

2. If f ⊆ f ′ for distinct f, f ′ ∈ F ,
then F := (V , F − {f }).

The result of applying the original GYO algorithm to a schema R is the GYO reduction of R.

(a) Prove that the original GYO algorithm yields the same output independent of the nondeterministic choices.

(b) [FMU82] Prove that Algorithm 6.4.4 given in the text yields the empty hypergraph on R iff the GYO reduction of R is the empty hypergraph.

Exercise 6.30
This exercise completes the proof of Theorem 6.4.5.

(a) [BG81] Prove that (3) ⇔ (4).

(b) Complete the other parts of the proof.

Exercise 6.31
[BFMY83] R has the running intersection property if there is an ordering R1, . . . , Rn of R such that for 2 ≤ i ≤ n there exists ji < i such that Ri ∩ (R1 ∪ · · · ∪ Ri−1) ⊆
Rj . In other words, the intersection of each R
s is contained
i
i with the union of the previous R′j
in one of these. Prove that R has the running intersection property iff R is acyclic.

Exercise 6.32
[BFMY83] A Berge cycle in a hypergraph F is a sequence (f1, v1, f2, v2, . . . , fn, vn, fn+1) such that
(i) v1, . . . , vn are distinct vertexes of F;
(ii) f1, . . . , fn are distinct edges of F, and fn+1 = f1;
(iii) n ≥ 2; and
(iv) vi ∈ fi ∩ fi+1 for i ∈ [1, n].

A hypergraph is Berge cyclic if it has a Berge cycle, and it is Berge acyclic otherwise.

(a) Prove that Berge acyclicity is necessary but not sufficient for acyclicity.

(b) Show that any hypergraph in which two edges have two nodes in common is Berge cyclic.

Exercise 6.33
[Yan81] Complete the proof of Corollary 6.4.6.

7 NotesonPractical
Languages
Alice:
What do you mean by practical languages?

Riccardo:
select from where .

Alice:
That’s it?

Vittorio:
Well, there are of course lots of bells and whistles.

Sergio:
But basically, this forms the core of most practical languages.

In this chapter we discuss the relationship of the abstract query languages discussed so far to three representative commercial relational query languages: Structured Query Language (SQL), Query-By-Example (QBE), and Microsoft Access. SQL is by far the dominant relational query language and provides the basis for languages in extensions of the relational model as well. Although QBE is less widespread, it illustrates nicely the basic capabilities and problems of graphic query languages. Access is a popular database management system for personal computers (PCs) and uses many elements of QBE.

Our discussion of the practical languages is not intended to provide a complete description of them, but rather to indicate some of the similarities and differences between theory and practice. We focus here on the central aspects of these languages. Many features, such as string-comparison operators, iteration, and embeddings into a host language, are not mentioned or are touched on only briefly.

We first present highlights of the three languages and then discuss considerations that arise from their use in the real world.

7.1
SQL: The Structured Query Language
SQL has emerged as the preeminent query language for mainframe and client-server relational dbms’s. This language combines the flavors of both the algebra and the calculus and is well suited for the specification of conjunctive queries.

This section begins by describing how conjunctive queries are expressed using SQL.

We then progress to additional features, including nested queries and various forms of negation.

Conjunctive Queries in SQL
Although there are numerous variants of SQL, it has become the standard for relational query languages and indeed for most aspects of relational database access, including data definition, data modification, and view definition. SQL was originally developed under the 142
7.1 SQL: The Structured Query Language
143
name Sequel at the IBM San Jose Research Laboratory. It is currently supported by most of the dominant mainframe commercial relational systems, and increasingly by relational dbms’s for PCs.

The basic building block of SQL queries is the select-from-where clause. Speaking loosely, these have the form
select
<list of fields to select>
from
<list of relation names>
where
<condition>
For example, queries (4.1) and (4.4) of Chapter 4 are expressed by
select
Director
from
Movies
where
Title = ‘Cries and Whispers’;
select
Location.Theater, Address
from
Movies, Location, Pariscope
where
Director = ‘Bergman’
and Movies.Title = Pariscope.Title
and Pariscope.Theater = Location.Theater;
In these queries, relation names themselves are used to denote variables ranging over tuples occurring in the corresponding relation. For example, in the preceding queries, the identifier Movies can be viewed as ranging over tuples in relation Movies. Relation name and attribute name pairs, such as Location.Theater, are used to refer to tuple components; and the relation name can be dropped if the attribute occurs in only one of the relations in the from clause.

The select keyword has the effect of the relational algebra projection operator, the from keyword has the effect of the cross-product operator, and the where keyword has the effect of the selection operator (see Exercise 7.3). For example, the second query translates to (using abbreviated attribute names)
πL.T h,A( σ
( Movies × Location × Pariscope)).

D=‘Bergman’∧M.T i=P .T i∧P .T h=L.T h
If all of the attributes mentioned in the from clause are to be output, then * can be used in place of an attribute list in the select clause. In general, the where condition may include conjunction, disjunction, negation, and (as will be seen shortly) nesting of select-from-where blocks. If the where clause is omitted, then it is viewed as having value true for all tuples of the cross-product. In implementations, as suggested in Chapter 6, optimizations will be used; for example, the from and where clauses will typically be merged to have the effect of an equi-join operator.

In SQL, as with most practical languages, duplicates may occur in a query answer.

144
Notes on Practical Languages
Technically, then, the output of an SQL query may be a bag (also called “multiset”)—
a collection whose members may occur more than once. This is a pragmatic compromise with the pure relational model because duplicate removal is rather expensive. The user may request that duplicates be removed by inserting the keyword distinct after the keyword select.

If more than one variable ranging over the same relation is needed, then variables can be introduced in the from clause. For example, query (4.7), which asks for pairs of persons such that the first directed the second and the second directed the first, can be expressed as select
M1. Director, M1. Actor
from
Movies M1, Movies M2
where
M1. Director = M2. Actor
and M1. Actor = M2. Director; In the preceding example, the Director coordinate of M1 is compared with the Actor coordinate of M2. This is permitted because both coordinates are (presumably) of type character string. Relations are declared in SQL by specifying a relation name, the attribute names, and the scalar types associated with them. For example, the schema for Movies might be declared as
create table Movies
( Title character[60]
Director character[30]
Actor character[30]);
In this case, Title and Director values would be comparable, even though they are character strings of different lengths. Other scalar types supported in SQL include integer, small integer, float, and date.

Although the select-from-where block of SQL has a syntactic flavor close to the relational calculus (but using tuple variables rather than domain variables), from a technical perspective the SQL semantics are firmly rooted in the algebra, as illustrated by the following example.

Example 7.1.1
Let {R[A], S[B], T [C]} be a database schema, and consider the following query:
select
A
from
R, S, T
where
R.A = S.B or R.A = T .C;
A direct translation of this into the SPJR algebra extended to permit disjunction in selection formulas (see Exercise 4.22) yields
7.1 SQL: The Structured Query Language
145
πA(σA=B∨A=C(R × S × T )),
which yields the empty answer if S is empty or if T is empty. Thus the foregoing SQL
query is not equivalent to the calculus query:
{x | R(x) ∧ (S(x) ∨ T (x))}.

A correct translation into the conjunctive calculus (with disjunction) query is
{w | ∃x, y, z(R(x) ∧ S(y) ∧ T (z) ∧ x = w ∧ (x = y ∨ x = z))}.

Adding Set Operators
The select-from-where blocks of SQL can be combined in a variety of ways. We describe first the incorporation of the set operators (union, intersect, and difference). For example, the query
(4.14)
List all actors and director of the movie “Apocalypse Now.”
can be expressed as
(select
Actor Participant
from
Movies
where
Title = ‘Apocalypse Now’)
union
(select
Director Participant
from
Movies
where
Title = ‘Apocalypse Now’);
In the first subquery the output relation uses attribute Participant in place of Actor. This illustrates renaming of attributes, analogous to relation variable renaming. This is needed here so that the two relations that are unioned have compatible sort.

Although union, intersect, and difference were all included in the original SQL, only union is in the current SQL2 standard developed by the American National Standards Institute (ANSI). The two left out can be simulated by other mechanisms, as will be seen later in this chapter.

SQL also includes a keyword contains, which can be used in a selection condition to test containment between the output of two nested select-from-where expressions.

Nested SQL Queries
Nesting permits the use of one SQL query within the where clause of another. A simple illustration of nesting is given by this alternative formulation of query (4.4):
146
Notes on Practical Languages
select
Theater
from
Pariscope
where
Title
in
(select
Title
from
Movies
where
Director = ‘Bergman’);
The preceding example tests membership of a unary tuple in a unary relation. The keyword in can also be used to test membership for arbitrary arities. The symbols < and
> are used to construct tuples from attribute expressions. In addition, because negation is permitted in the where clause, set difference can be expressed. Consider the query List title and theater for movies being shown in only one theater.

This can be expressed in SQL by
select
Title, Theater
from
Pariscope
where
Title, Theater
not in
(select
P1.Title, P1.Theater
from
Pariscope P1, Pariscope P2
where
P1.Title = P2.Title
and not ( P1.Theater = P2.Theater));
Expressing First-Order Queries in SQL
We now discuss the important result that SQL is relationally “complete,” in the sense that it can express all relational queries expressible in the calculus. Recall from Chapter 5 that the family of nr-datalog¬ programs is equivalent to the calculus and algebra. We shall show how to simulate nr-datalog¬ using SQL. Intuitively, the result follows from the facts that (a) each rule can be simulated using the select-from-where construct; (b) multiple rules defining the same predicate can be simulated using union; and (c) negation in rule bodies can be simulated using not in.

We present an example here and leave the formal proof for Exercise 7.4.

Example 7.1.2
Consider the following query against the CINEMA database:
Find the theaters showing every movie directed by Hitchcock.

An nr-datalog¬ program expressing the query is
7.1 SQL: The Structured Query Language
147
Pariscope′(xth, x title) ← Pariscope(xth, x title, x sch) Bad _th(xth)
← Movies(x title, Hitchcock, x act),
Location(xth, x loc, xph),
¬ Pariscope′(xth, x title)
Answer(xth)
← Location(xth, x loc, xph), ¬ Bad _th(xth).

In the program, Bad_th holds the list of “bad” theaters, for which one can find a movie by Hitchcock that the theater is not showing. The last rule takes the complement of Bad_th with respect to the list of theaters provided by Location.

An SQL query expressing an nr-datalog¬ program such as this one can be constructed in two steps. The first is to write SQL queries for each rule separately. In this example, we have
Pariscope′:
select
Theater, Title
from
Pariscope;
Bad_th:
select
Theater
from
Movies, Location
where
Director = ‘Hitchcock’
and Theater, Title
not in
(select *
from
Pariscope′);
Answer:
select
Theater
from
Location
where
Theater
not in
(select *
from
Bad_th);
The second step is to combine the queries. In general, this involves replacing nested queries by their definitions, starting from the answer relation and working backward. In this example, we have
select
Theater
from
Location
where
Theater
not in
(select
Theater
from
Movies, Location
where
Director = ‘Hitchcock’
and Theater, Title
not in
(select
Theater, Title
from
Pariscope));
In this example, each idb (see Section 4.3) relation that occurs in a rule body occurs
148
Notes on Practical Languages
negatively. As a result, all variables that occur in the rule are bound by edb relations, and so the from part of the (possibly nested) query corresponding to the rule refers only to edb relations. In general, however, variables in rule bodies might be bound by positively occurring idb relations, which cannot be used in any from clause in the final SQL query.

To resolve this problem, the nr-datalog¬ program should be rewritten so that all positively occurring relations in rule bodies are edb relations (see Exercise 7.4a).

View Creation and Updates
We conclude our consideration of SQL by noting that it supports both view creation and updates.

SQL includes an explicit mechanism for view creation. The relation Champo-info from Example 4.3.4 is created in SQL by
create view
Le Champo as
select
Pariscope.Title, Schedule, Phone
from
Pariscope, Location
where
Pariscope.Theater = ‘Le Champo’
and Location.Theater = ‘Le Champo.’
Views in SQL can be accessed as can normal relations and are useful in building up complex queries.

As a practical database language, SQL provides commands for updating the database.

We briefly illustrate these here; some theoretical aspects concerning updates are presented in Chapter 22.

SQL provides three primitive commands for modifying the contents of a database—
insert, delete, and update (in the sense of modifying individual tuples of a relation).

The following can be used to insert a new tuple into the Movies database: insert into Movies
values (‘Apocalypse Now,’ ‘Coppola,’ ‘Duvall’);
A set of tuples can be deleted simultaneously:
delete
Movies
where
Director = ‘Hitchcock’;
Tuple update can also operate on sets of tuples (as illustrated by the following) that might be used to correct a typographical error:
update Movies
set
Director = ‘Hitchcock’
where
Director = ‘Hickcook’;
7.2 Query-by-Example and Microsoft Access
149
The ability to insert and delete tuples provides an alternative approach to demonstrating the relational completeness of SQL. In particular, subexpressions of an algebra expression can be computed in intermediate, temporary relations (see Exercise 7.6). This approach does not allow the same degree optimization as the one based on views because the SQL interpreter is required to materialize each of the intermediate relations.

7.2
Query-by-Example and Microsoft Access
We now turn to two query languages that have a more visual presentation. The first, Query-by-Example (QBE), presents a visual display for expressing conjunctive queries that is close to the perspective of tableau queries. The second language, Access, is available on personal computers; it uses elements of QBE, but with a more graphical presentation of join relationships.

QBE
The language Query-By-Example (QBE) was originally developed at the IBM T. J. Watson Research Center and is currently supported as part of IBM’s Query Management Facility.

As illustrated at the beginning of Chapter 4, the basic format of QBE queries is fundamentally two-dimensional and visually close to the tableau queries. Importantly, a variety of features are incorporated into QBE to give more expressive power than the tableau queries and to provide data manipulation capabilities. We now indicate some features that can be incorporated into a QBE-like visual framework. The semantics presented here are a slight variation of the semantics supported for QBE in IBM’s product line.

As seen in Fig. 4.2, which expresses query (4.4), QBE uses strings with prefix _ to denote variables and other strings to denote constants. If the string is preceded by P., then the associated coordinate value forms part of the query output. QBE framework can provide a partial union capability by permitting the inclusion in a query of multiple tuples having a P. prefix in a single relation. For example, Fig. 7.1 expresses the query (4.12)
What films with Allen as actor or director are currently featured at the Concorde?

Under one natural semantics for QBE queries, which parallels the semantics of conjunctive queries and of SQL, this query will yield the empty answer if either σ Director=“Allen” Movies or σ Actor=“Allen” Movies is empty (see Example 7.1.1).

QBE also includes a capability of condition boxes, which can be viewed as an extension of the incorporation of equality atoms into tableau queries.

QBE does not provide a mechanism analogous to SQL for nesting of queries. It is hard to develop an appropriate visual representation of such nesting within the QBE framework, in part due to the lack of scoping rules. More recent extensions of QBE address this issue by incorporating, for example, hierarchical windows. QBE also provides mechanisms for both view definition and database update.

Negation can be incorporated into QBE queries in a variety of ways. The use of database update is an obvious mechanism, although not especially efficient. Two restricted
150
Notes on Practical Languages
Movies
Title
Director
Actor
_X
Allen
_Y
Allen
Pariscope
Theater
Title
Schedule
Concorde
P._X
Concorde
P._Y
Figure 7.1:
One form of union in QBE
Movies
Title
Director
Actor
¬
_Z
Bergman
Pariscope
Theater
Title
Schedule
P._champio ¬Concorde
_ Z
Figure 7.2:
A query with negation in QBE
forms of negation are illustrated in Fig. 7.2, which expresses the following query: (assuming that each film has only one director) what theaters, other than the Concorde, feature a film not directed by Bergman? The ¬ in the Pariscope relation restricts attention to those tuples with Theater coordinate not equal to Concorde, and the ¬ preceding the tuple in the Movies relation is analogous to a negative literal in a datalog rule and captures a limited form of ¬∃ from the calculus; in this case it excludes all films directed by Bergman. When such negation is used, it is required that all variables that occur in a row preceded by ¬ also appear in positive rows. Other restricted forms of negation in QBE include using negative literals in condition boxes and supporting an operator analogous to relational division (as defined in Exercise 5.8).

The following example shows more generally how view definition can be used to obtain relational completeness.

Example 7.2.1
Recall the query and nr-datalog¬ program of Example 7.1.2. As with
SQL, the QBE query corresponding to an nr-datalog¬ will involve one or more views for each rule (see Exercise 7.5). For this example, however, it turns out that we can compute the effect of the first two rules with a single QBE query. Thus the two stages of the full query are shown in Fig. 7.3, where the symbol I. indicates that the associated tuples are to be inserted into the answer. The creation of the view Bad_th is accomplished using the
7.2 Query-by-Example and Microsoft Access
151
Stage I:
Movies
Title
Director
Actor
_ xtitle
Hitchcock
Location
Theater
Address
Phone
_ xth
Pariscope
Theater
Title
Schedule
¬
_ x
_ x
th
title
I.VIEW Bad_th I.

Theater
I.

_ xth
Stage II:
Location
Theater
Address
Phone
_ xth
Answer
Theater
I.

_ xth
Bad_th
Theater
¬
_ xth
Figure 7.3:
Illustration of relational completeness of QBE
expression I. VIEW Bad _ th I., which both creates the view and establishes the attribute names for the view relation.

Microsoft Access: A Query Language for PCs
A number of dbms’s for personal computers have become available over the past few years, such as DBASE IV, Microsoft Access, Foxpro, and Paradox. Several of these support a version of SQL and a more visual query language. The visual languages have a flavor somewhat different from QBE. We illustrate this here by presenting an example of a query from the Microsoft Access dbm’s.

Access provides an elegant graphical mechanism for constructing conjunctive queries.

This includes a tabular display to indicate the form and content of desired output tuples, the use of single-attribute conditions within this display (in the rows named “Criteria” and
“or”), and a graphical presentation of join relationships that are to hold between relations used to form the output. Fig. 7.4 shows how query (4.4) can be expressed using Access.

152
Notes on Practical Languages
SelectQuery: Query4
Movies
Pariscope
Location
Title
Theater
Theater
Director
Title
Address
Actor
Schedule
Phone
Field
Theater
Address
Director
Table
Location
Location
Movies
Sort
Show
Criteria
“Bergman”
Or
Figure 7.4:
Example query in Access
(Although not shown in the figure, join conditions can also be expressed using single-attribute conditions represented as text.)

Limited forms of negation and union can be incorporated into the condition part of an Access query. For more general forms of negation and union, however, the technique of building views to serve as intermediate relations can be used.

7.3
Confronting the Real World
Because they are to be used in practical situations, the languages presented in this chapter incorporate a number of features not included in their formal counterparts. In this section we touch on some of these extensions and on fundamental issues raised by them. These include domain independence, the implications of incorporating many-sorted atomic objects, the use of arithmetic, and the incorporation of aggregate operators.

Queries from all of the practical languages described in this chapter are domain independent. This is easily verified from the form of queries in these languages: Whenever a variable is introduced, the relation it ranges over is also specified. Furthermore, the specific semantics associated with or’s occurring in where clauses (see Example 7.1.1) prevent the kind of safety problem illustrated by query unsafe-2 of Section 5.3.

Most practical languages permit the underlying domain of values to be many-sorted—
for example, including distinct scalar domains for the types integer, real, character string, etc., and some constructed types, such as date, in some languages. (More recent systems, such as POSTGRES, permit the user to incorporate abstract data types as well.) For most of the theoretical treatment, we assumed that there was one underlying domain of values, dom, which was shared equally by all relational attributes. As noted in the discussion of
7.3 Confronting the Real World
153
SQL, the typing of attributes can be used to ensure that comparisons make sense, in that they compare values of comparable type. Much of the theory developed here for a single underlying domain can be generalized to the case of a many-sorted underlying domain (see Exercise 7.8).

Another fundamental feature of practical query languages is that they offer value comparators other than equality. Typically most of the base sorts are totally ordered. This is the case for the integers or the strings (under the lexicographical ordering). It is therefore natural to introduce ≤, ≥, <, > as comparators. For example, to ask the query, “What can we see at the Le Champo after 21:00,” we can use
ans(xt) ← Pariscope(“Le Champo,”xt, xs), xs > “21:00”; and, in the algebra, as
π Title(σ Theater=“Le Champo”∧ Schedule>“21:00” Pariscope).

Exercise 4.30 explores the impact of incorporating comparators into the conjunctive queries. Many languages also incorporate string-comparison operators.

Given the presence of integers and reals, it is natural to incorporate arithmetic operators. This yields a fundamental increase in expressive power: Even simple counting is beyond the power of the calculus (see Exercise 5.34).

Another extension concerns the incorporation of aggregate operators into the practical languages (see Section 5.5). Consider, for example, the query, “How many films did Hitchcock direct?”. In SQL, this can be expressed using the query
select
count(distinct Title)
from
Movies
where
Director = ‘Hitchcock’;
(The keyword distinct is needed here, because otherwise SQL will not remove duplicates from the projection onto Title.) Other aggregate operators typically supported in practical languages include sum, average, minimum, and maximum.

In the preceding example, the aggregate operator was applied to an entire relation.

By using the group by command, aggregate operators can be applied to clusters of tuples, each common values on a specified set of attributes. For example, the following SQL query determines the number of movies directed by each director:
select
Director, count(distinct Title)
from
Movies
group by
Director;
The semantics of group by in SQL are most easily understood when we study an extension of the relational model, called the complex object (or nested relation) model, which models grouping in a natural fashion (see Chapter 20).

154
Notes on Practical Languages
Bibliographic Notes
General descriptions of SQL and QBE may be found in [EN89, KS91, Ull88]; more details on SQL can be found in [C+76], and on QBE in [Zlo77]. Another language similar in spirit to SQL is Quel, which was provided with the original INGRES system. A description of Quel can be found in [SWKH76]. Reference [OW93] presents a survey of QBE langauges and extensions. A reference on Microsoft Access is [Cam92]. In Unix, the command awk provides a basic relational tool.

The formal semantics for SQL are presented in [NPS91]. Example 7.1.1 is from
[VanGT91]. Other proofs that SQL can simulate the relational calculus are presented in
[PBGG89, Ull88]. Motivated by the fact that SQL outputs bags rather than sets, [CV93]
studies containment and equivalence of conjunctive queries under the bag semantics (see
“Bibliographic Notes” in Chapter 6).

Aggregate operators in query languages are studied in [Klu82].

SQL has become the standard relational query language [57391, 69392]; reference
[GW90] presents the original ANSI standard for SQL, along with commentary about particular products and some history. SQL is available on most main-frame relational dbms’s, including, for example, IBM’s DB2, Oracle, Informix, INGRES, and Sybase, and in some more recent database products for personal computers (e.g.,Microsoft Access, dBASE IV).

QBE is available as part of IBM’s product QMF (Query Management Facility). Some personal computer products support more restricted graphical query languages, including Microsoft Access and Paradox (which supports a form-based language).

Exercises
Exercise 7.1
Write SQL, QBE, and Access queries expressing queries (4.1 to 4.14) from Chapter 4. Start by expressing them as nr-datalog¬ programs.

Exercise 7.2
Consider again the queries (5.2 and 5.3) of Chapter 5. Express these in SQL, QBE, and Access.

Exercise 7.3
Describe formally the mapping of SQL select-from-where blocks into the SPJR
algebra.

♠ Exercise 7.4
(a) Let P be an nr-datalog¬ program. Describe how to construct an equivalent program P ′ such that each predicate that occurs positively in a rule body is an edb predicate.

(b) Develop a formal proof that SQL can simulate nr-datalog¬.

Exercise 7.5
Following Example 7.2.1, show that QBE is relationally complete.

Exercise 7.6
(a) Assuming that R and S have compatible sorts, show how to compute in SQL the value of R − S into the relation T using insert and delete.

(b) Generalize this to show that SQL is relationally complete.

Exercises
155
Exercise 7.7
In a manner analogous to Exercise 7.6, show that Access is relationally complete.

⋆ Exercise 7.8 The intuition behind the typed restricted PSJ algebra is that each attribute has a distinct type whose elements are incomparable with the types of other attributes. As motivated by the practical query languages, propose and study a restriction of the SPJR algebra analogous to the typed restricted PSJ algebra, but permitting more than one attribute with the same type. Does the equivalence of the various versions of the conjunctive queries still hold? Can Exercise 6.21 be generalized to this framework?

8 FunctionalandJoin
Dependency
Alice:
Your model reduces the most interesting information to something flat and boring.

Vittorio:
You’re right, and this causes a lot of problems.

Sergio:
Designing the schema for a complex application is tough, and it is easy to make mistakes when updating a database.

Riccardo:
Also, the system knows so little about the data that it is hard to obtain good performance.

Alice:
Are you telling me that the model is bad?

Vittorio:
No, wait, we are going to fix it!

Thischapterbeginswithaninformaldiscussionthatintroducessomesimpledependencies and illustrates the primary motivations for their development and study. The two following sections of the chapter are devoted to two of the simple kinds of dependencies; and the final section introduces the chase, an important tool for analyzing these dependencies and their effect on queries.

Many of the early dependencies introduced in the literature use the named (as opposed to unnamed) perspective on tuples and relations. Dependency theory was one of the main reasons for adopting this perspective in theoretical investigations. This is because dependencies concern the semantics of data, and attribute names carry more semantics than column numbers. The general view of dependencies based on logic, which is considered in Chapter 10, uses the column-number perspective, but a special subcase (called typed) retains the spirit of the attribute-name perspective.

8.1
Motivation
Consider the database shown in Fig. 8.1. Although the schema itself makes no restrictions on properties of data that might be stored, the intended application for the schema may involve several such restrictions. For example, we may know that there is only one director associated with each movie title, and that in Showings, only one movie title is associated with a given theater-screen pair.1 Such properties are called functional dependencies (fd’s) because the values of some attributes of a tuple uniquely or functionally determine the values of other attributes of that tuple. In the syntax to be developed in this chapter, the 1 Gone are the days of seeing two movies for the price of one!

159
160
Functional and Join Dependency
Movies
Title
Director
Actor
The Birds
Hitchcock
Hedren
The Birds
Hitchcock
Taylor
Bladerunner
Scott
Hannah
Apocalypse Now
Coppola
Brando
Showings
Theater
Screen
Title
Snack
Rex
1
The Birds
coffee
Rex
1
The Birds
popcorn
Rex
2
Bladerunner
coffee
Rex
2
Bladerunner
popcorn
Le Champo
1
The Birds
tea
Le Champo
1
The Birds
popcorn
Cinoche
1
The Birds
Coke
Cinoche
1
The Birds
wine
Cinoche
2
Bladerunner
Coke
Cinoche
2
Bladerunner
wine
Action Christine
1
The Birds
tea
Action Christine
1
The Birds
popcorn
Figure 8.1:
Sample database illustrating simple dependencies
dependency in the Movies relation is written as
Movies : Title → Director
and that of the Showings relation is written as
Showings : Theater Screen → Title.

Technically, there are sets of attributes on the left- and right-hand sides of the arrow, but we continue with the convention of omitting set braces when understood from the context.

When there is no confusion from the context, a dependency R : X → Y is simply denoted X → Y . A relation I satisfies a functional dependency X → Y if for each pair s, t of tuples in I ,
πX(s) = πX(t) implies πY (s) = πY (t).

An important notion in dependency theory is implication. One can observe that any relation satisfying the dependency
8.1 Motivation
161
(a)
Title → Director
also has to satisfy the dependency
(b)
Title, Actor → Director.

We will say that dependency (a) implies dependency (b).

A key dependency is an fd X → U , where U is the full set of attributes of the relation.

It turns out that dependency (b) is equivalent to the key dependency Title, Actor → Title, Director, Actor.

A second fundamental kind of dependency is illustrated by the relation Showings. A tuple ( th, sc, ti, sn) is in Showings if theater th is showing movie ti on screen sc and if theater th offers snack sn. Intuitively, one would expect a certain independence between the Screen-Title attributes, on the one hand, and the Snack attribute, on the other, for a given value of Theater. For example, because (Cinoche, 1, The Birds, Coke) and (Cinoche, 2, Bladerunner, wine) are in Showings, we also expect (Cinoche, 1, The Birds, wine) and (Cinoche, 2, Bladerunner, Coke) to be present. More precisely, if a relation I has this property, then
I = π Theater, Screen, Title(I ) ⊲⊳ π Theater, Snack(I ).

This is a simple example of a join dependency (jd) which is formally expressed by Showings : ⊲⊳[{ Theater, Screen, Title}, { Theater, Snacks}].

In general, a jd may involve more than two attribute sets. Multivalued dependency (mvd) is the special case of jd’s that have at most two attribute sets. Due to their naturalness, mvd’s were introduced before jd’s and have several interesting properties, which makes them worth studying on their own.

As will be seen later in this chapter, the fact that the fd Title → Director is satisfied by the Movies relation implies that the jd
⊲⊳[{ Title, Director}, { Title, Actor}]
is also satisfied. We will also study such interaction between fd’s and jd’s.

So far we have considered dependencies that apply to individual relations. Typically these dependencies are used in the context of a database schema, in which case one has to specify the relation concerned by each dependency. We will also consider a third fundamental kind of dependency, called inclusion dependency (ind) and also referred to as
“referential constraint.” In the example, we might expect that each title currently being shown (i.e., occurring in the Showings relation) is the title of a movie (i.e., also occurs in the Movies relation). This is denoted by
Showings[ Title] ⊆ Movies[ Title].

162
Functional and Join Dependency
In general, ind’s may involve sequences of attributes on both sides. Inclusion dependencies will be studied in depth in Chapter 9.

Data dependencies such as the ones just presented provide a formal mechanism for expressing properties expected from the stored data. If the database is known to satisfy a set of dependencies, this information can be used to (1) improve schema design, (2) protect data by preventing certain erroneous updates, and (3) improve performance. These aspects are considered in turn next.

Schema Design and Update Anomalies
The task of designing the schema in a large database application is far from being trivial, so the designer has to receive support from the system. Dependencies are used to provide information about the semantics of the application so that the system may help the user choose, among all possible schemas, the most appropriate one.

There are various ways in which a schema may not be appropriate. The relations Movies and Showings illustrate the most prominent kinds of problems associated with fd’s and jd’s:
Incomplete information: Suppose that one is to insert the title of a new movie and its director without knowing yet any actor of the movie. This turns out to be impossible with the foregoing schema, and it is an insertion anomaly. An analogue for deletion, a deletion anomaly, occurs if actor Marlon Brando is no longer associated with the movie
“Apocalypse Now.” Then the tuple Apocalypse Now, Coppola, Brando should be deleted from the database. But this has the additional effect of deleting the association between the movie “Apocalypse Now” and the director Coppola from the database, information that may still be valid.

Redundancy: The fact that Coke can be found at the Cinoche is recorded many times.

Furthermore, suppose that the management of the Cinoche decided to sell Pepsi instead of Coke. It is not sufficient to modify the tuple Cinoche, 1, The Birds, Coke to Cinoche, 1, The Birds, Pepsi because this would lead to a violation of the jd. We have to modify several tuples. This is a modification anomaly. Insertion and deletion anomalies are also caused by redundancy.

Thus because of a bad choice for the schema, updates can lead to loss of information, inconsistency in the data, and more difficulties in writing correct updates. These problems can be prevented by choosing a more appropriate schema. In the example, the relation Movies should be “decomposed” into two relations M-Director[ Title, Director] and M-Actor[ Title, Actor], where M-Director satisfies the fd Title → Director. Similarly, the relation Showings should be replaced by two relations ST-Showings[ Theater, Screen, Title]
and S-Showings[ Theater, Snack], where ST-Showings satisfies the fd Theater, Screen →
Title. This approach to schema design is explored in Chapter 11.

Data Integrity
Data dependencies also serve as a filter on proposed updates in a natural fashion: If a database is expected to satisfy a dependency σ and a proposed update would lead to the
8.2 Functional and Key Dependencies
163
violation of σ , then the update is rejected. In fact, the system supports transactions. During a transaction, the database can be in an inconsistent state; but at the end of a transaction, the system checks the integrity of the database. If dependencies are violated, the whole transaction is rejected ( aborted); otherwise it is accepted ( validated).

Efficient Implementation and Query Optimization
It is natural to expect that knowledge of structural properties of the stored data be useful in improving the performances of a system for a particular application.

At the physical level, the satisfaction of dependencies leads to a variety of alternatives for storage and access structures. For example, satisfaction of an fd or jd implies that a relation can be physically stored in decomposed form. In addition, satisfaction of a key dependency can be used to reduce indexing space.

A particularly striking theoretical development in dependency theory provides a method for optimizing conjunctive queries in the presence of a large class of dependencies.

As a simple example, consider the query
ans(d, a) ← Movies(t, d, a′), Movies(t, d′, a), which returns tuples d, a, where actor a acted in a movie directed by d. A naive implementation of this query will require a join. Because Movies satisfies Title → Director, this query can be simplified to
ans(d, a) ← Movies(t, d, a),
which can be evaluated without a join. Whenever the pattern of tuples {t, d, a′, t, d′, a}
is found in relation Movies, it must be the case that d = d′, so one may as well use just the pattern {t, d, a}, yielding the simplified query. This technique for query optimization is based on the chase and is considered in the last section of this chapter.

8.2
Functional and Key Dependencies
Functional dependencies are the most prominent form of dependency, and several elegant results have been developed for them. Key dependencies are a special case of functional dependencies. These are the dependencies perhaps most universally supported by relational systems and used in database applications. Many issues in dependency theory have nice solutions in the context of functional dependencies, and these dependencies lie at the origin of the decomposition approach to schema design.

To specify a class of dependencies, one must define the syntax and the semantics of the dependencies of concern. This is done next for fd’s.

Definition 8.2.1
If U is a set of attributes, then a functional dependency (fd) over U is an expression of the form X → Y , where X, Y ⊆ U . A key dependency over U is an fd of the form X → U . A relation I over U satisfies X → Y , denoted I |= X → Y , if for each
164
Functional and Join Dependency
pair s, t of tuples in I , πX(s) = πX(t) implies πY (s) = πY (t). For a set F of fd’s, I satisfies F, denoted I |= F, if I |= σ for each σ ∈ F.

A functional dependency over a database schema R is an expression R : X → Y , where R ∈ R and X → Y is a dependency over sort(R). These are sometimes referred to as tagged dependencies, because they are “tagged” by the relation that they apply to.

The notion of satisfaction of fd’s by instances over R is defined in the obvious way. In the remainder of this chapter, we consider only relational schemas. All can be extended easily to database schemas.

The following simple property provides the basis for the decomposition approach to schema design. Intuitively, it says that if a certain fd holds in a relation, one can store instead of the relation two projections of it, without loss of information. More precisely, the original relation can be reconstructed by joining the projections. Such joins have been termed “lossless joins” and will be discussed in some depth in Section 11.2.

Proposition 8.2.2
Let I be an instance over U that satisfies X → Y and Z = U − XY .

Then I = πXY (I ) ⊲⊳ πXZ(I ).

Proof
The inclusion I ⊆ πXY (I ) ⊲⊳ πXZ(I ) holds for all instances I . For the opposite inclusion, let r be a tuple in the join. Then there are tuples s, t ∈ I such that πXY (r) =
πXY (s) and πXZ(r) = πXZ(t). Because πX(r) = πX(t), and I |= X → Y , πY (r) = πY (t).

It follows that r = t, so r is in I .

Logical Implication
In general, we may know that a set F of fd’s is satisfied by an instance. A natural question is, What other fd’s are necessarily satisfied by this instance? This is captured by the following definition.

Definition 8.2.3
Let F and Ŵ be sets of fd’s over an attribute set U . Then F ( logically) implies Ŵ, denoted F |=U Ŵ or simply F |= Ŵ, if U is understood from the context, if for all relations I over U , I |= F implies I |= Ŵ. Two sets Ŵ, F are ( logically) equivalent, denoted Ŵ ≡ F, if Ŵ |= F and F |= Ŵ.

Example 8.2.4
Consider the set F1 = {A → C, B → C, CD → E} of fd’s over { A, B, C, D, E}. Then2 a simple argument allows to show that F1 |= AD → E. In addition, F1 |=
CDE → C. In fact, ∅ |= CDE → C (where ∅ is the empty set of fd’s).

Although the definition just presented focuses on fd’s, this definition will be used in connection with other classes of dependencies studied here as well.

2 We generally omit set braces from singleton sets of fd’s.

8.2 Functional and Key Dependencies
165
The fd closure of a set F of fd’s over an attribute set U , denoted F∗,U or simply F∗ if U is understood from the context, is the set
{X → Y | XY ⊆ U and F |= X → Y }.

It is easily verified that for any set F of fd’s over U and any sets Y ⊆ X ⊆ U , X →
Y ∈ F∗,U . This implies that the closure of a set of fd’s depends on the underlying set of attributes. It also implies that F∗,U has size greater than 2|U|. (It is bounded by 22|U| by definition.) Other properties of fd closures are considered in Exercise 8.3.

Determining Implication for fd’s Is Linear Time
One of the key issues in dependency theory is the development of algorithms for testing logical implication. Although a set F of fd’s implies an exponential (in terms of the number of attributes present in the underlying schema) number of fd’s, it is possible to test whether F implies an fd X → Y in time that is linear in the size of F and X → Y (i.e., the space needed to write them).

A central concept used in this algorithm is the fd closure of a set of attributes. Given a set F of fd’s over U and attribute set X ⊆ U , the fd closure of X under F, denoted (X, F)∗,U or simply X∗ if F and U are understood, is the set {A ∈ U | F |= X → A}. It turns out that this set is independent of the underlying attribute set U (see Exercise 8.6).

Example 8.2.5
Recall the set F1 of fd’s from Example 8.2.4. Then A∗ = AC, ( AB)∗ =
ABC, and ( AD)∗ = ACDE. The family of subsets X of U such that X∗ = X is {∅, C, D, E, AC, BC, CE, DE, ABC, ACE, ADE, BCE, BDE, CDE, ABCE, ACDE, BCDE, ABCDE}.

The following is easily verified (see Exercise 8.4):
Lemma 8.2.6
Let F be a set of fd’s and X → Y an fd. Then F |= X → Y iff Y ⊆ X∗.

Thus testing whether F |= X → Y can be accomplished by computing X∗. The following algorithm can be used to compute this set.

Algorithm 8.2.7
Input: a set F of fd’s and a set X of attributes.

Output: the closure X∗ of X under F.

1. unused := F;
2. closure := X;
3. repeat until no further change:
if W → Z ∈ unused and W ⊆ closure then
i. unused := unused − {W → Z};
ii. closure := closure ∪ Z
4. output closure.

166
Functional and Join Dependency
Proposition 8.2.8
On input F and X, Algorithm 8.2.7 computes (X, F)∗.

Proof
Let U be a set of attributes containing the attributes occurring in F or X, and let result be the output of the algorithm. Using properties established in Exercise 8.5, an easy induction shows that result ⊆ X∗.

For the opposite inclusion, note first that for attribute sets Y, Z, if Y ⊆ Z then Y ∗ ⊆ Z∗.

Because X ⊆ result, it now suffices to show that result∗ ⊆ result. It is enough to show that if A ∈ U − result, then F |= result → A. To show this, we construct an instance I over U
such that I |= F but I |= result → A for A ∈ U − result. Let I = {s, t}, where π result(s) =
π result(t) and s(A) = t (A) for each A ∈ U − result. (Observe that this uses the fact that the domain has at least two elements.) Note that, by construction, for each fd W → Z ∈ F, if W ⊆ result then Z ⊆ result. It easily follows that I |= F. Furthermore, for A ∈ U − result, s(A) = t (A), so I |= result → A. Thus F |= result → A, and result∗ ⊆ result.

The algorithm provides the means for checking whether a set of dependencies implies a single dependency. To test implication of a set of dependencies, it suffices to test independently the implication of each dependency in the set. In addition, one can check that the preceding algorithm runs in time O(n2), where n is the length of F and X. As shown in Exercise 8.7, this algorithm can be improved to linear time. The following summarizes this development.

Theorem 8.2.9
Given a set F of fd’s and a single fd σ , determine whether F |= σ can be decided in linear time.

Several interesting properties of fd-closure sets are considered in Exercises 8.11 and 8.12.

Axiomatization for fd’s
In addition to developing algorithms for determining logical implication, the second fundamental theme in dependency theory has been the development of inference rules, which can be used to generate symbolic proofs of logical implication. Although the inference rules do not typically yield the most efficient mechanisms for deciding logical implication, in many cases they capture concisely the essential properties of the dependencies under study. The study of inference rules is especially intriguing because (as will be seen in the next section) there are several classes of dependencies for which there is no finite set of inference rules that characterizes logical implication.

Inference rules and algorithms for testing implication provide alternative approaches to showing logical implication between dependencies. In general, the existence of a finite set of inference rules for a class of dependencies is a stronger property than the existence of an algorithm for testing implication. It will be shown in Chapter 9 that
• the existence of a finite set of inference rules for a class of dependencies implies the existence of an algorithm for testing logical implication; and
8.2 Functional and Key Dependencies
167
• there are dependencies for which there is no finite set of inference rules but for which there is an algorithm to test logical implication.

We now present the inference rules for fd’s.

FD1: (reflexivity) If Y ⊆ X, then X → Y .

FD2: (augmentation) If X → Y , then XZ → Y Z.

FD3: (transitivity) If X → Y and Y → Z, then X → Z.

The variables X, Y, Z range over sets of attributes. The first rule is sometimes called an axiom because it is degenerate in the sense that no fd’s occur in the antecedent.

The inference rules are used to form proofs about logical implication between fd’s, in a manner analogous to the proofs found in mathematical logic. It will be shown that the resulting proof system is “sound” and “complete” for fd’s (two classical notions to be recalled soon). Before formally presenting the notion of proof, we give an example.

Example 8.2.10
The following is a proof of AD → E from the set F1 of fd’s of Example 8.2.4.

σ1 :
A → C
∈ F1,
σ2 :
AD → CD
from σ1 using FD2,
σ3 :
CD → E
∈ F1,
σ4 :
AD → E
from σ2 and σ3 using FD3.

Let U be a set of attributes. A substitution for an inference rule ρ (relative to U ) is a function that maps each variable appearing in ρ to a subset of U , such that each set inclusion indicated in the antecedent of ρ is satisfied by the associated sets. Now let F be a set of fd’s over U and σ an fd over U . A proof of σ from F using the set I = {FD1, FD2, FD3} is a sequence of fd’s σ1, . . . , σn = σ (n ≥ 1) such that for each i ∈ [1, n], either (a) σi ∈ F, or
(b) there is a substitution for some rule ρ ∈ I such that σi corresponds to the consequent of ρ, and such that for each fd in the antecedent of ρ the corresponding fd is in the set {σj | 1 ≤ j < i}.

The fd σ is provable from F using I (relative to U ), denoted F I
⊢ σ or F ⊢ σ if I is
understood from the context, if there is a proof of σ from F using I.

Let I be a set of inference rules. Then
I is sound for logical implication of fd’s if F I
⊢ σ implies F |= σ ,
I is complete for logical implication of fd’s if F |= σ implies F I
⊢ σ .

We will generalize these definitions to other dependencies and other sets of inference rules.

In general, a finite sound and complete set of inference rules for a class C of dependencies is called a (finite) axiomatization of C. In such a case, C is said to be (finitely) axiomatizable.

We now state the following:
168
Functional and Join Dependency
Theorem 8.2.11
The set {FD1, FD2, FD3} is sound and complete for logical implica-
tion of fd’s.

Proof
Suppose that F is a set of fd’s over an attribute set U . The proof of soundness involves a straightforward induction on proofs σ1, . . . , σn from F, showing that F |= σi for each i ∈ [1, n] (see Exercise 8.5).

For the proof of completeness, we show that F |= X → Y implies F ⊢ X → Y . As a first step, we show that F ⊢ X → X∗ using an induction based on Algorithm 8.2.7. In particular, let closure i be the value of closure after i iterations of step 3 for some fixed execution of that algorithm on input F and X. We set closure 0 = X. Suppose inductively that a proof σ1, . . . , σk of X → closure
i
i has been constructed. [The case for i = 0 follows
from FD1.] Suppose further that W → Z is chosen for the (i + 1)st iteration. It follows that W ⊆ closure i and closure i+1 = closure i ∪ Z. Extend the proof by adding the following steps:
σki+1 = W → Z
in F
σki+2 = closure i → W
by FD1
σki+3 = closure i → Z
by FD3
σki+4 = closure i → closure i+1
by FD2
σki+5 = X → closure i+1
by FD3
At the completion of this construction we have a proof σ1, . . . , σn of X → X∗. By Lemma 8.2.6, Y ⊆ X∗. Using FD1 and FD3, the proof can be extended to yield a proof of X → Y .

Other inference rules for fd’s are considered in Exercise 8.9.

Armstrong Relations
In the proof of Proposition 8.2.8, an instance I is created such that I |= F but I |= X → A.

Intuitively, this instance witnesses the fact that F |= X → A. This raises the following natural question: Given a set F of fd’s over U , is there a single instance I that satisfies F and that violates every fd not in F∗? It turns out that for each set of fd’s, there is such an instance; these are called Armstrong relations.

Proposition 8.2.12
If F is a set of fd’s over U , then there is an instance I such that, for each fd σ over U , I |= σ iff σ ∈ F∗.

Crux
Suppose first that F |= ∅ → A for any A (i.e., ∅∗ = ∅). For each set X ⊆ U satisfying X = X∗, choose an instance IX = {sX, tX} such that sX(A) = tX(A) iff A ∈ X. In addition, choose these instances so that adom(IX) ∩ adom(IY ) = ∅ for X = Y . Then
∪{IX | X ⊂ U and X = X∗}
is an Armstrong relation for F.

8.3 Join and Multivalued Dependencies
169
If ∅∗ = ∅, then the instances IX should be modified so that πA(IX) = πA(IY ) for each X, Y and A ∈ ∅∗.

In some applications, the domains of certain attributes may be finite (e.g., Sex conventionally has two values, and Grade typically consists of a finite set of values). In such cases, the construction of an Armstrong relation may not be possible. This is explored in Exercise 8.13.

Armstrong relations can be used in practice to assist the user in specifying the fd’s for a particular application. An interactive, iterative specification process starts with the user specifying a first set of fd’s. The system then generates an Armstrong relation for the fd’s, which violates all the fd’s not included in the specification. This serves as a worst-case counterexample and may result in detecting additional fd’s whose satisfaction should be required.

8.3
Join and Multivalued Dependencies
The second kind of simple dependency studied in this chapter is join dependency (jd), which is intimately related to the join operator of the relational algebra. As mentioned in Section 8.1, a basic motivation for join dependency stems from its usefulness in connection with relation decomposition. This section also discusses multivalued dependency (mvd), an important special case of join dependency that was historically the first to be introduced.

The central results and tools for studying jd’s are different from those for fd’s. It has been shown that there is no sound and complete set of inference rules for jd’s analogous to those for fd’s. (An axiomatization for a much larger family of dependencies will be presented in Chapter 10.) In addition, as shown in the following section, logical implication for jd’s is decidable. The complexity of implication is polynomial for a fixed database schema but becomes np-hard if the schema is considered part of the input. (An exact characterization of the complexity remains open.)

The following section also presents an interesting correspondence between mvd’s and acyclic join dependencies (i.e., those based on joins that are acyclic in the sense introduced in Chapter 6).

A major focus of the current section is on mvd’s; this is because of several positive results that hold for them, including axiomatizability of fd’s and mvd’s considered together.

Join Dependency and Decomposition
Before defining join dependency, we recall the definition of natural join. For attribute set U , sets X1, . . . , Xn ⊆ U , and instances Ij over Xj for j ∈ [1, n], the ( natural) join of the Ij ’s is
⊲⊳n
{I
(s) ∈ I
j =1
j } = {s over ∪ Xj | πXj
j for each j ∈ [1, n]}.

A join dependency is satisfied by an instance I if it is equal to the join of some of its projections.

170
Functional and Join Dependency
Definition 8.3.1
A join dependency (jd) over attribute set U is an expression of the form
⊲⊳[X1, . . . , Xn], where X1, . . . , Xn ⊆ U and ∪n X
i=1
i = U . A relation I over U satisfies
⊲⊳[X1, . . . , Xn] if I = ⊲⊳n
{π (I )}.

j =1
Xj
A jd σ is n- ary if the number of attribute sets involved in σ is n. As discussed earlier, the relation Showings of Fig. 8.1 satisfies the 2-ary jd
⊲⊳[{ Theater, Screen, Title}, { Theater, Snacks}].

The 2-ary jd’s are also called multivalued dependencies (mvd’s). These are often denoted in a style reminiscent of fd’s.

Definition 8.3.2
If U is a set of attributes, then a multivalued dependency (mvd) over U is an expression of the form X →
→ Y , where X, Y ⊆ U . A relation I over U satisfies
X →
→ Y if I |= ⊲⊳[XY, X(U − Y )].

In the preceding definition, it would be equivalent to write ⊲⊳[XY, (U − Y )]; we choose the foregoing form to emphasize the importance of X. For instance, the jd
⊲⊳[{ Theater, Screen, Title}, { Theater, Snack}]
can be written as an mvd using
Theater →
→ Screen, Title,
or equivalently,
Theater →
→ Snack.

Exercise 8.16 explores the original definition of satisfaction of an mvd.

Figure 8.2 shows a relation schema SDT and an instance that satisfies a 3-ary jd. This relation focuses on snacks, distributors, and theaters. We assume for this example that a tuple (s, d, p, t) is in SDT if the conjunction of the following predicates is true: P1(s, d, p):
Snack s is supplied by distributor d at price p.

P2(d, t):
Theater t is a customer of distributor d.

P3(s, t):
Snack s is bought by theater t.

Under these assumptions, each instance of SDT must satisfy the jd:
⊲⊳[{ Snack, Distributor, Price}, { Distributor, Theater}, { Snack, Theater}].

For example, this holds for the instance in Fig. 8.2. Note that if tuple coffee, Smart, 2.35, Cinoche were removed, then the instance would no longer satisfy the jd because coffee, Smart, 2.35, coffee, Cinoche, and Smart, Cinoche would remain in the appropriate projections. We also expect the instances of SDT to satisfy Snack, Distributor → Price.

It can be argued that schema SDT with the aforementioned constraint is unnatural in the following sense. Intuitively, if we choose such a schema, the presence of a tuple
8.3 Join and Multivalued Dependencies
171
SDT
Snack
Distributor
Price
Theater
coffee
Smart
2.35
Rex
coffee
Smart
2.35
Le Champo
coffee
Smart
2.35
Cinoche
coffee
Leclerc
2.60
Cinoche
wine
Smart
0.80
Rex
wine
Smart
0.80
Cinoche
popcorn
Leclerc
5.60
Cinoche
Figure 8.2:
Illustration of join dependency
s, d, p, t seems to indicate that t buys s from d. If we wish to record just the information about who buys what, who sells what, and who sells to whom, a more appropriate schema would consist of three relations SD[ Snack, Distributor, Price], ST [ Snack, Theater], and DT [ Distributor, Theater] corresponding to the three sets of attributes involved in the preceding jd. The jd then guarantees that no information is lost in the decomposition because the original relation can be reconstructed by joining the projections.

Join Dependencies and Functional Dependencies
The interaction of fd’s and jd’s is important in the area of schema design and user interfaces to the relational model. Although this is explored in more depth in Chapter 11, we present here one of the first results on the interaction of the two kinds of dependencies.

Proposition 8.3.3
Let U be a set of attributes, {X, Y, Z} be a partition of U , and F be a set of fd’s over U . Then F |= ⊲⊳[XY, XZ] iff either F |= X → Y or F |= X → Z.

Crux
Sufficiency follows immediately from Proposition 8.2.2. For necessity, suppose that F does not imply either of the fd’s. Then Y − X∗ = ∅ and Z − X∗ = ∅, say C ∈ Y − X∗
and C′ ∈ Z − X∗. Consider the two-element instance I = {u, v} where, u(A) = v(A) = 0
if A is in X∗ and u(A) = 0, v(A) = 1 otherwise. Clearly, I satisfies F and one can verify that πXY (I ) ⊲⊳ πXZ(I ) contains a tuple w with w(C) = 0 and w(C′) = 1. Thus w is not in I , so I violates ⊲⊳[XY, XZ].

Axiomatizations
As will be seen later (Theorem 8.4.12), there is a decision procedure for jd’s in isolation, and for jd’s and fd’s considered together. Here we consider axiomatizations, first for jd’s in isolation and then for fd’s and mvd’s taken together.

We state first the following result without proof.

Theorem 8.3.4
There is no axiomatization for the family of jd’s.

172
Functional and Join Dependency
In contrast, there is an axiomatization for the class of fd’s and multivalued dependencies. Note first that implication for fd’s is independent of the underlying set of attributes (i.e., if F ∪ {σ } is a set of fd’s over U and V ⊇ U , then F |= σ relative to U iff F |= σ relative to V ; see Exercise 8.6). An important difference between fd’s and mvd’s is that this is not the case for mvd’s. Thus the inference rules for mvd’s must be used in connection with a fixed underlying set of attributes, and a variable (denoted U ) referring to this set is used in one of the rules.

The following lists the four rules for mvd’s alone and an additional pair of rules needed when fd’s are incorporated.

MVD0: (complementation) If X →
→ Y , then X →
→ (U − Y ).

MVD1: (reflexivity) If Y ⊆ X, then X →
→ Y .

MVD2: (augmentation) If X →
→ Y , then XZ →
→ Y Z.

MVD3: (transitivity) If X →
→ Y and Y →
→ Z, then X →
→ (Z − Y ).

FMVD1: (conversion) If X → Y , then X →
→ Y .

FMVD2: (interaction) If X →
→ Y and XY → Z, then X → (Z − Y ).

Theorem 8.3.5
The set {FD1, FD2, FD3, MVD0, MVD1, MVD2, MVD3, FMVD1,
FMVD2} is sound and complete for logical implication of fd’s and mvd’s considered together.

Crux
Soundness is easily verified. For completeness, let an underlying set U of attributes be fixed, and assume that F ⊢ σ , where σ = X → Y or σ = X →
→ Y .

The dependency set of X is dep(X) = {Y ⊆ U | F ⊢ X →
→ Y }. One first shows that
1. dep(X) is a Boolean algebra of sets for U .

That is, it contains U and is closed under intersection, union, and difference (see Exercise 8.17). In addition,
2. for each A ∈ X+, {A} ∈ dep(X),
where X+ denotes {A ∈ U | F ⊢ X → A}.

A dependency basis of X is a family {W1, . . . , Wm} ⊆ dep(X) such that (1) ∪n W
i=1
i =
U ; (2) Wi = ∅ for i ∈ [1, n]; (3) Wi ∩ Wj = ∅ for i, j ∈ [1, n] with i = j ; and (4) if W ∈ dep(X), W = ∅, and W ⊆ Wi for some i ∈ [1, n], then W = Wi. One then proves that
3. there exists a unique dependency basis of X.

Now construct an instance I over U that contains all tuples t satisfying the following conditions:
(a) t (A) = 0 for each A ∈ X+.

(b) If Wi is in the dependency basis and Wi = {A} for each A ∈ X+, then t (B) = 0
for all B ∈ Wi or t (B) = 1 for all B ∈ Wi.

It can be shown that I |= F but I |= σ (see Exercise 8.17).

8.4 The Chase
173
This easily implies the following (see Exercise 8.18):
Corollary 8.3.6
The set {MVD0, MVD1, MVD2, MVD3} is sound and complete for
logical implication of mvd’s considered alone.

8.4
The Chase
This section presents the chase, a remarkable tool for reasoning about dependencies that highlights a strong connection between dependencies and tableau queries. The discussion here is cast in terms of fd’s and jd’s, but as will be seen in Chapter 10, the chase generalizes naturally to a broader class of dependencies. At the end of this section, we explore important applications of the chase technique. We show how it can also be used to determine logical implication between sets of dependencies and to optimize conjunctive queries.

The following example illustrates an intriguing connection between dependencies and tableau queries.

Example 8.4.1
Consider the tableau query (T , t) shown in Fig. 8.3(a). Suppose the query is applied only to instances I satisfying some set F of fd’s and jd’s. The chase is based on the following simple idea. If ν is a valuation embedding T into an instance I satisfying F, ν(T ) must satisfy F. Valuations that do not satisfy F are therefore of no use.

The chase is a procedure that eliminates the useless valuations by changing (T , t) itself so that T , viewed as an instance, satisfies F. We will show that the tableau query resulting from the chase is then equivalent to the original on instances satisfying F. As we shall see, this can be used to optimize queries and test implication of dependencies.

Let us return to the example. Suppose first that F = {B → D}. Suppose (T , t) is applied to an instance I satisfying F. In each valuation embedding T into I , it must be the case that z and z′ are mapped to the same constant. Thus in this context one might as well replace T by the tableau where z = z′. This transformation is called “applying the fd B → D” to (T , t). It is easy to see that the resulting tableau query is in fact equivalent to the identity, because T contains an entire row of distinguished variables.

Consider next an example involving both fd’s and jd’s. Let F consist of the following two dependencies over ABCD: the jd ⊲⊳[ AB, BCD] and the fd A → C. In this example we argue that for each I satisfying these dependencies, (T , t)(I ) = I or, in other words, in the context of input instances that satisfy the dependencies, the query (T , t) is equivalent to the identity query ({t}, t).

Let I be an instance over ABCD satisfying the two dependencies. We first explain why (T , t)(I ) = (T ′, t)(I ) for the tableau query (T ′, t) of Fig. 8.3(b). It is clear that (T ′, t )(I ) ⊆ (T , t )(I ), because T ′ is a superset of T . For the opposite inclusion, suppose that ν is a valuation for T with ν(T ) ⊆ I . Then, in particular, both ν(w, x, y, z′) and ν(w′, x, y′, z) are in I . Because I |= ⊲⊳[ AB, BCD], it follows that ν(w, x, y′, z) ∈ I .

Thus ν(T ′) ⊆ I and ν(t) ∈ (T ′, t)(I ). The transformation from (T , t) to (T ′, t) is termed
“applying the jd ⊲⊳[ AB, BCD],” because T ′ is the result of adding a member of π AB(T ) ⊲⊳
174
Functional and Join Dependency
A
B
C
D
A
B
C
D
A
B
C
D
T
w
x
y
z′
T′
w
x
y
z′
T′′
w
x
y
z′
w′
x
y′
z
w′
x
y′
z
w′
x
y
z
w
x
y′
z
w
x
y
z
t
w
x
y
z
t
w
x
y
z
t
w
x
y
z
(a) The tableau query ( T, t)
(b) (One) result of applying
(c) Result of applying
the jd [ AB, BCD]
the fd A → C
Figure 8.3:
Illustration of the chase
π BCD(T ) to T . We shall see that, by repeated applications of a jd, one can eventually
“force” the tableau to satisfy the jd.

The tableau T ′′ of Fig. 8.3(c) is the result of chasing (T ′, t) with the fd A → C (i.e., replacing all occurrences of y′ by y). We now argue that (T ′, t)(I ) = (T ′′, t)(I ). First, by Theorem 6.2.3, (T ′, t)(I ) ⊇ (T ′′, t)(I ) because there is a homomorphism from (T ′, t) to (T ′′, t). For the opposite inclusion, suppose now that ν(T ′) ⊆ I . This implies that ν
embeds the first tuple of T ′′ into I . In addition, because ν(w, x, y, z′) and ν(w, x, y′, z) are in I and I |= A → C, it follows that ν(y) = ν(y′). Thus ν(w′, x, y, z) = ν(w′, x, y′, z) ∈ I , and ν(w, x, y, z) = ν(w, x, y′, z) ∈ I , [i.e., ν embeds the second and third tuples of T ′′ into I , such that ν(T ′′) ⊆ I ]. Note that (T ′′, t) is the result of identifying a pair of variables that caused a violation of A → C in T ′. We will see that by repeated applications of an fd, one can eventually “force” a tableau to satisfy the fd. Note that in this case, chasing with respect to A → C has no effect before chasing with respect to
⊲⊳[AB, BCD].

Finally, note that by the Homomorphism Theorem 6.2.3 of Chapter 6, (T ′′, t) ≡
({t }, t ). It follows, then, that for all instances I that satisfy {A → C, ⊲⊳[ AB, BCD]}, (T , t) and ({t}, t) yield the same answer.

Defining the Chase
As seen in Example 8.4.1, the chase relates to equivalence of queries over a family of instances satisfying certain dependencies. For a family F of instances over R, we say that q1 is contained in q2 relative to F, denoted q1 ⊆F q2, if q1(I) ⊆ q2(I) for each instance I in F . We are particularly interested in families F that are defined by a set F of dependencies (in the current context, fd’s and jd’s). Let F be a set of (functional and join) dependencies over R. The satisfaction family of F, denoted sat(R, F) or simply sat(F) if R is understood from the context, is the family
sat(F) = {I over R | I |= F}.

8.4 The Chase
175
Query q1 is contained in q2 relative to F, denoted q1 ⊆F q2, if q1 ⊆ sat(F) q2. Equivalence relative to a family of instances (≡F ) and to a set of dependencies (≡F) are defined similarly.

The chase is a general technique that can be used, given a set of dependencies F, to transform a tableau query q into a query q′ such that q ≡F q′. The chase is defined as a nondeterministic procedure based on the successive application of individual dependencies from F, but as will be seen this process is “Church-Rosser” in the sense that the procedure necessarily terminates with a unique end result. As a final step in this development, the chase will be used to characterize equivalence of conjunctive queries with respect to a set F of dependencies (≡F).

In the following, we let R be a fixed relation schema, and we focus on sets F of fd’s and jd’s over R and tableau queries with no constants over R. The entire development can be generalized to database schemas and conjunctive queries with constants (Exercise 8.27) and to a considerably larger class of dependencies (Chapter 10).

For technical convenience, we assume that there is a total order ≤ on the set var. Let R be a fixed relation schema and suppose that (T , t) is a tableau query over R. The chase is based on the successive application of the following two rules:
fd rule: Let σ = X → A be an fd over R, and let u, v ∈ T be such that πX(u) = πX(v) and u(A) = v(A). Let x be the lesser variable in {u(A), v(A)} under the ordering ≤, and let y be the other one (i.e., {x, y} = {u(A), v(A)} and x < y). The result of applying the fd σ to u, v in (T , t) is the tableau query (θ (T ), θ (t)), where θ is the substitution that maps y to x and is the identity elsewhere.

jd rule: Let σ =⊲⊳[X1, . . . , Xn] be a jd over R, let u be a free tuple over R not in T , and suppose that u1, . . . , un ∈ T satisfy πX (u
(u) for i ∈ [1, n]. Then the result of
i
i ) = πXi
applying the jd σ to (u1, . . . , un) in (T , t) is the tableau query (T ∪ {u}, t).

Following the lead of Example 8.4.1, the following is easily verified (see Exercise 8.24a).

Proposition 8.4.2
Suppose that F is a set of fd’s and jd’s over R, σ ∈ F, and q is a
tableau query over R. If q′ is the result of applying σ to some tuples in q, then q′ ≡F q.

A chasing sequence of (T , t) by F is a (possibly infinite) sequence (T , t ) = (T0, t0), . . . , (Ti, ti), . . .

such that for each i ≥ 0, (Ti+1, ti+1) (if defined) is the result of applying some dependency in F to (Ti, ti). The sequence is terminal if it is finite and no dependency in F can be applied to it. The last element of the terminal sequence is called its result. The notion of satisfaction of a dependency is extended naturally to tableaux. The following is an important property of terminal chasing sequences (Exercise 8.24b).

Lemma 8.4.3
Let (T ′, t′) be the result of a terminal chasing sequence of (T , t) by F.

Then T ′, considered as an instance, satisfies F.

176
Functional and Join Dependency
Because the chasing rules do not introduce new variables, it turns out that the chase procedure always terminates. The following is easily verified (Exercise 8.24c): Lemma 8.4.4
Let (T , t) be a tableau query over R and F a set of fd’s and jd’s over R.

Then each chasing sequence of (T , t) by F is finite and is the initial subsequence of a terminal chasing sequence.

An important question now is whether the results of different terminal chasing sequences are the same. This turns out to be the case. This property of chasing sequences is called the Church-Rosser property. We provide the proof of the Church-Rosser property for the chase at the end of this section (Theorem 8.4.18).

Because the Church-Rosser property holds, we can define without ambiguity the result of chasing a tableau query by a set of fd’s and jd’s.

Definition 8.4.5
If (T , t) is a tableau query over R and F a set of fd’s and jd’s over R, then the chase of (T , t) by F, denoted chase(T , t, F), is the result of some (any) terminal chasing sequence of (T , t) by F.

From the previous discussion, chase(T , t, F) can be computed as follows. The dependencies are picked in some arbitrary order and arbitrarily applied to the tableau. Applying an fd to a tableau query q can be performed within time polynomial in the size of q. However, determining whether a jd can be applied to q is np-complete in the size of q. Thus the best-known algorithm for computing the chase is exponential (see Exercise 8.25). However, the complexity is polynomial if the schema is considered fixed.

Until now, besides the informal discussion in Section 8.1, the chase remains a purely syntactic technique. We next state a result that shows that the chase is in fact determined by the semantics of the dependencies in F and not just their syntax.

In the following proposition, recall that by definition, F ≡ F′ if F |= F′ and F′ |=
F. The proof, which we omit, uses the Church-Rosser property of the chase (see also Exercise 8.26).

Proposition 8.4.6
Let F and F′ be sets of fd’s and jd’s over R, and let (T , t) be a
tableau query over R. If F ≡ F′, then chase(T , t, F) and chase(T , t, F′) coincide.

We next consider several important uses of the chase that illustrate the power of this technique.

Query Equivalence
We consider first the problem of checking the equivalence of tableau queries in the presence of a set of fd’s and jd’s. This allows, for example, checking whether a tableau query can be replaced by a simpler tableau query when the dependencies are satisfied. Suppose now that (T ′, t′) and (T ′′, t′′) are two tableau queries and F a set of fd’s and jd’s such that (T ′, t ′) ≡F (T ′′, t′′). From the preceding development (Proposition 8.4.2), it follows that
8.4 The Chase
177
chase(T ′, t′, F) ≡F (T ′, t′) ≡F (T ′′, t′′) ≡F chase(T ′′, t′′, F).

We now show that, in fact, chase(T ′, t′, F) ≡ chase(T ′′, t′′, F). Furthermore, this condition is sufficient as well as necessary.

To demonstrate this result, we first establish the following more general fact.

Theorem 8.4.7
Let F be a family of instances over relation schema R that is closed under isomorphism, and let (T1, t1), (T2, t2), (T ′, t′ ), and (T ′, t′ ) be tableau queries over 1
1
2
2
R. Suppose further that for i = 1, 2,
(a) (T ′, t′) ≡
i
i
F (Ti , ti ) and
(b) T ′, considered as an instance, is in F .3
i
Then (T1, t1) ⊆F (T2, t2) iff (T ′, t′ ) ⊆ (T ′, t′ ).

1
1
2
2
Proof
The if direction is immediate. For the only-if direction, suppose that (T1, t1) ⊆F
(T2, t2). It suffices by the Homomorphism Theorem 6.2.3 to exhibit a homomorphism that embeds (T ′, t′ ) into (T ′, t′ ). Because T ′, considered as an instance, is in F , 2
2
1
1
1
t ′ ∈
∈
∈
∈
1
(T ′1, t′1)(T ′1) ⇒ t′1 (T1, t1)(T ′1) ⇒ t′1 (T2, t2)(T ′1) ⇒ t′1 (T ′2, t′2)(T ′1).

It follows that there is a homomorphism h such that h(T ′) ⊆ T ′ and h(t′ ) = t′ . Thus 2
1
2
1
(T ′, t ′ ) ⊆ (T ′, t ′ ). This completes the proof.

1
1
2
2
Together with Lemma 8.4.3, this implies the following:
Theorem 8.4.8
Let (T1, t1) and (T2, t2) be tableau queries over R and F a set of fd’s and jd’s over R. Then
1. (T1, t1) ⊆F (T2, t2) iff chase(T1, t1, F) ⊆ chase(T2, t2, F).

2. (T1, t1) ≡F (T2, t2) iff chase(T1, t1, F) ≡ chase(T2, t2, F).

Query Optimization
As suggested in Example 8.4.1, the chase can be used to optimize tableau queries in the presence of dependencies such as fd’s and jd’s. Given a tableau query (T , t) and a set F of fd’s and jd’s, chase(T , t, F) is equivalent to (T , t) on all instances satisfying F. A priori, it is not clear that the new tableau is an improvement over the first. It turns out that the chase using fd’s can never yield a more complicated tableau and, as shown in Example 8.4.1, can yield a much simpler one. On the other hand, the chase using jd’s may yield a more complicated tableau, although it may also produce a simpler one.

We start by looking at the effect on tableau minimization of the chase using fd’s.

In the following, we denote by min(T , t) the tableau resulting from the minimization of 3 More precisely, T ′ considered as an instance is in F means that some instance isomorphic to T ′ is in F .

178
Functional and Join Dependency
the tableau (T , t) using the Homomorphism Theorem 6.2.3 for tableau queries, and by
| min(T , t)| we mean the cardinality of the tableau of min(T , t).

Lemma 8.4.9
Let (T , t) be a tableau query and F a set of fd’s. Then | min( chase(T , t, F))| ≤ | min(T , t )|.

Crux
By the Church-Rosser property of the chase, the order of the dependencies used in a chase sequence is irrelevant. Clearly it is sufficient to show that for each tableau query (T ′, t ′) and σ ∈ F, | min( chase(T ′, t′, σ ))| ≤ | min(T ′, t′)|. We can assume without loss of generality that σ is of the form X → A, where A is a single attribute.

Let (T ′′, t′′) = chase(T ′, t′, {X → A}), and let θ be the chase homomorphism of a chasing sequence for chase(T ′, t′, {X → A}), i.e., the homomorphism obtained by composing the substitutions used in that chasing sequence (see the proof of Theorem 8.4.18).

We will use here the Church-Rosser property of the chase (Theorem 8.4.18) as well as a related property stating that the homomorphism θ , like the result, is also the same for all chase sequences (this follows from the proof of Theorem 8.4.18).

By Theorem 6.2.6, there is some S ⊆ T ′ such that (S, t′) is a minimal tableau query equivalent to (T ′, t′); we shall use this as the representative of min(T ′, t′). Let h be a homomorphism such that h(T ′, t′) = (S, t′). Consider the mapping f on (T ′′, t′′) defined by f (θ (x)) = θ (h(x)), where x is a variable in (T ′, t′). If we show that f is well defined, we are done. [If f is well defined, then f is a homomorphism from (T ′′, t′′) to θ (S, t′) =
(θ (S), t ′′), and so (T ′′, t′′) ⊇ θ (S, t′). On the other hand, the θ (S) ⊆ θ (T ′) = T ′′, and so (T ′′, t′′) ⊆ θ (S, t′). Thus, (T ′′, t′′) ≡ θ (S, t′) = θ ( min(T ′, t′)), and so | min(T ′′, t′′)| =
| min(θ( min(T ′, t′)))| ≤ |θ( min(T ′, t′))| ≤ | min(T ′, t′)|.]
To see that f is well defined, suppose θ (x) = θ (y). We have to show that θ (h(x)) =
θ (h(y)). Consider a terminal chasing sequence of (T ′, t′) using X → A, and (u1, v1), . . . , (un, vn) as the sequence of pairs of tuples used in the sequence, yielding the chase homomorphism θ . Consider the sequence (h(u1), h(v1)), . . . , (h(un), h(vn)). Clearly if X → A can be applied to (u, v), then it can be applied to (h(u), h(v)), unless h(u(A)) = h(v(A)).

Let (h(ui ), h(v )), . . . , (h(u ), h(v )) be the subsequence of these pairs for which X →
1
i1
ik
ik
A can be applied. It can be easily verified that there is a chasing sequence of (h(T ′), t′) using X → A that uses the pairs (h(ui ), h(v )), . . . , (h(u ), h(v )), with chase homo-1
i1
ik
ik
morphism θ ′. Note that for all x′, y′, if θ (x′) = θ (y′) then θ ′(h(x′)) = θ ′(h(y′)). In particular, θ ′(h(x)) = θ ′(h(y)). Because h(T ′) ⊆ T ′, θ ′ is the chase homomorphism of a chasing sequence σ1, . . . , σk of (T ′, t′). Let θ′′ be the chase homomorphism formed from a terminal chasing sequence that extends σ1, . . . , σk. Then θ′′(h(x)) = θ′′(h(y)). Finally, by the uniqueness of the chase homomorphism, θ ′′ = θ , and so θ (h(x)) = θ (h(y)) as desired. This concludes the proof.

It turns out that jd’s behave differently than fd’s with respect to minimization of tableaux. The following shows that the chase using jd’s may yield simpler but also more complicated tableaux.

8.4 The Chase
179
A
B
C
D
A
B
C
D
A
B
C
D
T
w
x
y′
z′
T′
w
x
y
z′
T′′
w′
x
y
z′
w′
x
y
z
w′
x′
y′
z
w
x′
y′
z
w′
x
y′
z
t
w
x
y
z
t′
w
x
y
z
w
x′
y
z′
t′′
w
x
y
z
(a) The tableau query ( T, t)
(b) The tableau query ( T′, t′)
(c) The tableau query
chase( T′, t′, { [ AB, CD]})
Figure 8.4:
Minimization and the chase using jd’s
Example 8.4.10
Consider the tableau query (T , t) shown in Fig. 8.4(a) and the jd σ =⊲⊳
[ AB, BCD]. Clearly (T , t) is minimal, so | min(T , t)| = 2. Next consider chase(T , t, σ ). It is easy to check that w, x, y, z ∈ chase(T , t, σ ), so chase(T , t, σ ) is equivalent to the identity and
| min( chase(T , t, σ ))| = 1.

Next let (T ′, t′) be the tableau query in Fig. 8.4(b) and σ =⊲⊳[AB, CD]. Again (T ′, t′) is minimal. Now chase(T ′, t′, σ ) is represented in Fig. 8.4(c) and is minimal. Thus
| min( chase(T ′, t′, σ ))| = 4 > | min(T ′, t′)|.

Despite the limitations illustrated by the preceding example, the chase in conjunction with tableau minimization provides a powerful optimization technique that yields good results in many cases. This is illustrated by the following example and by Exercise 8.28.

Example 8.4.11
Consider the SPJ expression
q = π AB(π BCD(R) ⊲⊳ π ACD(R)) ⊲⊳ π AD(R), where R is a relation with attributes ABCD. Suppose we wish to optimize the query on databases satisfying the dependencies
F = {B → D, D → C, ⊲⊳[ AB, ACD]}.

The tableau (T , t) corresponding to q is represented in Fig. 8.5(a). Note that (T , t) is minimal. Next we chase (T , t) using the dependencies in F. The chase using the fd’s in F does not change (T , t), which already satisfies them. The chase using the jd
180
Functional and Join Dependency
A
B
C
D
A
B
C
D
T
w′
x
y′
z′
T′′
w′
x
y′
z′
w
x′
y′
z′
w
x′
y′
z
w
x′′
y′′
z
w
x′′
y′
z
t
w
x
y
z
t′′
w
x
y
z
(a) The tableau query
(c) The tableau query
( T, t) corresponding to q
( T′′, t′′) = chase( T′, t′, { B → D, D → C}) A
B
C
D
A
B
C
D
T′
w′
x
y′
z′
T′′′
w′
x
y′
z
w
x′
y′
z′
w
x′
y′
z
w
x′′
y′′
z
t′′′
w
x
y
z
w
x′
y′′
z
w
x′′
y′
z′
t′
w
x
y
z
(b) The tableau query
(d) The tableau query
( T′, t′) = chase( T, t, { [ AB, ACD]}) ( T′′′, t′′′) = min( T′′, t′′) Figure 8.5:
Optimization of SPJ expressions by tableau minimization and the chase
⊲⊳[ AB, ACD] yields the tableau (T ′, t′) in Fig. 8.5(b). Now the fd’s can be applied to (T ′, t ′) yielding the tableau (T ′′, t′′) in Fig. 8.5(c). Finally (T ′′, t′′) is minimized to (T ′′′, t ′′′) in Fig. 8.5(d). Note that (T ′′′, t′′′) satisfies F, so the chase can no longer be applied. The SPJ expression corresponding to (T ′′′, t′′′) is π ABD(π BCD(R) ⊲⊳ π ACD(R)). Thus, the optimization of q resulted in saving one join operation. Note that the new query is not simply a subexpression of the original. In general, the shape of queries can be changed radically by the foregoing procedure.

The Chase and Logical Implication
We consider a natural correspondence between dependency satisfaction and conjunctive query containment. This correspondence uses tableaux to represent dependencies. We will see that the chase provides an alternative point of view to dependency implication.

First consider a jd σ =⊲⊳[X1, . . . , Xn]. It is immediate to see that an instance I satisfies σ iff qσ (I ) ⊆ qid(I ), where
qσ = [X1] ⊲⊳ · · · ⊲⊳ [Xn]
8.4 The Chase
181
and qid is the identity query. Both qσ and qid are PSJR expressions. We can look at alternative formalisms for expressing qσ and qid. For instance, the tableau query of σ is (Tσ , t), where for some t1, . . . , tn,
• t is a free tuple over R with a distinct variable for each coordinate,
• Tσ = {t1, . . . , tn},
• πX (t
(t ) for i ∈ [1, n], and
i
i ) = πXi
• the other coordinates of the ti’s hold distinct variables.

It is again easy to see that qσ = (Tσ , t), so I |= σ iff (Tσ , t)(I ) ⊆ ({t}, t)(I ).

For fd’s, the situation is only slightly more complicated. Consider an fd σ ′ = X → A over U . It is easy to see that I |= σ ′ iff (Tσ′, tσ′)(I ) ⊆ (Tσ′, t′σ′)(I), where X
A
(U − AX)
X
A
(U − AX)
Tσ′
u
x
v1
u
x
v1
u
x′
v2
u
x′
v2
tσ′
x
x′
t ′σ′
x
x
where u, v1, v2 are vectors of distinct variables and x, x′ are distinct variables occurring in none of these vectors. The tableau query of σ ′ is (Tσ′, tσ′).

Again observe that (Tσ′, tσ′), (Tσ , tσ ) can be expressed as PSJR expressions, so fd satisfaction also reduces to containment of PSJR expressions. It will thus be natural to look more generally at all dependencies expressed as containment of PSJR expressions.

In Chapter 10, we will consider the general class of algebraic dependencies based on containment of these expressions.

Returning to the chase, we next use the tableau representation of dependencies to obtain a characterization of logical implication (Exercise 8.29). This result is generalized by Corollary 10.2.3.

Theorem 8.4.12
Let F and {σ } be sets of fd’s and jd’s over relation schema R, let (Tσ , tσ ) be the tableau query of σ , and let T be the tableau in chase(Tσ , tσ , F). Then F |= σ iff
(a) σ = X → A and |πA(T )| = 1, that is, the projection over A of T is a singleton; or
(b) σ = ⊲⊳[X1, . . . , Xn] and tσ ∈ T .

This implies that determining logical implication for jd’s alone, and for fd’s and jd’s taken together, is decidable. On the other hand, tableau techniques are also used to obtain the following complexity results for logical implication of jd’s (see Exercise 8.30).

182
Functional and Join Dependency
Theorem 8.4.13
(a) Testing whether a jd and an fd imply a jd is np-complete.

(b) Testing whether a set of mvd’s implies a jd is np-hard.

Acyclic Join Dependencies
In Section 6.4, a special family of joins called acyclic was introduced and was shown to enjoy a number of desirable properties. We show now a connection between those results, join dependencies, and multivalued dependencies.

A jd ⊲⊳[X1, . . . , Xn] is acyclic if the hypergraph corresponding to [X1, . . . , Xn] is acyclic (as defined in Section 6.4).

Using the chase, we show here that a jd is acyclic iff it is equivalent to a set of mvd’s.

The discussion relies on the notation and techniques developed in the discussion of acyclic joins in Section 6.4.

We shall use the following lemma.

Lemma 8.4.14
Let σ = ⊲⊳X be a jd over U , and let X, Y ⊆ U be disjoint sets. Then the following are equivalent:
(i) σ |= X →
→ Y ;
(ii) there is no Xi ∈ X such that Xi ∩ Y = ∅ and Xi ∩ (U − XY ) = ∅; (iii) Y is a union of connected components of the hypergraph X|U−X.

Proof
Let Z = U − XY . Let τ denote the mvd X →
→ Y , and let (Tτ , tτ ) be the tableau
query corresponding to τ . Let Tτ = {tY , tZ} where tY [XY ] = tτ [XY ] and tZ[XZ] = tτ [XZ]
and distinct variables are used elsewhere in tY and tZ.

We show now that (i) implies (ii). By Theorem 8.4.12, tτ ∈ T = chase(Tτ , tτ , σ ). Let Xi ∈ X. Suppose that t is a new tuple created by an application of σ during the computation of T . Then t[Xi] agrees with t′[Xi] for some already existing tuple. An induction implies that tτ [Xi] = tY [Xi] or tτ [Xi] = tZ[Xi]. Because tY and tZ agree only on X, this implies that Xi cannot intersect with both Y and Z.

That (ii) implies (iii) is immediate. To see that (iii) implies (i), consider an application of the jd ⊲⊳X on Tτ , where Xi ∈ X is associated with tY if Xi − X ⊆ Y , and Xi is associated with tZ otherwise. This builds the tuple tτ , and so by Theorem 8.4.12, σ |=
X →
→ Y .

We now have the following:
Theorem 8.4.15
A jd σ is acyclic iff there is a set F of mvd’s that is equivalent to σ .

Proof
(only if) Suppose that σ =⊲⊳X over U is acyclic. By Theorem 6.4.5, this implies that the output of the GYO algorithm on X is empty. Let X1, . . . , Xn be an enumeration of X in the order of an execution of the GYO algorithm. In particular, Xi is an ear of the hypergraph formed by {Xi+1, . . . , Xn}.

8.4 The Chase
183
For each i ∈ [1, n − 1], let Pi = ∪j∈[1,i]Xj and Qi = ∪j∈[i+1,n]Xj . Let F = {[Pi ∩
Qi] →
→ Qi | i ∈ [1, n − 1]}. By Lemma 8.4.14 and the choice of sequence X1, . . . , Xn, σ |= F. To show that F |= σ , we construct a chasing sequence of (Tσ , tσ ) using F that yields tσ . This chase shall inductively produce a sequence t1, . . . , tn of tuples, such that ti[Pi] = tσ [Pi] for i ∈ [1, n].

We begin by setting t1 to be the tuple of Tσ that corresponds to X1. Then t1[P1] =
tσ [P1] because P1 = X1. More generally, given ti with i ≥ 1, the mvd [Pi ∩ Qi] →
→ Qi on
ti and the tuple corresponding to Xi+1 can be used to construct tuple ti+1 with the desired property. The final tuple tn constructed by this process is tσ , and so F |= σ as desired.

(if) Suppose that σ =⊲⊳X over U is equivalent to the set F of mvd’s but that σ is not acyclic. From the definition of acyclic, this implies that there is some W ⊆ U such that Y = X|W has no articulation pair. Without loss of generality we assume that Y is connected.

Let Y= {Y1, . . . , Ym}. Suppose that s1, . . . are the tuples produced by some chasing sequence of (Tσ , tσ ). We argue by induction that for each k ≥ 1, sk[W ] ∈ πW (Tσ ). Suppose otherwise, and let sk be the first where this does not hold. Suppose that sk is the result of applying an mvd X →
→ Y in F. Without loss of generality we assume that X ∩ Y = ∅.

Let Z = U − XY . Because sk results from X →
→ Y , there are two tuples s′ and s′′ either
in Tσ or already produced, such that sk[XY ] = s′[XY ] and sk[XZ] = s′′[XZ]. Because sk is chosen to be least, there are tuples ti and tj in Tσ , which correspond to Xi and Xj , respectively, such that s′[W ] = ti[W ] and s′′[W ] = tj [W ].

Because ti and tj correspond to Xi and Xj , for each attribute A ∈ U we have ti[A] =
tj [A] iff A ∈ Xi ∩ Xj . Thus X ∩ W ⊆ Xi ∩ Xj .

Because sk[W ] = ti[W ], W − XZ = ∅, and because sk[W ] = tj [W ], W − XY = ∅.

Now, by Lemma 8.4.14, because X →
→ Y is implied by σ , there is no Xk ∈ X such
that Xk ∩ Y = ∅ and Xk ∩ Z = ∅. It follows that Y|W−X is disconnected. Finally, let Y = Xi ∩ W and Y ′ = Xj ∩ W . Because X ∩ W ⊆ Xi ∩ Xj , it follows that Y ∩ Y ′ is an articulation set for Y, a contradiction.

We conclude with a complexity result about acyclic jd’s. The first part follows from the proof of the preceding theorem and the fact that the GYO algorithm runs in polynomial time. The second part, stated without proof, is an interesting converse of the first part.

Proposition 8.4.16
(a) There is a ptime algorithm that, given an acyclic jd σ , produces a set of mvd’s equivalent to σ .

(b) There is a ptime algorithm that, given a set F of mvd’s, finds a jd equivalent to F or determines that there is none.

The Chase Is Church-Rosser
To conclude this section, we provide the proof that the results of all terminal chasing sequences of a tableau query q by a set F of fd’s and jd’s are identical. To this end, we first introduce tools to describe correspondences between the free tuples occurring in the different elements of chasing sequences.

184
Functional and Join Dependency
Let (T , t) = (T0, t0), . . . , (Tn, tn) be a chasing sequence of (T , t) by F. Then for each i ∈ [1, n], the chase homomorphism for step i, denoted θi, is an assignment with domain var(Ti) defined as follows:
(a) If (Ti+1, ti+1) is the result of applying the fd rule to (Ti, ti), which replaces all occurrences of variable y by variable x, then θi+1 is defined so that θi+1(y) = x and θi+1 is the identity on var(Ti) − {y}.

(b) If (Ti+1, ti+1) is the result of applying the jd rule to (Ti, ti), then θi+1 is the identity on var(Ti).

The chase homomorphism of this chasing sequence is θ = θ1 ◦ · · · ◦ θn. If w ∈ (T ∪ {t}), then the tuple corresponding to w in (Ti, ti) is wi = θ1 ◦ · · · ◦ θi(w). It may arise that ui = vi for distinct tuples u, v in T . Observe that θ1 ◦ · · · ◦ θi(T ) ⊆ Ti and that, because of the jd rule, the inclusion may be strict.

We now have the following:
Lemma 8.4.17
Suppose that I |= F, ν is a substitution over var(T ), ν(T ) ⊆ I , and (T0, t0), . . . , (Tn, tn) is a chasing sequence of (T , t) by F. Then ν(wi) = ν(w) for each i ∈ [1, n] and each w ∈ (T ∪ {t}),
and ν(Ti) ⊆ I for each i ∈ [1, n].

Crux
Use an induction on the chasing sequence (Exercise 8.24d).

Observe that this also holds if I is a tableau over R that satisfies F. This is used in the following result.

Theorem 8.4.18
Let (T , t) be a tableau query over R and F a set of fd’s and jd’s over R. Then the results of all terminal chasing sequences of (T , t) by F are identical.

Proof
Let (T ′, t′) and (T ′′, t′′) be the results of two terminal chasing sequences on (T , t) using F, and let θ ′, θ ′′ be the chase homomorphisms of these chasing sequences. For each tuple w ∈ T , let w′ denote the tuple of T ′ that corresponds to w, and similarly for w′′, T ′′.

By construction, θ ′′(T ) ⊆ T ′′ and θ ′′(t) = t′′. Because T ′′ |= F and θ ′′(T ) ⊆ T ′′, θ ′′(T ′) ⊆ T ′′ by Lemma 8.4.17 considering the chasing sequence leading to T ′. The same argument shows that θ ′′(w′) = w′′ for each w in T and θ ′′(t′) = t′′. By symmetry, θ ′(T ′′) ⊆ T ′, θ ′(w′′) = w′ for each w in T and θ ′(t′′) = t′.

We next prove that
(*)
θ ′′ is an isomorphism from (T ′, t′) to (T ′′, t′′).

Let w′′ be in T ′′ for some w in T . Then
θ ′ ◦ θ ′′(w′′) = θ ′′(θ ′(w′′)) = θ ′′(w′) = w′′.

Bibliographic Notes
185
Observe that each variable x in var(T ′′) occurs in w′′, for some w in T . Thus θ ′ ◦ θ ′′ is the identity over var(T ′′). We therefore have
θ ′ ◦ θ ′′(T ′′) = T ′′.

By symmetry, θ ′′ ◦ θ ′ is the identity over var(T ′) and
θ ′′ ◦ θ ′(T ′) = T ′.

Thus |T ′′| = |T ′|. Because θ ′′(T ′) ⊆ T ′′, θ ′′(T ′) = T ′′ and θ ′′ is an isomorphism from (T ′, t ′) to (T ′′, t′′), so (*) holds.

To conclude, we prove that
(**)
θ ′′ is the identity over var(T ′).

We first show that for each pair x, y of variables occurring in T , (†)
θ ′′(x) = θ ′′(y) iff θ ′(x) = θ ′(y).

Suppose that θ ′′(x) = θ ′′(y). Then for some tuples u, v ∈ T and attributes A, B, we have u(A) = x, v(B) = y and u′′(A) = θ ′′(x) = θ ′′(y) = v′′(B). Next θ ′(x) = u′(A) and θ ′(y) = v′(B). Because θ ′ is an isomorphism from (T ′′, t′′) to (T ′, t′) and θ ′(u′′) =
u′, θ ′(v′′) = v′, it follows that u′(A) = v′(B). Hence θ ′(x) = u′(A) = v′(B) = θ ′(y) as desired. The if direction follows by symmetry.

Now let x ∈ var(T ′). To prove (**) and the theorem, it now suffices to show that θ ′′(x) = x. Let
A′ = {y ∈ var(T ) | θ ′(y) = θ ′(x)},
A′′ = {y ∈ var(T ) | θ ′′(y) = θ ′′(x)}.

First (†) implies that A′ = A′′. Furthermore, an induction on the chasing sequence for (T ′, t′) shows that for each z ∈ A′, θ ′(z) is the least (under the ordering on var) element of A′, and similarly for (T ′′, t′′). Thus θ ′ and θ ′′ map all elements of A′ and A′′ to the same variable z. Because x ∈ var(T ′), it follows that z = x so, in particular, θ ′(x) =
θ ′′(x) = x.

Bibliographic Notes
On a general note, we first mention that comprehensive presentations of dependency theory can be found in [Var87, FV86]. A more dense presentation is provided in [Kan91].

Dependency theory is also the topic of the book [Tha91].

Research on general integrity constraints considered from the perspective of first-order logic is presented in [GM78]. Other early work in this framework includes [Nic78], which observes that fd’s and mvd’s have a natural representation in logic, and [Nic82], which
186
Functional and Join Dependency
considers incremental maintanence of integrity constraints under updates to the underlying state.

Functional dependencies were introduced by Codd [Cod72b]. The axiomatization is due to [Arm74]. The problem of implication is studied in [BB79, Mai80]. Several alternative formulations of fd implication, including formulation in terms of the propositional calculus perspective (see Exercise 8.22), are mentioned in [Kan91]; they are due to [SDPF81, CK85, CKS86].

Armstrong relations were introduced and studied in [Fag82b, Fag82a, BDFS84]. Interesting practical applications of Armstrong relations are proposed in [SM81, MR85]. The idea is that, given a set F of fd’s, the system presents an Armstrong relation for F with natural column entries to a user, who can then determine whether F includes all of the desired restrictions.

The structure of families of instances specified by a set of fd’s is studied in [GZ82, Hul84].

Multivalued dependencies were discovered independently in [Zan76, Fag77b, Del78].

They were generalized in [Ris77, Nic78, ABU79]. The axiomatization of fd’s and mvd’s is from [BFH77]. A probabilistic view of mvd’s in terms of conditional independence is presented in [PV88, Pea88]. This provides an alternative motivation for the study of such dependencies.

The issue of whether there is an axiomatization for jd’s has a lengthy history. As will be detailed in Chapter 10, the family of full typed dependencies subsumes the family of jd’s, and an axiomatization for these was presented in [BV84a, YP82]; see also [SU82].

More focused axiomatizations, which start with jd’s and end with jd’s but use slightly more general dependencies at intermediate stages, are presented in [Sci82] and [BV85]; see also
[BV81b]. Reference [BV85] also develops an axiomatization for join dependencies based on Gentzen-style proofs (see, e.g., [Kle67]); proofs in this framework maintain a form of scratch paper in addition to a sequence of inferred sentences. Finally, [Pet89] settled the issue by establishing that there is no axiomatization (in the sense defined in Section 8.2) for the family of jd’s.

As noted in Chapter 6, acyclic joins received wide interest in the late 1970s and early 1980s so Theorem 8.4.15 was demonstrated in [FMU82]. Proposition 8.4.16 is from
[GT83].

An ancestor to the chase can be found in [ABU79]. The notion of chase was articulated in [MMS79]. Related results can be found in [MSY81, Var83]. The relationship between the chase
and both tableau queries and logical implication was originally presented in
[MMS79] and builds on ideas originally introduced in [ASU79b, ASU79a]. The chase technique is extended to more general dependencies in [BV84c]; see also Chapter 10.

The connection between the chase and the more general theorem-proving technique of resolution with paramodulation (see [CL73]) is observed and analyzed in [BV80b]. The chase technique is applied to datalog programs in [RSUV89, RSUV93].

Exercises
Exercise 8.1
Describe the set of fd’s, mvd’s, and jd’s that are tautologies (i.e., dependencies that are satisfied by all instances) for a relation schema R.

Exercises
187
Exercise 8.2
Let F1 be as in Example 8.2.4. Prove that F1 |= AD → E and F1 |= CDE → C.

Exercise 8.3
Let U be a set of attributes, and let F, Ŵ be sets of dependencies over U . Show that
(a) F ⊆ F∗.

(b) (F∗)∗ = F∗.

(c) If Ŵ ⊆ F, then Ŵ∗ ⊆ F∗.

State and prove analogous results for fd closures of attribute sets.

Exercise 8.4
Prove Lemma 8.2.6.

Exercise 8.5
Let U be a set of attributes and F a set of fd’s over U . Prove the soundness of FD1, FD2, FD3 and show that
If F ⊢ X → Y and F ⊢ X → Z, then F ⊢ X → Y Z.

Exercise 8.6
Let F be a set of fd’s over U .

(a) Suppose that X ⊆ U and U ⊆ V . Show that (X, F)∗,U = (X, F)∗,V . Hint: Use the proof of Proposition 8.2.8.

(b) Suppose that XY ⊆ U , and U ⊆ V . Show that F |=U X → Y iff F |=V X → Y .

♠ Exercise 8.7 [BB79] Describe how to improve the efficiency of Algorithm 8.2.7 to linear time.

Hint: For each unused fd W → Z in F, record the number attributes of W not yet in closure.

To do this efficiently, maintain a list for each attribute A of those unused fd’s of F for which A occurs in the left-hand side.

Exercise 8.8
Give a proof of AB → F from F = {AB → C, A → D, CD → EF } using
{FD1, FD2, FD3}.

Exercise 8.9
Prove or disprove the soundness of the following rules:
FD4: (pseudo-transitivity) If X → Y and Y W → Z, then XW → Z.

FD5: (union) If X → Y and X → Z, then X → Y Z.

FD6: (decomposition) If X → Y Z, then X → Y .

MVD4: (pseudo-transitivity) If X →
→ Y and Y W →
→ Z, then XW →
→ Z − Y .

MVD5: (union) If X →
→ Y and X →
→ Z, then X →
→ Y Z.

MVD6: (decomposition) If X →
→ Y and X →
→ Z, then X →
→ Y ∩ Z, X →
→ Y − Z, and
X →
→ Z − Y .

bad-FD1: If XW → Y and XY → Z, then X → (Z − W ).

bad-MVD1: If X →
→ Y and Y →
→ Z, then X →
→ Z.

bad-FMVD1: If X →
→ Y and XY → Z, then X → Z.

(The use of the hint is optional.)

Exercise 8.10
Continuing with Exercise 8.9,
(a) [BFH77] Find a two-element subset of {FD1, FD2, FD3, FD4, FD5, FD6} that is sound and complete for inferring logical implication of fd’s.

188
Functional and Join Dependency
(b) Prove that there is exactly one two-element subset of {FD1, FD2, FD3, FD4, FD5, FD6} that is sound and complete for inferring logical implication of fd’s.

Exercise 8.11
[Arm74] Let U be a fixed set of attributes. An attribute set X ⊆ U is saturated with respect to a set F of fd’s over U if X = X∗. The family of saturated sets of F with respect to U is satset(F) = {X ⊆ U | X is saturated with respect to F}.

(a) Show that satset = satset(F) satisfies the following properties: S1: U ∈ satset.

S2: If Y ∈ satset and Z ∈ satset, then Y ∩ Z ∈ satset.

⋆ (b) Suppose that satset is a family of subsets of U satisfying properties (S1) and (S2).

Prove that satset = satset(Ŵ) for some set Ŵ of fd’s over U . Hint: Use Ŵ = {Y → Z|
for each X ∈ satset, if Y ⊆ X then Z ⊆ X}.

Exercise 8.12
Let F and Ŵ be sets of fd’s over U . Using the notation of Exercise 8.11, (a) Show that satset(F ∪ Ŵ) = satset(F) ∩ satset(Ŵ).

(b) Show that satset(F∗ ∩ Ŵ∗) = satset(F) ∧ satset(Ŵ), where for families F , G, the wedge of F and G is F ∧ G = {X ∩ Y | X ∈ F and Y ∈ G}.

(c) For V ⊆ U , define πV F = {X → Y ∈ F | XY ⊆ V }. For V ⊆ U characterize satset (πV (F∗)) (where this family is defined with respect to V ).

Exercise 8.13
(a) Exhibit a set F1 of fd’s over {A, B} such that each Armstrong relation for F has at least three distinct values occurring in the A column. Exhibit a set F2 of fd’s over
{A, B, C} such that each Armstrong relation for F has at least four distinct values occurring in the A column.

(b) [GH83, BDFS84] Let F be a set of fd’s over U . Recall the notion of saturated set from Exercise 8.11. For an instance I over U , the agreement set of I is agset(I ) =
{X ⊆ U | ∃ s, t ∈ I such that s(A) = t (A) iff A ∈ X}. For a family F of subsets of U , the intersection closure of F is intclo(F ) = {∩n X
i=1
i | n ≥ 0 and each Xi ∈ F }
(where the empty intersection is defined to be U ). Prove that I is an Armstrong relation for F iff intclo( agset(I )) = satset(F).

Exercise 8.14
[Mai80] Let F be a set of fd’s over U , X → Y ∈ F, and let A be an attribute.

A is extraneous in X → Y with respect to F if either
(a) (F − {X → Y }) ∪ {X → (Y − A)} |= X → Y ; or
(b) (F − {X → Y }) ∪ {(X − A) → Y } |= X → Y .

Develop an O(n2) algorithm that takes as input a set F of fd’s and produces as output a set F′ ≡ F, where F′ has no extraneous attributes.

Exercise 8.15
Show that there is no set F of jd’s and fd X → A such that F |= X → A. Hint: Show that for any instance I there exists an instance I ′ such that I ⊆ I ′ and I ′ |= F. Then choose I violating X → A.

Exercise 8.16
[Fag77b, Zan76] This exercise refers to the original definition of mvd’s. Let U
be a set of attributes and X, Y ⊆ U . Given an instance I over U and a tuple x ∈ πX(I ), the image
Exercises
189
of x on Y in I is the set image Y (x, I ) = πY (σX=x(I )) of tuples over Y . Prove that I |= X →
→ Y
iff
for each x ∈ πX(I ) and each z ∈ image Z(x, I ), image Y (x, I ) = image Y (xz, I ), where Z = U − XY and xz denotes the tuple w over XZ such that πX(w) = x and πZ(w) = z.

⋆ Exercise 8.17 [BFH77] Complete the proof of Theorem 8.3.5. Hint: Of course, the inference rules can be used when reasoning about I . The following claims are also useful: Claim 1: If A ∈ X+, then I |= ∅ → A.

Claim 2: If A, B ∈ Wi for some i ∈ [1, n], then I |= A → B.

Claim 3: For each i ∈ [1, n], I |= ∅ →
→ Wi.

Exercise 8.18
Prove Corollary 8.3.6.

Exercise 8.19
[Kan91] Consider the following set of inference rules:
MVD7: X →
→ U − X.

MVD8: If Y ∩ Z = ∅, X →
→ Y , and Z →
→ W , then X →
→ W − Y .

FMVD3: If Y ∩ Z = ∅, X →
→ Y , and Z → W , then X → Y ∩ W .

Prove that {MVD7, MVD2, MVD8} are sound and complete for inferring implication for mvd’s, and that {FD1, FD2, FD3, MVD7, MVD2, MVD8, FMVD1, FMVD3} are sound and complete for inferring implication for fd’s and mvd’s considered together.

Exercise 8.20
[Bee80] Let F be a set of fd’s and mvd’s, and let m(F) = {X →
→ Y | X →
→
Y ∈ F} ∪ {X →
→ A | A ∈ Y for some X → Y ∈ F}. Prove that
(a) F |= X → Y implies m(F) |= X →
→ Y ; and
(b) F |= X →
→ Y iff m(F) |= X →
→ Y .

Hint: For (b) do an induction on proofs using the inference rules.

Exercise 8.21
For sets F and Ŵ of dependencies over U , F implies Ŵ for two-element instances, denoted F |=2 Ŵ, if for each instance I over U with |I | ≤ 2, I |= F implies I |= Ŵ.

(a) [SDPF81] Prove that if F ∪ {σ } is a set of fd’s and mvd’s, then F |=2 σ iff F |= σ .

(b) Prove that the equivalence of part (a) does not hold if jd’s are included.

(c) Exhibit a jd σ such that there is no set F of mvd’s with σ ≡ F.

♠ Exercise 8.22 [SDPF81] This exercise develops a close connection between fd’s and mvd’s, on the one hand, and a fragment of propositional logic, on the other. Let U be a fixed set of attributes. We view each attribute A ∈ U as a propositional variable. For the purposes of this exercise, a truth assignment is a mapping ξ : U → {T , F } (where T denotes true and F denotes false). Truth assignments are extended to mappings on subsets X of U by ξ(X) = ∧A∈Xξ(A). A truth assignment ξ satisfies an fd X → Y , denoted ξ |= X → Y , if ξ(X) = T implies ξ(Y ) = T .

It satisfies an mvd X →
→ Y , denoted ξ |= X →
→ Y , if ξ(X) = T implies that either ξ(Y ) = T
or ξ(U − Y ) = T . Given a set F ∪ {σ } of fd’s and mvd’s, F implies σ in the propositional calculus, denoted F |=prop σ , if for each truth assignment ξ , ξ |= F implies ξ |= σ . Prove that for all sets F ∪ {σ } of fd’s and mvd’s, F |= σ iff F |=prop σ .

190
Functional and Join Dependency
⋆ Exercise 8.23 [Bis80] Exhibit a set of inference rules for mvd’s that are sound and complete in the context in which an underlying set of attributes is not fixed.

♠ Exercise 8.24
(a) Prove Proposition 8.4.2.

(b) Prove Lemma 8.4.3.

(c) Prove Lemma 8.4.4. What is the maximum size attainable by the tableau in the result of a terminal chasing sequence?

(d) Prove Lemma 8.4.17.

♠ Exercise 8.25
(a) Describe a polynomial time algorithm for computing the chase of a tableau query by F, assuming that F contains only fd’s.

(b) Show that the problem of deciding whether a jd can be applied to a tableau query is np-complete if the schema is considered variable, and polynomial if the schema is considered fixed. Hint: Use Exercise 6.16.

(c) Prove that it is np-hard, given a tableau query (T , t) and a set F of fd’s and jd’s, to compute chase(T , t, F) (this assumes that the schema is part of the input and thus not fixed).

(d) Describe an exponential time algorithm for computing the chase by a set of fd’s and jd’s. (Again the schema is not considered fixed.)

Exercise 8.26
Prove Proposition 8.4.6. Hint: Rather than modifying the proof of Theorem 8.4.18, prove as a lemma that if F |= σ , then chase(T , t, F) = chase(T , t, F ∪ {σ }).

Exercise 8.27
(a) Verify that the results concerning the chase generalize immediately to the context in which database schemas as opposed to relation schemas are used.

(b) Describe how to generalize the chase to tableau in which constants occur, and state and prove the results about the chase and tableau queries. Hint: If the chase procedure attempts to equate two distinct constants (a situation not occurring before), we obtain a particular new tableau, called T false, which corresponds to the query producing an empty result on all input instances.

Exercise 8.28
For each of the following relation schemas R, SPJ expressions q over R, and dependencies F over R, simplify q knowing that it is applied only to instances over R satisfying F. Use tableau minimization and the chase.

(a) sort(R) = ABC, q = π AC(π AB(σA=2(R) ⊲⊳ π BC(R)) ⊲⊳ π AB(σB=8(R) ⊲⊳ π BC(R)), F = {A → C, B → C}
(b) sort(R) = ABCD, q = π BC(R) ⊲⊳ π ABD(R), F = {B →
→ CD, B →
→ D}
(c) sort(R) = ABCD, q = π ABD(R) ⊲⊳ π AC(R), F = {A → B, B →
→ C}.

♠ Exercise 8.29 Prove Theorem 8.4.12.

♠ Exercise 8.30 Prove Theorem 8.4.13(a) [BV80a] and Theorem 8.4.13(b) [FT83].

Exercise 8.31
[MMS79] Describe an algorithm based on the chase for
(a) computing the closure of an attribute set X under a set F of fd’s and jd’s (where the notion of closure is extended to include all fd’s implied by F); and
Exercises
191
(b) computing the dependency basis (see Section 8.3) of a set X of attributes under a set F of fd’s and jd’s (where the notion of dependency basis is extended to include fd’s in the natural manner).

Exercise 8.32
[GH86] Suppose that the underlying domain dom has a total order ≤. Let U = {A1, . . . , An} be a set of attributes. For each X ⊆ U , define the partial order ≤X over the set of tuples of X by t ≤X t′ iff t (A) ≤ t′(A) for each A ∈ X. A sort set dependency (SSD) over U is an expression of the form s(X), where X ⊆ U . An instance I over U satisfies s(X), denoted I |= s(X), if ≤X is a total order on πX(I ).

(a) Show that the following set of inference rules is sound and complete for finite logical implication between SSDs:
SSD1: If A is an attribute, then s(A).

SSD2: If s(X) and Y ⊆ X, then s(Y ).

SSD3: If s(X), s(Y ) and s(X △ Y ), then s(XY ) [where X △ Y denotes (X −
Y ) ∪ (Y − X), i.e., the symmetric difference of X and Y ].

(b) Exhibit a polynomial time algorithm for inferring logical implication between sets of SSDs.

(c) Describe how SSDs might be used in connection with indexes.

9 InclusionDependency
Vittorio:
Fd’s and jd’s give some structure to relations.

Alice:
But there are no connections between them.

Sergio:
Making connections is the next step . . .

Riccardo:
. . . with some unexpected consequences.

The story of inclusion dependencies starts in a manner similar to that for functional dependencies: Implication is decidable (although here it is pspace-complete), and there is a simple set of inference rules that is sound and complete. But the story becomes much more intriguing when functional and inclusion dependencies are taken together.

First, the notion of logical implication will have to be refined because the behavior of these dependencies taken together is different depending on whether infinite instances are permitted. Second, both notions of logical implication are nonrecursive. And third, it can be proven in a formal sense that no “finite” axiomatization exists for either notion of logical implication of the dependencies taken together. At the end of this chapter, two restricted classes of inclusion dependencies are discussed. These are significant because they arise in modeling certain natural relationships such as those encountered in semantic data models.

Positive results have been obtained for inclusion dependencies from these restricted classes considered with fd’s and other dependencies.

Unlike fd’s or jd’s, a single inclusion dependency may refer to more than one relation.

Also unlike fd’s and jd’s, inclusion dependencies are “untyped” in the sense that they may call for the comparison of values from columns (of the same or different relations) that are labeled by different attributes. A final important difference from fd’s and jd’s is that inclusion dependencies are “embedded.” Speaking intuitively, to satisfy an inclusion dependency the presence of one tuple in an instance may call for the presence of another tuple, of which only some coordinate values are determined by the dependency and the first tuple. These and other differences will be discussed further in Chapter 10.

9.1
Inclusion Dependency in Isolation
To accommodate the fact that inclusion dependencies permit the comparison of values from different columns of one or more relations, we introduce the following notation. Let R be a relation schema and X = A1, . . . , An a sequence of attributes (possibly with repeats) from R. For an instance I of R, the projection of I onto the sequence X, denoted I [X], is the n-ary relation {t (A1), . . . , t (An) | t ∈ I }.

The syntax and semantics of inclusion dependencies is now given by the following: 192
9.1 Inclusion Dependency in Isolation
193
Definition 9.1.1
Let R be a relational schema. An inclusion dependency (ind) over R
is an expression of the form σ = R[A1, . . . , Am] ⊆ S[B1, . . . , Bm], where (a) R, S are (possibly identical) relation names in R,
(b) A1, . . . , Am is a sequence of distinct attributes of sort(R), and (c) B1, . . . , Bm is a sequence of distinct attributes of sort(S).

An instance I of R satisfies σ , denoted I |= σ , if I(R)[A1, . . . , Am] ⊆ I(S)[B1, . . . , Bm].

Satisfaction of a set of ind’s is defined in the natural manner.

To illustrate this definition, we recall an example from the previous chapter.

Example 9.1.2
There are two relations: Movies with attributes Title, Director, Actor and Showings with Theater, Screen, Title, Snack; and we have an ind Showings[ Title] ⊆ Movies[ Title].

The generalization of ind’s to permit repeated attributes on the left-or right-hand side is considered in Exercise 9.4.

The notion of logical implication between sets of ind’s is defined in analogy with that for fd’s. (This will be refined later when fd’s and ind’s are considered together.) Rules for Inferring ind Implication
The following set of inference rules will be shown sound and complete for inferring logical implication between sets of ind’s. The variables X, Y , and Z range over sequences of distinct attributes; and R, S, and T range over relation names.

IND1: (reflexivity) R[X] ⊆ R[X].

IND2: (projection and permutation) If R[A1, . . . , Am] ⊆ S[B1, . . . , Bm], then R[Ai , 1
. . . , Ai ] ⊆ S[B , . . . , B ] for each sequence i
k
i1
ik
1, . . . , ik of distinct integers in
{1, . . . , m}.

IND3: (transitivity) If R[X] ⊆ S[Y ] and S[Y ] ⊆ T [Z], then R[X] ⊆ T [Z].

The notions of proof and of provability (denoted ⊢) using these rules are defined in analogy with that for fd’s.

Theorem 9.1.3
The set {IND1, IND2, IND3} is sound and complete for logical impli-
cation of ind’s.

Proof
Soundness of the rules is easily verified. For completeness, let F be a set of ind’s over database schema R = {R1, . . . , Rn}, and let σ = Ra[A1, . . . , Am] ⊆ Rb[B1, . . . , Bm]
194
Inclusion Dependency
be an ind over R such that F |= σ . We construct an instance I of R and use it to demonstrate that F ⊢ σ .

To begin, let s′ be the tuple over Ra such that s′(Ai) = i for i ∈ [1, m] and s′(B) = 0
otherwise. Set I(Ra) = {s′} and I(Rj ) = ∅ for j = a. We now apply the following rule to I until it can no longer be applied.

If Ri[C1, . . . , Ck] ⊆ Rj [D1, . . . , Dk] ∈ F and t ∈ I(Ri), then add (∗)
u to I(Rj ), where u(Dl) = t (Cl) for l ∈ [1, k] and u(D) = 0 for D
∈ {D1, . . . , Dk}.

Application of this rule will surely terminate, because all tuples are constructed from a set of at most m + 1 values. Clearly the result of applying this rule until termination is unique, so let J be this result.

Remark 9.1.4
This construction is reminiscent of the chase for join dependencies. It differs because the ind’s may be embedded. Intuitively, an ind may not specify all the entries of the tuples we are adding. In the preceding rule (∗), the same value (0) is always used for tuple entries that are otherwise unspecified.

It is easily seen that J |= F. Because F |= σ , we have J |= σ . To conclude the proof, we show the following:
If for some Rj in R, u ∈ J(Rj ), integer q, and distinct attributes (∗∗)
C1, . . . , Cq in sort(Rj ), u(Cp) > 0 for p ∈ [1, q], then F ⊢ Ra[Au(C1), . . . , Au(Cq)] ⊆ Rj[C1, . . . , Cq].

Suppose that (∗∗) holds. Let s′′ be a tuple of J(Rb) such that s′′[B1, . . . , Bm] =
s′[A1, . . . , Am]. (Such a tuple exists because J |= σ .) Use (∗∗) with Rj = Rb, q = m, C1, . . . , Cq = B1, . . . , Bm.

To demonstrate (∗∗), we show inductively that it holds for all tuples of J by considering them in the order in which they were inserted. The claim holds for s in J(Ra) by IND1.

Suppose now that
• I′ is the instance obtained after k applications of the rule for some k ≥ 0;
• the claim holds for all tuples in I′; and
• u is added to Rj by the next application of rule (∗), due to the ind Ri[C1, . . . , Ck] ⊆
Rj [D1, . . . , Dk] ∈ F and tuple t ∈ I′(Ri).

Now let {E1, . . . , Eq} be a set of distinct attributes in sort(Rj ) with u(Ep) > 0 for p ∈
[1, q]. By the construction of u in (*), {E1, . . . , Eq} ⊆ {D1, . . . , Dk}. Choose the mapping ρ such that Dρ(p) = Ep for p ∈ [1, q]. Because Ri[C1, . . . , Ck] ⊆ Rj [D1, . . . , Dk] ∈ F, IND2 yields
F ⊢ Ri[Cρ(1), . . . , Cρ(q)] ⊆ Rj [E1, . . . , Eq].

9.1 Inclusion Dependency in Isolation
195
By the inductive assumption,
F ⊢ Ra[At(Cρ(1)), . . . , At(Cρ(q))] ⊆ Ri[Cρ(1), . . . , Cρ(q)].

Thus, by IND3,
F ⊢ Ra[At(Cρ(1)), . . . , At(Cρ(q))] ⊆ Rj[E1, . . . , Eq].

Finally, observe that for each p, t (Cρ(p)) = u(Dρ(p)) = u(Ep), so
F ⊢ Ra[Au(E1), . . . , Au(Eq)] ⊆ Rj[E1, . . . , Eq].

Deciding Logical Implication for ind’s
The proof of Theorem 9.1.3 yields a decision procedure for determining logical implication between ind’s. To see this, we use the following result:
Proposition 9.1.5
Let F be a set of ind’s over R and Ra[A1, . . . , Am] ⊆ Rb[B1, . . . , Bm]. Then F |= Ra[A1, . . . , Am] ⊆ Rb[B1, . . . , Bm] iff there is a sequence Ri [
C
1
1], . . . ,
Ri [
C
k
k] such that
(a) Ri ∈ R for j ∈ [1, k];
j
(b)
Cj is a sequence of m distinct attributes in sort(Ri ) for j ∈ [1, k]; j
(c) Ri [
C
1
1] = Ra[A1, . . . , Am];
(d) Ri [
C
k
k] = Rb[B1, . . . , Bm];
(e) Ri [
C
[
C
j
j ] ⊆ Rij+1
j +1] can be obtained from an ind in F by one application of
rule IND2, for j ∈ [1, (k − 1)].

Crux
Use the instance J constructed in the proof of Theorem 9.1.3. Working backward from the tuple s′′ in J(Rb), a chain of relation-tuple pairs (Ri , s j
j ) can be constructed so
that each of 1, . . . , m occurs exactly once in sj , and sj+1 is inserted into I as a result of sj and IND2.

Based on this, it is straightforward to verify that the following algorithm determines logical implication between ind’s. Note that only ind’s of arity m are considered in the algorithm.

Algorithm 9.1.6
Input: A set F of ind’s over R and ind Ra[A1, . . . , Am] ⊆ Rb[B1, . . . , Bm].

Output: Determine whether F |= Ra[A1, . . . , Am] ⊆ Rb[B1, . . . , Bm].

Procedure: Build a set E of expressions of the form Ri[C1, . . . , Cm] as follows: 1. E := {Ra(A1, . . . , Am)}.

196
Inclusion Dependency
2. Repeat until Rb[B1, . . . , Bm] ∈ E or no change possible:
If Ri[C1, . . . , Cm] ∈ E and
Ri[C1, . . . , Cm] ⊆ Rj [D1, . . . , Dm]
can be derived from an ind of F by one application of IND2, then insert Rj [D1, . . . , Dm] into E.

3. If Rb[B1, . . . , Bm] ∈ E then return yes; else return no.

As presented, the preceding algorithm is nondeterministic and might therefore take more than polynomial time. The following result shows that this is indeed likely for any algorithm for deciding implication between ind’s.

Theorem 9.1.7
Deciding logical implication for ind’s is pspace-complete.

Crux
Algorithm 9.1.6 can be used to develop a nondeterministic polynomial space procedure for deciding logical implication between ind’s. By Savitch’s theorem (which states that pspace = npspace), this can be transformed into a deterministic algorithm that runs in polynomial space. To show that the problem is pspace-hard, we describe a reduction from the problem of linear space acceptance.

A (Turing) machine is linear bounded if on each input of size n, the machine does not use more that n tape cells. The problem is the following:
Linear Space Acceptance (LSA) problem
Input: The description of a linear bounded machine M and an input word x; Output: yes iff M accepts x.

The heart of the proof is, given an instance (M, x) of the LSA problem, to construct a set F of ind’s and an ind σ such that F |= σ iff x is accepted by M.

Let M = (K, Ŵ, K, s, h) be a Turing machine with states K, alphabet Ŵ, transition relation K, start state s, and accepting state h; and let x = x1 . . . xn ∈ Ŵ∗ have length n.

Configurations of M are viewed as elements of Ŵ∗KŴ+ with length n + 1, where the placement of the state indicates the head position (the state is listed immediately left of the scanned letter). Observe that transitions can be described by expressions of the form α1, α2, α3 → β1, β2, β3 with α1, . . . , β3 in (K ∪ Ŵ). For instance, the transition
“if reading b in state p, then overwrite with c and move left”
corresponds to a, p, b → p, a, c for each a in Ŵ. Let χ be the set of all such expressions corresponding to transitions of M.

The initial configuration is sx. The final configuration is h bn for some particular letter b, iff M accepts x.

The ind’s of F are defined over a single relation R. The attributes of R are {Ai,j | i ∈
(K ∪ Ŵ), j ∈ {1, 2, . . . , n + 1}} . The intuition here is that the attribute Ap,j corresponds to the statement that the j th symbol in a given configuration is p. To simplify the presentation, attribute Aa,k is simply denoted by the pair (a, k).

9.2 Finite versus Infinite Implication
197
The ind σ is
R[(s, 1), (x1, 2), . . . , (xn, n + 1)] ⊆ R[(h, 1), ( b, 2), . . . , ( b, n + 1)].

The ind’s in F correspond to valid moves of M. In particular, for each j ∈ [1, n − 1], F
includes all ind’s of the form
R[(α1, j ), (α2, j + 1), (α3, j + 2),
A ] ⊆ R[(β1, j ), (β2, j + 1), (β3, j + 2),
A ],
where α1, α2, α3 → β1, β2, β3 is in χ, and
A is an arbitrary fixed sequence that lists all
of the attributes in Ŵ × {1, . . . , j − 1, j + 3, . . . , n + 1}. Thus each ind in F has arity 3 + (n − 2)|Ŵ|, and |F| ≤ n|K|.

Although the choice of
A permits the introduction of many ind’s, observe that the
construction is still polynomial in the size of the linear space automaton problem (M, x).

Using Proposition 9.1.5, it is now straightforward to verify that F |= σ iff M has an accepting computation of x.

Although the general problem of deciding implication for ind’s is pspace-complete, naturally arising special cases of the problem have polynomial time solutions. This includes the family of ind’s that are at most k-ary (ones in which the sequences of attributes have length at most some fixed k) and ind’s that have the form R[
A ] ⊆ S[
A ] (see
Exercise 9.10). The latter case arises in examples such as Grad − Stud[ Name, Major] ⊆
Student[ Name, Major]. This theme is also examined at the end of this chapter.

9.2
Finite versus Infinite Implication
We now turn to the interaction between ind’s and fd’s, which leads to three interesting phenomena. The first of these requires a closer look at the notion of logical implication.

Consider the notion of logical implication used until now: F logically implies σ if for all relation (or database) instances I, I |= F implies I |= σ . Although this notion is close to the corresponding notion of mathematical logic, it is different in a crucial way: In the context of databases considered until now, only finite instances are considered. From the point of view of logic, the study of logical implication conducted so far lies within finite model theory.

It is also interesting to consider logical implication in the traditional mathematical logic framework in which infinite database instances are permitted. As will be seen shortly, when fd’s or ind’s are considered separately, permitting infinite instances has no impact on logical implication. However, when fd’s and ind’s are taken together, the two flavors of logical implication do not coincide.

The notion of infinite relation and database instances is defined in the natural manner.

An unrestricted relation (database) instance is a relation (database) instance that is either finite or infinite. Based on this, we now redefine “unrestricted implication” to permit infinite instances, and we define “finite logical implication” for the case in which only finite instances are considered.

198
Inclusion Dependency
R
A
B
R
A
B
1
0
1
1
2
1
2
1
3
2
3
2
4
3
4
3
..

.

.

.

.

..

..

..

(a)
(b)
Figure 9.1:
Instances used for distinguishing |=fin and |=unr
Definition 9.2.1
A set F of dependencies over R implies without restriction a dependency σ , denoted F |=unr σ , if for each unrestricted instance I of R, I |= F implies I |= σ .

A set F of dependencies over R finitely implies a dependency σ , denoted F |=fin σ , if for each (finite) instance I of R, I |= F implies I |= σ .

If finite and unrestricted implication coincide, or if the kind of implication is understood from the context, then we may use |= rather than |=fin or |=unr. This is what we implicitly did so far by using |= in place of |=fin.

Of course, if F |=unr σ , then F |=fin σ . The following shows that the converse need not hold:
Theorem 9.2.2
(a) There is a set F of fd’s and ind’s and an ind σ such that F |=fin σ but F |=unr σ .

(b) There is a set F of fd’s and ind’s and an fd σ such that F |=fin σ but F |=unr σ .

Proof
For part (a), let R be binary with attributes A, B; let F = {A → B, R[A] ⊆ R[B]}; and let σ be R[B] ⊆ R[A]. To see that F |=fin σ , let I be a finite instance of R that satisfies F. Because I |= A → B, |πA(I )| ≥ |πB(I )| and because I |= R[A] ⊆ R[B], |πB(I )| ≥
|πA(I )|. It follows that |πA(I )| = |πB(I )|. Because I is finite and πA(I ) ⊆ πB(I ), it follows that πB(I ) ⊆ πA(I ) and I |= R[B] ⊆ R[A].

On the other hand, the instance shown in Fig. 9.1(a) demonstrates that F |=unr σ .

For part (b), let F be as before, and let σ be the fd B → A. As before, if I |= F, then
|πA(I )| = |πB(I )|. Because I |= A → B, each tuple in I has a distinct A-value. Thus the number of B-values occurring in I equals the number of tuples in I . Because I is finite, this implies that I |= B → A. Thus F |=fin σ . On the other hand, the instance shown in Fig. 9.1(b) demonstrates that F |=unr σ .

It is now natural to reconsider implication for fd’s, jd’s, and inds taken separately and in combinations. Are unrestricted and finite implication different in these cases? The answer is given by the following:
9.2 Finite versus Infinite Implication
199
Theorem 9.2.3
Unrestricted and finite implication coincide for fd’s and jd’s considered separately or together and for ind’s considered alone.

Proof
Unrestricted implication implies finite implication by definition. For fd’s and jd’s taken separately or together, Theorem 8.4.12 on the relationship between chasing and logical implication can be used to obtain the opposite implication. For ind’s, Theorem 9.1.3
shows that finite implication and provability by the ind inference rules are equivalent. It is easily verified that these rules are also sound for unrestricted implication. Thus finite implication implies unrestricted implication for ind’s as well.

The notion of finite versus unrestricted implication will be revisited in Chapter 10, where dependencies are recast into a logic-based formalism.

Implication Is Undecidable for fd’s + ind’s
As will be detailed in Chapter 10, fd’s and ind’s (and most other relational dependencies) can be represented as sentences in first-order logic. By Gödel’s Completeness Theorem implication is recursively enumerable for first-order logic. It follows that unrestricted implication is r.e. for fd’s and ind’s considered together. On the other hand, finite implication for fd’s and ind’s taken together is co-r.e. This follows from the fact that there is an effective enumeration of all finite instances over a fixed schema; if F |=fin σ , then a witness of this fact will eventually be found. When unrestricted and finite implication coincide, this pair of observations is sufficient to imply decidability of implication; this is not the case for fd’s and ind’s.

The Word Problem for (Finite) Monoids
The proof that (finite) implication for fd’s and ind’s taken together is undecidable uses a reduction from the word problem for monoids, which we discuss next.

A monoid is a set with an associative binary operation ◦ defined on it and an identity element ε. Let Ŵ be a finite alphabet and Ŵ∗ the free monoid generated by Ŵ (i.e., the set of finite words with letters in Ŵ with the concatenation operation). Let E = {αi = βi |
i ∈ [1..n]} be a finite set of equalities, and let e be an additional equality α = β, where αi, βi, α, β ∈ Ŵ∗. Then E (finitely) implies e, denoted E |=unr e (E |=fin e), if for each (finite) monoid M and homomorphism h : Ŵ∗ → M, if h(αi) = h(βi) for each i ∈ [1..n], then h(α) = h(β). The word problem for (finite) monoids is to decide, given E and e, whether E |=unr e (E |=fin e). Both the word problem for monoids and the word problem for finite monoids are undecidable.

Using this, we have the following:
Theorem 9.2.4
Unrestricted and finite implication for fd’s and ind’s considered together are undecidable. In particular, let F range over sets of fd’s and ind’s. The following sets are not recursive:
(a) {(F, σ ) | σ an ind and F |=unr σ }; {(F, σ ) | σ an ind and F |=fin σ };
200
Inclusion Dependency
(b) {(F, σ ) | σ an fd and F |=unr σ }; and {(F, σ ) | σ an fd and F |=fin σ }.

Crux
We prove (a) using a reduction from the word problem for (finite) monoids to the (finite) implication problem for fd’s and ind’s. The proof of part (b) is similar and is left for Exercise 9.5. We first consider the unrestricted case.

Let Ŵ be a fixed alphabet. Let E = {αi = βi | i ∈ [1, n]} be a set of equalities over Ŵ∗, and let e be another equality α = β. A prefix is defined to be any prefix of αi, βi, α, or β (including the empty string ε, and full words α1, β1, etc.). A single relation R is used, which has attributes
(i) Aγ , for each prefix γ ;
(ii) Ax, Ay, Axy;
(iii) Aya, for each a ∈ Ŵ; and
(iv) Axya, for each a ∈ Ŵ;
where x and y are two fixed symbols.

To understand the correspondence between constrained relations and homomorphisms over monoids, suppose that there is a homomorphism h from Ŵ∗ to some monoid M.

Intuitively, a tuple of R will hold information about two elements h(x), h(y) of M (in columns Ax, Ay, respectively) and their product h(x) ◦ h(y) = h(xy) (in column Axy).

For each a in Ŵ, tuples will also hold information about h(ya) and h(xya) in columns Aya, Axya. More precisely, the instance IM,h corresponding to the monoid M and the homomorphism h : Ŵ∗ → M is defined by
IM,h = {tu,v | u, v ∈ Ŵ∗},
where for each u, v ∈ Ŵ∗, tu,v is the tuple such that
tu,v(Ax) = h(u),
tu,v(Aγ ) = h(γ ), for each prefix γ ,
tu,v(Ay) = h(v),
tu,v(Aya) = h(va), for each a ∈ Ŵ,
tu,v(Axy) = h(uv),
tu,v(Axya) = h(uva), for each a ∈ Ŵ.

Formally, to force the correspondence between the relations and homomorphisms over monoids, we use a set F of dependencies. In other words, we wish to find a set F of dependencies that characterizes precisely the instances over R that correspond to some homomorphism h from Ŵ∗ to some monoid M. The key to the proof is that this can be done using just fd’s and ind’s. Strictly speaking, the dependencies of (8) in the following list are not ind’s because an attribute is repeated in the left-hand side. As discussed in Exercise 9.4(e), the set of dependencies used here can be modified to a set of proper ind’s that has the desired properties. In addition, we use fd’s with an empty left-hand side, which are sometimes not considered as real fd’s. The use of such dependencies is not crucial. A slightly more complicated proof can be found that uses only fd’s with a nonempty left-hand side. The set F is defined as follows:
9.2 Finite versus Infinite Implication
201
1. ∅ → Aγ for each prefix γ ;
2. AxAy → Axy;
3. Ay → Aya, for each a ∈ Ŵ;
4. R[Aε] ⊆ R[Ay];
5. R[Aγ , Aγ a] ⊆ R[Ay, Aya], for each a ∈ Ŵ and prefix γ ;
6. R[Axy, Axya] ⊆ R[Ay, Aya], for each a ∈ Ŵ;
7. R[Ax, Aya, Axya] ⊆ R[Ax, Ay, Axy], for each a ∈ Ŵ;
8. R[Ay, Aε, Ay] ⊆ R[Ax, Ay, Axy]; and
9. R[Aα ] ⊆ R[A ], for each i ∈ [1, n].

i
βi
The ind σ is R[Aα] ⊆ R[Aβ].

Let I be an instance satisfying . Observe that I has to satisfy a number of implied properties. In particular, one can verify that I also satisfies the following property: R[Axya] ⊆ R[Aya] ⊆ R[Ay] = R[Axy] ⊆ R[Ax]
and that adom(I ) ⊆ I [Ax].

We now show that |=unr σ iff E |=unr e. We first show that E |=unr e implies
|=unr σ . Suppose that there is a monoid M and homomorphism h : Ŵ∗ → M that satisfies the equations of E but violates the equation e. Consider IM,h defined earlier. It is straightforward to verify that I |= but I |= σ .

For the opposite direction, suppose now that E |=unr e, and let I be a (possibly infinite) instance of R that satisfies . To conclude the proof, it must be shown that I [Aα] ⊆ I [Aβ].

(Observe that these two relations both consist of a single tuple because of the fd’s with an empty left-hand-side.)

We now define a function h : Ŵ∗ → adom(I ). We will prove that h is a homomorphism from Ŵ∗ to a free monoid whose elements are h(Ŵ∗) and that satisfies the equations of E
(and hence, e). We will use the fact that the monoid satisfies e to derive that I [Aα] ⊆ I [Aβ].

We now give an inductive definition of h and show that it has the property that h(v) ∈
I [Ay] for each v ∈ Ŵ∗.

Basis: Set h(ε) to be the element in I [Aε]. Note that h(ε) is also in I [Ay] because R[Aε] ⊆
R[Ay] ∈ .

Inductive step: Given h(v) and a ∈ Ŵ, let t ∈ I be such that t[Ay] = h(v). Define h(va) =
t (Aya). This is uniquely determined because Ay → Aya ∈ . In addition, h(va) ∈
I [Ay] because R[Ax, Aya, Axya] ⊆ R[Ax, Ay, Axy] ∈ .

We next show by induction on v that
(†)
h(u), h(v), h(uv) ∈ I [Ax, Ay, Axy] for each u, v ∈ Ŵ∗.

For a fixed u, the basis (i.e., v = ε) is provided by the fact that h(u) ∈ I [Ay] and the ind R[Ay, Aε, Ay] ⊆ R[Ax, Ay, Axy] ∈ . For the inductive step, let h(u), h(v), h(uv) ∈
I [Ax, Ay, Axy] and a ∈ Ŵ. Let t ∈ I be such that t[Ax, Ay, Axy] = h(u), h(v), h(uv).

202
Inclusion Dependency
Then by construction of h, h(va) = t (Aya), and from the ind R[Axy, Axya] ⊆ R[Ay, Aya], we have h(uva) = t (Axya). Finally, the ind R[Ax, Aya, Axya] ⊆ R[Ax, Ay, Axy] implies that h(u), h(va), h(uva) ∈ I [Ax, Ay, Axy] as desired.

Define the binary operation ◦ on h(Ŵ∗) as follows. For a, b ∈ h(Ŵ∗), let a ◦ b = c if for some t ∈ I , t[Ax, Ay, Axy] = a, b, c.

There is such a tuple by (†) and c is uniquely defined because Ax, Ay → Axy ∈ . Furthermore, by (†), for each u, v, h(u) ◦ h(v) = h(uv). Thus for h(u), h(v), h(w) in h(Ŵ∗), (h(u) ◦ h(v)) ◦ h(w) = h(uvw) = (h(u) ◦ h(v)) ◦ h(w),
and
h(u) ◦ h(ε) = h(u)
so (h(Ŵ∗), ◦) is a monoid. In addition, h is a homomorphism from the free monoid over Ŵ∗
to the monoid (h(Ŵ∗), ◦).

It is easy to see that I [Aα ] = {h(α
] = {h(β
i
i )} and I [Aβi
i )} for i ∈ [1, n]. Let i be
fixed. Because R[Aα ] ⊆ R[A ], h(α
i
βi
i ) = h(βi ). Because E |=unr e, h(α) = h(β ). Thus
I [Aα] = {h(α)} = {h(β)} = I [Aβ]. It follows that I |=unr R[Aα] ⊆ R[Aβ] as desired.

This completes the proof for the unrestricted case. For the finite case, note that everything has to be finite: The monoid is finite, I is finite, and the monoid h[Ŵ∗] is finite. The rest of the argument is the same.

The issue of decidability of finite and unrestricted implication for classes of dependencies is revisited in Chapter 10.

9.3
Nonaxiomatizability of fd’s + ind’s
The inference rules given previously for fd’s, mvd’s and ind’s can be viewed as “inference rule schemas,” in the sense that each of them can be instantiated with specific attribute sets (sequences) to create infinitely many ground inference rules. In these cases the family of inference rule schemas is finite, and we informally refer to them as “finite axiomatizations.”
Rather than formalizing the somewhat fuzzy notion of inference rule schema, we focus in this section on families R of ground inference rules. A ( ground) axiomatization of a family S of dependencies is a set of ground inference rules that is sound and complete for (finite or unrestricted) implication for S. Two properties of an axiomatization R will be considered, namely: (1) R is recursive, and (2) R is k-ary, in the sense (formally defined later in this section) that each rule in R has at most k dependencies in its condition.

Speaking intuitively, if S has a “finite axiomatization,” that is, if there is a finite family R′ of inference rule schemas that is sound and complete for S, then R′ specifies a ground axiomatization for S that is both recursive and k-ary for some k. Two results are demonstrated in this section: (1) There is no recursive axiomatization for finite implication
9.3 Nonaxiomatizability of fd’s + ind’s
203
of fd’s and ind’s, and (2) there is no k-ary axiomatization for finite implication of fd’s and ind’s. It is also known that there is no k-ary axiomatization for unrestricted implication of fd’s and ind’s. The intuitive conclusion is that the family of fd’s and ind’s does not have a
“finite axiomatization” for finite implication or for unrestricted implication.

To establish the framework and some notation, we assume temporarily that we are dealing with a family F of database instances over a fixed database schema R =
{R1, . . . , Rn}. Typically, F will be the set of all finite instances over R, or the set of all (finite or infinite) instances over R. All the notions that are defined are with respect to F .

Let S be a family of dependencies over R. (At present, S would be the set of fd’s and ind’s over R.) Logical implication |= among dependencies in S is defined with respect to F in the natural manner. In particular, |=unr and |=fin are obtained by letting F be the set of unrestricted or finite instances.

A ( ground) inference rule over S is an expression of the form ρ = if S then s,
where S ⊆ S and s ∈ S.

Let R be a set of rules over R. Then R is sound if each rule in R is sound. Let
∪ {σ } ⊆ S be a set of dependencies over R. A proof of σ from using R is a finite sequence σ1, . . . , σn = σ such that for each i ∈ [1, n], either (1) σi ∈ , or (2) for some rule ‘if S then s’ in R, σi = s and S ⊆ {σ1, . . . , σi−1}. We write ⊢R σ (or ⊢ σ if R is understood) if there is a proof of σ from using R. Clearly, if each rule in R is sound, then ⊢ σ implies |= σ . The set R is complete if for each pair (, σ ), |= σ implies
⊢R σ . A ( sound and complete) axiomatization for logical implication is a set R of rules that is sound and complete.

The aforementioned notions are now generalized to permit all schemas R. In particular, we consider a set R of rules that is a union ∪{RR | R is a schema}. The notions of sound, proof, etc.can be generalized in the natural fashion.

Note that with the preceding definition, every set S of dependencies has a sound and complete axiomatization. This is provided by the set R of all rules of the form if S then s,
where S |= s. Clearly, such trivial axiomatizations hold no interest. In particular, they are not necessarily effective (i.e., one may not be able to tell if a rule is in R, so one may not be able to construct proofs that can be checked). It is thus natural to restrict R to be recursive.

We now present the first result of this section, which will imply that there is no recursive axiomatization for finite implication of fd’s and ind’s. In this result we assume that the dependencies in S are sentences in first-order logic.

Proposition 9.3.1
Let S be a class of dependencies. If S has a recursive axiomatization for finite implications, then finite implication is decidable for S.

Crux
Suppose that S has a recursive axiomatization. Consider the set
204
Inclusion Dependency
Implic = {(S, s) | S ⊆ S, s ∈ S, and S |=fin s}.

First note that the set Implic is r.e.; indeed, let R be a recursive axiomatization for S. One can effectively enumerate all proofs of implication that use rules in R. This allows one to enumerate Implic effectively. Thus Implic is r.e. We argue next that Implic is also co-r.e.

To conclude that a pair (S, s) is not in Implic, it is sufficient to exhibit a finite instance satisfying S and violating s. To enumerate all pairs (S, s) not in Implic, one proceeds as follows. The set of all pairs (S, s) is clearly r.e., as is the set of all instances over a fixed schema. Repeat for all positive integers n the following. Enumerate the first n pairs (S, s) and the first n instances. For each (S, s) among the n, check whether one of the n instances is a counterexample to the implication S |= s, in which case output (S, s). Clearly, this procedure enumerates the complement of Implic, so Implic is co-r.e. Because it is both r.e.

and co-r.e., Implic is recursive, so there is an algorithm testing whether (S, s) is in Implic.

It follows that there is no recursive axiomatization for finite implication of fd’s and ind’s. [To see this, note that by Theorem 9.2.4, logical implication for fd’s and ind’s is undecidable. By Proposition 9.3.1, it follows that there can be no finite axiomatization for fd’s and ind’s.] Because implication for jd’s is decidable (Theorem 8.4.12), but there is no axiomatization for them (Theorem 8.3.4), the converse of the preceding proposition does not hold.

Speaking intuitively, the preceding development implies that there is no finite set of inference rule schemas that is sound and complete for finite implication of fd’s and ind’s. However, the proof is rather indirect. Furthermore, the approach cannot be used in connection with unrestricted implication, nor with classes of dependencies for which finite implication is decidable (see Exercise 9.9). The notion of k-ary axiomatization developed now shall overcome these objections.

A rule ‘if S then s’ is k-ary for some k ≥ 0 if |S| = k. An axiomatization R is k-ary if each rule in R is l-ary for some l ≤ k. For example, the instantiations of rules FD1 and IND1 are 0-ary, those of rules FD2 and IND2 are 1-ary, and those of FD3 and IND3
are 2-ary. Theorem 9.3.3 below shows that there is no k-ary axiomatization for finite implication of fd’s and ind’s.

We now turn to an analog in terms of logical implication of k-ary axiomatizability.

Again let S be a set of dependencies over R, and let F be a family of instances over R. Let k ≥ 0. A set Ŵ ⊆ S is:
closed under implication with respect to S if σ ∈ Ŵ whenever (a) σ ∈ S and (b) Ŵ |= σ
closed under k-ary implication with respect to S if σ ∈ Ŵ whenever (a) σ ∈ S, and for some ⊆ Ŵ, (b1) |= σ and (b2) || ≤ k.

Clearly, if Ŵ is closed under implication, then it is closed under k-ary implication for each
9.3 Nonaxiomatizability of fd’s + ind’s
205
k ≥ 0, and if Ŵ is closed under k-ary implication, then it is closed under k′-ary implication for each k′ ≤ k.

Proposition 9.3.2
Let R be a database schema, S a set of dependencies over R, and k ≥ 0. Then there is a k-ary axiomatization for S iff whenever Ŵ ⊆ S is closed under k-ary implication, then Ŵ is closed under implication.

Proof
Suppose that there is a k-ary axiomatization for S, and let Ŵ ⊆ S be closed under k-ary implication. Suppose further that Ŵ |= σ for some σ ∈ S. Let σ1, . . . , σn be a proof of σ from Ŵ using R. Using the fact that R is k-ary and that Ŵ is closed under k-ary implication, a straightforward induction shows that σi ∈ Ŵ for i ∈ [1, n].

Suppose now that for each Ŵ ⊆ S, if Ŵ is closed under k-ary implication, then Ŵ is closed under implication. Set
R = {‘if S then s’ | S ⊆ S, s ∈ S, |S| ≤ k, and S |= s}.

To see that R is complete, suppose that Ŵ |= σ . Consider the set Ŵ∗ = {γ | Ŵ ⊢R γ }. From the construction of R, Ŵ∗ is closed under k-ary implication. By assumption it is closed under implication, and so Ŵ ⊢R σ as desired.

In the following, we consider finite implication, so F is the set of finite instances.

Theorem 9.3.3
For no k does there exist a k-ary sound and complete axiomatization for finite implication of fd’s and ind’s taken together. More specifically, for each k there is a schema R for which there is no k-ary sound and complete axiomatization for finite implication of fd’s and ind’s over R.

Proof
Let k ≥ 0 be fixed. Let R = {R0, . . . , Rk} be a database schema where sort(Ri) =
{A, B} for each i ∈ [0, k]. In the remainder of this proof, addition is always done modulo k + 1. The dependencies = a ∪ b and σ are defined by
(a) a = {Ri : A → B | i ∈ [0, k]};
(b) b = {Ri[A] ⊆ Ri+1[B] | i ∈ [0, k]}; and
(c) σ = R0[B] ⊆ Rk[A].

Let Ŵ be the union of with all fd’s and ind’s that are tautologies (i.e., that are satisfied by all finite instances over R).

In the remainder of the proof, it is shown that (1) Ŵ is not closed under finite implication, but (2) Ŵ is closed under k-ary finite implication. Proposition 9.3.2 will then imply that the family of fd’s and ind’s has no k-ary sound and complete axiomatization for R.

First observe that Ŵ does not contain σ , so to show that Ŵ is not closed under finite implication, it suffices to demonstrate that |=fin σ . Let I be a finite instance of R that satisfies . By the ind’s of , |I(Ri)[A]| ≤ |I(Ri+1)[B]| for each i ∈ [0, k], and by the fd’s of , |I(Ri)[B]| ≤ |I(Ri)[A]| for each i ∈ [0, k]. From this we obtain
206
Inclusion Dependency
|I(R0)[A]| ≤ |I(R1)[B]| ≤ |I(R1)[A]|
≤
. . .

≤ |I(Rk)[B]| ≤ |I(Rk)[A]| ≤ |I(R0)[B]| ≤ |I(R0)[A]|.

In particular, |I(Rk)[A]| = |I(R0)[B]|. Since I is finite and we have I(Rk)[A] ⊆ I(R0)[B]
and |I(Rk)[A]| = |I(R0)[B]|, it follows that I(R0)[B] ⊆ I(Rk)[A] as desired.

We now show that Ŵ is closed under k-ary finite implication. Suppose that $ ⊆ Ŵ has no more than k elements (|$| ≤ k). It must be shown that if γ is an fd or ind and $ |=fin γ , then γ ∈ Ŵ. Because contains k + 1 ind’s, any subset $ of Ŵ that has no more than k members must omit some ind δ of . We shall exhibit an instance I such that I |= γ iff γ ∈ Ŵ − {δ}. (Thus I will be an Armstrong instance for Ŵ − {δ}.) It will then follow that Ŵ − {δ} is closed under finite implication. Because $ ⊆ Ŵ − {δ}, this will imply that for each fd or ind γ , if $ |=fin γ , then Ŵ − {δ} |=fin γ , so γ ∈ Ŵ.

Because is symmetric with regard to ind’s, we can assume without loss of generality that δ is the ind Rk[A] ⊆ R0[B]. Assuming that N × N is contained in the underlying domain, define I so that
I(R0) = { (0, 0), (0, k + 1), (1, 0), (1, k + 1), (2, 0), (1, k + 1)}
and for each i ∈ [1, k],
I(Ri) = { (0, i), (0, i − 1), (1, i), (1, i − 1), . . . ,
(2i + 1, i), (2i + 1, i − 1), (2i + 2, i), (2i + 1, i − 1)}.

Figure 9.2 shows I for the case k = 3.

We now show for each fd and ind γ over R that I |= γ iff γ ∈ Ŵ − δ. Three cases arise: 1. γ is a tautology. Then this clearly holds.

2. γ is an fd that is not a tautology. Then γ is equivalent to one of the following for some i ∈ [0, k]:
Ri : A → B,
Ri : B → A,
Ri : ∅ → A,
Ri : ∅ → B,
or
Ri : ∅ → AB.

If γ is Ri : A → B, then γ ∈ Ŵ and clearly I |= γ . In the other cases, γ ∈ Ŵ and I |= γ .

3. γ is an ind that is not a tautology. Considering now which ind’s I satisfies, note that the only pairs of nondisjoint columns of relations in I are I(R0)[A], I(R1)[B];
I(R1)[A], I(R2)[B];
. . . ;
I(Rk−1)[A], I(Rk)[B].

Furthermore, I |= Ri+1[B] ⊆ Ri[A] for each i ∈ [0, k]; and I |= Ri[A] ⊆ Ri+1[B].

This implies that I |= γ iff γ ∈ Ŵ − {δ}, as desired.

9.4 Restricted Kinds of Inclusion Dependency
207
I(R0)
A
B
I(R1)
A
B
(0,0)
(0,4)
(0,1)
(0,0)
(1,0)
(1,4)
(1,1)
(1,0)
(2,0)
(1,4)
(2,1)
(2,0)
(3,1)
(3,0)
(4,1)
(3,0)
I(R2)
A
B
I(R3)
A
B
(0,2)
(0,1)
(0,3)
(0,2)
(1,2)
(1,1)
(1,3)
(1,2)
(2,2)
(2,1)
(2,3)
(2,2)
(3,2)
(3,1)
(3,3)
(3,2)
(4,2)
(4,1)
(4,3)
(4,2)
(5,2)
(5,1)
(5,3)
(5,2)
(6,2)
(5,1)
(6,3)
(6,2)
(7,3)
(7,2)
(8,3)
(7,2)
Figure 9.2:
An Armstrong relation for Ŵ − δ
In the proof of the preceding theorem all relations used are binary, and all fd’s and ind’s are unary, in the sense that at most one attribute appears on either side of each dependency.

In proofs that there is no k-ary axiomatization for unrestricted implication of fd’s and ind’s, some of the ind’s used involve at least two attributes on each side. This cannot be improved to unary ind’s, because there is a 2-ary sound and complete axiomatization for unrestricted implication of unary ind’s and arbitrary fd’s (see Exercise 9.18).

9.4
Restricted Kinds of Inclusion Dependency
This section explores two restrictions on ind’s for which several positive results have been obtained. The first one focuses on sets of ind’s that are acyclic in a natural sense, and the second restricts the ind’s to having only one attribute on either side. The restricted dependencies are important because they are sufficient to model many natural relationships, such as those captured by semantic models (see Chapter 11). These include subtype relationships of the kind “every student is also a person.”
This section also presents a generalization of the chase that incorporates ind’s. Because ind’s are embedded, chasing in this context may lead to infinite chasing sequences.

In the context of acyclic sets of ind’s, however, the chasing sequences are guaranteed to terminate. The study of infinite chasing sequences will be taken up in earnest in Chapter 10.

208
Inclusion Dependency
Ind’s and the Chase
Because ind’s may involve more than one relation, the formal notation of the chase must be extended. Suppose now that R is a database schema, and let q = (T, t) be a tableau query over R. The fd and jd rules are generalized to this context in the natural fashion.

We first present an example and then describe the rule that is used for ind’s.

Example 9.4.1
Consider the database schemas consisting of two relation schemas P , Q
with sort(P ) = ABC, sort(Q) = DEF, the dependencies Q[ DE] ⊆ P [ AB]
and
P : A → B,
and the tableau T shown in Fig. 9.3. Consider T1 and T2 in the same figure. The tableau T1 is obtained by applying to T the ind rule given after this example. The intuition is that the tuples x, yi should also be in the P -relation because of the ind. Then T2 is obtained by applying the fd rule. Tableau minimization can be applied to obtain T3.

The following rule is used for ind’s.

ind rule: Let σ = R[X] ⊆ S[Y ] be an ind, let u ∈ T(R), and suppose that there is no free tuple v ∈ T(S) such that v[Y ] = u[X]. In this case, we say that σ is applicable to R(u).

Let w be a free tuple over S such that w[Y ] = u[X] and w has distinct new variables in all coordinates of sort(S) − Y that are greater than all variables occurring in q. Then
“the” result of applying σ to R(u) is (T′, t), where
• T′(P ) = T(P ) for each relation name P ∈ R − {S}, and
• T′(S) = T(S) ∪ {w}.

For a tableau query q and a set of ind’s, it is possible that two terminal chasing sequences end with nonisomorphic tableau queries, that there are no finite terminal chasing sequences, or that there are both finite terminal chasing sequences and infinite chasing sequences (see Exercise 9.12). General approaches to resolving this problem will be considered in Chapter 10. In the present discussion, we focus on acyclic sets of ind’s, for which the chase always terminates after a finite number of steps.

Acyclic Inclusion Dependencies
Definition 9.4.2
A family of ind’s over R is acyclic if there is no sequence Ri[Xi] ⊆
Si[Yi] (i ∈ [1, n]) of ind’s in where for i ∈ [1, n], Ri+1 = Si for i ∈ [1, n − 1], and R1 = Sn. A family of dependencies has acyclic ind’s if the set of ind’s in is acyclic.

The following is easily verified (see Exercise 9.14):
Proposition 9.4.3
Let q be a tableau query and a set of fd’s, jd’s, and acyclic ind’s over R. Then each chasing sequence of q by terminates after an exponentially bounded number of steps.

9.4 Restricted Kinds of Inclusion Dependency
209
T( P)
A
B
C
T( Q)
D
E
F
x
y 1
z
x
y 2
x
t
y 1
x
T
T
1( P)
A
B
C
1( Q)
D
E
F
x
y
w
x
y
1
1
1
z
x
y
w
x
y
2
2
2
x
t
y 1
x
T
T
2( P)
A
B
C
2( Q)
D
E
F
x
y
w
x
y
1
1
1
z
x
y
w
x
y
1
2
1
x
t
y 1
x
T
T
3( P)
A
B
C
3( Q)
D
E
F
x
y
x
y
1
w 1
1
x
t
y 1
x
Figure 9.3:
Chasing with ind’s
For each tableau query q and set of fd’s, jd’s, and acyclic ind’s, let chase(q, ) denote the result of some arbitrary chasing sequence of q by . (One can easily come up with some syntactic strategy for arbitrarily choosing this sequence.) Using an analog to Lemma 8.4.3, one obtains the following result on tableau query containment (an analog to Theorem 8.4.8).

Theorem 9.4.4
Let q, q′ be tableau queries and a set of fd’s, jd’s, and acyclic ind’s over R. Then q ⊆ q′ iff chase(q, ) ⊆ chase(q′, ).

Next we consider the application of the chase to implication of dependencies. For database schema R and ind σ = R[X] ⊆ S[Y ] over R, the tableau query of σ is qσ =
({R(uσ )}, uσ ), where uσ is a free tuple all of whose entries are distinct. For example, given R[ ABCD], S[ EFG], and σ = R[ BC] ⊆ S[ GE], qσ = ({R(x1, x2, x3, x4)}, x1, x2,
210
Inclusion Dependency
x3, x4). In analogy with Theorem 8.4.12, we have the following for fd’s, jd’s, and acyclic ind’s.

Theorem 9.4.5
Let be a set of fd’s, jd’s, and acyclic ind’s over database schema R
and let T be the tableau in chase(qσ , ). Then |=unr σ iff (a) For fd or jd σ over R, T satisfies the conditions of Theorem 8.4.12.

(b) For ind σ = R[X] ∈ S[Y ], uσ [X] ∈ T(S)[Y ].

This yields the following:
Corollary 9.4.6
Finite and unrestricted implication for sets of fd’s, jd’s, and acyclic ind’s coincide and are decidable in exponential time.

An improvement of the complexity here seems unlikely, because implication of an ind by an acyclic set of ind’s is np-complete (see Exercise 9.14).

Unary Inclusion Dependencies
A unary inclusion dependency (uind) is an ind in which exactly one attribute appears on each side. The uind’s arise frequently in relation schemas in which certain columns range over values that correspond to entity types (e.g., if SS# is a key for the Person relation and is also used to identify people in the Employee relation).

As with arbitrary ind’s, unrestricted and finite implication do not coincide for fd’s and uind’s (proof of Theorem 9.2.2). However, both forms of implication are decidable in polynomial time. In this section, the focus is on finite implication. We present a sound and complete axiomatization for finite implication of fd’s and uind’s (but in agreement with Theorem 9.3.3, it is not k-ary for any k).

For uind’s considered in isolation, the inference rules for ind’s are specialized to yield the following two rules, which are sound and complete for (unrestricted and finite) implication. Here A, B, and C range over attributes and R, S, and T over relation names: UIND1: (reflexivity) R[A] ⊆ R[A].

UIND2: (transitivity) If R[A] ⊆ S[B] and S[B] ⊆ T [C], then R[A] ⊆ T [C].

To capture the interaction of fd’s and uind’s in the finite case, the following family of rules is used:
C : (cycle rules) For each positive integer n,


 R
R
 1 : A1 → B1,
 1 : B1 → A1,


 R

2[A2] ⊆ R1[B1],
 R1[B1] ⊆ R2[A2],
if
. . . ,
then
. . . ,





 Rn : An → Bn, and

 Rn : Bn → An, and
R1[A1] ⊆ Rn[Bn]
Rn[Bn] ⊆ R1[A1].

Exercises
211
The soundness of this family of rules follows from a straightforward cardinality argument.

More generally, we have the following (see Exercise 9.16):
Theorem 9.4.7
The set {FD1, FD2, FD3, UIND1, UIND2} along with the cycle rules
(C) is sound and complete for finite implication of fd’s and uind’s. Furthermore, finite implication is decidable in polynomial time.

Bibliographic Notes
Inclusion dependency is based on the notion of referential integrity, which was known to the broader database community during the 1970s (see, e.g., [Dat81]). A seminal paper on the theory of ind’s is [CFP84], in which inference rules for ind’s are presented and the nonaxiomatizability of both finite and unrestricted implication for fd’s and ind’s is demonstrated. A non-k-ary sound and complete set of inference rules for finite implication of fd’s and ind’s is presented in [Mit83b]. Another seminal paper is [JK84b], which also observed the distinction between finite and unrestricted implication for fd’s and ind’s, generalized the chase to incorporate fd’s and ind’s, and used this to characterize containment between conjunctive queries. Related work is reported in [LMG83].

Undecidability of (finite) implication for fd’s and ind’s taken together was shown independently by [CV85] and [Mit83a]. The proof of Theorem 9.2.4 is taken from [CV85].

(The undecidability of the word problem for monoids is from [Pos47], and of the word problem for finite monoids is from [Gur66].)

Acyclic ind’s were introduced in [Sci86]. Complexity results for acyclic ind’s include that implication for acyclic ind’s alone is np-complete [CK86], and implication for fd’s and acyclic ind’s has an exponential lower bound [CK85].

Given the pspace complexity of implication for ind’s and the negative results in connection with fd’s, unary ind’s emerged as a more tractable form of inclusion dependency.

The decision problems for finite and unrestricted implication for uind’s and fd’s taken together, although not coextensive, both lie in polynomial time [CKV90]. This extensive paper also develops axiomatizations of both finite and unrestricted logical implication for unary ind’s and fd’s considered together, and develops results for uind’s with some of the more general dependencies studied in Chapter 10.

Typed ind’s are studied in [CK86]. In addition to using traditional techniques from dependency theory, such as chasing, this work develops tools for analyzing ind’s using equational theories.

Ind’s in connection with other dependencies are also studied in [CV83].

Exercises
Exercise 9.1
Complete the proof of Proposition 9.1.5.

Exercise 9.2
Complete the proof of Theorem 9.1.7.

Exercise 9.3
[CFP84] (In this exercise, by a slight abuse of notation, we allow fd’s with sequences rather than sets of attributes.) Demonstrate the following: (a) If |
A| = |
B|, then {R[
A
C] ⊆ S[
B
D], S :
B →
D} |=unr R :
A →
C.

212
Inclusion Dependency
(b) If |
A| = |
B|, then {R[
A
C] ⊆ S[
B
D], R[
A
E] ⊆ S[
B
F ], S :
B →
D} |=unr R[
A
C
E]
⊆ S[
B
D
F ].

(c) Suppose that |
A| = |
B|; = {R[
A
C] ⊆ S[
B
D], R[
A
E] ⊆ S[
B
D], S :
B →
D};
and I |= . Then u[
C] = u[
E] for each u ∈ I(R).

Exercise 9.4
As defined in the text, we require in ind R[A1, . . . , Am] ⊆ S[B1, . . . , Bm] that the Ai’s and Bi’s are distinct. A repeats-permitted inclusion dependency (rind) is defined as was inclusion dependency, except that repeats are permitted in the attribute sequences on both the left- and right-hand sides.

(a) Show that if is a set of ind’s, σ a rind, and |=unr σ , then σ is equivalent to an ind.

(b) Exhibit a set of ind’s and fd’s such that |=unr R[AB] ⊆ S[CC]. Do the same for R[AA] ⊆ R[BC].

♠ (c) [Mit83a] Consider the rules
IND4: If R[A1A2] ⊆ S[BB] and R[
C] ⊆ T [
D], then R[
C′] ⊆ T [
D], where
C′
is obtained from
C by replacing one or more occurrences of A2 by A1.

IND5: If R[A1A2] ⊆ S[BB] and T [
C] ⊆ R[
D], then T [
C] ⊆ R[
D′], where
D′
is obtained from
D by replacing one or more occurrences of A2 by A1.

Prove that the inference rules {IND1, IND2, IND3, IND4, IND5} are sound and complete for finite implication of sets of rind’s.

(d) Prove that unrestricted and finite implication coincide for rind’s.

(e) A left-repeats-permitted inclusion dependency (l-rind) is a rind for which there are no repeats on the right-hand side. Given a set ∪ {σ } of l-rind’s over R, describe how to construct a schema R′ and ind’s ′ ∪ {σ ′} over R′ such that |= σ iff ′ |= σ ′
and |=fin σ iff ′ |=fin σ ′.

(f) Do the same as in part (e), except for arbitrary rind’s.

Exercise 9.5
[CV85] Prove part (b) of Theorem 9.2.4. Hint: In the proof of part (a), extend the schema of R to include new attributes Aα′, Aβ′, and Ay′; add dependencies Ay → Ay′, R[Aα, Aα′] ⊆ R[Ay, Ay′], R[Aβ, Aβ′] ⊆ R[Ay, Ay′]; and use Aα′ → Aβ′ as σ .

Exercise 9.6
(a) Develop an alternative proof of Theorem 9.3.3 in which δ is an fd rather than an ind.

(b) In the proof of Theorem 9.3.3 for finite implication, the dependency σ used is an ind.

Using the same set , find an fd that can be used in place of σ in the proof.

Exercise 9.7
Prove that there is no k for which there is a k-ary sound and complete axiomatization for finite implication of fd’s, jd’s, and ind’s.

⋆ Exercise 9.8 [SW82] Prove that there is no k-ary sound and complete set of inference rules for finite implication of emvd’s.

Exercise 9.9
Recall the notion of sort-set dependency (ssd) from Exercise 8.32.

(a) Prove that finite and unrestricted implication coincide for fd’s and ssd’s considered together. Conclude that implication for fd’s and ssd’s is decidable.

Exercises
213
⋆ (b) [GH86] Prove that there is no k-ary sound and complete set of inference rules for finite implication of fd’s (key dependencies) and ssd’s taken together.

Exercise 9.10
(a) [CFP84] A set of ind’s is bounded by k if each ind in the set has at most k attributes on the left-hand side and on the right-hand side. Show that logical implication for bounded sets of ind’s is decidable in polynomial time.

(b) [CV83] An ind is typed if it has the form R[
A ] ⊆ S[
A ]. Exhibit a polynomial time
algorithm for deciding logical implication between typed ind’s.

Exercise 9.11
Suppose that some attribute domains may be finite.

(a) Show that {IND1, IND2, IND3} remains sound in the framework.

(b) Show that if one-element domains are permitted, then {IND1, IND2, IND3} is not complete.

(c) Show for each n > 0 that if all domains are required to have at least n elements, then
{IND1, IND2, IND3} is not complete.

Exercise 9.12
Suppose that no restrictions are put on the order of application of ind rules in chasing sequences.

(a) Exhibit a tableau query q and a set of ind’s and two terminal chasing sequences of q by that end with nonisomorphic tableau queries.

(b) Exhibit a tableau query q and a set of ind’s, a terminal chasing sequence of q by
, and an infinite chasing sequence of q by .

(c) Exhibit a tableau query q and a set of ind’s such that q has no finite terminal chasing sequence by .

♠ Exercise 9.13 [JK84b] Recall that for tableau queries q and q′ and a set of fd’s and jd’s over R, q ⊆ q′ if for each instance I that satisfies , q(I ) ⊆ q′(I ). In the context of ind’s, this containment relationship may depend on whether infinite instances are permitted or not. For tableau queries q, q′ and a set of dependencies over R, we write q ⊆,fin q′ (q ⊆,unr q′) if q(I) ⊆ q′(I) for each finite (unrestricted) instance I that satisfies .

(a) Show that if is a set of fd’s and jd’s, then ⊆,fin and ⊆,unr coincide.

(b) Exhibit a set of fd’s and ind’s and tableau queries q, q′ such that q ⊆,fin q′ but q ⊆,unr q′.

Exercise 9.14
(a) Prove Proposition 9.4.3.

(b) Prove Theorem 9.4.4.

(c) Let q be a tableau query and a set of fd’s, jd’s, and ind’s over R, where the set of ind’s in is acyclic; and suppose that q′, q′′ are the final tableaux of two terminal chasing sequences of q by (where the order of rule application is not restricted).

Prove that q ≡ q′.

(d) Prove Theorem 9.4.5.

(e) Prove Corollary 9.4.6.

Exercise 9.15
214
Inclusion Dependency
(a) Exhibit an acyclic set of ind’s and a tableau query q such that chase(q, ) is exponential in the size of and q.

(b) [CK86] Prove that implication of an ind by an acyclic set of ind’s is np-complete.

Hint: Use a reduction from the problem of Permutation Generation [GJ79].

(c) [CK86] Recall from Exercise 9.10(b) that an ind is typed if it has the form R[
A] ⊆
S[
A]. Prove that implication of an ind by a set of fd’s and an acyclic set of typed ind’s is np-hard. Hint: Use a reduction from 3-SAT.

♠ Exercise 9.16 [CKV90] In this exercise you will prove Theorem 9.4.7. The exercise begins by focusing on the unirelational case; for notational convenience we omit the relation name from uind’s in this context.

Given a set of fd’s and uind’s over R, define G() to be a multigraph with node set R
and two colors of edges: a red edge from A to B if A → B ∈ , and a black edge from A to B is B ⊆ A ∈ . If A and B have red (black) edges in both directions, replace them with an undirected red (black) edge.

(a) Suppose that is closed under the inference rules. Prove that G() has the following properties:
1. Nodes have red (black) self-loops, and the red (black) subgraph of G() is transitively closed.

2. The subgraphs induced by the strongly connected components of G() contain only undirected edges.

3. In each strongly connected component, the red (black) subset of edges forms a collection of node disjoint cliques (the red and black partitions of nodes could be different).

4. If A1 . . . Am → B is an fd in and A1, . . . , Am have common ancestor A in the red subgraph of G(), then G() contains a red edge from A to B.

(b) Given a set of fd’s and uind’s closed under the inference rules, use G() to build counterexample instances that demonstrate that ⊢ σ implies |=fin σ for fd or uind σ .

(c) Use the rules to develop a polynomial time algorithm for inferring finite implication for a set of fd’s and uind’s.

(d) Generalize the preceding development to arbitrary database schemas.

Exercise 9.17
(a) Let k > 1 be an integer. Prove that there is a database schema R with at least one unary relation R ∈ R, and a set of fd’s and ind’s such that (i) for each I |= , |I(R)| = 0 or |I(R)| = 1 or |I(R)| ≥ k.

(ii) for each l ≥ k there is an instance Il |= with |I(R)| = l.

(b) Prove that this result cannot be strengthened so that condition (i) reads (i) (i′) for each I |= , |I(R)| = 0 or |I(R)| = 1 or |I(R)| = k.

♠ Exercise 9.18 [CKV90]
(a) Show that the set of inference rules containing {FD1, FD2, FD3, UIND1, UIND2}
and
FD-UIND1: If ∅ → A and R[B] ⊆ R[A], then ∅ → B.

FD-UIND1: If ∅ → A and R[B] ⊆ R[A], then R[A] ⊆ R[B].

Exercises
215
is sound and complete for unrestricted logical implication of fd’s and uind’s over a single relation schema R.

(b) Generalize this result to arbitrary database schemas, under the assumption that in all instances, each relation is nonempty.

10 ALargerPerspective
Alice:
fd’s, jd’s, mvd’s, ejd’s, emvd’s, ind’s—it’s all getting very confusing.

Vittorio:
Wait! We’ll use logic to unify it all.

Sergio:
Yes! Logic will make everything crystal clear.

Riccardo:
And we’ll get a better understanding of dependencies that make sense.

The dependencies studied in the previous chapters have a strong practical motivation and provide a good setting for studying two of the fundamental issues in dependency theory: deciding logical implication and constructing axiomatizations.

Several new dependencies were introduced in the late 1970s and early 1980s, sometimes motivated by practical examples and later motivated by a desire to understand fundamental theoretical properties of unirelational dependencies or to find axiomatizations for known classes of dependencies. This process culminated with a rather general perspective on dependencies stemming from mathematical logic: Almost all dependencies that have been introduced in the literature can be described as logical sentences having a simple structure, and further syntactic restrictions on that structure yield natural subclasses of dependencies. The purpose of this chapter is to introduce this general class of dependencies and its natural subclasses and to present important results and techniques obtained for them.

The general perspective is given in the first section, along with a simple application of logic to obtain the decidability of implication for a large class of dependencies. It turns out that the chase is an invaluable tool for analyzing implication; this is studied in the second section. Axiomatizations for important subclasses have been developed, again using the chase; this is the topic of the third section. We conclude the chapter with a provocative alternative view of dependencies stemming from relational algebra.

The classes of dependencies studied in this chapter include complex dependencies that would not generally arise in practice. Even if they did arise, they are so intricate that they would probably be unusable—it is unlikely that database administrators would bother to write them down or that software would be developed to use or enforce them. Nevertheless, it is important to repeat that the perspective and results discussed in this chapter have served the important function of providing a unified understanding of virtually all dependencies raised in the literature and, in particular, of providing insight into the boundaries between tractable and intractable problems in the area.

216
10.1 A Unifying Framework
217
10.1
A Unifying Framework
The fundamental property of all of the dependencies introduced so far is that they essentially say, “The presence of some tuples in the instance implies the presence of certain other tuples in the instance, or implies that certain tuple components are equal.” In the case of jd’s and mvd’s, the new tuples can be completely specified in terms of the old tuples, but for ind’s this is not the case. In any case, all of the dependencies discussed so far can be expressed using first-order logic sentences of the form
(∗)
∀x1 . . . ∀xn [ ϕ(x1, . . . , xn) → ∃z1 . . . ∃zkψ(y1, . . . , ym) ], where {z1, . . . , zk} = {y1, . . . , ym} − {x1, . . . , xn}, and where ϕ is a (possibly empty) conjunction of atoms and ψ a nonempty conjunction. In both ϕ and ψ, one finds relation atoms of the form R(w1, . . . , wl) and equality atoms of the form w = w′, where each of the w, w′, w1, . . . , wl is a variable.

Because we generally focus on sets of dependencies, we make several simplifying assumptions before continuing (see Exercise 10.1a). These include that (1) we may eliminate equality atoms from ϕ without losing expressive power; and (2) we can also assume without loss of generality that no existentially quantified variable participates in an equality atom in ψ. Thus we define an (embedded) dependency to be a sentence of the foregoing form, where
1. ϕ is a conjunction of relation atoms using all of the variables x1, . . . , xn; 2. ψ is a conjunction of atoms using all of the variables z1, . . . , zk; and 3. there are no equality atoms in ψ involving existentially quantified variables.

A dependency is unirelational if at most one relation name is used, and it is multirelational otherwise. To simplify the presentation, the focus in this chapter is almost exclusively on unirelational dependencies. Thus, unless otherwise indicated, the dependencies considered here are unirelational.

We now present three fundamental classifications of dependencies.

Full versus embedded: A full dependency is a dependency that has no existential quantifiers.

Tuple generating versus equality generating: A tuple-generating dependency (tgd) is a dependency in which no equality atoms occur; an equality-generating dependency (egd) is a dependency for which the right-hand formula is a single equality atom.

Typed versus untyped: A dependency is typed if there is an assignment of variables to column positions such that (1) variables in relation atoms occur only in their assigned position, and (2) each equality atom involves a pair of variables assigned to the same position.

It is sometimes important to distinguish dependencies with a single atom in the right-hand formula. A dependency is single head if the right-hand formula involves a single atom; it is multi-head otherwise.

The following result is easily verified (Exercise 10.1b).

218
A Larger Perspective
Untyped
ind’s
Embedded
Typed
jd’s
Full
fd’s
mvd’s
egd’s
Single-head tgd’s Multi-head tgd’s
tgd’s
Figure 10.1:
Dependencies
Proposition 10.1.1
Each (typed) dependency is equivalent to a set of (typed) egd’s
and tgd’s.

It is easy to classify the fd’s, jd’s, mvd’s, ejd’s, emvd’s and ind’s studied in Chapters 8
and 9 according to the aforementioned dimensions. All except the last are typed. During the late 1970s and early 1980s the class of typed dependencies was studied in depth. In many cases, the results obtained for dependencies and for typed dependencies are equivalent.

However, for negative results the typed case sometimes requires more sophisticated proof techniques because it imposes more restrictions.

A classification of dependencies along the three axes is given in Fig. 10.1. The gray square at the lower right indicates that each full multihead tgd is equivalent to a set of single-head tgd’s. The intersection of ind’s and jd’s stems from trivial dependencies. For example, R[AB] ⊆ R[AB] and ⊲⊳[AB] over relation R(AB) are equivalent [and are syntactically the same when written in the form of (∗)].

There is a strong relationship between dependencies and tableaux. Tableaux provide a convenient notation for expressing and working with dependencies. (As will be seen in Section 10.4, the family of typed dependencies can also be represented using a formalism based on algebraic expressions.) The tableau representation of two untyped egd’s is shown in Figs. 10.2(a) and 10.2(b). These two egd’s are equivalent. Note that all egd’s can be expressed as a pair (T , x = y), where T is a tableau and x, y ∈ va r(T ). If (T , x = y) is typed, unirelational, and x, y are in the A column of T , then this is referred to as an A- egd.

Parts (c) and (d) of Fig. 10.2 show two full tgd’s that are equivalent. This is especially interesting because, considered as tableau queries, (T ′, t) properly contains (T , t) (see Exercise 10.4). As suggested earlier, each full tgd is equivalent to some set of full single-head tgd’s. In the following, when considering full tgd’s, we will assume that they are single head.

Part (e) of Fig. 10.2 shows a typed tgd that is not single head. To represent these within
10.1 A Unifying Framework
219
A
B
C
A
B
C
S
x
y
w
S′
x
y
w
1
1
y
w
z
y
w
2
2
u
z
y
w 3
u
y
w 3
y
w
x = z
4
z
z
y
w 5
x = z
(a) ( S, x = z)
(b) ( S′ , x = z)
A
B
A
B
A
B
T
x
y 1
T′
x
y 1
T 1
x
y 1
x 1
y 1
x 1
y 1
x 1
y 1
x 1
y
x 1
y 2
x 1
y 2
t
x
y
x 2
y 2
x′
y 2
x 2
y
T
x
y
2
3
t
x
y
x′
y 3
(c) ( T, t)
(d) ( T′ , t)
(e) ( T 1 , T 2)
Figure 10.2:
Five dependencies
the tableau notation, we use an ordered pair (T1, T2), where both T1 and T2 are tableaux.

This tgd is not equivalent to any set of single-head tgd’s (see Exercise 10.6b).

Finite versus Unrestricted Implication Revisited
We now reexamine the issues of finite versus unrestricted implication using the logical perspective on dependencies. Because all of these lie within first-order logic, |=fin is co-r.e.

and |=unr is r.e. (see Chapter 2). Suppose that = {σ1, . . . , σn} is a set of dependencies and
{σ } a dependency. Then |=unr σ ( |=fin σ ) iff there is no unrestricted (finite) model of σ1 ∧ · · · ∧ σn ∧ ¬σ . If these are all full dependencies, then they can be rewritten in prenex normal form, where the quantifier prefix has the form ∃∗∀∗. (Here each of the σi is universally quantified, and ¬σ contributes the existential quantifier.) The family of sentences that have a quantifier prefix of this form (and no function symbols) is called the initially extended Bernays-Schönfinkel class, and it has been studied in the logic community since the 1920s. It is easily verified that finite and unrestricted satisfiability coincide for sentences in this class (Exercise 10.3). It follows that finite and unrestricted implication coincide for full dependencies and, as discussed in Chapter 9, it follows that implication is decidable.

220
A Larger Perspective
On the other hand, because fd’s and uind’s are dependencies, we know from Theorem 9.2.4
that the two forms of implication do not coincide for (embedded) dependencies, and both are nonrecursive. Although not demonstrated here, these results have been extended to the family of embedded multivalued dependencies (emvd’s).

To summarize:
Theorem 10.1.2
1. For full dependencies, finite and unrestricted implication coincide and are decidable.

2. For (typed) dependencies, finite and unrestricted implication do not coincide and are both undecidable. In fact, this is true for embedded multivalued dependencies.

In particular, finite implication is not r.e., and unrestricted implication is not co-r.e.

10.2
The Chase Revisited
As suggested by the close connection between dependencies and tableaux, chasing is an invaluable tool for characterizing logical implication for dependencies. In this section we first use chasing to develop a test for logical implication of arbitrary dependencies by full dependencies. We also present an application of the chase for determining how full dependencies are propagated to views. We conclude by extending the chase to work with embedded dependencies. In this discussion we focus almost entirely on typed dependencies, but it will be clear that the arguments can be modified to the untyped case.

Chasing with Full Dependencies
We first state without proof the natural generalization of chasing by fd’s and jd’s (Theorem 8.4.12) to full dependencies (see Exercise 10.8). In this context we begin either with a tableau T , or with an arbitrary tgd (T , T ′) or egd (T , x = y). The notion of applying a full dependency to this is defined in the natural manner. Lemma 8.4.17 and the notation developed for it generalize naturally to this context, as does the following analog of Theorem 8.4.18:
Theorem 10.2.1
If is a set of full dependencies and T is a tableau (τ a dependency), then chasing T (τ ) by yields a unique finite result, denoted chase(T , ) ( chase(τ, )).

Logical implication of (full or embedded) dependencies by sets of full dependencies will now be characterized by a straightforward application of the techniques developed in Section 8.4 (see Exercise 10.8). A dependency τ is trivial if (a) τ is an egd (T , x = x); or
(b) τ is a tgd (T , T ′) and there is a substitution θ for T ′ such that θ (T ′) ⊆ T and θ
is the identity on var(T ) ∩ var(T ′).

Note that if τ is a full tgd, then (b) simply says that T ′ ⊆ T .

10.2 The Chase Revisited
221
A dependency τ is a tautology for finite (unrestricted) instances if each finite (unrestricted) instance of appropriate type satisfies τ —that is, if ∅ |=fin τ (∅ |=unr τ ). It is easily verified that a dependency is a tautology iff it is trivial.

The following now provides a simple test for implication by full typed dependencies: Theorem 10.2.2
Let be a set of full typed dependencies and τ a typed dependency.

Then |= τ iff chase(τ, ) is trivial.

Recall that the chase relies on a total order ≤ on var. For egd (T , x = y) we assume that x < y and that these are the least and second to least variables appearing in the tableau; and for full tgd (T , t), t (A) is least in T (A) for each attribute A. Using this convention, we can obtain the following:
Corollary 10.2.3
Let be a set of full typed dependencies.

(a) If τ = (T , x = y) is a typed egd, then |= τ iff x and y are identical or y ∈
var( chase(T , )).

(b) If τ = (T , t) is a full typed tgd, then |= τ iff t ∈ chase(T , ).

Using the preceding results, it is straightforward to develop a deterministic exponential time algorithm for testing implication of full dependencies. It is also known that for both the typed and untyped cases, implication is complete in exptime. (Note that, in contrast, logical implication for arbitrary sets of initially extended Bernays-Schöfinkel sentences is known to be complete in nondeterministic exptime.)

Dependencies and Views
On a bit of a tangent, we now apply the chase to characterize the interaction of full dependencies and user views. Let R = {R1, . . . , Rn} be a database schema, where Rj has associated set j of full dependencies for j ∈ [1, n]. Set = {Ri : σ | σ ∈ i}. Note that the elements of are tagged by the relation name they refer to. Suppose that a view is defined by algebraic expression E : R → S[V ]. It is natural to ask what dependencies will hold in the view. Formally, we say that R : implies E : σ , denoted R : |= E : σ , if E(I) satisfies σ for each I that satisfies . The notion of R : |= E : Ŵ for a set Ŵ is defined in the natural manner.

To illustrate these notions in a simple setting, we state the following easily verified result (see Exercise 10.10).

Proposition 10.2.4
Let (R[U ], ) be a relation schema where is a set of fd’s and
mvd’s, and let V ⊆ U . Then
(a) R : |= [πV (R)] : X → A iff |= X → A and XA ⊆ V .

(b) R : |= [πV (R)] : X →
→ Y iff |= X →
→ Z for some X ⊆ V and Y = Z ∩ V .

Given a database schema R, a family of tagged full dependencies over R, a view
222
A Larger Perspective
expression E mapping R to S[V ], and a full dependency γ , is it decidable whether R : |= E : γ ? If E ranges over the full relational algebra, the answer is no, even if the only dependencies considered are fd’s.

Theorem 10.2.5
It is undecidable, given database schema R, tagged fd’s , algebra expression E : R → S and fd σ over S, whether R : |= E : σ .

Proof
Let R = {R[U ], S[U ]}, σ = R : ∅ → U and = {σ }. Given two algebra expressions E1, E2 : S → R, consider
E = R ∪ [E1(S) − E2(S)] ∪ [E2(S) − E1(S)]
Then R : |= E : σ iff E1 ≡ E2. This is undecidable by Corollary 6.3.2.

In contrast, we now present a decision procedure, based on the chase, for inferring view dependencies when the view is defined using the SPCU algebra.

Theorem 10.2.6
It is decidable whether R : |= E : γ , if E is an SPCU query and
∪ {γ } is a set of (tagged) full dependencies.

Crux
We prove the result for SPC queries that do not involve constants, and leave the extension to include union and constants for the reader (Exercise 10.12).

Let E : R → S[V ] be an SPC expression, where S ∈ R. Recall from Chapter 4 (Theorem 4.4.8; see also Exercise 4.18) that for each such expression E there is a tableau mapping τE = (T, t) equivalent to E.

Assume now that is a set of full dependencies and γ a full tgd. (The case where γ is an egd is left for the reader.) Let the tgd γ over S be expressed as the tableau (W, w). Create a new free instance Z out of (T, t) and W as follows: For each tuple u ∈ W , set Tu = ν(T) where valuation ν maps t to u, and maps all other variables in T to new distinct variables.

Set Z = ∪u∈W Tu. It can now be verified that R : |= E : γ iff w ∈ E( chase(Z, )).

In the case where ∪ {γ } is a set of fd’s and mvd’s and the view is defined by an SPCU
expression, testing the implication of a view dependency can be done in polynomial time, if jd’s are involved the problem is np-complete, and if full dependencies are considered the problem is exptime-complete.

Recall from Section 8.4 that a satisfaction family is a family sat(R, ) for some set of dependencies. Suppose now that SPC expression E : R[U ] → S[V ] is given, and that is a set of full dependencies over R. Theorem 10.2.6, suitably generalized, shows that the family Ŵ of full dependencies implied by for view E is recursive. This raises the natural question: Does E( sat(R, )) = sat(Ŵ), that is, does Ŵ completely characterize the image of sat(R, ) under E? The affirmative answer to this question is stated next. This result follows from the proof of Theorem 10.2.6 (see Exercise 10.13).

10.2 The Chase Revisited
223
Theorem 10.2.7
If is a set of full dependencies over R and E : R → S is an SPC
expression without constants, then there is a set Ŵ of full dependencies over S such that E( sat(R, )) = sat(S, Ŵ).

Suppose now that E : R[U ] → S[V ] is given, and is a finite set of dependencies.

Can a finite set Ŵ be found such that E( sat(R, )) = sat(S, Ŵ)? Even in the case where E is a simple projection and is a set of fd’s, the answer to this question is sometimes negative (Exercise 10.11c).

Chasing with Embedded Dependencies
We now turn to the case of (embedded) dependencies. From Theorem 10.1.2(b), it is apparent that we cannot hope to generalize Theorem 10.2.2 to obtain a decision procedure for (finite or unrestricted) implication of dependencies. As initially discussed in Chapter 9, the chase need not terminate if dependencies are used. All is not lost, however, because we are able to use the chase to obtain a proof procedure for testing unrestricted implication of a dependency by a set of dependencies.

For nonfull tgd’s, we shall use the following rule. We present the rule as it applies to tableaux, but it can also be used on dependencies.

tgd rule: Let T be a tableau, and let σ = (S, S′) be a tgd. Suppose that there is a valuation θ for S that embeds S into T , but no extension θ ′ to var(S) ∪ var(S′) of θ such that θ ′(S′) ⊆ T . In this case σ can be applied to T .

Let θ1, . . . , θn be a list of all valuations having this property. For each i ∈ [1, n], (nondeterministically) choose a distinct extension, i.e., an extension θ ′ to var(S) ∪
i
var(S′) of θi such that each variable in var(S′) − var(S) is assigned a distinct new variable greater than all variables in T . (The same variable is not chosen in two extensions θ ′, θ ′ , i = j .)

i
j
The result of applying σ to T is T ∪ {θ ′(S′) | i ∈ [1, n]}.

i
This rule is nondeterministic because variables not occurring in T are chosen for the existentially quantified variables of σ . We assume that some fixed mechanism is used for selecting these variables when given T , (S, S′), and θ .

The notion of a chasing sequence T = T1, T2, . . . of a tableau (or dependency) by a set of dependencies is now defined in the obvious manner. Clearly, this sequence may be infinite.

Example 10.2.8
Let = {τ1, τ2, τ3}, where
A
B
C
D
A
B
C
D
A
B
C
D
T
w
x
T′
w
y
z
T′′
x
z
w
y
x
y
x
z′
t
x
y
t′
w
x
z
z = z′
τ
τ
1
2
τ3
224
A Larger Perspective
A
B
C
D
A
B
C
D
x 1
x 2
x 3
x 4
x 1
x 2
x 3
x 4
x 1
x 5
x 6
x 7
x 1
x 5
x 6
x 7
x 10 x 2
x 6
x 12 application
x 10 x 2
x 6
x 4
application
x 11 x 5
x 3
x 13 of τ1
x 11 x 5
x 3
x 7
of τ3
(a)
(b)
A
B
C
D
A
B
C
D
x 1
x 2
x 3
x 4
x 1
x 2
x 3
x 4
x 1
x 5
x 6
x 7
x 1
x 5
x 6
x 4
x 10 x 2
x 6
x 4
x 10 x 2
x 6
x 4
x 11 x 5
x 3
x 7
x 11 x 5
x 3
x 4
x 1
x 5
x 20 x 4
x 1
x 5
x 20 x 4
x 11 x 2
x 21 x 7
x 11 x 2
x 21 x 4
x 1
x 2
x 22 x 7
application
x 1
x 2
x 22 x 4
application
x 10 x 5
x 23 x 4
of τ2
x 10 x 5
x 23 x 4
of τ3
(c)
(d)
Figure 10.3:
Parts of a chasing sequence
We show here only the relevant variables of τ1, τ2, and τ3; all other variables are assumed to be distinct. Here τ3 ≡ B → D.

In Fig. 10.3, we show some stages of a chasing sequence that demonstrates that
|=unr A → D. To do that, the chase begins with the tableau { x1, x2, x3, x4, x1, x5, x6, x7}. Figure 10.3 shows the results of applying τ1, τ3, τ2, τ3 in turn (left to right). This sequence implies that |=unr A → D, because variables x4 and x7 are identified.

Consider now the typed tgd’s:
A
B
C
D
A
B
C
D
T′′′
w
x
z
T′′′′
w
x
w
y
w
y
t′′
x
y
z
t′′′
w
x
y
τ
τ
4
5
10.2 The Chase Revisited
225
The chasing sequence of Fig. 10.3 also implies that |=unr τ4, because (x10, x2, x6, x4) is in the second tableau. On the other hand, we now argue that |=unr τ5. Consider the chasing sequence beginning as the one shown in Fig. 10.3, and continuing by applying the sequence τ1, τ3, τ2, τ3 repeatedly. It can be shown that this chasing sequence will not terminate and that (x1, x2, x6, v) does not occur in the resulting infinite sequence for any variable v (see Exercise 10.16). It follows that |=unr τ5; in particular, the infinite result of the chasing sequence is a counterexample to this implication. On the other hand, this chasing sequence does not alone provide any information about whether |=fin τ5. It can be shown that this also fails.

To ensure that all relevant dependencies have a chance to influence a chasing sequence, we focus on chasing sequences that satisfy the following conditions: (1) Whenever an egd is applied, it is applied repeatedly until it is no longer applicable.

(2) No dependency is “starved” (i.e., each dependency that is applicable infinitely often is applied infinitely often).

Even if these conditions are satisfied, it is possible to have two chasing sequences of a tableau T by typed dependencies, where one is finite and the other infinite (see Exercise 10.14).

Now consider an infinite chasing sequence T1 = T , T2, . . . . Let us denote it by T , .

Because egd’s may be applied arbitrarily late in T , , for each n, tuples of Tn may be modified as the result of later applications of egd’s. Thus we cannot simply take the union of some tail Tn, Tn+1, . . . to obtain the result of the chase. As an alternative, for the chasing sequence T , = T1, T2, . . . , we define
chase(T , ) = {u | ∃n ∀m > n(u ∈ Tm)}.

This is nonempty because (1) the “new” variables introduced by the tgd rule are always greater than variables already present; and (2) when the egd rule is applied, the newer variable is replaced by the older one.

By generalizing the techniques developed, it is easily seen that the (possibly infinite) resulting tableau satisfies all dependencies in . More generally, let be a set of dependencies and σ a dependency. Then one can show that |=unr σ iff for some chasing sequence σ, of σ using , chase(σ, ) is trivial. Furthermore, it can be shown that
• if for some chasing sequence σ, of σ using , chase(σ, ) is trivial, then it is so for all chasing sequences of σ using ; and
• for each chasing sequence σ, = T1, . . . , Tn, . . . of σ using , chase(σ, ) is trivial iff Ti is trivial for some i.

This shows that, for practical purposes, it suffices to generate some chasing sequence of σ
using and stop as soon as some tableau in the sequence becomes trivial.

226
A Larger Perspective
10.3
Axiomatization
A variety of axiomatizations have been developed for the family of dependencies and for subclasses such as the full typed tgd’s. In view of Theorem 10.1.2, sound and complete recursively enumerable axiomatizations do not exist for finite implication of dependencies.

This section presents an axiomatization for the family of full typed tgd’s and typed egd’s (which is sound and complete for both finite and unrestricted implication). A generalization to the embedded case (for unrestricted implication) has also been developed (see Exercise 10.21). The axiomatization presented here is closely related to the chase. In the next section, a very different kind of axiomatization for typed dependencies is discussed.

We now focus on the full typed dependencies (i.e., on typed egd’s and full typed tgd’s). The development begins with the introduction of a technical tool for forming the composition of tableaux queries. The axiomatization then follows.

Composition of Typed Tableaux
Suppose that τ = (T , t) and σ = (S, s) are two full typed tableau queries over relation schema R. It is natural to ask whether there is a tableau query τ • σ corresponding to the composition of τ followed by σ —that is, with the property that for each instance I over R, (τ • σ )(I ) = σ (τ (I ))
and, if so, whether there is a simple way to construct it. We now provide an affirmative answer to both questions. The syntactic composition of full typed tableau mappings will be a valuable tool for combining pairs of full typed tgd’s in the axiomatization presented shortly.

Let T = {t1, . . . , tn} and S = {s1, . . . , sm}. Suppose that tuple w is in σ (τ (I )). Then there is an embedding ν of s1, . . . , sm into τ (I ) such that ν(s) = w. It follows that for each j ∈ [1, m] there is an embedding µj of T into I , with µj (t) = ν(sj ). This suggests that the tableau of τ • σ should have mn tuples, with a block of n tuples for each sj .

To be more precise, for each j ∈ [1, m], let Ts be θ
j
j (T ), where θj is a substitution that
maps t (A) to sj (A) for each attribute A of R and maps each other variable of T to a new, distinct variable not used elsewhere in the construction. Now set
[S](T , t) ≡ ∪{Ts | j ∈ [1, m]} and τ • σ ≡ ([S](T , t), s).

j
The following is now easily verified (see Exercise 10.18):
Proposition 10.3.1
For full typed tableau queries τ and σ over R, and for each instance I of R, τ • σ (I ) = σ (τ (I )).

Example 10.3.2
The following table shows two full typed tableau queries and their
composition.

10.3 Axiomatization
227
A
B
C
A
B
C
A
B
C
T
x
y
z′
S
u
v
w′
u
v
p 1
x
y′
z
u′
v
w
u
p
w′
2
x
y′
z′′
s
u
v
w
u
p
p
2
3
t
w
x
y
u′
v
p 4
u′
p
w
5
u′
p
p
5
6
u
v
w
τ
σ
τ • σ
It is straightforward to verify that the syntactic operation of composition is associative.

Suppose that τ and σ are full typed tableau queries. It can be shown by simple chasing arguments that {τ, σ } and {τ • σ } are equivalent as sets of dependencies. It follows that full typed tgd’s are closed under finite conjunction, in the sense that each finite set of full typed tgd’s over a relation schema R is equivalent to a single full typed tgd. This property does not hold in the embedded case (see Exercise 10.20).

An Axiomatization for Full Typed Dependencies
For full typed tgd’s, τ = (T , t) and σ = (S, s), we say that τ embeds into σ denoted τ ֒→ σ , if there is a substitution ν such that ν(T ) ⊆ S and ν(t) = s. Recall from Chapter 4
that τ ⊇ σ (considered as tableau queries) iff τ ֒→ σ . As a result we have that if τ ֒→ σ , then τ |= σ , although the converse does not necessarily hold. Analogously, for A-egd’s τ = (T , x = y) and σ = (S, v = w), we define τ ֒→ σ if there is a substitution ν such that ν(T ) ⊆ S, and ν({x, y}) = {v, w}. Again, if τ ֒→ σ , then τ |= σ .

We now list the axioms for full typed tgd’s:
FTtgd1: (triviality) For each free tuple t without constants, ({t}, t).

FTtgd2: (embedding) If τ and τ ֒→ σ , then σ .

FTtgd3: (composition) If τ and σ , then τ • σ .

The following rules focus exclusively on typed egd’s:
Tegd1: (triviality) If x ∈ var(T ), then (T , x = x).

Tegd2: (embedding) If τ and τ ֒→ σ , then σ .

The final rules combining egd’s and full typed tgd’s use the following notation. Let R[U ] be a relation schema. For A ∈ U , A denotes U − {A}. Given typed A-egd τ =
(T , x = y) over R, define free tuples ux, uy such that ux(A) = x, uy(A) = y and ux[A] =
uy[A] consists of distinct variables not occurring in T . Define two full typed tgd’s τx =
(T ∪ {uy}, ux) and τy = (T ∪ {ux}, uy).

228
A Larger Perspective
FTD1: (conversion) If τ = (T , x = y), then τx and τy.

FTD2: (composition) If (T , t) and (S, x = y), then ([S](T , t), x = y).

We now have the following:
Theorem 10.3.3
The set {FTtgd1, FTtgd2, FTtgd3, Tegd1, Tegd2, FTD1, FTD2}
is sound and complete for (finite and unrestricted) logical implication of full typed dependencies.

Crux
Soundness is easily verified. We illustrate completeness by showing that the FTtgd rules are complete for tgd’s. Suppose that |= τ = (T , t), where is a set of full typed tgd’s and (T , t) is full and typed. By Theorem 10.2.2 there is a chasing sequence of T by yielding T ′ with t ∈ T ′. Let σ1, . . . , σn (n ≥ 0) be the sequence of elements of used in the chasing sequence. It follows that t ∈ σn(. . . (σ1(T ) . . .), and by Proposition 10.3.1, t ∈ (σ1 • · · · • σn)(T ). This implies that (σ1 • · · · • σn) ֒→ (T , t). A proof of τ from is now obtained by starting with σ1 (or ({s}, s) if n = 0), followed by n − 1 applications of FTtgd3 and one application of FTtgd2 (see Exercise (10.18b).

The preceding techniques and the chase can be used to develop an axiomatization of unrestricted implication for the family of all typed dependencies.

10.4
An Algebraic Perspective
This section develops a very different paradigm for specifying dependencies based on the use of algebraic expressions. Surprisingly, the class of dependencies formed is equivalent to the class of typed dependencies. We also present an axiomatization that is rooted primarily in algebraic properties rather than chasing and tableau manipulations.

We begin with examples that motivate and illustrate this approach.

Example 10.4.1
Let R[ ABCD] be a relation schema. Consider the tgd τ of Fig. 10.4 and the algebraic expression
π AC(π AB(R) ⊲⊳ π BC(R)) ⊆ π AC(R).

It is straightforward to verify that for each instance I over ABCD, I |= τ iff π AC(π AB(I ) ⊲⊳ π BC(I )) ⊆ π AC(I ).

Now consider dependency σ . One can similarly verify that for each instance I over ABCD,
I |= σ iff π AC(π AB(I ) ⊲⊳ π BC(I )) ⊆ π AC(π AD(I ) ⊲⊳ π CD(I )).

10.4 An Algebraic Perspective
229
A
B
C
D
A
B
C
D
T
x
y′
S
x
y′
y′
z
y′
z
t
x
z
S′
x
w′
z
w′
τ
σ
Figure 10.4:
Dependencies of Example 10.4.1
The observation of this example can be generalized in the following way. A project-join (PJ) expression is an algebraic expression over a single relation schema using only projection and natural join. We describe next a natural recursive algorithm for translating PJ expressions into tableau queries (see Exercise 10.23). (This algorithm is also implicit in the equivalence proofs of Chapter 4.)

Algorithm 10.4.2
Input: a PJ expression E over relation schema R[A1, . . . , An]
Output: a tableau query (T , t) equivalent to E
Basis: If E is simply R, then return ({ x1, . . . , xn}, x1, . . . , xn).

Inductive steps:
1. If E is πX(q) and the tableau query of q is (T , t), then return (T , πX(t)).

2. Suppose E is q1 ⊲⊳ q2 and the tableau query of qi is (Ti, ti) for i ∈ [1, 2].

Let X be the intersection of the output sorts of q1 and q2. Assume without loss of generality that the two tableaux use distinct variables except that t1(A) = t2(A) for A ∈ X. Then return (T1 ∪ T2, t1 ⊲⊳ t2).

Suppose now that (T , T ′) is a typed dependency with the property that for some free tuple t, (T , t) is the tableau associated by this algorithm with PJ expression E, and (T ′, t) is the tableau associated with PJ expression E′. Suppose also that the only variables common to T and T ′ are those in t. Then for each instance I , I |= (T , T ′) iff E(I ) ⊆ E′(I ).

This raises three natural questions: (1) Is the family of PJ inclusions equivalent to the set of typed tgd’s? (2) If not, can this paradigm be extended to capture all typed tgd’s? (3) Can this paradigm be extended to capture typed egd’s as well as tgd’s?

The answer to the first question is no (see Exercise 10.24).

The answer to the second and third questions is yes. This relies on the notion of extended relations and extended project-join expressions. Let R[A1, . . . , An] be a relation schema. For each i ∈ [1, n], we suppose that there is an infinite set of attributes A1, A2, . . . , called copies of A
i
i
i . The extended schema of R is the schema
R[A1, . . . , A1
, . . . , A2
1
n, A2
1
n, . . .]. For an instance I of R, the extended instance of R corresponding to
j
I , denoted I , has one “tuple” u for each tuple u ∈ I , where u(A ) = u(A i
i ) for
each i ∈ [1, n] and j > 0.

An extended project-join expression over R is a PJ expression over R such that a
230
A Larger Perspective
A
B
C
D
A
B
C
D
T
x
z
w′
T
x
z
w′
z′
w′
z′
w′
x′
z′
w
x′
z′
w
T′
x
y′
x = x′
y′
z
w
τ
σ
Figure 10.5:
tgd and egd of Example 10.4.3
projection operator is applied first to each occurrence of R. (This ensures that the evaluation and the result of such expressions involve only finite objects.) Given two extended PJ
expressions E and E′ with the same target sort, and instance I over R, E(I ) ⊆e E′(I ) denotes E(I ) ⊆ E′(I ).

An algebraic dependency is a syntactic expression of the form E ⊆e E′, where E and E′ are extended PJ expressions over a relation schema R with the same target sort. An instance I over R satisfies E ⊆e E′ if E(I ) ⊆e E′(I )—that is, if E(I ) ⊆ E′(I ).

This is illustrated next.

Example 10.4.3
Consider the dependency τ of Fig. 10.5. Let
E = π ACD 1(R) ⊲⊳ πC1D1(R) ⊲⊳ πA1C1D(R).

Here we use A, A1, . . . to denote different copies the attribute A, etc.

It can be shown that, for each instance I over ABCD, I |= τ iff E1(I ) ⊆e E2(I ), where E1 = π ACD(E)
E2 = π ACD(π AB 1(R) ⊲⊳ πB1 CD(R)).

(See Exercise 10.25).

Consider now the functional dependency A → BC over ABCD. This is equivalent to π ABC(R) ⊲⊳ π AB 1C1(R) ⊆e π ABCB 1C1(R).

Finally, consider σ of Fig. 10.5. This is equivalent to F1 ⊆e F2, where F1 = π AA 1(E)
F2 = π AA 1(R).

We next see that algebraic dependencies correspond precisely to typed dependencies.

Theorem 10.4.4
For each algebraic dependency, there is an equivalent typed depen-
dency, and for each typed dependency, there is an equivalent algebraic dependency.

10.4 An Algebraic Perspective
231
Crux
Let R[A1, . . . , An] be a relation schema, and let E ⊆e E′ be an algebraic dependency over R, where E and E′ have target sort X. Without loss of generality, we can assume that there is k such that the sets of attributes involved in E and E′ are contained in
U = {A1, . . . , A1
, . . . , Ak}. Using Algorithm 10.4.2, construct tableau queries
1
n, . . . , Ak
1
n
τ = (T , t ) and τ ′ = (T ′, t′) over
U corresponding to E and E′. We assume without loss of
generality that τ and τ ′ do not share any variables except that t (A) = t′(A) for each A ∈ X.

Consider T (over
U ). For each tuple s ∈ T and j ∈ [1, k],
• construct an atom
j
R(x1, . . . , xn), where xi = s(A ) for each i ∈ [1, n];
i
• construct atoms
j
j ′
s(A ) = s(A ) for each i ∈ [1, n] and j, j ′ satisfying
i
i
1 ≤ j < j ′ ≤ k.

Let ϕ(x1, . . . , xp) be the conjunction of all atoms obtained from τ in this manner. Let ψ (y1, . . . , yq) be constructed analogously from τ ′. It can now be shown (Exercise 10.26) that E ⊆e E′ is equivalent to the typed dependency
∀x1 . . . xp(ϕ(x1, . . . , xp) → ∃z1 . . . zrψ(y1, . . . , yq)),
where z1, . . . , zr is the set of variables in {y1, . . . , yq} − {x1, . . . , xp}.

For the converse, we generalize the technique used in Example 10.4.3. For each attribute A, one distinct copy of A is used for each variable occurring in the A column.

An Axiomatization for Algebraic Dependencies
Figure 10.6 shows a family of inference rules for algebraic dependencies. Each of these rules stems from an algebraic property of join and project, and only the last explicitly uses a property of extended instances. (It is assumed here that all expressions are well formed.) The use of these rules to infer dependencies is considered in Exercises 10.31, and 10.32.

It can be shown that:
Theorem 10.4.5
The family {AD1, . . . , AD8} is sound and complete for inferring
unrestricted implication of algebraic dependencies.

To conclude this discussion of the algebraic perspective on dependencies, we consider a new operation, direct product, and the important notion of faithfulness.

Faithfulness and Armstrong Relations
We show now that sets of typed dependencies have Armstrong relations,1 although these may sometimes be infinite. To accomplish this, we first introduce a new way to combine instances and an important property of it.

1 Recall that given a set of dependencies over some schema R, an Armstrong relation for is an instance I over R that satisfies and violates every dependency not implied by .

232
A Larger Perspective
AD1: (Idempotency of Projection)
(a) πX(πY E) =e πXE
(b) π sort(E)E =e E
AD2: (Idempotency of Join)
(a) E ⊲⊳ πXE =e E
(b) π sort(E)(E ⊲⊳ E′) ⊆e E
AD3: (Monotonicity of Projection)
If E ⊆e E′ then πXE ⊆e πXE′
AD4: (Monotonicity of Join)
If E ⊆e E′, then E ⊲⊳ E′′ ⊆e E′ ⊲⊳ E′′
AD5: (Commutativity of Join)
E ⊲⊳ E′ =e E′ ⊲⊳ E
AD6: (Associativity of Join)
(E ⊲⊳ E′) ⊲⊳ E′′ =e E ⊲⊳ (E′ ⊲⊳ E′′)
AD7: (Distributivity of Projection over Join)
Suppose that X ⊆ sort(E) and Y ⊆ sort(E′). Then
(a) πX∪Y (E ⊲⊳ E′) ⊆e πX∪Y (E ⊲⊳ πY E′).

(b) If sort(E) ∩ sort(E′) ⊆ Y , then equality holds in (a).

AD8: (Extension)
If X ⊆ sort(R) and A, A′ are copies of the same attribute, then πAA′R ⊲⊳ πAXR =e πAA′XR.

Figure 10.6:
Algebraic dependency axioms
Let R be a relation schema of arity n. We blur our notation and use elements of dom × dom as if they were elements of dom. Given tuples u = x1, . . . , xn and v =
y1, . . . , yn, we define the direct product of u and v to be u ⊗ v = (x1, y1), . . . , (xn, yn).

The direct product of two instances I, J over R is
I ⊗ J = {u ⊗ v | u ∈ I, v ∈ J }.

This is generalized to form k-ary direct product instances for each finite k. Furthermore, if J is a (finite or infinite) index set and {Ij | j ∈ J } is a family of instances over R, then
⊗{Ij | j ∈ J } denotes the (possibly infinite) direct product of this family of instances.

A dependency σ is faithful if for each family {Ij | j ∈ J } of nonempty instances,
⊗{Ij | j ∈ J } |= σ if and only if ∀j ∈ J , Ij |= σ.

(The restriction that the instances be nonempty is important—if this were omitted then no nontrivial dependency would be faithful.)

The following holds because the ⊗ operator commutes with project, join, and “extension” (see Exercise 10.29).

Bibliographic Notes
233
Proposition 10.4.6
The family of typed dependencies is faithful.

We can now prove that each set of typed dependencies has an Armstrong relation.

Theorem 10.4.7
Let be a set of typed dependencies over relation R. Then there is a (possibly infinite) instance I such that for each typed dependency σ over R, I |= σ iff
|=unr σ .

Proof
Let Ŵ be the set of typed dependencies over R not in ∗. For each γ ∈ Ŵ, let Iγ be a nonempty instance that satisfies but not γ . Then ⊗{Iγ | γ ∈ Ŵ} is the desired relation.

This result cannot be strengthened to yield finite Armstrong relations because one can exhibit a finite set of typed tgd’s with no finite Armstrong relation.

Bibliographic Notes
The papers [FV86, Kan91, Var87] all provide excellent surveys on the motivations and history of research into relational dependencies; these have greatly influenced our treatment of the subject here.

Because readers could be overwhelmed by the great number of dependency theory terms we have used a subset of the terminology. For instance, the typed single-head tgd’s (that were studied in depth) are called template dependencies. In addition, the typed unirelational dependencies that are considered here were historically called embedded implicational dependencies (eid’s); and their full counterparts were called implicational dependencies (id’s). We use this terminology in the following notes.

After the introduction of fd’s and mvd’s, there was a flurry of research into special classes of dependencies, including jd’s and ind’s. Embedded dependencies were first introduced in [Fag77b], which defined embedded multivalued dependencies (emvd’s); these are mvd’s that hold in a projection of a relation. Embedded jd’s are defined in the analogous fashion. This is distinct from projected jd’s [MUV84]—these are template dependencies that correspond to join dependencies, except that some of the variables in the summary row may be distinct variables not occurring elsewhere in the dependency. Several other specialized dependencies were introduced. These include subset dependencies [SW82], which generalize mvd’s; mutual dependencies [Nic78], which say that a relation is a 3-ary join; generalized mutual dependencies [MM79]; transitive dependencies [Par79], which generalize fd’s and mvd’s; extended transitive dependencies [PPG80], which generalize mutual dependencies and transitive dependencies; and implied dependencies [GZ82], which form a specialized class of egd’s. In many cases these classes of dependencies were introduced in attempts to provide axiomatizations for the emvd’s, jd’s, or superclasses of them. Although most of the theoretical work studies dependencies in an abstract setting, [Sci81, Sci83] study families of mvd’s and ind’s as they arise in practical situations.

The proliferation of dependencies spawned interest in the development of a unifying framework that subsumed essentially all of them. Nicolas [Nic78] is credited with first observing that fd’s, mvd’s, and others have a natural representation in first-order logic. At
234
A Larger Perspective
roughly the same time, several researchers reached essentially the same generalized class of dependencies that was studied in this chapter. [BV81a] introduced the class of tgd’s and egd’s, defined using the paradigm of tableaux. Chasing was studied in connection with both full and embedded dependencies in [BV84c]. Reference [Fag82b] introduced the class of typed dependencies, essentially the same family of dependencies but presented in the paradigm of first-order logic. Simultaneously, [YP82] introduced the algebraic dependencies, which present the same class in algebraic terms. A generalization of algebraic dependencies to the untyped case is presented in [Abi83].

Related general classes of dependencies introduced at this time are the general dependencies [PJ81], which are equivalent to the full typed tgd’s, and generalized dependency constraints [GJ82], which are the full dependencies.

Importantly, several kinds of constraints that lie outside the dependencies described in this chapter have been studied in the literature. Research on the use of arbitrary first-order logic sentences as constraints includes [GM78, Nic78, Var82b]. A different extension of dependencies based on partitioning relationships, which are not expressible in first-order logic, is studied in [Cos87]. Another kind of dependency is the afunctional dependency of
[BP83], which, as the name suggests, focuses on the portions of an instance that violate an fd. The partition dependencies [CK86] are not first-order expressible and are powerful; interestingly, finite and unrestricted implication coincide for this class of dependencies and are decidable in ptime. Order [GH83] and sort-set dependencies [GH86] address properties of instances defined in terms of orderings on the underlying domain elements. There is provably no finite axiomatization for order dependencies, or for sort-set dependencies and fd’s considered together (Exercise 9.8).

Another broad class of constraints not included in the dependencies discussed in this chapter is dynamic constraints, which focus on how data change over time [CF84, Su92, Via87, Via88]; see Section 22.6.

As suggested by the development of this chapter, one of the most significant theoretical directions addressed in connection with dependencies has been the issue of decidability of implication. The separation of finite and unrestricted implication, and the undecidability of the implication problem, were shown independently for typed dependencies in [BV81a, CLM81]. Subsequently, these results were independently strengthened to projected jd’s in
[GL82, Var84, YP82]. Then, after nearly a decade had elapsed, this result was strengthened to include emvd’s [Her92].

On the other hand, the equivalence of finite and unrestricted implication for full dependencies was observed in [BV81a]. That deciding implication for full typed dependencies is complete in exptime is due to [CLM81]. See also [BV84c, FUMY83], which present numerous results on full and embedded typed dependencies. The special case of deciding implication of a typed dependency by ind’s has been shown to be pspace-complete
[JK84b].

The issue of inferring view dependencies was first studied in [Klu80], where Theorem 10.2.5 was presented. Reference [KP82] developed Theorem 10.2.6.

The issue of attempting to characterize view images of a satisfaction family as a satisfaction family was first raised in [GZ82], where Exercise 10.11b was shown. Theorem 10.2.7 is due to [Fag82b], although a different proof technique was used there. Reference [Hul84] demonstrates that some projections of satisfaction families defined by fd’s
Exercises
235
cannot be characterized by any finite set of full dependencies (see Exercise 10.11c,d).

That investigation is extended in [Hul85], where it is shown that if is a family of fd’s over U and V ⊆ U , and if πV ( sat(U, )) = sat(V , Ŵ) for any set Ŵ of fd’s, then πV ( sat(U, )) = sat(V , Ŵ) for any finite set Ŵ of full dependencies.

Another primary thrust in the study of dependencies has been the search for axiomatizations for various classes of dependencies. The axiomatization presented here for full typed dependencies is due to [BV84a], which also provides an axiomatization for the embedded case. The axiomatization for algebraic dependencies is from [YP82]. An axiomatization for template dependencies is given in [SU82] (see Exercise 10.22). Research on axiomatizations for jd’s is described in the Bibliographic Notes of Chapter 8.

The direct product construction is from [Fag82b]. Proposition 10.4.6 is due to
[Fag82b], and the proof presented here is from [YP82]. A finite set of tgd’s with no finite Armstrong relation is exhibited in [FUMY83]. The direct product has also been used in connection with tableau mappings and dependencies [FUMY83] (see Exercise 10.19).

The direct product has been studied in mathematical logic; the notion of (upward) faithful presented here (see Exercise 10.28) is equivalent to the notion of “preservation under direct product” found there (see, e.g., [CK73]); and the notion of downward faithful is related to, but distinct from, the notion of “preservation under direct factors.”
Reference [MV86] extends the work on direct product by characterizing the expressive power of different families of dependencies in terms of algebraic properties satisfied by families of instances definable using them.

Exercises
Exercise 10.1
(a) Show that for each first-order sentence of the form (∗) of Section 10.1, there exists an equivalent finite set of dependencies.

(b) Show that each dependency is equivalent to a finite set of egd’s and tgd’s.

Exercise 10.2
Consider the tableaux in Example 10.3.2. Give σ • σ . Compare it (as a mapping) to σ . Give σ • τ . Compare it (as a mapping) to τ • σ .

Exercise 10.3
[DG79] Let ϕ be a first-order sentence with equality but no function symbols that is in prenex normal form and has quantifier structure ∃∗∀∗. Prove that ϕ has an unrestricted model iff it has a finite model.

Exercise 10.4
This exercise concerns the dependencies of Fig. 10.2.

(a) Show that (S, x = z) and (S′, x = z) are equivalent.

(b) Show that (T , t) and (T ′, t) are equivalent, but that (T , t) ⊂ (T ′, t) as tableau queries.

Exercise 10.5
Let R[ ABC] be a relation scheme. We construct a family of egd’s over R as follows. For n ≥ 0, let
Tn = { xi, yi, z2i, xi, yi+1, z2i+1 | i ∈ [0, n]}
and set τn = (Tn, z0 = z2n+1). Note that τ0 ≡ A → C.

236
A Larger Perspective
(a) Prove that as egd’s, τi ≡ τj for all i, j > 0.

(b) Prove that τ0 |= τ1, but not vice versa.

Exercise 10.6
(a) [FUMY83] Prove that there are exactly three distinct (up to equivalence) full typed single-head tgd’s over a binary relation. Hint: See Exercise 10.4.

(b) Prove that there is no set of single-head tgd’s that is equivalent to the typed tgd (T1, T2) of Fig. 10.2.

(c) Exhibit an infinite chain τ1, τ2, . . . of typed tgd’s over a binary relation where each is strictly weaker than the previous (i.e., such that τi |= τi+1 but τi+1 |= τi for each i ≥ 1).

⋆ Exercise 10.7 [FUMY83] Let U = {A1, . . . , An} be a set of attributes.

(a) Consider the full typed single-head tgd (full template dependency) τ strongest =
({t1, . . . , tn}, t), where ti(Ai) = t (Ai) for i ∈ [1, n], and all other variables used are distinct. Prove that τ strongest is the “strongest” template dependency for U , in the sense that for each (not necessarily full) template dependency τ over U , τ strongest |= τ .

(b) Let τ weakest be the template dependency (S, s), where s(Ai) = xi for i ∈ [1, n] and where S includes all tuples s′ over U that satisfy (1) s′(Ai) = xi or yi for i ∈ [1, n], and (2) s′(Ai) = xi for at least one i ∈ [1, n]. Prove that τ weakest is the “weakest” full template dependency U , in the sense that for each nontrivial full template dependency τ over U , τ |= τ weakest.

(c) For V ⊆ U , a template dependency over U is V - partial if it can be expressed as a tableau (T , t), where t is over V . For V ⊆ U exhibit a “weakest” V -partial template dependency.

Exercise 10.8
[BV84c] Prove Theorems 10.2.1 and 10.2.2.

Exercise 10.9
Prove that the triviality problem for typed tgd’s is np-complete. Hint: Use a reduction from tableau containment (Theorem 6.2.3).

Exercise 10.10
(a) Prove Proposition 10.2.4.

(b) Develop an analogous result for the binary natural join.

Exercise 10.11
Let R[ ABCDE] and S[ ABCD] be relation schemas, and let V = ABCD. Consider = {A → E, B → E, CE → D}.

(a) Describe the set Ŵ of fd’s implied by on πV (R).

(b) [GZ82] Show that sat(πV (R, )) = sat(S, Ŵ). Hint: Consider the instance J =
{ a, b1,
c, d1, a, b, c1, d2, a1, b, c, d3} over S.

⋆ (c) [Hul84] Show that there is no finite set ϒ of full dependencies over S such that πV ( sat(R, )) = sat(S, ϒ) Hint: Say that a satisfaction family F over R has rank n if F = sat(R, Ŵ) for some Ŵ where the tableau in each dependency of Ŵ has ≤ n elements. Suppose that πV ( sat(R, )) has rank n. Exhibit an instance J over V with n + 1 elements such that (a) J ∈ πV ( sat(R, )), and (b) J satisfies each dependency σ that is implied for πV (R) by , and that has ≤ n elements in its tableau. Conclude that J ∈ sat(V , Ŵ), a contradiction.

Exercises
237
⋆ (d) [Hul84] Develop a result for mvd’s analogous to part (c).

Exercise 10.12
[KP82] Complete the proof of Theorem 10.2.6 for the case where is a set of full dependencies and γ is a full tgd. Show how to extend that proof (a) to the case where γ is an egd; (b) to include union; and (c) to permit constants in the expression E. Hint: For (a), use the technique of Theorem 8.4.12; for (b) use union of tableaux, but permitting multiple output rows; and for (c) recall Exercise 8.27b.

Exercise 10.13
[Fag82b] Prove Theorem 10.2.7.

Exercise 10.14
Exhibit a typed tgd τ and a set of typed dependencies such that |= τ , and there are two chasing sequences of τ by , both of which satisfy conditions (1) and (2), in the definition of chasing for embedded dependencies in Section 10.2, where one sequence is finite and the other is infinite.

Exercise 10.15
Consider these dependencies:
A
B
C
A
B
C
x
y
x
z
AC → B
x
z
y
z
y
z
x
y
τ
τ
1
2
τ3
(a) Starting with input T = { 1, 2, 3, 1, 4, 5}, perform four steps of the chase using these dependencies.

(b) Prove that {τ1, τ2, τ3} |=unr A → B.

⋆ Exercise 10.16
(a) Prove that the chasing sequence of Example 10.2.8 does not terminate; then use this sequence to verify that |=unr τ5.

(b) Show that |=fin τ5.

(c) Exhibit a set ′ of dependencies and a dependency σ ′ such that the chasing sequence of σ ′ with ′ is infinite, and such that ′ |=unr σ ′ but ′ |=fin σ ′.

♠ Exercise 10.17 [BV84c] Suppose that T , is a chasing sequence. Prove that chase(T , ) satisfies .

Exercise 10.18
[BV84a] (a) Prove Proposition 10.3.1. (b) Complete the proof of Theorem 10.3.3.

Exercise 10.19
[FUMY83] This exercise uses the direct product construction for combining full typed tableau mappings. Let R be a fixed relation schema of arity n. The direct product of free tuples and tableaux is defined as for tuples and instances. Given two full typed tgd’s τ = (T , t ) and τ ′ = (T ′, t′) over relation schema R, their direct product is τ ⊗ τ ′ = (T ⊗ T ′, t ⊗ t ′).

(a) Let τ, σ be full typed single-head tgd’s over R. Prove that τ ⊗ σ is equivalent to
{τ, σ }.

238
A Larger Perspective
(b) Are τ ⊗ σ and τ • σ comparable as tableau queries under ⊆, and, if so, how?

(c) Show that the family of typed egd’s that have equality atoms referring to the same column of R is closed under finite conjunction.

Exercise 10.20
[FUMY83]
(a) Let τ and τ ′ be typed tgd’s. Prove that τ |=unr τ ′ iff τ |=fin τ ′. Hint: Show that chasing will terminate in this case.

(b) Prove that there is a pair τ, τ ′ of typed tgd’s for which there is no typed tgd τ ′′
equivalent to {τ, τ ′}. Hint: Assume that typed tgd’s were closed under conjunction in this way. Use part (a).

⋆ Exercise 10.21 [BV84a] State and prove an axiomatization theorem for the family of typed dependencies.

Exercise 10.22
[SU82] Exhibit a set of axioms for template dependencies (i.e., typed single-head tgd’s), and prove that it is sound and complete for unrestricted logical implication.

Exercise 10.23
Prove that Algorithm 10.4.2 is correct. (See Exercise 4.18a).

Exercise 10.24
(a) Consider the full typed tgd
τ = ({ x, y′, x′, y′, x′, y}, x, y).

Prove that there is no pair E, E′ of (nonextended) PJ expressions such that τ is equivalent to E ⊆ E′ [i.e., such that I |= τ iff E(I ) ⊆ E′(I )].

(b) Let τ be as in Fig. 10.5. Prove that there is no pair E, E′ of (nonextended) PJ
expressions such that τ is equivalent to E ⊆ E′.

Exercise 10.25
In connection with Example 10.4.3,
(a) Prove that τ is equivalent to E1 ⊆e E2.

(b) Prove that A → BC is equivalent to π ABC(R) ⊲⊳ π AB 1C1(R) ⊆e π ABCB 1C1(R).

(c) Prove that σ is equivalent to F1 ⊆e F2.

⋆ Exercise 10.26 Complete the proof of Theorem 10.4.4.

Exercise 10.27
An extended PJ expression E is shallow if it has the form πX(R) or the form πX(πY (R) ⊲⊳ · · · ⊲⊳ π (R)). An algebraic dependency E ⊆
1
Yn
e E′ is shallow if E and E′ are
shallow. Prove that every algebraic dependency is equivalent to a shallow one.

Exercise 10.28
[Fag82b] A dependency σ is upward faithful (with respect to direct products) if, for each family of nonempty instances {Ij | j ∈ J },
∀j ∈ J , Ij |= σ implies ⊗ {Ij | j ∈ J } |= σ.

Analogously, σ is downward faithful if
⊗{Ij | j ∈ J } |= σ implies ∀j ∈ J , Ij |= σ.

Exercises
239
(a) Show that the constraint
∀x, y, y′, z, z′(R(x, y, z) ∧ R(x, y′, z′) → (y = y′ ∨ z = z′))
is downward faithful but not upward faithful.

(b) Show that the constraint
∀x, y, z(R(x, y) ∧ R(y, z) → R(x, z))
is upward faithful but not downward faithful.

Exercise 10.29
[Fag82b, YP82] Prove Proposition 10.4.6.

Exercise 10.30
[Fag82b] The direct product operator ⊗ is extended to instances of database schema R = {R1, . . . , Rn} by forming, for each i ∈ [1, n], a direct product of the relation instances associated with Ri. Let R = {P [A], Q[A]} be a database schema. Show that the empty set of typed dependencies over R has no Armstrong relation. Hint: Find typed dependencies σ1, σ2 over R such that ∅ |= (σ1 ∨ σ2) but ∅ |= σ1 and ∅ |= σ2.

⋆ Exercise 10.31 [YP82] Let R[ ABCD] be a relation schema. The pseudo-transitivity rule for multivalued dependencies (Chapter 8) implies, given A →
→ B and B →
→ C, that A →
→ C.

Express this axiom in the paradigm of algebraic dependencies. Prove it using axioms {AD1,
. . . , AD7} (without using extended relations).

⋆ Exercise 10.32 Infer the three axioms for fd’s from rules {A1, . . . , A8}.

Exercise 10.33
[YP82] Prove that {A1, . . . , A8} is sound.

11 DesignandDependencies
When the only tool you have is a hammer,
everything begins to look like a nail.

— Anonymous
Alice:
Will we use a hammer for schema design?

Riccardo:
Sure: decomposition, semantic modeling, . . .

Vittorio:
And each provides nails to which the data must fit.

Sergio:
The more intricate the hammer, the more intricate the nail.

We have discussed earlier applications of dependencies in connection with query optimization (Section 8.4) and user views (Section 10.2). In this chapter, we briefly consider how dependencies are used in connection with the design of relational database schemas.

The problem of designing database schemas is complex and spans the areas of cognitive science, knowledge representation, software practices, implementation issues, and theoretical considerations. Due to the interaction of these many aspects (some of them in-tegrally related to how people think and perceive the world), we can only expect a relatively narrow and somewhat simplistic contribution from theoretical techniques. As a result, the primary focus of this chapter is to introduce the kinds of formal tools that are used in the design process; a broader discussion of how to use these tools in practice is not attempted.

The interested reader is referred to the Bibliographic Notes, which indicate where more broad-based treatments of relational schema design can be found.

In the following discussion, designing a relational schema means coming up with a
“good” way of grouping the attributes of interest into tables, yielding a database schema.

The choice of a schema is guided by semantic information about the application data provided by the designer. There are two main ways to do this, and each leads to a different approach to schema design.

Semantic data model: In this approach (Section 11.1), the application data is first described using a model with richer semantic constructs than relations. Such models are called
“semantic data models.” The schema in the richer model is then translated into a relational schema. The hope is that the use of semantic constructs will naturally lead to specifying good schemas.

Refinement of relational schema: This approach (Section 11.2) starts by specifying an initial relational schema, augmented with dependencies (typically fd’s and mvd’s). The design process uses the dependencies to improve the schema. But what is it that makes 240
Design and Dependencies
241
one schema better than another? This is captured by the notion of “normal form” for relational schemas, a central notion in design theory.

Both of these approaches focus on the transformation of a schema S1 into a relational schema S2. Speaking in broad terms, three criteria are used to evaluate the result of this transformation:
(1) Preservation of data;
(2) Desirable properties of S2, typically described using normal forms; and (3) Preservation of “meta-data” (i.e., information captured by schema and dependencies).

Condition (1) requires that information not be lost when instances of S1 are represented in S2. This is usually formalized by requiring that there be a “natural” mapping τ : Inst(S1) →
Inst(S2) that is one-to-one. As we shall see, the notion of “natural” can vary, depending on the data model used for S1.

Criterion (2) has been the focus of considerable research, especially in connection with the approach based on refining relational schemas. In this context, the notion of relational schema is generalized to incorporate dependencies, as follows: A relation schema is a pair (R, ), where R is a relation name and is a set of dependencies over R. Similarly, a database schema is a pair (R, ), where R is a database schema as before, and is a set of dependencies over R. Some of these may be tagged by a single relation (i.e., have the form Rj : σ , where σ is a dependency over Rj ∈ R). Others, such as ind’s, may involve pairs of relations. More generally, some dependencies might range over the full set of attributes occurring in R. (This requires a generalization of the notion of dependency satisfaction, which is discussed in Section 11.3.)

With this notation established, we return to criterion (2). In determining whether one relational schema is better than another, the main factors that have been considered are redundancy in the representation of data and update anomalies. Recall that these were illustrated in Section 8.1, using the relations Movies and Showings. We concluded there that certain schemas yielded undesirable behavior. This resulted from the nature of the information contained in the database, as specified by a set of dependencies.

Although the dependencies are in some sense the cause of the problems, they also suggest ways to eliminate them. For example, the fd
Movies: Title → Director
suggests that the attribute Director is a characteristic of Title, so the two attributes belong together and can safely be represented in isolation from the other data. It should be clear that one always needs some form of semantic information to guide schema design; in the absence of such information, one cannot distinguish “good” schemas from “bad”
ones (except for trivial cases). As will be seen, the notion of normal form captures some characteristics of “good” schemas by guaranteeing that certain kinds of redundancies and update anomalies will not occur. It will also be seen that the semantic data model approach to schema design can lead to relational schemas in normal form.

242
Design and Dependencies
In broad terms, the intuition behind criterion (3) is that properties of data captured by schema S1 (e.g., functional or inclusion relationships) should also be captured by schema S2. In the context of refining relational schemas, a precise meaning will be given for this criterion in terms of “preservation” of dependencies. We shall see that there is a kind of trade-off between criteria (2) and (3).

The approach of refining relational schemas typically makes a simplifying assumption called the “pure universal relation assumption” (pure URA). Intuitively, this states that the input schema S1 consists of a single relation schema, possibly with some dependencies. Section 11.3 briefly considers this assumption in a more general light. In addition, the
“weak” URA is introduced, and the notions of dependency satisfaction and query interpretation are extended to this context.

This chapter is more in the form of a survey than the previous chapters, for several reasons. As noted earlier, more broad-based treatments of relational schema design may be found elsewhere and require a variety of tools complementary to formal analysis. The tools presented here can at best provide only part of the skeleton of a design methodology for relational schemas. Normal forms and the universal relation assumption were active research topics in the 1970s and early 1980s and generated a large body of results. Some of that work is now considered somewhat unfashionable, primarily due to the emergence of new data models. However, we mention these topics briefly because (1) they lead to interesting theoretical issues, and (2) we are never secure from a change of fashion.

11.1
Semantic Data Models
In this section we introduce semantic data models and describe how they are used in relational database design. Semantic data models provide a framework for specifying database schemas that is considerably richer than the relational model. In particular, semantic models are arguably closer than the relational model to ways that humans organize information in their own thinking. The semantic data models are precursors of the recently emerging object-oriented database models (presented in a more formal fashion in Chapter 21) and are thus of interest in their own right.

As a vehicle for our discussion, we present a semantic data model, called loosely the generic semantic model (GSM). (This is essentially a subset of the IFO model, one of the first semantic models defined in a formal fashion.) We then illustrate how schemas from this model can be translated into relational schemas. Our primary intention is to present the basic flavor of the semantic data model approach to relational schema design and some formal results that can be obtained. The presentation itself is somewhat informal so that the notation does not become overly burdensome.

In many practical contexts, the semantic model used is the Entity-Relationship model (ER model) or one of its many variants. The ER model is arguably the first semantic data model that appeared in the literature. We use the GSM because it incorporates several features of the semantic modeling literature not present in the ER model, and because the GSM presents a style closer to object-oriented database models.

11.1 Semantic Data Models
243
GSM Schemas
Figure 11.1 shows the schema CINEMA-SEM from the GSM, which can be used to represent information on movies and theaters. The major building blocks of such schemas are abstract classes, attributes, complex value classes, and the ISA hierarchy; these will be considered briefly in turn.

The schema of Fig. 11.1 shows five classes that hold abstract objects: Person, Director, Actor, Movie, and Theater. These correspond to collections of similar objects in the world. There are two kinds of abstract class: primary classes, shown using diamonds, and subclasses shown using circles. This distinction will be clarified further when ISA relationships are discussed.

Instances of semantic schemas are constructed from the usual printable classes (e.g., string, integer, float, etc.) and “abstract” classes. The printable classes correspond to (subsets of) the domain dom used in the relational model. The printable classes are indicated using squares; in Fig. 11.1 we have labeled these to indicate the kind of values that populate them. Conceptually, the elements of an abstract class such as Person are actual persons in the world; in the formal model internal representations for persons are used. These internal representations have come to be known as object identifiers (OIDs). Because they are internal, it is usually assumed that OIDs cannot be presented explicitly to users, although programming and query languages can use variables that hold OIDs. The notion of instance will be defined more completely later and is illustrated in Example 11.1.1 and Fig. 11.2.

Attributes provide one mechanism for representing relationships between objects and other objects or printable values; they are drawn using arrows. For example, the Person class has attributes name and citizenship, which associate strings with each person object.

These are examples of single-valued attributes. (In this schema, all attributes are assumed to be total.) Multivalued attributes are also allowed; these map each object to a set of objects or printable values and are denoted using arrows with double heads. For example, acts_in maps actors to the movies that they have acted in. It is common to permit inverse constraints between pairs of attributes. For example, consider the relationship between actors and movies. It can be represented using the multivalued attribute acts_in on Actor or the multivalued attribute actors on Movie. In this schema, we assume that the attributes acts_in and actors are constrained to be inverses of each other, in the sense that m ∈ acts _ in( a) iff a ∈ actor( m). A similar constraint is assumed between the attributes associating movies with directors.

In the schema CINEMA-SEM, the Pariscope node is an example of a complex value class. Members of the underlying class are triples whose coordinates are from the classes Theater, Time, and Movie, respectively. In the GSM, each complex value is the result of one application of the tuple construct. This is indicated using a node of the form ⊗, with components indicated using dashed arrows. The components of each complex value can be printable, abstract, or complex values. However, there cannot be a directed cycle in the set of edges used to define the complex values. As suggested by the attribute price, a complex value class may have attributes. Complex value classes can also serve as the range of an attribute, as illustrated by the class Award.

Complex values are of independent interest and are discussed in some depth in Chapter 20. Complex values generally include hierarchical structures built from a handful of
244
Design and Dependencies
Name
Pariscope
Citizen-
Price
Person
ship
Theater
Time
Movie
Director
Actor
Award
Acts_in
Name
Address
Phone
Title
Actors
Name
Prize
Figure 11.1:
The schema CINEMA-SEM in the Generic Semantic Model
11.1 Semantic Data Models
245
basic constructors, including tuple (as shown here) set, and sometimes others such as bag and list. Rich complex value models are generally incorporated into object-oriented data models and into some semantic data models. Some constructs for complex values, such as set, cannot be simulated directly using the pure relational model (see Exercise 11.24).

The final building block of the GSM is the ISA relationship, which represents set inclusion. In the example schema of Fig. 11.1, the ISA relationships are depicted by double-shafted arrows and indicate that the set of Director is a subset of Person, and likewise that Actor is a subset of Person. In addition to indicating set inclusion, ISA relationships indicate a form of subtyping relationship, or inheritance. Specifically, if class B ISA class A, then each attribute of A is also relevant (and defined for) elements of class B. In the context of semantic models, this should be no surprise because the elements of B are elements of A.

In the GSM, the graph induced by ISA relationships is a directed acyclic graph (DAG).

The root nodes are primary abstract classes (represented with diamonds), and all other nodes are subclass nodes (represented with circles). Each subclass node has exactly one primary node above it. Complex value classes cannot participate in ISA relationships.

In the GSM, the tuple and multivalued attribute constructs are somewhat redundant: A multivalued attribute is easily simulated using a tuple construct. Such redundancy is typical of semantic models: The emphasis is on allowing schemas that correspond closely to the way that users think about an application. On a bit of a tangent, we also note that the tuple construct of GSM is close to the relationship construct of the ER model.

GSM Instances
Let S be a GSM schema. It is assumed that a fixed (finite or infinite) domain is associated to each printable class in S. We also assume a countably infinite set obj of OIDs.

An instance of S is a function I whose domain is the set of primary, subclass, and complex value classes of S and the set of attributes of S. For primary class C, I(C) is a finite set of OIDs, disjoint from I(C′) for each other primary class C′. For each subclass D, I(D) is a set of OIDs, such that the inclusions indicated by the ISA relationships of S
are satisfied. For complex value class C with components D1, . . . , Dn, I(C) is a finite set of tuples d1, . . . , dn, where di ∈ I(Di) if Di is an abstract or complex value class, and di is in the domain of Di if Di is a printable class. For a single-valued attribute f from C to C′, I(f ) is a function from I(C) to I(C′) (or to the domain of C′, if C′ is printable). For a multivalued attribute f from C to C′, I(f ) is a function from I(C) to finite subsets of I(C′) (or the domain of C′, if C′ is printable). Given instance I, attribute f from C to C′, and object o in I(C), we often write f (o) to denote [I(f )](o).

Example 11.1.1
Part of a very small instance I1 of CINEMA-SEM is shown in Fig. 11.2. The values of complex value Award, the attributes award, address, and phone are not shown. The symbols o1, o2, etc., denote OIDs.

Consider an instance I′ that is identical to I1, except that o2 is replaced by o8 everywhere. Because OIDs serve only as internal representations that cannot be accessed
246
Design and Dependencies
I1( Person) =
name(o1) = Alice
citizenship(o1) = Great Britain
{o1, o2, o3}
name(o2) = Allen
citizenship(o2) = United States
name(o3) = Keaton
citizenship(o3) = United States
I1( Director) = {o2}
directed(o2) = {o4, o5}
I1( Actor) = {o2, o3}
acts _ in(o2) = {o4, o5}
acts _ in(o3) = {o5}
I1( Movie) = {o4, o5}
title(o4) = Take the Money
and Run
title(o5) = Annie Hall
director(o4) = o2
actors(o4) = {o2}
director(o5) = o2
actors(o5) = {o2, o3}
I1( Theater) = {o6}
name(o6) = Le Champo
I1( Pariscope) =
price( o6, 20:00, o4) = 30FF
{ o6, 20:00, o4}
Figure 11.2:
Part of an instance I1 of CINEMA-SEM
explicitly, I1 and I′ are considered to be identical in terms of the information that they represent.

Let S be a GSM schema. An OID isomorphism is a function µ that is a permutation on the set obj of OIDs and leaves all printables fixed. Such functions are extended to Inst(S) in the natural fashion. Two instances I and I′ are OID equivalent, denoted I ≡ OID I′, if there is an OID isomorphism µ such that µ(I) = I′. This is clearly an equivalence relation.

As suggested by the preceding example, if two instances are OID equivalent, then they represent the same information. The formalism of OID equivalence will be used later when we discuss the relational simulation of GSM.

The GSM is a very basic semantic data model, and many variations on the semantic constructs included in the GSM have been explored in the literature. For example, a variety of simple constraints can be incorporated, such as cardinality constraints on attributes and disjointness between subclasses (e.g., that Director and Actor are disjoint). Another variation is to require that a class be “dependent” on an attribute (e.g., that each Award object must occur in the image of some Actor) or on a complex value class. More complex constraints based on first-order sentences have also been explored. Some semantic models support different kinds of ISA relationships, and some provide “derived data” (i.e., a form of user view incorporated into the base schema).

11.1 Semantic Data Models
247
Translating into the Relational Model
We now describe an approach for translating semantic schemas into relational database schemas. As we shall see, the semantics associated with the semantic schema will yield dependencies of various forms in the relational schema.

A minor problem to be surmounted is that in a semantic model, real-world objects such as persons can be represented using OIDs, but printable classes must be used in the pure relational model. To resolve this, we assume that each primary abstract class has a key, that is, a set {k1, . . . , kn} of one or more attributes with printable range such that for each instance I and pair o, o′ of objects in the class, o = o′ iff k1(o) = k1(o′) and . . . and kn(o) = kn(o′). (Although more than one key might exist for a primary class, we assume that a single key is chosen.) In the schema CINEMA-SEM, we assume that ( person _) name is the key for Person, that title is the key for Movie, and that ( theater _) name is the key for Theater. (Generalizations of this approach permit the composition of attributes to serve as part of a key; e.g., including in the key for Movie the composition director ◦ name, which would give the name of the director of the movie.)

An alternative to the use of keys as just described is to permit the use of surrogates.

Informally, a surrogate of an object is a unique, unchanging printable value that is associated with the object. Many real-world objects have natural surrogates (e.g., Social Security number for persons in the United States or France; or Invoice Number for invoices in a commercial enterprise). In other cases, abstract surrogates can be used.

The kernel of the translation of GSM schemas into relational ones concerns how objects in GSM instances can be represented using (tuples of) printables. For each class C
occurring in the GSM schema, we associate a set of relational attributes, called the representation of C, and denoted rep(C). For a printable class C, rep(C) is a single attribute having this sort. For abstract class C, rep(C) is a set of attributes corresponding to the key attributes of the primary class above C. For a complex value class C = [C1, . . . , Cm], rep(C) consists of (disjoint copies of) all of the attributes occurring in rep(C1), . . . , rep(Cm).

Translation of a GSM schema into a relation schema is illustrated in the following example.

Example 11.1.2
One way to simulate schema CINEMA-SEM in the relational model is to use the schema CINEMA-REL, which has the following schema: Person
[ name, citizenship]
Director
[ name]
Actor
[ name]
Acts_in
[ name, title]
Award
[ prize, year]
Has_Award
[ name, prize, year]
Movie
[ title, director_name]
Theater
[ theater_name, address, phone]
Pariscope
[ theater_name, time, title, price]
248
Design and Dependencies
Person
name
citizenship
Movie
title
director_name
Alice
Great Britain
Take the Money and Run
Allen
Allen
United States
Annie Hall
Allen
Keaton
United States
Pariscope
theater_name
time
title
price
Le Champo
20:00
Take the Money and Run
30FF
Figure 11.3:
Part of a relational instance I2 that simulates I1
Figure 11.3 shows three relations in the relational simulation I2 of the instance I1 of Fig. 11.2.

In schema CINEMA-REL, both Actor and Acts_in are included in case there are one or more actors that did not act in any movie. For similar reasons, Acts_in and Has_Award are separated.

In contrast, we have assumed that each person has a citizenship (i.e., that citizenship is a total function). If not, then two relations would be needed in place of Person. Analogous remarks hold for directors, movies, theaters, and Pariscope objects.

In schema CINEMA-REL, we have not explicitly provided relations to represent the attributes directed of Director or actors of Movie. This is because both of these are inverses of other attributes, which are represented explicitly (by Movie and Acts_in, respectively).

If we were to consider the complex value class Awards of CINEMA-SEM to be dependent on the attribute award, then the relation Award could be omitted.

Suppose that I is an instance of CINEMA-SEM and that I′ is the simulation of I.

The semantics of CINEMA-SEM, along with the assumed keys, imply that I′ will satisfy several dependencies. This includes the following fd’s (in fact, key dependencies): Person
:
name → citizenship
Movie
:
title → director _ name
Theater
:
theater _ name → address, phone
Pariscope
:
theater _ name, time, title → price A number of ind’s are also implied:
Director[ name]
⊆
Person[ name]
Actor[ name]
⊆
Person[ name]
Movie[ director _ name]
⊆
Director[ name]
Acts _ in[ name]
⊆
Actor[ name]
Acts _ in[ title]
⊆
Movie[ title]
Has _ Award[ name]
⊆
Actor[ name]
11.1 Semantic Data Models
249
Has _ Award[ prize, year]
⊆
Award[ prize, year]
Pariscope[ theater _ name]
⊆
Theater[ theater _ name]
Pariscope[ title]
⊆
Movie[ title]
The first group of ind’s follows from ISA relationships; the second from restrictions on attribute ranges; and the third from restrictions on the components of complex values. All but one of the ind’s here are unary, because all of the keys, except the key for Award, are based on a single attribute.

Preservation of Data
Suppose that S is a GSM schema with keys for primary classes, and (R, ∪ Ŵ) is a relational schema that simulates it, constructed in the fashion illustrated in Example 11.1.2, where is the set of fd’s and Ŵ is the set of ind’s. As noted in criterion (1) at the beginning of this chapter, it is desirable that there be a natural one-to-one mapping τ from instances of S to instances of (R, ∪ Ŵ). To formalize this, two obstacles need to be overcome.

First, we have not developed a query language for the GSM. (In fact, no query language has become widely accepted for any of the semantic data models. In contrast, some query languages for object-oriented database models are now gaining wide acceptance.) We shall overcome this obstacle by developing a rather abstract notion of “natural” for this context.

The second obstacle stems from the fact that OID-equivalent GSM instances hold essentially the same information. Thus we would expect OID-equivalent instances to map to the same relational instance.1 To refine criterion (1) for this context, we are searching for a one-to-one mapping from Inst(S)/ ≡ OID into Inst(R, ∪ Ŵ).

A mapping τ : Inst(S) → Inst(R, ∪ Ŵ) is OID consistent if I ≡ OID I′ implies τ (I) =
τ (I′). In this case, we can view τ as a mapping with domain Inst(S)/≡ OID. The mapping τ preserves the active domain if for each I ∈ Inst(S), adom(τ (I)) = adom(I). [The active domain of a GSM instance I, denoted adom(I), is the set of all printables that occur in I.]
The following can be verified (see Exercise 11.3):
Theorem 11.1.3 (Informal)
Let S be a GSM schema with keys for primary classes,
and let (R, ∪ Ŵ) be a relational simulation of S. Then there is a function τ : Inst(S) →
Inst(R, ∪ Ŵ) such that τ is OID consistent and preserves the active domain, and such that τ : Inst(S)/≡ OID → Inst(R, ∪ Ŵ) is one-to-one and onto.

Properties of the Relational Schema
We now consider criteria (2) and (3) to highlight desirable properties of relational schemas that simulate GSM schemas.

1 When artificial surrogates are used to represent OIDs in the relational database, one might have to use a notion of an “equivalent” relational database instances as well.

250
Design and Dependencies
Criterion (2) for schema transformations concerns desirable properties of the target schema. We now describe three such properties resulting from the transformation of GSM
schemas into relational ones.

Suppose again that S is a GSM schema with keys, and (R, ∪ Ŵ) is a relational simulation of it. We assume as before that no constraints hold for S, aside from those implied by the constructs in S and the keys.

The three properties are as follows:
1. First, is equivalent to a family of key dependencies; in the terminology of the next section, this means that each of the relation schemas obtained is in Boyce-Codd Normal Form (BCNF). Furthermore, the only mvd’s satisfied by relations in R are implied by , and so the relation schemas are in fourth normal form (4NF).

2. Second, the family Ŵ of ind’s is acyclic (see Chapter 9). That is, there is no sequence R1[X1] ⊆ R2[Y1], R2[X2] ⊆ R3[Y2], . . . , Rn[Xn] ⊆ R1[Yn] of ind’s in the set. By Theorem 9.4.5, this implies that logical implication can be decided for ( ∪ Ŵ) and that finite and unrestricted implication coincide.

3. Finally, each ind R[X] ⊆ S[Y ] in Ŵ key based. That is, Y is a (minimal) key of S
under .

Together these properties present a number of desirable features. In particular, dependency implication is easy to check. Given a database schema R and sets of fd’s and Ŵ
of ind’s over R, and Ŵ are independent if (1) for each fd σ over R, ( ∪ Ŵ) |= σ implies |= σ , and (2) for each ind γ over R, ( ∪ Ŵ) |= γ implies Ŵ |= γ . Suppose that S
is a GSM schema and that (R, ∪ Ŵ) is a relational simulation of S. It can be shown that the three aforementioned properties imply that and Ŵ are independent (see Exercise 11.4).

To conclude this section, we consider criterion (3). This criterion concerns the preservation of meta-data. We do not attempt to formalize this criterion for this context, but it should be clear that there is a close correspondence between the dependencies in ∪ Ŵ
and the constructs used in S. In other words, the semantics of the application as expressed by S is also captured, in the relational representation, by the dependencies ∪ Ŵ.

The preceding discussion assumes that no dependency holds for S, aside from those implied by the keys and the constructs in S. However, in many cases constraints will be incorporated into S that are not directly implied by the structure of S. For instance, recall Example 11.1.2, and suppose that the fd Pariscope : theater_name, time → price is true for the underlying data. The relational simulation will have to include this dependency and, as a result, the resulting relational schema may be missing some of the desirable features (e.g., the family of fd’s is not equivalent to a set of keys and the schema is no longer in BCNF).

This suggests that a semantic model might be used to obtain a coarse relational schema, which might be refined further using the techniques for improving relational schemas developed in the next section.

11.2 Normal Forms
251
11.2
Normal Forms
In this section, we consider schema design based on the refinement of relational schemas and normal forms, which provide the basis for this approach. The articulation of these normal forms is arguably the main contribution of relational database theory to the realm of schema design. We begin the discussion by presenting two of the most prominent normal forms and a design strategy based on “decomposition.” We then develop another normal form that overcomes certain technical problems of the first two, and describe an associated design strategy based on “synthesis.” We conclude with brief comments on the relationship of ind’s with decomposition.

When all the dependencies in a relational schema (R, ) are considered to be tagged, one can view the database schema as a set {(R1, 1), . . . , (Rn, n)}, where each (Rj , j ) is a relation schema and the Rj ’s are distinct. In particular, an fd schema is a relation schema (R, ) or database schema (R, ), where is a set of tagged fd’s; this is extended in the natural fashion to other classes of dependencies. Much of the work on refinement of relational schemas has focused on fd schemas and (fd + mvd) schemas. This is what we consider here. (The impact of the ind’s is briefly considered at the end of this section.) A normal form restricts the set of dependencies that are allowed to hold in a relation schema. The main purpose of the normal forms is to eliminate at least some of the redundancies and update anomalies that might otherwise arise. Intuitively, schemas in normal form are “good” schemas.

We introduce next two kinds of normal forms, namely BCNF and 4NF. (We will consider a third one, 3NF, later.) We then consider techniques to transform a schema into such desirable normal forms.

BCNF: Do Not Represent the Same Fact Twice
Recall the schema ( Movies[ T ( itle), D( irector), A( actor)], {T → D}) from Section 8.1. As discussed there, the Movies relation suffers from various anomalies, primarily because there is only one Director associated with each Title but possibly several Actors. Suppose that (R[U ], ) is a relation schema, |= X → Y , Y ⊆ X and |= X → U . It is not hard to see that anomalies analogous to those of Movies can arise in R. Boyce-Codd normal form prohibits this kind of situation.

Definition 11.2.1 A relation schema (R[U ], ) is in Boyce-Codd normal form (BCNF) if |= X → U whenever |= X → Y for some Y ⊆ X. An fd schema (R, ) is in BCNF
if each of its relation schemas is.

BCNF is most often discussed in cases where involves only functional dependencies. In such cases, if (R, ) is in BCNF, the anomalies of Section 8.1 do not arise. An essential intuition underlying BCNF is, “Do not represent the same fact twice.”
The question now arises: What does one do with a relation schema (R, ) that is not in BCNF? In many cases, it is possible to decompose this schema into subschemas (R1, 1), . . . , (Rn, n) without information loss. As a simple example, Movies can be decomposed into
252
Design and Dependencies


( Movie _ director[ TD], { T → D}), ( Movie _ actors[ TA], ∅)
A general framework for decomposition is presented shortly.

4NF: Do Not Store Unrelated Information in the Same Relation
Consider the relation schema ( Studios[ N( ame), D( irector), L( ocation)], {N →
→ D|L}). A
tuple n, d, l is in Studios if director d is employed by the studio with name n and if this studio has an office in location l. Only trivial fd’s are satisfied by all instances of this schema, and so it is in BCNF. However, update anomalies can still arise, essentially because the D and L values are independent from each other. This gives rise to the following generalization of BCNF2:
Definition 11.2.2
A relation schema (R[U ], ) is in fourth normal form ( 4NF) if (a) whenever |= X → Y and Y ⊆ X, then |= X → U
(b) whenever |= X →
→ Y and Y ⊆ X, then |= X → U .

An (fd + mvd) schema (R, ) is in 4NF if each of its relation schemas is.

It is clear that if a relation schema is in 4NF, then it is in BCNF. It is easily seen that Studios can be decomposed into two 4NF relations, without loss of information and that the resulting relation schemas do not have the update anomalies mentioned earlier. An essential intuition underlying 4NF is, “Do not store unrelated information in the same relation.”
The General Framework of Decomposition
One approach to refining relational schemas is decomposition. In this approach, it is usually assumed that the original schema consists of a single wide relation containing all attributes of interest. This is referred to as the pure universal relation assumption, or pure URA. A relaxation of the pure URA, called the “weak URA,” is considered briefly in Section 11.3.

The pure URA is a simplifying assumption, because in practice the original schema is likely to consist of several tables, each with its own dependencies. In that case, the design process described for the pure URA is applied separately to each table. We adopt the pure URA here. In this context, the schema transformation produced by the design process consists of decomposing the original table into smaller tables by using the projection operator.

(In an alternative approach, selection is used to yield so-called horizontal decompositions.) We now establish the basic framework of decompositions. Let (U [Z], ) be a relation schema. A decomposition of (U [Z], ) is a database schema R = {R1[X1], . . . , Rn[Xn]}
with dependencies Ŵ, where ∪{Xj | j ∈ [1, n]} = Z. (The relation name ‘U ’ is used to suggest that it is a “universal” relation.) In the sequel, we often use relation names U (Ri) and attribute sets Z (Xi), interchangeably if ambiguity does not arise.

2 The motivation behind the names of several of the normal forms is largely historical; see the Bibliographic Notes.

11.2 Normal Forms
253
We now consider the three criteria for schema transformation in the context of decomposition. As already suggested, criterion (2) is evaluated in terms of the normal forms. With regard to the preservation of data (1), the “natural” mapping from R to R is obtained by projection: The decomposition mapping of R is the function πR : Inst(U ) → Inst(R) such that for I ∈ inst(U ), we have πR(I )(Rj ) = πR (I ). Criterion (1) says that the decompo-j
sition should not lose information when I is replaced by its projections (i.e., it should be one-to-one).

A natural property implying that a decomposition is one-to-one is that the original instance can be obtained by joining the component relations. Formally, a decomposition is said to have the lossless join property if for each instance I of (U, ) the join of the projections is the original instance, i.e., ⊲⊳ (πR(I)) = I. It is easy to test if a decomposition R = {R1, . . . , Rn} of (U, ) has the lossless join property. Consider the query q(I ) =
πR (I ) ⊲⊳ · · · ⊲⊳ π (I ). The lossless join property means that q(I ) = I for every instance 1
Rn
I over (U, ). But q(I ) = I simply says that I satisfies the jd ⊲⊳ [R]. Thus we have the following:
Theorem 11.2.3
Let (U, ) be a (full dependencies) schema and R a decomposition for (U, ). Then R has the lossless join property iff |=⊲⊳ [R].

The preceding implication can be tested using the chase (see Chapter 8), as illustrated next.

Example 11.2.4
Recall the schema ( Movies[ TDA], {T → D}). As suggested earlier, a decomposition into BCNF is R = { TD, TA}. This decomposition has the lossless join property. The tableau associated with the jd σ =⊲⊳ [ TD, TA] is as follows: Tσ
T
D
A
t
d
a1
t
d1
a
tσ
t
d
a
Consider the chase of Tσ , tσ with {T → D}. Because the two first tuples agree on the T
column, d and d1 are merged because of the fd. Thus t, d, a ∈ chase(Tσ , tσ , {T → D}).

Hence T → D implies the jd σ , so R has the lossless join property. (See also Exercise 11.9.)

Referring to the preceding example, note that it is possible to represent information in R that cannot be directly represented in Movies. Specifically, in the decomposed schema we can represent a movie with a director but no actors and a movie with an actor but no director.

This indicates, intuitively, that a decomposed schema may have more information capacity
254
Design and Dependencies
than the original (see Exercise 11.23). In practice, this additional capacity is exploited; in fact, it provides part of the solution of so-called deletion anomalies.

Remark 11.2.5
In the preceding example, we used the natural join operator to reconstruct decompositions. Interestingly, there are cases in which the natural join does not suffice. To show that a decomposition is one-to-one, it suffices to exhibit an inverse to the projection, called a reconstruction mapping. If is permitted to include very general constraints expressed in first-order logic that may not be dependencies per se, then there are one-to-one decompositions whose reconstruction mappings are not the natural join (see Exercise 11.20).

We now consider criterion (3), the preservation of meta-data. In the context of decomposition, this is formalized in terms of “dependency preservation”: Given schema (U, ), which is replaced by a decomposition R = {R1, . . . , Rn}, we would like to find for each j a family Ŵj of dependencies over Rj such that ∪j Ŵj is equivalent to the original . In the case where is a set of fd’s, we can make this much more precise. For V ⊆ U , let πV () = {X → A | XA ⊆ V and |= X → A},
let Ŵj = πX (), and let Ŵ = ∪
j
j Ŵj . Obviously, |= Ŵ. (See Proposition 10.2.4.) Intu-
itively, Ŵ consists of the dependencies in ∗ that are local to the relations in the decomposition R. The decomposition R is said to be dependency preserving iff Ŵ ≡ . In other words, can be enforced by the dependencies local in the decomposition. It is easy to see that the decomposition of Example 11.2.4 is dependency preserving.

Given an fd schema (U, ) and V ⊆ U , πV () has size exponential in V , simply because of trivial fd’s. But perhaps there is a smaller set of fd’s that is equivalent to πV (). A cover of a set Ŵ of fd’s is a set Ŵ′ of fd’s such that Ŵ′ ≡ Ŵ. Unfortunately, in some cases the smallest cover for a projection πV () is exponential in the size of (see Exercise 11.11).

What about projections of sets of mvd’s? Suppose that is a set of fd’s and mvd’s over U . Let V ⊆ U and
π mvd() = {[X →
→ (Y ∩ V )|(Z ∩ V )] | [X →
→ Y |Z] ∈ ∗ and X ⊆ V }.

V
Consider a decomposition R of (U, ). Viewed as constraints on U , the sets π mvd() are Rj
now embedded mvd’s. As we saw in Chapter 10, testing implication for embedded mvd’s is undecidable. However, the issue of testing for dependency preservation in the context of decompositions involving fd’s and mvd’s is rather specialized and remains open.

Fd’s and Decomposition into BCNF
We now present a simple algorithm for decomposing an fd schema (U, ) into BCNF
relations. The decomposition produced by the algorithm has the lossless join property but is not guaranteed to be dependency preserving.

We begin with a simple example.

11.2 Normal Forms
255
Example 11.2.6
Consider the schema (U, ), where U has attributes
TITLE
D_NAME
TIME
PRICE
TH_NAME
ADDRESS
PHONE
and contains
FD 1 :
TH _ NAME → ADDRESS, PHONE
FD 2 :
TH _ NAME, TIME, TITLE → PRICE
FD 3 :
TITLE → D _ NAME
Intuitively, schema (U, ) represents a fragment of the real-world situation represented by the semantic schema CINEMA-SEM.

A first step toward transforming this into a BCNF schema is to decompose using FD 1, to obtain the database schema


({ TH _ NAME, ADDRESS, PHONE}, { FD 1}), ({ TH _ NAME, TITLE, TIME, PRICE, D _ NAME}, { FD 2, FD 3}) Next FD 3 can be used to split the second relation, obtaining


 ({ TH _ NAME, ADDRESS, PHONE}, { FD 1}) 
({ TITLE, D _ NAME}, { FD 3})


({ TH _ NAME, TITLE, TIME, PRICE}, { FD 2}) which is in BCNF. It is easy to see that this decomposition has the lossless join property and is dependency preserving. In fact, in this case, we obtain the same relational schema as would result from starting with a semantic schema.

We now present the following:
Algorithm 11.2.7 (BCNF Decomposition)
Input: A relation schema (U, ), where is a set of fd’s.

Output: A database schema (R, Ŵ) in BCNF
1. Set (R, Ŵ) := {(U, )}.

2. Repeat until (R, Ŵ) is in BCNF:
(a) Choose a relation schema (S[V ], L) ∈ R that is not in BCNF.

(b) Choose nonempty, disjoint X, Y, Z ⊂ V such that
(i) XY Z = V ;
(ii) L |= X → Y ; and
(iii) L |= X → A for each A ∈ Z.

(c) Replace (S[V ], L) in R by (S1[XY ], πXY (L)) and (S2[XZ], πXZ(L)).

(d) If there are (S[V ], L), (S′[V ′], L′) in R with V ⊆ V ′, then remove S([V ], L) from R.

256
Design and Dependencies
It is easily seen that the preceding algorithm terminates [each iteration of the loop eliminates at least one violation of BCNF among finitely many possible ones]. The following is easily verified (see Exercise 11.10):
Theorem 11.2.8
The BCNF Decomposition Algorithm yields a BCNF schema and a
decomposition that has the lossless join property.

What is the complexity of running the BCNF Decomposition Algorithm? The main expenses are (1) examining subschemas (S[V ], L) to see if they are in BCNF and, if not, finding a way to decompose them; and (2) computing the projections of L. (1) is polynomial, but (2) is inherently exponential (see Exercise 11.11). This suggests a modification to the algorithm, in which only the relational schemas S[V ] are computed at each stage, but L = πV () is not. However, the problem of determining, given fd schema (U, ) and V ⊆ U , whether (V , πV ()) is in BCNF is co-np-complete (see Exercise 11.12). Interestingly, a polynomial time algorithm does exist for finding some BCNF decomposition of an input schema (U, ) (see Exercise 11.13).

When applying BCNF decomposition to the schema of Example 11.2.6, the same result is achieved regardless of the order in which the dependencies are applied. This is not always the case, as illustrated next.

Example 11.2.9
Consider (ABC, {A → B, B → C}). This has two BCNF decompo-
sitions
R1 = {(AB, {A → B}), (BC, {B → C})}
R2 = {(AB, {A → B}), (AC, ∅)}.

Note that R1 is dependency preserving, but R2 is not.

Fd’s, Dependency Preservation, and 3NF
It is easy to check that the schemas in Examples 11.2.4, 11.2.6, and 11.2.9 have dependency-preserving decompositions into BCNF. However, this is not always achievable, as shown by the following example.

Example 11.2.10
Consider a schema Lectures[ C( ourse), P( rofessor), H( our)], where tuple c, p, h indicates that course c is taught by professor p at hour h. We assume that Hour ranges over weekday-time pairs (e.g., Tuesday at 4PM) and that a given course may have lectures during several hours each week. Assume that the following two dependencies are to hold:


C → P
=
.

PH → C
In other words, each course is taught by only one professor, and a professor can teach only one course at a given hour.

11.2 Normal Forms
257
The schema ( Lectures, ) is not in BCNF because |= C → P , but |= C → H .

Applying the BCNF Decomposition Algorithm yields R = {( CP, {C → P }), ( CH, ∅)}.

It is easily seen that { CP : C → P } |= , and so this decomposition does not preserve dependencies. A simple case analysis shows that there is no BCNF decomposition of Lectures that preserves dependencies.

This raises the question: Is there a less restrictive normal form for fd’s so that a lossless join decomposition that preserves dependencies can always be found? The affirmative answer is based on “third normal form” (3NF). To define it, we need some auxiliary notions. Suppose that (R[U ], ) is an fd schema. A superkey of R is a set X ⊆ U such that |= X → U . A key of R is a minimal superkey. A key attribute is an attribute A ∈ U
that is in some key of R. We now have the following:
Definition 11.2.11
An fd schema (U, ) is in third normal form ( 3NF) if whenever X → A is a nontrivial fd implied by , then either X is a superkey or A is a key attribute.

An fd schema (R, ) is in 3NF if each of its components is.

Example 11.2.12
Recall the schema ( Lectures,{C → P , PH → C}) described in Example 11.2.10. Here PH is a key, so P is a key attribute. Thus the schema is in 3NF.

A 3NF Decomposition Algorithm can be defined in analogy to the BCNF Decomposition Algorithm. We present an alternative approach, generally referred to as “synthesis.”
Given a set of fd’s, a minimal cover of is a set ′ of fd’s such that (a) each dependency in ′ has the form X → A, where A is an attribute; (b) ′ ≡ ;
(c) no proper subset of ′ implies ; and
(d) for each dependency X → A in ′, there is no Y ⊂ X such that |= Y → A.

A minimal cover can be viewed as a reduced representative for a set of fd’s. It is straightforward to develop a polynomial time algorithm for producing a minimal cover of a set of fd’s (see Exercise 11.16).

We now have the following:
Algorithm 11.2.13 (3NF Synthesis)
Input: A relation schema (U, ), where is a set of fd’s that is a minimal cover. We assume that each attribute of U occurs in at least one fd of .

Output: An fd schema (R, Ŵ) in 3NF
1. If there is an fd X → A in , where XA = U , then output (U, ).

2. Otherwise
(a) for each fd X → A in , include the relational schema ( XA, {X → A}) in the output schema (R, Ŵ); and
258
Design and Dependencies
(b) choose a key X of U under , and include (X, ∅) in the output.

A central aspect of this algorithm is to form a relation XA for each fd X → A in .

Intuitively, then, the output relations result from combining or “synthesizing” attributes rather than decomposing the full attribute set.

The following is easily verified (see Exercise 11.17):
Theorem 11.2.14
The 3NF Synthesis Algorithm decomposes a relation schema into a
database schema in 3NF that has the lossless join property and preserves dependencies.

Several improvements to the basic 3NF Synthesis Algorithm can be made easily. For example, different schemas obtained in step (2.a) can be merged if they come from fd’s with the same left-hand side. Step (2.b) is not needed if step (2.a) already produced a schema whose set of attributes is a superkey for (U, ). In many practical situations, it may be appropriate to omit step (2.b) of the algorithm. In that case, the decomposition preserves dependencies but does not necessarily satisfy the lossless join property.

In the preceding algorithm, it was assumed that each attribute of U occurs in at least one fd of . Obviously, this may not always be the case, for example, the attribute A_NAME in Example 11.2.15b does not participate in fd’s. One approach to remedy this situation is to introduce symbolic fd’s. For instance, in that example one might include the fd TITLE, A_NAME → ω1, where ω1 is a new attribute. One relation produced by the algorithm will be { TITLE, A _ NAME, ω1}. As a last step, attributes such as ω1 are removed.

In Example 11.2.9 we saw that the output of a BCNF decomposition may depend on the order in which fd’s are applied. In the case of the preceding algorithm for 3NF, the minimal cover chosen greatly impacts the final result.

Mvd’s and Decomposition into 4NF
A fundamental problem with BCNF decomposition and 3NF synthesis as just presented is that they do not take into account the impact of mvd’s.

Example 11.2.15
(a) The schema ( Studios[ N( ame), D( irector), L( ocation)], {N →
→
D|L}) is in BCNF and 3NF but has update anomalies. The mvd suggests a decomposition into ({ Name, Director}, { Name, Location}).

(b) A related issue is that BCNF decompositions may not separate attributes that intuitively should be separated. For example, consider again the schema of Example 11.2.6, but suppose that the attribute A_NAME is included to denote actor names. Following the same decomposition steps as before, we obtain the schema



 ({ TH _ NAME, ADDRESS, PHONE}, { FD 1}),






({ TITLE, D _ NAME}, { FD 3}),








({ TH _ NAME, TITLE, TIME, PRICE, A _ NAME}, { FD 2})
11.2 Normal Forms
259
which can be further decomposed to



 ({ TH _ NAME, ADDRESS, PHONE}, { FD 1}), 








 ({ TITLE, D _ NAME}, { FD 3}),







 ({ TH _ NAME, TITLE, TIME, PRICE}, { FD 2}), 







({ TH _ NAME, TITLE, TIME, A _ NAME}, ∅) Although there is a connection in the underlying data between TITLE and A_NAME, the last relation here is unnatural. If we assume that the mvd TITLE →
→ A _ NAME is
incorporated into the original schema, we can further decompose the last relation and apply a step analogous to (2d) of the BCNF Decomposition Algorithm to obtain



 ({ TH _ NAME, ADDRESS, PHONE}, { FD 1}), 








 ({ TITLE, D _ NAME}, { FD 3}),







 ({ TH _ NAME, TITLE, TIME, PRICE}, { FD 2}), 







({ TITLE, A _ NAME}, ∅)
Fourth normal form (4NF) was originally developed to address these kinds of situations. As suggested by the preceding example, an algorithm yielding 4NF decompositions can be developed along the lines of the BCNF Decomposition Algorithm. As with BCNF, the output of 4NF decomposition is a lossless join decomposition that is not necessarily dependency preserving.

A Note on Ind’s
In relational schema design starting with a semantic data model, numerous ind’s are typically generated. In contrast, the decomposition and synthesis approaches for refining relational schemas as presented earlier do not take ind’s into account. It is possible to incorporate ind’s into these approaches, but the specific choice of ind’s is dependent on the intended semantics of the target schema.

Example 11.2.16
Recall the schema ( Movies[ TDA], {T → D}) and decomposition into (R1[ TD], {T → D}) and (R2[ TA], ∅).

(a) If all movies must have a director and at least one actor, then both R1[T ] ⊆ R2[T ]
and R2[T ] ⊆ R1[T ] should be included. In this case, the mapping from Movies to its decomposed representation is one-to-one and onto.

(b) If the fd T → D is understood to mean that there is a total function from movies to directors, but movies without actors are permitted, then the ind R2[T ] ⊆
R1[T ] should be included.

260
Design and Dependencies
(c) Finally, suppose the fd T → D is understood to mean that each movie has at most one director (i.e., it is a partial function), and suppose that a movie can have no actor. Then an additional relation R3[T ] should be added to hold the titles of all movies, along with ind’s R1[T ] ⊆ R3[T ] and R2[T ] ⊆ R3[T ].

More generally, what if one is to refine a relational schema (R, ∪ Ŵ), where is a set of tagged fd’s and mvd’s and Ŵ is a set of ind’s? It may occur that there is an ind Ri[X] ⊆ Rj [Y ], and either X or Y is to be “split” as the result of a decomposition step.

The desired semantics of the target schema can be used to select between a variety of heuristic approaches to preserving the semantics of this ind. If Ŵ consists of unary ind’s, such splitting cannot occur. Speaking intuitively, if the ind’s of Ŵ are key based, then the chances of such splitting are reduced.

11.3
Universal Relation Assumption
In the preceding section, we saw that the decomposition and synthesis approaches to relational schema design assume the pure URA. This section begins by articulating some of the implications that underly the pure URA. It then presents the “weak URA,” which provides an intuitively natural mechanism for viewing a relational database instance I as if it were a universal relation.

Underlying Assumptions
Suppose that an fd schema (U [Z], ) is given and that decomposition or synthesis will be applied. One of several different database schemas might be produced, but presumably all of them carry roughly the same semantics. This suggests that the attributes in Z can be grouped into relation schemas in several different ways, without substantially affecting their underlying semantics. Intuitively, then, it is the attributes themselves (along with the dependencies in ), rather than the attributes as they occur in different relation schemas, that carry the bulk of the semantics in the schema. The notion that the attributes can represent a substantial portion of the semantics of an application is central to schema design based on the pure URA.

When decomposition and synthesis were first introduced, the underlying implications of this notion were not well understood. Several intuitive assumptions were articulated that attempted to capture these implications. We describe here two of the most important assumptions. Any approach to relational schema design based on the pure URA should also abide by these two assumptions.

Universal Relation Scheme Assumption: This states that if an attribute name appears in two or more places in a database schema, then it refers to the same entity set in each place.

For example, an attribute name Number should not be used for both serial numbers and employee numbers; rather two distinct attribute names Serial# and Employee# should be used.

Unique Role Assumption: This states that for each set of attributes there is a unique rela-
11.3 Universal Relation Assumption
261
tionship between them. This is sometimes weakened to say that there may be several relationships, but one is deemed primary. This is illustrated in the following example.

Example 11.3.1
(a) Recall in Example 11.2.15(b) that D_NAME and A_NAME were used for director and actor names, respectively. This is because there were two possible relationships between movies and persons.

(b) For a more complicated example, consider a schema for bank branches that includes attributes for B( ranch), L( oan), ( checking) A( ccount), and C( ustomer). Suppose there are four relations
BL, which holds data about branches and loans they have given BA, which holds data about branches and checking accounts they provide CL, which holds data about customers and loans they have
CA, which holds data about customers and checking accounts they have.

This design does not satisfy the unique role assumption, mainly because of the cycle in the schema. For example, consider the relationship between branches and customers. In fact, there are two relationships—via loans and via accounts. Thus a request for “the” data in the relationship between banks and customers is somewhat ambiguous, because it could mean tuples stemming from either of the two relationships or from the intersection or union of both of them.

One solution to this ambiguity is to “break” the cycle. For example, we could replace the Customer attribute by the two attributes L-C( ustomer) and A-C( ustomer). Now the user can specify the desired relationship by using the appropriate attribute.

The Weak Universal Relation Assumption
Suppose that schema (U, ) has decomposition (R, Ŵ) (with R = {R1, . . . , Rn}). When studying decomposition, we focused primarily on instances I of (R, Ŵ) that were the image of some instance I of (U, ) under the decomposition mapping πR. In particular, such instances I are globally consistent. [Recall from Chapter 6 that instance I is globally consistent if for each j ∈ [1, n], πR (⊲⊳ I) = I(R
j
j ); i.e., no tuple of I(Rj ) is dangling
relative to the full join.] However, in many practical situations it might be useful to use the decomposed schema R to store instances I that are not globally consistent.

Example 11.3.2
Recall the schema ( Movies[ TDA], {T → D}) from Example 11.2.4 and its decomposition { TD, TA}. Suppose that for some movie the director is known, but no actors are known. As mentioned previously, this information is easily stored in the decomposed database, but not in the original. The impossibility of representing this information in the original schema was one of the anomalies that motivated the decomposition in the first place.

Suppose that fd schema (U, ) has decomposition (R, Ŵ) = {(R1, Ŵ1), . . . , (Rn, Ŵn)}.

Suppose also that I is an instance of R such that (1) I(Rj ) |= Ŵj for each j , but (2) I is
262
Design and Dependencies
AB
A
B
AB
A
B
AB
A
B
a
b
a
b
a
b
a′
b
BC
B
C
BC
B
C
BC
B
C
b
c
b
c
b
c
ACD
A
C
D
ACD
A
C
D
ACD
A
C
D
a
c
d
a
c
d
a
c
d
a′
c
d′
a′
c
d′
I1
I2
I3
Figure 11.4:
Instances illustrating weak URA
not necessarily globally consistent. Should I be considered a “valid” instance of schema (R, Ŵ)? More generally, given a schema (U, ), a decomposition R of U , and a (not necessarily globally consistent) instance I over R, how should we define the notion of
“satisfaction” of by I?

The weak universal relation assumption ( weak URA) provides one approach for answering this question. Under the weak URA, we say that I satisfies if there is some instance J ∈ sat (U, ) such that I(Rj ) ⊆ πR (J ) for each j ∈ [1, n]. In this case, J is j
called a weak instance for I.

Example 11.3.3
Let U = { ABCD}, = {A → B, BC → D}, and R = { AB, BC, ACD}.

Consider the three instances of R shown in Fig. 11.4. The instance I1 satisfies under the weak URA, because J1 = { a, b, c, d} is a weak instance.

On the other hand, I2, which contains I1, does not satisfy under the weak URA. To see this, suppose that J2 is a weak instance for I2. Then J2 must contain the following (not necessarily distinct) tuples:
t1 = a, b, c1, d1
t2 = a′, b, c2, d2
t3 = a3, b, c, d3
t4 = a, b4, c, d
t5 = a′, b5, c, d′
where the subscripted constants may be new. Because J2 |= A → B, by considering the
11.3 Universal Relation Assumption
263
pairs t1, t4 and t2, t5, we see that b4 = b5 = b. Next, because J2 |= BC → D, and by considering the pair t4, t5, we have that d = d′, a contradiction.

Finally, I3 does satisfy under the weak URA.

As suggested by the preceding example, testing whether an instance I over R is a weak instance of (U, ) for a set of fd’s can be performed using the chase. To do that, it suffices to construct a table over U by padding the tuples from each Rj with distinct new variables. The resulting table is chased with the dependencies in . If the chase fails, there is no weak instance for I. On the other hand, a successful chase provides a weak instance for I by simply replacing each remaining variable with a distinct new constant.

This yields the following (see Exercise 11.27):
Theorem 11.3.4
Let be a set of fd’s over U and R a decomposition of U . Testing whether I over R satisfies under the weak URA can be performed in polynomial time.

Of course, the chasing technique can be extended to arbitrary egd’s, although the complexity jumps to exptime-complete.

What about full tgd’s? Recall that full tgd’s can always be satisfied by adding new tuples to an instance. Let be a set of full dependencies. It is easy to see that I satisfies under the weak URA iff I satisfies ∗ ∩ {σ | σ is an egd} under the weak URA.

Querying under the Weak URA
Let (U, ) be a schema, where is a set of full dependencies, and let R be a decomposition of U . Let us assume the weak URA, and suppose that database instance I over R satisfies .

How should queries against I be answered? One approach is to consider the query against all weak instances for I and then take the intersection of the answers. That is, q weak(I) = ∩{q(I ) | I is a weak instance of I}.

We develop now a constructive method for computing q weak.

Given instance I of R, the representative instance of I is defined as follows: For each component Ij of I, let I ′ be the result of extending I
j
j to be a free instance over U by
padding tuples with distinct variables. Set I ′ = ∪{I ′ | j ∈ [1, n]}. Now apply the chase j
using to obtain the representative instance rep(I, ) (or the empty instance, if two distinct constants are to be identified). Note that some elements of rep(I, ) may have variables occurring in them.

For X ⊆ U , let π ↓X( rep(I, )) denote the set of tuples (i.e., with no variables present) in πX( rep(I, )). The following can now be verified (see Exercise 11.28).

Proposition 11.3.5
Let (U, ), R and I be as above, and let X ⊆ U . Then
(a) [πX] weak(I) = π↓X( rep(I, )).

(b) If is a set of fd’s, then [πX] weak(I) can be computed in ptime.

264
Design and Dependencies
This proposition provides the basis of a constructive method for evaluating an arbitrary algebra query q under the weak URA. Furthermore, if is a set of fd’s, then evaluating q will take time at most polynomial in the size of the input instance. This approach can be generalized to the case where is a set of full dependencies but computing the projection is exptime-complete.

Bibliographic Notes
The recent book [MR92] provides an in-depth coverage of relational schema design, including both the theoretical underpinnings and other, less formal factors that go into good design. Extensive treatments of the topic are also found in [Dat86, Fv89, Ull88, Vos91].

References [Ken78, Ken79, Ken89] illustrate the many difficulties that arise in schema design, primarily with a host of intriguing examples that show how skilled the human mind is at organizing diverse information and how woefully limiting data models are.

Surveys of semantic data models include [Bor85, HK87, PM88], and the book [TL82];
[Vos91] includes a chapter on this topic. Prominent early semantic data models include the Entity-Relationship (ER) model [Che76] (see also [BLN86, MR92, TYF86]), the Functional Data Model [Shi81, HK81], the Semantic Data Model [HM81], and the Semantic Binary Data Model [Abr74]. An early attempt to incorporate semantic data modeling constructs into the relational model is RM/T [Cod79]; more recently there have been various extensions of the relational model to incorporate object-oriented data modeling features (e.g., [SJGP90]). Many commercial systems support “tuple IDs,” which can be viewed as a form of OID. Galileo [ACO85], Taxis [MBW80], and FQL [BFN82] are programming languages that support constructs stemming from semantic data models. The IFO
[AH87] model is a relatively simple, formal semantic data model that subsumes the structural components of the aforementioned semantic models and several others. Reference
[AH87] clarifies issues concerning ISA hierarchies in semantic schemas (see also [BLN86, Cod79, DH84] and studies the propagation of updates.

Reference [Che76] describes a translation of the ER model into the relational model, so that the resulting schema is in BCNF. From a practical perspective, this has become widely accepted as the method of choice for designing relational schemas; [TYF86] provides a subsequent perspective on this approach. There has also been considerable work on understanding the properties of relational schemas resulting from ER schemas and mapping relational schemas into ER ones. Reference [MR92] provides an in-depth discussion of this area.

Reference [LV87] presents a translation from a semantic to the relational model and studies the constraints implied for the relational schema, including cardinality constraints. The logical implication of constraints within a semantic model schema is studied in [CL94]. References [Lie80, Lie82] study the relationship of schemas from the network and relational models.

At a fundamental level, an important aspect of schema design is to replace one schema with another that can hold essentially the same information. This raises the issue of developing formal methods for comparing the relative information capacity of different schemas. Early work in this direction for the relational model includes [AABM82] and
[BMSU81] (see Exercise 11.22). More abstract work is found in [HY84, Hul86] (see Exercises 11.23 and 11.24), which forms the basis for Theorem 11.1.3. Reference [MS92]
Bibliographic Notes
265
provides justification for translations from the Entity-Relationship model into the relational model using notions of relative information capacity. Formal notions of relative information capacity have also been applied in the context of schema integration and translation
[MIR93] and heterogeneous databases [MIR94]. A very abstract framework for comparing schemas from different data models is proposed in [AT93].

The area of normal forms and relational database design was studied intensively in the 1970s and early 1980s. Much more complete coverage of this topic than presented here may be found in [Dat86, Mai83, Ull88, Vos91]. We mention some of the most important papers in this area. First normal form [Cod70] is actually fundamental to the relational model: A relation is in first normal form (1NF) if each column contains atomic values. In Chapter 20
this restriction shall be relaxed to permit relations some of whose columns themselves hold relations (which again may not be in first normal form). References [Cod71, Cod72a]
raised the issue of update anomalies and initiated the search for normal forms that prevent them by introducing second and third normal forms. The definition of 3NF used here is from [Zan82]. (Second normal form is less restrictive than third normal form.) Boyce-Codd normal form (BCNF) was introduced in [Cod74] to provide a normal form simpler than 3NF. Another improvement of 3NF is proposed in [LTK81]. Fourth normal form was introduced in [Fag77b]; Example 11.2.15 is inspired from that reference. Even richer normal forms include project-join normal form (PJ/NF) [Fag79] and domain-key normal form [Fag81].

In addition to introducing second and third normal form, [Cod72a] initiated the search for normalization algorithms by proposing the first decomposition algorithms. This spawned other research on decomposition [DC72, RD75, PJ81] and synthesis [BST75, Ber76b, WW75]. The fact that these two criteria are not equivalent was stressed in [Ris77], where it is proposed that both be attempted. Early surveys on these approaches to relational design include [BBG78, Fag77a, Ris78]. Algorithms for synthesis into 3NF include
[Ber76b, BDB79], for decomposition into BCNF include [TF82], and for decomposition into 4NF include [Fag77b]. Computational issues raised by decompositions are studied in
[LO78, BB79, FJT83, TF82] and elsewhere. Reference [Got87] presents a good heuristic for finding covers of the projection of a set of fd’s. The 3NF Synthesis Algorithm presented in this chapter begins with a minimal cover of a set of fd’s; [Mai80] shows that minimal covers can be found in polynomial time.

The more formal study of decompositions and their properties was initiated in [Ris77], which considered decompositions into two-element sets and proposed the notion of independent components; and [AC78], which studied decompositions with lossless joins and dependency preservation. This was extended independently to arbitrary decompositions over fd’s by [BR80] and [MMSU80]. Lossless join was further investigated in [Var82b]
(see Exercise 11.20).

The notion that not all integrity constraints specified in a schema should be considered for the design process was implicit in various works on semantic data modeling (e.g.,
[Che76, Lie80, Lie82]). It was stated explicitly in connection with relational schema design in [FMU82, Sci81]. An extensive application of this approach to develop an approach to schema design that incorporates both fd’s and mvd’s is [BK86].

A very different form of decomposition, called horizontal decomposition, is introduced in [DP84]. This involves splitting a relation into pieces, each of which satisfies a given set of fd’s.

266
Design and Dependencies
The universal relation assumption has a long history; the reader is directed to [AA93, MUV84, Ull89b] for a much more complete coverage of this topic than found in this chapter. The URA was implicit in much of the early work on normal forms and decompositions; this was articulated more formally in [FMU82, MUV84]. The weak URA was studied in connection with query processing in [Sag81, Sag83], and in connection with fd satisfaction in [Hon82]. Proposition 11.3.5(a) is due to [MUV84] and part (b) is due to [Hon82]; the extension to full dependencies is due to [GMV86]. Reference [Sci86] presents an interesting comparison of the relational model with inclusion dependencies to a variant of the universal relation model and shows an equivalence when certain natural restrictions are imposed.

A topic related to the URA is that of universal relation interfaces (URI); these attempt to present a user view of a relational database in the form of a universal relation. An excellent survey of research on this topic is found in [MRW86]; see also [AA93, Osb79, Ull89b].

Exercises
Exercise 11.1
(a) Extend the instance of Example 11.1.1 for CINEMA-SEM so that it has at least two objects in each class.

(b) Let CINEMA-SEM′ be the same as CINEMA-SEM, except that a complex value class Movie_Actor is used in CINEMA-SEM in place of the attributes acted_in and has_actors. How would the instance you constructed for part (a) be represented in CINEMA-SEM′?

Exercise 11.2
(a) Suppose that in CINEMA-SEM some theaters do not have phones. Describe how the simulation CINEMA-REL can be changed to reflect this (without using null values).

What dependencies are satisfied?

(b) Do the same for the case where some persons may have more than one citizenship.

Exercise 11.3
(a) Describe a general algorithm for translating GSM schemas with keys into relational ones.

(b) Verify Theorem 11.1.3.

(c) Verify that the relational schema resulting from a GSM schema is in 4NF and has acyclic and key-based ind’s.

♠ Exercise 11.4 [MR88, MR92] Let R be a relational database schema, a set of tagged fd’s for R, and Ŵ a set of ind’s for R. Assume that (R, ) is in BCNF and that Ŵ is acyclic and consists of key-based ind’s (as will arise if R is the simulation of a GSM schema). Prove that and Ŵ are independent. Hint: Show that if I is an instance of R satisfying , then no fd can be applied during chasing of I by ( ∪ Ŵ). Now apply Theorem 9.4.5.

Exercise 11.5
[Fag79] Let (R, ) be a relation schema, and let ′ be the set of key dependencies implied by . Show that R is in 4NF iff each nontrivial mvd implied by is implied by ′.

Exercises
267
Exercise 11.6
[DF92] A key dependency X → U is simple if X is a singleton.

(a) Suppose that (R, ) is in BCNF, where may involve both fd’s and mvd’s. Suppose further that (R, ) has at least one simple key. Prove that (R, ) is in 4NF.

(b) Suppose that (R, ) is in 3NF and that each key of is simple. Prove that (R, ) is in BCNF.

A schema (R, ) is in project-join normal form ( PJ/NF) if each JD σ implied by is implied by the key dependencies implied by .

(a) Show that if (R, ) is in 3NF and each key of is simple, then (R, ) is in PJ/NF.

Exercise 11.7
Let (U, ) be a schema, where contains possibly fd’s, mvd’s, and jd’s. Show that (a) (U, ) is in BCNF implies (U, ) is in 3NF; (b) (U, ) is in 4NF implies (U, ) is in BCNF; (c) (U, ) is in PJ/NF implies (U, ) is in 4NF.

Exercise 11.8
[BR80, MMSU80] Prove Theorem 11.2.3.

Exercise 11.9
Recall the schema ( Movies[ TDA],{T → D}). Consider the decomposition R1 =
{( TD, {T → D}), (DA, ∅)}.

(a) Show that this does not have the lossless join property.

⋆ (b) Show that this decomposition is not one-to-one. That is, exhibit two distinct instances I, I ′ of ( Movies, {T → D}) such that πR (I ) = π (I ′).

1
R1
Exercise 11.10
Verify Theorem 11.2.8. Hint: To prove the lossless join property, use repeated applications of Proposition 8.2.2.

Exercise 11.11
[FJT83] For each n ≥ 0, describe an fd schema (U, ) and V ⊆ U , such that has ≤ 2n + 1 dependencies but the smallest cover for πV () has at least 2n elements.

Exercise 11.12
(a) Let (U [Z], Ŵ) be an fd schema. Give a polynomial time algorithm for determining whether this relation schema is in BCNF. (In fact, there is a linear time algorithm.) (b) [BB79] Show that the following problem is co-np-complete. Given fd schema (R[U ], ) and V ⊆ U , determine whether (V , πV ()) is in BCNF. Hint: Reduce to the hitting set problem [GJ79].

⋆ Exercise 11.13 [TF82] Develop a polynomial time algorithm for finding BCNF decompositions. Hint: First show that each two-attribute fd schema is in BCNF. Then show that if (S[V ], L) is not in BCNF, then there are A, B ∈ V such that (V − AB) → A.

Exercise 11.14
Recall the schema Showings[ Th( eater), Sc( reen), Ti( tle), Sn( ack)] of Section 8.1, which satisfies the fd Th, Sc → Ti and the mvd Th →
→ Sc, Ti | Sn. Consider the two
decompositions
R1 = {{ Th, Sc, Ti}, { Th, Sn}}
R2 = {{ Th, Sc, Ti}, { Th, Sc, Sn}}.

Are they one-to-one? dependency preserving? Describe anomalies that can arise if either of these decompositions is used.

Exercise 11.15
[BB79] Verify that the schema of Example 11.2.10 has no BCNF decomposition that preserves dependencies.

268
Design and Dependencies
Exercise 11.16
[Mai80] Develop a polynomial time algorithm that finds a minimal cover of a set of fd’s.

Exercise 11.17
Prove Theorem 11.2.14.

Exercise 11.18
[Mai83] Show that a schema (R[U ], ) with 2n attributes and 2n fd’s can have as many as 2n keys.

Exercise 11.19
[LO78] Let (S[V ], L) be an fd schema. Show that the following problem is np-complete: Given A ∈ V , is there a nontrivial fd Y → A implied by L, where Y is not a superkey and A is not a key attribute?

⋆ Exercise 11.20 [Var82b] For this exercise, you will exhibit an example of a schema (R, ), where consists of dependencies expressed in first-order logic (which may not be embedded dependencies) and a decomposition R of R such that R is one-to-one but does not have the lossless join property.

Consider the schema R[ ABCD]. Given t ∈ I ∈ inst(R), t[A] is a key element for AB in I if there is no s ∈ I with t[A] = s[A] and t[B] = s[B]. The notion of t[C] being a key element for CD is defined analogously. Let consist of the constraints (i) ∃t ∈ I such that both t[A] and t[C] are key elements.

(ii) If t ∈ I , then t[A] is a key element or t[C] is a key element.

(iii) If s, t ∈ I and s[A] or t[C] is a key element, then the tuple u is in I , where u[AB] =
s[AB] and u[ CD] = t[ CD].

Let R = {R1[AB], R2[ CD]} be a decomposition of (R, ).

(a) Show that the decomposition R for (R, ) is one-to-one.

(b) Exhibit a reconstruction mapping for R. (The natural join will not work.) Exercise 11.21
This and the following exercise provide one kind of characterization of the relative information capacity of decompositions of relation schemas. Let U be a set of attributes, let α = {X1, . . . , Xn} be a nonempty family of subsets of U , and let X = ∪n X
i=1
i . The project-
join mapping determined by α, denoted PJ α, is a mapping from instances over U to instances over ∪n X
(π (I )). α is full if ∪n
= U , in which case PJ
i=1
i defined by PJ α(I ) = ⊲⊳n
i=1
Xi
i=1
α is a
full project-join mapping.

Prove the following for instances I and J over U :
(a) πX(I ) ⊆ PJ α(I )
Exercises
269
(b) PJ α( PJ α(I )) = PJ α(I )
(c) if I ⊆ J then PJ α(I ) ⊆ PJ α(J ).

⋆ Exercise 11.22 [BMSU81] Let U be a set of attributes. If α = {X1, . . . , Xn} is a nonempty full family of subsets of U , then Fixpt(α) denotes {I over U | PJ α(I ) = I } (see the preceding exercise). For α and β nonempty full families of subsets of U , β covers α, denoted α ( β, if for each set X ∈ α there is a set Y ∈ β such that X ⊆ Y . Prove for nonempty full families α, β
of subsets of U that the following are equivalent:
(a) α ( β
(b) PJ α(I ) ⊇ PJ β(I ) for each instance I over U
(c) Fixpt(α) ⊆ Fixpt(β).

Exercise 11.23
Given relational database schemas S and S′, we say that S′ dominates S using the calculus, denoted S (calc S′, if there are calculus queries q : Inst(S) → Inst(S′) and q′ : Inst(S′) → Inst(S) such that q ◦ q′ is the identity on Inst(S). Let schema R = (ABC, {A → B}) and the decomposition R = {(AB, {A → B}), (AC, ∅)}. (a) Verify that R (calc R. (b) Show that R (calc R. Hint: For schemas S and S′, S′ dominates S absolutely, denoted S (abs S′, if there is some n ≥ 0 such that for each finite subset d ⊆ dom with |d| ≥ n, |{I ∈ Inst(S) | adom(I) ⊆
d}| ≤ |{I ∈ Inst(S′) | adom(I) ⊆ d}|. Show that S (calc S′ implies S (abs S′. Then show that R (abs R.

⋆ Exercise 11.24 [HY84] Let A and B be relational attributes. Consider the complex value type T = A, {B}, where each instance of T is a finite set of pairs having the form a, ˆb, where a ∈ dom and ˆb is a finite subset of dom. Show that for each relational schema R, R (abs T and T (abs R. (See Exercise 11.23 for the definition of (abs.)

♠ Exercise 11.25 [BV84b, CP84]
(a) Let (U, ) be a (full dependencies) schema and R an acyclic decomposition of U (in the sense of acyclic joins). Then πR is one-to-one iff R has the lossless join property.

Hint: First prove the result for the case where the decomposition has two elements (i.e., it is based on an mvd). Then generalize to acyclic decompositions, using an induction based on the GYO algorithm.

(b) [CKV90] Show that (a) can be generalized to include unary ind’s in .

Exercise 11.26
[Hon82] Let (U, ) be an fd schema and R= {R1, . . . , Rn} a decomposition of U . Consider the following notions of “satisfaction” by I over R of : I |=1 : if Ij |= πR () for each j ∈ [1, n].

j
I |=2 : if ⊲⊳ I |= .

I |=3 : if I = πR(I ) for some I over U such that I |= .

(a) Show that |=1 and |=2 are incomparable.

(b) Show that if R preserves dependencies, then |=1 implies |=2.

(c) What is the relationship of |=1 and |=2 to |=3?

(d) What is the relationship of all of these to the notion of satisfaction based on the weak URA?

♠ Exercise 11.27 [Hon82] Prove Theorem 11.3.4.

Exercise 11.28
[MUV84, Hon82] Prove Proposition 11.3.5.

P A R T
D DatalogandRecursion
InPartB,weconsideredquerylanguagesrangingfromconjunctivequeriestofirst-order queries in the three paradigms: algebraic, logic, and deductive. We did this by enriching the conjunctive queries first with union (disjunction) and then with difference (negation).

In this part, we further enrich these languages by adding recursion. First we add recursion to the conjunctive queries, which yields datalog. We study this language in Chapter 12.

Although it is too limited for practical use, datalog illustrates some of the essential aspects of recursion. Furthermore, most existing optimization techniques have been developed for datalog.

Datalog owes a great debt to Prolog and the logic-programming area in general. A fundamental contribution of the logic-programming paradigm to relational query languages is its elegant notation for expressing recursion. The perspective of databases, however, is significantly different from that of logic programming. (For example, in databases datalog programs define mappings from instances to instances, whereas logic programs generally carry their data with them and are studied as stand-alone entities.) We adapt the logic-programming approach to the framework of databases.

We study evaluation techniques for datalog programs in Chapter 13, which covers the main optimization techniques developed for recursion in query languages, including seminaive evaluation and magic sets.

Although datalog is of great theoretical importance, it is not adequate as a practical query language because of the lack of negation. In particular, it cannot express even the first-order queries. Chapters 14 and 15 deal with languages combining recursion and negation, which are proper extensions of first-order queries. Chapter 14 considers the issue of combining negation and recursion. Languages are presented from all three paradigms, which support both negation and recursion. The semantics of each one is defined in fundamentally operational terms, which include datalog with negation and a straightforward, fixpoint semantics. As will be seen, the elegant correspondence between languages in the three paradigms is maintained in the presence of recursion.

Chapter 15 considers approaches to incorporating negation in datalog that are closer in spirit to logic programming. Several important semantics for negation are presented, including stratification and well-founded semantics.

271
12 Datalog
Alice:
What do we see next?

Riccardo:
We introduce recursion.

Sergio:
He means we ask queries about your ancestors.

Alice:
Are you leading me down a garden path?

Vittorio:
Kind of — queries related to paths in a graph call for recursion and are crucial for many applications.

Foralongtime,relationalcalculusandalgebrawereconsidered the databaselanguages.

Codd even defined as “complete” a language that would yield precisely relational calculus. Nonetheless, there are simple operations on data that cannot be realized in the calculus. The most conspicuous example is graph transitive closure. In this chapter, we study a language that captures such queries and is thus more “complete” than relational calculus.1 The language, called datalog, provides a feature not encountered in languages studied so far: recursion.

We start with an example that motivates the need for recursion. Consider a database for the Parisian Metro. Note that this database essentially describes a graph. (Database applications in which part of the data is a graph are common.) To avoid making the Metro database too static, we assume that the database is describing the available metro connections on a day of strike (not an unusual occurrence). So some connections may be missing, and the graph may be partitioned. An instance of this database is shown in Fig. 12.1.

Natural queries to ask are as follows:
(12.1)
What are the stations reachable from Odeon?

(12.2)
What lines can be reached from Odeon?

(12.3)
Can we go from Odeon to Chatelet?

(12.4)
Are all pairs of stations connected?

(12.5)
Is there a cycle in the graph (i.e., a station reachable in one or more stops from itself)?

Unfortunately, such queries cannot be answered in the calculus without using some a 1 We postpone a serious discussion of completeness until Part E, where we tackle fundamental issues such as “What is a formal definition of data manipulation (as opposed to arbitrary computation)?

What is a reasonable definition of completeness for database languages?”
273
274
Datalog
Links
Line
Station
Next Station
4
St.-Germain
Odeon
4
Odeon
St.-Michel
4
St.-Michel
Chatelet
1
Chatelet
Louvre
1
Louvre
Palais-Royal
1
Palais-Royal
Tuileries
1
Tuileries
Concorde
9
Pont de Sevres
Billancourt
9
Billancourt
Michel-Ange
9
Michel-Ange
Iena
9
Iena
F. D. Roosevelt
9
F. D. Roosevelt
Republique
9
Republique
Voltaire
Figure 12.1:
An instance I of the Metro database
priori knowledge on the Metro graph, such as the graph diameter. More generally, given a graph G, a particular vertex a, and an integer n, it is easy to write a calculus query finding the vertexes at distance less than n from a; but it seems difficult to find a query for all vertexes reachable from a, regardless of the distance. We will prove formally in Chapter 17
that such a query is not expressible in the calculus. Intuitively, the reason is the lack of recursion in the calculus.

The objective of this chapter is to extend some of the database languages considered so far with recursion. Although there are many ways to do this (see also Chapter 14), we focus in this chapter on an approach inspired by logic programming. This leads to a field called deductive databases, or database logic programming, which shares motivation and techniques with the logic-programming area.

Most of the activity in deductive databases has focused on a toy language called datalog, which extends the conjunctive queries with recursion. The interaction between negation and recursion is more tricky and is considered in Chapters 14 and 15. The importance of datalog for deductive databases is analogous to that of the conjunctive queries for the relational model. Most optimization techniques for relational algebra were developed for conjunctive queries. Similarly, in this chapter most of the optimization techniques in deductive databases have been developed around datalog (see Chapter 13).

Before formally presenting the language datalog, we present informally the syntax and various semantics that are considered for that language. Following is a datalog program PT C that computes the transitive closure of a graph. The graph is represented in relation G
and its transitive closure in relation T :
T (x, y) ← G(x, y)
T (x, y) ← G(x, z), T (z, y).

Datalog
275
Observe that, except for the fact that relation T occurs both in the head and body of the second rule, these look like the nonrecursive datalog rules of Chapter 4.

A datalog program defines the relations that occur in heads of rules based on other relations. The definition is recursive, so defined relations can also occur in bodies of rules.

Thus a datalog program is interpreted as a mapping from instances over the relations occurring in the bodies only, to instances over the relations occurring in the heads. For instance, the preceding program maps a relation over G (a graph) to a relation over T (its transitive closure).

A surprising and elegant property of datalog, and of logic programming in general, is that there are three very different but equivalent approaches to defining the semantics. We present the three approaches informally now.

A first approach is model theoretic. We view the rules as logical sentences stating a property of the desired result. For instance, the preceding rules yield the logical formulas (1)
∀x, y(T (x, y) ← G(x, y))
(2)
∀x, y, z(T (x, y) ← (G(x, z) ∧ T (z, y))).

The result T must satisfy the foregoing sentences. However, this is not sufficient to determine the result uniquely because it is easy to see that there are many T s that satisfy the sentences. However, it turns out that the result becomes unique if one adds the following natural minimality requirement: T consists of the smallest set of facts that makes the sentences true. As it turns out, for each datalog program and input, there is a unique minimal model. This defines the semantics of a datalog program. For example, suppose that the instance contains
G(a, b), G(b, c), G(c, d).

It turns out that T (a, d) holds in each instance that obeys (1) and (2) and where these three facts hold. In particular, it belongs to the minimum model of (1) and (2).

The second proof-theoretic approach is based on obtaining proofs of facts. A proof of the fact T (a, d) is as follows:
(i) G(c, d) belongs to the instance;
(ii) T (c, d) using (i) and the first rule;
(iii) G(b, c) belongs to the instance;
(iv) T (b, d) using (iii), (ii), and the second rule;
(v) G(a, b) belongs to the instance;
(vi) T (a, d) using (v), (iv), and the second rule.

A fact is in the result if there exists a proof for it using the rules and the database facts.

In the proof-theoretic perspective, there are two ways to derive facts. The first is to view programs as “factories” producing all facts that can be proven from known facts.

The rules are then used bottom up, starting from the known facts and deriving all possible new facts. An alternative top-down evaluation starts from a fact to be proven and attempts to demonstrate it by deriving lemmas that are needed for the proof. This is the underlying
276
Datalog
intuition of a particular technique (called resolution) that originated in the theorem-proving field and lies at the core of the logic-programming area.

As an example of the top-down approach, suppose that we wish to prove T (a, d). Then by the second rule, this can be done by proving G(a, b) and T (b, d). We know G(a, b), a database fact. We are thus left with proving T (b, d). By the second rule again, it suffices to prove G(b, c) (a database fact) and T (c, d). This last fact can be proven using the first rule. Observe that this yields the foregoing proof (i) to (vi). Resolution is thus a particular technique for obtaining such proofs. As detailed later, resolution permits variables as well as values in the goals to be proven and the steps used in the proof.

The last approach is the fixpoint approach. We will see that the semantics of the program can be defined as a particular solution of a fixpoint equation. This approach leads to iterating a query until a fixpoint is reached and is thus procedural in nature. However, this computes again the facts that can be deduced by applications of the rules, and in that respect it is tightly connected to the (bottom-up) proof-theoretic approach. It corresponds to a natural strategy for generating proofs where shorter proofs are produced before longer proofs so facts are proven “as soon as possible.”
In the next sections we describe in more detail the syntax, model-theoretic, fixpoint, and proof-theoretic semantics of datalog. As a rule, we introduce only the minimum amount of terminology from logic programming needed in the special database case. However, we make brief excursions into the wider framework in the text and exercises. The last section deals with static analysis of datalog programs. It provides decidability and undecidability results for several fundamental properties of programs. Techniques for the evaluation of datalog programs are discussed separately in Chapter 13.

12.1
Syntax of Datalog
As mentioned earlier, the syntax of datalog is similar to that of languages introduced in Chapter 4. It is an extension of nonrecursive datalog, which was introduced in Chapter 4.

We provide next a detailed definition of its syntax. We also briefly introduce some of the fundamental differences between datalog and logic programming.

Definition 12.1.1
A (datalog) rule is an expression of the form
R1(u1) ← R2(u2), . . . , Rn(un),
where n ≥ 1, R1, . . . , Rn are relation names and u1, . . . , un are free tuples of appropriate arities. Each variable occurring in u1 must occur in at least one of u2, . . . , un. A datalog program is a finite set of datalog rules.

The head of the rule is the expression R1(u1); and R2(u2), . . . , Rn(un) forms the body.

The set of constants occurring in a datalog program P is denoted adom(P ); and for an instance I, we use adom(P , I) as an abbreviation for adom(P ) ∪ adom(I).

We next recall a definition from Chapter 4 that is central to this chapter.

12.1 Syntax of Datalog
277
Definition 12.1.2
Given a valuation ν, an instantiation
R1(ν(u1)) ← R2(ν(u2)), . . . , Rn(ν(un))
of a rule R1(u1) ← R2(u2), . . . , Rn(un) with ν is obtained by replacing each variable x by ν(x).

Let P be a datalog program. An extensional relation is a relation occurring only in the body of the rules. An intensional relation is a relation occurring in the head of some rule of P . The extensional (database) schema, denoted edb(P ), consists of the set of all extensional relation names; whereas the intensional schema idb(P ) consists of all the intensional ones. The schema of P , denoted sch(P ), is the union of edb(P ) and idb(P ). The semantics of a datalog program is a mapping from database instances over edb(P ) to database instances over idb(P ). In some contexts, we call the input data the extensional database and the program the intensional database. Note also that in the context of logic-based languages, the term predicate is often used in place of the term relation name.

Let us consider an example.

Example 12.1.3
The following program P metro computes the answers to queries (12.1), (12.2), and (12.3):
St _ Reachable(x, x) ←
St _ Reachable(x, y) ← St _ Reachable(x, z), Links(u, z, y) Li _ Reachable(x, u) ← St _ Reachable(x, z), Links(u, z, y) Ans _1(y)
← St _ Reachable( Odeon, y)
Ans _2(u)
← Li _ Reachable( Odeon, u)
Ans _3()
← St _ Reachable( Odeon, Chatelet)
Observe that St _ Reachable is defined using recursion. Clearly, edb(P metro) = { Links},
idb(P metro) = { St _ Reachable, Li _ Reachable, Ans _ 1, Ans _ 2, Ans _ 3}
For example, an instantiation of the second rule of P metro is as follows: St _ Reachable( Odeon, Louvre) ← St _ Reachable( Odeon, Chatelet), Links(1, Chatelet, Louvre)
278
Datalog
Datalog versus Logic Programming
Given the close correspondence between datalog and logic programming, we briefly highlight the central differences between these two fields. The major difference is that logic programming permits function symbols, but datalog does not.

Example 12.1.4
The simple logic program Pleq is given by
leq(0, x) ←
leq(s(x), s(y)) ← leq(x, y)
leq(x, +(x, y)) ←
leq(x, z) ← leq(x, y), leq(y, z)
Here 0 is a constant, s a unary function sysmbol, + a binary function sysmbol, and leq a binary predicate. Intuitively, s might be viewed as the successor function, + as addition, and leq as capturing the less-than-or-equal relation. However, in logic programming the function symbols are given the “free” interpretation—two terms are considered nonequal whenever they are syntactically different. For example, the terms +(0, s(0)), +(s(0), 0), and s(0) are all nonequal. Importantly, functional terms can be used in logic programming to represent intricate data structures, such as lists and trees.

Observe also that in the preceding program the variable x occurs in the head of the first rule and not in the body, and analogously for the third rule.

Another important difference between deductive databases and logic programs concerns perspectives on how they are typically used. In databases it is assumed that the database is relatively large and the number of rules relatively small. Furthermore, a datalog program P is typically viewed as defining a mapping from instances over the edb to instances over the idb. In logic programming the focus is different. It is generally assumed that the base data is incorporated directly into the program. For example, in logic programming the contents of instance Link in the Metro database would be represented using rules such as Link(4, St.- Germain, Odeon) ←. Thus if the base data changes, the logic program itself is changed. Another distinction, mentioned in the preceding example, is that logic programs can construct and manipulate complex data structures encoded by terms involving function symbols.

Later in this chapter we present further comparisons of the two frameworks.

12.2
Model-Theoretic Semantics
The key idea of the model-theoretic approach is to view the program as a set of first-order sentences (also called a first-order theory) that describes the desired answer. Thus the database instance constituting the result satisfies the sentences. Such an instance is also called a model of the sentences. However, there can be many (indeed, infinitely many) instances satisfying the sentences of a program. Thus the sentences themselves do not uniquely identify the answer; it is necessary to specify which of the models is
12.2 Model-Theoretic Semantics
279
the intended answer. This is usually done based on assumptions that are external to the sentences themselves. In this section we formalize (1) the relationship between rules and logical sentences, (2) the notion of model, and (3) the concept of intended model.

We begin by associating logical sentences with rules, as we did in the beginning of this chapter. To a datalog rule
ρ : R1(u1) ← R2(u2), . . . , Rn(un)
we associate the logical sentence
∀x1, . . . , xm(R1(u1) ← R2(u2) ∧ · · · ∧ Rn(un)),
where x1, . . . , xm are the variables occurring in the rule and ← is the standard logical implication. Observe that an instance I satisfies ρ, denoted I |= ρ, if for each instantiation R1(ν(u1)) ← R2(ν(u2)), . . . , Rn(ν(un))
such that R2(ν(u2)), . . . , Rn(ν(un)) belong to I, so does R1(ν(u1)). In the following, we do not distinguish between a rule ρ and the associated sentence. For a program P , the conjunction of the sentences associated with the rules of P is denoted by P .

It is useful to note that there are alternative ways to write the sentences associated with rules of programs. In particular, the formula
∀x1, . . . , xm(R1(u1) ← R2(u2) ∧ · · · ∧ Rn(un))
is equivalent to
∀x1, . . . , xq(∃xq+1, . . . , xm(R2(u2) ∧ · · · ∧ Rn(un)) → R1(u1)), where x1, . . . , xq are the variables occurring in the head. It is also logically equivalent to
∀x1, . . . , xm(R1(u1) ∨ ¬R2(u2) ∨ · · · ∨ ¬Rn(un)).

This last form is particularly interesting. Formulas consisting of a disjunction of literals of which at most one is positive are called in logic Horn clauses. A datalog program can thus be viewed as a set of (particular) Horn clauses.

We next discuss the issue of choosing, among the models of P , the particular model that is intended as the answer. This is not a hard problem for datalog, although (as we shall see in Chapter 15) it becomes much more involved if datalog is extended with negation.

For datalog, the idea for choosing the intended model is simply that the model should not contain more facts than necessary for satisfying P . So the intended model is minimal in some natural sense. This is formalized next.

Definition 12.2.1
Let P be a datalog program and I an instance over edb(P ). A model of P is an instance over sch(P ) satisfying P . The semantics of P on input I, denoted P (I), is the minimum model of P containing I, if it exists.

280
Datalog
Ans _1
Station
Ans _2
Line
Odeon
4
St.-Michel
1
Chatelet
Louvres
Palais-Royal
Ans _3
Tuileries
Concorde
〈 〉
Figure 12.2:
Relations of P metro(I)
For P metro as in Example 12.1.3, and I as in Fig. 12.1, the values of Ans _1, Ans _2, and Ans _3 in P (I) are shown in Fig. 12.2.

We briefly discuss the choice of the minimal model at the end of this section.

Although the previous definition is natural, we cannot be entirely satisfied with it at this point:
• For given P and I, we do not know (yet) whether the semantics of P is defined (i.e., whether there exists a minimum model of P containing I).

• Even if such a model exists, the definition does not provide any algorithm for computing P (I). Indeed, it is not (yet) clear that such an algorithm exists.

We next provide simple answers to both of these problems.

Observe that by definition, P (I) is an instance over sch(P ). A priori, we must consider all instances over sch(P ), an infinite set. It turns out that it suffices to consider only those instances with active domain in adom(P , I) (i.e., a finite set of instances). For given P and I, let B(P , I) be the instance over sch(P ) defined by 1. For each R in edb(P ), a fact R(u) is in B(P , I) iff it is in I; and 2. For each R in idb(P ), each fact R(u) with constants in adom(P , I) is in B(P , I).

We now verify that B(P , I) is a model of P containing I.

Lemma 12.2.2
Let P be a datalog program and I an instance over edb(P ). Then B(P , I) is a model of P containing I.

Proof
Let A1 ← A2, . . . , An be an instantiation of some rule r in P such that A2, . . . , An hold in B(P , I). Then consider A1. Because each variable occurring in the head of r also occurs in the body, each constant occurring in A1 belongs to adom(P , I). Thus by definition 2 just given, A1 is in B(P , I). Hence B(P , I) satisfies the sentence associated with that particular rule, so B(P , I) satisfies P . Clearly, B(P , I) contains I by definition 1.

12.2 Model-Theoretic Semantics
281
Thus the semantics of P on input I, if defined, is a subset of B(P , I). This means that there is no need to consider instances with constants outside adom(P , I).

We next demonstrate that P (I) is always defined.

Theorem 12.2.3
Let P be a datalog program, I an instance over edb(P ), and X the set of models of P containing I. Then
1. ∩X is the minimal model of P containing I, so P (I) is defined.

2. adom(P (I)) ⊆ adom(P , I).

3. For each R in edb(P ), P (I)(R) = I(R).

Proof
Note that X is nonempty, because B(P , I) is in X . Let r ≡ A1 ← A2, . . . , An be a rule in P and ν a valuation of the variables occurring in the rule. To prove (1), we show that
(*)
if ν(A2), . . . , ν(An) are in ∩X then ν(A1) is also in ∩X .

For suppose that (*) holds. Then ∩X |= r, so ∩X satisfies P . Because each instance in X
contains I, ∩X contains I. Hence ∩X is a model of P containing I. By construction, ∩X
is minimal, so (1) holds.

To show (*), suppose that ν(A2), . . . , ν(An) are in ∩X and let K be in X . Because
∩X ⊆ K, ν(A2), . . . , ν(An) are in K. Because K is in X , K is a model of P , so ν(A1) is in K. This is true for each K in X . Hence ν(A1) is in ∩X and (*) holds, which in turn proves (1).

By Lemma 12.2.2, B(P , I) is a model of P containing I. Therefore P (I) ⊆ B(P , I).

Hence
• adom(P (I)) ⊆ adom(B(P , I)) = adom(P , I), so (2) holds.

• For each R in edb(P ), I(R) ⊆ P (I)(R) [because P (I) contains I] and P (I)(R) ⊆
B(P , I)(R) = I(R); which shows (3).

The previous development also provides an algorithm for computing the semantics of datalog programs. Given P and I, it suffices to consider all instances that are subsets of B(P , I), find those that are models of P and contain I, and compute their intersection. However, this is clearly an inefficient procedure. The next section provides a more reasonable algorithm.

We conclude this section with two remarks on the definition of semantics of datalog programs. The first explains the choice of a minimal model. The second rephrases our definition in more standard logic-programming terminology.

Why Choose the Minimal Model?

This choice is the natural consequence of an implicit hypothesis of a philosophical nature: the closed world assumption (CWA) (see Chapter 2).

The CWA concerns the connection between the database and the world it models.

282
Datalog
Clearly, databases are often incomplete (i.e., facts that may be true in the world are not necessarily recorded in the database). Thus, although we can reasonably assume that a fact recorded in the database is true in the world, it is not clear what we can say about facts not explicitly recorded. Should they be considered false, true, or unknown? The CWA provides the simplest solution to this problem: Treat the database as if it records complete information about the world (i.e., assume that all facts not in the database are false). This is equivalent to taking as true only the facts that must be true in all worlds modeled by the database. By extension, this justifies the choice of minimal model as the semantics of a datalog program. Indeed, the minimal model consists of the facts we know must be true in all worlds satisfying the sentences (and including the input instance). As we shall see, this has an equivalent proof-theoretic counterpart, which will justify the proof-theoretic semantics of datalog programs: Take as true precisely the facts that can be proven true from the input and the sentences corresponding to the datalog program. Facts that cannot be proven are therefore considered false.

Importantly, the CWA is not so simple to use in the presence of negation or disjunction.

For example, suppose that a database holds {p ∨ q}. Under the CWA, then both ¬p and
¬q are inferred. But the union {p ∨ q, ¬p, ¬q} is inconsistent, which is certainly not the intended result.

Herbrand Interpretation
We relate briefly the semantics given to datalog programs to standard logic-programming terminology.

In logic programming, the facts of an input instance I are not separated from the sentences of a datalog program P . Instead, sentences stating that all facts in I are true are included in P . This gives rise to a logical theory P, I consisting of the sentences in P
and of one sentence P (u) [sometimes written P (u) ←] for each fact P (u) in the instance.

The semantics is defined as a particular model of this set of sentences. A problem is that standard interpretations in first-order logic permit interpretation of constants of the theory with arbitrary elements of the domain. For instance, the constants Odeon and St.-Michel may be interpreted by the same element (e.g., John). This is clearly not what we mean in the database context. We wish to interpret Odeon by Odeon and similarly for all other constants. Interpretations that use the identity function to interpret the constant symbols are called Herbrand interpretations (see Chapter 2). (If function symbols are present, restrictions are also placed on how terms involving functions are interpreted.) Given a set Ŵ of formulas, a Herbrand model of Ŵ is a Herbrand interpretation satisfying Ŵ.

Thus in logic programming terms, the semantics of a program P given an instance I can be viewed as the minimum Herbrand model of P, I.

12.3
Fixpoint Semantics
In this section, we present an operational semantics for datalog programs stemming from fixpoint theory. We use an operator called the immediate consequence operator. The operator produces new facts starting from known facts. We show that the model-theoretic se-
12.3 Fixpoint Semantics
283
mantics, P (I), can also be defined as the smallest solution of a fixpoint equation involving that operator. It turns out that this solution can be obtained constructively. This approach therefore provides an alternative constructive definition of the semantics of datalog programs. It can be viewed as an implementation of the model-theoretic semantics.

Let P be a datalog program and K an instance over sch(P ). A fact A is an immediate consequence for K and P if either A ∈ K(R) for some edb relation R, or A ← A1, . . . , An is an instantiation of a rule in P and each Ai is in K. The immediate consequence operator of P , denoted TP , is the mapping from inst( sch(P )) to inst( sch(P )) defined as follows.

For each K, TP (K) consists of all facts A that are immediate consequences for K and P .

We next note some simple mathematical properties of the operator TP over sets of instances. We first define two useful properties. For an operator T ,
• T is monotone if for each I, J, I ⊆ J implies T (I) ⊆ T (J).

• K is a fixpoint of T if T (K) = K.

The proof of the next lemma is straightforward and is omitted (see Exercise 12.9).

Lemma 12.3.1
Let P be a datalog program.

(i) The operator TP is monotone.

(ii) An instance K over sch(P ) is a model of P iff TP (K) ⊆ K.

(iii) Each fixpoint of TP is a model of P ; the converse does not necessarily hold.

It turns out that P (I) (as defined by the model-theoretic semantics) is a fixpoint of TP .

In particular, it is the minimum fixpoint containing I. This is shown next.

Theorem 12.3.2
For each P and I, TP has a minimum fixpoint containing I, which equals P (I).

Proof
Observe first that P (I) is a fixpoint of TP :
• TP (P (I)) ⊆ P (I) because P (I) is a model of P ; and
• P (I) ⊆ TP (P (I)). [Because TP (P (I)) ⊆ P (I) and TP is monotone, TP (TP (P (I)))
⊆ TP (P (I)). Thus TP (P (I)) is a model of P . Because TP preserves the contents of the edb relations and I ⊆ P (I), we have I ⊆ TP (P (I)). Thus TP (P (I)) is a model of P containing I. Because P (I) is the minimum such model, P (I) ⊆ TP (P (I)).]
In addition, each fixpoint of TP containing I is a model of P and thus contains P (I) (which is the intersection of all models of P containing I). Thus P (I) is the minimum fixpoint of P containing I.

The fixpoint definition of the semantics of P presents the advantage of leading to a constructive definition of P (I). In logic programming, this is shown using fixpoint theory (i.e., using Knaster-Tarski’s and Kleene’s theorems). However, the database framework is much simpler than the general logic-programming one, primarily due to the lack of function symbols. We therefore choose to show the construction directly, without the formidable machinery of the theory of fixpoints in complete lattices. In Remark 12.3.5
284
Datalog
we sketch the more standard proof that has the advantage of being applicable to the larger context of logic programming.

Given an instance I over edb(P ), one can compute TP (I), T 2(I), T 3(I), etc. Clearly, P
P
I ⊆ TP (I) ⊆ T 2
P (I) ⊆ T 3(I) . . . ⊆ B(P , I).

P
This follows immediately from the fact that I ⊆ TP (I) and the monotonicity of TP . Let N
be the number of facts in B(P , I). (Observe that N depends on I.) The sequence {T i (I)}
P
i
reaches a fixpoint after at most N steps. That is, for each i ≥ N , T i (I) = T N (I). In P
P
particular, TP (T N(I)) = T N(I), so T N(I) is a fixpoint of T
P
P
P
P . We denote this fixpoint by
T ω(I).

P
Example 12.3.3
Recall the program PT C for computing the transitive closure of a
graph G:
T (x, y) ← G(x, y)
T (x, y) ← G(x, z), T (z, y).

Consider the input instance
I = {G(1, 2), G(2, 3), G(3, 4), G(4, 5)}.

Then we have
TP (I ) = I ∪ {T (1, 2), T (2, 3), T (3, 4), T (4, 5)}
T C
T 2
P
(I ) = TP (I ) ∪ {T (1, 3), T (2, 4), T (3, 5)}
T C
T C
T 3 (I ) = T 2 (I ) ∪ {T (1, 4), T (2, 5)}
PT C
PT C
T 4
P
(I ) = T 3 (I ) ∪ {T (1, 5)}
T C
PT C
T 5 (I ) = T 4 (I ).

PT C
PT C
Thus T ω (I ) = T 4 (I ).

PT C
PT C
We next show that T ω(I) is exactly P (I) for each datalog program P .

P
Theorem 12.3.4
Let P be a datalog program and I an instance over edb(P ). Then T ω(I) = P (I).

P
Proof
By Theorem 12.3.2, it suffices to show that T ω(I) is the minimum fixpoint of T
P
P
containing I. As noted earlier,
TP (T ω(I)) = T
(I)) = T N (I) = T ω(I).

P
P (T N
P
P
P
12.3 Fixpoint Semantics
285
where N is the number of facts in B(P , I). Therefore T ω(I) is a fixpoint of T
P
P that con-
tains I.

To show that it is minimal, consider an arbitrary fixpoint J of TP containing I. Then J ⊇ T 0(I) = I. By induction on i, J ⊇ T i (I) for each i, so J ⊇ T ω(I). Thus T ω(I) is the P
P
P
P
minimum fixpoint of TP containing I.

The smallest integer i such that T i (I) = T ω(I) is called the stage for P and I and is P
P
denoted stage(P , I). As already noted, stage(P , I) ≤ N = |B(P , I)|.

Evaluation
The fixpoint approach suggests a straightforward algorithm for the evaluation of datalog.

We explain the algorithm in an example. We extend relational algebra with a while operator that allows us to iterate an algebraic expression while some condition holds. (The resulting language is studied extensively in Chapter 17.)

Consider again the transitive closure query. We wish to compute the transitive closure of relation G in relation T . Both relations are over AB. This computation is performed by the following program:
T : = G;
while q(T ) = T do T : = q(T );
where
q(T ) = G ∪ πAB(δB→C(G) ⊲⊳ δA→C(T )).

(Recall that δ is the renaming operation as introduced in Chapter 4.) Observe that q is an SPJRU expression. In fact, at each step, q computes the immediate consequence operator TP , where P is the transitive closure datalog program in Example 12.3.3. One can show in general that the immediate consequence operator can be computed using SPJRU expressions (i.e., relational algebra without the difference operation). Furthermore, the SPJRU expressions extended carefully with a while construct yield exactly the expressive power of datalog. The test of the while is used to detect when the fixpoint is reached.

The while construct is needed only for recursion. Let us consider again the nonrecursive datalog of Chapter 4. Let P be a datalog program. Consider the graph ( sch(P ), EP ), where S , S ′ is an edge in EP if S′ occurs in the head of some rule r in P and S occurs in the body of r. Then P is nonrecursive if the graph is acyclic. We mentioned already that nr-datalog programs are equivalent to SPJRU queries (see Section 4.5). It is also easy to see that, for each nr-datalog program P , there exists a constant d such that for each I over edb(P ), stage(P , I) ≤ d. In other words, the fixpoint is reached after a bounded number of steps, dependent only on the program. (See Exercise 12.29.) Programs for which this happens are called bounded. We examine this property in more detail in Section 12.5.

A lot of redundant computation is performed when running the preceding transitive closure program. We study optimization techniques for datalog evaluation in Chapter 13.

286
Datalog
Remark 12.3.5
In this remark, we make a brief excursion into standard fixpoint theory to reprove Theorem 12.3.4. This machinery is needed when proving the analog of that theorem in the more general context of logic programming. A partially ordered set (U, ≤) is a complete lattice if each subset has a least upper bound and a greatest lower bound, denoted sup and inf , respectively. In particular, inf (U ) is denoted ⊥ and sup(U ) is denoted
⊤. An operator T on U is monotone iff for each x, y ∈ U , x ≤ y implies T (x) ≤ T (y). An operator T on U is continuous if for each subset V , T ( sup(V )) = sup(T (V )). Note that continuity implies monotonicity.

To each datalog program P and instance I, we associate the program PI consisting of the rules of P and one rule R(u) ← for each fact R(u) in I. We consider the complete lattice formed with ( inst( sch(P )), ⊆) and the operator TP defined by the following: For I
each K, a fact A is in TP (K) if A is an immediate consequence for K and P
I
I. The operator
TP on ( inst( sch(P )), ⊆) is continuous (so also monotone).

I
The Knaster-Tarski theorem states that a monotone operator in a complete lattice has a least fixpoint that equals inf ({x | x ∈ U, T (x) ≤ x}). Thus the least fixpoint of TPI exists. Fixpoint theory also provides the constructive definition of the least fixpoint for continuous operators. Indeed, Kleene’s theorem states that if T is a continuous operator on a complete lattice, then its least fixpoint is sup({Ki | i ≥ 0}) where K0 = ⊥ and for each i > 0, Ki = T (Ki−1). Now in our case, ⊥ = ∅ and
∅ ∪ TP (∅) ∪ · · · ∪ T i (∅) ∪ · · ·
I
PI
coincides with P (I).

In logic programming, function symbols are also considered (see Example 12.1.4). In this context, the sequence of {T i (I)}
P
i>0 does not generally converge in a finite number
I
of steps, so the fixpoint evaluation is no longer constructive. However, it does converge in countably many steps to the least fixpoint ∪{T i (∅) | i ≥ 0}. Thus fixpoint theory is useful PI
primarily when dealing with logic programs with function symbols. It is an overkill in the simpler context of datalog.

12.4
Proof-Theoretic Approach
Another way of defining the semantics of datalog is based on proofs. The basic idea is that the answer of a program P on I consists of the set of facts that can be proven using P and I. The result turns out to coincide, again, with P (I).

The first step is to define what is meant by proof . A proof tree of a fact A from I and P is a labeled tree where
1. each vertex of the tree is labeled by a fact;
2. each leaf is labeled by a fact in I;
3. the root is labeled by A; and
4. for each internal vertex, there exists an instantiation A1 ← A2, . . . , An of a rule in P such that the vertex is labeled A1 and its children are respectively labeled A2, . . . , An.

Such a tree provides a proof of the fact A.

12.4 Proof-Theoretic Approach
287
rule 1
S(1,6)
S
rule 2
T(1,5)
R(5, a,6)
a
T
rule 3
R(1, a,2) R(2, b,3)
T(3,5)
a
b
T
R(3, a,4)
R(4, a,5)
a
a
(a) Datalog proof
(b) Context-free derivation
Figure 12.3:
Proof tree
Example 12.4.1
Consider the following program:
S(x1, x3) ← T (x1, x2), R(x2, a, x3)
T (x1, x4) ← R(x1, a, x2), R(x2, b, x3), T (x3, x4)
T (x1, x3) ← R(x1, a, x2), R(x2, a, x3)
and the instance
{R(1, a, 2), R(2, b, 3), R(3, a, 4), R(4, a, 5), R(5, a, 6)}.

A proof tree of S(1, 6) is shown in Fig. 12.3(a).

The reader familiar with context-free languages will notice the similarity between proof trees and derivation trees in context-free languages. This connection is especially strong in the case of datalog programs that have the form of the one in Example 12.4.1.

This will be exploited in the last section of this chapter.

Proof trees provide proofs of facts. It is straightforward to show that a fact A is in P (I) iff there exists a proof tree for A from I and P . Now given a fact A to prove, one can look for a proof either bottom up or top down.

The bottom-up approach is an alternative way of looking at the constructive fixpoint technique. One begins with the facts from I and then uses the rules to infer new facts, much like the immediate consequence operator. This is done repeatedly until no new facts can be inferred. The rules are used as “factories” producing new facts from already proven ones.

This eventually yields all facts that can be proven and is essentially the same as the fixpoint approach.

In contrast to the bottom-up and fixpoint approaches, the top-down approach allows one to direct the search for a proof when one is only interested in proving particular facts.

288
Datalog
For example, suppose the query Ans _1( Louvre) is posed against the program P metro of Example 12.1.3, with the input instance of Fig. 12.1. Then the top-down approach will never consider atoms involving stations on Line 9, intuitively because they are are not reachable from Odeon or Louvre. More generally, the top-down approach inhibits the indiscriminate inference of facts that are irrelevant to the facts of interest.

The top-down approach is described next. This takes us to the field of logic programming. But first we need some notation, which will remind us once again that “To bar an easy access to newcomers every scientific domain has introduced its own terminology and notation” [Apt91].

Notation
Although we already borrowed a lot of terminology and notation from the logic-programming field (e.g., term, fact, atom), we must briefly introduce some more.

A positive literal is an atom [i.e., P (u) for some free tuple u]; and a negative literal is the negation of one [i.e., ¬P (u)]. A formula of the form
∀x1, . . . , xm(A1 ∨ · · · ∨ An ∨ ¬B1 ∨ · · · ∨ ¬Bp),
where the Ai, Bj are positive literals, is called a clause. Such a clause is written in clausal form as
A1, . . . , An ← B1, . . . , Bp.

A clause with a single literal in the head (n = 1) is called a definite clause. A definite clause with an empty body is called a unit clause. A clause with no literal in the head is called a goal clause. A clause with an empty body and head is called an empty clause and is denoted
. Examples of these and their logical counterparts are as follows:
definite
T (x, y) ← R(x, z), T (z, y)
T (x, y) ∨ ¬R(x, z) ∨ ¬T (z, y)
unit
T (x, y) ←
T (x, y)
goal
← R(x, z), T (z, y)
¬R(x, z) ∨ ¬T (z, y)
empty
false
The empty clause is interpreted as a contradiction. Intuitively, this is because it corresponds to the disjunction of an empty set of formulas.

A ground clause is a clause with no occurrence of variables.

The top-down proof technique introduced here is called SLD resolution. Goals serve as the basic focus of activity in SLD resolution. As we shall see, the procedure begins with a goal such as ← St _ Reachable(x, Concorde), Li _ Reachable(x, 9). A correct answer of this goal on input I is any value a such that St _ Reachable(a, Concorde) and Li _ Reachable(a, 9) are implied by P
. Furthermore, each intermediate step of the
metro, I
top-down approach consists of obtaining a new goal from a previous goal. Finally, the procedure is deemed successful if the final goal reached is empty.

The standard exposition of SLD resolution is based on definite clauses. There is a
12.4 Proof-Theoretic Approach
289
subtle distinction between datalog rules and definite clauses: For datalog rules, we imposed the restriction that each variable that occurs in the head also appears in the body. (In particular, a datalog unit clause must be ground.) We will briefly mention some minor consequences of this distinction.

As already introduced in Remark 12.3.5, to each datalog program P and instance I, we associate the program PI consisting of the rules of P and one rule R(u) ← for each fact R(u) in I. Therefore in the following we ignore the instance I and focus on programs that already integrate all the known facts in the set of rules. We denote such a program PI to emphasize its relationship to an instance I. Observe that from a semantic point of view P (I) = PI(∅).

This ignores the distinction between edb and idb relations, which no longer exists for PI.

Example 12.4.2
Consider the program P and instance I of Example 12.4.1. The rules of PI are
1. S(x1, x3) ← T (x1, x2), R(x2, a, x3)
2. T (x1, x4) ← R(x1, a, x2), R(x2, b, x3), T (x3, x4)
3. T (x1, x3) ← R(x1, a, x2), R(x2, a, x3)
4. R(1, a, 2) ←
5. R(2, b, 3) ←
6. R(3, a, 4) ←
7. R(4, a, 5) ←
8. R(5, a, 6) ←
Warm-Up
Before discussing SLD resolution, as a warm-up we look at a simplified version of the technique by considering only ground rules. To this end, consider a datalog program PI (integrating the facts) consisting only of fully instantiated rules (i.e., with no occurrences of variables). Consider a ground goal g ≡
← A1, . . . , Ai, . . . , An
and some (ground) rule r ≡ Ai ← B1, . . . , Bm in PI. A resolvent of g with r is the ground goal
← A1, . . . , Ai−1, B1, . . . , Bm, Ai+1, . . . , An.

Viewed as logical sentences, the resolvent of g with r is actually implied by g and r.

This is best seen by writing these explicitly as clauses:
290
Datalog
← S(1,6)
S(1,6) ← T(1,5), R(5, a,6)
← T(1,5),
R(5, a,6)
T(1,5) ← R(1, a,2), R(2, b,3), T(3,5)
← R(1, a,2), R(2, b,3), T(3,5), R(5, a,6) R(1, a,2) ←
← R(2, b,3), T(3,5), R(5, a,6) R(2, b,3) ←
← T(3,5),
R(5, a,6)
T(3,5) ← R(3, a,4), R(4, a,5)
← R(3, a,4), R(4, a,5), R(5, a,6) R(3, a,4) ←
← R(4, a,5), R(5, a,6)
R(4, a,5) ←
← R(5, a,6)
R(5, a,6) ←
←
Figure 12.4:
SLD ground refutation
(¬A1 ∨ · · · ∨ ¬Ai ∨ · · · ∨ ¬An) ∧ (Ai ∨ ¬B1 ∨ · · · ∨ ¬Bm)
⇒ (¬A1 ∨ · · · ∨ ¬Ai−1 ∨ ¬B1 ∨ · · · ∨ ¬Bm ∨ ¬Ai+1 ∨ · · · ∨ ¬An).

In general, the converse does not hold.

A derivation from g with PI is a sequence of goals g ≡ g0, g1, . . . such that for each i > 0, gi is a resolvent of gi−1 with some rule in PI. We will see that to prove a fact A, it suffices to exhibit a refutation of ← A—that is, a derivation g0 ≡← A,
g1, . . . , gi, . . . ,
gq ≡ .

Example 12.4.3
Consider Example 12.4.1 and the program obtained by all possible
instantiations of the rules of PI in Example 12.4.2. An SLD ground refutation is shown in Fig. 12.4. It is a refutation of ← S(1, 6) [i.e. a proof of S(1, 6)].

Let us now explain why refutations provide proofs of facts. Suppose that we wish to prove A1 ∧ · · · ∧ An. To do this we may equivalently prove that its negation (i.e. ¬A1 ∨
· · · ∨ ¬An) is false. In other words, we try to refute (or disprove) ← A1, . . . , An. The following rephrasing of the refutation in Fig. 12.4 should make this crystal clear.

12.4 Proof-Theoretic Approach
291
Example 12.4.4
Continuing with the previous example, to prove S(1, 6), we try to refute its negation [i.e., ¬S(1, 6) or ← S(1, 6)]. This leads us to considering, in turn, the formulas Goal
Rule used
¬S(1, 6)
(1)
⇒ ¬T (1, 5) ∨ ¬R(5, a, 6)
(2)
⇒ ¬R(1, a, 2) ∨ ¬R(2, b, 3) ∨ ¬T (3, 5) ∨ ¬R(5, a, 6)
(4)
⇒ ¬R(2, b, 3) ∨ ¬T (3, 5) ∨ ¬R(5, a, 6)
(5)
⇒ ¬T (3, 5) ∨ ¬R(5, a, 6)
(3)
⇒ ¬R(3, a, 4) ∨ ¬R(4, a, 5) ∨ ¬R(5, a, 6)
(6)
⇒ ¬R(4, a, 5) ∨ ¬R(5, a, 6)
(7)
⇒ ¬R(5, a, 6)
(8)
⇒ false
At the end of the derivation, we have obtained a contradiction. Thus we have refuted
¬S(1, 6) [i.e., proved S(1, 6)].

Thus refutations provide proofs. As a consequence, a goal can be thought of as a query.

Indeed, the arrow is sometimes denoted with a question mark in goals. For instance, we sometimes write
?- S(1, 6) for ← S(1, 6).

Observe that the process of finding a proof is nondeterministic for two reasons: the choice of the literal A to replace and the rule that is used to replace it.

We now have a technique for proving facts. The benefit of this technique is that it is sound and complete, in the sense that the set of facts in P (I) coincides with the facts that can be proven from PI.

Theorem 12.4.5
Let PI be a datalog program and ground(PI) be the set of instantiations of rules in PI with values in adom(P , I). Then for each ground goal g, PI(∅) |= ¬g iff there exists a refutation of g with ground(PI).

Crux
To show the “only if,” we prove by induction that
for each ground goal g, if T i (∅) |= ¬g,
(**)
PI
there exists a refutation of g with ground(PI).

(The “if” part is proved similarly by induction on the length of the refutation. Its proof is left for Exercise 12.18.)

The base case is obvious. Now suppose that (**) holds for some i ≥ 0, and let A1, . . . , Am be ground atoms such that T i+1(∅) |= A
P
1 ∧ · · · ∧ Am. Therefore each Aj is
I
in T i+1(∅). Consider some j . If A
P
j is an edb fact, we are back to the base case. Otherwise
I
292
Datalog
← S(1, x)
S( x 1, x 3) ← T( x 1, x 2), R( x 2, a, x 3)
← T(1, x
R( x
2),
2, a, x)
T( x 1, x 4) ← R( x 1, a, x 2), R( x 2, b, x 3), T( x 3, x 4)
← R(1, a, y
R( y
2),
2, b, x 3), T( x 3, x 2), R( x 2, a, x) R(1, a,2) ←
← R(2, b, x
T( x
3),
3, x 2), R( x 2, a, x)
R(2, b,3) ←
← T(3, x
R( x
2),
2, a, x)
T( x 1, x 3) ← R( x 1, a, x 2), R( x 2, a, x 3)
← R(3, a, z
R( z
2),
2, a, x 2), R( x 2, a, x) R(3, a,4) ←
← R(4, a, x
R( x
2),
2, a, x)
R(4, a,5) ←
← R(5, a, x)
R(5, a,6) ←
←
Figure 12.5:
SLD refutation
there exists an instantiation Aj ← B1, . . . , Bp of some rule in PI such that B1, . . . , Bp are in T i (∅). The refutation of ← A
P
j with ground(PI) is as follows. It starts with
I
← Aj
← B1, B2 . . . , Bp.

Now by induction there exist refutations of ← Bn, 1 ≤ n ≤ p, with ground(PI). Using these refutations, one can extend the preceding derivation to a derivation leading to the empty clause. Furthermore, the refutations for each of the Aj ’s can be combined to obtain a refutation of ← A1, . . . , Am as desired. Therefore (**) holds for i + 1. By induction, (**) holds.

SLD Resolution
The main difference between the general case and the warm-up is that we now handle goals and tuples with variables rather than just ground ones. In addition to obtaining the goal , the process determines an instantiation θ for the free variables of the goal g, such that PI(∅) |= ¬θg. We start with an example: An SLD refutation of ← S(1, x) is shown in Fig. 12.5.

In general, we start with a goal (which does not have to be ground):
12.4 Proof-Theoretic Approach
293
← A1, . . . , Ai, . . . , An.

Suppose that we selected a literal to be replaced [e.g., Ai = Q(1, x2, x5)]. Any rule used for the replacement must have Q for predicate in the head, just as in the ground case. For instance, we might try some rule
Q(x1, x4, x3) ← P (x1, x2), P (x2, x3), Q(x3, x4, x5).

We now have two difficulties:
(i) The same variable may occur in the selected literal and in the rule with two different meanings. For instance, x2 in the selected literal is not to be confused with x2 in the rule.

(ii) The pattern of constants and of equalities between variables in the selected literal and in the head of the rule may be different. In our example, for the first attribute we have 1 in the selected literal and a variable in the rule head.

The first of these two difficulties is handled easily by renaming the variables of the rules.

We shall use the following renaming discipline: Each time a rule is used, a new set of distinct variables is substituted for the ones in the rule. Thus we might use instead the rule Q(x11, x14, x13) ← P (x11, x12), P (x12, x13), Q(x13, x14, x15).

The second difficulty requires a more careful approach. It is tackled using unification, which matches the pattern of the selected literal to that of the head of the rule, if possible.

In the example, unification consists of finding a substitution θ such that θ (Q(1, x2, x5)) =
θ (Q(x11, x14, x13)). Such a substitution is called a unifier. For example, the substitution θ (x11) = 1, θ(x2) = θ(x14) = θ(x5) = θ(x13) = y is a unifier for Q(1, x2, x5) and Q(x11, x14, x13), because θ (Q(1, x2, x5)) = θ (Q(x11, x14, x13)) = Q(1, y, y). Note that this particular unifier is unnecessarily restrictive; there is no reason to identify all of x2, x3, x4, x5.

A unifier that is no more restrictive than needed to unify the atoms is called a most general unifier (mgu). Applying the mgu to the rule to be used results in specializing the rule just enough so that it applies to the selected literal. These terms are formalized next.

Definition 12.4.6
Let A, B be two atoms. A unifier for A and B is a substitution θ such that θ A = θ B. A substitution θ is more general than a substitution ν, denoted θ ֒→ ν, if for some substitution ν′, ν = θ ◦ ν′. A most general unifier (mgu) for A and B is a unifier θ for A, B such that, for each unifier ν of A, B, we have θ ֒→ ν.

Clearly, the relation ֒→ between unifiers is reflexive and transitive but not antisymmetric. Let ≈ be the equivalence relation on substitutions defined by θ ≈ ν iff θ ֒→ ν and ν ֒→ θ . If θ ≈ ν, then for each atom A, θ (A) and ν(A) are the same modulo renaming of variables.

294
Datalog
Computing the mgu
We now develop an algorithm for computing an mgu for two atoms. Let R be a relation of arity p and R(x1, . . . , xp), R(y1, . . . , yp) two literals with disjoint sets of variables.

Compute ≡, the equivalence relation on var ∪ dom defined as the reflexive, transitive closure of: xi ≡ yi for each i in [1, p]. The mgu of R(x1, . . . , xp) and R(y1, . . . , yp) does not exist if two distinct constants are in the same equivalence class. Otherwise their mgu is the substitution θ such that
1. If z ≡ a for some constant a, θ (z) = a;
2. Otherwise θ (z) = z′, where z′ is the smallest (under a fixed ordering on var) such that z ≡ z′.

We show that the foregoing computes an mgu.

Lemma 12.4.7
The substitution θ just computed is an mgu for R(x1, . . . , xp) and R(y1, . . . , yp).

Proof
Clearly, θ is a unifier for R(x1, . . . , xp) and R(y1, . . . , yp). Suppose ν is another unifier for the same atoms. Let ≡ν be the equivalence relation on var ∪ dom defined by x ≡ν y iff ν(x) = ν(y). Because ν is a unifier, ν(xi) = ν(yi). It follows that xi ≡ν yi, so
≡ refines ≡ν. Then the substitution ν′ defined by ν′(θ(x)) = ν(x), is well defined, because θ (x) = θ (x′) implies ν(x) = ν(x′). Thus ν = θ ◦ ν′ so θ ֒→ ν. Because this holds for every unifier ν, it follows that θ is an mgu for the aforementioned atoms.

The following facts about mgu’s are important to note. Their proof is left to the reader (Exercise 12.19). In particular, part (ii) of the lemma says that the mgu of two atoms, if it exists, is essentially unique (modulo renaming of variables).

Lemma 12.4.8
Let A, B be atoms.

(i) If there exists a unifier for A, B, then A, B have an mgu.

(ii) If θ and θ ′ are mgu’s for A, B then θ ≈ θ ′.

(iii) Let A, B be atoms with mgu θ . Then for each atom C, if C = θ1A = θ2B for substitutions θ1, θ2, then C = θ3(θ(A)) = θ3(θ(B)) for some substitution θ3.

We are now ready to rephrase the notion of resolvent to incorporate variables. Let g ≡← A1, . . . , Ai, . . . , An,
r ≡ B1 ← B2, . . . , Bm
be a goal and a rule such that
1. g and r have no variable in common (which can always be ensured by renaming the variables of the rule).

2. Ai and B1 have an mgu θ.

12.4 Proof-Theoretic Approach
295
Then the resolvent of g with r using θ is the goal
← θ(A1), . . . , θ(Ai−1), θ(B2), . . . , θ(Bm), θ(Ai+1), . . . , θ(An).

As before, it is easily verified that this resolvent is implied by g and r.

An SLD derivation from a goal g with a program PI is a sequence g0 = g, g1, . . . of goals and θ0, . . . of substitutions such that for each j , gj is the resolvent of gj−1 with some rule in PI using θj . An SLD refutation of a goal g with P
1
I is an SLD derivation
g0 = g, . . . , gq =
with PI.

We now explain the meaning of such a refutation. As in the variable-free case, the existence of a refutation of a goal ← A1, . . . , An with PI can be viewed as a proof of the negation of the goal. The goal is
∀x1, . . . , xm(¬A1 ∨ · · · ∨ ¬An)
where x1, . . . , xm are the variables in the goal. Its negation is therefore equivalent to
∃x1, . . . , xm(A1 ∧ · · · ∧ An),
and the refutation can be seen as a proof of its validity. Note that, in the case of datalog programs (where by definition all unit clauses are ground), the composition θ1 ◦ · · · ◦ θq of mgu’s used while refuting the goal yields a substitution by constants. This substitution provides “witnesses” for the existence of the variables x1, . . . , xm making true the conjunction. In particular, by enumerating all refutations of the goal, one could obtain all values for the variables satisfying the conjunction—that is, the answer to the query
{ x1, . . . , xm | A1 ∧ · · · ∧ An}.

This is not the case when one allows arbitrary definite clauses rather than datalog rules, as illustrated in the following example.

Example 12.4.9
Consider the program
S(x, z) ← G(x, z)
S(x, z) ← G(x, y), S(y, z)
S(x, x) ←
that computes in S the reflexive transitive closure of graph G. This is a set of definite clauses but not a datalog program because of the last rule. However, resolution can be extended to (and is indeed in general presented for) definite clauses. Observe, for instance, that the goal
← S(w, w) is refuted with a substitution that does not bind variable w to a constant.

SLD resolution is a technique that provides proofs of facts. One must be sure that it produces only correct proofs (soundness) and that it is powerful enough to prove all
296
Datalog
true facts (completeness). To conclude this section, we demonstrate the soundness and completeness of SLD resolution for datalog programs.

We use the following lemma:
Lemma 12.4.10
Let g ≡← A1, . . . , Ai, . . . , An and r ≡ B1 ← B2, . . . , Bm be a goal and a rule with no variables in common, and let
g′ ≡← A1, . . . , Ai−1, B2, . . . , Bm, Ai+1, . . . , An.

If θg′ is a resolvent of g with r using θ , then the formula r implies: r′ ≡ ¬θg′ → ¬θg
= θ(A1 ∧ · · · ∧ Ai−1 ∧ B2 ∧ · · · ∧ Bm ∧ Ai+1 ∧ · · · ∧ An) → θ(A1 ∧ · · · ∧ An).

Proof
Let J be an instance over sch(P ) satisfying r and let valuation ν be such that J |= ν[θ (A1) ∧ · · · ∧ θ(Ai−1) ∧ θ(B2) ∧ · · · ∧ θ(Bm) ∧ θ(Ai+1) ∧ · · · ∧ θ(An)].

Because
J |= ν[θ (B2) ∧ · · · ∧ θ(Bm)]
and J |= B1 ← B2, . . . , Bm, J |= ν[θ(B1)]. That is, J |= ν[θ(Ai)]. Thus J |= ν[θ (A1) ∧ · · · ∧ θ(An)].

Hence for each ν, J |= νr′. Therefore J |= r′. Thus each instance over sch(P ) satisfying r also satisfies r′, so r implies r′.

Using this lemma, we have the following:
Theorem 12.4.11
(Soundness of SLD resolution) Let PI be a program and g ≡←
A1, . . . , An a goal. If there exists an SLD-refutation of g with PI and mgu’s θ1, . . . , θq, then PI implies
θ1 ◦ · · · ◦ θq(A1 ∧ · · · ∧ An).

Proof
Let J be some instance over sch(P ) satisfying PI. Let g0 = g, . . . , gq =
be an
SLD refutation of g with PI and for each j , let gj be a resolvent of gj−1 with some rule in PI using some mgu θj . Then for each j , the rule that is used implies ¬gj → θj (¬gj−1) by Lemma 12.4.10. Because J satisfies PI, for each j ,
J |= ¬gj → θj (¬gj−1).

12.4 Proof-Theoretic Approach
297
Clearly, this implies that for each j ,
J |= θj+1 ◦ · · · ◦ θq(¬gj ) → θj ◦ · · · ◦ θq(¬gj−1).

By transitivity, this shows that
J |= ¬gq → θ1 ◦ · · · ◦ θq(¬g0),
and so
J |= true → θ1 ◦ · · · ◦ θq(¬g).

Thus J |= θ1 ◦ · · · ◦ θq(A1 ∧ · · · ∧ An).

We next prove the converse of the previous result (namely, the completeness of SLD
resolution).

Theorem 12.4.12
(Completeness of SLD resolution) Let PI be a program and g ≡←
A1, . . . , An a goal. If PI implies ¬g, then there exists a refutation of g with PI.

Proof
Suppose that PI implies ¬g. Consider the set ground(PI) of instantiations of rules in PI with constants in adom(P , I). Clearly, ground(PI)(∅) is a model of PI, so it satisfies
¬g. Thus there exists a valuation θ of the variables in g such that ground(PI)(∅) satisfies
¬θg. By Theorem 12.4.5, there exists a refutation of θg using ground(PI).

Let g0 = θg, . . . , gp =
be that refutation. We show by induction on k that for each
k in [0, p],
(†) there exists a derivation g′ =
0
g, . . . , g′ with
for some
k
PI such that gk = θkg′k
θk.

For suppose that (†) holds for each k. Then for k = p, there exists a derivation g′ =
1
g, . . . , g′ with
for some
= . Therefore there exists
p
PI such that
= gp = θpg′p
θp, so g′p
a refutation of g with PI.

The basis of the induction holds because g0 = θg = θg′ . Now suppose that (†) holds 0
for some k. The next step of the refutation consists of selecting some atom B of gk and applying a rule r in ground(PI). In g′ select the atom B′ with location in g′ corresponding k
to the location of B in gk. Note that B = θkB′. In addition, we know that there is rule r′′ = B′′ ← A′′ . . . A′′ in P
1
n
I that has r for instantiation via some substitution θ ′′ (such a pair B′, r′′ exists although it may not be unique). As usual, we can assume that the variables in g′ are disjoint from those in r′′. Let θ
k
k ⊕ θ ′′ be the substitution defined by
θk ⊕ θ ′′(x) = θk(x) if x is a variable in g′ , and θ
k
k ⊕ θ ′′(x) = θ ′′(x) if x is a variable in r ′′.

Clearly, θk ⊕ θ′′(B′) = θk ⊕ θ′′(B′′) = B so, by Lemma 12.4.8 (i), B′ and B′′ have some mgu θ . Let g′
be the resolvent of g′ with r′′, B′ using mgu θ . By the definition of mgu, k+1
k
there exists a substitution θk+1 such that θk ⊕ θ′′ = θ ◦ θk+1. Clearly, θk+1(g′
) = g
k+1
k+1
and (†) holds for k + 1. By induction, (†) holds for each k.

298
Datalog
← S(1, x)
1: x 1/1, x 3/ x
← T(1, x 2), R( x 2, a, x) 2: x 1/1, x 2/ y 2, x 4/ x 2
← R(1, a, y 2), R( y 2, b, x 3), T( x 3, x 2), R( x 2, a, x) 2
3: x 1/ x 3, x 2/ z 2, x 3/ x 2
← R(1, a, y 2), R( y 2, b, x 3), R( x 3, a, z 2), T( z 3, x 2), R( x 2, a, x) 4: y 2/2
← R(2, b, x 3), R( x 3, a, z 2), R( z 2, a, x 2), R( x 2, a, x) 5: x
3: x
3/3
1/1, x 2/ y 2, x 3/ x 2
← R(3, a, z
← R(1, a, y
2), R( z 2, a, x 2), R( x 2, a, x) 2), R( y 2, a, x 2), R( x 2, a, x) 6: z
4: y
2/4
2/1
← R(4, a, x
← R(1, a,1), R(1, a, x
2), R( x 2, a, x)
2), R( x 2, a, x)
7: x 2/5
Infinite
← R(5, a, x)
no possible derivation
subtree
8: x/6
Figure 12.6:
SLD tree
SLD Trees
We have shown that SLD resolution is sound and complete. Thus it provides an adequate top-down technique for obtaining the facts in the answer to a datalog program. To prove that a fact is in the answer, one must search for a refutation of the corresponding goal. Clearly, there are many refutations possible. There are two sources of nondeterminism in searching for a refutation: (1) the choice of the selected atom, and (2) the choice of the clause to unify with the atom. Now let us assume that we have fixed some golden rule, called a selection rule, for choosing which atom to select at each step in a refutation. A priori, such a rule may be very simple (e.g., as in Prolog, always take the leftmost atom) or in contrast very involved, taking into account the entire history of the refutation. Once an atom has been selected, we can systematically search for all possible unifying rules. Such a search can be represented in an SLD tree. For instance, consider the tree of Fig. 12.6 for the program in Example 12.4.2. The selected atoms are represented with boxes. Edges denote unifications used. Given S(1, x), only one rule can be used. Given T (1, x2), two rules are applicable that account for the two descendants of vertex T (1, x2). The first number in edge labels denotes the rule that is used and the remaining part denotes the substitution. An SLD tree is a representation of all the derivations obtained with a fixed selection rule for atoms.

12.4 Proof-Theoretic Approach
299
There are several important observations to be made about this particular SLD tree: (i) It is successful because one branch yields .

(ii) It has an infinite subtree that corresponds to an infinite sequence of applications of rule (2) of Example 12.4.2.

(iii) It has a blocking branch.

We can now explain (to a certain extent) the acronym SLD. SLD stands for selection rule-driven linear resolution for definite clauses. Rule-driven refers to the rule used for selecting the atom. An important fact is that the success or failure of an SLD tree does not depend on the rule for selecting atoms. This explains why the definition of an SLD tree does not specify the selection rule.

Datalog versus Logic Programming, Revisited
Having established the three semantics for datalog, we summarize briefly the main differences between datalog and the more general logic-programming (lp) framework.

Syntax: Datalog has only relation symbols, whereas lp uses also function symbols. Datalog requires variables in rule heads to appear in bodies; in particular, all unit clauses are ground.

Model-theoretic semantics: Due to the presence of function symbols in lp, models of lp programs may be infinite. Datalog programs always have finite models. Apart from this distinction, lp and datalog are identical with respect to model-theoretic semantics.

Fixpoint semantics: Again, the minimum fixpoint of the immediate consequence operator may be infinite in the lp case, whereas it is always finite for datalog. Thus the fixpoint approach does not necessarily provide a constructive semantics for lp.

Proof-theoretic semantics: The technique of SLD resolution is similar for datalog and lp, with the difference that the computation of mgu’s becomes slightly more complicated with function symbols (see Exercise 12.20). For datalog, the significance of SLD
resolution concerns primarily optimization methods inspired by resolution (such as
“magic sets”; see Chapter 13). In lp, SLD resolution is more important. Due to the possibly infinite answers, the bottom-up approach of the fixpoint semantics may not be feasible. On the other hand, every fact in the answer has a finite proof by SLD
resolution. Thus SLD resolution emerges as the practical alternative.

Expressive power: A classical result is that lp can express all recursively enumerable (r.e.) predicates. However, as will be discussed in Part E, the expressive power of datalog lies within ptime. Why is there such a disparity? A fundamental reason is that function symbols are used in lp, and so an infinite domain of objects can be constructed from a finite set of symbols. Speaking technically, the result for lp states that if S is a (possibly infinite) r.e. predicate over terms constructed using a finite language, then there is an lp program that produces for some predicate symbol exactly the tuples in S. Speaking intuitively, this follows from the facts that viewed in a bottom-up sense, lp provides composition and looping, and terms of arbitrary length can be used as scratch paper
300
Datalog
(e.g., to simulate a Turing tape). In contrast, the working space and output of range-restricted datalog programs are always contained within the active domain of the input and the program and thus are bounded in size.

Another distinction between lp and datalog in this context concerns the nature of expressive power results for datalog and for query languages in general. Specifically, a datalog program P is generally viewed as a mapping from instances of edb(P ) to instances of idb(P ). Thus expressive power of datalog is generally measured in comparison with mappings on families of database instances rather than in terms of expressing a single (possibly infinite) predicate.

12.5
Static Program Analysis
In this section, the static analysis of datalog programs is considered.2 As with relational calculus, even simple static properties are undecidable for datalog programs. In particular, although tableau homomorphism allowed us to test the equivalence of conjunctive queries, equivalence of datalog programs is undecidable in general. This complicates a systematic search for alternative execution plans for datalog queries and yields severe limitations to query optimization. It also entails the undecidability of many other problems related to optimization, such as deciding when selection propagation (in the style of “pushing”
selections in relational algebra) can be performed, or when parallel evaluation is possible.

We consider three fundamental static properties: satisfiability, containment, and a new one, boundedness. We exhibit a decision procedure for satisfiability. Recall that we showed in Chapter 5 that an analogous property is undecidable for CALC. The decidability of satisfiability for datalog may therefore be surprising. However, one must remember that, although datalog is more powerful than CALC in some respects (it has recursion), it is less powerful in others (there is no negation). It is the lack of negation that makes satisfiability decidable for datalog.

We prove the undecidability of containment and boundedness for datalog programs and consider variations or restrictions that are decidable.

Satisfiability
Let P be a datalog program. An intensional relation T is satisfiable by P if there exists an instance I over edb(P ) such that P (I)(T ) is nonempty. We give a simple proof of the decidability of satisfiability for datalog programs. We will soon see an alternative proof based on context-free languages.

We first consider constant-free programs. We then describe how to reduce the general case to the constant-free one.

To prove the result, we use an auxiliary result about instance homomorphisms that is of some interest in its own right. Note that any mapping θ from dom to dom can be extended to a homomorphism over the set of instances, which we also denote by θ .

2 Recall that static program analysis consists of trying to detect statically (i.e., at compile time) properties of programs.

12.5 Static Program Analysis
301
Lemma 12.5.1
Let P be a constant-free datalog program, I, J two instances over sch(P ), q a positive-existential query over sch(P ), and θ a mapping over dom. If θ (I) ⊆ J, then (i) θ (q(I)) ⊆ q(J), and (ii) θ (P (I)) ⊆ P (J).

Proof
For (i), observe that q is monotone and that q ◦ θ ⊆ θ ◦ q (which is not necessary if q has constants). Because TP can be viewed as a positive-existential query, a straightforward induction proves (ii).

This result does not hold for datalog programs with constants (see Exercise 12.21).

Theorem 12.5.2
The satisfiability of an idb relation T by a constant-free datalog program P is decidable.

Proof
Suppose that T is satisfiable by a constant-free datalog program P . We prove that P (Ia)(T ) is nonempty for some particular instance Ia. Let a be in dom. Let Ia be the instance over edb(P ) such that for each R in edb(P ), Ia(R) contains a single tuple with a in each entry. Because T is satisfiable by P , there exists I such that P (I)(T ) = ∅. Consider the function θ that maps every constant in dom to a. Then θ (I) ⊆ Ia. By the previous lemma, θ (P (I)) ⊆ P (Ia). Therefore P (Ia)(T ) is nonempty. Hence T is satisfiable by P
iff P (Ia)(T ) = ∅.

Let us now consider the case of datalog programs with constants. Let P be a datalog program with constants. For example, suppose that b, c are the only two constants occurring in the program and that R is a binary relation occurring in P . We transform the problem into a problem without constants. Specifically, we replace R with nine new relations: R⋆⋆, Rb⋆, Rc⋆, R⋆b, R⋆c, Rbc, Rcb, Rbb, Rcc.

The first one is binary, the next four are unary, and the last four are 0-ary (i.e., are proposi-tions). Intuitively, a fact R(x, y) is represented by the fact R⋆⋆(x, y) if x, y are not in {b, c}; R(b, x) with x not in {b, c} is represented by Rb⋆(x), and similarly for Rc⋆, R⋆b, R⋆c. The fact R(b, c) is represented by proposition Rbc(), etc. Using this kind of transformation for each relation, one translates program P into a constant-free program P ′ such that T is satisfiable by P iff Tw is satisfiable by P ′ for some string w of ⋆ or constants occurring in P .

(See Exercise 12.22a.)

Containment
Consider two datalog programs P , P ′ with the same extensional relations edb(P ) and a target relation T occurring in both programs. We say that P is included in P ′ with respect to T , denoted P ⊆T P ′, if for each instance I over edb(P ), P (I)(T ) ⊆ P ′(I)(T ).

The containment problem is undecidable. We prove this by reduction of the containment problem for context-free languages. The technique is interesting because it exhibits a correspondence between proof trees of certain datalog programs and derivation trees of context-free languages.

302
Datalog
We first illustrate the correspondence in an example.

Example 12.5.3
Consider the context-free grammar G = (V , , , S), where V =
{S, T }, S is the start symbol, = {a, b}, and the set of production rules is S → T a
T → abT | aa.

The corresponding datalog program PG is the program of Example 12.4.1. A proof tree and its corresponding derivation tree are shown in Fig. 12.3.

We next formalize the correspondence between proof trees and derivation trees.

A context-free grammar is a (⋆) grammar if the following hold:
(1) G is ǫ free (i.e., does not have any production of the form X → ǫ, where ǫ
denotes the empty string) and
(2) the start symbol does not occur in any right-hand side of a production.

We use the following:
Fact
It is undecidable, given (⋆) grammars G1, G2, whether L(G1) ⊆ L(G2).

For each (⋆) grammar G, let PG, the corresponding datalog program, be constructed (similar to Example 12.5.3) as follows: Let G = (V , , , S). We may assume without loss of generality that V is a set of relation names of arity 2 and a set of elements from dom. Then idb(PG) = V and edb(PG) = {R}, where R is a ternary relation. Let x1, x2, . . .

be an infinite sequence of distinct variables. To each production in , T → C1 . . . Cn,
we associate a datalog rule
T (x1, xn+1) ← A1, . . . , An,
where for each i
• if Ci is a nonterminal T ′, then Ai = T ′(xi, xi+1);
• if Ci is a terminal b, then Ai = R(xi, b, xi+1).

Note that, for any proof tree of a fact S(a1, an) using PG, the sequence of its leaves is (in this order)
R(a1, b1, a2), . . . , R(an−1, bn−1, an),
for some a2, . . . , an−1 and b1, . . . , bn−1. The connection between derivation trees of G and proof trees of PG is shown in the following.

12.5 Static Program Analysis
303
Proposition 12.5.4
Let G be a (⋆) grammar and PG be the associated datalog pro-
gram constructed as just shown. For each a1, . . . , an, b1, . . . , bn−1, there is a proof tree of S(a1, an) from PG with leaves R(a1, b1, a2), . . . , R(an−1, bn−1, an) (in this order) iff b1 . . . bn−1 is in L(G).

The proof of the proposition is left as Exercise 12.25. Now we can show the following: Theorem 12.5.5
It is undecidable, given P , P ′ (with edb(P ) = edb(P ′)) and T , whether P ⊆T P ′.

Proof
It suffices to show that
for each pair G1, G2 of (⋆) grammars,
(‡)
L(G1) ⊆ L(G2) ⇔ PG ⊆
.

1
S PG2
Suppose (‡) holds and T containment is decidable. Then we obtain an algorithm to decide containment of (⋆) grammars, which contradicts the aforementioned fact.

Let G2, G2 be two (⋆) grammars. We show here that
L(G1) ⊆ L(G2) ⇒ PG ⊆
.

1
S PG2
(The other direction is similar.) Suppose that L(G1) ⊆ L(G2). Let I be over edb(PG ) and 1
S(a1, an) be in PG (I). Then there exists a proof tree of S(a and I, with
1
1, an) from PG1
leaves labeled by facts
R(a1, b1, a2), . . . , R(an−1, bn−1, an),
in this order. By Proposition 12.5.4, b1 . . . bn−1 is in L(G1). Because L(G1) ⊆ L(G2), b1 . . . bn−1 is in L(G2). By the proposition again, there is a proof tree of S(a1, an) from PG2
with leaves R(a1, b1, a2), . . . , R(an−1, bn−1, an), all of which are facts in I. Thus S(a1, an) is in PG (I), so P
⊆
.

2
G1
S PG2
Note that the datalog programs used in the preceding construction are very particular: They are essentially chain programs. Intuitively, in a chain program the variables in a rule body form a chain. More precisely, rules in chain programs are of the form A0(x0, xn) ← A1(x0, x1), A2(x1, x2), . . . , An(xn−1, xn).

The preceding proof can be tightened to show that containment is undecidable even for chain programs (see Exercise 12.26).

The connection with grammars can also be used to provide an alternate proof of the decidability of satisfiability; satisfiability can be reduced to the emptiness problem for context-free languages (see Exercise 12.22c).

Although containment is undecidable, there is a closely related, stronger property which is decidable—namely, uniform containment. For two programs P , P ′ over the same
304
Datalog
set of intensional and extensional relations, we say that P is uniformly contained in P ′, denoted P ⊆ P ′, iff for each I over sch(P ), P (I) ⊆ P ′(I). Uniform containment is a sufficient condition for containment. Interestingly, one can decide uniform containment.

The test for uniform containment uses dependencies studied in Part D and the fundamental chase technique (see Exercises 12.27 and 12.28).

Boundedness
A key problem for datalog programs (and recursive programs in general) is to estimate the depth of recursion of a given program. In particular, it is important to know whether for a given program the depth is bounded by a constant independent of the input. Besides being meaningful for optimization, this turns out to be an elegant mathematical problem that has received a lot of attention.

A datalog program P is bounded if there exists a constant d such that for each I over edb(P ), stage(P , I) ≤ d. Clearly, if a program is bounded it is essentially nonrecursive, although it may appear to be recursive syntactically. In some sense, it is falsely recursive.

Example 12.5.6
Consider the following two-rule program:
Buys( x, y) ← Trendy(x), Buys( z, y) Buys( x, y) ← Likes( x, y) This program is bounded because Buys(z,y) can be replaced in the body by Likes(z,y), yielding an equivalent recursion-free program. On the other hand, the program Buys( x, y) ← Knows( x, z), Buys( z, y) Buys( x, y) ← Likes( x, y) is inherently recursive (i.e., is not equivalent to any recursion-free program).

It is important to distinguish truly recursive programs from falsely recursive (bounded) programs. Unfortunately, boundedness cannot be tested.

Theorem 12.5.7
Boundedness is undecidable for datalog programs.

The proof is by reduction of the PCP (see Chapter 2). One can even show that boundedness remains undecidable under strong restrictions, such as that the programs that are considered (1) are constant-free, (2) contain a unique recursive rule, or (3) contain a unique intensional relation. Decidability results have been obtained for linear programs or chain-rule programs (see Exercise 12.31).

Bibliographic Notes
It is difficult to attribute datalog to particular researchers because it is a restriction or extension of many previously proposed languages; some of the early history is discussed in [MW88a]. The name datalog was coined (to our knowledge) by David Maier.

Bibliographic Notes
305
Many particular classes of datalog programs have been investigated. Examples are the class of monadic programs (all intensional relations have arity one), the class of linear programs (in the body of each rule of these programs, there can be at most one relation that is mutually recursive with the head relation; see Chapter 13), the class of chain programs
[UG88, AP87a] (their syntax resembles that of context-free grammars), and the class of single rule programs or sirups [Kan88] (they consist of a single nontrivial rule and a trivial exit rule).

The fixpoint semantics that we considered in this chapter is due to [CH85]. However, it has been considered much earlier in the context of logic programming [vEK76, AvE82].

For logic programming, the existence of a least fixpoint is proved using [Tar55].

The study of stage functions stage(d, H ) is a major topic in [Mos74], where they are defined for finite structures (i.e., instances) as well as for infinite structures.

Resolution was originally proposed in the context of automatic theorem proving. Its foundations are due to Robinson [Rob65]. SLD resolution was developed in [vEK76].

These form the basis of logic programming introduced by Kowalski [Kow74] and
[CKRP73] and led to the language Prolog. Nice presentations of the topic can be found in [Apt91, Llo87]. Standard SLD resolution is more general than that presented in this chapter because of the presence of function symbols. The development is similar except for the notion of unification, which is more involved. A survey of unification can be found in [Sie88, Kni89].

The programming language Prolog proposed by Colmerauer [CKRP73] is based on SLD resolution. It uses a particular strategy for searching for SLD refutations. Various ways to couple Prolog with a relational database system have been considered (see
[CGT90]).

The undecidability of containment is studied in [CGKV88, Shm87]. The decidability of uniform containment is shown in [CK86, Sag88]. The decidability of containment for monadic programs is studied in [CGKV88]. The equivalence of recursive and nonrecursive datalog programs is shown to be decidable in [CV92]. The complexity of this problem is considered in [CV94].

Interestingly, bounded recursion is defined and used early in the context of universal relations [MUV84]. Example 12.5.6 is from [Nau86]. Undecidability results for boundedness of various datalog classes are shown in [GMSV87, GMSV93, Var88, Abi89]. Decidability results for particular subclasses are demonstrated in [Ioa85, Nau86, CGKV88, NS87, Var88].

Boundedness implies that the query expressed by the program is a positive existential query and therefore is expressible in CALC (over finite inputs). What about the converse?

If infinite inputs are allowed, then (by a compactness argument) unboundedness implies nonexpressibility by CALC. But in the finite (database) case, compactness does not hold, and the question remained open for some time. Kolaitis observed that unboundedness does not imply nonexpressibility by CALC over finite structures for datalog with inequalities (x = y). (We did not consider comparators =, <, ≤, etc. in this chapter.) The question was settled by Ajtai and Gurevich [AG89], who showed by an elegant argument that no unbounded datalog program is expressible in CALC, even on finite structures.

Another decision problem for datalog concerns arises from the interaction of datalog with functional dependencies. In particular, it is undecidable, given a datalog program P ,
306
Datalog
set of fd’s on edb(P ), and set Ŵ of fd’s on idb(P ) whether P (I) |= Ŵ whenever I |=
[AH88].

The expressive power of datalog has been investigated in [AC89, ACY91, CH85, Shm87, LM89, KV90c]. Clearly, datalog expresses only monotonic queries, commutes with homomorphisms of the database (if there are no constants in the program), and can be evaluated in polynomial time (see also Exercise 12.11). It is natural to wonder if datalog expresses precisely those queries. The answer is negative. Indeed, [ACY91] shows that the existence of a path whose length is a perfect square between two nodes is not expressible in datalog= (datalog augmented with inequalities x = y), and so not in datalog. This is a monotonic, polynomial-time query commuting with homomorphisms. The parallel complexity of datalog is surveyed in [Kan88].

The function symbols used in logic programming are interpreted over a Herbrand domain and are prohibited in datalog. However, it is interesting to incorporate arithmetic functions such as addition and multiplication into datalog. Such functions can also be viewed as infinite base relations. If these are present, it is possible that the bottom-up evaluation of a datalog program will not terminate. This issue was first studied in [RBS87], where finiteness dependencies were introduced. These dependencies can be used to describe how the finiteness of the range of a set of variables can imply the finiteness of the range of another variable. [For example, the relation +(x, y, z) satisfies the finiteness dependencies {x, y} ❀ {z}, {x, z} ❀ {y}, and {y, z} ❀ {x}.] Safety of datalog programs with infinite relations constrained by finiteness dependencies is undecidable [SV89]. Various syntactic conditions on datalog programs that ensure safety are developed in [RBS87, KRS88a, KRS88b, SV89]. Finiteness dependencies were used to develop a safety condition for the relational calculus with infinite base relations in [EHJ93]. Safety was also considered in the context of data functions (i.e., functions whose extent is predefined).

Exercises
Exercise 12.1
Refer to the Parisian Metro database. Give a datalog program that yields, for each pair of stations (a, b), the stations c such that c is reachable (1) from both a and b; and (2) from a or b.

Exercise 12.2
Consider a database consisting of the Metro and Cinema databases, plus a relation Theater-Station giving for each theater the closest metro station. Suppose that you live near the Odeon metro station. Write a program that answers the query “Near which metro station can I see a Bergman movie?” (Having spent many years in Los Angeles, you do not like walking, so your only option is to take the metro at Odeon and get off at the station closest to the theater.) Exercise 12.3
(Same generation) Consider a binary relation Child _ of , where the intended meaning of Child _ of (a, b) is that a is the child of b. Write a datalog program computing the set of pairs (c, d), where c and d have a common ancestor and are of the same generation with respect to this ancestor.

Exercise 12.4
We are given two directed graphs G black and G white over the same set V of vertexes, represented as binary relations. Write a datalog program P that computes the set of pairs (a, b) of vertexes such that there exists a path from a to b where black and white edges alternate, starting with a white edge.

Exercises
307
Exercise 12.5
Suppose we are given an undirected graph with colored vertexes represented by a binary relation Color giving the colors of vertexes and a binary relation Edge giving the connection between them. (Although Edge provides directed edges, we ignore the direction, so we treat the graph as undirected.) Say that a vertex is good if it is connected to a blue vertex (blue is a constant) or if it is connected to an excellent vertex. An excellent vertex is a vertex that is connected to an outstanding vertex and to a red vertex. An outstanding vertex is a vertex that is connected to a good vertex, an excellent one, and a yellow one. Write a datalog program that computes the excellent vertexes.

Exercise 12.6
Consider a directed graph G represented as a binary relation. Show a datalog program that computes a binary relation T containing the pairs (a, b) for which there is a path of odd length from a to b in G.

Exercise 12.7
Given a directed graph G represented as a binary relation, write a datalog program that computes the vertexes x such that (1) there exists a cycle of even length passing through x; (2) there is a cycle of odd length through x; (3) there are even- and odd-length cycles through x.

Exercise 12.8
Consider the following program P :
R(x, y) ← Q(y, x), S(x, y)
S(x, y) ← Q(x, y), T (x, z)
T (x, y) ← Q(x, z), S(z, y)
Let I be a relation over edb(P ). Describe the output of the program. Now suppose the first rule is replaced by R(x, y) ← Q(y, x). Describe the output of the new program.

Exercise 12.9
Prove Lemma 12.3.1.

Exercise 12.10
Prove that datalog queries are monotone.

Exercise 12.11
Suppose P is some property of graphs definable by a datalog program. Show that P is preserved under extensions and homomorphisms. That is, if G is a graph satisfying P , then (1) every supergraph of G satisfies P and (2) if h is a graph homomorphism, then h(G) satisfies P .

Exercise 12.12
Show that the following graph properties are not definable by datalog programs:
(i) The number of nodes is even.

(ii) There is a nontrivial cycle (a trivial cycle is an edge a, a for some vertex a).

(iii) There is a simple path of even length between two specified nodes.

Show that nontrivial cycles can be detected if inequalities of the form x = y are allowed in rule bodies.

♠ Exercise 12.13 [ACY91] Consider the query perfect square on graphs: Is there a path (not necessarily simple) between nodes a and b whose length is a perfect square?

(i) Prove that perfect square is preserved under extension and homomorphism.

(ii) Show that perfect square is not expressible in datalog.

Hint: For (ii), consider “words” consisting of simple paths from a to b, and prove a pumping lemma for words “accepted” by datalog programs.

308
Datalog
Exercise 12.14
Present an algorithm that, given the set of proof trees of depth i with a program P and instance I, constructs all proof trees of depth i + 1. Make sure that your algorithm terminates.

Exercise 12.15
Let P be a datalog program, I an instance of edb(P ), and R in idb(P ). Let u be a vector of distinct variables of the arity of R. Demonstrate that P (I)(R) = {θ R(u) | there is a refutation of ← R(u) using PI and substitutions θ1, . . . θn such that θ = θ1 ◦ · · · ◦ θn}.

Exercise 12.16
(Substitution lemma) Let PI be a program, g a goal, and θ a substitution. Prove that if there exists an SLD refutation of θg with PI and ν, there also exists an SLD refutation of g with PI and θ ◦ ν.

Exercise 12.17
Reprove Theorem 12.3.4 using Tarski’s and Kleene’s theorems stated in Remark 12.3.5.

Exercise 12.18
Prove the “if part” of Theorem 12.4.5.

Exercise 12.19
Prove Lemma 12.4.8.

⋆ Exercise 12.20 (Unification with function symbols) In general logic programming, one can use function symbols in addition to relations. A term is then either a constant in dom, a variable in var, or an expression f (t1, . . . , tn), where f is an n-ary function symbol and each ti is a term.

For example, f (g(x, 5), y, f (y, x, x)) is a term. In this context, a substitution θ is a mapping from a subset of var into the set of terms. Given a substitution θ , it is extended in the natural manner to include all terms constructed over the domain of θ . Extend the definitions of unifier and mgu to terms and to atoms permitting terms. Give an algorithm to obtain the mgu of two atoms.

Exercise 12.21
Prove that Lemma 12.5.1 does not generalize to datalog programs with constants.

Exercise 12.22
This exercise develops three alternative proofs of the generalization of Theorem 12.5.2 to datalog programs with constants. Prove the generalization by (a) using the technique outlined just after the statement of the theorem (b) making a direct proof using as input an instance IC∪{a}, where C is the set of all constants occurring in the program and a is new, and where each relation in I contains all tuples constructed using C ∪ {a}
(c) reducing to the emptiness problem for context-free languages.

♠ Exercise 12.23 (datalog=) The language datalog= is obtained by extending datalog with a new predicate = with the obvious meaning.

(a) Formally define the new language.

(b) Extend the least-fixpoint and minimal-model semantics to datalog=.

⋆ (c) Show that satisfiability remains decidable for datalog= and that it can be tested in exponential time with respect to the size of the program.

⋆ Exercise 12.24 Which of the properties in Exercise 12.12 are expressible in datalog=?

Exercise 12.25
Prove Proposition 12.5.4.

Exercises
309
Exercise 12.26
Prove that containment of chain datalog programs is undecidable. Hint: Modify the proof of Theorem 12.5.5 by using, for each b ∈ , a relation Rb such that Rb(x, y) iff R(x, b, y).

Exercise 12.27
Prove that containment does not imply uniform containment by exhibiting two programs P , Q over the same edb’s and with S as common idb such that P ⊆S Q but P ⊆ Q.

♠ Exercise 12.28 (Uniform containment [CK86, Sag88]) Prove that uniform containment of two datalog programs is decidable.

Exercise 12.29
Prove that each nr-datalog program is bounded.

♠ Exercise 12.30 [GMSV87, Var88] Prove Theorem 12.5.7. Hint: Reduce the halting problem of Turing machines on an empty tape to boundedness of datalog programs. More precisely, have the edb encode legal computations of a Turing machine on an empty tape, and have the program verify the correctness of the encoding. Then show that the program is unbounded iff there are unbounded computations of the machine on the empty tape.

Exercise 12.31
(Boundedness of chain programs) Prove decidability of boundedness for chain programs. Hint: Reduce testing for boundedness to testing for finiteness of a context-free language.

♠ Exercise 12.32 This exercise demonstrates that datalog is likely to be stronger than positive first order extended by generalized transitive closure.

(a) [Coo74] Recall that a single rule program (sirup) is a datalog program with one nontrivial rule. Show that the sirup
R(x) ← R(y), R(z), S(x, y, z)
is complete in ptime. (This has been called variously the graph accessibility problem and the blue-blooded water buffalo problem; a water buffalo is blue blooded only if both of its parents are.)

(b) [KP86] Show that the in some sense simpler sirup
R(x) ← R(y), R(z), T (y, x), T (x, z)
is complete in ptime.

310
Datalog
(c) [Imm87b] The generalized transitive closure operator is defined on relations with arity 2n so that TC( R) is the output of the datalog program ans(x1, . . . , x2n) ← R(x1, . . . , x2n)
ans(x1, . . . , xn, z1, . . . , zn) ← R(x1, . . . , xn, y1, . . . , yn), ans(y1, . . . , yn, z1, . . . , zn)
Show that the positive first order extended with generalized transitive closure is in logspace.

13 EvaluationofDatalog
Alice:
I don’t mean to sound naive, but isn’t it awfully expensive to answer datalog queries?

Riccardo:
Not if you use the right bag of tricks . . .

Vittorio:
. . . and some magical wisdom.

Sergio:
Well, there is no real need for magic. We will see that the evaluation is much easier if the algorithm knows where it is going and takes advantage of this knowledge.

The introduction of datalog led to a flurry of research in optimization during the late 1980s and early 1990s. A variety of techniques emerged covering a range of different approaches. These techniques are usually separated into two classes depending on whether they focus on top-down or bottom-up evaluation. Another key dimension of the techniques concerns whether they are based on direct evaluation or propose some compilation of the query into a related query, which is subsequently evaluated using a direct technique.

This chapter provides a brief introduction to this broad family of heuristic techniques.

A representative sampling of such techniques is presented. Some are centered around an approach known as “Query-Subquery”; these are top down and are based on direct evaluation. Others, centered around an approach called “magic set rewriting,” are based on an initial preprocessing of the datalog program before using a fairly direct bottom-up evaluation strategy.

The advantage of top-down techniques is that selections that form part of the initial query can be propagated into the rules as they are expanded. There is no direct way to take advantage of this information in bottom-up evaluation, so it would seem that the bottom-up technique is at a disadvantage with respect to optimization. A rather elegant conclusion that has emerged from the research on datalog evaluation is that, surprisingly, there are bottom-up techniques that have essentially the same running time as top-down techniques.

Exposition of this result is a main focus of this chapter.

Some of the evaluation techniques presented here are intricate, and our main emphasis is on conveying the essential ideas they use. The discussion is centered around the presentation of the techniques in connection with a concrete running example. In the cases of Query-Subquery and magic sets rewriting, we also informally describe how they can be applied in the general case. This is sufficient to give a precise understanding of the techniques without becoming overwhelmed by notation. Proofs of the correctness of these techniques are typically lengthy but straightforward and are left as exercises.

311
312
Evaluation of Datalog
f
up
flat
down
f
f
a
e
g
f
l
f
l
m
n
o
p
a
f
m n
m f
d
d u
u
u
u
u
d
f
m
m o
g
b
g
n
p
m
h
c
e
f
g
h
i
j
k
f
h
n
i
d
i
o
p
k
u
u
d
d
d
j
o
a
b
c
d
(a) The instance
(b) Represented as a graph
Figure 13.1:
Instance I0 for RSG example
13.1
Seminaive Evaluation
The first stop on our tour of evaluation techniques is a strategy for improving the efficiency of the bottom-up technique described in Chapter 12. To illustrate this and the other techniques, we use as a running example the program “Reverse-Same-Generation” (RSG) given by
rsg(x, y) ← flat(x, y)
rsg(x, y) ← up(x, x1), rsg(y1, x1), down(y1, y) and the sample instance I0 illustrated in Fig. 13.1. This is a fairly simple program, but it will allow us to present the main features of the various techniques presented throughout this chapter.

If the bottom-up algorithm of Chapter 12 is used to compute the value of rsg on input I0, the following values are obtained:
level 0:
∅
level 1:
{g, f , m, n, m, o, p, m}
level 2:
{level 1} ∪ {a, b, h, f , i, f , j, f , f, k}
level 3:
{level 2} ∪ {a, c, a, d}
level 4:
{level 3}
at which point a fixpoint has been reached. It is clear that a considerable amount of redundant computation is done, because each layer recomputes all elements of the previous layer. This is a consequence of the monotonicity of the TP operator for datalog programs P .

This algorithm has been termed the naive algorithm for datalog evaluation. The central idea of the seminaive algorithm is to focus, to the extent possible, on the new facts generated at each level and thereby avoid recomputing the same facts.

Consider the facts inferred using the second rule of RSG in the consecutive stages of
13.1 Seminaive Evaluation
313
the naive evaluation. At each stage, some new facts are inferred (until a fixpoint is reached).

To infer a new fact at stage i + 1, one must use at least one fact newly derived at stage i.

This is the main idea of seminaive evaluation. It is captured by the following “version” of RSG, called RSG′:
.1 rsg(x, y) ← flat(x, y)
.i+1
rsg (x, y) ← up(x, x1), .i rsg(y1, x1), down(y1, y) where an instance of the second rule is included for each i ≥ 1. Strictly speaking, this is not a datalog program because it has an infinite number of rules. On the other hand, it is not recursive.

Intuitively, .i
contains the facts in
rsg
rsg newly inferred at the ith stage of the naive
evaluation. To see this, we note a close relationship between the repeated applications of T RSG and the values taken by the .i . Let I be a fixed input instance. Then rsg
• for i ≥ 0, let rsg i = T i
(I)( rsg) (i.e., the value of rsg after i applications of T
RSG
RSG
on I); and
• for i ≥ 1, let δi
=
when
rsg
RSG′(I)(.i rsg) (i.e., the value of .i rsg T RSG′ reaches a
fixpoint on I).

It is easily verified for each i ≥ 1 that T i−1
. Fur-
RSG′(I)(.i rsg) = ∅ and T i
RSG′(I)(.i rsg) = δi rsg
thermore, for each i ≥ 0 we have
rsg i+1 − rsg i ⊆ δi+1 ⊆
rsg
rsg i+1.

Therefore RSG
j
(I)( rsg) = ∪1≤i(δi
,
rsg). Furthermore, if j
satisfies δ rsg ⊆ ∪i<j δi rsg
then RSG(I)( rsg) = ∪i<j δi , that is, only
rsg
j levels of RSG′ need be computed to find
RSG(I)( rsg). Importantly, bottom-up evaluation of RSG′ typically involves much less redundant computation than direct bottom-up evaluation of RSG.

Continuing with the informal development, we introduce now two refinements that further reduce the amount of redundant computation. The first is based on the observation that when executing RSG′, we do not always have δi+1 =
rsg
rsg i+1 − rsg i. Using I0, we
have g, f ∈ δ2 but not in
rsg
rsg 2 − rsg 1. This suggests that the efficiency can be further improved by using rsg i − rsg i−1 in place of .i
in the body of the second “rule” of RSG′.

rsg
Using a pidgin language that combines both datalog and imperative commands, the new version RSG′′ is given by
.1

rsg(x, y)
←
flat(x, y)
rsg 1
:=
.1 rsg
 temp i+1


rsg (x, y)
←
up(x, x1), .i rsg(y1, x1), down(y1, y) 


.i+1
:=
−
rsg
temp i+1
rsg
rsg i


 rsg i+1
:=
rsg i ∪ .i+1

rsg
(where an instance of the second family of commands is included for each i ≥ 1).

314
Evaluation of Datalog
The second improvement to reduce redundant computation is useful when a given idb predicate occurs twice in the same rule. To illustrate, consider the nonlinear version of the ancestor program:
anc(x, y) ← par(x, y)
anc(x, y) ← anc(x, z), anc(z, y)
A seminaive “version” of this is
.1

anc(x, y)
←
par(x, y)
anc 1
:=
.1 anc
 temp i+1

anc (x, y)
←
.i anc(x, z), anc(z, y)






 temp i+1
anc (x, y)
←
anc(x, z), .i anc(z, y) 
.i+1
:=
temp i+1 − anc i

anc
anc





 anc i+1
:=
anc i ∪ .i+1

anc
Note here that both .i
and
anc
anc i are needed to ensure that all new facts in the next level are obtained.

Consider now an input instance consisting of par(1, 2), par(2, 3). Then we have
.1
= {1
anc
, 2, 2, 3}
anc 1 = {1, 2, 2, 3}
.2
= {1
anc
, 3}
Furthermore, both of the rules for temp 2
will compute the join of tuples 1
anc
, 2 and 2, 3,
and so we have a redundant computation of 1, 3. Examples are easily constructed where this kind of redundancy occurs for at an arbitrary level i > 0 (see Exercise 13.2).

An approach for preventing this kind of redundancy is to replace the two rules for temp i+1 by
temp i+1(x, y) ← .i anc(x, z), anc i−1(z, y) temp i+1(x, y) ← anc i(x, z), .i anc(z, y)
This approach is adopted below.

We now present the seminaive algorithm for the general case. Let P be a datalog program over edb R and idb T. Consider a rule S(u) ← R1(v1), . . . , Rn(vn), T1(w1), . . . , Tm(wm)
in P , where the Rk’s are edb predicates and the Tj ’s are idb predicates. Construct for each j ∈ [1, m] and i ≥ 1 the rule
13.1 Seminaive Evaluation
315
temp i+1(u) ← R
S
1(v1), . . . , Rn(vn),
T i1(w1), . . . , T i
(w
(w
j −1(wj −1), .iT
j ), T i−1
j +1), . . . , T i−1
j
j +1
m
(wm).

Let P i represent the set of all i-level rules of this form constructed for the idb predicate S
S
(i.e., the rules for temp i+1, j in [1, m]).

S
Suppose now that T1, . . . , Tl is a listing of the idb predicates of P that occur in the body of a rule defining S. We write
P i (I, T i−1, . . . , T i−1, T i
, .i , . . . , .i )
S
1
l
1 , . . . , T i
l
T1
Tl
to denote the set of tuples that result from applying the rules in P i to given values for input S
instance I and for the T i−1, T i, and .i .

j
j
Tj
We now have the following:
Algorithm 13.1.1 (Basic Seminaive Algorithm)
Input: Datalog program P and input instance I
Output: P (I)
1. Set P ′ to be the rules in P with no idb predicate in the body; 2. S0 := ∅, for each idb predicate S;
3. .1 := P ′(I)(S), for each idb predicate S;
S
4. i := 1;
5. do begin
for each idb predicate S, where T1, . . . , Tl
are the idb predicates involved in rules defining S,
begin
Si := Si−1 ∪ .i ;
S
.i+1 := P i (I, T i−1, . . . , T i−1, T i, . . . , T i, .i , . . . , .i ) − Si; S
S
1
l
1
l
T1
Tl
end;
i := i + 1
end
until .i = ∅ for each idb predicate S.

S
6. s := si, for each idb predicate S.

The correctness of this algorithm is demonstrated in Exercise 13.3. However, it is still doing a lot of unnecessary work on some programs. We now analyze the structure of datalog programs to develop an improved version of the seminaive algorithm. It turns out that this analysis, with simple control of the computation, allows us to know in advance which predicates are likely to grow at each iteration and which are not, either because they are already saturated or because they are not yet affected by the computation.

Let P be a datalog program. Form the precedence graph GP for P as follows: Use the idb predicates in P as the nodes and include edge (R, R′) if there is a rule with head predicate R′ in which R occurs in the body. P is recursive if GP has a directed cycle. Two predicates R and R′ are mutually recursive if R = R′ or R and R′ participate in the same
316
Evaluation of Datalog
cycle of GP. Mutual recursion is an equivalence relation on the idb predicates of P , where each equivalence class corresponds to a strongly connected component of GP. A rule of P
is recursive if the body involves a predicate that is mutually recursive with the head.

We now have the following:
Algorithm 13.1.2 (Improved Seminaive Algorithm)
Input: Datalog program P and edb instance I
Output: P (I)
1. Determine the equivalence classes of idb(P) under mutual recursion.

2. Construct a listing [R1], . . . , [Rn] of the equivalence classes, according to a topological sort of GP (i.e., so that for each pair i < j there is no path in GP from Rj to Ri).

3. For i = 1 to n do
Apply Basic Seminaive Algorithm to compute the values of predicates in [Ri], treating all predicates in [Rj ], j < i, as edb predicates.

The correctness of this algorithm is left as Exercise 13.4.

Linear Datalog
We conclude this discussion of the seminaive approach by introducing a special class of programs.

Let P be a program. A rule in P with head relation R is linear if there is at most one atom in the body of the rule whose predicate is mutually recursive with R. P is linear if each rule in P is linear. We now show how the Improved Seminaive Algorithm can be simplified for such programs.

Suppose that P is a linear program, and
ρ : R(u) ← T1(v1), . . . , Tn(vn)
is a rule in P , where Tj is mutually recursive with R. Associate with this the “rule”
.i+1(u) ← T
(v
R
1(v1), . . . , .iT
j ), . . . , Tn(vn).

j
Note that this is the only rule that will be associated by the Improved Seminaive Algorithm with ρ. Thus, given an equivalence class [Tk] of mutually recursive predicates of P , the rules for predicates S in [Tk] use only the .i , but not the Si. In contrast, as seen earlier, S
both the .i and Si must be used in nonlinear programs.

S
13.2
Top-Down Techniques
Consider the RSG program from the previous section, augmented with a selection-based query:
13.2 Top-Down Techniques
317
rsg(x, y) ← flat(x, y)
rsg(x, y) ← up(x, x1), rsg(y1, x1), down(y1, y) query(y) ← rsg(a, y)
where a is a constant. This program will be called the RSG query. Suppose that seminaive evaluation is used. Then each pair of rsg will be produced, including those that are not used to derive any element of query. For example, using I0 of Fig. 13.1 as input, fact rsg(f, k) will be produced but not used. A primary motivation for the top-down approaches to datalog query evaluation is to avoid, to the extent possible, the production of tuples that are not needed to derive any answer tuples.

For this discussion, we define a datalog query to be a pair (P , q), where P is a datalog program and q is a datalog rule using relations of P in its body and the new relation query in its head. We generally assume that there is only one rule defining the predicate query, and it has the form
query(u) ← R(v)
for some idb predicate R.

A fact is relevant to query (P , q) on input I if there is a proof tree for query in which the fact occurs. A straightforward criterion for improving the efficiency of any datalog evaluation scheme is to infer only relevant facts. The evaluation procedures developed in the remainder of this chapter attempt to satisfy this criterion; but, as will be seen, they do not do so perfectly.

The top-down approaches use natural heuristics to focus attention on relevant facts. In particular, they use the framework provided by SLD resolution. The starting point for these algorithms (namely, the query to be answered) often includes constants; these have the effect of restricting the search for derivation trees and thus the set of facts produced. In the context of databases without function symbols, the top-down datalog evaluation algorithms can generally be forced to terminate on all inputs, even when the corresponding SLD-resolution algorithm does not. In this section, we focus primarily on the query-subquery (QSQ) framework.

There are four basic elements of this framework:
1. Use the general framework of SLD resolution, but do it set-at-a-time. This permits the use of optimized versions of relational algebra operations.

2. Beginning with the constants in the original query, “push” constants from goals to subgoals, in a manner analogous to pushing selections into joins.

3. Use the technique of “sideways information passing” (see Chapter 6) to pass constant binding information from one atom to the next in subgoals.

4. Use an efficient global flow-of-control strategy.

Adornments and Subqueries
Recall the RSG query given earlier. Consider an SLD tree for it. The child of the root would be rsg(a, y). Speaking intuitively, not all values for rsg are requested, but rather only those
318
Evaluation of Datalog
with first coordinate a. More generally, we are interested in finding derivations for rsg where the first coordinate is bound and the second coordinate is free. This is denoted by the expression rsg bf , where the superscript ‘bf ’ is called an adornment.

The next layer of the SLD tree will have a node holding flat(a, y) and a node holding up(a, x1), rsg(y1, x1), down(y1, y). Answers generated for the first of these nodes are given by π2(σ1 = ‘a’( flat)). Answers for the other node can be generated by a left-to-right evaluation. First the set of possible values for x1 is J = π2(σ1 = ‘a’( up)). Next the possible values for y1 are given by {y1 | y1, x1 ∈ rsg and x1 ∈ J } (i.e., the first coordinate values of rsg stemming from second coordinate values in J ). More generally, then, this calls for an evaluation of rsg f b, where the second coordinate values are bound by J .

Finally, given y1 values, these can be used with down to obtain y values (i.e., answers to the query).

As suggested by this discussion, a top-down evaluation of a query in which constants occur can be broken into a family of “subqueries” having the form (Rγ , J ), where γ is an adornment for idb predicate R, and J is a set of tuples that give values for the columns bound by γ . Expressions of the form (Rγ , J ) are called subqueries. If the RSG
query were applied to the instance of Fig. 13.1, the first subquery generated would be ( rsg f b, {e, f }). As we shall see, the QSQ framework is based on a systematic evaluation of subqueries.

Let P be a datalog program and I an input instance. Suppose that R is an idb predicate and γ is an adornment for R (i.e., a string of b’s and f ’s having length the arity of R). Then bound(R, γ ) denotes the coordinates of R bound in γ . Let t be a tuple over bound(R, γ ).

Then a completion for t in Rγ is a tuple s such that s[ bound(R, γ )] = t and s ∈ P (I)(R).

The answer to a subquery (Rγ , J ) over I is the set of all completions of all tuples in J .

The use of adornments within a rule body is a generalization of the technique of sideways information passing discussed in Chapter 6. Consider the rule (*)
R(x, y, z) ← R1(x, u, v), R2(u, w, w, z), R3(v, w, y, a).

Suppose that a subquery involving R bfb is invoked. Assuming a left-to-right evaluation, this will lead to subqueries involving
bff
bffb
bbfb
R
, R
, and R
. We sometimes rewrite the rule as
1
2
3
bff
bffb
bbfb
R bfb(x, y, z) ← R
(x, u, v), R
(u, w, w, z), R
(v, w, y, a)
1
2
3
to emphasize the adornments. This is an example of an adorned rule. As we shall see, the adornments of idb predicates in rule bodies shall be used to guide evaluations of queries and subqueries. It is common to omit the adornments of edb predicates.

The general algorithm for adorning a rule, given an adornment for the head and an ordering of the rule body, is as follows: (1) All occurrences of each bound variable in the rule head are bound, (2) all occurrences of constants are bound, and (3) if a variable x occurs in the rule body, then all occurrences of x in subsequent literals are bound.

A different ordering of the rule body would yield different adornments. In general, we permit different orderings of rule bodies for different adornments of a given rule head. (A generalization of this technique is considered in Exercise 13.19.)

The definition of adorned rule also applies to situations in which there are repeated
13.2 Top-Down Techniques
319
variables or constants in the rule head (see Exercise 13.9). However, adornments do not capture all of the relevant information that can arise as the result of repeated variables or constants that occur in idb predicates in rule bodies. Mechanisms for doing this are discussed in Section 13.4.

Supplementary Relations and QSQ Templates
A key component of the QSQ framework is the use of QSQ templates which store appropriate information during intermediate stages of an evaluation. Consider again the preceding rule (*), and imagine attempting to evaluate the subquery (R bfb, J ). This will result in calls to the generalized queries
bff
bffb
bbfb
(R
, π
, K), and (R
, L) for some relations K
1
1(J )), (R2
3
and L that depend on the evaluation of the preceding queries. Importantly, note that relation K relies on values passed from both J and R1, and L relies on values passed from R1 and R2. A QSQ template provides data structures that will remember all of the values needed during a left-to-right evaluation of a subquery.

To do this, QSQ templates rely on supplementary relations. A total of n + 1 supplementary relations are associated to a rule body with n atoms. For example, the supplementary relations sup 0, . . . , sup 3 for the rule (*) with head adorned by R bfb are bff
bffb
bbfb
R bfb(x, y, z) ← R
(x, u, v), R
(u, w, w, z), R
(v, w, y, a)
1
2
3
↑
↑
↑
↑
sup 0[x, z] sup 1[x, z, u, v] sup 2[x, z, v, w] sup 3[x, y, z]
Note that variables serve as attribute names in the supplementary relations. Speaking intuitively, the body of a rule may be viewed as a process that takes as input tuples over the bound attributes of the head and produces as output tuples over the variables (bound and free) of the head. This determines the attributes of the first and last supplementary relations.

In addition, a variable (i.e., an attribute name) is in some supplementary relation if it is has been bound by some previous literal and if it is needed in the future by some subsequent literal or in the result.

More formally, for a rule body with atoms A1, . . . , An, the set of variables used as attribute names for the ith supplementary relation is determined as follows:
• For the 0th (i.e., zeroth) supplementary relation, the attribute set is the set X0 of bound variables of the rule head; and for the last supplementary relation, the attribute set is the set Xn of variables in the rule head.

• For i ∈ [1, n − 1], the attribute set of the ith supplementary relation is the set Xi of variables that occur both “before” Xi (i.e., occur in X0, A1, . . . , Ai) and “after” Xi (i.e., occur in Ai+1, . . . , An, Xn).

The QSQ template for an adorned rule is the sequence ( sup 0, . . . , sup n) of relation schemas for the supplementary relations of the rule. During the process of QSQ query evaluation, relation instances are assigned to these schemas; typically these instances repeatedly acquire new tuples as the algorithm runs. Figure 13.2 shows the use of QSQ
templates in connection with the RSG query.

320
Evaluation of Datalog
rsgbf( x, y)
rsgbf( x, y)
flat( x, y)
up( x, x ), rsgfb( y , x ), down( y , y) 1
1
1
1
sup 1[ x]
sup 1[ x, y]
sup 3[ x]
sup 3[ x, x ]
sup 3[ x, y ]
sup 3[ x, y]
0
1
0
1
1
2
1
3
a
a
a e
a g
a b
a f
rsg fb( x, y)
rsg fb( x, y)
flat( x, y)
down( y , y), rsgbf( y , x ), up( x, x ) 1
1
1
1
sup 2[ y]
sup 2[ x, y]
sup 4[ y]
sup 4[ y, y ]
sup 4[ y, x ]
sup 4[ x, y]
0
1
0
1
1
2
1
3
e
g f
e
f
l
f
f
f m
input_rsgbf
input_rsg fb
ans_rsgbf
ans_rsg fb
a
e
a b
g f
f
Figure 13.2:
Illustration of QSQ framework
The Kernel of QSQ Evaluation
The key components of QSQ evaluation are as follows. Let (P , q) be a datalog query and let I be an edb instance. Speaking conceptually, QSQ evaluation begins by constructing an adorned rule for each adornment of each idb predicate in P and for the query q. In practice, the construction of these adorned rules can be lazy (i.e., they can be constructed only if needed during execution of the algorithm). Let (P ad, qad) denote the result of this transformation.

The relevant adorned rules for the RSG query are as follows:
1. rsgbf (x, y) ← flat(x, y)
2. rsg fb(x, y) ← flat(x, y)
13.2 Top-Down Techniques
321
3. rsgbf (x, y) ← up(x, x1), rsg fb(y1, x1), down(y1, y) 4. rsg fb(x, y) ← down(y1, y), rsgbf (y1, x1), up(x, x1).

Note that in the fourth rule, the literals of the body are ordered so that the binding of y in down can be “passed” via y1 to rsg and via x1 to up.

A QSQ template is constructed for each relevant adorned rule. We denote the j th (counting from 0) supplementary relation of the ith adorned rule as sup i. In addition, the j
following relations are needed and will serve as variables in the QSQ evaluation algorithm: (a) for each idb predicate R and relevant adornment γ the variable ans _Rγ , with same arity as R;
(b) for each idb predicate R and relevant adornment γ , the variable input _Rγ with same arity as bound(R, γ ) (i.e., the number of b’s occurring in γ ); and (c) for each supplementary relation sup i, the variable sup i.

j
j
Intuitively, input _Rγ will be used to form subqueries (Rγ , input _Rγ ). The completion of tuples in input _Rγ will go to ans _Rγ . Thus ans _Rγ will hold tuples that are in P (I)(R) and were generated from subqueries based on Rγ .

A QSQ algorithm begins with the empty set for each of the aforementioned relations.

The query is then used to initialize the process. For example, the rule query(y) ← rsg(a, y)
gives the initial value of {a} to input _ rsg bf . In general, this gives rise to the subquery (Rγ , {t }), where t is constructed using the set of constants in the initial query.

There are essentially four kinds of steps in the execution. Different possible orderings for these steps will be considered. The first of these is used to initialize rules.

(A) Begin evaluation of a rule: This step can be taken whenever there is a rule with head predicate Rγ and there are “new” tuples in a variable input _Rγ that have not yet been processed for this rule. The step is to add the “new” tuples to the 0th supplementary relation for this rule. However, only “new” tuples that unify with the head of the rule are added to the supplementary relation. A “new” tuple in input _Rγ might fail to unify with the head of a rule defining R if there are repeated variables or constants in the rule head (see Exercise 13.9).

New tuples are generated in supplementary relations sup i in two ways: Either some j
new tuples have been obtained for sup i
(case B); or some new tuples have been obtained
j −1
for the idb predicate occurring between sup i
and sup i (case C).

j −1
j
(B) Pass new tuples from one supplementary relation to the next: This step can be taken whenever there is a set T of “new” tuples in a supplementary variable sup i that have not
j −1
yet been processed, and sup i
is not the last supplementary relation of the corresponding
j −1
rule. Suppose that Aj is the atom in the rule immediately following sup i .

j −1
322
Evaluation of Datalog
Two cases arise:
(i) Aj is Rγ (u) for some edb predicate R. Then a combination of joins and projections on R and T is used to determine the appropriate tuples to be added to sup i.

j
(ii) Aj is Rγ (u) for some idb predicate R. Note that each of the bound variables in γ occurs in sup i
. Two actions are now taken.

j −1
(a) A combination of joins and projections on ans _Rγ (the current value for R) and T is used to determine the set T ′ of tuples to be added to sup i.

j
(b) The tuples in T [ bound(R, γ )] − input _Rγ are added to input _Rγ .

(C) Use new idb tuples to generate new supplementary relation tuples: This step is similar to the previous one but is applied when “new” tuples are added to one of the idb relation variables ans _Rγ . In particular, suppose that some atom Aj with predicate Rγ
occurs in some rule, with surrounding supplementary variables sup i and sup i. In this
j −1
j
case, use join and projection on all tuples in sup i
and the “new” tuples of ans _Rγ to
j −1
create new tuples to be added to sup i.

j
(D) Process tuples in the final supplementary relation of a rule: This step is used to generate tuples corresponding to the output of rules. It can be applied when there are “new”
tuples in the final supplementary variable sup i of a rule. Suppose that the rule predicate is n
Rγ . Add the new tuples in sup i to
n
ans _Rγ .

Example 13.2.1
Figure 13.2 illustrates the data structures and “scratch paper” relations used in the QSQ algorithm, in connection with the RSG query, as applied to the instance of Fig. 13.1. Recall the adorned version of the RSG query presented on page 321. The QSQ
templates for these are shown in Fig. 13.2. Finally, the scratch paper relations for the input-
and ans-variables are shown.

Figure 13.2 shows the contents of the relation variables after several steps of the QSQ approach have been applied. The procedure begins with the insertion of a into input _ rsg bf ; this corresponds to the rule
query(y) ← rsg(a, y)
Applications of step (A) place a into the supplementary variables sup 1 and sup 3. Step 0
0
(B.i) then yields a, e and a, f in sup 3. Because ans _ rsg f b is empty at this point, 1
step (B.ii.a) does not yield any tuples for sup 3. However, step (B.ii.b) is used to insert e 2
and f into input _ rsg f b. Application of steps (B) and (D) on the template of the second rule yield g, f in ans _ rsg f b. Application of steps (C), (B), and (D) on the template of the third rule now yield the first entry in ans _ rsg bf . The reader is invited to extend the evaluation to its conclusion (see Exercise 13.10). The answer is obtained by applying π2σ 1 = ‘a’ to the final contents of ans _ rsg bf .

13.2 Top-Down Techniques
323
Global Control Strategies
We have now described all of the basic building blocks of the QSQ approach: the use of QSQ templates to perform information passing both into rules and sideways through rule bodies, and the three classes of relations used. A variety of global control strategies can be used for the QSQ approach. The most basic strategy is stated simply: Apply steps (A) through (D) until a fixpoint is reached. The following can be shown (see Exercise 13.12): Theorem 13.2.2
Let (P , q) be a datalog query. For each input I, any evaluation of QSQ
on (P ad, qad) yields the answer of (P , q) on I.

We now present a more specific algorithm based on the QSQ framework. This algorithm, called QSQ Recursive (QSQR) is based on a recursive strategy. To understand the central intuition behind QSQR, suppose that step (B) described earlier is to be performed, passing from supplementary relation sup i
across an idb predicate Rγ to supplementary
j −1
relation sup i . This may lead to the introduction of new tuples into sup i by step (B.ii.a) and j
j
to the introduction of new tuples into input _Rγ by step (B.ii.b). The essence of QSQR is that it now performs a recursive call to determine the Rγ values corresponding to the new tuples added to input _Rγ , before applying step (B) or (D) to the new tuples placed into sup i .

j We present QSQR in two steps: first a subroutine and then the recursive algorithm itself. During processing in QSQR, the global state includes values for ans _Rγ and input _Rγ for each idb predicate R and relevant adornment γ . However, the supplementary relations are not global—local copies of the supplementary relations are maintained by each call of the subroutine.

Subroutine
Process subquery on one rule
Input: A rule for adorned predicate Rγ , input instance I, a QSQR “state” (i.e., set of values for the input- and ans-variables), and a set T ⊆ input _Rγ . (Intuitively, the tuples in T
have not been considered with this rule yet).

Action:
1. Remove from T all tuples that do not unify with (the appropriate coordinates of) the head of the rule.

2. Set sup 0 := T . [This is step (A) for the tuples in T .]
3. Proceed sideways across the body A1, . . . , An of the rule to the final supplementary relation sup n as follows:
For each atom Aj
(a) If Aj has edb predicate R′, then apply step (B.i) to populate sup j.

(b) If Aj has idb predicate R′δ, then apply step (B.ii) as follows: (i) Set S := sup j−1[ bound(R′, δ)] − input _R′δ.

(ii) Set input _R′δ := input _R′δ ∪ S. [This is step (B.ii.b).]
(iii) (Recursively) call algorithm QSQR on the query (R′δ, S).

324
Evaluation of Datalog
[This has the effect of invoking step (A) and its consequences
for the tuples in S.]
(iv) Use sup j−1 and the current value of global variable ans _R′δ
to populate sup j. [This includes steps (B.ii.a) and (C).]
4. Add the tuples produced for sup n into the global variable ans _Rγ . [This is step (D).]
The main algorithm is given by the following:
Algorithm 13.2.3 (QSQR)
Input: A query of the form (Rγ , T ), input instance I, and a QSQR “state” (i.e., set of values for the input- and ans-variables).

Procedure:
1. Repeat until no new tuples are added to any global variable:
Call the subroutine to process subquery (Rγ , T ) on each rule defining R.

Suppose that we are given the query
query(u) ← R(v)
Let γ be the adornment of R corresponding to v, and let T be the singleton relation corresponding to the constants in v. To find the answer to the query, the QSQR algorithm is invoked with input (Rγ , T ) and the global state where input _Rγ = T and all other input-
and ans-variables are empty. For example, in the case of the rsg program, the algorithm is first called with argument ( rsg bf , {a}) , and in the global state input _ rsg bf = {a}. The answer to the query is obtained by performing a selection and projection on the final value of ans _Rγ .

It is straightforward to show that QSQR is correct (Exercise 13.12).

13.3
Magic
An exciting development in the field of datalog evaluation is the emergence of techniques for bottom-up evaluation whose performance rivals the efficiency of the top-down techniques. This family of techniques, which has come to be known as “magic set” techniques, simulates the pushing of selections that occurs in top-down approaches. There are close connections between the magic set techniques and the QSQ algorithm. The magic set technique presented in this section simulates the QSQ algorithm, using a datalog program that is evaluated bottom up. As we shall see, the magic sets are basically those sets of tuples stored in the relations input _Rγ and sup i of the QSQ algorithm. Given a datalog query j
(P , q), the magic set approach transforms it into a new query (P m, qm) that has two important properties: (1) It computes the same answer as (P , q), and (2) when evaluated using a bottom-up technique, it produces only the set of facts produced by top-down approaches
13.3 Magic
325
(s1.1)
rsg bf (x, y)
← input _ rsg bf (x), flat(x, y)
(s2.1)
rsg f b(x, y)
← input _ rsg f b(y), flat(x, y)
(s3.1)
sup 31(x, x1)
← input _ rsg bf (x), up(x, x1)
(s3.2)
sup 32(x, y1)
← sup 31(x, x1), rsg f b(y1, x1)
(s3.3)
rsg bf (x, y)
← sup 32(x, y1), down(y1, y)
(s4.1)
sup 41(y, y1)
← input _ rsg f b(y), down(y1, y)
(s4.2)
sup 42(y, x1)
← sup 41(y, y1), rsg bf (y1, x1)
(s4.3)
rsg f b(x, y)
← sup 42(y, x1), up(x, x1)
(i3.2)
input _ rsg bf (x1) ← sup 31(x, x1)
(i4.2)
input _ rsg f b(y1) ← sup 41(y, y1)
(seed)
input _ rsg bf (a) ←
(query)
query(y)
← rsg bf (a, y)
Figure 13.3:
Transformation of RSG query using magic sets
such as QSQ. In particular, then, (P m, qm) incorporates the effect of “pushing” selections from the query into bottom-up computations, as if by magic.

We focus on a technique originally called “generalized supplementary magic”; it is perhaps the most general magic set technique for datalog in the literature. (An earlier form of magic is considered in Exercise 13.18.) The discussion begins by explaining how the technique works in connection with the RSG query of the previous section and then presents the general algorithm.

As with QSQ, the starting point for magic set algorithms is an adorned datalog query (P ad, qad). Four classes of rules are generated (see Fig. 13.3). The first consists of a family of rules for each rule of the adorned program P ad. For example, recall rule (3) (see p. 321) of the adorned program for the RSG query presented in the previous section: rsg bf (x, y) ← up(x, x1), rsg f b(y1, x1), down(y1, y).

We first present a primitive family of rules corrresponding to that rule, and then apply some optimizations.

326
Evaluation of Datalog
(s3.0’)
sup 30(x)
← input _ rsg bf (x)
(s3.1’)
sup 31(x, x1) ← sup 30(x), up(x, x1)
(s3.2)
sup 32(x, y1) ← sup 31(x, x1), rsg f b(y1, x1) (s3.3’)
sup 33(x, y) ← sup 32(x, y1), down(y1, y)
(S3.4’)
rsg bf (x, y) ← sup 33(x, y)
Rule (s3.0’) corresponds to step (A) of the QSQ algorithm; rules (s3.1’) and (s3.3’) correspond to step (B.i); rule (s3.2) corresponds to steps (B.ii.a) and (C); and rule (s3.4’) corresponds to step (D). In the literature, the predicate input _ rsg f b has usually been denoted as magic _ rsg f b and sup i as supmagic i . We use the current notation to stress the j
j
connection with the QSQ framework. Note that the predicate rsg bf here plays the role of ans _ rsg bf there.

As can be seen by the preceding example, the predicates sup 3 and sup 3 are essentially 0
3
redundant. In general, if the ith rule defines Rγ , then the predicate sup i is eliminated, with 0
input _Rγ used in its place to eliminate rule (3.0’) and to form (s3.1)
sup 31(x, x1) ← input _ rsg bf (x), up(x, x1).

Similarly, the predicate of the last supplementary relation can be eliminated to delete rule (s3.4’) and to form
(s3.3)
rsg bf (x, y) ← sup 32(x, y1), down(y1, y).

Therefore the set of rules (s3.0’) through (s3.4’) may be replaced by (s3.1), (s3.2), and (s3.3). Rules (s4.1), (s4.2), and (s4.3) of Fig. 13.3 are generated from rule (4) of the adorned program for the RSG query (see p. 321). (Recall how the order of the body literals in that rule are reversed to pass bounding information.) Finally, rules (s1.1) and (s2.1) stem from rules (1) and (2) of the adorned program.

The second class of rules is used to provide values for the input predicates [i.e., simulating step (B.ii.b) of the QSQ algorithm]. In the RSG query, one rule for each of input _ rsg bf and input _ rsg f b is needed: (i3.2)
input _ rsg bf (x1) ← sup 31(x, x1)
(i4.2)
input _ rsg f b(y1) ← sup 41(y, y1).

Intuitively, the first rule comes from rule (s3.2). In other words, it follows from the second atom of the body of rule (3) of the original adorned program (see p. 321). In general, an adorned rule with k idb atoms in the body will generate k input rules of this form.

The third and fourth classes of rules include one rule each; these initialize and conclude the simulation of QSQ, respectively. The first of these acts as a “seed” and is derived from the initial query. In the running example, the seed is
input _rsgbf (a) ← .

13.4 Two Improvements
327
The second constructs the answer to the query; in the example it is query(y) ← rsg bf (a, y).

From this example, it should be straightforward to specify the magic set rewriting of an adorned query (P ad, qad) (see Exercise 13.16a).

The example showed how the “first” and “last” supplementary predicates sup 3 and 0
sup 3 were redundant with input _ rsg bf and rsg bf , respectively, and could be eliminated.

4
Another improvement is to merge consecutive sequences of edb atoms in rule bodies as follows. For example, consider the rule
(i)
γ
Rγ (u) ← R 1(u
1
1), . . . , Rγn
n (un)
and suppose that predicate Rk is the last idb relation in the body. Then rules (si.k), . . . , (si.n) can be replaced with
(s
γ
γ
i.k′′)
Rγ (u) ← sup i
k (u
k+1(u
k−1(vk−1), Rk
k), Rk+1
k+1), . . . , Rγn
n (un).

For example, rules (s3.2) and (s3.3) of Fig. 13.3 can be replaced by (s3.2′′)
rsg bf (x, y) ← sup 31(x, x1), rsg f b(y1, x1), down(y1, y).

This simplification can also be used within rules. Suppose that Rk and Rl are idb relations with only edb relations occurring in between. Then rules (i.k), . . . , (i.l − 1) can be replaced with
(s
γ
γ
γ
i.k′′)
sup i
k (u
k+1(u
l−1(u
l−1(vl−1) ← sup ik−1(vk−1), Rk
k), Rk+1
k+1), . . . , Rl−1
l−1).

An analogous simplification can be applied if there are multiple edb predicates at the beginning of the rule body.

To summarize the development, we state the following (see Exercise 13.16): Theorem 13.3.1
Let (P , q) be a query, and let (P m, qm) be the query resulting from the magic rewriting of (P , q). Then
(a) The answer computed by (P m, qm) on any input instance I is identical to the answer computed by (P , q) on I.

(b) The set of facts produced by the Improved Seminaive Algorithm of (P m, qm) on input I is identical to the set of facts produced by an evaluation of QSQ on I.

13.4
Two Improvements
This section briefly presents two improvements of the techniques discussed earlier. The first focuses on another kind of information passing resulting from repeated variables and constants occurring in idb predicates in rule bodies. The second, called counting, is applicable to sets of data and rules having certain acyclicity properties.

328
Evaluation of Datalog
Repeated Variables and Constants in Rule Bodies (by Example)
Consider the program Pr:
(1)
T (x, y, z) ← R(x, y, z)
(2)
T (x, y, z) ← S(x, y, w), T (w, z, z)
query(y, z) ← T (1, y, z)
Consider as input the instance I1 shown in Fig. 13.4(a). The data structures for a QSQ
evaluation of this program are shown in Fig. 13.4(b). (The annotations ‘$2 = $3’, ‘$2 = $3
= 4’, etc., will be explained later.)

A magic set rewriting of the program and query yields
T bff (x, y, z)
← input _T bff (x), R(x, y, z)
sup 21(x, y, w) ← input _T bff (x), S(x, y, w) T bff (x, y, z)
← sup 21(x, y, w), T bff (w, z, z)
input _T bff (w) ← sup 21(x, y, w)
input _T bff (1) ←
query(y, z)
← T bff (1, y, z).

On input I1, the query returns the empty instance. Furthermore, the SLD tree for this query on I1 shown in Fig. 13.5, has only 9 goals and a total of 13 atoms, regardless of the value of n. However, both the QSQ and magic set approach generate a set of facts with size proportional to n (i.e., to the size of I1).

Why do both QSQ and magic sets perform so poorly on this program and query? The answer is that as presented, neither QSQ nor magic sets take advantage of restrictions on derivations resulting from the repeated z variable in the body of rule (2). Analogous examples can be developed for cases where constants appear in idb atoms in rule bodies.

Both QSQ and magic sets can be enhanced to use such information. In the case of QSQ, the tuples added to supplementary relations can be annotated to carry information about restrictions imposed by the atom that “caused” the tuple to be placed into the leftmost supplementary relation. This is illustrated by the annotations in Fig. 13.4(b). First consider the annotation ‘$2 = $3’ on the tuple 3 in input _T bff . This tuple is included into input _
T bff because 1, 2, 3 is in sup 2, and the next atom considered is T bff (w, z, z). In particular, 1
then, any valid tuple (x, y, z) resulting from 3 must have second and third coordinates equal. The annotation ‘$2 = $3’ is passed with 3 into sup 1 and sup 2.

0
0
Because variable y is bound to 4 in the tuple 3, 4, 5 in sup 2, the annotation ‘$2 =
1
$3’ on 3 in sup 2 “transforms” into ‘$3 = 4’ on this new tuple. This, in turn, implies the 0
annotation ‘$2 = $3 = 4’ when 5 is added to input _T bff and to both sup 1 and sup 2.

0
0
Now consider the tuple 5 in sup 1, with annotation ($2 = $3 = 4). This can generate a 0
tuple in sup 1 only if 5, 4, 4 is in R. For input I
1
1 this tuple is not in R, and so the annotated
13.4 Two Improvements
329
A
B
C
A
B
C
R
5
6
6
S
1
2
3
5
6
7
3
4
5
5
6
8
...

5
6
n
I1( R)
I1( S)
(a) Sample input instance I1
Tbff( x, y, z)
R( x, y, z)
input_Tbff
1
3 ($2 = $3)
5 ($2 = $3 = 4)
sup 1[ x]
sup 1[ x, y, z]
0
1
1
5
6
6
3 ($2 = $3)
5
6
7
5 ($2 = $3 = 4)
5
6
8
...

5
6
n
Tbff( x, y, z)
S( x, y, w), Tbff( w, z, z)
ans_Tbff
5
6
6
5
6
7
...

sup 2[ x]
sup 2[ x, y, w]
sup 2[ x, y, z]
0
1
2
5
6
n
1
1 2 3
3 4 6
3
4
6
3 ($2 = $3)
3 4 5 ($3 = 4)
5 ($2 = $3 = 4)
(b) QSQ evaluation
Figure 13.4:
Behavior of QSQ on program with repeated variables
330
Evaluation of Datalog
← T(1, y, z)
← R(1, y, z)
← S(1, y, w 1), T( w 1, z, z)
×
← T(3, z, z)
← R(3, z, z)
← S(3, z, w 2), T( w 2, z, z)
×
← T(5, 4, 4)
← R(5, 4, 4)
← S(5, 4, w 3), T( w 3, 4, 4)
×
×
Figure 13.5:
Behavior of SLD on program with repeated variables
tuple 5 in sup 1 generates nothing (even though in the original QSQ framework many 0
tuples are generated). Analogously, because there is no tuple 5, 4, w in S, the annotated tuple 5 of sup 2 does not generate anything in sup 2. This illustrates how annotations can 0
1
be used to restrict the facts generated during execution of QSQ.

More generally, annotations on tuples are conjunctions of equality terms of the form
‘$i = $j ’ and ‘$i = a’ (where a is a constant). During step (B.ii.b) of QSQ, annotations are associated with new tuples placed into relations input _Rγ . We permit the same tuple to occur in input _Rγ with different annotations. This enhanced version of QSQ is called annotated QSQ. The enhancement correctly produces all answers to the initial query, and the set of facts generated now closely parallels the set of facts and assignments generated by the SLD tree corresponding to the QSQ templates used.

The magic set technique can also be enhanced to incorporate the information captured by the annotations just described. This is accomplished by an initial preprocessing of the program (and query) called “subgoal rectification.” Speaking loosely, a subgoal corresponding to an idb predicate is rectified if it has no constants and no repeated variables.

Rectified subgoals may be formed from nonrectified ones by creating new idb predicates that correspond to versions of idb predicates with repeated variables and constants. For example, the following is the result of rectifying the subgoals of the program Pr: T (x, y, z)
← R(x, y, z)
T (x, y, z)
← S(x, y, w), T$2=$3(w, z)
T$2=$3(x, z) ← R(x, z, z)
T$2=$3(x, z) ← S(x, z, w), T$2=$3(w, z)
13.4 Two Improvements
331
query(y, z) ← T (1, y, z)
query(z, z) ← T$2=$3(1, z).

It is straightforward to develop an iterative algorithm that replaces an arbitrary datalog program and query with an equivalent one, all of whose idb subgoals are rectified (see Exercise 13.20). Note that there may be more than one rule defining the query after rectification.

The magic set transformation is applied to the rectified program to obtain the final result. In the preceding example, there are two relevant adornments for the predicate T$2=$3
(namely, bf and bb).

The following can be verified (see Exercise 13.21):
Theorem 13.4.1 (Informal)
The framework of annotated QSQ and the magic set trans-
formation augmented with subgoal rectification are both correct. Furthermore, the set of idb predicate facts generated by evaluating a datalog query with either of these techniques is identical to the set of facts occurring in the corresponding SLD tree.

A tight correspondence between the assignments in SLD derivation trees and the supplementary relations generated both by annotated QSQ and rectified magic sets can be shown. The intuitive conclusion drawn from this development is that top-down and bottom-up techniques for datalog evaluation have essentially the same efficiency.

Counting (by Example)
We now present a brief sketch of another improvement of the magic set technique. It is different from the previous one in that it works only when the underlying data set is known to have certain acyclicity properties.

Consider evaluating the following SG query based on the Same-Generation program: (1)
sg(x, y) ← flat(x, y)
(2)
sg(x, y) ← up(x, x1), sg(x1, y1), down(y1, y) query(y) ← sg(a, y)
on the input Jn given by
Jn( up)
= {a, bi | i ∈ [1, n]} ∪ {bi, cj | i, j ∈ [1, n]}
Jn( flat)
= {ci, dj | i, j ∈ [1, n]}
Jn( down) = {di, ej | i, j ∈ [1, n]} ∪ {ei, f | i ∈ [1, n]}.

Instance J2 is shown in Fig. 13.6.

The completed QSQ template on input J2 for the second rule of the SG query is shown in Fig. 13.7(a). (The tuples are listed in the order in which QSQR would discover them.) Note that on input Jn both sup 2 and sup 2 would contain n(n + 1) tuples.

1
2
Consider now the proof tree of SG having root sg(a, f ) shown in Fig. 13.8 (see Chapter 12). There is a natural correspondence of the children at depth 1 in this tree with the supplementary relation atoms sup 2(a), sup 2(a, b
(a, e
(a, f ) generated
0
1
1), sup 2
2
1), and sup 2
3
332
Evaluation of Datalog
flat
c
c
d
d
1
2
1
2
up
down
b
b
e
e
1
2
1
2
up
down
a
f
Figure 13.6:
Instance J2 for counting
by QSQ; and between the children at depth 2 with sup 2(b
(b
(b
0
1), sup 2
1
1, c1), sup 2
2
1, d1), and
sup 2(b
3
1, e1).

A key idea in the counting technique is to record information about the depths at which supplementary relation atoms occur. In some cases, this permits us to ignore some of the specific constants present in the supplementary atoms. You will find that this is illustrated in Fig. 13.7(b). For example, we show atoms count _ sup 2(1, a), count _ sup 2(1, b 0
1
1), count _
sup 2(1, e
(1, f ) that correspond to the supplementary atoms sup 2(a), 2
1), and count _ sup 2
3
0
sup 2(a, b
(a, e
(a, f ). Note that, for example, count _ sup 2(2, c
1
1), sup 2
2
1), and sup 2
3
1
1) corre-
sponds to both sup 2(b
(b
1
1, c1) and sup 2
1
2, c1).

More generally, the modified supplementary relation atoms hold an “index” that indicates a level in a proof tree corresponding to how the atom came to be created. Because of the structure of SG, and assuming that the up relation is acyclic, these modified supplementary relations can be used to find query answers. Note that on input Jn, the relations countsup 2′ and count _ sup 2′ hold 2n tuples each rather than n(n + 1), as in the original QSQ
1
2
approach.

We now describe how the magic set program associated with the SG query can be transformed into an equivalent program (on acyclic input) that uses the indexes suggested by Fig. 13.7(b). The magic set rewriting of the SG query is given by (s1.1)
sg bf (x, y) ← input _ sg bf (x), flat(x, y) (s2.1)
sup 21(x, x1) ← input _ sg bf (x), up(x, x1) (s2.2)
sup 22(x, y1) ← sup 21(x, x1), sg bf (x1, y1) (s2.3)
sg bf (x, y) ← sup 22(x, y1), down(y1, y)
13.4 Two Improvements
333
sgbf( x, y)
up( x, x ), sgbf( x , y ), down( y , y) 1
1
1
1
sup 2[ x]
sup 2[ x, x ]
sup 2[ x, y ]
sup 2[ x, y]
0
1
1
2
1
3
a
a b
b d
b e
1
1
1
1
1
b
a b
b d
b e
1
2
1
2
1
2
b
b c
b d
b e
2
1
1
2
1
2
1
b c
b d
b e
1
2
2
2
2
2
b c
a e
a f
2
1
1
b c
a e
2
2
2
(a) Completed QSQ template for sgbf on input J2
sgbf( x, y)
up( x, x ), sgbf( x , y ), down( y , y) 1
1
1
1
count_sup 2[ d, x]
count_sup 2[ d, x ]
count_sup 2[ d, y ]
count_sup 2[ d, y]
0
1
1
2
1
3
1 a
1 b
2 d
2 e
1
1
1
2 b
1 b
2 d
2 e
1
2
2
2
2 b
2 c
1 e
1 f
2
1
1
2 c
1 e
2
2
(b) Alternative QSQ “template,” using indices
Figure 13.7:
Illustration of intuition behind counting
(i2.2)
input _ sg bf (x1) ← sup 21(x, x1)
(seed)
input _ sg bf (a) ←
(query)
query(y)
← sg bf (a, y).

The counting version of this is now given. (In other literature on counting, the seed is initialized with 0 rather than 1.)

334
Evaluation of Datalog
sg( a, f)
up( a, b )
sg( b , e )
down( e , f)
1
1
1
1
up( b , c )
sg( c , d )
down( d , e )
1
1
1
1
1
1
flat( c , d )
1
1
Figure 13.8:
A proof tree for sg(a, f )
(c-s1.1)
count _ sg bf (I, y)
← count _ input _ sg bf (I, x), flat(x, y) (c-s2.1)
count _ sup 21(I, x1)
← count _ input _ sg bf (I, x), up(x, x1) (c-s2.2)
count _ sup 22(I, y1)
← count _ sup 21(I, x1), count _ sg bf (I + 1, y1) (c-s2.3)
count _ sg bf (I, y)
← count _ sup 22(I, y1), down(y1, y)
(c-i2.2)
count _ input _ sg bf (I + 1, x1) ← count _ sup 21(I, x1) (c-seed)
count _ input _ sg bf (1, a)
←
(c-query) query(y)
← count _ sg bf (1, y)
In the preceding, expressions such as I + 1 are viewed as a short hand for using a variable J in place of I + 1 and including J = I + 1 in the rule body.

In the counting version, the first coordinate of each supplementary relation keeps track of a level in a proof tree rather than a specific value. Intuitively, when “constructing”
a sequence of supplementary atoms corresponding to a given level of a proof tree, each idb atom used must have been generated from the next deeper level. This is why count _
sg bf (I + 1, y1) is used in rule (c-s2.2). Furthermore, rule (c-i2.2) initiates the “construction” corresponding to a new layer of the proof tree.

The counting program of the preceding example is not safe, in the sense that on some inputs the program may produce an infinite set of tuples in some predicates (e.g., count _ sup 2). For example, this will happen if there is a cycle in the up relation reachable 1
from a. Analogous situations occur with most applications of counting. As a result, the counting technique can only be used where the underlying data set is known to satisfy certain restrictions.

Bibliographic Notes
335
This preceding example is a simple application of the general technique of counting.

A more general version of counting uses three kinds of indexes. The first, illustrated in the example, records information about levels of proof trees. The second is used to record information about what rule is being expanded, and the third is used to record which atom of the rule body is being considered (see Exercise 13.23). A description of the kinds of programs for which the counting technique can be used is beyond the scope of this book. Although limited in applicability, the counting technique has been shown to yield significant savings in some contexts.

Bibliographic Notes
This chapter has presented a brief introduction to the research on heuristics for datalog evaluation. An excellent survey of this work is [BR88a], which presents a taxonomy of different techniques and surveys a broad number of them. Several books provide substantial coverage of this area, including [Bid91a, CGT90, Ull89b]. Experimental results comparing several of the techniques in the context of datalog are described in [BR88b]. An excellent survey on deductive database systems, which includes an overview of several prototype systems that support datalog, is presented in [RU94].

The naive and seminaive strategies for datalog evaluation underlie several early investigations and implementations [Cha81b, MS81]; the seminaive strategy for evaluation is described in [Ban85, Ban86], which also propose various refinements. The use of T i−1 and T i in Algorithm 13.1.1 is from [BR87b]. Reference [CGT90] highlights the close relationship of these approaches to the classical Jacobi and Gauss-Seidel algorithms of numerical analysis.

An essential ingredient of the top-down approaches to datalog evaluation is that of
“pushing” selections into recursions. An early form of this was developed in [AU79], where selections and projections are pushed into restricted forms of fixpoint queries (see Chapter 14 for the definition of fixpoint queries).

The Query-Subquery (QSQ) approach was initially presented in [Vie86]; the independently developed method of “extension tables” [DW87] is essentially equivalent to this.

The QSQ approach is extended in [Vie88, Vie89] to incorporate certain global optimizations. An extension of the technique to general logic programming, called SLD-AL, is developed in [Vie87a, Vie89]. Related approaches include APEX [Loz85], Earley Deduction [PW80, Por86], and those of [Nej87, Roe87]. The connection between context-free parsing and datalog evaluation is highlighted in [Lan88].

The algorithms of the QSQ family are sometimes called “memo-ing” approaches, because they use various data structures to remember salient inferred facts to filter the work of traditional SLD resolution.

Perhaps the most general of the top-down approaches uses “rule/goal” graphs [Ull85]; these potentially infinite trees intuitively correspond to a breadth-first, set-at-a-time execution of SLD resolution. Rule/goal graphs are applied in [Van86] to evaluate datalog queries in distributed systems. Similar graph structures have also been used in connection with general logic programs (e.g., [Kow75, Sic76]). A survey of several graph-based approaches is
[DW85].

Turning to bottom-up approaches, the essentially equivalent approaches of [HN84] and
336
Evaluation of Datalog
[GdM86] develop iterative algebraic programs for linear datalog programs. [GS87] extends these. A more general approach based on rewriting iterative algebra programs is presented in [CT87, Tan88].

The magic set and counting techniques originally appeared for linear datalog in
[BMSU86]. Our presentation of magic sets is based on an extended version called “generalized supplementary magic sets” [BR87a, BR91]. That work develops a general notion of sideways information passing based on graphs (see Exercise 13.19), and develops both magic sets and counting in connection with general logic programming. The Alexander method [RLK86, Ker88], developed independently, is essentially the same as generalized supplementary magic sets for datalog. This was generalized to logic programming in
[Sek89]. Magic set rewriting has also been applied to optimize SQL queries [MFPR90].

The counting method is generalized and combined with magic sets in [SZ86, SZ88].

Supplementary magic is incorporated in [BR91]. Analytic comparisons of magic and counting for selected programs are presented in [MSPS87].

Another bottom-up technique is Static Filtering [KL86a, KL86b]. This technique forms a graph corresponding to the flow of tuples through a bottom-up evaluation and then modifies the graph in a manner that captures information passing resulting from constants in the initial query.

Several of the investigations just mentioned, including [BR87a, KL86a, KL86b, Ull85, Vie86], emphasize the idea that sideways information passing and control are largely independent. Both [SZ88] and [BR91] describe fairly general mechanisms for specifying and using alternative sideways information passing and related message passing. A more general form of sideways information passing, which passes bounding inequalities between subgoals, is studied in [APP+86]. A formal framework for studying the success of pushing selections into datalog programs is developed in [BKBR87].

Several papers have studied the connection between top-down and bottom-up evaluation techniques. One body of the research in this direction focuses on the sets of facts generated by the top-down and bottom-up techniques. One of the first results relating top-down and bottom-up is from [BR87a, BR91], where it is shown that if a top-down technique and the generalized supplementary magic set technique use a given family of sideways information passing techniques, then the sets of intermediate facts produced by both techniques correspond. That research is conducted in the context of general logic programs that are range restricted. These results are generalized to possibly non-range-restricted logic programs in the independent research [Ram91] and [Sek89]. In that research, bottom-up evaluations may use terms and tuples that include variables, and bottom-up evaluation of rewritten programs uses unification rather than simple relational join. A close correspondence between top-down and bottom-up evaluation for datalog was established in [Ull89a], where subgoal rectification is used. The treatment of Program Pr and Theorem 13.4.1 are inspired by that development. This close correspondence is extended to arbitrary logic programs in [Ull89b]. Using a more detailed cost model, [SR93] shows that bottom-up evaluation asymptotically dominates top-down evaluation for logic programs, even if they produce nonground terms in their output.

A second direction of research on the connection between top-down and bottom-up approaches provides an elegant unifying framework [Bry89]. Recall in the discussion of Theorem 13.2.2 that the answer to a query can be obtained by performing the steps of
Exercises
337
the QSQ until a fixpoint is reached. Note that the fixpoint operator used in this chapter is different from the conventional bottom-up application of TP used by the naive algorithm for datalog evaluation. The framework presented in [Bry89] is based on meta-interpreters (i.e., interpreters that operate on datalog rules in addition to data); these can be used to specify QSQ and related algorithms as bottom-up, fixpoint evaluations. (Such meta-programming is common in functional and logic programming but yields novel results in the context of datalog.) Reference [Bry89] goes on to describe several top-down and bottom-up datalog evaluation techniques within the framework, proving their correctness and providing a basis for comparison.

A recent investigation [NRSU89] improves the performance of the magic sets in some cases. If the program and query satisfy certain conditions, then a technique called factoring can be used to replace some predicates by new predicates of lower arity. Other improvements are considered in [Sag90], where it is shown in particular that the advantage of one method over another may depend on the actual data, therefore stressing the need for techniques to estimate the size of idb’s (e.g., [LN90]).

Extensions of the datalog evaluation techniques to stratified datalog¬ programs (see Chapter 15) include [BPR87, Ros91, SI88, KT88].

Another important direction of research has been the parallel evaluation of datalog programs. Heuristics are described in [CW89b, GST90, Hul89, SL91, WS88, WO90].

A novel approach to answering datalog queries efficiently is developed in [DT92, DS93]. The focus is on cases in which the same query is asked repeatedly as the underlying edb is changing. The answer of the query (and additional scratch paper relations) is materialized against a given edb state, and first-order queries are used incrementally to maintain the materialized data as the underlying edb state is changed.

A number of prototype systems based on variants of datalog have been developed, incorporating some of the techniques mentioned in this chapter. They include DedGin
[Vie87b, LV89], NAIL! [Ull85, MUV86, MNS+87], LDL [NT89], ALGRES [CRG+88], NU-Prolog [RSB+87], GLUE-NAIL [DMP93], and CORAL [RSS92, RSSS93]. Descriptions of projects in this area can also be found in [Zan87], [RU94].

Exercises
Exercise 13.1
Recall the program RSG′ from Section 13.1. Exhibit an instance I such that on this input, δi = ∅ for each i > 0.

rsg
Exercise 13.2
Recall the informal discussion of the two seminaive “versions” of the nonlinear ancestor program discussed in Section 13.1. Let P1 denote the first of these, and P2 the second.

Show the following.

(a) For some input, P2 can produce the same tuple more than once at some level beyond the first level.

(b) If P2 produces the same tuple more than once, then each occurrence corresponds to a distinct proof tree (see Section 12.5) from the program and the input.

(c) P1 can produce a given tuple twice, where the proof trees corresponding to the two occurrences are identical.

Exercise 13.3
Consider the basic seminaive algorithm (13.1.1).

338
Evaluation of Datalog
(a) Verify that this algorithm terminates on all inputs.

(b) Show that for each i ≥ 0 and each idb predicate S, after the ith execution of the loop the value of variable Si is equal to T i (I)(S) and the value of .i+1 is equal P
S
to T i+1(I)(S) − T i (I)(S).

P
P
(c) Verify that this algorithm produces correct output on all inputs.

(d) Give an example input for which the same tuple is generated during different loops of the algorithm.

Exercise 13.4
Consider the improved seminaive algorithm (13.1.2).

(a) Verify that this algorithm terminates and produces correct output on all inputs.

(b) Give an example of a program P for which the improved seminaive algorithm produces fewer redundant tuples than the basic seminaive algorithm.

Exercise 13.5
Let P be a linear datalog program, and let P ′ be the set of rules associated with P by the improved seminaive algorithm. Suppose that the naive algorithm is performed using P ′
on some input I. Does this yield P (I)? Why or why not? What if the basic seminaive algorithm is used?

Exercise 13.6
A set X of relevant facts for datalog query (P , q) and input I is minimal if (1) for each answer β of q there is a proof tree for β constructed from facts in X, and (2) X is minimal having this property. Informally describe an algorithm that produces a minimal set of relevant facts for a query (P , q) and input I and is polynomial time in the size of I.

Exercise 13.7
[BR91] Suppose that program P includes the rule
ρ : S(x, y) ← S1(x, z), S2(z, y), S3(u, v), S4(v, w),
where S3, S4 are edb relations. Observe that the atoms S3(u, v) and S4(v, w) are not connected to the other atoms of the rule body or to the rule head. Furthermore, in an evaluation of P on input I, this rule may contribute some tuple to S only if there is an assignment α for u, v, w such that {S3(u, v), S4(v, w)}[α] ⊆ I. Explain why it is typically more efficient to replace ρ with ρ′ : S(x, y) ← S1(x, z), S2(z, y)
if there is such an assignment and to delete ρ from P otherwise. Extend this to the case when S3, S4 are idb relations. State a general version of this heuristic improvement.

Exercise 13.8
Consider the adorned rule
bf
bf
ff
bf
Rbf (x, w) ← S
(x, y), S
(y, z), T (u, v), T
(v, w).

1
2
1
2
Explain why it makes sense to view the second occurrence of v as bound.

Exercise 13.9
Consider the rule
R(x, y, y) ← S(y, z), T (z, x).

(a) Construct adorned versions of this rule for R ff b and Rf bb.

Exercises
339
(b) Suppose that in the QSQ algorithm a tuple b, c is placed into input _Rf bb. Explain why this tuple should not be placed into the 0th supplementary relation for the second adorned rule constructed in part (a).

(c) Exhibit an example analogous to part (b) based on the presence of a constant in the head of a rule rather than on repeated variables.

Exercise 13.10
(a) Complete the evaluation in Example 13.2.1.

(b) Use Algorithm 13.2.3 (QSQR) to evaluate that example.

⋆ Exercise 13.11 In the QSQR algorithm, the procedure for processing subqueries of the form (Rγ , S) is called until no global variable is changed. Exhibit an example datalog query and input where the second cycle of calls to the subqueries (Rγ , S) generates new answer tuples.

♠ Exercise 13.12
(a) Prove Theorem 13.2.2. (b) Prove that the QSQR algorithm is correct.

⋆ Exercise 13.13 The Iterative QSQ ( QSQI) algorithm uses the QSQ framework, but without recursion. Instead in each iteration it processes each rule body from left to right, using the values currently in the relations ans _Rγ when computing values for the supplementary relations.

As with QSQR, the variables input _Rγ and ans _Rγ are global, and the variables for the supplementary relations are local. Iteration continues until there is no change to the global variables.

(a) Specify the QSQI algorithm more completely.

(b) Give an example where QSQI performs redundant work that QSQR does not.

Exercise 13.14
[BR91] Consider the following query based on a nonlinear variant of the same-generation program, called here the SGV query:
(a) sgv(x, y) ← flat(x, y)
(b) sgv(x, y) ← up(x, z1), sgv(z1, z2), flat(z2, z3), sgv(z3, z4), down(z4, y) query(y) ← sgv(a, y)
Give the magic set transformation of this program and query.

Exercise 13.15
Give examples of how a query (P m, qm) resulting from magic set rewriting can produce nonrelevant and redundant facts.

♠ Exercise 13.16
(a) Give the general definition of the magic set rewriting technique.

(b) Prove Theorem 13.3.1.

Exercise 13.17
Compare the difficulties, in practical terms, of using the QSQ and magic set frameworks for evaluating datalog queries.

⋆ Exercise 13.18 Let (P, q) denote the SGV query of Exercise 13.14. Let (P m, qm) denote the result of rewriting this program, using the (generalized supplementary) magic set transformation presented in this chapter. Under an earlier version, called here “original” magic, the rewritten form of (P , q) is (P om, qom):
340
Evaluation of Datalog
(o-m1)
sgv bf (x, y)
← input _ sgv bf (x), flat(x, y)
(o-m2)
sgv bf (x, y)
← input _ sgv bf (x), up(x, z1), sgv bf (z1, z2), flat(z2, z3), sgv bf (z3, z4), down(z4, y)
(o-i2.2)
input _ sgv bf (z1) ← input _ sgv bf (x), up(x, z1) (o-i2.4)
input _ sgv bf (z3) ← input _ sgv bf (x), up(x, z1), sgv bf (z1, z2), flat(z2, z3)
(o-seed)
input _ sgv(a)
←
(o-query)
query(y)
← sgv bf (a, y)
Intuitively, the original magic set transformation uses the relations input _Rγ , but not supplementary relations.

(a) Verify that (P om, qom) is equivalent to (P , q).

(b) Compare the family of facts computed during the executions of (P m, qm) and (P om, qom).

(c) Give a specification for the original magic set transformation, applicable to any datalog query.

⋆ Exercise 13.19 Consider the adorned rule
bf
bf
bf
bf
bbf
Rbbf (x, y, z) ← T
(x, s), T
(s, t ), T
(y, u), T
(u, v), T
(t, v, z).

1
2
3
4
5
A sip graph for this rule has as nodes all atoms of the rule and a special node exit, and edges (R, T1), (T1, T2), (R, T3), (T3, T4), (T2, T5), (T4, T5), (T5, exit). Describe a family of supplementary relations, based on this sip graph, that can be used in conjunction with the QSQ
and magic set approaches. [Use one supplementary relation for each edge (corresponding to the output of the tail of the edge) and one supplementary relation for each node except for R
(corresponding to the input to this node—in general, this will equal the join of the relations for the edges entering the node).] Explain how this may increase efficiency over the left-to-right approach used in this chapter. Generalize the construction. (The notion of sip graph and its use is a variation of [BR91].)

♠ Exercise 13.20 [Ull89a] Specify an algorithm that replaces a program and query by an equivalent one, all of whose idb subgoals are rectified. What is the complexity of this algorithm?

♠ Exercise 13.21
(a) Provide a more detailed specification of the QSQ framework with annotations, and prove its correctness.

(b) [Ull89b, Ull89a] State formally the definitions needed for Theorem 13.4.1, and prove it.

Exercise 13.22
Write a program using counting that can be used to answer the RSG query presented at the beginning of Section 13.2.

Exercises
341
(c-s1.1)
count _ sgv bf (I, K, L, y)
← count _ input _ sgv bf (I, K, L, x), flat(x, y) (c-s2.1)
count _ sup 21(I, K, L, z1)
← count _ input _ sgv bf (I, K, L, x), up(x, z1) (c-s2.2)
count _ sup 22(I, K, L, z2)
← count _ sup 21(I, K, L, z1),
count _ sgv bf (I + 1, 2K + 2, 5L + 2, z2)
(c-s2.3)
count _ sup 23(I, K, L, z3)
← count _ sup 22(I, K, L, z2), flat(z2, z3)
(c-s2.4)
count _ sup 24(I, K, L, z4)
← count _ sup 23(I, K, L, z3),
count _ sgv bf (I + 1, 2K + 2, 5L + 4, z4),
(c-s2.5)
count _ sgv bf (I, K, L, y)
← count _ sup 24(I, K, L, z4), down(z4, y)
(c-i2.2)
count _ input _ sgv bf (I + 1, 2K + 2, 5L + 2, z1)
← count _ sup 21(I, K, L, z1)
(c-i2.4)
count _ input _ sgv bf (I + 1, 2K + 2, 5L + 4, z3)
← count _ sup 23(I, K, L, z3)
(c-seed)
count _ input _ sgv bf (1, 0, 0, a) ←
(c-query)
query(y)
← count _ sgv bf (1, 0, 0, y)
Figure 13.9:
Generalized counting transformation on SGV query
⋆ Exercise 13.23 [BR91] This exercise illustrates a version of counting that is more general than that of Exercise 13.22. Indexed versions of predicates shall have three index coordinates (occurring leftmost) that hold:
(i) The level in the proof tree of the subgoal that a given rule is expanding.

(ii) An encoding of the rules used along the path from the root of the proof tree to the current subgoal. Suppose that there are k rules, numbered (1), . . . , (k). The index for the root node is 0 and, given index K, if rule number i is used next, then the next index is given by kK + i.

(iii) An encoding of the atom occurrence positions along the path from root to the current node. Assuming that l is the maximum number of idb atoms in any rule body, this index is encoded in a manner similar to item (ii).

A counting version of the SGV query of Exercise 13.14 is shown in Fig. 13.9. Verify that this is equivalent to the SGV query in the case where there are no cycles in up or down.

14 RecursionandNegation
Vittorio:
Let’s combine recursion and negation.

Riccardo:
That sounds hard to me.

Sergio:
It’s no problem, just add fixpoint to the calculus, or while to the algebra.

Riccardo:
That sounds hard to me.

Vittorio:
OK—how about datalog with negation?

Riccardo:
That sounds hard to me.

Alice:
Riccardo, you are recursively negative.

The query languages considered so far were obtained by augmenting the conjunctive queries successively with disjunction, negation, and recursion. In this chapter, we consider languages that provide both negation and recursion. They allow us to ask queries such as, “Which are the pairs of metro stops which are not connected?” . This query is not expressible in relational calculus and algebra or in datalog.

The integration of recursion and negation is natural and yields highly expressive languages. We will see how it can be achieved in the three paradigms considered so far: algebraic, logic, and deductive. The algebraic language is an extension of the algebra with a looping construct and an assignment, in the style of traditional imperative programming languages. The logic language is an extension of the calculus in which recursion is provided by a fixpoint operator. The deductive language extends datalog with negation.

In this chapter, the semantics of datalog with negation is defined from a purely computational perspective that is in the spirit of the algebraic approach. More natural and widely accepted model-theoretic semantics, such as stratified and well-founded semantics, are presented in Chapter 15.

As we consider increasingly powerful languages, the complexity of query evaluation becomes a greater concern. We consider two flavors of the languages in each paradigm: the inflationary one, which guarantees termination in time polynomial in the size of the database; and the noninflationary one, which only guarantees that a polynomial amount of space is used.1 In the last section of this chapter, we show that the polynomial-time-bounded languages defined in the different paradigms are equivalent. The set of queries they define is called the fixpoint queries. The polynomial-space-bounded languages are also equivalent, and the corresponding set of queries is called the while queries. In Chapter 17, we examine in more detail the expressiveness and complexity of the fixpoint and while queries. Note that, in particular, the polynomial time and space bounds on the complexity 1 For comparison, it is shown in Chapter 17 that CALC requires only logarithmic space.

342
Recursion and Negation
343
of such queries imply that there are queries that are not fixpoint or while queries. More powerful languages are considered in Chapter 18.

Before describing specific languages, we present an example that illustrates the principles underlying the two flavors of the languages.

Example
The following is based on a version of the well-known “game of life,” which is used to model biological evolution. The game starts with a set of cells, some of which are alive and some dead; the alive ones are colored in blue or red. (One cell may have two colors.) Each cell has other cells as neighbors. Suppose that a binary relation Neighbor holds the neighbor relation (considered as a symmetric relation) and that the information about living cells and their color is held in a binary relation Alive (see Fig. 14.1). Suppose first that a cell can change status from dead to alive following this rule: (α)
A dead cell becomes alive if it has at least two neighbors that are alive and have the same color. It then takes the color of the “parents.”
The evolution of a particular population for the Neighbor graph of Fig. 14.1(a) is given in Fig. 14.1(b). Observe that the sets of tuples keep increasing and that we reach a stable state.

This is an example of inflationary iteration.

Now suppose that the evolution also obeys the second rule:
(β)
A live cell dies if it has more than three live neighbors.

The evolution of the population with the two rules is given in Fig. 14.1(c). Observe that the number of tuples sometimes decreases and that the computation diverges. This is an example of noninflationary iteration.

All languages that we consider use a fixed set of relation schemas throughout the computation. At any point in the computation, intermediate results contain only constants from the input database or that are specified in the query. Suppose the relations used in the computation have arities r1, . . . , rk, the input database contains n constants, and the query refers to c constants. Then the number of tuples in any intermediate result is bounded by k
i=1(n + c)ri , which is a polynomial in n. Thus such queries can be evaluated in polynomial space. As will be seen when the formal definitions are in place, this implies that each noninflationary iteration, and hence each noninflationary query, can be evaluated in polynomial space, whether or not it terminates. In contrast, the inflationary semantics ensures termination by requiring that a tuple can never be deleted once it has been inserted.

Because there are only polynomially many tuples, each such program terminates in polynomial time.

To summarize, the inflationary languages use iteration based on an “inflation of tuples.” In all three paradigms, inflationary queries can be evaluated in polynomial time, and the same expressive power is obtained. The noninflationary languages use noninflationary or destructive assignment inside of iterations. In all three paradigms, noninflationary queries can be evaluated in polynomial space, and again the same expressive power is
344
Recursion and Negation
Neighbor
a
e
b
e
c
e
d
e
(a) Neighbor
Alive
Alive
Alive
a
blue
a
blue
a
blue
b
red
b
red
b
red
c
blue
c
blue
c
blue
. . .

d
red
d
red
d
red
e
blue
e
blue
e
red
e
red
(b) Inflationary evolution
Alive
Alive
Alive
Alive
Alive
a
blue
a
blue
a
blue
a
blue
a
blue
b
red
b
red
b
red
b
red
b
red
. . .

c
blue
c
blue
c
blue
c
blue
c
blue
d
red
d
red
d
red
d
red
d
red
e
blue
e
blue
e
red
e
red
(c) Noninflationary evolution
Figure 14.1:
Game of life
obtained. (We note, however, that it remains open whether the inflationary and the noninflationary languages have equivalent expressive power; we discuss this issue later.) 14.1
Algebra + While
Relational algebra is essentially a procedural language. Of the query languages, it is the closest to traditional imperative programming languages. Chapters 4 and 5 described how it can be extended syntactically using assignment (:=) and composition (;) without increasing its expressive power. The extensions of the algebra with recursion are also consistent with
14.1 Algebra + While
345
the imperative paradigm and incorporate a while construct, which calls for the iteration of a program segment. The resulting language comes in two flavors: inflationary and noninflationary. The two versions of the language differ in the semantics of the assignment statement. The noninflationary version was the one first defined historically, and we discuss it next. The resulting language is called the while language.

Noninflationary Semantics
Recall from Chapter 4 that assignment statements can be incorporated into the algebra using expressions of the form R := E, where E is an algebra expression and R a relational variable of the same sort as the result of E. (The difference from Chapter 4 is that it is no longer required that each successive assignment statement use a distinct, previously unused variable.) In the while language, the semantics of an assignment statement is as follows: The value of R becomes the result of evaluating the algebra expression E on the current state of the database. This is the usual destructive assignment in imperative programming languages, where the old value of a variable is overwritten.

While statements have the form
while change do
begin
loop body
end
There is no explicit termination condition. Instead a loop runs as long as the execution of the body causes some change to some relation (i.e., until a stable state is reached). At the end of this section, we consider the introduction of explicit terminating conditions and see that this does not affect the language in an essential manner.

Nesting of loops is permitted. A while program is a finite sequence of assignment or while statements. The program uses a finite set of relational variables of specified sorts, including the names of relations in the input database. Relational variables that are not in the input database are initialized to the empty relation. A designated relational variable holds the output to the program at the end of the computation. The image (or value) of program P on I, denoted P (I), is the value finally assigned to the designated variable if P
terminates on I; otherwise P (I) is undefined.

Example 14.1.1 (Transitive Closure)
Consider a binary relation G[AB], specifying
the edges of a graph. The following while program computes in T [AB] the transitive closure of G.

T := G;
while change do
begin
T := T ∪ πAB(δB→C(T ) ⊲⊳ δA→C(G));
end
A computation ends when T becomes stable, which means that no new edges were added in the current iteration, so T now holds the transitive closure of G.

346
Recursion and Negation
Example 14.1.2 (Add-Remove)
Consider again a binary relation G specifying the
edges of a graph. Each loop of the following program
• removes from G all edges a, b if there is a path of length 2 from a to b, and
• inserts an edge a, b if there is a vertex not directly connected to a and b.

This is iterated while some change occurs. The result is placed into the binary relation T .

In addition, the binary relation variables ToAdd and ToRemove are used as “scratch paper.”
For the sake of readability, we use the calculus with active domain semantics whenever this is easier to understand than the corresponding algebra expression.

T := G;
while change do
begin
ToRemove := {x, y | ∃z(T (x, z) ∧ T (z, y))};
ToAdd := {x, y | ∃z(¬T (x, z) ∧ ¬T (z, x) ∧ ¬T (y, z) ∧ ¬T (z, y))}; T := (T ∪ ToAdd) − ToRemove;
end
In the Transitive Closure example, the transitive closure query always terminates. This is not the case for the Add-Remove query. (Try the graph {a, a, a, b, b, a, b, b}.) The halting problem for while programs is undecidable (i.e., there is no algorithm that, given a while program P , decides whether P halts on each input; see Exercise 14.2). Observe, however, that for a pair (P , I), one can decide whether P halts on input I because, as argued earlier, while computations are in pspace.

Inflationary Semantics
We define next an inflationary version of the while language, denoted by while+. The while+ language differs with while in the semantics of the assignment statement. In particular, in while+, assignment is cumulative rather than destructive: Execution of the statement assigning E to R results in adding the result of E to the old value of R. Thus no tuple is removed from any relation throughout the execution of the program. To distinguish the cumulative semantics from the destructive one, we use the notation P += e for the cumulative semantics.

Example 14.1.3 (Transitive Closure Revisited)
Following is a while+ program that
computes the transitive closure of a graph represented by a binary relation G[AB]. The result is obtained in the variable T [AB].

T += G;
while change do
begin
T += πAB(δB→C(T ) ⊲⊳ δA→C(G));
end
14.2 Calculus + Fixpoint
347
This is almost exactly the same program as in the while language. The only difference is that because assignment is cumulative, it is not necessary to add the content of T to the result of the projection.

To conclude this section, we consider alternatives for the control condition of loops.

Until now, we based termination on reaching a stable state. It is also common to use explicit terminating conditions, such as tests for emptiness of the form E = ∅, E = ∅, or E = E′, where E, E′ are relational algebra expressions. The body of the loop is executed as long as the condition is satisfied. The following example shows how transitive closure is computed using explicit looping conditions.

Example 14.1.4
We use another relation schema old T also of sort AB.

T += G;
while (T − old T ) = ∅ do
begin
old T += T ;
T += πAB(δB→C(T ) ⊲⊳ δA→C(G));
end
In the program, old T keeps track of the value of T resulting from the previous iteration of the loop. The computation ends when old T and T coincide, which means that no new edges were added in the current iteration, so T now holds the transitive closure of G.

It is easily shown that the use of such termination conditions does not modify the expressive power of while, and the use of conditions such as E = E′ does not modify the expressive power of while+ (see Exercise 14.5).

In Section 14.4 we shall see that nesting of loops in while queries does not increase expressive power.

14.2
Calculus + Fixpoint
Just as in the case of the algebra, we provide inflationary and noninflationary extensions of the calculus with recursion. This could be done using assignment statements and while loops, as for the algebra. Indeed, we used calculus notation in Example 14.1.2 ( Add-Remove). Instead we use an equivalent but more logic-oriented construct to augment the calculus. The construct, called a fixpoint operator, allows the iteration of calculus formulas up to a fixpoint. In effect, this allows defining relations inductively using calculus formulas.

As with while, the fixpoint operator comes in a noninflationary and an inflationary flavor.

For the remainder of this chapter, as a notational convenience, we use active domain semantics for calculus queries. In addition, we often use a formula ϕ(x1, . . . , xn) as an abbreviation for the query {x1, . . . , xn | ϕ(x1, . . . , xn)}. These two simplifications do not affect the results developed.

348
Recursion and Negation
Partial Fixpoints
The noninflationary version of the fixpoint operator is considered first. It is illustrated in the following example.

Example 14.2.1 (Transitive Closure Revisited)
Consider again the transitive closure
of a graph G. The relations Jn holding pairs of nodes at distance at most n can be defined inductively using the single formula
ϕ(T ) = G(x, y) ∨ T (x, y) ∨ ∃ z(T (x, z) ∧ G(z, y))
as follows:
J0 = ∅;
Jn = ϕ(Jn−1),
n > 0.

Here ϕ(Jn−1) denotes the result of evaluating ϕ(T ) when the value of T is Jn−1. Note that, for each input G, the sequence {Jn}n≥0 converges. That is, there exists some k for which Jk = Jj for every j > k (indeed, k is the diameter of the graph). Clearly, Jk holds the transitive closure of the graph. Thus the transitive closure of G can be defined as the limit of the foregoing sequence. Note that Jk = ϕ(Jk), so Jk is also a fixpoint of ϕ(T ). The relation Jk thereby obtained is denoted by µT (ϕ(T )). Then the transitive closure of G is defined by
µT (G(x, y) ∨ T (x, y) ∨ ∃z(T (x, z) ∧ G(z, y))).

By definition, µT is an operator that produces a new relation (the fixpoint Jk) when applied to ϕ(T ). Note that, although T is used in ϕ(T ), T is not a database relation but rather a relation used to define inductively µT (ϕ(T )) from the database, starting with T = ∅. T is said to be bound to µT . Indeed, µT is somewhat similar to a quantifier over relations. Note that the scope of the free variables of ϕ(T ) is restricted to ϕ(T ) by the operator µT .

In the preceding example, the limit of the sequence {Jn}n≥0 happens to exist and is in fact the least fixpoint of ϕ. This is not always the case; the possibility of nontermination is illustrated next (and Exercise 14.4 considers cases in which a nonminimal fixpoint is reached).

Example 14.2.2
Consider
ϕ(T ) = (x = 0 ∧ ¬T (0) ∧ ¬T (1)) ∨ (x = 0 ∧ T (1)) ∨ (x = 1 ∧ T (0)).

In this case the sequence {Jn}n≥0 is ∅, {0}, {1}, {0}, . . . (i.e., T flip-flops between zero and one). Thus the sequence does not converge, and µT (ϕ(T )) is not defined. Situations in which µ is undefined correspond to nonterminating computations in the while language.

The following nonterminating while program corresponds to µT (ϕ(T )).

14.2 Calculus + Fixpoint
349
T := {0};
while change do
begin
T := {0, 1} − T ;
end
Because µ is only partially defined, it is called the partial fixpoint operator. We now define its syntax and semantics in more detail.

Partial Fixpoint Operator
Let R be a database schema, and let T [m] be a relation
schema not in R. Let S denote the schema R ∪ {T }. Let ϕ(T ) be a formula using T and relations in R, with m free variables. Given an instance I over R, µT (ϕ(T )) denotes the relation that is the limit, if it exists, of the sequence {Jn}n≥0 defined by J0 = ∅;
Jn = ϕ(Jn−1),
n > 0,
where ϕ(Jn−1) denotes the result of evaluating ϕ on the instance Jn−1 over S whose restriction to R is I and Jn−1(T ) = Jn−1.

The expression µT (ϕ(T )) denotes a new relation (if it is defined). In turn, it can be used in more complex formulas like any other relation. For example, µT (ϕ(T ))(y, z) states that y, z is in µT (ϕ(T )). If µT (ϕ(T )) defines the transitive closure of G, the complement of the transitive closure is defined by
{x, y | ¬ µT (ϕ(T ))(x, y)}.

The extension of the calculus with µ is called partial fixpoint logic, denoted CALC+µ.

Partial Fixpoint Logic
CALC+µ formulas are obtained by repeated applications of
CALC operators (∃, ∀, ∨, ∧, ¬) and the partial fixpoint operator, starting from atoms. In particular, µT (ϕ(T ))(e1, . . . , en), where T has arity n, ϕ(T ) has n free variables, and the ei are variables or constants, is a formula. Its free variables are the variables in the set
{e1, . . . , en} [thus the scope of variables occurring inside ϕ(T ) consists of the subformula to which µT is applied]. Partial fixpoint operators can be nested. CALC+µ queries over a database schema R are expressions of the form
{e1, . . . , en | ξ},
where ξ is a CALC+µ formula whose free variables are those occurring in e1, . . . , en. The formula ξ may use relation names in addition to those in R; however, each occurrence P
of such relation name must be bound to some partial fixpoint operator µP . The semantics of CALC+µ queries is defined as follows. First note that, given an instance I over R and a sentence σ in CALC+µ, there are three possibilities: σ is undefined on I; σ is defined on I
350
Recursion and Negation
and is true; and σ is defined on I and is false. In particular, given an instance I over R, the answer to the query
q = {e1, . . . , en | ξ }
is undefined if the application of some µ in a subformula is undefined. Otherwise the answer to q is the n-ary relation consisting of all valuations ν of e1, . . . , en for which ξ(ν(e1), . . . , ν(en)) is defined and true. The queries expressible in partial fixpoint logic are called the partial fixpoint queries.

Example 14.2.3 (Add-Remove Revisited)
Consider again the query in Example
14.1.2. To express the query in CALC+µ, a difficulty arises: The while program initializes T to G before the while loop, whereas CALC+µ lacks the capability to do this directly.

To distinguish the initialization step from the subsequent ones, we use a ternary relation Q
and two distinct constants: 0 and 1. To indicate that the first step has been performed, we insert in Q the tuple 1, 1, 1. The presence of 1, 1, 1 in Q inhibits the repetition of the first step. Subsequently, an edge x, y is encoded in Q as x, y, 0. The while program in Example 14.1.2 is equivalent to the CALC+µ query
{x, y | µQ(ϕ(Q))(x, y, 0)}
where
ϕ(Q) =
[¬Q(1, 1, 1) ∧ [(G(x, y) ∧ z = 0) ∨ (x = 1 ∧ y = 1 ∧ z = 1)]]
∨
[Q(1, 1, 1) ∧ [(x = 1 ∧ y = 1 ∧ z = 1) ∨
((z = ((z = 0) ∧ Q(x, y, 0) ∧ ¬∃w(Q(x, w, 0) ∧ Q(w, y, 0))) ∨
((z = ((z = 0) ∧ ∃w(¬Q(x, w, 0) ∧ ¬Q(w, x, 0) ∧
¬Q(y, w, 0) ∧ ¬Q(w, y, 0)))]].

Clearly, this query is more awkward than its counterpart in while. The simulation highlights some peculiarities of computing with CALC+µ.

In Section 14.4 it is shown that the family of partial fixpoint queries is equivalent to the while queries. In the preceding definition of µT (ϕ(T )), the scope of all free variables in ϕ is defined by µT . For example, if T is binary in the following
∃y(P (y) ∧ µT (ϕ(T , x, y))(z, w)),
then ϕ(T , x, y) has free variables x, y. According to the definition, y is not free in µT (ϕ(T , x, y))(z, w) (the free variables are z, w). Hence the quantifier ∃y applies to the y in P (y) alone and has no relation to the y in µT (ϕ(T , x, y))(z, w). To avoid confusion, it is preferable to use distinct variable names in such cases. For instance, the preceding
14.2 Calculus + Fixpoint
351
sentence can be rewritten as
∃y(P (y) ∧ µT (ϕ(T , x′, y′))(z, w)).

A variant of the fixpoint operator can be developed that permits free variables under the fixpoint operator, but this does not increase the expressive power (see Exercise 14.11).

Simultaneous Induction
Consider the following use of nested partial fixpoint operators, where G, P , and Q are binary:
µP (G(x, y) ∧ µQ(ϕ(P , Q))(x, y)).

Here ϕ(P , Q) involves both P and Q. This corresponds to a nested iteration. In each iteration i in the computation of {Jn}n≥0 over P , the fixpoint µQ(ϕ(P , Q)) is recomputed for the successive values Ji of P .

In contrast, we now consider a generalization of the partial fixpoint that permits simultaneous iteration over two or more relations. For example, let R be a database schema and ϕ(P , Q) and ψ(P , Q) be calculus formulas using P and Q not in R, such that the arity of P (respectively Q) is the number of free variables in ϕ (ψ). On input I over R, one can define inductively the sequence {Jn}n≥0 of relations over {P , Q} as follows: J0(P ) = ∅
J0(Q) = ∅
Jn(P ) = ϕ(Jn−1(P ), Jn−1(Q))
Jn(Q) = ψ(Jn−1(P ), Jn−1(Q)).

Such a mutually recursive definition of Jn(P ) and Jn(Q) is referred to as simultaneous induction. If the sequence {Jn(P ), Jn(Q)}n≥0 converges, the limit is a fixpoint of the mapping on pairs of relations defined by ϕ(P , Q) and ψ(P , Q). This pair of values for P and Q is denoted by µP,Q(ϕ(P , Q), ψ(P , Q)), and µP,Q is a simultaneous induction partial fixpoint operator. The value for P in µP,Q is denoted by µP,Q(ϕ(P , Q), ψ(P , Q))(P ) and the value for Q by µP,Q(ϕ(P , Q), ψ(P , Q))(Q). Clearly, simultaneous induction definitions like the foregoing can be extended for any number of relations. Simultaneous induction can simplify certain queries, as shown next.

Example 14.2.4 (Add-Remove by Simultaneous Induction)
Consider again the
query Add-Remove in Example 14.2.3. One can simplify the query by introducing an auxiliary unary relation Off , which inhibits the transfer of G into T after the first step in a direct fashion. T and Off are defined in a mutually recursive fashion by ϕ Off and ϕT , respectively:
352
Recursion and Negation
ϕ Off (x) = x = 1
ϕT (x, y) = [¬ Off (1) ∧ G(x, y)]
∨ [ Off (1) ∧ ¬∃z(T (x, z) ∧ T (z, y)) ∧
(T (x, y) ∨ ∃z(¬T (x, z) ∧ ¬T (z, x) ∧ ¬T (y, z) ∧ ¬T (z, y))].

The Add-Remove query can now be written as
{x, y | µ Off ,T (ϕ Off ( Off , T ), ϕT ( Off , T ))(T )(x, y)}.

It turns out that using simultaneous induction instead of regular fixpoint operators does not provide additional power. For example, a CALC+µ formula equivalent to the query in Example 14.2.4 is the one shown in Example 14.2.3. More generally, we have the following:
Lemma 14.2.5
For some n, let ϕi(R1, . . . , Rn) be CALC formulas, i in [1..n], such that µR
(ϕ
1,...,Rn
1(R1, . . . , Rn), . . . , ϕn(R1, . . . , Rn)) is a correct formula. Then for each i ∈ [1, n] there exist CALC formulas ϕ′(Q) and tuples !

e
i
i of variables or constants such
that for each i,
µR
(ϕ
1,...,Rn
1(R1, . . . , Rn), . . . , ϕn(R1, . . . , Rn))(Ri) ≡ µQ(ϕ′i(Q))( !

ei).

Crux
We illustrate the construction with reference to the query of Example 14.2.4. Instead of using two relations Off and T , we use a ternary relation Q that encodes both Off and T . The extra coordinate is used to distinguish between tuples in T and tuples in Off .

A tuple x in Off is encoded as a tuple x, 1, 1 in Q. A tuple x, y in T is encoded as a tuple x, y, 0 in Q. The final result is obtained by selecting from Q the tuples where the third coordinate is 0 and projecting the result on the first two coordinates.

Note that the use of the tuples !

ei allows one to perform appropriate selections and
projections on µQ(ϕ′(Q)) necessary for decoding. These selections and projections are i
essential and cannot be avoided (see Exercise 14.17c).

Inflationary Fixpoint
The nonconvergence in some cases of the sequence {Jn}n≥0 in the semantics of the partial fixpoint operator is similar to nonterminating computations in the while language with noninflationary semantics. The semantics of the partial fixpoint operator µ is essentially noninflationary because in the inductive definition of Jn, each step is a destructive assignment. As with while, we can make the semantics inflationary by having the assignment at each step of the induction be cumulative. This yields an inflationary version of µ, denoted by µ+ and called the inflationary fixpoint operator, which is defined for all formulas and databases to which it is applied.

14.2 Calculus + Fixpoint
353
Inflationary Fixpoint Operators and Logic
The definition of µ+(ϕ(T )) is identical to
T
that of the partial fixpoint operator except that the sequence {Jn}n≥0 is defined as follows: J0 = ∅;
Jn = Jn−1 ∪ ϕ(Jn−1),
n > 0.

This definition ensures that the sequence {Jn}n≥0 is increasing: Ji−1 ⊆ Ji for each i > 0.

Because for each instance there are finitely many tuples that can be added, the sequence converges in all cases.

Adding µ+ instead of µ to CALC yields inflationary fixpoint logic, denoted by CALC+µ+. Note that inflationary fixpoint queries are always defined.

The set of queries expressible by inflationary fixpoint logic is called the fixpoint queries. The fixpoint queries were historically defined first among the inflationary languages in the algebraic, logic, and deductive paradigms. Therefore the class of queries expressible in inflationary languages in the three paradigms has come to be referred to as the fixpoint queries.

As a simple example, the transitive closure of a graph G is defined by the following CALC+µ+ query:
{x, y | µ+(G(x, y) ∨ ∃z(T (x, z) ∧ G(z, y))(x, y)}.

T
Recall that datalog as presented in Chapter 12 uses an inflationary operator and yields the minimal fixpoint of a set of rules. One may also be tempted to assume that an inflationary simultaneous induction of the form µ+ (ϕ(P , Q), ψ(P , Q)) is equivalent to a system P ,Q
of equational definitions of the form
P = ϕ(P , Q)
Q = ψ (P , Q)
and that it computes the unique minimal fixpoint for P and Q. However, one should be careful because the result of the inflationary fixpoint computation is only one of the possible fixpoints. As illustrated in the following example, this may not be minimal or the “naturally” expected fixpoint. (There may not exist a unique minimal fixpoint; see Exercise 14.4.)

Example 14.2.6
Consider the equation
T (x, y)
= G(x, y) ∨ T (x, y) ∨ ∃z(T (x, z) ∧ G(z, y))
CT (x, y) = ¬T (x, y).

One is tempted to believe that the fixpoint of these two equations yields the complement of transitive closure. However, with the inflationary semantics
354
Recursion and Negation
J0(T ) = ∅
J0(CT ) = ∅
Jn(T ) = Jn−1(T ) ∪ {x, y | G(x, y) ∨ Jn−1(T )(x, y)
∨ ∃z(Jn−1(T )(x, z) ∧ G(z, y))}
Jn(CT ) = Jn−1(CT ) ∪ {x, y | ¬Jn−1(T )(x, y)}
leads to saturating CT at the first iteration.

Positive and Monotone Formulas
Making the fixpoint operator inflationary by definition is not the only way to guarantee polynomial-time termination of the fixpoint iteration. An alternative approach is to restrict the formulas ϕ(T ) so that convergence of the sequence {Jn}n≥0 associated with µT (ϕ(T )) is guaranteed. One such restriction is monotonicity. Recall that a query q is monotone if for each I, J, I ⊆ J then q(I) ⊆ q(J). One can again show that for such formulas, a least fixpoint always exists and that it is obtained after a finite (but unbounded) number of stages of inductive applications of the formula.

Unfortunately, monotonicity is an undecidable property for CALC. One can also restrict the application of fixpoint to positive formulas. This was historically the first track that was followed and presents the advantage that positiveness is a decidable (syntactic) property. It is done by requiring that T occur only positively in ϕ(T ) (i.e., under an even number of negations in the syntax tree of the formula). All formulas thereby obtained are monotone, and so µT (ϕ(T )) is always defined (see Exercise 14.10).

It can be shown that the approach of inflationary fixpoint and the two approaches based on fixpoint of positive or monotone formulas are equivalent (i.e., the sets of queries expressed are identical; see Exercise 14.10).

Fixpoint Operators and Circumscription
In some sense, the fixpoint operators act as quantifiers on relational variables. This is somewhat similar to the well-known technique of circumscription studied in artificial intelligence. Suppose ψ(T ) is a calculus sentence (i.e., no free variables) that uses T in addition to relations from a database schema R. The circumscription of ψ(T ) with respect to T , denoted here by circ T (ψ(T )), can be thought of as an operator defining a new relation, starting from the database. More precisely, let I be an instance over R. Then circ T (ψ(T )) denotes the relation containing all tuples belonging to every relation T such that (1) ψ(T ) holds for I, and (2) T is minimal under set inclusion2 with this property. Consider now a fixpoint query. As stated earlier, fixpoint queries can be expressed using just fixpoint operators µT applied to formulas positive in T (i.e., T always appears in ϕ under an even number of negations). We claim that µT (ϕ(T )) = circ T (ϕ′(T )), where ϕ′(T ) is a sentence 2 Other kinds of minimality have also been considered.

14.3 Datalog with Negation
355
obtained from ϕ(T ) as follows:
ϕ′(T ) = ∀x1, . . . ∀xn(ϕ(T , x1, . . . , xn) → T (x1, . . . , xn)), where the arity of T is n. To see this, it is sufficient to note that µT (ϕ(T )) is the unique minimal T satisfying ϕ′(T ). This uses the monotonicity of ϕ(T ) with respect to T , which follows from the fact that ϕ(T ) is positive in T (see Exercise 14.10). Although computing with circumscription is generally intractable, the fixpoint operator on positive formulas can always be evaluated in polynomial time. Thus the fixpoint operator can be viewed as a tractable restriction of circumscription.

14.3
Datalog with Negation
Datalog provides recursion but no negation. It defines only monotonic queries. Viewed from the standpoint of the deductive paradigm, datalog provides a form of monotonic reasoning. Adding negation to datalog rules permits the specification of nonmonotonic queries and hence of nonmonotonic reasoning.

Adding negation to datalog rules requires defining semantics for negative facts. This can be done in many ways. The different definitions depend to some extent on whether datalog is viewed in the deductive framework or simply as a specification formalism like any other query language. In this chapter, we examine the latter point of view. Then datalog with negation can essentially be viewed as a subset of the while or fixpoint queries and can be treated similarly. This is not necessarily appropriate in the deductive framework.

For instance, the basic assumptions in the reasoning process may require that once a fact is assumed false at some point in the inferencing process, it should not be proven true at a later point. This idea lies at the core of stratified and well-founded semantics, two of the most widely accepted in the deductive framework. The deductive point of view is considered in depth in Chapter 15.

The semantics given here for datalog with negation follows the semantics given in Chapter 12 for datalog, but does not correspond directly to the semantics for nonrecursive datalog¬ given in Chapter 5. The semantics in Chapter 5 is inspired by the stratified semantics but can be simulated by (either of) the semantics presented in this chapter.

As in the previous section, we consider both inflationary and noninflationary versions of datalog with negation.

Inflationary Semantics
The inflationary language allows negations in bodies of rules and is denoted by datalog¬.

Like datalog, its rules are used to infer a set of facts. Once a fact is inferred, it is never removed from the set of true facts. This yields the inflationary character of the language.

Example 14.3.1
We present a datalog¬ program with input a graph in binary re-
lation G. The program computes the relation closer(x, y, x′, y′) defined as follows:
356
Recursion and Negation
closer(x, y, x′, y′) means that the distance d(x, y) from x to y in G is smaller than the distance d(x′, y′) from x′ to y′ [d(x, y) is infinite if there is no path from x to y].

T (x, y)
← G(x, y)
T (x, y)
← T (x, z), G(z, y)
closer(x, y, x′, y′) ← T (x, y), ¬T (x′, y′)
The program is evaluated as follows. The rules are fired simultaneously with all applicable valuations. At each such firing, some facts are inferred. This is repeated until no new facts can be inferred. A negative fact such as ¬T (x′, y′) is true if T (x′, y′) has not been inferred so far. This does not preclude T (x′, y′) from being inferred at a later firing of the rules.

One firing of the rules is called a stage in the evaluation of the program. In the preceding program, the transitive closure of G is computed in T . Consider the consecutive stages in the evaluation of the program. Note that if the fact T (x, y) is inferred at stage n, then d(x, y) = n. So if T (x′, y′) has not been inferred yet, this means that the distance between x and y is less than that between x′ and y′. Thus if T (x, y) and ¬T (x′, y′) hold at some stage n, then d(x, y) ≤ n and d(x′, y′) > n and closer(x, y, x′, y′) is inferred.

The formal syntax and semantics of datalog¬ are straightforward extensions of those for datalog. A datalog¬ rule is an expression of the form
A ← L1, . . . , Ln,
where A is an atom and each Li is either an atom Bi (in which case it is called positive) or a negated atom ¬Bi (in which case it is called negative). (In this chapter we use an active domain semantics for evaluating datalog¬ and so do not require that the rules be range restricted; see Exercise 14.13.)

A datalog¬ program is a nonempty finite set of datalog¬ rules. As for datalog programs, sch(P ) denotes the database schema consisting of all relations involved in the program P ; the relations occurring in heads of rules are the idb relations of P , and the others are the edb relations of P .

The semantics of datalog¬ that we present in this chapter is an extension of the fixpoint semantics of datalog. Let K be an instance over sch(P ). Recall that an (active domain) instantiation of a rule A ← L1, . . . , Ln is a rule ν(A) ← ν(L1), . . . , ν(Ln), where ν is a valuation that maps each variable into adom(P , K). A fact A′ is an immediate consequence for K and P if A′ ∈ K(R) for some edb relation R, or A′ ← L′ , . . . , L′ is an instantiation 1
n
of a rule in P and each positive L′ is a fact in K, and for each negative L′ = ¬A′ , A′ ∈
i
i
i
i
K. The immediate consequence operator of P , denoted ŴP , is now defined as follows. For each K over sch(P ),
ŴP (K) = K ∪ {A | A is an immediate consequence for K and P }.

Given an instance I over edb(P ), one can compute ŴP (I), Ŵ2 (I), Ŵ3 (I), etc. As suggested P
P
in Example 14.3.1, each application of ŴP is called a stage in the evaluation. From the
14.3 Datalog with Negation
357
definition of ŴP , it follows that
ŴP (I) ⊆ Ŵ2P (I) ⊆ Ŵ3 (I) ⊆ . . . .

P
As for datalog, the sequence reaches a fixpoint, denoted Ŵ∞(I), after a finite number of P
steps. The restriction of this to the idb relations (or some subset thereof) is called the image (or answer) of P on I.

An important difference with datalog is that Ŵ∞(I) is no longer guaranteed to be a P
minimal model of P containing I, as illustrated next.

Example 14.3.2
Let P be the program
R(0) ← Q(0), ¬R(1)
R(1) ← Q(0), ¬R(0).

Let I = {Q(0)}. Then P (I) = {Q(0), R(0), R(1)}. Although P (I) is a model of P , it is not minimal. The minimal models containing I are {Q(0), R(0)} and {Q(0), R(1)}.

As discussed in Chapter 12, the operational semantics of datalog based on the immediate consequence operator is equivalent to the natural semantics based on minimal models. As shown in the preceding example, there may not be a unique minimal model for a datalog¬ program, and the semantics given for datalog¬ may not yield any of the minimal models. The development of a natural model-theoretic semantics for datalog¬ thus calls for selecting a natural model from among several possible candidates. Inevitably, such choices are open to debate; Chapter 15 presents several alternatives.

Noninflationary Semantics
The language datalog¬ has inflationary semantics because the set of facts inferred through the consecutive firings of the rules is increasing. To obtain a noninflationary variant, there are several possibilities. One could keep the syntax of datalog¬ but make the semantics noninflationary by retaining, at each stage, only the newly inferred facts (see Exercise 14.16). Another possibility is to allow explicit retraction of a previously inferred fact.

Syntactically, this can be done using negations in heads of rules, interpreted as deletions of facts. We adopt this solution here, in part because it brings our language closer to some practical languages that use so-called (production) rules in the sense of expert and active database systems. The resulting language is denoted by datalog¬¬, to indicate that negations are allowed in both heads and bodies of rules.

Example 14.3.3 (Add-Remove Visited Again)
The following datalog¬¬ program
computes in T the Add-Remove query of Example 14.1.2, given as input a graph G.

358
Recursion and Negation
T (x, y)
← G(x, y), ¬ off (1)
off (1)
←
¬T (x, y) ← T (x, z), T (z, y), off (1)
T (x, y)
← ¬T (x, z), ¬T (z, x), ¬T (y, z), ¬T (z, y), off (1)
Relation off is used to inhibit the first rule (initializing T to G) after the first step.

The immediate consequence operator ŴP and semantics of a datalog¬¬ program are analogous to those for datalog¬, with the following important proviso. If a negative literal
¬A is inferred, the fact A is removed, unless A is also inferred in the same firing of the rules. This gives priority to inference of positive over negative facts and is somewhat arbitrary. Other possibilities are as follows: (1) Give priority to negative facts; (2) interpret the simultaneous inference of A and ¬A as a “no-op” (i.e., including A in the new instance only if it is there in the old one); and (3) interpret the simultaneous inference of A and
¬A as a contradiction that makes the result undefined. The chosen semantics has the advantage over possibility (3) that the semantics is always defined. In any case, the choice of semantics is not crucial: They yield equivalent languages (see Exercise 14.15).

With the semantics chosen previously, termination is no longer guaranteed. For instance, the program
T (0)
← T (1)
¬T (1) ← T (1)
T (1)
← T (0)
¬T (0) ← T (0)
never terminates on input T (0). The value of T flip-flops between {0} and {1}, so no fixpoint is reached.

Datalog¬¬ and Datalog¬ as Fragments of CALC+µ and CALC+µ+
Consider datalog¬¬. It can be viewed as a subset of CALC+µ in the following manner.

Suppose that P is a datalog¬¬ program. The idb relations defined by rules can alternately be defined by simultaneous induction using formulas that correspond to the rules. Each firing of the rules corresponds to one step in the simultaneous inductive definition. For instance, the simultaneous induction definition corresponding to the program in Example 14.3.3 is the one in Example 14.2.4. Because simultaneous induction can be simulated in CALC+µ
(see Lemma 14.2.5), datalog¬¬ can be simulated in CALC+µ. Moreover, notice that only a single application of the fixpoint operator is used in the simulation. Similar remarks apply to datalog¬ and CALC+µ+. Furthermore, in the inflationary case it is easy to see that the formula can be chosen to be existential (i.e., its prenex normal form3 uses only existential 3 A CALC formula in prenex normal form is a formula Q1x1 . . . Qkxkϕ where Qi, 1 ≤ i ≤ k are quantifiers and ϕ is quantifier free.

14.3 Datalog with Negation
359
quantifiers). The same can be shown in the noninflationary case, although the proof is more subtle. In summary (see Exercise 14.18), the following applies:
Lemma 14.3.4 Each datalog¬¬ (datalog¬) query is equivalent to a CALC+µ (CALC+µ+) query of the form
{ !

x | µ(+)(ϕ(T ))(!t)},
T
where
(a) ϕ is an existential CALC formula, and
(b) !t is a tuple of variables or constants of appropriate arity and !

x is the tuple of
distinct free variables in !t.

The Rule Algebra
The examples of datalog¬ programs shown in this chapter make it clear that the semantics of such programs is not always easy to understand. There is a simple mechanism that facilitates the specification by the user of various customized semantics. This is done by means of the rule algebra, which allows specification of an order of firing of the rules as well as firing up to a fixpoint in an inflationary or noninflationary manner. For the inflationary version RA+ of the rule algebra, the base expressions are individual datalog¬
rules; the semantics associated with a rule is to apply its immediate consequence operator once in a cumulative fashion. Union (∪) can be used to specify simultaneous application of a pair of rules or more complex programs. The expression P ; Q specifies the composition of P and Q; its semantics is to execute P once and then Q once. Inflationary iteration of program P is called for by (P )+. The noninflationary version of the rule algebra, denoted RA, starts with datalog¬ rules, but now with a noninflationary, destructive semantics, as defined in Exercise 14.16. Union and composition are generalized in the natural fashion, and the noninflationary iterator, denoted ∗, is used.

Example 14.3.5
Let P be the set of rules
T (x, y) ← G(x, y)
T (x, y) ← T (x, z), G(z, y)
and let Q consist of the rule
CT (x, y) ← ¬T (x, y).

The RA+ program (P )+; Q computes in CT the complement of the transitive closure of G.

It follows easily from the results of Section 14.4 that RA+ is equivalent to datalog¬, and RA is equivalent to noninflationary datalog¬ and hence to datalog¬¬ (Exercise 14.23).

Thus an RA+ program can be compiled into a (possibly much more complicated) datalog¬
360
Recursion and Negation
program. For instance, the RA+ program in Example 14.3.5 is equivalent to the datalog¬
program in Example 14.4.2. The advantage of the rule algebra is the ease of expressing various semantics. In particular, RA+ can be used easily to specify the stratified and well-founded semantics for datalog¬ introduced in Chapter 15.

14.4
Equivalence
The previous sections introduced inflationary and noninflationary recursive languages with negation in the algebraic, logic, and deductive paradigms. This section shows that the inflationary languages in the three paradigms, while+, CALC+µ+, and datalog¬, are equivalent and that the same holds for the noninflationary languages while, CALC+µ, and datalog¬¬.

This yields two classes of queries that are central in the theory of query languages: the fixpoint queries (expressed by the inflationary languages) and the while queries (expressed by the noninflationary languages). This is summarized in Fig. 14.2, at the end of the chapter.

We begin with the equivalence of the inflationary languages because it is the more difficult to show. The equivalence of CALC+µ+ and while+ is easy because the languages have similar capabilities: Program composition in while+ corresponds closely to formula composition in CALC+µ+, and the while change loop of while+ is close to the inflationary fixpoint operator of CALC+µ+. More difficult and surprising is the equivalence of these languages with datalog¬, because this much simpler language has no explicit constructs for program composition or nested recursion.

Lemma 14.4.1
CALC+µ+ and while+ are equivalent.

Proof We consider first the simulation of CALC+µ+ queries by while+. Let {x1,. . . ,xm |
ξ(x1,. . . ,xm)} be a CALC+µ+ query over an input database with schema R. It suffices to show that there exists a while+ program Pξ that defines the same result as ξ(x1, . . . , xm) in some m-ary relation Rξ . The proof is by induction on the depth of nesting of the fixpoint operator in ξ , denoted d(ξ ). If d(ξ ) = 0 (i.e., ξ does not contain a fixpoint operator), then ξ is in CALC and Pξ is
Rξ += Eξ ,
where Eξ is the relational algebra expression corresponding to ξ . Now suppose the statement is true for formulas with depth of nesting of the fixpoint operator less than d(d > 0).

Let ξ be a formula with d(ξ ) = d.

If ξ = µQ(ϕ(Q))(f1, . . . , fk), then Pξ is
Q += ∅;
while change do
begin
Eϕ;
Q += Rϕ
end;
Rξ += π(σ (Q)),
14.4 Equivalence
361
where π(σ (Q)) denotes the selection and projection corresponding to f1, . . . , fk.

Suppose now that ξ is obtained by first-order operations from k formulas ξ1, . . . , ξk, each having µ+ as root. Let Eξ (Rξ , . . . , R ) be the relational algebra expression corre-1
ξk
sponding to ξ , where each subformula ξi = µQ(ϕ(Q))(ei , . . . , ei ) is replaced by R . For 1
n
ξ
i
i
each i, let Pξ be a program that produces the value of µ
, . . . , ei ) and places
i
Q(ϕ(Q))(ei1
ni
it into Rξ . Then P
i
ξ is
Pξ ; . . . ; P ;
1
ξk
Rξ += Eξ (Rξ , . . . , R ).

1
ξk
This completes the induction and the proof that CALC+µ+ can be simulated by while+.

The converse simulation is similar (Exercise 14.20).

We now turn to the equivalence of CALC+µ+ and datalog¬. Lemma 14.3.4 yields the subsumption of datalog¬ by CALC+µ+. For the other direction, we simulate CALC+µ+
queries using datalog¬. This simulation presents two main difficulties.

The first involves delaying the firing of a rule until after the completion of a fixpoint by another set of rules. Intuitively, this is hard because checking that the fixpoint has been reached involves checking the nonexistence rather than the existence of some valuation, and datalog¬ is more naturally geared toward checking the existence of valuations. The solution to this difficulty is illustrated in the following example.

Example 14.4.2
The following datalog¬ program computes the complement of the tran-
sitive closure of a graph G. The example illustrates the technique used to delay the firing of a rule (computing the complement) until the fixpoint of a set of rules (computing the transitive closure) has been reached (i.e., until the application of the transitivity rule yields no new tuples). To monitor this, the relations old-T , old-T - except- final are used. old-T
follows the computation of T but is one step behind it. The relation old-T - except- final is identical to old-T but the rule defining it includes a clause that prevents it from firing when T has reached its last iteration. Thus old-T and old-T - except- final differ only in the iteration after the transitive closure T reaches its final value. In the subsequent iteration, the program recognizes that the fixpoint has been reached and fires the rule computing the complement in relation CT . The program is
T (x, y)
← G(x, y)
T (x, y)
← G(x, z), T (z, y)
old-T (x, y)
← T (x, y)
old-T - except- final(x, y) ← T (x, y), T (x′, z′), T (z′, y′), ¬T (x′, y′) CT (x, y)
← ¬T (x, y), old-T (x′, y′),
¬ old-T - except- final(x′, y′)
(It is assumed that G is not empty; see Exercise 14.3.)

362
Recursion and Negation
The second difficulty concerns keeping track of iterations in the computation of a fixpoint. Given a formula µ+(ϕ(T )), the simulation of ϕ itself may involve numerous re-T
lations other than T , whose behavior may be “sabotaged” by an overly zealous application of iteration of the immediate consequence operator. To overcome this, we separate the internal computation of ϕ from the external iteration over T , as illustrated in the following example.

Example 14.4.3
Let G be a binary relation schema. Consider the CALC+µ+ query
µ+
(φ ( good))(x), where
good
φ = ∀y (G(y, x) → good(y)).

Note that the query computes the set of nodes in G that are not reachable from a cycle (in other words, the nodes such that the length of paths leading to them is bounded). One application of ϕ( good) is achieved by the datalog¬ program P : bad(x) ← G(y, x), ¬ good(y)
delay
←
good(x) ← delay, ¬ bad(x)
Simply iterating P does not yield the desired result. Intuitively, the relations delay and bad, which are used as “scratch paper” in the computation of a single iteration of µ+, cannot be reinitialized and so cannot be reused to perform the computation of subsequent iterations.

To surmount this problem, we essentially create a version of P for each iteration of ϕ( good). The versions are distinguished by using “timestamps.” The nodes themselves serve as timestamps. The timestamps marking iteration i are the values newly introduced in relation good at iteration i − 1. Relations delay and delay-stamped are used to delay the derivation of new tuples in good until bad and bad-stamped (respectively) have been computed in the current iteration. The process continues until no new values are introduced in an iteration. The full program is the union of the three rules given earlier, which perform the first iteration, and the following rules, which perform the iteration with timestamp t: bad-stamped(x, t ) ← G(y, x), ¬ good(y), good(t ) delay-stamped(t ) ← good(t )
good(x)
← delay-stamped(t), ¬ bad-stamped(x, t).

We now embark on the formal demonstration that datalog¬ can simulate CALC+µ+.

We first introduce some notation relating to the timestamping of a program in the simulation. Let m ≥ 1. For each relation schema Q, let Q be a new relational schema with arity(Q) = arity(Q) + m. If (¬)Q(e1, . . . , en) is a literal and !z an m-tuple of distinct variables, then (¬)Q(e1, . . . , en)[!z] denotes the literal (¬)Q(e1, . . . , en, z1, . . . , zm). For each program P and tuple !z, P [!z] denotes the program obtained from P by replacing each literal A by A[!

z]. Let P be a program and B1, . . . , Bq a list of literals. Then P // B1, . . . , Bq is the program obtained by appending B1, . . . , Bq to the bodies of all rules in P .

14.4 Equivalence
363
To illustrate the previous notation, consider the program P consisting of the following two rules:
S(x, y) ← R(x, y)
S(x, y) ← R(x, z), S(z, y).

Then P [z] // ¬T (x, w, y) is
S(x, y, z) ← R(x, y, z), ¬T (x, w, y)
S(x, y, z) ← R(x, z, z), S(z, y, z), ¬T (x, w, y).

Lemma 14.4.4
CALC+µ+ and datalog¬ are equivalent.

Proof
As seen in Lemma 14.3.4, datalog¬ is essentially a fragment of CALC+µ+, so we just need to show the simulation of CALC+µ+ by datalog¬. The proof is by structural induction on the CALC+µ+ formula. The core of the proof involves a control mechanism that delays firing certain rules until other rules have been evaluated. Therefore the induction hypothesis involves the capability to simulate the CALC+µ+ formula using a datalog¬
program as well as to produce concomitantly a predicate that only becomes true when the simulation has been completed. More precisely, we will prove by induction the following: For each CALC+µ+ formula ϕ over a database schema R, there exists a datalog¬ program prog(ϕ) whose edb relations are the relations in R, whose idb relations include result ϕ
with arity equal to the number of free variables in ϕ and a 0-ary relation done ϕ such that for every instance I over R,
(i) [ prog(ϕ)(I)]( result ϕ) = ϕ(I), and (ii) the 0-ary predicate done ϕ becomes true at the last stage in the evaluation of prog(ϕ) on I.

We will assume, without loss of generality, that no variable of ϕ occurs free and bound, or bound to more than one quantifier, that ϕ contains no ∀ or ∨, and that the initial query has the form {x1, . . . , xn | ξ }, where x1, . . . , xn are distinct variables. Note that the last assumption implies that (i) establishes the desired result.

Suppose now that ϕ is an atom R(!e). Let !

x be the tuple of distinct variables occurring
in !e. Then prog(ϕ) consists of the rules
done ϕ
←
result ϕ(!

x) ← R(!

e).

There are four cases to consider for the induction step.

1. ϕ = α ∧ β. Without loss of generality, we assume that the idb relations of prog(α) and prog(β) are disjoint. Thus there is no interference between prog(α) and prog(β). Let !

x and !

y be the tuples of distinct free variables of α and β, re-
spectively, and let !z be the tuple of distinct free variables occurring in !

x or !

y.

364
Recursion and Negation
Then prog(ϕ) consists of the following rules:
prog(α)
prog(β)
result ϕ(!z) ← done α, done β, result α(!

x), result β(!

y)
done ϕ
← done α, done β.

2. ϕ = ∃ x(ψ). Let !

y be the tuple of distinct free variables of ψ, and let !

z be the tuple
obtained from !

y by removing the variable x. Then prog(ϕ) consists of the rules prog(ψ)
result ϕ(!z) ← done ψ, result ψ(!

y)
done ϕ
← done ψ.

3. ϕ = ¬(ψ). Let !

x be the tuple of distinct free variables occurring in ψ. Then
prog(ϕ) consists of
prog(ψ)
result ϕ(!

x) ← done ψ, ¬ result ψ(!

x)
done ϕ
← done ψ.

4. ϕ = µS(ψ(S))(!e). This case is the most involved, because it requires keeping track of the iterations in the computation of the fixpoint as well as bookkeeping to control the value of the special predicate done ϕ. Intuitively, each iteration is marked by timestamps. The current timestamps consist of the tuples newly inserted in the previous iteration. The program prog(ϕ) uses the following new auxiliary relations:
Relation fixpoint ϕ contains µS(ψ(S)) at the end of the computation, and result ϕ contains µS(ψ(S))(!e).

Relation run ϕ contains the timestamps.

Relation used ϕ contains the timestamps introduced in the previous stages of the iteration. The active timestamps are in run ϕ − used ϕ.

Relation not- final ϕ is used to detect the final iteration (i.e., the iteration that adds no new tuples to fixpoint ϕ). The presence of a timestamp in used ϕ −
not - final ϕ indicates that the final iteration has been completed.

Relations delay ϕ and not- empty ϕ are used for timing and to detect an empty result.

In the following, !

y and !t are tuples of distinct variables with the same arity as S. We first have particular rules to perform the first iteration and to handle the special case of an empty result:
14.4 Equivalence
365
prog(ψ)
fixpoint ϕ(!y) ← result ψ(!y), done ψ
delay
←
ϕ
done ψ
not-empty
←
ϕ
result ψ(!

y)
done ϕ
← delay ϕ, ¬ not-empty ϕ.

The remainder of the program contains the following rules:
• Stamping of the database and starting an iteration: For each R in ψ different from S
and a tuple !

x of distinct variables with same arity as R,
R(!

x, !t) ← R(!

x), fixpoint ϕ(!t)
run ϕ(!t) ← fixpoint ϕ(!t)
S(!

y, !t) ← fixpoint ϕ(!y), fixpoint ϕ(!t).

• Timestamped iteration:
prog(ψ)[!t]// run ϕ(!t), ¬ used ϕ(!t)
• Maintain fixpoint ϕ, not-last ϕ, and used ϕ: fixpoint ϕ(!y) ← done ψ(!t), result ψ(!y, !t), ¬ used ϕ(!t) not-final ϕ(!t) ← done ψ(!t), result ψ(!y, !t), ¬ fixpoint ϕ(!y) used ϕ(!t)
← done ψ(!t)
• Produce the result and detect termination:
result ϕ(!z) ← fixpoint ϕ(!e)
where !z is the tuple of distinct variables in !e,
done ϕ ← used ϕ(!t), ¬ not- final ϕ(!t).

It is easily verified by inspection that prog(ϕ) satisfies (i) and (ii) under the induction hypothesis for cases (1) through (3). To see that (i) and (ii) hold in case (4), we carefully consider the stages in the evaluation of prog ϕ. Let I be an instance over the relations in ψ other than S; let J0 = ∅ be over S; and let Ji = Ji−1 ∪ ψ(Ji−1) for each i > 0.

Then µS(ψ(S))(I) = Jn for some n such that Jn = Jn−1. The program prog ϕ simulates the consecutive iterations of this process. The first iteration is simulated using prog ψ directly, whereas the subsequent iterations are simulated by prog ψ timestamped with the tuples added at the previous iteration. (We omit consideration of the case in which the fixpoint is ∅; this is taken care of by the rules involving delay ϕ and not- empty ϕ.)

366
Recursion and Negation
We focus on the stages in the evaluation of prog ϕ corresponding to the end of the simulation of each iteration of ψ. The stage in which the simulation of the first iteration is completed immediately follows the stage in which done ψ becomes true. The subsequent iterations are completed immediately following the stages in which
∃!t( done ψ(!t) ∧ ¬ used ϕ(!t))
becomes true. Thus let k1 be the stage in which done ψ becomes true, and let ki (2 < i ≤ n) be the successive stages in which
∃!t( done ψ(!t) ∧ ¬ used ϕ(!t))
is true. First note that
• at stage k1
{!

y | result ψ(!

y)} = ψ (J0);
• at stage k1 + 1
fixpoint =
ϕ
J1.

For i > 1 it can be shown by induction on i that
• at stage ki (i ≤ n)
{ !t | done ψ(!t) ∧ ¬ used ϕ(!t)} = ψ(Ji−2) − Ji−2 = Ji−1 − Ji−2
{ !

y | done ψ(!t) ∧ result ψ(!

y, !t) ∧ ¬ used ϕ(!t)} = ψ(Ji−1);
{ !t | done ψ(!t) ∧ result ψ(!y, !t) ∧ ¬ fixpoint ϕ(!y)} = ψ(Ji−1) − Ji−1 = Ji − Ji−1;
• at stage ki + 1 (i < n)
fixpoint =
ϕ
Ji−1 ∪ ψ(Ji−1) = Ji,
used ϕ = not-last ϕ = done ψ = Ji−1;
• at stage ki + 2 (i < n)
{ !t | run ϕ(!t) ∧ ¬ used ϕ(!t)} = Ji − Ji−1,
{ !

x | R(!

x, !t) ∧ run ϕ(!t) ∧ ¬ used ϕ(!t)} = I(R),
{ !

x | S(!

x, !t) ∧ run ϕ(!t) ∧ ¬ used ϕ(!t)} = Ji.

Finally, at stage kn + 1
used ϕ = Jn−1,
14.4 Equivalence
367
not-last ϕ = Jn−2,
fixpoint =
ϕ
Jn = µS(ψ(S))(I),
and at stage kn + 2
result ϕ = µS(ψ(S))(!z)(I),
done ϕ = true.

Thus (i) and (ii) hold for prog ϕ in case (4), which concludes the induction.

Lemmas 14.4.1 and 14.4.4 now yield the following:
Theorem 14.4.5
while+, CALC+µ+, and datalog¬ are equivalent.

The set of queries expressible in while+, CALC+µ+, and datalog¬ is called the fixpoint queries. An analogous equivalence result can be proven for the noninflationary languages while, CALC+µ, and datalog¬¬. The proof of the equivalence of CALC+µ and datalog¬¬
is easier than in the inflationary case because the ability to perform deletions in datalog¬¬
facilitates the task of simulating explicit control (see Exercise 14.21). Thus we can prove the following:
Theorem 14.4.6
while, CALC+µ, and datalog¬¬ are equivalent.

The set of queries expressible in while, CALC+µ, and datalog¬¬ is called the while queries. We will look at the fixpoint queries and the while queries from a complexity and expressiveness standpoint in Chapter 17. Although the spirit of our discussion in this chapter suggested that fixpoint and while are distinct classes of queries, this is far from obvious. In fact, the question remains open: As shown in Chapter 17, fixpoint and while are equivalent iff ptime = pspace (Theorem 17.4.3).

The equivalences among languages discussed in this chapter are summarized in Fig. 14.2.

Normal Forms
The two equivalence theorems just presented have interesting consequences for the underlying extensions of datalog and logic. First they show that these languages are closed under composition and complementation. For instance, if two mappings f, g, respectively, from a schema S to a schema S′ and from S′ to a schema S′′ are expressible in datalog¬(¬), then f ◦ g and ¬f are also expressible in datalog¬(¬). Analogous results are true for CALC+µ(+).

A more dramatic consequence concerns the nesting of recursion in the calculus and algebra. Consider first CALC+µ+. By the equivalence theorems, this is equivalent to datalog¬, which, in turn (by Lemma 14.3.4), is essentially a fragment of CALC+µ+.

This yields a normal form for CALC+µ+ queries and implies that a single application of
368
Recursion and Negation
Languages
Class of queries
while+
inflationary
CALC +µ+
fixpoint
datalog¬
while
noninflationary
CALC +µ
while
datalog¬¬
Figure 14.2:
Summary of language equivalence results
the inflationary fixpoint operator is all that is needed. Similar remarks apply to CALC+µ
queries. In summary, the following applies:
Theorem 14.4.7
Each CALC+µ(+) query is equivalent to a CALC+µ(+) query of the
form
{ !

x | µ(+)(ϕ(T ))(!t)},
T
where ϕ is an existential CALC formula.

Analogous normal forms can be shown for while(+) (Exercise 14.22) and for RA(+) (Exercise 14.24).

14.5
Recursion in Practical Languages
To date, there are numerous prototypes (but no commercial product) that provide query and update languages with recursion. Many of these languages provide semantics for recursion in the spirit of the procedural semantics described in this chapter. Prototypes implementing the deductive paradigm are discussed in Chapter 15.

SQL 2-3 (a norm provided by ISO/ANSII) allows select statements that define a table used recursively in the from and where clauses. Such recursion is also allowed in Starburst.

The semantics of the recursion is inflationary, although noninflationary semantics can be achieved using deletion. An extension of SQL 2-3 is ESQL (Extended SQL). To illustrate the flavor of the syntax (which is typical for this category of languages), the following is an ESQL program defining a table SPARTS (subparts), the transitive closure of the table PARTS. This is done using a view creation mechanism.

create view SPARTS as
select *
from PARTS
union
Bibliographic Notes
369
select P1.PART, P2.COMPONENT
from SPARTS P1, PARTS P2
where P1.COMPONENT = P2.PART ;
This is in the spirit of CALC+µ+. With deletion, one can simulate CALC+µ. The system Postgres also provides similar iteration up to a fixpoint in its query language POSTQUEL.

A form of recursion closer to while and while+ is provided by SQL embedded in full programming languages, such as C+SQL, which allows SQL statements coupled with C
programs. The recursion is provided by while loops in the host language.

The recursion provided by datalog¬ and datalog¬¬ is close in spirit to production-rule systems. Speaking loosely, a production rule has the form
if condition then action.

Production rules permit the specification of database updates, whereas deductive rules usually support only database queries (with some notable exceptions). Note that the deletion in datalog¬¬ can be viewed as providing an update capability. The production-rule approach has been studied widely in connection with expert systems in artificial intelligence; OPS5
is a well-known system that uses this approach.

A feature similar to recursive rules is found in the emerging field of active databases.

In active databases, the rule condition is often broken into two pieces; one piece, called the trigger, is usually closely tied to the database (e.g., based on insertions to or deletions from relations) and can be implemented deep in the system.

In active database systems, rules are recursively fired when conditions become true in the database. Speaking in broad terms, the noninflationary languages studied in this chapter can be viewed as an abstraction of this behavior. For example, the database language RDL1
is close in spirit to the language datalog¬¬. (See also Chapter 22 for a discussion of active databases.)

The language Graphlog, a visual language for queries on graphs developed at the University of Toronto, emphasizes queries involving paths and provides recursion specified using regular expressions that describe the shape of desired paths.

Bibliographic Notes
The while language was first introduced as RQ in [CH82] and as LE in [Cha81a]. The other noninflationary languages, CALC+µ and datalog¬¬, were defined in [AV91a]. The equivalence of the noninflationary languages was also shown there.

The fixpoint languages have a long history. Logics with fixpoints have been considered by logicians in the general case where infinite structures (corresponding to infinite database instances) are allowed [Mos74]. In the finite case, which is relevant in this book, the fixpoint queries were first defined using the partial fixpoint operator µT applied only to formulas positive in T [CH82]. The language allowing applications of µT to formulas monotonic, but not necessarily positive, in T was further studied in [Gur84]. An interesting difference between unrestricted and finite models arises here: Every CALC formula monotone in some predicate R is equivalent for unrestricted structures to some CALC formula positive in R (Lyndon’s lemma), whereas this is not the case for finite structures [AG87].

Monotonicity is undecidable for both cases [Gur84].

370
Recursion and Negation
The languages (1) with fixpoint over positive formulas, (2) with fixpoint over monotone formulas, and (3) with inflationary fixpoint over arbitrary formulas were shown equivalent in [GS86]. As a side-effect, it was shown in [GS86] that the nesting of µ (or µ+) provides no additional power. This fact had been proven earlier for the first language in [Imm86]. Moreover, a new alternative proof of the sufficiency of a single application of the fixpoint in CALC+µ+ is provided in [Lei90]. The simultaneous induction lemma (Lemma 14.2.5) was also proven in [GS86], extending an analogous result of [Mos74] for infinite structures. Of the other inflationary languages, while+ was defined in [AV90] and datalog¬ with fixpoint semantics was first defined in [AV88c, KP88].

The equivalence of datalog¬ with CALC+µ+ and while+ was shown in [AV91a]. The relationship between the while and fixpoint queries was investigated in [AV91b], where it was shown that they are equivalent iff ptime = pspace. The issues of complexity and expressivity of fixpoint and while queries will be considered in detail in Chapter 17.

The rule algebra for logic programs was introduced in [IN88].

The game of life is described in detail in [Gar70]. The normal forms discussed in this chapter can be viewed as variations of well-known folk theorems, described in [Har80].

SQL 2-3 is described in an ISO/ANSII norm [57391, 69392]). Starburst is presented in
[HCL+90]. ESQL (Extended SQL) is described in [GV92]. The example ESQL program in Section 14.5 is from [GV92]. The query language of Postgres, POSTQUEL, is presented in [SR86]. OPS5 is described in [For81].

The area of active databases is the subject of numerous works, including [Mor83, Coh89, KDM88, SJGP90, MD89, WF90, HJ91a]. Early work on database triggers includes
[Esw76, BC79]. The language RDL1 is presented in [dMS88].

The visual graph language Graphlog, developed at the University of Toronto, is described in [CM90, CM93a, CM93b].

Exercises
Exercise 14.1
(Game of life) Consider the two rules informally described in Example 14.1.

(a) Express the corresponding queries in datalog¬(¬), while(+), and CALC+µ(+).

(b) Find an input for which a vertex keeps changing color forever under the second rule.

Exercise 14.2
Prove that the termination problem for a while program is undecidable (i.e., that it is undecidable, given a while query, whether it terminates on all inputs). Hint: Use a reduction of the containment problem for algebra queries.

Exercise 14.3
Recall the datalog¬¬ program of Example 14.4.2.

(a) After how many stages does the program complete for an input graph of diameter n?

(b) Modify the program so that it also handles the case of empty graphs.

(c) Modify the program so that it terminates in order of log(n) stages for an input graph of diameter n.

Exercise 14.4
Recall the definition of µT (ϕ(T )).

(a) Exhibit a formula ϕ such that ϕ(T ) has a unique minimal fixpoint on all inputs, and µT (ϕ(T )) terminates on all inputs but does not evaluate to the minimal fixpoint on any of them.

Exercises
371
(b) Exhibit a formula ϕ such that µT (ϕ(T )) terminates on all inputs but ϕ does not have a unique minimal fixpoint on any input.

Exercise 14.5
(a) Give a while program with explicit looping condition for the query in Example 14.1.2.

(b) Prove that while(+) with looping conditions of the form E = ∅, E = ∅, E = E′, and E = E′, where E, E′ are algebra expressions, is equivalent to while(+) with the change conditions.

Exercise 14.6
Consider the problem of finding, given two graphs G, G′ over the same vertex set, the minimum set X of vertexes satisfying the following conditions: (1) For each vertex v, if all vertexes v′ such that there is a G-edge from v′ to v are in X, then v is in X; and (2) the analogue for G′-edges. Exhibit a while program and a fixpoint query that compute this set.

Exercise 14.7
Recall the CALC+µ+ query of Example 14.4.3.

(a) Run the query on the input graph G:
{a, b, c, b, b, d, d, e, e, f , f, g, g, d, e, h, i, j , j, h}.

(b) Exhibit a while+ program that computes good.

(c) Write a program in your favorite conventional programming language (e.g., C or LISP) that computes the good vertexes of a graph G. Compare it with the database queries developed in this chapter.

(d) Show that a vertex a is good if there is no path from a vertex belonging to a cycle to a. Using this as a starting point, propose an alternative algorithm for computing the good vertexes. Is your algorithm expressible in while? In fixpoint?

⋆ Exercise 14.8 Suppose that the input consists of a graph G together with a successor relation on the vertexes of G [i.e., a binary relation succ such that (1) each element has exactly one successor, except for one that has none; and (2) each element in the binary relation G occurs in succ].

(a) Give a fixpoint query that tests whether the input satisfies (1) and (2).

(b) Sketch a while program computing the set of pairs a, b such that the shortest path from a to b is a prime number.

(c) Do (b) using a while+ query.

Exercise 14.9
(Simultaneous induction) Prove Lemma 14.2.5.

♠ Exercise 14.10 (Fixpoint over positive formulas) Let ϕ(T ) be a formula positive in T (i.e., each occurrence of T is under an even number of negations in the syntax tree of ϕ). Let R be the set of relations other than T occurring in ϕ(T ).

(a) Show that ϕ(T ) is monotonic in T . That is, for all instances I and J over R ∪ {T }
such that I(R) = J(R) and I(T ) ⊆ J(T ), ϕ(I) ⊆ ϕ(J).

(b) Show that µT (ϕ(T )) is defined on every input instance.

(c) [GS86] Show that the family of CALC+µ queries with fixpoints only over positive formulas is equivalent to the CALC+µ+ queries.

372
Recursion and Negation
⋆ Exercise 14.11 Suppose CALC+µ+ is modified so that free variables are allowed under fixpoint operators. More precisely, let
ϕ(T , x1, . . . , xn, y1, . . . , ym)
be a formula where T has arity n and the xi and yj are free in ϕ. Then µT ,x
(ϕ(T , x
1,...,xn
1, . . . , xn, y1, . . . , ym))(e1, . . . , en)
is a correct formula, whose free variables are the yj and those occurring among the ei. The fixpoint is defined with respect to a given valuation of the yj . For instance,
∃z∃w(P (z) ∧ µT,x,y(ϕ(T , x, y, z))(u, w))
is a well-formed formula. Give a precise definition of the semantics for queries using this operator. Show that this extension does not yield increased expressive power over CALC+µ+.

Do the same for CALC+µ.

Exercise 14.12
Let G be a graph. Give a fixpoint query in each of the three paradigms that computes the pairs of vertexes such that the shortest path between them is of even length.

Exercise 14.13
Let datalog¬(¬)
rr
denote the family of datalog¬(¬) programs that are range
restricted, in the sense that for each rule r and each variable x occurring in r, x occurs in a positive literal in the body of r. Prove that datalog¬ ≡ datalog¬ and datalog¬¬ ≡ datalog¬¬.

rr
rr
Exercise 14.14
Show that negations in bodies of rules are redundant in datalog¬¬ (i.e., for each datalog¬¬ program P there exists an equivalent datalog¬¬ program Q that uses no negations in bodies of rules). Hint: Maintain the complement of each relation R in a new relation R′, using deletions.

♠ Exercise 14.15 Consider the following semantics for negations in heads of datalog¬¬ rules: (α) the semantics giving priority to positive over negative facts inferred simultaneously (adopted in this chapter),
(β) the semantics giving priority to negative over positive facts inferred simultaneously, (γ ) the semantics in which simultaneous inference of A and ¬A leads to a “no-op” (i.e., including A in the new instance only if it is there in the old one), and (δ) the semantics prohibiting the simultaneous inference of a fact and its negation by making the result undefined in such circumstances.

For a datalog¬¬ program P , let Pξ , denote the program P with semantics ξ ∈ {α, β, γ , δ}.

(a) Give an example of a program P for which Pα, Pβ, Pγ , and Pδ define distinct queries.

(b) Show that it is undecidable, for a given program P , whether Pδ never simultaneously infers a positive fact and its negation for any input.

(c) Let datalog¬¬ denote the family of queries P
ξ
ξ for ξ ∈ {α, β, γ }. Prove that data-
log¬¬ ≡ datalog¬¬ ≡ datalog¬¬.

α
β
γ
(d) Give a syntactic condition on datalog¬¬ programs such that under the δ semantics they never simultaneously infer a positve fact and its negation, and such that the resulting query language is equivalent to datalog¬¬.

α
Exercises
373
Exercise 14.16
(Noninflationary datalog¬) The semantics of datalog¬ can be made noninflationary by defining the immediate consequence operator to be destructive in the sense that only the newly inferred facts are kept after each firing of the rules. Show that, with this semantics, datalog¬ is equivalent to datalog¬¬.

⋆ Exercise 14.17 (Multiple versus single carriers)
(a) Consider a datalog¬ program P producing the answer to a query in an idb relation S. Prove that there exists a program Q with the same edb relations as P and just one idb relation T such that, for each edb instance I,
[P (I)](S) = π(σ ([Q(I)](T ))),
where σ denotes a selection and π a projection.

(b) Show that the projection π and selection σ in part (a) are indispensable. Hint: Suppose there is a datalog¬ program with a single edb relation computing the complement of transitive closure of a graph. Reach a contradiction by showing in this case that connectivity of a graph is expressible in relational calculus. (It is shown in Chapter 17 that connectivity is not expressible in the calculus.)

(c) Show that the projection and selection used in Lemma 14.2.5 are also indispensable.

⋆ Exercise 14.18
(a) Prove Lemma 14.3.4 for the inflationary case.

(b) Prove Lemma 14.3.4 for the noninflationary case. Hint: For datalog¬¬, the straightforward simulation yields a formula µT (ϕ(T ))(!x), where ϕ may contain negations over existential quantifiers to simulate the semantics of deletions in heads of rules of the datalog¬¬ program. Use instead the noninflationary version of datalog¬ described in Exercise 14.16.

Exercise 14.19
Prove that the simulation in Example 14.4.3 works.

Exercise 14.20
Complete the proof of Lemma 14.4.1 (i.e., prove that each while+ program can be simulated by a CALC+µ+ program).

⋆ Exercise 14.21 Prove the noninflationary analogue of Lemma 14.4.4 (i.e., that datalog¬¬ can simulate CALC+µ). Hint: Simplify the simulation in Lemma 14.4.4 by taking advantage of the ability to delete in datalog¬¬. For instance, rules can be inhibited using “switches,” which can be turned on and off. Furthermore, no timestamping is needed.

Exercise 14.22
Formulate and prove a normal form for while+ and while, analogous to the normal forms stated for CALC+µ+ and CALC+µ.

Exercise 14.23
Prove that RA+ is equivalent to datalog¬ and RA is equivalent to noninflationary datalog¬, and hence to datalog¬¬. Hint: Use Theorems 14.4.5 and 14.4.6 and Exercise 14.16.

Exercise 14.24
Let the star height of an RA program be the maximum number of occurrences of ∗ and + on a path in the syntax tree of the program. Show that each RA program is equivalent to an RA program of star height one.

15 NegationinDatalog
Alice:
I thought we already talked about negation.

Sergio:
Yes, but they say you don’t think by fixpoint.

Alice:
Humbug, I just got used to it!

Riccardo:
So we have to tell you how you really think.

Vittorio:
And convince you that our explanation is well founded!

As originally introduced in Chapter 12, datalog is a toy language that expresses many interesting recursive queries but has serious shortcomings concerning expressive power. Because it is monotonic, it cannot express simple relational algebra queries such as the difference of two relations. In the previous chapter, we considered one approach for adding negation to datalog that led to two procedural languages—namely, inflationary datalog¬ and datalog¬¬. In this chapter, we take a different point of view inspired by nonmonotonic reasoning that attempts to view the semantics of such programs in terms of a natural reasoning process.

This chapter begins with illustrations of how the various semantics for datalog do not naturally extend to datalog¬. Two semantics for datalog¬ are then considered. The first, called stratified, involves a syntactic restriction on programs but provides a semantics that is natural and relatively easy to understand. The second, called well founded, requires no syntactic restriction on programs, but the meaning associated with some programs is expressed using a 3-valued logic. (In this logic, facts are true, false, or unknown.) With respect to expressive power, well-founded semantics is equivalent to the fixpoint queries, whereas the stratified semantics is strictly weaker. A proof-theoretic semantics for datalog¬, based on negation as failure, is discussed briefly at the end of this chapter.

15.1
The Basic Problem
Suppose that we want to compute the pairs of disconnected nodes in a graph G (i.e., we are interested in the complement of the transitive closure of a graph whose edges are given by a binary relation G). We already know how to define the transitive closure of G in a relation T using the datalog program PT C of Chapter 12:
T (x, y) ← G(x, y)
T (x, y) ← G(x, z), T (z, y).

To define the complement CT of T , we are naturally tempted to use negation as we 374
15.1 The Basic Problem
375
did in Chapter 5. Let PT C comp be the result of adding the following rule to PT C: CT (x, y) ← ¬T (x, y).

To simplify the discussion, we generally assume an active domain interpretation of datalog¬ rules.

In this example, negation appears to be an appealing addition to the datalog syntax.

The language datalog¬ is defined by allowing, in bodies of rules, literals of the form
¬Ri(ui), where Ri is a relation name and ui is a free tuple. In addition, the equality predicate is allowed, and ¬ = (x, y) is denoted by x = y.

One might hope to extend the model-theoretic, fixpoint, and proof-theoretic semantics of datalog just as smoothly as the syntax. Unfortunately, things are less straightforward when negation is present. We illustrate informally the problems that arise if one tries to extend the least-fixpoint and minimal-model semantics of datalog. We shall discuss the proof-theoretic aspect later.

Fixpoint Semantics: Problems
Recall that, for a datalog program P , the fixpoint semantics of P on input I is the unique minimal fixpoint of the immediate consequence operator TP containing I. The immediate consequence operator can be naturally extended to a datalog¬ program P . For a program P , TP is defined as follows1: For each K over sch(P ), A is TP (K) if A ∈ K| edb(P ) or if there exists some instantiation A ← A1, . . . , An of a rule in P for which (1) if Ai is a positive literal, then Ai ∈ K; and (2) if Ai = ¬Bi where Bi is a positive literal, then Bi ∈ K.

[Note the difference from the immediate consequence operator ŴP defined for datalog¬ in Section 14.3: ŴP is inflationary by definition, (that is, K ⊆ ŴP (K) for each K over sch(P ), whereas TP is not.] The following example illustrates several unexpected properties that TP might have.

Example 15.1.1
(a) TP may not have any fixpoint. For the propositional program P1 = {p ← ¬p}, TP has no fixpoint.

1
(b) TP may have several minimal fixpoints containing a given input. For example, the propositional program P2 = {p ← ¬q, q ← ¬p} has two minimal fixpoints (containing the empty instance): {p} and {q}.

(c) Consider the sequence {T i (∅)}
P
i>0 for a given datalog¬ program P . Recall that
for datalog, the sequence is increasing and converges to the least fixpoint of TP .

In the case of datalog¬ , the situation is more intricate:
1. The sequence does not generally converge, even if TP has a least fixpoint. For example, let P3 = {p ← ¬r; r ← ¬p; p ← ¬p, r}. Then
1 Given an instance J over a database schema R with S ⊆ R, J|S denotes the restriction of J to S.

376
Negation in Datalog
TP has a least fixpoint {p} but {T i (∅)}
3
P
i>0 alternates between ∅ and
3
{p, r} and so does not converge (Exercise 15.2).

2. Even if {T i (∅)}
P
i>0 converges, its limit is not necessarily a minimal
fixpoint of TP , even if such fixpoints exist. To see this, let P4 = {p ←
p, q ← q, p ← ¬p, q ← ¬p}. Now {T i (∅)}
P
i>0 converges to {p, q }
4
but the least fixpoint of TP equals {p}.

4
Remark 15.1.2 (Inflationary fixpoint semantics)
The program P4 of the preceding ex-
ample contains two rules of a rather strange form: p ← p and q ← q. In some sense, such rules may appear meaningless. Indeed, their logical forms [e.g., (p ∨ ¬p)] are tautologies.

However, rules of the form R(x1, . . . , xn) ← R(x1, . . . , xn) have a nontrivial impact on the immediate consequence operator TP . If such rules are added for each idb relation R, this results in making TP inflationary [i.e., K ⊆ TP (K) for each K], because each fact is an immediate consequence of itself. It is worth noting that in this case, {T i (I)}
P
i>0 al-
ways converges and the semantics given by its limit coincides with the inflationary fixpoint semantics for datalog¬ programs exhibited in Chapter 14.

To see the difference between the two semantics, consider again program PT C comp.

The sequence {T i
(I )}
P
i>0 on input I over G converges to the desired answer (the
T C comp
complement of transitive closure). With the inflationary fixpoint semantics, CT becomes a complete graph at the first iteration (because T is initially empty) and PT C comp does not compute the complement of transitive closure. Nonetheless, it was shown in Chapter 14 that there is a different (more complicated) datalog¬ program that computes the complement of transitive closure with the inflationary fixpoint semantics.

Model-Theoretic Semantics: Problems
As with datalog, we can associate with a datalog¬ program P the set P of CALC
sentences corresponding to the rules of P . Note first that, as with datalog, P always has at least one model containing any given input I. B(P , I) is such a model. [Recall that B(P , I), introduced in Chapter 12, is the instance in which the idb relations contain all tuples with values in I or P .]
For datalog, the model-theoretic semantics of a program P was given by the unique minimal model of P containing the input. Unfortunately, this simple solution no longer works for datalog¬, because uniqueness of a minimal model containing the input is not guaranteed. Program P2 in Example 15.1.1(b) provides one example of this: {p} and {q}
are distinct minimal models of P2. As another example, consider the program PT C comp and an input I for predicate G. Let J over sch(PT C comp) be such that J(G) = I , J(T ) ⊇ I , J(T ) is transitively closed, and J(CT ) = {x, y | x, y occur in I, x, y ∈ J(T )}. Clearly, there may be more than one such J, but one can verify that each one is a minimal model of P
satisfying J(G) = I .

T C comp
It is worth noting the connection between TP and models of P : An instance K over sch(P ) is a model of P iff TP (K) ⊆ K. In particular, every fixpoint of TP is a model of P . The converse is false (Exercise 15.3).

When for a program P , P has several minimal models, one must specify which
15.2 Stratified Semantics
377
among them is the model intended to be the solution. To this end, various criteria of
“niceness” of models have been proposed that can distinguish the intended model from other candidates. We shall discuss several such criteria as we go along. Unfortunately, none of these criteria suffices to do the job. Moreover, upon reflection it is clear that no criteria can exist that would always permit identification of a unique intended model among several minimal models. This is because, as in the case of program P2 of Example 15.1.1(b), the minimal models can be completely symmetric; in such cases there is no property that would separate one from the others using just the information in the input or the program.

In summary, the approach we used for datalog, based on equivalent least-fixpoint or minimum-model semantics, breaks down when negation is present. We shall describe several solutions to the problem of giving semantics to datalog¬ programs. We begin with the simplest case and build up from there.

15.2
Stratified Semantics
This section begins with the restricted case in which negation is applied only to edb relations. The semantics for negation is straightforward in this case. We then turn to stratified semantics, which extends this simple case in an extremely natural fashion.

Semipositive Datalog¬
We consider now semipositive datalog¬ programs, which only apply negation to edb relations. For example, the difference of R and R′ can be defined by the one-rule program Diff ( x) ← R(x), ¬R′(x).

To give semantics to ¬R′(x), we simply use the closed world assumption (see Chapter 2):
¬R′(x) holds iff x is in the active domain and x ∈ R′. Because R′ is an edb relation, its content is given by the database and the semantics of the program is clear. We elaborate on this next.

Definition 15.2.1
A datalog¬ program P is semipositive if, whenever a negative literal
¬R′(x) occurs in the body of a rule in P , R′ ∈ edb(P ).

As their name suggests, semipositive programs are almost positive. One could eliminate negation from semipositive programs by adding, for each edb relation R′, a new edb relation R′ holding the complement of R′ (with respect to the active domain) and replacing
¬R′(x) by R′(x). Thus it is not surprising that semipositive programs behave much like datalog programs. The next result is shown easily and is left for the reader (Exercise 15.7).

Theorem 15.2.2
Let P be a semipositive datalog¬ program. For every instance I over edb(P ),
(i) P has a unique minimal model J satisfying J| edb(P ) = I.

(ii) TP has a unique minimal fixpoint J satisfying J| edb(P ) = I.

378
Negation in Datalog
(iii) The minimum model in (i) and the least fixpoint in (ii) are identical and equal to the limit of the sequence {T i (I)}
P
i>0.

Remark 15.2.3
Observe that in the theorem, we use the formulation “minimal model
satisfying J| edb(P ) = I,” whereas in the analogous result for datalog we used “minimal model containing I.” Both formulations would be equivalent in the datalog setting because adding tuples to the edb predicates would result in larger models because of monotonicity.

This is not the case here because negation destroys monotonicity.

Given a semipositive datalog¬ program P and an input I, we denote by P semi− pos(I) the minimum model of P (or equivalently, the least fixpoint of TP ) whose restriction to edb(P ) equals I.

An example of a semipositive program that is neither in datalog nor in CALC is given by
T (x, y) ← ¬G(x, y)
T (x, y) ← ¬G(x, z), T (z, y).

This program computes the transitive closure of the complement of G. On the other hand, the foregoing program for the complement of transitive closure is not a semipositive program. However, it can naturally be viewed as the composition of two semipositive programs: the program computing the transitive closure followed by the program computing its complement. Stratification, which is studied next, may be viewed as the closure of semipositive programs under composition. It will allow us to specify, for instance, the composition just described, computing the complement of transitive closure.

Syntactic Restriction for Stratification
We now consider a natural extension of semipositive programs. In semipositive programs, the use of negation is restricted to edb relations. Now suppose that we use some defined relations, much like views. Once a relation has been defined by some program, other programs can subsequently treat it as an edb relation and apply negation to it. This simple idea underlies an important extension to semipositive programs, called stratified programs.

Suppose we have a datalog¬ program P . Each idb relation is defined by one or more rules of P . If we are able to “read” the program so that, for each idb relation R′, the portion of P defining R′ comes before the negation of R′ is used, then we can simply compute R′ before its negation is used, and we are done. For example, consider program PT C comp introduced at the beginning of this chapter. Clearly, we intended for T to be defined by the first two rules before its negation is used in the rule defining CT . Thus the first two rules are applied before the third. Such a way of “reading” P is called a stratification of P and is defined next.

Definition 15.2.4
A stratification of a datalog¬ program P is a sequence of datalog¬
programs P 1, . . . , P n such that for some mapping σ from idb(P ) to [1..n], (i) {P 1, . . . , P n} is a partition of P .

15.2 Stratified Semantics
379
(ii) For each predicate R, all the rules in P defining R are in P σ (R) (i.e., in the same program of the partition).

(iii) If R(u) ← . . . R′(v) . . . is a rule in P , and R′ is an idb relation, then σ (R′) ≤
σ (R).

(iv) If R(u) ← . . . ¬R′(v) . . . is a rule in P , and R′ is an idb relation, then σ (R′) < σ (R).

Given a stratification P 1, . . . , P n of P , each P i is called a stratum of the stratification, and σ is called the stratification mapping.

Intuitively, a stratification of a program P provides a way of parsing P as a sequence of subprograms P 1, . . . , P n, each defining one or several idb relations. By (iii), if a relation R′
is used positively in the definition of R, then R′ must be defined earlier or simultaneously with R (this allows recursion!). If the negation of R′ is used in the definition of R, then by (iv) the definition of R′ must come strictly before that of R.

Unfortunately, not every datalog¬ program has a stratification. For example, there is no way to “read” program P2 of Example 15.1.1 so that p is defined before q and q before p. Programs that have a stratification are called stratifiable. Thus P2 is not stratifiable. On the other hand, PT C comp is clearly stratifiable: The first stratum consists of the first two rules (defining T ), and the second stratum consists of the third rule (defining CT using T ).

Example 15.2.5
Consider the program P7 defined by
r1
S(x) ← R′1(x), ¬R(x)
r2
T (x) ← R′2(x), ¬R(x)
r3
U (x) ← R′3(x), ¬T (x)
r4
V (x) ← R′4(x), ¬S(x), ¬U(x).

Then P7 has 5 distinct stratifications, namely,
{r1}, {r2}, {r3}, {r4}
{r2}, {r1}, {r3}, {r4}
{r2}, {r3}, {r1}, {r4}
{r1, r2}, {r3}, {r4}
{r2}, {r1, r3}, {r4}.

These lead to five different ways of reading the program P7. As will be seen, each of these yields the same semantics.

There is a simple test for checking if a program is stratifiable. Not surprisingly, it involves testing for an acyclicity condition in definitions of relations using negation. Let P
be a datalog¬ program. The precedence graph GP of P is the labeled graph whose nodes are the idb relations of P . Its edges are the following:
380
Negation in Datalog
+
V
–
–
–
–
P
:
T
CT
P : P
Q
P : S
U
TC comp
2
7
–
–
T
Figure 15.1:
Precedence graphs for PCT , P2, and P7
• If R(u) ← . . . R′(v) . . . is a rule in P , then R′, R is an edge in GP with label +
(called a positive edge).

• If R(u) ← . . . ¬R′(v) . . . is a rule in P , then R′, R is an edge in GP with label −
(called a negative edge).

For example, the precedence graphs for program PT C comp, P2, and P7 are represented in Fig. 15.1. It is straightforward to show the following (proof omitted): Lemma 15.2.6
Let P be a program with stratification σ . If there is a path from R′ to R in GP, then σ (R′) ≤ σ (R); and if there is a path from R′ to R in GP containing some negative edge, then σ (R′) < σ (R).

We now show how the precedence graph of a program can be used to test the stratifiability of the program.

Proposition 15.2.7
A datalog¬ program P is stratifiable iff its precedence graph GP
has no cycle containing a negative edge.

Proof
Consider the “only if” part. Suppose P is a datalog¬ program whose precedence graph has a cycle R1, . . . Rm, R1 containing a negative edge, say from Rm to R1. Suppose, toward a contradiction, that σ is a stratification mapping for P . By Lemma 15.2.6, σ (R1) < σ (R1), because there is a path from R1 to R1 with a negative edge. This is a contradiction, so no stratification mapping σ exists for P .

Conversely, suppose P is a program whose precedence graph GP has no cycle with negative edges. Let ≺ be the binary relation among the strongly connected components of GP defined as follows: C ≺ C′ if C = C′ and there is a (positive or negative) edge in GP
from some node of C to some node of C′.

We first show that
(*)
≺ is acyclic.

Suppose there is a cycle in ≺. Then by construction of ≺, this cycle must traverse two distinct strongly connected components, say C, C′. Let A be in C. It is easy to deduce that there is a path in GP from some vertex in C′ to A and from A to some vertex in C′.

15.2 Stratified Semantics
381
Because C′ is a strongly connected component of GP, A is in C′. Thus C ⊆ C′, so C = C′, a contradiction. Hence (*) holds.

In view of (*), the binary relation ≺ induces a partial order among the strongly connected components of GP, which we also denote by ≺, by abuse of notation. Let C1, . . . , Cn be a topographic sort with respect to ≺ of the strongly connected components of GP; that is, C1 . . . Cn is the set of strongly connected components of GP and if Ci ≺ Cj , then i ≤ j . Finally, for each i, 1 ≤ i ≤ n, let Qi consist of all rules defining some relation in Ci. Then Q1, . . . , Qn is a stratification of P . Indeed, (i) and (ii) in the definition of stratification are clearly satisfied. Conditions (iii) and (iv) follow immediately from the construction of GP and ≺ and from the hypothesis that GP has no cycle with negative edge.

Clearly, the stratifiability test provided by Proposition 15.2.7 takes time polynomial in the size of the program P .

Verification of the following observation is left to the reader (Exercise 15.4).

Lemma 15.2.8
Let P 1, . . . , P n be a stratification of P , and let Q1, . . . , Qm be obtained as in Proposition 15.2.7. If Qj ∩ P i = ∅, then Qj ⊆ P i. In particular, the partition Q1, . . . , Qm of P refines all other partitions given by stratifications of P .

Semantics of Stratified Programs
Consider a stratifiable program P with a stratification σ = P 1, . . . , P n. Using the stratification σ , we can now easily give a semantics to P using the well-understood semipositive programs. Notice that for each program P i in the stratification, if P i uses the negation of R′, then R′ ∈ edb(P i) [note that edb(P i) may contain some of the idb relations of P ]. Furthermore, R′ is either in edb(P ) or is defined by some P j preceding P i
[i.e., R′ ∈ ∪j<i idb(P j )]. Thus each program P i is semipositive relative to previously defined relations. Then the semantics of P is obtained by applying, in order, the programs P i. More precisely, let I be an instance over edb(P ). Define the sequence of instances I0 = I
Ii = Ii−1 ∪ P i(Ii−1| edb(P i)), 0 < i ≤ n.

Note that Ii extends Ii−1 by providing values to the relations defined by P i; and that P i(Ii−1| edb(P i)), or equivalently, P i(Ii−1), is the semantics of the semipositive program P i applied to the values of its edb relations provided by Ii−1. Let us denote the final instance In thus obtained by σ (I). This provides the semantics of a datalog¬ program under a stratification σ .

Independence of Stratification
As shown in Example 15.2.5, a datalog¬ program can have more than one stratification.

Will the different stratifications yield the same semantics? Fortunately, the answer is yes.

382
Negation in Datalog
To demonstrate this, we use the following simple lemma, whose proof is left to the reader (Exercise 15.10).

Lemma 15.2.9
Let P be a semipositive datalog¬ program and σ a stratification for P .

Then P semi− pos(I) = σ (I) for each instance I over edb(P ).

Two stratifications of a datalog¬ program are equivalent if they yield the same semantics on all inputs.

Theorem 15.2.10
Let P be a stratifiable datalog¬ program. All stratifications of P are equivalent.

Proof
Let GP be the precedence graph of P and σG = Q1, . . . , Qn be a stratification P
constructed from GP as in the proof of Theorem 15.2.7. Let σ = P 1, . . . , P k be a stratification of P . It clearly suffices to show that σ is equivalent to σG . The stratification σ
P
GP
is used as a reference because, as shown in Lemma 15.2.8, its strata are the finest possible among all stratifications for P .

As in the proof of Theorem 15.2.7, we use the partial order ≺ among the strongly connected components of GP and the notation introduced there. Clearly, the relation ≺ on the Ci induces a partial order on the Qi, which we also denote by ≺ (Qi ≺ Qj if Ci ≺ Cj ).

We say that a sequence Qi1, . . . , Qir of some of the Qi is compatible with ≺ if for every l < m it is not the case that Qim ≺ Qil.

We shall prove that
1. If σ ′ and σ ′′ are permutations of σG that are compatible with ≺, then σ ′ and σ ′′
P
are equivalent stratifications of P .

2. For each P i, 1 ≤ i ≤ k, there exists σi = Qi1, . . . , Qir such that σi is a stratification of P i, and the sequence Qi1, . . . , Qir is compatible with ≺.

3. σ1, . . . , σk is a permutation of Q1, . . . , Qn compatible with ≺.

Before demonstrating these, we argue that the foregoing statements (1 through 3) are sufficient to show that σ and σG are equivalent. By statement 2, each σ
P
i is a stratification
of P i. Lemma 15.2.9 implies that P i is equivalent to σi. It follows that σ = P 1, . . . , P k is equivalent to σ1, . . . , σk which, by statement 3, is a permutation of σG compatible with P
≺. Then σ1, . . . , σk and σG are equivalent by statement 1, so σ and σ
are equivalent.

P
GP
Consider statement 1. Note first that one can obtain σ ′′ from σ ′ by a sequence of exchanges of adjacent Qi, Qj such that Qi ≺ Qj and Qj ≺ Qi (Exercise 15.9). Thus it is sufficient to show that for every such pair, Qi, Qj is equivalent to Qj , Qi. Because Qi ≺ Qj and Qj ≺ Qi, it follows that no idb relation of Qi occurs in Qj and conversely.

Then Qi ∪ Qj is a semipositive program [with respect to edb(Qi ∪ Qj )] and both Qi, Qj and Qj , Qi are stratifications of Qi ∪ Qj . By Lemma 15.2.9, Qi, Qj and Qj , Qi are both equivalent to Qi ∪ Qj (as a semipositive program), so Qi, Qj and Qj , Qi are equivalent.

Statement 2 follows immediately from Lemma 15.2.8.

Finally, consider statement 3. By statement 2, each σi is compatible with ≺. Thus it remains to be shown that, if Qm occurs in σi, Ql occurs in σj , and i < j , then Ql ≺ Qm.

15.2 Stratified Semantics
383
Note that Ql is included in P j , and Qm is included in P i. It follows that for all relations R
defined by Qm and R′ defined by Ql, σ (R) < σ (R′), where σ is the stratification function of P 1, . . . , P k. Hence R′ ≺ R so Ql ≺ Qm.

Thus all stratifications of a given stratifiable program are equivalent. This means that we can speak about the semantics of such a program independently of a particular stratification. Given a stratifiable datalog¬ program P and an input I over edb(P ), we shall take as the semantics of P on I the semantics σ (I) of any stratification σ of P . This semantics, well defined by Theorem 15.2.10, is denoted by P strat(I). Clearly, P strat(I) can be computed in time polynomial with respect to I.

Now that we have a well-defined semantics for stratified programs, we can verify that for semipositive programs, the semantics coincides with the semantics already introduced.

If P is a semipositive datalog¬ program, then P is also stratifiable. By Lemma 15.2.9, P semi− pos and P strat are equivalent.

Properties of Stratified Semantics
Stratified semantics has a procedural flavor because it is the result of an ordering of the rules, albeit implicit. What can we say about P strat(I) from a model-theoretic point of view? Rather pleasantly, P strat(I) is a minimal model of P containing I. However, no precise characterization of stratified semantics in model-theoretic terms has emerged. Some model-theoretic properties of stratified semantics are established next.

Proposition 15.2.11
For each stratifiable datalog¬ program P and instance I over edb(I),
(a) P strat(I) is a minimal model of P whose restriction to edb(P ) equals I.

(b) P strat(I) is a minimal fixpoint of TP whose restriction to edb(P ) equals I.

Proof
For part (a), let σ = P 1, . . . , P n be a stratification of P and I an instance over edb(P ). We have to show that P strat(I) is a minimal model of P whose restriction to edb(P ) equals I. Clearly, P strat(I) is a model of P whose restriction to edb(P ) equals I.

To prove its minimality, it is sufficient to show that, for each model J of P , (**)
if I ⊆ J ⊆ P strat(I) then J = P strat(I).

Thus suppose I ⊆ J ⊆ P strat(I). We prove by induction on k that (†)
P strat(I)| sch(∪i≤kP i) = J| sch(∪i≤kP i) for each k, 1 ≤ k ≤ n. The equality of P strat(I) and J then follows from (†) with k = n.

For k = 1, edb(P 1) ⊆ edb(P ) so
P strat(I)| edb(P 1) = I| edb(P 1) = J| edb(P 1).

By the definition of stratified semantics and Theorem 15.2.2, P strat(I)| sch(P 1) is the
384
Negation in Datalog
minimum model of P1 whose restriction to edb(P 1) equals P strat(I)| edb(P 1). On the other hand, J| sch(P 1) is also a model of P1 whose restriction to edb(P 1) equals P strat(I)| edb(P 1). From the minimality of P strat(I)| sch(P 1), it follows that P strat(I)| sch(P 1) ⊆ J| sch(P 1).

From (**) it then follows that P strat(I)| sch(P 1) = J| sch(P 1), which establishes (†) for k = 1. For the induction step, suppose (†) is true for k, 1 ≤ k < n. Then (†) for k + 1 is shown in the same manner as for the case k = 1. This proves (†) for 1 ≤ k ≤ n. It follows that P strat(I) is a minimal model of P whose restriction to edb(P ) equals I.

The proof of part (b) is left for Exercise 15.12.

There is another appealing property of stratified semantics that takes into account the syntax of the program in addition to purely model-theoretic considerations. This property is illustrated next.

Consider the two programs
P5 = {p ← ¬q}
P6 = {q ← ¬p}
From the perspective of classical logic, P and
are equivalent to each other and to
5
P6
{p ∨ q}. However, TP and T have different behavior: The unique fixpoint of T is {p}, 5
P6
P5
whereas that of TP is {q}. This is partially captured by the notion of “supported” as follows.

6
Let datalog¬ program P and input I be given. As with pure datalog, J is a model of P iff J ⊇ TP (J). We say that J is a supported model if J ⊆ TP (J) (i.e., if each fact in J is
“justified” or supported by being the head of a ground instantiation of a rule in P whose body is all true in J). (In the context of some input I, we say that J is supported relative to I and the definition is modified accordingly.) This condition, which has both syntactic and semantic aspects, captures at least some of the spirit of the immediate consequence operator TP . As suggested in Remark 15.1.2, its impact can be annulled by adding rules of the form p ← p.

The proof of the following is left to the reader (Exercise 15.13).

Proposition 15.2.12
For each stratifiable program P and instance I over edb(P ), P strat(I) is a supported model of P relative to I.

We have seen that stratification provides an elegant and simple approach to defining semantics of datalog¬ programs. Nonetheless, it has two major limitations. First, it does not provide semantics to all datalog¬ programs. Second, stratified datalog¬ programs are not entirely satisfactory with regard to expressive power. From a computational point of view, they provide recursion and negation and are inflationary. Therefore, as discussed in Chapter 14, one might expect that they express the fixpoint queries. Unfortunately, stratified datalog¬ programs fall short of expressing all such queries, as will be shown in Section 15.4. Intuitively, this is because the stratification condition prohibits recursive
15.3 Well-Founded Semantics
385
application of negation, whereas in other languages expressing fixpoint this computational restriction does not exist.

For these reasons, we consider another semantics for datalog¬ programs called well founded. As we shall see, this provides semantics to all datalog¬ programs and expresses all fixpoint queries. Furthermore, well-founded and stratified semantics agree on stratified datalog¬ programs.

15.3
Well-Founded Semantics
Well-founded semantics relies on a fundamental revision of our expectations of the answer to a datalog¬ program. So far, we required that the answer must provide information on the truth or falsehood of every fact. Well-founded semantics is based on the idea that a given program may not necessarily provide such information on all facts. Instead some facts may simply be indifferent to it, and the answer should be allowed to say that the truth value of those facts is unknown. As it turns out, relaxing expectations about the answer in this fashion allows us to provide a natural semantics for all datalog¬ programs. The price is that the answer is no longer guaranteed to provide total information.

Another aspect of this approach is that it puts negative and positive facts on a more equal footing. One can no longer assume that ¬R(u) is true simply because R(u) is not in the answer. Instead, both negative and positive facts must be inferred. To formalize this, we shall introduce 3-valued instances, in which the truth value of facts can be true, false, or unknown.

This section begins by introducing a largely declarative semantics for datalog¬ programs. Next an equivalent fixpoint semantics is developed. Finally it is shown that stratified and well-founded semantics agree on the family of stratified datalog¬ programs.

A Declarative Semantics for Datalog¬
The aim of giving semantics to a datalog¬ program P will be to find an appropriate 3-valued model I of P . In considering what appropriate might mean, it is useful to recall the basic motivation underlying the logic-programming approach to negation as opposed to the purely computational approach. An important goal is to model some form of natural reasoning process. In particular, consistency in the reasoning process is required.

Specifically, one cannot use a fact and later infer its negation. This should be captured in the notion of appropriateness of a 3-valued model I, and it has two intuitive aspects:
• the positive facts of I must be inferred from P assuming the negative facts in I; and
• all negative facts that can be inferred from I must already be in I.

A 3-valued model satisfying the aforementioned notion of appropriateness will be called a 3-stable model of P . It turns out that, generally, programs have several 3-stable models. Then it is natural to take as an answer the certain (positive and negative) facts that belong to all such models, which turns out to yield, in some sense, the smallest 3-stable model. This is indeed how the well-founded semantics of P will be defined.

386
Negation in Datalog
Example 15.3.1
The example concerns a game with states, a, b, . . . . The game is between two players. The possible moves of the games are held in a binary relation moves. A tuple a, b in moves indicates that when in state a, one can choose to move to state b. A player loses if he or she is in a state from which there are no moves. The goal is to compute the set of winning states (i.e., the set of states such that there exists a winning strategy for a player in this state). These are obtained in a unary predicate win.

Consider the input K with the following value for moves: K( moves) = {b, c, c, a, a, b, a, d, d, e, d, f , f, g}
Graphically, the input is represented as
b
c
e
a
d
f
g
It is seen easily that there are indeed winning strategies from states d (move to e) and f (move to g). Slightly more subtle is the fact that there is no winning strategy from any of states a, b, or c. A given player can prevent the other from winning, essentially by forcing a nonterminating sequence of moves.

Now consider the following nonstratifiable program P win:
win(x) ← moves(x, y), ¬ win(y)
Intuitively, P win states that a state x is in win if there is at least one state y that one can move to from x, for which the opposing player loses. We now exhibit a 3-valued model J
of P win that agrees with K on moves. As will be seen, this will in fact be the well-founded semantics of P win on input K. Instance J is such that J( moves) = K( moves) and the values of win-atoms are given as follows:
true
win(d), win(f )
false
win(e), win(g)
unknown
win(a), win(b), win(c)
We now embark on defining formally the well-founded semantics. We do this in three steps. First we define the notion of 3-valued instance and extend the notion of truth value and satisfaction. Then we consider datalog and show the existence of a minimum 3-valued model for each datalog program. Finally we consider datalog¬ and the notion of 3-stable model, which is the basis of well-founded semantics.

3-valued Instances
Dealing with three truth values instead of the usual two requires
extending some of the basic notions like instance and model. As we shall see, this is straightforward. We will denote true by 1, false by 0, and unknown by 1/2.

15.3 Well-Founded Semantics
387
Consider a datalog¬ program P and a classical 2-valued instance I. As was done in the discussion of SLD resolution in Chapter 12, we shall denote by PI the program obtained from P by adding to P unit clauses stating that the facts in I are true. Then P (I) = PI(∅).

For the moment, we shall deal with datalog¬ programs such as these, whose input is included in the program. Recall that B(P ) denotes all facts of the form R(a1, . . . , ak), where R is a relation and a1, . . . , ak constants occurring in P . In particular, B(PI) =
B(P , I).

Let P be a datalog¬ program. A 3-valued instance I over sch(P ) is a total mapping from B(P ) to {0, 1/2, 1}. We denote by I1, I1/2, and I0 the set of atoms in B(P ) whose truth value is 1, 1/2, and 0, respectively. A 3-valued instance I is total, or 2-valued, if I1/2 = ∅.

There is a natural ordering ≺ among 3-valued instances over sch(P ), defined by I ≺ J iff for each A ∈ B(P ), I(A) ≤ J(A).

Note that this is equivalent to I1 ⊆ J1 and I0 ⊇ J0 and that it generalizes containment for 2-valued instances.

Occasionally, we will represent a 3-valued instance by listing the positive and negative facts and omitting the undefined ones. For example, the 3-valued instance I, where I(p) =
1, I(q) = 1, I(r) = 1/2, I(s) = 0, will also be written as I = {p, q, ¬s}.

Given a 3-valued instance I, we next define the truth value of Boolean combinations of facts using the connectives ∨, ∧, ¬, ←. The truth value of a Boolean combination α of facts is denoted by ˆI(α), defined by
ˆI(β ∧ γ ) = min{ˆI(β), ˆI(γ )}
ˆI(β ∨ γ ) = max{ˆI(β), ˆI(γ )}
ˆI(¬β)
= 1 − ˆI(β)
ˆI(β ← γ ) = 1 if ˆI(γ ) ≤ ˆI(β), and 0 otherwise.

The reader should be careful: Known facts about Boolean operators in the 2-valued context may not hold in this more complex one. For instance, note that the truth value of p ← q may be different from that of p ∨ ¬q (see Exercise 15.15). To see that the preceding definition matches the intuition, one might want to verify that with the specific semantics of ← used here, the instance J of Example 15.3.1 does satisfy (the ground instantiation of) P win, K. That would not be the case if we define the semantics of ← in a more standard way; by using p ← q ≡ p ∨ ¬q.

A 3-valued instance I over sch(P ) satisfies a Boolean combination α of atoms in B(P ) iff ˆI(α) = 1. Given a datalog(¬) program P , a 3-valued model of P is a 3-valued instance over sch(P ) satisfying the set of implications corresponding to the rules in ground(P ).

Example 15.3.2
Recall the program P win of Example 15.3.1 and the input instance K
and output instance J presented there. Consider these ground sentences: win(a) ← moves(a, d), ¬ win(d)
win(a) ← moves(a, b), ¬ win(b).

388
Negation in Datalog
The first is true for J, because ˆJ(¬ win(d)) = 0, ˆJ( moves(a, d)) = 1, ˆJ( win(a)) = 1/2, and 1/2 ≥ 0. The second is true because ˆJ(¬ win(b)) = 1/2, ˆJ( moves(a, b)) = 1, ˆJ( win(a)) =
1/2, and 1/2 ≥ 1/2.

Observe that, on the other hand,
ˆJ( win(a) ∨ ¬( moves(a, b) ∧ ¬ win(b))) = 1/2.

3-valued Minimal Model for Datalog
We next extend the definition and semantics of
datalog programs to the context of 3-valued instances. Although datalog programs do not contain negation, they will now be allowed to infer positive, unknown, and false facts.

The syntax of a 3-extended datalog program is the same as for datalog, except that the truth values 0, 1/2, and 1 can occur as literals in bodies of rules. Given a 3-extended datalog program P , the 3-valued immediate consequence operator 3-T P of P is a mapping on 3-valued instances over sch(P ) defined as follows. Given a 3-valued instance I and A ∈ B(P ), 3-T P (I)(A) is
1 if there is a rule A ← body in ground(P ) such that ˆI( body)= 1, 0 if for each rule A ← body in ground(P ), ˆI( body)= 0 (and, in particular, if there is no rule with A in head),
1/2 otherwise.

Example 15.3.3
Consider the 3-extended datalog program P = {p ← 1/2; p ← q, 1/2;
q ← p, r; q ← p, s; s ← q; r ← 1}. Then
3-TP ({¬p, ¬q, ¬r, ¬s}) = {¬q, r, ¬s}
3- T P ({¬q, r, ¬s})
= {r, ¬s}
3- T P ({r, ¬s})
= {r}
3- T P ({r})
= {r}.

In the following, 3-valued instances are compared with respect to ≺. Thus “least,”
“minimal,” and “monotonic” are with respect to ≺ rather than the set inclusion used for classical 2-valued instances. In particular, note that the minimum 3-valued instance with respect to ≺ is that where all atoms are false. Let ⊥ denote this particular instance.

With the preceding definitions, extended datalog programs on 3-valued instances behave similarly to classical programs. The next lemma can be verified easily (Exercise 15.16):
Lemma 15.3.4
Let P be a 3-extended datalog program. Then
1. 3−TP is monotonic and the sequence { 3- T i (⊥)}
P
i>0 is increasing and converges
to the least fixpoint of 3- TP ;
15.3 Well-Founded Semantics
389
2. P has a unique minimal 3-valued model that equals the least fixpoint of 3- TP .

The semantics of an extended datalog program is the minimum 3-valued model of P .

Analogous to conventional datalog, we denote this by P (⊥).

3-stable Models of Datalog¬
We are now ready to look at datalog¬ programs and formally define 3-stable models of a datalog¬ program P . We “bootstrap” to the semantics of programs with negation, using the semantics for 3-extended datalog programs described earlier. Let I be a 3-valued instance over sch(P ). We reduce the problem to that of applying a positive datalog program, as follows. The positivized ground version of P given I, denoted pg(P , I), is the 3-extended datalog program obtained from ground(P ) by replacing each negative premise ¬A by Î(¬A) (i.e., 0, 1, or 1/2). Because all negative literals in ground(P ) have been replaced by their truth value in I, pg(P , I) is now a 3-extended datalog program (i.e, a program without negation). Its least fixpoint pg(P , I)(⊥) contains all the facts that are consequences of P
by assuming the values for the negative premises as given by I. We denote pg(P , I)(⊥) by conseq P (I). Thus the intuitive conditions required of 3-stable models now amount to conseq P (I) = I.

Definition 15.3.5
Let P be a datalog¬ program. A 3-valued instance I over sch(P ) is a 3-stable model of P iff conseq P (I) = I.

Observe an important distinction between conseq P and the immediate consequence operator used for inflationary datalog¬. For inflationary datalog¬, we assumed that ¬A was true as long as A was not inferred. Here we just assume in such a case that A is unknown and try to prove new facts. Of course, doing so requires the 3-valued approach.

Example 15.3.6
Consider the following datalog¬ program P :
p ← ¬r
q ← ¬r, p
s ← ¬t
t ← q, ¬s
u ← ¬t, p, s
The program has three 3-stable models (represented by listing the positive and negative facts and leaving out the unknown facts):
I1 = {p, q, t, ¬r, ¬s, ¬u}
I2 = {p, q, s, ¬r, ¬t, ¬u}
I3 = {p, q, ¬r}
Let us check that I3 is a 3-stable model of P . The program P ′ = pg(P , I3) is
390
Negation in Datalog
p ← 1
q ← 1, p
s ← 1/2
t ← q, 1/2
u ← 1/2, p, s
The minimum 3-valued model of pg(P , I3) is obtained by iterating 3- TP ′(⊥) up to a fixpoint. Thus we start with ⊥ = {¬p, ¬q, ¬r, ¬s, ¬t, ¬u}. The first application of 3- TP ′ yields 3- TP ′(⊥) = {p, ¬q, ¬r, ¬t, ¬u}. Next ( 3- TP ′)2(⊥) = {p, q, ¬r, ¬t}. Finally ( 3- TP ′)3(⊥) = ( 3- TP ′)4(⊥) = {p, q, ¬r}. Thus
conseq P (I3) = pg(P , I3)(⊥) = ( 3- TP ′)3(⊥) = I3, and I3 is a 3-stable model of P .

The reader is invited to verify that in Example 15.3.1, the instance J is a 3-stable model of the program P win, K for the input instance K presented there.

As seen from the example, datalog¬ programs generally have several 3-stable models.

We will show later that each datalog¬ program has at least one 3-stable model. Therefore it makes sense to let the final answer consist of the positive and negative facts belonging to all 3-stable models of the program. As we shall see, the 3-valued instance so obtained is itself a 3-stable model of the program.

Definition 15.3.7
Let P be a datalog¬ program. The well-founded semantics of P is the 3-valued instance consisting of all positive and negative facts belonging to all 3-stable models of P . This is denoted by P wf (∅),or simply, P wf . Given datalog¬ program P and input instance I,
wf
P
(∅) is denoted P wf (I).

I
Thus the well-founded semantics of the program P in Example 15.3.6 is P wf (∅) =
{
wf
p, q, ¬r}. We shall see later that in Example 15.3.1, P
(K) = J.

win
A Fixpoint Definition
Note that the preceding description of the well-founded semantics, although effective, is inefficient. The straightforward algorithm yielded by this description involves checking all possible 3-valued instances of a program, determining which are 3-stable models, and then taking their intersection. We next provide a simpler, efficient way of computing the well-founded semantics. It is based on an “alternating fixpoint” computation that converges to the well-founded semantics. As a side-effect, the proof will show that each datalog¬
program has at least one 3-stable model (and therefore the well-founded semantics is always defined), something we have not proven. It will also show that the well-founded model is itself a 3-stable model, in some sense the smallest.

The idea of the computation is as follows. We define an alternating sequence {Ii}i≥0 of 3-valued instances that are underestimates and overestimates of the facts known in every
15.3 Well-Founded Semantics
391
3-stable model of P . The sequence is as follows:
I0
= ⊥
Ii+1 = conseq P (Ii).

Recall that ⊥ is the least 3-valued instance and that all facts have value 0 in ⊥. Also note that each of the Ii just defined is a total instance. This follows easily from the following facts (Exercise 15.17):
• if I is total, then conseq P (I) is total; and
• the Ii are constructed starting from the total instance ⊥ by repeated applications of conseq P .

The intuition behind the construction of the sequence {Ii}i≥0 is the following. The sequence starts with ⊥, which is an overestimate of the negative facts in the answer (it contains all negative facts). From this overestimate we compute I1 = conseq P (⊥), which includes all positive facts that can be inferred from ⊥. This is clearly an overestimate of the positive facts in the answer, so the set of negative facts in I1 is an underestimate of the negative facts in the answer. Using this underestimate of the negative facts, we compute I2 = conseq P (I1), whose positive facts will now be an underestimate of the positive facts in the answer. By continuing the process, we see that the even-indexed instances provide underestimates of the positive facts in the answer and the odd-indexed ones provide underestimates of the negative facts in the answer. Then the limit of the even-indexed instances provides the positive facts in the answer and the limit of the odd-indexed instances provides the negative facts in the answer. This intuition will be made formal later in this section.

It is easy to see that conseq P (I) is antimonotonic. That is, if I ≺ J, then conseq P (J) ≺
conseq P (I) (Exercise 15.17). From this and the facts that ⊥ ≺ I1 and ⊥ ≺ I2, it immediately follows that, for all i > 0,
I0 ≺ I2 . . . ≺ I2i ≺ I2i+2 ≺ . . . ≺ I2i+1 ≺ I2i−1 ≺ . . . ≺ I1.

Thus the even subsequence is increasing and the odd one is decreasing. Because there are finitely many 3-valued instances relative to a given program P , each of these sequences becomes constant at some point. Let I∗ denote the limit of the increasing sequence
{I2i}i≥0, and let I∗ denote the limit of the decreasing sequence {I2i+1}i≥0. From the aforementioned inequalities, it follows that I∗ ≺ I∗. Moreover, note that conseq P (I∗) = I∗ and conseq P (I∗) = I∗. Finally let I∗∗ denote the 3-valued instance consisting of the facts known in both I∗ and I∗; that is,
1
if I∗(A) = I∗(A) = 1
I∗∗(A) = 0
if I∗(A) = I∗(A) = 0 and
1/2
otherwise.

Equivalently, I∗∗ = (I∗)1 ∪ (I∗)0. As will be seen shortly, I∗∗ = P wf (∅). Before proving this, we illustrate the alternating fixpoint computation with several examples.

392
Negation in Datalog
Example 15.3.8
(a) Consider again the program in Example 15.3.6. Let us perform the alternating fixpoint computation described earlier. We start with I0 = ⊥ = {¬p, ¬q,
¬r, ¬s, ¬t, ¬u}. By applying conseq P , we obtain the following sequence of instances:
I1 = {p, q, ¬r, s, t, u},
I2 = {p, q, ¬r, ¬s, ¬t, ¬u},
I3 = {p, q, ¬r, s, t, u},
I4 = {p, q, ¬r, ¬s, ¬t, ¬u}.

Thus I∗ = I4 = {p, q, ¬r, ¬s, ¬t, ¬u} and I∗ = I3 = {p, q, ¬r, s, t, u}. Finally I∗∗ = {p, q, ¬r}, which coincides with the well-founded semantics of P computed in Example 15.3.6.

(b) Recall now P win and input K of Example 15.3.1. We compute I∗∗ for the program P win, I. Note that for I0 the value of all move atoms is false, and for each j ≥ 1, Ij agrees with the input K on the predicate moves; thus we do not show the move atoms here. For the win predicate, then, we have
I1 = { win(a), win(b), win(c), win(d), ¬ win(e), win(f ), ¬ win(g)}
I2 = {¬ win(a), ¬ win(b), ¬ win(c), win(d), ¬ win(e), win(f ), ¬ win(g)}
I3 = I1
I4 = I2.

Thus
I∗ = I2 = {¬ win(a), ¬ win(b), ¬ win(c), win(d), ¬ win(e), win(f ), ¬ win(g)}
I∗ = I1 = { win(a), win(b), win(c), win(d), ¬ win(e), win(f ), ¬ win(g)}
I∗∗ = { win(d), ¬ win(e), win(f ), ¬ win(g)}, which is the instance J of Example 15.3.1.

(c) Consider the database schema consisting of a binary relation G and a unary relation good and the following program defining bad and answer: bad(x)
← G(y, x), ¬ good(y)
answer(x) ← ¬ bad(x)
Consider the instance K over G and good, where
K(G)
= {b, c, c, b, c, d, a, d, a, e}, and
K( good) = {a}.

We assume that the facts of the database are added as unit clauses to P , yielding PK. Again we perform the alternating fixpoint computation for PK. We start with
15.3 Well-Founded Semantics
393
I0 = ⊥ (containing all negated atoms). Applying conseq P yields the following K
sequence {Ii}i>0:
bad
answer
I0
∅
∅
I1
{¬a, b, c, d, e}
{a, b, c, d, e}
I2
{¬a, b, c, d, ¬e}
{a, ¬b, ¬c, ¬d, ¬e}
I3
{¬a, b, c, d, ¬e}
{a, ¬b, ¬c, ¬d, e}
I4
{¬a, b, c, d, ¬e}
{a, ¬b, ¬c, ¬d, e}
We have omitted [as in (b)] the facts relating to the edb predicates G and good, which do not change after step 1.

Thus I∗∗ = I∗ = I∗ = I3 = I4. Note that P is stratified and its well-founded semantics coincides with its stratified semantics. As we shall see, this is not accidental.

We now show that the fixpoint construction yields the well-founded semantics for datalog¬ programs.

Theorem 15.3.9
For each datalog¬ program P ,
1. I∗∗ is a 3-stable model of P .

2. P wf (∅) = I∗∗.

Proof
For statement 1, we need to show that conseq P (I∗∗) = I∗∗. We show that for every fact A, if I∗∗(A) = ǫ ∈ {0, 1/2, 1}, then conseq P (I∗∗)(A) = ǫ. From the antimonotonicity of conseq P , the fact that I∗ ≺ I∗∗ ≺ I∗ and conseq P (I∗) = I∗, conseq P (I∗) = I∗, it follows that I∗ ≺ conseq P (I∗∗) ≺ I∗. If I∗∗(A) = 0, then I∗(A) = 0 so conseq P (I∗∗)(A) = 0; similarly for I∗∗(A) = 1. Now suppose that I∗∗(A) = 1/2. It is sufficient to prove that conseq P (I∗∗)(A) ≥
1/2. [It is not possible that conseq P (I∗∗)(A) = 1. If this were the case, the rules used to infer A involve only facts whose value is 0 or 1. Because those facts have the same value in I∗ and I∗, the same rules can be used in both pg(P , I∗) and pg(P , I∗) to infer A, so I∗(A) = I∗(A) = I∗∗(A) = 1, which contradicts the hypothesis that I∗∗(A) = 1/2.]
We now prove that conseq P (I∗∗)(A) ≥ 1/2. By the definition of I∗∗, I∗(A) = 0 and I∗(A) = 1. Recall that conseq P (I∗) = I∗, so conseq P (I∗)(A) = 1. In addition, conseq P (I∗) is the limit of the sequence { 3- T i
}
pg(P , I∗) i>0. Let stage(A) be the minimum i such that 3- T i
(A) = 1. We prove by induction on stage(A) that conseq
pg(P , I∗)
P (I∗
∗)(A) ≥ 1/2. Sup-
pose that stage(A) = 1. Then there exists in ground(P ) a rule of the form A ←, or one of the form A ← ¬B1, . . . , ¬Bn, where I∗(Bj ) = 0, 1 ≤ j ≤ n. However, the first case cannot occur, for otherwise conseq P (I∗)(A) must also equal 1 so I∗(A) = 1 and therefore I∗∗(A) = 1, contradicting the fact that I∗∗(A) = 1/2. By the same argument, I∗(Bj ) = 1, so I∗∗(Bj) = 1/2, 1 ≤ j ≤ n. Consider now pg(P , I∗∗). Because I∗∗(Bj) =
394
Negation in Datalog
1/2, 1 ≤ j ≤ n, the second rule yields conseq P (I∗∗)(A) ≥ 1/2. Now suppose that the statement is true for stage(A) = i and suppose that stage(A) = i + 1. Then there exists a rule A ← A1 . . . Am¬B1 . . . ¬Bn such that I∗(Bj ) = 0 and 3- T i (A
pg(P , I∗)
k) = 1 for each j and
k. Because I∗(Bj ) = 0, I∗∗(Bj) ≤ 1/2 so I∗∗(¬Bj) ≥ 1/2. In addition, by the induction hypothesis, conseq P (I∗∗)(Ak) ≥ 1/2. It follows that conseq P (I∗∗)(A) ≥ 1/2, and the induction is complete. Thus conseq P (I∗∗) = I∗∗ and I∗∗ is a 3-stable model of P .

Consider statement 2. We have to show that the positive and negative facts in I∗∗ are those belonging to every 3-stable model M of P . Because I∗∗ is itself a 3-stable model of P , it contains the positive and negative facts belonging to every 3-stable model of P . It remains to show the converse (i.e., that the positive and negative facts in I∗∗ belong to every 3-stable model of P ). To this end, we first show that for each 3-stable model M of P and i ≥ 0,
(‡)
I2i ≺ M ≺ I2i+1.

The proof is by induction on i. For i = 0, we have
I0 = ⊥ ≺ M.

Because conseq P is antimonotonic, conseq P (M) ≺ conseq P (I0). Now conseq P (I0) = I1
and because M is 3-stable, conseq P (M) = M. Thus we have I0 ≺ M ≺ I1.

The induction step is similar and is omitted.

By (‡), I∗ ≺ M ≺ I∗. Now a positive fact in I∗∗ is in I∗ and so is in M because I∗ ≺ M.

Similarly, a negative fact in I∗∗ is in I∗ and so is in M because M ≺ I∗.

Note that the proof of statement 2 above formalizes the intuition that the I2i provide underestimates of the positive facts in all acceptable answers (3-stable models) and the I2i+1 provide underestimates of the negative facts in those answers. The fact that P wf (∅) is a minimal model of P is left for Exercise 15.19.

Variations of the alternating fixpoint computation can be obtained by starting with initial instances different from ⊥. For example, it may make sense to start with the content of the edb relations as an initial instance. Such variations are sometimes useful for technical reasons. It turns out that the resulting sequences still compute the well-founded semantics.

We show the following:
Proposition 15.3.10
Let P be a datalog¬ program. Let {Ii}i≥0 be defined in the same way as the sequence {Ii}i≥0, except that I0 is some total instance such that
⊥ ≺ I0 ≺ P wf (∅).

Then
15.3 Well-Founded Semantics
395
I0 ≺ I2 . . . ≺ I2i ≺ I2i+2 ≺ . . . ≺ I2i+1 ≺ I2i−1 ≺ . . . ≺ I1
and (using the same notation as before),
∗
I∗ = P wf (∅).

Proof
Let us compare the sequences {Ii}i≥0 and {Ii}i≥0. Because I0 ≺ P wf (∅) and I0 is total, it easily follows that I0 ≺ I∗. Thus ⊥ = I0 ≺ I0 ≺ I∗. From the antimonotonicity of the conseq P operator and the fact that conseq 2 (I P
∗) = I∗, it follows that I2i ≺ I2i ≺ I∗ for all i, i ≥ 0. Thus I∗ = I∗. Then
∗
I = conseq P (I∗) = conseq P (I∗) = I∗
∗
so I∗ = I∗∗ = P wf (∅).

As noted earlier, the instances in the sequence {Ii}i≥0 are total. A slightly different alternating fixpoint computation formulated only in terms of positive and negative facts can be defined. This is explored in Exercise 15.25.

Finally, the alternating fixpoint computation of the well-founded semantics involves looking at the ground rules of the given program. However, one can clearly compute the semantics without having to explicitly look at the ground rules. We show in Section 15.4
how the well-founded semantics can be computed by a fixpoint query.

Well-Founded and Stratified Semantics Agree
Because the well-founded semantics provides semantics to all datalog¬ programs, it does so in particular for stratified programs. Example 15.3.8(c) showed one stratified program for which stratified and well-founded semantics coincide. Fortunately, as shown next, stratified and well-founded semantics are always compatible. Thus if a program is stratified, then the stratified and well-founded semantics agree.

A datalog¬ program P is said to be total if P wf (I) is total for each input I over edb(P ).

Theorem 15.3.11
If P is a stratified datalog¬ program, then P is total under the well-founded semantics, and for each 2-valued instance I over edb(P ), P wf (I) = P strat(I).

Proof
Let P be stratified, and let input I0 over edb(P ) be fixed. The idea of the proof is the following. Let J be a 3-stable model of PI . We shall show that J = P strat(I 0
0). This will
imply that P strat(I0) is the unique 3-stable model for PI . In particular, it contains only the 0
positive and negative facts in all 3-stable models of PI and is thus P wf (I 0
0).

For the proof, we will need to develop some notation.

Notation for the stratification: Let P 1, . . . , P n be a stratification of P . Let P 0 = ∅I (i.e., 0
the program corresponding to all of the facts in I0). For each k in [0, n], let Sk = idb(P k) (S0 is edb(P ));
S[0,k] = ∪i∈[0,k]Si; and
396
Negation in Datalog
Ik = (P 1 ∪ · · · ∪ P k) strat(I0) = In|S[0,k] (and, in particular, P strat(I0) = In).

Notation for the 3-stable model: Let ˆ
P = pg(PI , J). Recall that because J is 3-stable for 0
PI ,
0
J = conseq ˆ (J) = lim 3-T i (∅).

P
î≥0
P
For each k in [0, n],
• let Jk = J|S[0,k]; and
• ˆ
P k+1 = pg(P k+1, J
, J).

J
k) = pg(P k+1
k
Jk
[Note that pg(P k+1, J
, J) because all the negations in P k+1 are over predi-
J
k) = pg(P k+1
k
Jk
cates in S[0,k].]
To demonstrate the result, we will show by induction on k ∈ [0, n] that (*)
∃lk ≥ 0 such that ∀i ≥ 0, Jk = 3- T lk+i(∅) | S
ˆ
[0,k] = Ik.

P
Clearly, for k = n, (*) demonstrates the result.

The case where k = 0 is satisfied by setting l0 = 1, because J0 = 3-T 1+i(∅)|S
ˆ
0 = I0
P
for each i ≥ 0.

Suppose now that (*) is true for some k ∈ [0, n − 1]. Then for each i ≥ 0, by the choice of ˆ
P k+1, the form of P k+1, and (*),
(1)
T i
(∅)|S
(I
P k+1(Ik)|Sk+1 ⊆ 3-T i+1
ˆ
k+1 ⊆ T i+1
k)|Sk+1.

P k+1
P k+1
(Here and later, ⊆ denotes the usual 2-valued containment between instances; this is well defined because all instances considered are total, even if J is not.) In (1), the 3- T i+1
ˆ
P k+1
and T i+1 terms may not be equal, because the positive atoms of I P k+1
k = Jk are available
when applying TPk+1 the first time but are available only during the second application of 3- T ând 3- T i+1 terms may not be equal (e.g., if there is P k+1. On the other hand, the T i
P k+1
ˆ
P k+1
a rule of the form A ← in P k+1).

By (1) and finiteness of the input, there is some m ≥ 0 such that for each i ≥ 0, (2)
In|Sk+1 = T m+i (I
(∅)|S
P k+1
k)|Sk+1 = 3-T m+i
ˆ
k+1.

P k+1
This is almost what is needed to complete the induction, except that ˆ
P k+1 is used instead
of ˆ
P . However, observe that for each i ≥ 0,
(3)
3-T iˆ (∅)|Sk+1 ⊆ 3-T i
(∅)|Sk+1
P
ˆ
P k+1
because 3-T i (∅)|S
ˆ
[0,k] ⊆ Jk for each i ≥ 0 by the induction hypothesis. Finally observe P
that for each i ≥ 0,
(4)
3-T iˆ
(∅)|Sk+1 ⊆ 3-T i+lk(∅)|Sk+1
P k+1
ˆ
P
15.4 Expressive Power
397
because 3-T lk(∅)|S
ˆ
[0,k] contains all of the positive atoms of Jk.

P
Then for each i ≥ 0 we have
3-T m+i (∅)|S
(∅)|S
ˆ
k+1 ⊆ 3-T m+i+lk
k+1
by (4)
P k+1
ˆ
P
⊆ 3-T m+i+lk(∅)|S
ˆ
k+1
by (3)
P k+1
⊆ 3-T m+i (∅)|S
ˆ
k+1
by (2).

P k+1
It follows that
(5)
3-T m+i (∅)|S
(∅)|S
ˆ
k+1 = 3-T m+i+lk
k+1.

P k+1
ˆ
P
Set l(k+1) = lk + m. Combining (2) and (5), we have, for each i ≥ 0, l
J|S
(k+1)+i
k+1 = 3-T
(∅)|S
ˆ
k+1 = In|Sk+1.

P
Together with the inductive hypothesis, we obtain for each i ≥ 0 that l
J|S
(k+1)+i
[0,k+1] = 3-T
(∅)|S
ˆ
[0,k+1] = In|S[0,k+1],
P
which concludes the proof.

As just seen, each stratifiable program is total under the well-founded semantics. However, as indicated by Example 15.3.8(b), a datalog¬ program P may yield a 3-valued model P wf (I) on some inputs. Furthermore, there are programs that are not stratified but whose well-founded models are nonetheless total (see Exercise 15.22). Unfortunately, there can be no effective characterization of those datalog¬ programs whose well-founded semantics is total for all input databases (Exercise 15.23). One can find sufficient syntactic conditions that guarantee the totality of the well-founded semantics, but this quickly becomes a tedious endeavor. It has been shown, however, that for each datalog¬ program P , one can find another program whose well-founded semantics is total on all inputs and that produces the same positive facts as the well-founded semantics of P .

15.4
Expressive Power
In this section, we examine the expressive power of datalog¬ with the various semantics for negation we have considered. More precisely, we focus on semipositive, stratified, and well-founded semantics. We first look at the relative power of these semantics and show that semipositive programs are weaker than stratified, which in turn are weaker than well founded. Then we look at the connection with languages studied in Chapter 14 that also use recursion and negation. We prove that well-founded semantics can express precisely the fixpoint queries.

Finally we look at the impact of order on expressive power. An ordered database contains a special binary relation succ that provides a successor relation on all constants
398
Negation in Datalog
in the active domain. Thus the constants are ordered by succ and in fact can be viewed as integers. The impact of assuming that a database is ordered is examined at length in Chapter 17. Rather surprisingly, we show that in the presence of order, semipositive programs are as powerful as programs with well-founded semantics. In particular, all three semantics are equivalent and express precisely the fixpoint queries.

We begin by briefly noting the connection between stratified datalog¬ and relational calculus (and algebra). To see that stratified datalog¬ can express all queries in CALC, recall the nonrecursive datalog¬ (nr-datalog¬) programs introduced in Chapter 5. Clearly, these are stratified datalog¬ programs in which recursion is not allowed. Theorem 5.3.10
states that nr-datalog¬ (with one answer relation) and CALC are equivalent. It follows that stratified datalog¬ can express all of CALC. Because transitive closure of a graph can be expressed in stratified datalog¬ but not in CALC (see Proposition 17.2.3), it follows that stratified datalog¬ is strictly stronger than CALC.

Stratified Datalog Is Weaker than Fixpoint
Let us look at the expressive power of stratified datalog¬. Computationally, stratified programs provide recursion and negation and are inflationary. Therefore one might expect that they express the fixpoint queries. It is easy to see that all stratified datalog¬ are fixpoint queries (Exercise 15.28). In particular, this shows that such programs can be evaluated in polynomial time. Can stratified datalog¬ express all fixpoint queries? Unfortunately, no.

The intuitive reason is that in stratified datalog¬ there is no recursion through negation, so the number of applications of negation is bounded. In contrast, fixpoint queries allow recursion through negation, so there is no bound on the number of applications of negation.

This distinction turns out to be crucial. We next outline the main points of the argument, showing that stratified datalog¬ is indeed strictly weaker than fixpoint.

The proof uses a game played on so-called game trees. The game is played on a given tree. The nodes of the tree are the possible positions in the game, and the edges are the possible moves from one position to another. Additionally, some leaves of the tree are labeled black. The game is between two players. A round of the game starting at node x begins with Player I making a move from x to one of its children y. Player II then makes a move from y, etc. The game ends when a leaf is reached. Player I wins if Player II picks a black leaf. For a given tree (with labels), Player I has a winning strategy for the game starting at node x if he or she can win starting at x no matter how Player II plays. We are interested in programs determining whether there is such a winning strategy.

The game tree is represented as follows. The set of possible moves is given by a binary relation move and the set of black nodes by a unary relation black. Consider the query winning (not to be confused with the predicate win of Example 15.3.1), which asks if Player I has a winning strategy starting at the root of the tree. We will define a set of game trees G
such that
(i) the query winning on the game trees in G is definable by a fixpoint query, and (ii) for each stratified program P , there exist game trees G, G′ ∈ G such that winning is true on G and false on G′, but P cannot distinguish between G and G′.

Clearly, (ii) shows that the winning query on game trees is not definable by a stratified
15.4 Expressive Power
399
datalog¬ program. The set G of game trees is defined next. It consists of the Gl,k and G′l,k defined by induction as follows:
• G0,k and G′ have no moves and just one node, labeled black in G
0,k
0,k and not labeled
in G′ .

0,k
• Gi+1,k consists of a copy of G′ , k disjoint copies of G
i,k
i,k, and a new root di+1. The
moves are the union of the moves in the copies of G′
and G
i,k
i,k together with new
moves from the root di+1 to the roots of the copies. The labels remain unchanged.

• G′
consists of k + 1 disjoint copies of G
from which
i+1,k
i,k and a new root d ′i+1
moves are possible to the roots of the copies of Gi,k.

The game trees G4,1 and G′ are represented in Fig. 15.2. It is easy to see that winning 4,1
is true on the game trees G2i,k and false on game trees G′
, i > 0 (Exercise 15.30).

2i,k
We first note that the query winning on game trees in G can be defined by a fixpoint query. Consider
ϕ(T ) = (∃y)[ Move(x, y) ∧ (∀z)( Move(y, z) → Black(z))]
∨ (∃y)[ Move(x, y) ∧ (∀z)( Move(y, z) → T (z))].

Root
G 4.1
Root
G′4.1
Figure 15.2:
Game trees
400
Negation in Datalog
It is easy to verify that winning is defined by µT (ϕ(T ))( root), where root is the root of the game tree (Exercise 15.30). Next we note that the winning query is not expressible by any stratified datalog¬ program. To this end, we use the following result, stated without proof.

Lemma 15.4.1
For each stratified datalog¬ program P , there exist i, k such that P (Gi,k)( winning) = P (G′i,k)( winning).

The proof of Lemma 15.4.1 uses an extension of Ehrefeucht-Fraissé games (the games are described in Chapter 17). The intuition of the lemma is that, to distinguish between Gi,k and G′
for i and k sufficiently large, one needs to apply more negations than the i,k
fixed number allowed by P . Thus no stratified program can distinguish between all the Gi,k and G′ . In particular, it follows that the fixpoint query winning is not equivalent to i,k
any stratified datalog¬ program. Thus we have the following result, settling the relationship between stratified datalog¬ and the fixpoint queries.

Theorem 15.4.2
The class of queries expressible by stratified datalog¬ programs is strictly included in the fixpoint queries.

Remark 15.4.3
The game tree technique can also be used to prove that the number of strata in stratified datalog¬ programs has an impact on expressive power. Specifically, let Strat i consist of all queries expressible by stratified datalog¬ programs with i strata. Then it can be shown that for all i, Strat i ⊂ Strat i+1. In particular, semipositive datalog¬ is weaker than stratified datalog¬.

Well-Founded Datalog¬ Is Equivalent to Fixpoint
Next we consider the expressive power of datalog¬ programs with well-founded semantics.

We prove that well-founded semantics can express precisely the fixpoint queries. We begin by showing that the well-founded semantics can be computed by a fixpoint query. More precisely, we show how to compute the set of false, true, and undefined facts of the answer using a while+ program (see Chapter 14 for the definition of while+ programs).

Theorem 15.4.4
Let P be a datalog¬ program. There exists a while+ program w with input relations edb(P ), such that
1. w contains, for each relation R in sch(P ), three relation variables Rǫ
, where
answer
ǫ ∈ {0, 1/2, 1};
2. for each instance I over edb(P ), u ∈ w(I)(Rǫ answer) iff P wf (I)(R(u)) = ǫ, for ǫ ∈ {0, 1/2, 1}.

Crux
Let P be a datalog¬ program. The while+ program mimics the alternating fixpoint computation of P wf . Recall that this involves repeated applications of the operator conseq P , resulting in the sequence
15.4 Expressive Power
401
I0 ≺ I2 . . . ≺ I2i ≺ I2i+2 ≺ . . . ≺ I2i+1 ≺ I2i−1 ≺ . . . ≺ I1.

Recall that the Ii are all total instances. Thus 3-valued instances are only required to produce the final answer from I∗ and I∗ at the end of the computation, by one last first-order query.

It is easily verified that while+ can simulate one application of conseq P on total instances (Exercise 15.27). The only delicate point is to make sure the computation is inflationary. To this end, the program w will distinguish between results of even and odd iterations of conseq P by having, for each R, an odd and even version R0 and R1 . R0
odd
even
odd
holds at iteration 2i + 1 the negative facts of R in I2i+1, and R1
holds at iteration 2
even
i
the positive facts of R in I2i. Note that both R0
and R1
are increasing throughout the
odd
even
computation.

We elaborate on the simulation of the operator conseq P on a total instance I. The program w will have to distinguish between facts in the input I, used to resolve the negative premises of rules in P , and those inferred by applications of 3- TP . Therefore for each relation R, the while+ program will also maintain a copy ¯
R even and ¯
R odd to hold the facts
produced by consecutive applications of 3- TP in the even and odd cases, respectively. More precisely, the ¯
R odd hold the positive facts inferred from input I2i represented in R1 , and even
the ¯
R even hold the positive facts inferred from input I2i+1 represented in R0 . It is easy odd
to write a first-order query defining one application of 3- TP for the even or odd cases.

Because the representations of the input are different in the even and odd cases, different programs must be used in the two cases. This can be iterated in an inflationary manner, because the set of positive facts inferred in consecutive applications of 3- TP is always increasing. However, the ¯
R odd and ¯
R even have to be initialized to ∅ at each application
of conseq P . Because the computation must be inflationary, this cannot be done directly.

Instead, timestamping must be used. The initialization of the ¯
R odd and ¯
R even is simulated
by timestamping each relation with the current content of R1
and
, respectively. This
even
R0 odd
is done in a manner similar to the proofs of Chapter 14.

We now exhibit a converse of Theorem 15.4.4, showing that any fixpoint query can essentially be simulated by a datalog¬ program with well-founded semantics. More precisely, the positive portion of the well-founded semantics yields the same facts as the fixpoint query.

Example 15.4.6 illustrates the proof of this result.

Theorem 15.4.5
Let q be a fixpoint query over input schema R. There exists a datalog¬
program P such that edb(P ) = R, P has an idb relation answer, and for each instance I over R, the positive portion of answer in P wf (I) coincides with q(I).

Crux
We will use the definition of fixpoint queries by iterations of positive first-order formulas. Let q be a fixpoint query. As discussed in Chapter 14, there exists a CALC
formula ϕ(T ), positive in T , such that q is defined by µT (ϕ(T ))(u), where u is a vector of variables and constants. Consider the CALC formula ϕ(T ). As noted earlier in this section, there is an nr-datalog¬ program Pϕ with one answer relation R′ such that Pϕ is equivalent
402
Negation in Datalog
to ϕ(T ). Because ϕ(T ) is positive in T , along any path in the syntax tree of ϕ(T ) ending with atom T there is an even number of negations. This is also true of paths in GP .

ϕ
Consider the precedence graph GP of P
ϕ
ϕ. Clearly, one can construct Pϕ such that
each idb relation except T is used in the definition of exactly one other idb relation, and all idb relations are used eventually in the definition of the answer R′. In other words, for each idb relation R other than T , there is a unique path in GP from R to R′. Consider the ϕ
paths from T to some idb relation R in Pϕ. Without loss of generality, we can assume that all paths have the same number of negations (otherwise, because all paths to T have an even number of negations, additional idb relations can be introduced to pad the paths with fewer negations, using rules that perform redundant double negations). Let the rank of an idb relation R in Pϕ be the number of negations on each path leading from T to R in GP .

ϕ
Now let P be the datalog¬ program obtained from Pϕ as follows:
• replace the answer relation R′ by T ;
• add one rule answer(v) ← T (u), where v is the vector of distinct variables occurring in u, in order of occurrence.

The purpose of replacing R′ by T is to cause program Pϕ to iterate, yielding µT (ϕ(T )).

The last rule is added to perform the final selection and projection needed to obtain the answer µT (ϕ(T ))(u). Note that, in some sense, P is almost stratified, except for the fact that the result T is fed back into the program.

Consider the alternating fixpoint sequence {Ii}i≥0 in the computation of P wf (I). Suppose R′ has rank q in Pϕ, and let R be an idb relation of Pϕ whose rank in Pϕ is r ≤ q.

Intuitively, there is a close correspondence between the sequence {Ii}i≥0 and the iterations of ϕ, along the following lines: Each application of conseq P propagates the correct result from relations of rank r in Pϕ to relations of rank r + 1. There is one minor glitch, however: In the fixpoint computation, the edb relations are given, and even at the first iteration, their negation is taken to be their complement; in the alternating fixpoint computation, all negative literals, including those involving edb relations, are initially taken to be true. This results in a mismatch. To fix the problem, consider a variation of the alternating fixpoint computation of P wf (I) defined as follows:
I0
= I ∪ ¬.{R(a1, . . . , an) | R ∈ idb(P ), R(a1, . . . , an) ∈ B(P , I)}
Ii+1 = conseq P (Ii).

∗
Clearly, ⊥ ≺ I0 ≺ P wf (I). Then, by Proposition 15.3.10, I∗ = P wf (I).

Now the following can be verified by induction for each idb relation R of rank r: For each i, (Iiq+r)1 contains exactly the facts of R true in Pϕ(ϕi(∅)).

Intuitively, this is so because each application of conseq P propagates the correct result across one application of negation to an idb predicate. Because R′ has rank q, it takes q applications to simulate a complete application of Pϕ. In particular, it follows that for each i, (Iiq)1 contains in T the facts true in ϕi(∅).

Thus (I∗)1 contains in T the facts true in µT (ϕ(T )). Finally answer is obtained by a simple selection and projection from T using the last rule in P and yields µT (ϕ(T ))(u).

15.4 Expressive Power
403
In the preceding theorem, the positive portion of answer for P wf (I) coincides with q(I). However, P wf (I) is not guaranteed to be total (i.e., it may contain unknown facts).

Using a recent result (not demonstrated here), a program Q can be found such that Qwf always provides a total answer, and such that the positive facts of P wf and Qwf coincide on all inputs.

Recall from Chapter 14 that datalog¬ with inflationary semantics also expresses precisely the fixpoint queries. Thus we have converged again, this time by the deductive database path, to the fixpoint queries. This bears witness, once more, to the naturalness of this class. In particular, the well-founded and inflationary semantics, although very different, have the same expressive power (modulo the difference between 3-valued and 2-valued models).

Example 15.4.6
Consider the fixpoint query µ good(ϕ( good))(x), where ϕ( good) = ∀y(G(y, x) → good(y)).

Recall that this query, also encountered in Chapter 14, computes the “good” nodes of the graph G (i.e., those that cannot be reached from a cycle). The nr-datalog¬ program Pϕ
corresponding to one application of ϕ( good) is the one exhibited in Example 15.3.8(c): bad(x) ← G(y, x), ¬ good(y)
R′(x) ← ¬ bad(x)
Note that bad is negative in Pϕ and has rank one, and good is positive. The answer R′ has rank two. The program P is as follows:
bad(x)
← G(y, x), ¬ good(y)
good(x)
← ¬ bad(x)
answer(x) ← good(x)
Consider the input graph
G = {b, c, c, b, c, d, a, d, a, e}.

The consecutive values of ϕi(∅) are
ϕ(∅) = {a},
ϕ2(∅) = {a, e},
ϕ3(∅) = {a, e}.

Thus µ good(ϕ( good))(x) yields the answer {a, e}. Consider now the alternating fixpoint sequence in the computation of P wf on the same input (only the positive facts of bad and good are listed, because G does not change and answer = good).

404
Negation in Datalog
bad
good
I0
∅
∅
I1
{b, c, d, e}
{a, b, c, d, e}
I2
∅
{a}
I3
{b, c, d}
{a, b, c, d, e}
I4
∅
{a, e}
I5
{b, c, d}
{a, b, c, d, e}
I6
∅
{a, e}
Thus
ϕ(∅) = (I2)1( good),
ϕ2(∅) = (I4)1( good)
and
(I4)1( answer) = µ good(ϕ( good))(x).

The relative expressive power of the various languages discussed in this chapter is summarized in Fig. 15.3. The arrows indicate strict inclusion. For a view of these languages in a larger context, see also Figs. 18.4 and 18.5 at the end of Part E.

The Impact of Order
Finally we look at the impact of order on the expressive power of the various datalog¬
semantics. As we will discuss at length in Chapter 17, the assumption that databases are ordered can have a dramatic impact on the expressive power of languages like fixpoint or while. The datalog¬ languages are no exception. The effect of order is spectacular.

With this assumption, it turns out that semipositive datalog¬ is (almost) as powerful as stratified datalog¬ and datalog¬ with well-founded semantics. The “almost” comes from a well-founded semantics datalog¬ ≡ fixpoint semantics datalog¬
⇑
stratified datalog¬
⇑
semipositive datalog¬
⇑
datalog
Figure 15.3:
Relative expressive power of datalog(¬) languages
15.4 Expressive Power
405
technicality concerning the order: We also need to assume that the minimum and maximum constants are explicitly given. Surprisingly, these constants, which can be computed with a first order query if succ is given, cannot be computed with semipositive programs (see Exercise 15.29).

The next lemma states that semipositive programs express the fixpoint queries on ordered databases with min and max (i.e., databases with a predicate succ providing a successor relation among all constants, and unary relations min and max containing the smallest and the largest constant).

Lemma 15.4.7
The semipositive datalog¬ programs express precisely the fixpoint queries on ordered databases with min and max.

Crux
Let q be a fixpoint query over database schema R. Because q is a fixpoint query, there is a first-order formula ϕ(T ), positive in T , such that q is defined by µT (ϕ(T ))(u), where u is a vector of variables and constants. Because T is positive in ϕ(T ), we can assume that ϕ(T ) is in prenex normal form Q1x1Q2x2 . . . Qkxk(ψ), where ψ is a quantifier free formula in disjunctive normal form and T is not negated in ψ. We show by induction on k that there exists a semipositive datalog¬ program Pϕ with an idb relation answer ϕ
defining µT (ϕ(T )) [the last selection and projection needed to obtain the final answer µT (ϕ(T ))(u) pose no problem]. Suppose k = 0 (i.e., ϕ = ψ). Then Pϕ is the nr-datalog¬
program corresponding to ψ, where the answer relation is T . Because ψ is quantifier free and T is not negated in ψ, Pϕ is clearly semipositive. Next suppose the statement is true for some k ≥ 0, and let ϕ(T ) have quantifier depth k + 1. There are two cases: (i) ϕ = ∃xψ(x, v), where ψ has quantifier depth k. Then Pϕ contains the rules of Pψ, where T is replaced in heads of rules by a new predicate T ′ and one additional rule
T (v) ← T ′(x, v).

(ii) ϕ = ∀xψ(x, v), where ψ has quantifier depth k. Then Pϕ consists, again, of Pψ, where T is replaced in heads of rules by a new predicate T ′, with the following rules added:
R′(x, v) ← T ′(x, v), min(x)
R′(x′, v) ← R′(x, v), succ(x, x′), T ′(x′, v)
T (v)
← R′(x, v), max(x),
where R′ is a new auxiliary predicate. Thus the program steps through all x’s using the successor relation succ, starting from the minimum constant. If the maximum constant is reached, then T ′(x, v) is satisfied for all x, and T (v) is inferred.

This completes the induction.

As we shall see in Chapter 17, fixpoint expresses on ordered databases exactly the
406
Negation in Datalog
queries computable in time polynomial in the size of the database (i.e., qptime). Thus we obtain the following result. In comparing well-founded semantics with the others, we take the positive portion of the well-founded semantics as the answer.

Theorem 15.4.8
Stratified datalog¬ and datalog¬ with well-founded semantics are
equivalent on ordered databases and express exactly qptime. They are also equivalent to semipositive datalog¬ on ordered databases with min and max and express exactly qptime.

15.5
Negation as Failure in Brief
In our presentation of datalog in Chapter 12, we saw that the minimal model and least fixpoint semantics have an elegant proof-theoretic counterpart based on SLD resolution.

One might naturally wonder if such a counterpart exists in the case of datalog¬. The answer is yes and no. Such a proof-theoretic approach has indeed been proposed and is called negation as failure. This was originally developed for logic programming and predates stratified and well-founded semantics. Unfortunately, the approach has two major drawbacks. The first is that it results in a proof-building procedure that does not always terminate. The second is that it is not the exact counterpart of any other existing semantics.

The semantics that has been proposed as a possible match is “Clark’s completion,” but the match is not perfect and Clark’s completion has its own problems. We provide here only a brief and informal presentation of negation as failure and the related Clark’s completion.

The idea behind negation as failure is simple. We would like to infer a negative fact
¬A if A cannot be proven by SLD resolution. Thus ¬A would then be proven by the failure to prove A. Unfortunately, this is generally noneffective because SLD derivations may be arbitrarily long, and so one cannot check in finite time2 that there is no proof of A by SLD
resolution. Instead we have to use a weaker notion of negation by failure, which can be checked. This is done as follows. A fact ¬A is proven if all SLD derivations starting from the goal ← A are finite and none produces an SLD refutation for ← A. In other words, A finitely fails. This procedure applies to ground atoms A only. It gives rise to a proof procedure called SLDNF resolution. Briefly, SLDNF resolution extends SLD resolution as follows. Refutations of positive facts proceed as for SLD resolution. Whenever a negative ground goal ← ¬A has to be proven, SLD resolution is applied to ← A, and ¬A is proven if the SLD resolution finitely fails for ← A. The idea of SLDNF seems appealing as the proof-theoretic version of the closed world assumption. However, as illustrated next, it quickly leads to significant problems.

Example 15.5.1
Consider the usual program P TC for transitive closure of a graph: T (x, y) ← G(x, y)
T (x, y) ← G(x, z), T (z, y)
2 Because databases are finite, one can develop mechanisms to bound the expansion. We ignore this aspect here.

15.5 Negation as Failure in Brief
407
Consider the instance I where G has edges {a, b, b, a, c, a}. Clearly, {a, c} is not in the transitive closure of G, and so not in T , by the usual datalog semantics. Suppose we wish to prove the fact ¬T (a, c), using negation as failure. We have to show that SLD
resolution finitely fails on T (a, c), with the preceding program and input. Unfortunately, SLD resolution can enter a negative loop when applied to ← T (a, c). One obtains the following SLD derivation:
1. ← T (a, c);
2. ← G(a, z), T (z, c), using the second rule;
3. ← T (b, c), using the fact G(a, b);
4. ← G(b, z), T (z, c) using the second rule;
5. ← T (a, c) using the fact G(b, a).

Note that the last goal is the same as the first, so this can be extended to an infinite derivation. It follows that SLD resolution does not finitely fail on ← T (a, c), so SLDNF
does not yield a proof of ¬T (a, c). Moreover, it has been shown that this does not depend on the particular program used to define transitive closure. In other words, there is no datalog¬ program that under SLDNF can prove the positive and negative facts true of the transitive closure of a graph.

The preceding example shows that SLDNF can behave counterintuitively, even in some simple cases. The behavior is also incompatible with all the semantics for negation that we have discussed so far. Thus one cannot hope for a match between SLDNF and these semantics.

Instead a semantics called Clark’s completion has been proposed as a candidate match for negation as failure. It works as follows. For a datalog¬ program P , the completion of P, comp(P), is constructed as follows. For each idb predicate R, each rule ρ : R(u) ← L1(v1), . . . , Ln(vn)
defining R is rewritten so there is a uniform set of distinct variables in the rule head and so all free variables in the body are existentially quantified:
ρ′ : R(u′) ← ∃v′(x1 = t1 ∧ · · · ∧ xk = tk ∧ L1(v1) ∧ · · · ∧ Ln(vn)).

(If the head of ρ has distinct variables for all coordinates, then the equality atoms can be avoided. If repeated variables or constants occur, then equality must be used.) Next, if the rewritten rules for R are ρ′ , . . . , ρ′, the completion of R is formed by 1
l
∀u′(R(u′) ↔ body(ρ′1) ∨ · · · ∨ body(ρ′l)).

Intuitively, this states that ground atom R(w) is true iff it is supported by one of the rules defining R. Finally the completion of P is the set of completions of all idb predicates of P , along with the axioms of equality, if needed.

408
Negation in Datalog
The semantics of P is now defined by the following: A is true iff it is a logical consequence of comp(P ). A first problem now is that comp(P ) is not always consistent; in fact, its consistency is undecidable. What is the connection between SLDNF and Clark’s completion? Because SLDNF is consistent (it clearly cannot prove A and ¬A) and comp(P ) is not so always, SLDNF is not always complete with respect to comp(P ). For consistent comp(P ), it can be shown that SLDNF resolution is sound. However, additional conditions must be imposed on the datalog¬ programs for SLDNF resolution to be complete.

Consider again the transitive closure program P TC and input instance I of Example 15.5.1. Then the completion of T is equivalent to
T (x, y) ↔ G(x, y) ∨ ∃z(G(x, z) ∧ T (z, y)).

Note that neither T (a, c) nor ¬T (a, c) are consequences of comp(P TC, I).

In summary, negation as failure does not appear to provide a convincing proof-theoretic counterpart to the semantics we have considered. The search for more successful proof-theoretic approaches is an active research area. Other proposals are described briefly in the Bibliographic Notes.

Bibliographic Notes
The notion of a stratified program is extremely natural. Not surprisingly, it was proposed independently by quite a few investigators [CH85, ABW88, Lif88, VanG86]. The independence of the semantics from a particular stratification (Theorem 15.2.10) was shown in
[ABW88].

Research on well-founded semantics, and the related notion of a 3-stable model, has its roots in investigations of stable and default model semantics. Although formulated somewhat differently, the notion of a stable/default model is equivalent to that of a total 3-stable model [Prz90]. Stable model semantics was introduced in [GL88], and default model semantics was introduced in [BF87, BF88]. Stable semantics is based on Moore’s autoepistemic logic [Moo85], and default semantics is based on Reiter’s default logic
[Rei80]. The equivalence between autoepistemic and default logic in the general case has been shown in [Kon88]. The equivalence between stable model semantics and default model semantics was shown in [BF88].

Several equivalent definitions of the well-founded semantics have been proposed. The definition used in this chapter comes from [Prz90]. The alternating fixpoint computation we described is essentially the same as in [VanG89]. Alternative procedures for computing the well-founded semantics are exhibited in [BF88, Prz89]. Historically, the first definition of well-founded semantics was proposed in [VanGRS88, VanGRS91]. This is described in Exercise 15.24.

The fact that well-founded and stratified semantics agree on stratifiable datalog¬ programs (Theorem 15.3.11) was shown in [VanGRS88].

Both the stratified and well-founded semantics were originally introduced for general logic programming, as well as the more restricted case of datalog. In the context of logic programming, both semantics have expressive power equivalent to the arithmetic hierarchy
[AW88] and are thus noneffective.

The result that datalog¬ with well-founded semantics expresses exactly the fixpoint
Bibliographic Notes
409
queries is shown in [VanG89]. Citation [FKL87] proves that for every datalog¬ program P
there is a total datalog¬ program Q such that the positive portions of P wf (I) and Qwf (I) coincide for every I. The fact that stratified datalog¬ is weaker than fixpoint, and therefore weaker than well-founded semantics, was shown in [Kol91], making use of earlier results from [Dal87] and [CH82]. In particular, Lemma 15.4.1 is based on Lemma 3.9 in [CH82].

The result that semipositive datalog¬ expresses qptime on ordered databases with min and max is due to [Pap85].

The investigation of negation as failure was initiated in [Cla78], in connection with general logic programming. In particular, SLDNF resolution as well as Clark’s completion are introduced there. The fact that there is no datalog¬ program for which the positive and negative facts about the transitive closure of the graph can be proven by SLDNF resolution was shown in [Kun88]. Other work related to Clark’s completion can be found in [She88, Llo87, Fit85, Kun87].

Several variations of SLDNF resolutions have been proposed. SLS resolution is introduced in [Prz88] to deal with stratified programs. An exact match is achieved between stratified semantics and the proof procedure provided by SLS resolution. Although SLS
resolution is effective in the context of (finite) databases, it is not so when applied to general logic programs, with function symbols. To deal with this shortcoming, several restrictions of SLS resolution have been proposed that are effective in the general framework [KT88, SI88].

Several proof-theoretic approaches corresponding to the well-founded semantics have been proposed. SLS resolution is extended from stratified to arbitrary datalog¬ programs in [Prz88], under well-founded semantics. Independently, another extension of SLS resolution called global SLS resolution is proposed in [Ros89], with similar results. These proposals yield noneffective resolution procedures. An effective procedure is described in
[BL90].

In [SZ90], an interesting connection between nondeterminism and stable models of a program (i.e., total 3-stable models; see also Exercise 15.20) is pointed out. Essentially, it is shown that the stable models of a datalog¬ program can be viewed as the result of a natural nondeterministic choice. This uses the choice construct introduced earlier in [KN88]. Another use of nondeterminism is exhibited in [PY92], where an extension of well-founded semantics is provided, which involves the nondeterministic choice of a fixpoint of a datalog¬ program. This is called tie-breaking semantics. A discussion of nondeterminism in deductive databases is provided in [GPSZ91].

Another semantics in the spirit of well-founded is the valid model semantics introduced in [BRSS92]. It is less conservative than well-founded semantics, in the sense that all facts that are positive in well-founded semantics are also positive in the valid model semantics, but the latter generally yields more positive facts than well-founded semantics.

There are a few prototypes (but no commercial system) implementing stratified datalog¬. The language LDL [NT89, BNR+87, NK88] implements, besides the stratified semantics for datalog¬, an extension to complex objects (see also Chapter 20). The implementation uses heuristics based on the magic set technique described in Chapter 13.

The language NAIL! (Not Yet Another Implementation of Logic!), developed at Stanford, is another implementation of the stratified semantics, allowing function symbols and a set construct. The implementation of NAIL! [MUG86, Mor88] uses a battery of evaluation techniques, including magic sets. The language EKS [VBKL89], developed at
410
Negation in Datalog
ECRC (European Computer-Industry Research Center) in Munich, implements the stratified semantics and extensions allowing quantifiers in rule bodies, aggregate functions, and constraint specification. The CORAL system [RSS92, RSSS93] provides a database programming language that supports both imperative and deductive capabilities, including stratification. An implementation of well-founded semantics is described in [CW92].

Nicole Bidoit’s survey on negation in databases [Bid91b], as well as her book on datalog [Bid91a], provided an invaluable source of information and inspired our presentation of the topic.

Exercises
Exercise 15.1
(a) Show that, for datalog¬ programs P , the immediate consequence operator TP is not always monotonic.

(b) Exhibit a datalog¬ program P (using negation at least once) such that TP is monotonic.

(c) Show that it is decidable, given a datalog¬ program P , whether TP is monotonic.

Exercise 15.2
Consider the datalog¬ program P3 = {p ← ¬r; r ← ¬p; p ← ¬p, r}. Verify that TP has a least fixpoint, but T
does not converge when starting on ∅.

3
P3
Exercise 15.3
(a) Exhibit a datalog¬ program P and an instance K over sch(P ) such that K is a model of $P but not a fixpoint of TP .

(b) Show that, for datalog¬ programs P , a minimal fixpoint of TP is not necessarily a minimal model of $P and, conversely, a minimal model of $P is not necessarily a minimal fixpoint of TP .

Exercise 15.4
Prove Lemma 15.2.8.

Exercise 15.5
Consider a database for the Parisian metro and bus lines, consisting of two relations Metro[ Station, Next-Station] and Bus[ Station, Next-Station]. Write stratifiable datalog¬
programs to answer the following queries.

(a) Find the pairs of stations a, b such that one can go from a to b by metro but not by bus.

(b) A pure bus path from a to b is a bus itinerary from a to b such that for all consecutive stops c, d along the way, one cannot go from c to d by metro. Find the pairs of stations a, b such that there is a pure bus path from a to b.

(c) Find the pairs of stations a, b such that b can be reached from a by some combination of metro or bus, but not by metro or bus alone.

(d) Find the pairs of stations a, b such that b can be reached from a by some combination of metro or bus, but there is no pure bus path from a to b.

(e) The metro is useless in a bus path from a to b if by taking the metro at any intermediate point c one can return to c but not reach any other station along the path. Find the pairs of stations a, b such that the metro is useless in all bus paths connecting a and b.

Exercises
411
Exercise 15.6
The semantics of stratifiable datalog¬ programs can be extended to infinite databases as follows. Let P be a stratifiable datalog¬ program and let σ = P 1 . . . P n be a stratification for P . For each (finite or infinite) instance I over edb(P ), σ (I) is defined similarly to the finite case. More precisely, consider the sequence
I0 = I
Ii = P i(Ii−1| edb(P i))
where
j
P i(Ii−1| edb(P i)) = ∪j>0T (I
P
i−1| edb(P i )).

i
Note that the definition is now noneffective because P i(Ii−1| edb(P i)) may be infinite.

Consider a database consisting of one binary relation succ providing a successor relation on an infinite set of constants. Clearly, one can identify these constants with the positive integers.

(a) Write a stratifiable datalog¬ program defining a unary relation prime containing all constants in succ corresponding to primes.

(b) Write a stratifiable datalog¬ program P defining a 0-ary relation Fermat, which is true iff Fermat’s Last Theorem3 is true. (No shortcuts, please: The computation of the program should provide a proof of Fermat’s Last Theorem, not just coincidence of truth value!)
Exercise 15.7
Prove Theorem 15.2.2.

Exercise 15.8
A datalog¬ program is nonrecursive if its precedence graph is acyclic. Show that every nonrecursive stratifiable datalog¬ program is equivalent to an nr-datalog¬ program, and conversely.

Exercise 15.9
Let (A, <) be a partially ordered set. A listing a1, . . . , an of the elements in A is compatible with < iff for i < j it is not the case that aj < ai. Let σ ′, σ ′′ be listings of A compatible with <. Prove that one can obtain σ ′′ from σ ′ by a sequence of exchanges of adjacent elements al, am such that al < am and am < al.

Exercise 15.10
Prove Lemma 15.2.9.

Exercise 15.11
(Supported models) Prove that there exist stratified datalog¬ programs P1, P2
such that sch(P1) = sch(P2), $P ≡ $ , and there is a minimal model I of $
such that I is a
1
P2
P1
supported model for P1, but not for P2. (In other words, the notion of supported model depends not only on $P , but also on the syntax of P .)

Exercise 15.12
Prove part (b) of Proposition 15.2.11.

Exercise 15.13
Prove Proposition 15.2.12.

♠ Exercise 15.14 [Bid91b] (Local stratification) The following extension of the notion of stratification has been proposed for general logic programs [Prz86]. This exercise shows that local stratification is essentially the same as stratification for the datalog¬ programs considered in this chapter (i.e., without function symbols).

3 Fermat’s Last Theorem: There is no n > 2 such that the equation an + bn = cn has a solution in the positive integers.

412
Negation in Datalog
A datalog¬ program P is locally stratified iff for each I over edb(P ), ground(PI) is stratified. [An example of a locally stratified logic program with function symbols is { even(0) ←; even(s(x)) ← ¬ even(x)}.] The semantics of a locally stratified program P on input I is the semantics of the stratified program ground(PI).

(a) Show that, if the rules of P contain no constants, then P is locally stratified iff it is stratified.

(b) Give an example of a datalog¬ program (with constants) that is locally stratified but not stratified.

(c) Prove that, for each locally stratified datalog¬ program P , there exists a stratified datalog¬ program equivalent to P .

Exercise 15.15
Let α and β be propositional Boolean formulas (using ∧, ∨, ¬, →). Prove the following:
(a) If α and β are equivalent with respect to 3-valued instances, then they are equivalent with respect to 2-valued instances.

(b) If α and β are equivalent with respect to 2-valued instances, they are not necessarily equivalent with respect to 3-valued instances.

Exercise 15.16
Prove Lemma 15.3.4.

Exercise 15.17
Let P be a datalog¬ program. Recall the definition of positivized ground version of P given I, denoted pg(P , I), where I is a 3-valued instance. Prove the following: (a) If I is total, then pg(P , I) is total.

(b) Let {Ii}i≥0 be the sequence of instances defined by
I0
= ⊥
Ii+1 = pg(P , Ii)(⊥) = conseq P (Ii).

Prove that
I0 ≺ I2 · · · ≺ I2i ≺ I2i+2 ≺ · · · ≺ I2i+1 ≺ I2i−1 ≺ · · · ≺ I1.

Exercise 15.18
Exhibit a datalog¬ program that yields the complement of the transitive closure under well-founded semantics.

Exercise 15.19
Prove that for each datalog¬ program P and instance I over edb(P ), P wf (I) is a minimal 3-valued model of P whose restriction to edb(P ) equals I.

♠ Exercise 15.20 A total 3-stable model of a datalog¬ program P is called a stable model of P
[GL88] (also called a default model [BF87, BF88]).

(a) Provide examples of datalog¬ programs that have (1) no stable models, (2) a unique stable model, and (3) several stable models.

(b) Show that P wf is total iff all 3-stable models are total.

(c) Prove that, if P wf is total, then P has a unique stable model, but the converse is false.

♠ Exercise 15.21 [BF88] Let P be a datalog¬ program and I an instance over edb(P ). Prove that the problem of determining whether PI has a stable model is np-complete in the size of PI.

Exercises
413
Exercise 15.22
Give an example of a datalog¬ program P such that P is not stratified but P wf is total.

⋆ Exercise 15.23 Prove that it is undecidable if the well-founded semantics of a given datalog¬
program P is always total. That is, it is undecidable whether, for each instance I over wf
edb(P ), P
is total.

I
♠ Exercise 15.24 [VanGRS88] This exercise provides an alternative (and historically first) definition of well-founded semantics. Let L be a ground literal. The complement of L is ¬A if L = A and A if L = ¬A. If I is a set of ground literals, we denote by ¬. I the set of complements of the literals in I. A set I of ground literals is consistent iff I ∩ ¬. I = ∅. Let P be a datalog¬ program.

The immediate consequence operator TP of P is extended to operate on sets of (positive and negative) ground literals as follows. Let I be a set of ground literals. TP (I) consists of all literals A for which there is a ground rule of P , A ← L1, . . . , Lk, such that Li ∈ I for each i. Note that TP can produce an inconsistent set of literals, which therefore does not correspond to a 3-valued model. Now let I be a set of ground literals and J a set of positive ground literals. J is said to be an unfounded set of P with respect to I if for each A ∈ J and ground rule r of P with A in the head, at least one of the following holds:
• the complement of some literal in the body of r is in I; or
• some positive literal in the body of r is in J.

Intuitively, this means that if all atoms of I are assumed true and all atoms in J are assumed false, then no atom of J is true under one application of TP .

Let the greatest unfounded set of P with respect to I be the union of all unfounded sets of P with respect to I, denoted UP (I). Next consider the operator WP on sets of ground literals defined by
WP (I) = TP (I) ∪ ¬.UP (I).

Prove the following:
(a) The greatest unfounded set UP (I) of P with respect to I is an unfounded set.

(b) The operator WP is monotonic (with respect to set inclusion).

(c) The least fixpoint of WP is consistent.

(d) The least fixpoint of WP equals P wf .

♠ Exercise 15.25 [VanG89] Let P be a datalog¬ program. If I is a set of ground literals, let P (I) = T ω(I), where T
P
P is the immediate consequence operator on sets of ground literals
defined in Exercise 15.24. Furthermore, P (I) denotes the complement of P (I) [i.e., B(P , I) −
P (I)]. Consider the sequence of sets of negative facts defined by N0
= ∅,
Ni+1 = ¬.P (¬.P (Ni)).

The intuition behind the definition is the following. N0 is an underestimate of the set of negative facts in the well-founded model. Then P (N) is an underestimate of the positive facts, and the negated complement ¬.P (N) is an overestimate of the negative facts. Using this overestimate, one can infer an overestimate of the positive facts, P (¬.P (N)). Therefore ¬.P (¬.P (N)) is now a new underestimate of the negative facts containing the previous underestimate. So {Ni}i≥0 is
414
Negation in Datalog
an increasing sequence of underestimates of the negative facts, which converges to the negative facts in the well-founded model. Formally prove the following:
(a) The sequence {Ni}i≥0 is increasing.

(b) Let N be the limit of the sequence {Ni}i≥0 and K = N∪P (N). Then K = P wf .

(c) Explain the connection between the sequence {Ni}i≥0 and the sets of negative facts in the sequence {Ii}i≥0 defined in the alternating fixpoint computation of P wf in the text.

(d) Suppose the definition of the sequence {Ni}i≥0 is modified such that N0 = ¬. B(P ) (i.e., all facts are negative at the start). Show that for each i ≥ 0, Ni = ¬.(I2i)0.

Exercise 15.26
Let P be a datalog¬ program. Let TP be the immediate consequence operator on sets of ground literals, defined in Exercise 15.24, and let ¯
TP be defined by ¯
TP (I) = I ∪ TP (I).

Given a set I of ground literals, let P (I) denote the limit of the increasing sequence { ¯
T i (I)}
P
i>0.

A set I− of negative ground literals is consistent with respect to P if P (I−) is consistent. I−
is maximally consistent with respect to P if it is maximal among the sets of negative literals consistent with P . Investigate the connection between maximal consistency, 3-stable models, and well-founded semantics:
(a) Is ¬. I0 maximally consistent for every 3-stable model I of P ?

(b) Is P (I−) a 3-stable model of P for every I− that is maximally consistent with respect to P ?

(c) Is ¬.(P wf )0 the intersection of all sets I− that are maximally consistent with respect to P ?

Exercise 15.27
Refer to the proof of Lemma 15.4.4.

(a) Outline a proof that conseq P can be simulated by a while+ program.

(b) Provide a full description of the timestamping technique outlined in the proof of Lemma 15.4.4.

Exercise 15.28
Show that every query definable by stratified datalog¬ is a fixpoint query.

Exercise 15.29
Consider an ordered database (i.e., with binary relation succ providing a successor relation on the constants). Prove that the minimum and maximum constants cannot be computed using a semipositive program.

⋆ Exercise 15.30 Consider the game trees and winning query described in Section 15.4.

(a) Show that winning is true on the game trees G2i,k and false on the game trees G′
,
2i,k
for i > 0.

(b) Prove that the winning query on game trees is defined by the fixpoint query exhibited in Section 15.4.

P A R T
E Expressivenessand
Complexity
Various query languages were presented in Parts B and D. Simple languages like conjunctive queries were successively augmented with various constructs such as union, negation, and recursion. The primary motivation for defining increasingly powerful languages was the need to express useful queries not captured by the simpler languages. In the presentation, the process was primarily example driven. The following chapters present a more advanced and global perspective on query languages. In addition to their ability to express specific queries, we consider more broadly the capability of languages to express queries of a given complexity. This leads to establishing formal connections between languages and complexity classes of queries. This approach lies on the border between databases, complexity theory, and logic. It is related to characterizations of complexity classes in terms of various logics.

The basic framework for the formal development is presented in Chapter 16, in which we discuss the notion of a query and produce a formal definition. It turns out that it is relatively easy to define languages expressing all queries. Such languages are called complete. However, the real challenge for the language designer is not simply to define increasingly powerful languages. Instead an important aspect of language design is to achieve a good balance between expressiveness and the complexity of evaluating queries.

The ideal language would allow expression of most useful queries while guaranteeing that all queries expressible in the language can be evaluated with reasonable complexity. To formalize this, we raise the following basic question: How does one evaluate a query language with respect to expressiveness and complexity? In an attempt to answer this question, we discuss the issue of sizing up languages in Chapter 16.

Chapter 17 considers some of the classes of queries discussed in Part B from the viewpoint of expressiveness and complexity. The focus is on the relational calculus of Chapter 5 and on its extensions fixpoint and while defined in Chapter 14. We show the connection of these languages to complexity classes. Several techniques for showing the nonexpressibility of queries are also presented, including games and 0-1 laws.

Chapter 17 also explores the intriguing theoretical implications of one of the basic assumptions of the pure relational model—namely, that the underlying domain dom consists of uninterpreted, unordered elements. This assumption can be viewed as a metaphor for the data independence principle, because it implies using only logical properties of data as 415
416
Expressiveness and Complexity
opposed to the underlying implementation (which would provide additional information, such as an order).

Chapter 18 presents highly expressive (and complex) languages, all the way up to complete languages. In particular, we discuss constructs for value invention, which are similar to the object creation mechanisms encountered in object languages (see Chapter 21).

For easy reference, the expressiveness and complexity of relational query languages are summarized at the end of Chapter 18.

16 SizingUpLanguages
Alice:
Do you ever worry about how hard it is to answer queries?

Riccardo:
Sure — my laptop can only do conjunctive queries.

Sergio:
I can do the while queries on my Sun.

Vittorio:
I don’t worry about it — I have a Cray in my office.

This chapter lays the groundwork for the study of the complexity and expressiveness of query languages. First the notion of query is carefully reconsidered and formally defined. Then, the complexity of individual queries is considered. Finally definitions that allow comparison of query languages and complexity classes are developed.

16.1
Queries
The goal of Part E is to develop a general understanding of query languages and their capabilities. The first step is to formulate a precise definition of what constitutes a query.

The focus is on a fairly high level of abstraction and thus on the mappings expressible by queries rather than on the syntax used to specify them. Thus, unlike Part B, in this part we use the term query primarily to refer to mappings from instances to instances rather than to syntactic objects. Although there are several correct definitions for the set of permissible queries, the one presented here is based on three fundamental assumptions: well-typedness, computability, and genericity.

The first assumption involves the schemas of the input and the answer to a query. A query is over a particular database schema, say R. It takes as input an instance over R
and returns as answer a relation over some schema S. In principle, it is conceivable that the schema of the result may be data dependent. However, to simplify, it is assumed here (as in most query languages) that the schema of the result is fixed for a given query. This assumption is referred to as well-typedness. Thus, for us, a query is a partial mapping from inst(R) to inst(S) for fixed R and S. By allowing partially defined mappings, we account for queries expressed by programs that may not always terminate.

Because we are only interested in effective queries, we also make the natural assumption that query mappings are computable. Query computability is defined using classical models of computation, such as Turing machines (TM). The basic idea is that the query must be “implementable” by a TM. Thus there must exist a TM that, given as input a natural encoding of a database instance on the tape, produces an encoding of the output. The formalization of these notions requires some care and is done next.

417
418
Sizing Up Languages
P
Q
a
b
c
c
b
a
(a)
P[0#1][1#0]Q[10#10]
(b)
Figure 16.1:
An instance I and its TM encoding with respect to α = abc
The first question in developing the formalization is, How can input and output instances be represented on a TM tape that has finite alphabet when the underlying domain dom is infinite? We resolve this by using standard encodings for dom. As we shall see later on, although this permits us to use conventional complexity theory in our study of query language expressiveness, it also takes us a bit outside of the pure relational model.

We focus on encodings of both dom and of subsets of dom, and we use the symbols 0
and 1. Let d ⊆ dom and let α = {d0, d1, . . . , di, . . .} be an enumeration of d. The encoding of d relative to α is the function enc α, which maps di to the binary representation of i (with no leading zeros) for each di ∈ d. Note that | enc α(di)| ≤ ⌈log i⌉ for each i.

We can now describe the encoding of instances. Suppose that a set d ⊆ dom, enumeration α for d, source schema R = {R1, . . . , Rm}, and target schema S are given. The encoding of instances of R uses the alphabet {0, 1, [, ], #} ∪ R ∪ {S}. An instance I over R
with adom(I) ⊆ d is encoded relative to α as follows: 1. enc α(a1, . . . , ak) is [ enc α(a1)# . . . # enc α(ak)].

2. enc α(I(R)), for R ∈ R, is R enc α(t1) . . . enc α(tl), where t1, . . . , tl are the tuples in I(R) in the lexicographic order induced by the enumeration α.

3. enc α(I) = enc α(I(R1)) . . . enc α(I(Rm)).

Example 16.1.1
Let R = {P , Q}, I be the instance over R in Fig. 16.1(a), and let α =
abc. Then enc α(I) is shown in Fig. 16.1(b).

Let α be a fixed enumeration of dom. In this case the encoding enc α described earlier is one-to-one on instances and thus has an inverse enc−1 when considered as a mapping α
on instances. We are now ready to formalize the notion of computability relative to an encoding of dom.

Definition 16.1.2
Let α be an enumeration of dom. A mapping q from inst(R) to inst(S) is computable relative to α if there exists a TM M such that for each instance I over R
16.1 Queries
419
(a) if q(I) is undefined, then M does not terminate on input enc α(I), and (b) if q(I) is defined, M halts on input enc α(I) with output enc α(q(I)) on the tape.

As will be seen shortly, the third assumption about queries (namely, genericity) will permit us to reformulate the preceding definition to be independent of the encoding of dom used. Before introducing that notion, we consider more carefully the representation of database instances on TM tapes. In some sense, TM encodings on the tape are similar to the internal representation of the database on some physical storage. In both cases, the representation contains more information than the database itself. In the case of the TM
representation, the extra information consists primarily of the enumeration α of constants necessary to define enc α. In the pure relational model, this kind of information is not part of the database. Instead, the database is an abstraction of its internal (or TM) representation.

This additional information can be viewed as noise associated with the internal representation and thus should not have any visible impact for the user at the conceptual level. This is captured by the data independence principle in databases, which postulates that a database provides an abstract interface that hides the internal representation of data.

We can now state the intuition behind the third and last requirement of queries, which formalizes the data independence principle. Although computations performed on the internal representation may take advantage of all information provided at this level, it is explicitly prohibited, in the definition of a query, that the result depend on such information.

(In some cases this restriction may be relaxed; see Exercise 16.4.) For example, consider a database that consists of a binary relation specifying the edges of a directed graph. Consider a query that returns as answer a subset of the vertexes in the graph. One can imagine queries that extract (1) all vertexes with positive in-degree, or (2) all vertexes belonging to some cycle, or (3) the first vertex of the graph as presented in the TM tape representation. Speaking intuitively, (1) and (2) are independent of the internal representation used, whereas (3) depends on it. Queries such as (3) will be excluded from the class of queries.

The property that a query depends only on information provided by the input instance is called genericity and is formalized next. The idea is that the constants in the database have no properties other than the relationships with each other specified by the database.

(In particular, their internal representation is irrelevant.) Thus the database is essentially unchanged if all constants are consistently renamed. Of course, a query can always explicitly name a finite set of constants, which can then be treated differently from other constants.

(The set of such constants is the set C in Definition 16.1.3.)

A permutation of dom is a one-to-one, onto mapping from dom to dom. As done before, each mapping ρ over dom is extended to tuples and database instances in the obvious way.

Definition 16.1.3
Let R and S be database schemas, and let C be a finite set of constants. A mapping q from inst(R) to inst(S) is C-generic iff for each I over R and each permutation ρ of dom that is the identity on C, ρ(q(I)) = q(ρ(I)). When C is empty, we simply say that the query is generic.

420
Sizing Up Languages
The previous definition is best visualized using the following commuting diagram: q
I
−→
q(I)


ρ
ρ
q
ρ(I)
−→ ρ(q(I)) = q(ρ(I)).

In other words, a query is C-generic if it commutes with permutations (that leave C fixed).

Genericity states that the query is insensitive to renaming of the constants in the database (using the permutation ρ). It uses only the relationships among constants provided by the database and is independent of any other information about the constants. The set C
specifies the exceptional constants named explicitly in the query. These cannot be renamed without changing the effect of the query.

Permutations ρ for which ρ(I) = I are of special interest. Such ρ are called automorphisms for I. If ρ is an automorphism for I and ρ(a) = b, this says intuitively that a and b cannot be distinguished using the structure of I. Let q be a generic query, I an instance, and ρ an automorphism for I. Then, by genericity,
ρ(q(I)) = q(ρ(I)) = q(I),
so ρ is also an automorphism for q(I). In particular, a generic query cannot distinguish between constants that are undistinguishable in the input (see Exercise 16.5). Of course, this is not the case if the query explicitly names some constants.

We illustrate these various aspects of genericity in an example.

Example 16.1.4
Consider a database over a binary relation G holding the edges of a directed graph. Let I be the instance {a, b, b, a, a, c, b, c}.

Let σ be the CALC query
{x | ∃yG(x, y)}.

Note that σ (I) = {a, b}. Let ρ be the permutation defined by ρ(a) = b, ρ(b) = c, and ρ(c) = d. Then ρ(I) = {b, c, c, b, b, d, c, d}. Genericity requires that σ (ρ(I)) =
{b, c}. This is true in this case.

Note also that a and b are undistinguishable in I. Formally, the renaming ρ defined by ρ(a) = b, ρ(b) = a, and ρ(c) = c has the property that ρ(I) = I and thus is an automorphism of I. Let q be a generic query on G. By genericity of q, either a and b both belong to q(I), or neither does. Thus a generic query cannot distinguish between a and b. Of course, this is not true for C-generic queries (for C nonempty). For instance, let qb = π1(σ2=b(G)).

Now qb is {b}-generic, and qb(I) = {a}. Thus qb distinguishes between a and b.

It is easily verified that if a database mapping q is C-generic, then for each input instance I, adom(q(I)) ⊆ C ∪ adom(I) (see Exercise 16.1).

16.1 Queries
421
In most cases we will ignore the issue of constants in queries because it is not central.

Note that a C-generic query can be viewed as a generic query by including the constants in C in the input, using one relation for each constant. For instance, the {b}-generic query qb over G in Example 16.1.4 is reduced to a generic query q′ over {G, Rb}, where Rb = {b}, defined as follows:
q′ = π1(σ2=3(G × Rb)).

In the following, we will usually assume that queries have no constants unless explicitly stated.

Suppose now that α and β are two enumerations of dom and that a generic mapping q from R to S is computed by a TM M using enc α. It is easily verified that the same query is computed by M if enc β is used in place of enc α (see Exercise 16.2). This permits us to adopt the following notion of computable, which is equivalent to “computable relative to enumeration α” in the case of generic queries. This definition has the advantage of relying on finite rather than infinite enumerations.

Definition 16.1.5
A generic mapping q from inst(R) to inst(S) is computable if there exists a TM M such that for each instance I over R and each enumeration α of adom(I), (a) if q(I) is undefined, then M does not terminate on input enc α(I), and (b) if q(I) is defined, M halts on input enc α(I) with output enc α(q(I)) on the tape.

We are now ready to define queries formally.

Definition 16.1.6
Let R be a database schema and S a relation schema. A query from R to S is a partial mapping from inst(R) to inst(S) that is generic and computable.

Note that all queries discussed in previous chapters satisfy the preceding definition (modulo constants in queries).

Queries and Query Languages
We are usually interested in queries specified by the expressions (i.e., syntactic queries or programs) of a given query language. Given an expression E in query language L, the mapping between instances that E describes is called the effect of E. Depending on the language, there may be several alternative semantics (e.g., inflationary versus noninflationary) for defining the query expressed by an expression. A related issue concerns the specification of the output schema of an expression. In calculus-based languages, the output schema is unambiguously specified by the form of the expression. The situation is more ambiguous for other languages, such as datalog and while. Programs in these languages typically manipulate several relations and may not specify explicitly which is to be taken as the answer to the query. In such cases, the concepts of input, output, and temporary relations may become important. Thus, in addition to semantically significant input and output relations, the programs may use temporary relations whose content is immaterial outside the
422
Sizing Up Languages
computation. We will state explicitly which relations are temporary and which constitute the output whenever this is not clear from the context.

A query language or computing device is called complete if it expresses all queries.

We will discuss such languages in Chapter 18.

16.2
Complexity of Queries
We now develop a framework for measuring the complexity of queries. This is done by reference to TMs and classical complexity classes defined using the TM model.

There are several ways to look at the complexity of queries. They differ in the parameters with respect to which the complexity is measured. The two main possibilities are as follows:
• data complexity: the complexity of evaluating a fixed query for variable database inputs; and
• expression complexity: the complexity of evaluating, on a fixed database instance, the various queries specifiable in a given query language.

Thus in the data complexity perspective, the complexity is with respect to the database input and the query is considered constant. Conversely, with expression complexity, the database input is fixed and the complexity is with respect to the size of the query expression.

Clearly, the measures provide different information about the complexity of evaluating queries. The usual situation is that the size of the database input dominates by far the size of the query, and so data complexity is typically most relevant. This is the primary focus of Part E, and we use the term complexity to refer to data complexity unless otherwise stated.

The complexity of queries is defined based on the recognition problem associated with the query. For a query q, the recognition problem is as follows: Given an instance I and a tuple u, determine if u belongs to the answer q(I). To be more precise, the recognition problem of a query q is the language
{ enc α(I)# enc α(u) | u ∈ q(I), α an enumeration of adom(I)}.

The ( data) complexity of q is the (conventional) complexity of its recognition problem.

Technically, the complexity is with respect to the size of the input [i.e., the length of the word enc α(I)# enc α(u)]. Because for an instance I the size (number of tuples) in I is closely related to the length of enc α(I) (see Exercise 16.12), the size of I is usually taken as the measure of the input.

For each Turing time or space complexity class c, one can define a corresponding complexity class of queries, denoted by qc . The class of queries qc consists of all queries whose recognition problem is in c. For example, the class qptime consists of all queries for which the recognition problem is in ptime.

There is another way to define the complexity of queries that is based on the complexity of actually constructing the result of the query rather than the recognition problem for individual tuples. The two definitions are in most cases interchangeable (see Exercise 16.13). In particular, for complexity classes insensitive to a polynomial factor, the
16.3 Languages and Complexity
423
definitions are equivalent. In general, the definition based on constructing the result distinguishes between a query with a large answer and one with a small answer, which is irrelevant to the definition based on recognition. On the other hand, the definition based on constructing the result may not distinguish between easy and hard queries with large results.

Example 16.2.1
Consider a database consisting of one binary relation G and the three queries cross, path, and self on G defined as follows: cross(G) = π1(G) × π2(G),
path(G) = {x, y | x and y are connected by a path in G},
self (G) = G.

Consider first cross and path. Both have potentially large answers, but cross is clearly easier than path, even though the time complexity of constructing the result is O(n2) for both cross and path. The time complexity of the recognition problem is O(n) for cross and O(n2) for path. Thus the measure based on constructing the result does not detect a difference between cross and path, whereas this is detected by the complexity of the recognition problem. Next consider cross and self . The time complexity of the recognition problem is in both cases O(n), but the complexity of computing the result is O(n) for self whereas it is O(n2) for cross. Thus the complexity of the recognition problem does not distinguish between cross and self , although cross can potentially generate a much larger answer. This difference is detected by the complexity of constructing the result.

In Part E, we will use the definition of query complexity based on the associated recognition problem.

16.3
Languages and Complexity
In the previous section we studied a definition of the complexity of an individual query.

To measure the complexity of a query language L, we need to establish a correspondence between
• the class of queries expressible in L, and
• a complexity class qc of queries.

Expressiveness with Respect to Complexity Classes
The most straightforward connection between L and a class of queries qc is when L and qc are precisely the same.1 In this case, it is said that L expresses qc. In every case, each query in L has complexity c, and conversely L can express every query of complexity c.

1 By abuse of notation, we also denote by L the set of queries expressible in L.

424
Sizing Up Languages
Ideally, one would be able to perform complexity-tailored language design; that is, for a desired complexity c, one would design a language expressing precisely qc. Unfortunately, we will see that this is not always possible. In fact, there are no such results for the pure relational model for complexity classes of polynomial time and below, that are of most interest. We consider this phenomenon at length in the next chapter. Intuitively, the shapes of classes of queries of low complexity do not match those of classes of queries defined by any known language. Therefore we are led to consider a less straightforward way to match languages to complexity classes.

Completeness with Respect to Complexity Classes
Consider a language L that does not correspond precisely to any natural complexity class of queries. Nonetheless we would like to say something about the complexity of queries in L. For instance, we may wish to guarantee that all queries in L lie within some complexity class c, even though L may not express all of qc. For the bound to be meaningful, we would also like that c is, in some sense, a tight upper bound for the complexity of queries in L. In other words, L should be able to express at least some queries that are among the hardest in qc. The property of a problem being hardest in a complexity class c is captured, in complexity theory, by the notion of completeness of the problem in the class (see Chapter 2). By extension to a language, this leads to the following: Definition 16.3.1
A language L is complete with respect to a complexity class c if (a) each query in L is also in qc, and
(b) there exists a query in L for which the associated recognition problem is complete with respect to the complexity class c.

As in the classical definition of completeness of a problem in a complexity class, we qualify, when necessary, the notion of a completeness in a complexity class by the complexity of the reduction. For instance, L is logspace complete with respect to c qualifies (b) by stating that the query expressible in L whose recognition problem is complete in c is in fact logspace complete in c.

In some sense, completeness without expressiveness says something negative about the language L. L can express some queries that are as hard as any query in qc; on the other hand, there may be easy queries in qc that are not expressible in L. This may at first appear contradictory because L expresses some queries that are complete in c, and any problem in c can be reduced to the complete problem. However, there is no contradiction.

The reduction of the “easy” query to the complete query may be computationally easy but nevertheless not expressible in L. Examples of this situation involve the familiar languages fixpoint and while. As will be shown in Section 17.3, these languages are complete in ptime and pspace, respectively. However, neither can express the simple parity query on a unary relation R:
even(R) = true if |R| is even, and false otherwise.

Bibliographic Notes
425
Complexity and Genericity
To conclude this chapter, we consider the delicate impact of genericity on complexity.

The foregoing query even illustrates a fundamental phenomenon relating genericity to the complexity of queries. As stated earlier, even cannot be computed by fixpoint or by while, both of which are powerful languages. The difficulty in computing even is due to the lack of information about the elements of the set. Because the database only provides a set of undifferentiated elements, genericity implies that they are treated uniformly in queries.

This rules out the straightforward solution of repeatedly extracting one arbitrary element from the set until the set is empty while keeping a binary counter: How does one specify the first element to be extracted?

On the other hand, consider the problem of computing even with a TM. The additional information provided by the encoding of the input on the tape makes the problem trivial and allows a linear-time solution.

This highlights the interesting fact that genericity may complicate the task of computing a query, whereas access to the internal representation may simplify this task considerably. Thus this suggests a trade-off between genericity and complexity. This can be formalized by defining complexity classes based on a computing device that is generic by definition in place of a TM. Such a device cannot take advantage of the representation of data in the same manner as a TM, and it treats data generically at all points in the computation. It can be shown that even is hard with respect to complexity measures based on such a device. The query even will be used repeatedly to illustrate various aspects of the complexity of queries.

Bibliographic Notes
The study of computable queries originated in the work of Chandra and Harel [CH80b, Cha81a, CH82]. In addition to well-typed languages, they also considered languages defining queries with data-dependent output schemas. The data and expression complexity of queries were introduced and studied in [CH80a, CH82] and further investigated in
[Var82a]. Data complexity is most widely used and is based on the associated recognition problem. Data complexity based on constructing the result of the query is discussed in
[AV90].

The notion of genericity was formalized in [AU79, CH80b] with different terminology.

The term C-genericity was first used in [HY84]. Other notions related in spirit to genericity are studied in [Hul86]. The definition of genericity is extended in [AK89] to object-oriented queries that can produce new constants in the result (arising from new object identifiers); see also [VandBGAG92, HY90]. This is further discussed in Chapters 18 and 21.

A modified notion of Turing machine is introduced in [HS93] that permits domain elements to appear on the Turing tape, thus obviating the need to encode them. However, this device still uses an ordered representation of the input instance. A device operating directly on relations is the on-site acceptor of [Lei89a]. This extends the formal algorithmic procedure (FAP) proposed in [Fri71] in the context of recursion theory. Another variation of this device is presented in [Lei89b]. Further generalizations of TMs, which do not assume an ordered input, are introduced in [AV91b, AV94]. These are used to define nonstandard
426
Sizing Up Languages
complexity classes of queries and to investigate the trade-off between genericity and complexity.

Informative discussions of the connection between query languages and complexity classes are provided in [Gur84, Gur88, Imm87b, Lei89a].

Exercises
Exercise 16.1 Let q be a C-generic mapping. Show that, for each input instance I, adom(q(I))
⊆ C ∪ adom(I).

Exercise 16.2 (Genericity) Let q be a generic database mapping from R to S.

(a) Let α and β be enumerations of dom, and suppose that M computes q using enc α.

Prove that for each instance I over R,
enc α ◦ M ◦ enc−1 =
.

α
enc β ◦ M ◦ enc−1
β
Conclude that M computes q using enc β.

(b) Verify that the definitions of computable relative to α and computable are equivalent for generic database mappings.

⋆ Exercise 16.3 Let R be a database schema and S a relation schema.

(a) Prove that it is undecidable to determine, given TM M that computes a mapping q from inst(R) to inst(S) relative to enumeration α of dom, whether q is generic.

(b) Show that the set of TMs that compute queries from R to S is co-r.e.

Exercise 16.4
In many practical situations the underlying domains used (e.g., strings, integers) have some structure (e.g., an ordering relationship that is visible to both user and implementation). For each of the following, develop a natural definition for generic and exhibit a nongeneric query, if there is one.

(a) dom is partitioned into several sorts dom1, . . . , domn.

(b) dom has a dense total order ≤. [A total order ≤ is dense if ∀x, y(x < y → ∃z(x < z ∧ z < y)).]
(c) dom has a discrete total order ≤. [A total order ≤ is discrete if ∀x[∃y(x < y →
∃z(x < z ∧ ¬∃w(x < w ∧ w < z))) ∧ ∃y(y < x → ∃z(z < x ∧ ¬∃w(z < w ∧ w < x)))].]
(d) dom is the set of nonnegative integers and has the usual ordering ≤.

Exercise 16.5
Let q be a C-generic query, and let I be an input instance. Let ρ be an automorphism of I that is the identity on C, and let a, b be constants in I, such that ρ(a) = b. Show that a occurs in q(I) iff b occurs in q(I).

The next several exercises use the following notions. Let R be a database schema. Let k be a positive integer and I an instance over R. 8I denotes the set of k-tuples that can be formed k
using just constants in I. Define the following relation ≡I on 8I : u ≡I v iff there exists an k
k
k
automorphism ρ of I such that ρ(u) = v. The k-type index of I, denoted #k(I), is the number of equivalence classes of ≡I .

k
Exercises
427
Exercise 16.6
(Equivalence induced by automorphisms) Let R be a database schema and I an instance of R.

(a) Show that ≡I is an equivalence relation on 8I .

k
k
(b) Let q be a generic query on R, whose output is a k-ary relation. Show that q(I) is a union of equivalence classes of ≡I .

k
♠ Exercise 16.7 (Type index) Let G be a binary relation schema corresponding to the edges of a directed graph. Show the following:
(a) The k-type index of a complete graph is a constant independent of the size of the graph, as long as it has at least k vertexes.

(b) The k-type index of graphs consisting of a simple path is polynomial in the size of the graph.

(c) [Lin90, Lin91] The k-type index of a complete binary tree is polynomial in the depth of the tree.

Exercise 16.8
Let k, n be integers, 0 < n < k, and I an instance over schema R.

(a) Show how to compute ≡I from ≡I .

n
k
(b) Prove that #n(I) < #k(I), unless I has just one constant.

⋆ Exercise 16.9 (Fixpoint queries and type index) Let ϕ be a fixpoint query on database schema R. Show that there exists a polynomial p such that, for each instance I over R, ϕ on input I terminates after at most p(#k(I)) steps, for some k > 0.

♠ Exercise 16.10 (Fixpoint queries on special graphs) Show that every fixpoint query terminates in
(a) constant number of steps on complete graphs;
(b) [Lin90, Lin91] p(log(|I|)) number of steps on complete binary trees I, for some polynomial p. Hint: Use Exercises 16.7 and 16.9.

♠ Exercise 16.11 [Ban78, Par78] Let R be a schema, I a fixed instance over R, and a1, . . . , an an enumeration of adom(I). For each automorphism ρ on I, let tρ = ρ(a1), . . . , ρ(an), and let auto(I) = {tρ | ρ an automorphism of I}.

(a) Prove that there is a CALC query q with no constants (depending on I) such that q(I) = auto(I).

(b) Prove that for each relation schema S and instance J over S with adom(J ) ⊆
adom(I),
there is a CALC query q with no constants
(depending on I and J )
such that q(I) = J
iff
for each automorphism ρ of I, ρ(J ) = J .

A query language is called bp -complete if it satisfies the “if” direction of part (b).

428
Sizing Up Languages
Exercise 16.12
(Tape encoding of instances) Let I be a nonempty instance of a database schema R. Let nc be the number of constants in I, nt the number of tuples, and α an enumeration of the constants in I. Show that there exist integers k1, k2, k3 depending only on R such that (a) nc ≤ k1nt ≤ | enc α(I)|,
(b) | enc α(I)| ≤ k2ntlog(nt),
(c) | enc α(I)| ≤ (nc)k3.

Exercise 16.13
(Recognition versus construction complexity) Let f be a time or space bound for a TM, and let q be a query. The notation r-complexity abbreviates the complexity based on recognition, and a-complexity stands for complexity based on constructing the answer. Show the following:
(a) If the time r-complexity of q is bounded by f , then there exists k, k > 0, such that the time a-complexity of q is bounded by nkf , where n is the number of constants in the input instance.

(b) If the space r-complexity of q is bounded by f , then there exists k, k > 0, such that the space a-complexity of q is bounded by nk + f , where n is the number of constants in the input instance.

(c) If the time a-complexity of q is bounded by f , then there exists k, k > 0, such that the time r-complexity of q is bounded by kf .

(d) If the space a-complexity of q is bounded by f , then the space r-complexity of q is bounded by f .

Exercise 16.14
(Data complexity of algebra) Determine the time and space complexity of each of the relational algebra operations (show the lowest complexity you can).

⋆ Exercise 16.15
(a) Develop an algorithm for computing the transitive closure of a graph that uses only the information provided by the graph (i.e., a generic algorithm).

(b) Develop algorithms for a TM to compute the transitive closure of a graph (starting from a standard encoding of the graph on the tape) that use as little time (space) as you can manage.

(c) Write a datalog program defining the transitive closure of a graph so that the number of stages in the bottom-up evaluation is as small as you can manage.

17 FirstOrder,Fixpoint,
and While
Alice:
I get it, now we’ll match languages to complexity classes.

Sergio:
It’s not that easy — data independence adds some spice.

Riccardo:
You can think of it as not having order.

Vittorio:
It’s a lot of fun, and we’ll play some games along the way.

In Chapter 16, we laid the framework for studying the expressiveness and complexity of query languages. In this chapter, we evaluate three of the most important classes of languages discussed so far—CALC, fixpoint, and while—with respect to expressiveness and complexity. We show that CALC is in logspace and ac0, that fixpoint is complete in ptime, and that while is complete in pspace.1 We also investigate the impact of the presence of an ordering of the constants in the input.

We first show that CALC can be evaluated in logspace. This complexity result partly explains the success of relational database systems: Relational queries can be evaluated efficiently. Furthermore, it implies that these queries are within nc and thus that they have a high potential of intrinsic parallelism (not yet fully exploited in actual systems). We prove that CALC queries can be evaluated in constant time in a particular (standard) model of parallel computation based on circuits.

While looking at the expressive power of CALC and the other two languages, we study their limitations by examining queries that cannot be expressed in these languages.

This leads us to introduce important tools that are useful in investigating the expressive power of query languages. We first present an elegant characterization of CALC based on Ehrenfeucht-Fraissé games. This is used to show limitations in the expressive power of CALC, such as the nonexpressibility of the transitive closure query on a graph. A second tool related to expressiveness, which applies to all languages discussed in this chapter, consists of proving 0-1 laws for languages. This powerful approach, based on probabilities, allows us to show that certain queries (such as even) are not expressible in while and thus not in fixpoint or CALC.

As discussed in Section 16.3, there are simple queries that these languages cannot express (e.g., the prototypical example of even). Together with the completeness of fixpoint and while in ptime and pspace, respectively, this suggests that there is an uneasy relationship between these languages and complexity classes. As intimated in Section 16.3, the problem can be attributed to the fact that a generic query language cannot take advantage of the information provided by the internal representation of data used by Turing machines, 1 ac0 and nc are two parallel complexity classes defined later in this chapter.

429
430
First Order, Fixpoint, and While
such as an ordering of the constants. For instance, the query even is easily expressible in while if an order is provided.

A fundamental result of this chapter is that fixpoint expresses exactly qptime under the assumption that queries can access an order on the constants. It is especially surprising that a complexity class based on such a natural resource as time coincides with a logic-based language such as fixpoint. However, this characterization depends on the order in a crucial manner, and this highlights the importance of order in the context of generic computation. No language is known that expresses qptime without the order assumption; and the existence of such a language remains one of the main open problems in the theory of query languages.

This chapter concludes with two recent developments that shed further light on the interplay of order and expressiveness. The first shows that a while query on an unordered database can be reduced to a while query on an ordered database via a fixpoint query. The fixpoint query produces an ordered database from a given unordered one by grouping tuples into a sequence of blocks that are never split in the computation of the while query; the blocks can then be thought of as elements of an ordered database. This also allows us to clarify the connection between fixpoint and while: They are distinct, unless ptime = pspace.

The second recent development considers nondeterminism as a means for overcoming limitations due to the absence of ordering of the domain. Several nondeterministic extensions of CALC, fixpoint, and while are shown.

The impact of order is a constant theme throughout the discussion of expressive power.

As discussed in Chapter 16, the need to consider computation without order is a consequence of the data independence principle, which is considered important in the database perspective. Therefore computation with order is viewed as a metaphor for an (at least partial) abandonment of the data independence principle.

17.1
Complexity of First-Order Queries
This section considers the complexity of first-order queries and shows that they are in qlogspace. This result is particularly significant given its implications about the parallel complexity of CALC and thus of relational languages in general. Indeed, logspace ⊆ nc.

As will be seen, this means that every CALC query can be evaluated in polylogarithmic time using a polynomial number of processors. Moreover, as described in this section, a direct proof shows the stronger result that the first-order queries can in fact be evaluated in ac0. Intuitively, this says that first-order queries can be evaluated in constant time with a polynomial number of processors.

We begin by showing the connection between CALC and qlogspace.

Theorem 17.1.1
CALC is included in qlogspace.

Proof
Let ϕ be a query in CALC over some database schema R. We will describe a TM
Mϕ, depending on ϕ, that solves the recognition problem for ϕ and uses a work tape with length logarithmic in the size of the read-only input tape.

Suppose that Mϕ is started with input enc α(I)# enc α(u) for some instance I over R,
17.1 Complexity of First-Order Queries
431
some enumeration α of the constants, and some tuple u over adom(I) whose arity is the same as that of the result of ϕ. Mϕ should accept the input iff u ∈ ϕ(I). We assume w.l.o.g.

that ϕ is in prenex normal form. We show by induction on the number of quantifiers of ϕ
that the computation can be performed using k · log(| enc α(I)# enc α(u)|) cells of the work tape, for some constant k.

Basis. If ϕ has no quantifiers, then all the variables of ϕ are free. Let ν be the valuation mapping the free variables of ϕ to u. Mϕ must determine whether I |= ϕ[ν]. To determine the truth value of each literal L under ν occurring in ϕ, one needs only scan the input tape looking for ν(L). This can be accomplished by considering each tuple of I in turn, comparing it with relevant portions of u. For each such tuple, the address of the beginning of the tuple should be stored on the tape along with the offset to the current location of the tuple being scanned. This can be accomplished within logarithmic space.

Induction. Now suppose that each prenex normal form CALC formula with less than n quantifiers can be evaluated in logspace, and let ϕ be a prenex normal form formula with n quantifiers. Suppose ϕ is of the form ∃x ψ. (The case when ϕ is of the form ∀x ψ
is similar.)

All possible values of x are tried. If some value is found that makes ψ true, then the input is accepted; otherwise it is rejected. The values used for x are all those that appear on the input tape in the order in which they appear. To keep track of the current value of x, one needs log(nc) work tape cells, where nc is the number of constants in I.

Because nc is less than the length of the input, the number of cells needed is no more than log(| enc α(I)# enc α(u)|). The problem is now reduced to evaluating ψ for each value of x.

By the induction hypothesis, this can be done using k · log(| enc α(I)# enc α(u)|) work tape cells for some k. Thus the entire computation takes (k + 1) log(| enc α(I)# enc α(u)|) work tape cells; which concludes the induction.

Unfortunately, CALC does not express all of qlogspace. It will be shown in Section 17.3 that even, although clearly in qlogspace, is not a first-order query.

We next consider informally the parallel complexity of CALC. We are concerned with two parallel complexity classes: nc and ac0. Intuitively, nc is the class of problems that can be solved using polynomially many processors in time polynomial in the logarithm of the input size; ac0 also allows polynomially many processors but only constant time. The formal definitions of nc and ac0 are based on a circuit model in which time corresponds to the depth of the circuit and the number of gates corresponds to its size. The circuits use and, or, and not gates and have unbounded fan-in.2 Thus ac0 is the class of problems definable using circuits where the depth is constant and the size polynomial in the input.

The fact that the complexity of CALC is logspace implies that its parallel complexity is nc, because it is well known that logspace ⊆ nc. However, one can prove a tighter result, which says that the parallel complexity of CALC is in fact ac0. So only constant time is needed to evaluate CALC queries. More than any other known complexity result on CALC, this captures the fundamental intuition that first-order queries can be evaluated in 2 The fan-in is the number of wires going into a gate.

432
First Order, Fixpoint, and While
parallel very efficiently and that they represent, in some sense, primitive manipulations of relations.

We sketch only the proof and leave the details for Exercise 17.2.

Theorem 17.1.2
Every CALC query is in ac0.

Crux
Let us first provide an intuition of the result independent of the circuit model. We will use the relational algebra. We will argue that each of the operations π, σ, ×, −, ∪ can be performed in constant parallel time using only polynomially many processors.

Let e be an expression in the algebra over some database schema R. Consider the following infinite space of processors. There is one processor for each pair f, u, where f is a subexpression of e and u is a tuple of the same arity as the result of f , using constants from dom. Let us denote one such processor by pf,u. Note that, in particular, for each relation name Q occurring in f and each u of the arity of Q, pQ,u is one of the processors.

Each processor has two possible states, true or false, indicating whether u is in the result of f .

At the beginning, all processors are in state false. An input instance is specified by turning on the processors corresponding to tuples in the input relations (i.e., processors pR,u if u is in input relation R). The result consists of the tuples u for which pe,u is in state true at the end of the computation. For a given input, we are only concerned with the processors formed from tuples with constants occurring in the input. Clearly, no more than polynomially many processors will be relevant during the computation.

It remains to show that each algebra operation takes constant time. Consider, for instance, cross product. Suppose f × g is a subexpression of e. To compute f × g, the processors pf,u and pg,v send the message true to processor p(f ×g),uv if their state is true. Processor p(f ×g),uv goes to state true when receiving two true messages. The other operations are similar. Thus e is evaluated in constant time in our informal model of parallel computation.

To formalize the foregoing intuition using the circuit model, one must construct, for each n, a circuit Bn that, for each input of length n consisting of an encoding over the alphabet {0, 1} of an instance I and a tuple u, outputs 1 iff u ∈ e(I). The idea for constructing the circuit is similar to the informal construction in the previous paragraph except that processors are replaced by wires (edges in the graph representing the circuit) that carry either the value 1 or 0. Moreover, each Bn has polynomial size. Thus only wires that can become active for some input are included. Figure 17.1 represents fragments of circuits computing some relational operations. In the figure, f is the cross product of g and h (i.e., g × h); f ′ is the difference g − h; and f ′′ is the projection of h on the first coordinate. Observe that projection is the most tricky operation. In the figure, it is assumed that the active domain consists of four constants. Note also that because of projection, the circuits have unbounded fan-in.

We leave the details of the construction of the circuits Bn to the reader (see Exercise 17.2). In particular, note that one must use a slightly more cumbersome encoding than that used for Turing machines because the alphabet is now restricted to {0, 1}.

17.2 Expressiveness of First-Order Queries
433
[ f, [ a, b, a, b]]
[ f ′ , [ b, c]]
[ f ′′ , [ a]]
and
and
or
not
[ g, [ a, b]]
[ h, [ a, b]]
[ g, [ b, c]]
[ h, [ b, c]]
[ h, [ a, a]] [ h, [ a, b]] [ h, [ a, c]] [ h, [ a, d]]
Figure 17.1:
Some fragments of circuits
One might naturally wonder if CALC expresses all queries in ac0. It turns out that there are queries in ac0 that are not first order. This is demonstrated in Section 17.4.

17.2
Expressiveness of First-Order Queries
We have seen that first-order queries have desirable properties with respect to complexity.

However, there is a price to pay for this in terms of expressiveness: There are many useful queries that are not first order. Typical examples of such queries are even and transitive closure of a graph. This section presents an elegant technique based on a two-player game that can be used to prove that certain queries (including even and transitive closure) are not first order. Although the game we describe is geared toward first-order queries, games provide a general technique that is used in conjunction with many other languages.

The connection between CALC sentences and games is, intuitively, the following.

Consider as an example a CALC sentence of the form
∀x1 ∃x2 ∀x3 ψ(x1, x2, x3).

One can view the sentence as a statement about a game with two players, 1 and 2, who alternate in picking values for x1, x2, x3. The sentence says that Player 2 can always force a choice of values that makes ψ(x1, x2, x3) true. In other words, no matter which value Player 1 chooses for x1, Player 2 can pick an x2 such that, no matter which x3 is chosen next by Player 1, ψ(x1, x2, x3) is true.

The actual game we use, called the Ehrenfeucht-Fraissé game, is slightly more involved, but is based on a similar intuition. It is played on two instances. Suppose that R is a database schema. Let I and J be instances over R, with disjoint sets of constants. Let r be
434
First Order, Fixpoint, and While
∀ x
∧
∃ y
∃ z
R( x, y)
P( x, z)
Figure 17.2:
A syntax tree
a positive integer. The game of length r associated with I and J is played by two players called Spoiler and Duplicator, making r choices each. Spoiler starts by picking a constant occurring in I or J, and Duplicator picks a constant in the opposite instance. This is repeated r times. At each move, Spoiler has the choice of the instance and a constant in it, and Duplicator must respond in the opposite instance.

Let ai be the ith constant picked in I (respectively, bi in J). The set of pairs {(a1, b1),
. . . , (ar, br)} is a round of the game. The subinstance of I generated by {a1, . . . , ar}, denoted I/{a1, . . . , ar}, consists of all facts in I using only these constants, and similarly for J, {b1, . . . , br} and J/{b1, . . . , br}.

Duplicator wins the round {(a1, b1), . . . , (ar, br)} iff the mapping ai → bi is an isomorphism of the subinstances I/{a1, . . . , ar} and J/{b1, . . . , br}.

Duplicator wins the game of length r associated with I and J if he or she has a winning strategy (i.e., Duplicator can always win any game of length r on I and J, no matter how Spoiler plays). This is denoted by I ≡r J. Note that the relation ≡r is an equivalence relation on instances over R (see Exercise 17.3).

Intuitively, the equivalence I ≡r J says that I and J cannot be distinguished by looking at just r constants at a time in the two instances. Recall that the quantifier depth of a CALC
formula is the maximum number of quantifiers in a path from the root to a leaf in the representation of the sentence as a tree. The main result of Ehrenfeucht-Fraissé games is that the ability to distinguish among instances using games of length r is equivalent to the ability to distinguish among instances using some CALC sentence of quantifier depth r.

Example 17.2.1
Consider the sentence ∀x (∃y R(x, y) ∧ ∃z P (x, z)). Its syntax tree is represented in Fig. 17.2. The sentence has quantifier depth 2. Note that, for a sentence in prenex normal form, the quantifier depth is simply the number of quantifiers in the formula.

The main result of Ehrenfeucht-Fraissé games, stated in Theorem 17.2.2, is that if I and J are two instances such that Duplicator has a winning strategy for the game of length r on the two instances, then I and J cannot be distinguished by any CALC sentence of
17.2 Expressiveness of First-Order Queries
435
quantifier depth r. Before proving this theorem, we note that the converse of that result also holds. Thus if two instances are undistinguishable using sentences of quantifier depth r, then they are equivalent with respect to ≡r. Although interesting, this is of less use as a tool for proving expressibility results, and we leave it as a (nontrivial!) exercise. The main idea is to show that each equivalence class of ≡r is definable by a sentence of quantifier depth r (see Exercises 17.9 and 17.10).

Theorem 17.2.2
Let I and J be two instances over a database schema R. If I ≡r J, then for each CALC sentence ϕ over R with quantifier depth r, I and J both satisfy ϕ or neither does.

Crux
Suppose that I |= ϕ and J |= ϕ for some ϕ of quantifier depth r. We prove that I ≡r J. We provide only a sketch of the proof in an example.

Let ϕ be the sentence ∀x1 ∃x2 ∀x3 ψ(x1, x2, x3), where ψ has no quantifiers, and let I and J be two instances such that I |= ϕ, J |= ϕ. Then I |= ∀x1 ∃x2 ∀x3 ψ(x1, x2, x3) and J |= ∃x1 ∀x2 ∃x3 ¬ψ(x1, x2, x3).

We will show that Spoiler can prevent Duplicator from winning by forcing the choice of constants a1, a2, a3 in I and b1, b2, b3 in J such that I |= ψ(a1, a2, a3) and J |=
¬ψ(b1, b2, b3). Then the mapping ai → bi cannot be an isomorphism of the subinstances I/{a1, a2, a3} and J/{b1, b2, b3}, contradicting the assumption that Duplicator has a winning strategy. To force this choice, Spoiler always picks “witnesses” corresponding to the existential quantifiers in ϕ and ¬ϕ (note that the quantifier for each variable is either ∀ in ϕ and ∃ in ¬ϕ, or vice versa).

Spoiler starts by picking a constant b1 in J such that
J |= ∀x2 ∃x3 ¬ψ(b1, x2, x3).

Duplicator must respond by picking a constant a1 in I. Due to the universal quantification in ϕ,
I |= ∃x2 ∀x3 ψ(a1, x2, x3),
regardless of which a1 was picked. Next Spoiler picks a constant a2 in I such that I |= ∀x3 ψ(a1, a2, x3).

Regardless of which constant b2 in J Duplicator picks,
J |= ∃x3 ¬ψ(b1, b2, x3).

Finally Spoiler picks b3 in J such that J |= ¬ψ(b1, b2, b3); Duplicator picks some a3 in I, and I |= ψ(a1, a2, a3).

436
First Order, Fixpoint, and While
a 1
a 3
B
a 2
B 1
b
b
1
3
b 2
B 2
Figure 17.3:
Two undistinguishable graphs
Theorem 17.2.2 provides an important tool for proving that certain properties are not definable by CALC. It is sufficient to exhibit, for each r, two instances Ir and Jr such that Ir has the property, Jr does not, and Ir ≡r Jr. In the next proposition, we illustrate the use of this technique by showing that graph connectivity, and therefore transitive closure, is not expressible in CALC.

Proposition 17.2.3
Let R be a database schema consisting of one binary relation. Then the query conn defined by
conn(I) = true iff I is a connected graph is not expressible in CALC.

Crux
Suppose that there is a CALC sentence ϕ checking graph connectivity. Let r be the quantifier depth of ϕ. We exhibit a connected graph Ir and a disconnected graph Jr such that Ir ≡r Jr. Then, by Theorem 17.2.2, the two instances satisfy ϕ or none does, a contradiction.

For a sufficiently large n (depending only on r; see Exercise 17.5), the graph Ir consists of a cycle B of 2n nodes and the graph Jr of two disjoint cycles B1 and B2 of n nodes each (see Fig. 17.3). We outline the winning strategy for Duplicator. The main idea is simple: Two nodes a, a′ in Ir that are far apart behave in the same way as two nodes b, b′ in Jr that belong to different cycles. In particular, Spoiler cannot take advantage of the fact that a, a′
are connected but b, b′ are not. To do so, Spoiler would have to exhibit a path connecting a to a′, which Duplicator could not do for b and b′. However, Spoiler cannot construct such a path because it requires choosing more than r nodes.

For example, if Spoiler picks an element a1 in Ir, then Duplicator picks an arbitrary element b1, say in B1. Now if Spoiler picks an element b2 in B2, then Duplicator picks an element a2 in Ir far from a1. Next, if Spoiler picks a b3 in B1 close to b1, then Duplicator picks an element a3 in Ir close to a1. The graphs are sufficiently large that this can proceed
17.3 Fixpoint and While Queries 437
for r moves with the resulting subgraphs isomorphic. The full proof requires a complete case analysis on the moves that Spoiler can make.

The preceding technique can be used to show that many other properties are not expressible in CALC—for instance, even, 2-colorability of graphs, or Eulerian graphs (i.e., graphs for which there is a cycle that passes through each edge exactly once) (see Exercise 17.7).

17.3
Fixpoint and While Queries
That transitive closure is not expressible in CALC has been the driving force behind extending relational calculus and algebra with recursion. In this section we discuss the expressiveness and complexity of the two main extensions of these languages with recursion: the fixpoint and while queries.

It is relatively easy to place an upper bound on the complexity of fixpoint and while queries. Recall that the main distinction between languages defining fixpoint queries and those defining while queries is that the first are inflationary and the second are not (see Chapter 14). It follows that fixpoint queries can be implemented in polynomial time and while queries in polynomial space. Moreover, these bounds are tight, as shown next.

Theorem 17.3.1
(a) The fixpoint queries are complete in ptime.

(b) The while queries are complete in pspace.

Crux
The fact that each fixpoint query is in ptime follows immediately from the inflationary nature of languages defining the fixpoint queries and the fact that the total number of tuples that can be built from constants in a given instance is polynomial in the size of the instance (see Chapter 14). For while, inclusion in pspace follows similarly (see Exercise 17.11). The completeness follows from an important result that will be shown in Section 17.4. The result, Theorem 17.4.2, states that if an order on the constants of the domain is available, fixpoint expresses exactly qptime and while expresses exactly qpspace.

The completeness then follows from the fact that there exist problems that are complete in ptime and problems that are complete in pspace (see Exercise 17.11).

The Parity Query
As was the case for the first-order queries, fixpoint and while do not match precisely with complexity classes of queries. Although they are powerful, neither fixpoint nor while can express certain simple queries. The typical example is the parity query even on a unary relation. We next provide a direct proof that while (and therefore fixpoint) cannot express even. The result also follows using 0-1 laws, which are presented later. We present the direct proof here to illustrate the proof technique of hyperplanes.

438
First Order, Fixpoint, and While
Proposition 17.3.2
The query even is not a while query.

Proof
Let R be a unary relation. Suppose that there exists a while program w that computes the query even on input R. We can assume, w.l.o.g., that R contains a unary relation ans so that, on input I, w(I)( ans) = ∅ if |I| is even, and w(I) = I otherwise. Let R
be the schema of w (so R contains R and ans). We will reach a contradiction by showing that the computation of w on a given input is essentially independent of its size. More precisely, for n large enough, the computations of w on all inputs of size greater than n will in some sense be identical. This contradicts the fact that ans should be empty at the end of some computations but not others.

To show this, we need a short digression related to computations on unary relations.

We assume here that w does not use constants, but the construction can be generalized to that case (see Exercise 17.14). Let I be an input instance and k an integer. We consider a partition of the set of k-tuples with entries in adom(I) into hyperplanes based on patterns of equalities and inequalities between components as follows. For each equivalence relation
≃ over {1, . . . , k}, the corresponding hyperplane is defined by3
H≃(I) = {u1, . . . , uk | for each i, j ∈ [1, k],
ui, uj ∈ adom(I) and ui = uj ⇔ i ≃ j }.

For instance, let adom(I) = {a, b, c}, k = 3 and
≃= {1, 1, 2, 2, 1, 2, 2, 1, 3, 3}.

Then
H≃(I) = {a, a, b, a, a, c, b, b, a, b, b, c, c, c, a, c, c, b}.

Finally there are two 0-ary hyperplanes, denoted true and false, that evaluate to {} and {}, respectively.

We will see that a while computation cannot distinguish between two k-tuples in the same hyperplane, and so intermediate relations of arity k will always consist of a union of hyperplanes.

Now consider the while program w. We assume that the condition guarding each while loop has the form R = ∅ for some R ∈ R, and that in each assignment R := E, E involves a single application of some unary or binary algebra operator. We label the statements of the program so we can talk about the program state (i.e., the label) after some number of computation steps on input I. We include two labels in a while statement in the following manner:
label1 while condition do label2 statement .

3 Note that, in logic terminology, ≃ corresponds to the notion of equality type, and hyperplanes correspond to realizations of equality types.

17.3 Fixpoint and While Queries 439
Let N be the maximum arity of any relation in R. To conclude the proof, we will show by induction on the steps of the computation that there is a number bw such that for each input I with size ≥ N , w terminates on I after exactly bw steps. Furthermore, (*) for each step m ≤ bw, there exists a label jm and for each relation T of arity k a set ET ,m of equivalence relations over {1, . . . , k} such that for each input I of size greater than N
1. the control is at label jm after m steps of the computation; and 2. each T then contains ∪{H≃(I) | ≃ in ET,m}.

To see that this yields the result, suppose that it is true. Then for each I with size ≥ N , w terminates with ans always empty or always nonempty, regardless of whether the size of I is even or odd (a contradiction).

The claim follows from an inductive proof of (*). It is clear that this holds at the 0th step. At the start of the computation, all T are empty except for the input unary relation R, which contains all constants and so consists of the hyperplane H≃, where
≃= {1, 1}. Suppose now that (*) holds for each step less than m and that the program has not terminated on any I with size ≥ N . We prove that (*) also holds for m. There are two cases to consider:
• Label jm−1 occurs before the keyword while. By induction, the relation controlling the loop is empty after the (m − 1)st step, for all inputs large enough, or nonempty for all such inputs. Thus at step m, the control will be at the same label for all instances large enough, so (*1) holds. No relations have been modified, so (*2) also holds.

• Otherwise jm−1 labels an assignment statement. Then after the (m − 1)st step, the control will clearly be at the label of the next statement for all instances large enough, so (*1) holds. With regard to (*2), we consider the case where the assignment is T := Q1 × Q2 for some variables T , Q1, and Q2; the other relation operators are handled in a similar fashion (see Exercise 17.12). By induction, (*2) holds for all relations distinct from T because they are not modified. Consider T . After step m, T contains


{H≃ (I) | ≃
{H (I) | ≃
1
1 in EQ1,m−1} ×
≃2
2 in EQ2,m−1} =
{H≃ (I) × H (I) | ≃
1
≃2
1 in EQ1,m−1, ≃2 in EQ2,m−1}.

Let k, l be the arities of Q1, Q2, respectively, and for each ≃2 in EQ2,m−1, let
≃+k= {(x + k, y + k) | (x, y) ∈ ≃
2
2}.

For an arbitrary binary relation γ ⊆ [1, k + l] × [1, k + l], let γ ∗ denote the reflexive, symmetric, and transitive closure of γ . For ≃1, ≃2 in EQ1,m−1, EQ2,m−1, respectively, set
440
First Order, Fixpoint, and While
≃1 ⊗ ≃2 = {(≃1 ∪ ≃+k ∪A)∗ | A ⊆ [1, k] × [k + 1, k + l],
2
and for all i, i′, j, j ′ such that [i, j ] ∈ A
and [i′, j ′] ∈ A, i ≃1 i′ iff j ≃+k j ′}.

2
It is straightforward to verify that for each pair ≃1, ≃2 in EQ1,m−1, EQ2,m−1, respectively, and I with size ≥ N ,
H≃ (I) × H (I) = H
(I).

1
≃2
≃1⊗≃2
Note that this uses the assumption that the size of I is greater than N , the maximum arity of relations in w. It follows that

ET ,m =
{≃1 ⊗ ≃2 | ≃1 in EQ1,m−1 and ≃2 in EQ2,m−1}.

Thus (*2) also holds for T at step m, and the induction is completed.

The hyperplane technique used in the preceding proof is based on the fact that in the context of a (sufficiently large) unary relation input, there are families of tuples (in this case the different hyperplanes) that “travel together” and hence that the intermediate and final results are unions of these families of tuples. Although there are other cases in which the technique of hyperplanes can be applied (see Exercise 17.15), in the general case the input is not a union of hyperplanes, and so the members of a hyperplane do not travel together. However, there is a generalization of hyperplanes based on automorphisms that yields the same effect. Recall that an automorphism of I is a one-to-one mapping ρ on adom(I) such that ρ(I) = I. For fixed I, consider the following equivalence relation ≡I on k
k-tuples of adom(I): u ≡I v iff there exists an automorphism ρ of I such that ρ(u) = v.

k
(See Exercises 16.6 and 16.7 in the previous chapter.) It can be shown that if w is a while query (without constants), then the members of equivalence classes ≡I travel together k
when w is executed on input I. More precisely, suppose that J is an instance obtained at some point in the computation of w on input I. The genericity of while programs implies that if ρ is an automorphism of I, it is also an automorphism of J. Thus for each k-tuple u in some relation of J and each v such that u ≡I v, v also belongs to that relation. Thus each k
relation in J of arity k is a union of equivalence classes of ≡I . The equivalence relation ≡I k
k
will be used in our development of 0-1 laws, presented next.

0-1 Laws
We now develop a powerful tool that provides a uniform approach to resolving in the negative a large spectrum of expressibility problems. It is based on the probability that a property is true in instances of a given size. We shall prove a surprising fact: All properties expressible by a while query are “almost surely” true, or “almost surely” false. More precisely, we prove the result for while sentences:
17.3 Fixpoint and While Queries 441
Definition 17.3.3
A sentence is a total query that is Boolean (i.e., returns as answer either true or false).

Let q be a sentence over some schema R. For each n, let µn(q) denote the fraction of instances over R with entries in {1, . . . , n} that satisfy q. That is,
|{I | q(I) = true and adom(I) = {1, . . . , n}}|
µn(q) =
.

|{I | adom(I) = {1, . . . , n}}|
Definition 17.3.4
A sentence q is almost surely true ( false) if limn→∞ µn(q) exists and equals 1 (0). If every sentence in a language L is almost surely true or almost surely false, the language L has a 0-1 law.

To simplify the discussion of 0-1 laws, we continue to focus exclusively on constant-free queries (see Exercise 17.19).

We will show that CALC, fixpoint, and while sentences have 0-1 laws. This provides substantial insight into limitations of the expressive power of these languages and can be used to show that they cannot express a variety of properties. For example, it follows immediately that even is not expressible in either of these languages. Indeed, µn( even) is 1
if n is even and 0 if n is odd. Thus µn( even) does not converge, so even is not expressible in a language that has a 0-1 law.

While 0-1 laws provide an elegant and powerful tool, they require the development of some nontrivial machinery. Interestingly, this is one of the rare occasions when we will need to consider infinite instances even though we aim to prove something about finite instances only.

We start by proving that CALC has a 0-1 law and then extend the result to fixpoint and while. For simplicity, we consider only the case when the input to the query is a binary relation G (representing edges in a directed graph with no edges of the form a, a). It is straightforward to generalize the development to arbitrary inputs (see Exercise 17.19).

We will use an infinite set A of CALC sentences called extension axioms, which refer to graphs. They say, intuitively, that every subgraph can be extended by one node in all possible ways. More precisely, A contains, for each k, all sentences of the form


∀x1 . . . ∀xk((
(xi = xj )) ⇒ ∃y(
(xi = y) ∧ connections(x1, . . . , xk; y))),
i=j
i
where connections(x1, . . . , xk; y) is some conjunction of literals containing, for each xi, one of G(xi, y) or ¬G(xi, y), and one of G(y, xi) or ¬G(y, xi). For example, for k = 3, one of the 26 extension axioms is
∀x1, x2, x3 ((x1 = x2 ∧ x2 = x3 ∧ x3 = x1) ⇒
∃y (x1 = y ∧ x2 = y ∧ x3 = y ∧
G(x1, y) ∧ ¬G(y, x1) ∧ ¬G(x2, y) ∧ ¬G(y, x2) ∧ G(x3, y) ∧ G(y, x3))) specifying the pattern of connections represented in Fig. 17.4.

442
First Order, Fixpoint, and While
y
x 1
x 2
x 3
Figure 17.4:
A connection pattern
A graph G satisfies this particular extension axiom if for each triple x1, x2, x3 of distinct vertexes in G, there exists a vertex y connected to x1, x2, x3, as shown in Fig. 17.4.

Note that A consists of an infinite set of sentences and that each finite subset of A is satisfied by some infinite instance. (The instance is obtained by starting from one node and repeatedly adding nodes required by the extension axioms in the subset.) Then by the compactness theorem there is an infinite instance satisfying all of A, and by the Löwenheim-Skolem theorem (see Chapter 2) there is a countably infinite instance R satisfying A.

The following lemma shows that R is unique up to isomorphism.

Lemma 17.3.5
If R and P are two countably infinite instances over G satisfying all sentences in A, then R and P are isomorphic.

Proof
Suppose that a1a2 . . . is an enumeration of all constants in R, and b1b2 . . . is an enumeration of those in P. We construct an isomorphism between R and P by alternatingly picking constants from R and from P. We construct sequences ai . . . a . . . and 1
ik
bi . . . b . . . such that a → b is an isomorphism from R to P. The procedure for pick-1
ik
ik
ik
ing the kth constants ai and b in these sequences is defined inductively as follows. For the k
ik
base case, let ai = a
= b
. . . a and b . . . b have
1
1 and bi1
1. Suppose that sequences ai1
ik
i1
ik
been defined. If k is even, let ai
be the first constant in a
k+1
1, a2, . . . that does not occur so
far in the sequence. Let σk be the sentence in A describing the way ai extends the sub-k+1
graph with nodes ai . . . a . Because P also satisfies σ
1
ik
k, there exists a constant b in P that
extends the subgraph bi . . . b in the same manner. Let b
= b. If k is odd, the procedure
1
ik
ik+1
is reversed (i.e., it starts by choosing first a new constant from b1, b2, . . .). This back-and-forth procedure ensures that (1) all constants from both R and P occur eventually among the chosen constants, and (2) the mapping ai → b is an isomorphism.

k
ik
Thus the foregoing proof shows that there exists a unique (up to isomorphism) countable graph R satisfying A. This graph, studied extensively by Rado [Rad64] and others, is usually referred to as the Rado graph. We can now prove the following crucial lemma.

The key point is the equivalence between (a) and (c), called the transfer property: It relates satisfaction of a sentence by the Rado graph to the property of being almost surely true.

Lemma 17.3.6
Let R be the Rado graph and σ a CALC sentence. The following are
equivalent:
(a) R satisfies σ ;
17.3 Fixpoint and While Queries 443
(b) A implies σ ; and
(c) σ is almost surely true.

Proof
(a) ⇒ (b): Suppose (a) holds but (b) does not. Then there exists some instance P
satisfying A but not σ . Because P satisfies A, P must be infinite. By the Lowënheim-Skolem theorem (see Chapter 2), we can assume that P is countable. But then, by Lemma 17.3.5, P is isomorphic to R. This is a contradiction, because R satisfies σ but P
does not.

(b) ⇒ (c): It is sufficient to show that each sentence in A is almost surely true.

Suppose this is the case and A implies σ . By the compactness theorem, σ is implied by some finite subset A′ of A. Because every sentence in A′ is almost surely true, the conjunction
A′ of these sentences is almost surely true. Because σ is true in every instance where
A′ is true, µn(σ ) ≥ µn(
A′), so µn(σ ) converges to 1 and σ is almost
surely true.

It remains to show that each sentence in A is almost surely true. Consider the following sentence σk in A:


∀x1 . . . ∀xk((
(xi = xj )) → ∃y(
(xi = y) ∧ connections(x1, . . . , xk; y))).

i=j
i
Then ¬σk is the sentence

∃x1 . . . ∃xk((
(xi = xj )) ∧
i=j

∀y(
(xi = y) → ¬ connections(x1, . . . , xk; y))).

i
We will show the following property on the probability that an instance with n constants does not satisfy σk:
1
(**)
µn(¬σk) ≤ n · (n − 1) · . . . · (n − k) · (1 −
)(n−k).

22k
Because limn→∞[n · (n − 1) · . . . · (n − k) · (1 − 1 )(n−k)] = 0, it follows that lim 22k
n→∞ µn
(¬σk) = 0, so ¬σk is almost surely false, and σk is almost surely true.

Let N be the number of instances with constants in {1, . . . , n}. To prove (**), observe the following:
1. For some fixed distinct a1, . . . , ak, b in {1, . . . , n}, the number of I satisfying some fixed literal in connections(a1, . . . , ak; b) is 1 · N.

2
2. For some fixed distinct a1, . . . , ak, b in {1, . . . , n}, the number of I satisfying connections(a1, . . . , ak; b) is 1 · N (because there are 2k literals in connections).

22k
3. The number of I not satisfying connections(a1, . . . , ak; b) is therefore N − 1 · N = (1 − 1 ) · N .

22k
22k
444
First Order, Fixpoint, and While
4. For some fixed a1, . . . , ak in {1, . . . , n}, the number of I satisfying

∀y(
(ai = y) → ¬ connections(a1, . . . , ak; y))
i
is (1 − 1 )n−k · N [because there are (n − k) ways of picking b distinct from 22k
a1, . . . , ak)].

5. The number of I satisfying ¬σk is thus at most
1
n · (n − 1) · . . . · (n − k) · (1 −
)(n−k) · N
22k
(from the choices of a1, . . . , ak). Hence (**) is proven.

(See Exercise 17.16.)

(c) ⇒ (a): Suppose that R does not satisfy σ (i.e., R |= ¬σ ). Because (a) ⇒ (c), ¬σ
is almost surely true. Then σ cannot be almost surely true (a contradiction).

The 0-1 law for CALC follows immediately.

Theorem 17.3.7
Each sentence in CALC is almost surely true or almost surely false.

Proof
Let σ be a CALC sentence. The Rado graph R satisfies either σ or ¬σ . By the transfer property [(a) ⇒ (c) in Lemma 17.3.6], σ is almost surely true or ¬σ is almost surely true. Thus σ is almost surely true or almost surely false.

The 0-1 law for CALC can be extended to fixpoint and while. We prove it next for while (and therefore fixpoint). Once again the proof uses the Rado graph and extends the transfer property to the while sentences.

Theorem 17.3.8
Every while sentence is almost surely true or almost surely false.

Proof
We use as a language for the while queries the partial fixpoint logic CALC+µ.

The main idea of the proof is to show that every CALC+µ sentence that is defined on all instances is in fact equivalent almost surely to a CALC sentence, and so by the previous result is almost surely true or almost surely false. We show this for CALC+µ sentences.

By Theorem 14.4.7, we can consider w.l.o.g. only sentences involving one application of the partial fixpoint operator µ. Thus consider a CALC+µ sentence ξ of the form ξ = ∃,
x (µT (ϕ(T ))(,t))
over schema R, where
(a) ϕ is a CALC formula, and
(b) ,t is a tuple of variables or constants of appropriate arity, and , x is the tuple of
distinct free variables in ,t.

17.3 Fixpoint and While Queries 445
(We need the existential quantification for binding the free variables. An alternative is to have constants in ,t but, as mentioned earlier we do not consider constants when discussing 0-1 laws.)

Essentially, a computation of a query ξ consists of iterating the CALC formula ϕ until convergence occurs (if ever). Consider the sequence {ϕi(I)}i>0, where I is an input. If I is finite, the sequence is periodic [i.e., there exist N and p such that, for each n ≥ N , ϕn(I) = ϕn+p(I)]. If p = 1, then the sequence converges (it becomes constant at some point); otherwise it does not. Now consider the sequence {ϕi(R)}i>0, where R is the Rado graph. Because the set of constants involved is no longer finite, the sequence may or may not be periodic. A key point in our proof is the observation that the sequence {ϕi(R)}i>0 is indeed periodic, just as in the finite case.

To see this, we use a technique similar to the hyperplane technique in the proof of Lemma 17.3.5. Let k be some integer. We argue next that for each k, there is a finite number of equivalence classes of k-tuples induced by automorphisms of R. For each pair u, v of k-tuples with entries in adom(R), let u ≡R v iff there exists an automorphism ρ of R such k
that ρ(u) = v.

Let u ≃R v if both the patterns of equality and the patterns of connection within u and k
v are identical. More formally, for each u = a1, . . . , ak, v = b1, . . . , bk (where ai and bi are constants in R), u ≃R v if
k
• for each i, j , ai = aj iff bi = bj , and
• for each i, j , ai, aj is an edge in R iff bi, bj is an edge in R.

We claim that
u ≡R
k
v iff u ≃R
k v.

The “only if” part follows immediately from the definitions. For the “if” part, suppose that u ≃R v. To show that u ≡R v, we must build an automorphism ρ of R such that ρ(u) = v.

k
k
This is done by a back-and-forth construction, as in Lemma 17.3.5, using the extension axioms satisfied by R (see Exercise 17.18).

Because there are finitely many patterns of connection and equality among k vertexes, there are finitely many equivalence classes of ≃R, so of ≡R. Due to genericity of the while k
k
computation, each ϕi(R) is a union of such equivalence classes (see Exercise 16.6 in the previous chapter). Thus there must exist m, l, 0 ≤ m < l, such that ϕm(R) = ϕl(R). Let N = m and p = l − m. Then for each n ≥ N , ϕn(R) = ϕn+p(R). It follows that: (1) {ϕi(R)}i>0 is periodic.

Using this fact, we show the following:
(2) The sequence {ϕi(R)}i>0 converges.

(3) The sentence ξ is equivalent almost surely to some CALC sentence σ .

Before proving these, we argue that (2) and (3) will imply the statement of the theorem.

Suppose that (2) and (3) holds. Suppose also that σ is false in R. By Lemma 17.3.6, σ is almost surely false. Then µn(ξ ) ≤ µn(ξ ≡ σ ) + µn(σ ) and both µn(ξ ≡ σ ) and µn(σ )
446
First Order, Fixpoint, and While
converge to 0, so limn→∞(µn(ξ )) = 0. Thus ξ is also almost surely false. By a similar argument, ξ is almost surely true if σ is true in R.

We now prove (2). Let $ij be the CALC sentence stating that ϕi and ϕj are equivalent.

Suppose {ϕi(R)}i>0 does not converge. Thus the period of the sequence is greater than 1, so there exist m, j, l, m < j < l, such that
ϕm(R) = ϕl(R) = ϕj (R).

Thus R satisfies the CALC sentence
χ = $ml ∧ ¬$mj .

Let I range over finite databases. Because ξ is defined on all finite inputs, {ϕi(I)}i≥0
converges. On the other hand, by the transfer property (Lemma 17.3.6), χ is almost surely true. It follows that the sequence {ϕi(I)}i>0 diverges almost surely. In particular, there exist finite I for which {ϕi(I)}i>0 diverges (a contradiction).

The proof of (3) is similar. By (1) and (2), the sequence {ϕi(R)}i>0 becomes constant after finitely many iterations, say N . Then ξ is equivalent on R to the CALC sentence σ =
∃,
x(ϕN (,t)). Suppose R satisfies ξ . Thus R satisfies σ . Furthermore, R satisfies $N(N+1) because {ϕi(R)}i>0 becomes constant at the Nth iteration. Thus R satisfies σ ∧ $N(N+1).

By the transfer property for CALC, σ ∧ $N(N+1) is almost surely true. For each finite instance I where $N(N+1) holds, {ϕi(I)}i>0 converges after N iterations, so ξ is equivalent to σ . It follows that ξ is almost surely equivalent to σ . The case where R does not satisfy ξ is similar.

Thus we have shown that while sentences have a 0-1 law. It follows immediately that many queries, including even, are not while sentences. The technique of 0-1 laws has been extended successfully to languages beyond while. Many languages that do not have 0-1 laws are also known, such as existential second-order logic (see Exercise 17.21). The precise border that separates languages that have 0-1 laws from those that do not has yet to be determined and remains an interesting and active area of research.

17.4
The Impact of Order
In this section, we consider in detail the impact of order on the expressive power of query languages. As mentioned at the beginning of this chapter, we view the assumption of order as, in some sense, suspending the data independence principle in a database. Because data independence is one of the main guiding principles of the pure relational model, it is important to understand its consequences in the expressiveness and complexity of query languages.

As illustrated by the even query, order can considerably affect the expressiveness of a language and the difficulty of computing some queries. Without the order assumption, no expressiveness results are known for the complexity classes of ptime and below; that is, no
17.4 The Impact of Order
447
P
succ
b
a
c
a
b
b
b
d
b
c
c
a
d
c
d
d
b
a
Figure 17.5:
An ordered instance
languages are known that express precisely the queries of those complexity classes. With order, there are numerous such results. We present two of the most prominent ones.

At the end of this section, we present two recent developments that further explore the interplay of order and expressiveness. The first is a normal form for while queries that, speaking intuitively, separates a while query into two components: one unordered and the second ordered. The second development increases expressive power on unordered input by introducing nondeterminism in queries.

We begin by making the notion of an ordered database more precise. A database is said to be ordered if it includes a designated binary relation succ that provides a successor relation on the constants occurring in the database. A query on an ordered database is a query whose input database schema contains succ and that ranges only over the ordered instances of the input database schema.

Example 17.4.1
Consider the database schema R = {P , succ}, where P is ternary. An ordered instance of R is represented in Fig. 17.5. According to succ, a is the first constant, b is the successor of a, c is the successor of b, and d is the successor of c. Thus a, b, c, d can be identified with the integers 1, 2, 3, 4, respectively.

We now consider the power of fixpoint and while on ordered databases. In particular, we prove the fundamental result that fixpoint expresses precisely qptime on ordered databases, and while expresses precisely qpspace on ordered databases. This shows that order has a far-reaching impact on expressiveness, well beyond isolated cases such as the even query. More broadly, the characterization of qptime by fixpoint (with the order assumption) provides an elegant logical description of what have traditionally been considered the tractable problems. Beyond databases, this is significant to both logic and complexity theory.

Theorem 17.4.2
(a) Fixpoint expresses qptime on ordered databases.

(b) While expresses qpspace on ordered databases.

Proof
Consider (a). We have already seen that fixpoint ⊆ qptime (see Exercise 17.11), and so it remains to show that all qptime queries on ordered databases are expressible in fixpoint. Let q be a query on a database with schema R that includes succ, such that q is
448
First Order, Fixpoint, and While
in qptime on the ordered instances of R. Thus there is a polynomial p and Turing machine M′ that, on input enc(I)# enc(u), terminates in time p(| enc(I)# enc(u)|) and accepts the input iff u ∈ q(I). (In this section, encodings of ordered instances are with respect to the enumeration of constants provided by succ; see also Chapter 16.) Because q(I) has size polynomial in I, a TM M can be constructed that runs in polynomial time and that, on input enc(I), produces as output enc(q(I)). We now describe the construction of a CALC+µ+
query qM that is equivalent to q on ordered instances of R.

The fixpoint query qM we construct, when given ordered input I, will operate in three phases: (α) construct an encoding of I that can be used to simulate M; (β) simulate M; and (γ ) decode the output of M. A key point throughout the construction is that qM is inflationary, and so it must compute without ever deleting anything from a relation. Note that this restriction does not apply to (b), which simplifies the simulation in that case.

We next describe the encoding used in the simulation of M. The encoding is centered around a relation that holds the different configurations reached by M.

Representing a tape. Because the tape is infinite, we only represent the finite portion, polynomial in length, that is potentially used. We need a way to identify each cell of the tape. Let nc be the number of constants in I. Because M runs in polynomial time, there is some k such that M on input enc(I) takes time ≤ nk, and thus ≤
tape cells (see also
c
nkc
Exercise 16.12 in the previous chapter). Consider the world of k-tuples with entries in the constants from I. Note that there are nk such tuples and that they can be lexicographically c
ordered using succ. Thus each cell can be uniquely identified by a k-tuple of constants from I. One can define by a fixpoint query a 2k-ary relation succ k providing the successor relation on k-tuples, in the lexicographic order induced by succ (see Exercise 17.23a). The ordered k-tuples thus allow us to represent a sequence of cells and hence M’s tape.

Representing all the configurations. Note that one cannot remove the tuples representing old configurations of M due to the inflationary nature of fixpoint computations. Thus one represents all the configurations in a single relation. To distinguish a particular configuration (e.g., that at time i, i ≤ nk),
c
k-columns are used as timestamp. Thus to keep track of
the sequence of configurations in a computation of M, one can use a (2k + 2)-ary relation RM where
1. the first k columns serve as a timestamp for the configuration,
2. the next k identify the tape cells,
3. column (2k + 1) holds the content of the cell, and
4. column (2k + 2) indicates the state and position of the head.

Note that now we are dealing with a double encoding: The database is encoded on the tape, and then the tape is encoded back into RM.

To illustrate this simple but potentially confusing situation, we consider an example.

Let R = {P , succ}, and let I be the ordered instance of R represented in Fig. 17.5. Then enc(I) is represented in Fig. 17.6. We assume, without loss of generality, that symbols in the tape alphabet and the states of M are in dom. Parts of the first two configurations are represented in the relation shown in Fig. 17.7. The representation assumes that k = 4, so the arity of the relation is 10. Because this is a single-volume book, only part of the relation is shown. More precisely, we show the first tuples from the representation of the
17.4 The Impact of Order
449
P[1#0#10][1#1#11][10#0#11][11#1#0] succ[0#1][1#10][10#11]
Figure 17.6:
Encoding of I and u on a TM tape
first two configurations. It is assumed that the original state is s and the head points to the first cell of the tape; and that in that state, the head moves to the right, changing P to 0, and the machine goes to state r. Observe that the timestamp for the first configuration is a, a, a, a, and a, a, a, b for the second. Observe also the numbering of tape cells: a, a, a, a, . . . , a, a, c, d, etc.

We can now describe the three phases of the operation of qM more precisely: For a given ordered instance I, qM
(α) computes, in RM, a representation of the initial configuration of M on input enc(I); (β) computes, also in RM, the sequence of consecutive configurations of M until termination; and
(γ ) decodes the final tape contents of M, as represented in RM, into the output relation.

We sketch the construction of the fixpoint queries realizing (α) and (β) here, and we leave (γ ) as an exercise (17.23).

Consider phase (α). Recall that each constant is encoded on the tape of M as the binary representation of its rank in the successor relation succ (e.g., c as 10). To perform the encoding of the initial configuration, it is useful first to construct an auxiliary relation that provides the encoding of each constant. Because there are nc constants, the code of each constant requires ≤ ⌈log(nc)⌉ bits, and thus less than nc bits. We can therefore use a ternary relation constant _ coding to record the encoding. A tuple x, y, z in that relation indicates that the kth bit of the encoding of constant x is z, where k is the rank of constant y in the succ relation. For instance, the relation constant _ coding corresponding to the succ in Fig. 17.5 is represented in Fig. 17.8. The tuples c, a, 1 and c, b, 0 indicate, for instance, that c is encoded as 10. It is easily seen that constant _ coding is definable from succ by a fixpoint query (see Exercise 17.23b).

With relation constant _ coding constructed, the task of computing the encoding of I and u into RM is straightforward. We will illustrate this using again the example in Fig. 17.5. To encode relation P , one steps through all 3-tuples of constants and checks if a tuple in P has been reached. To step through the 3-tuples, one first constructs the successor relation succ 3 on 3-tuples. The first tuple in P that is reached is b, a, c. Because this is the first tuple encoded, one first inserts into RM the identifying information for P (the first tuple in Fig. 17.7). This proceeds, yielding the next tuples in Fig. 17.7. The binary representation for each of b, a, c is obtained from relation constant _ coding. This proceeds by moving to the next 3-tuple. It is left to the reader to complete the details of the fixpoint query constructing RM (see Exercise 17.23c). Several additional relations have to be used for bookkeeping purposes. For instance, when stepping through the tuples in succ 3, one must keep track of the last tuple that has been processed.

We next outline the construction for (β). One must simulate the computation of M
starting from the initial configuration represented in RM. To construct a new configuration from the current one, one must simulate a move of M. This is repeated until M reaches
450
First Order, Fixpoint, and While
RM
a
a
a
a
a
a
a
a
P
s
a
a
a
a
a
a
a
b
[
0
a
a
a
a
a
a
a
c
1
0
a
a
a
a
a
a
a
d
#
0
a
a
a
a
a
a
b
a
0
0
a
a
a
a
a
a
b
b
#
0
a
a
a
a
a
a
b
c
1
0
a
a
a
a
a
a
b
d
0
0
a
a
a
a
a
a
c
a
]
0
a
a
a
a
a
a
c
b
[
0
a
a
a
a
a
a
c
c
1
0
a
a
a
a
a
a
c
d
#
0
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

a
a
a
b
a
a
a
a
0
0
a
a
a
b
a
a
a
b
[
r
a
a
a
b
a
a
a
c
1
0
a
a
a
b
a
a
a
d
#
0
a
a
a
b
a
a
b
a
0
0
a
a
a
b
a
a
b
b
#
0
a
a
a
b
a
a
b
c
1
0
a
a
a
b
a
a
b
d
0
0
a
a
a
b
a
a
c
a
]
0
a
a
a
b
a
a
c
b
[
0
a
a
a
b
a
a
c
c
1
0
a
a
a
b
a
a
c
d
#
0
.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

Figure 17.7:
Coding of part of the (first two) configurations
a final state (accepting or rejecting), which, as we assumed earlier, happens after at most nk steps. The iteration can be performed using the fixpoint operator in c
CALC + µ+. Each
step consists of defining the new configuration from the current one, timestamping it, and adding it to RM. This can be done with a CALC formula. For instance, suppose the current state of M is q, the content of the current cell is 0, and the corresponding move of M is to change 0 to 1, move right, and change states from q to r. Suppose also that
17.4 The Impact of Order
451
constant _ coding
a
a
0
b
a
1
c
a
1
c
b
0
d
a
1
d
b
1
Figure 17.8:
The relation constant _ coding corresponding to a,b,c,d
• ,t is the timestamp (in the example this is a 4-tuple) identifying the current configuration,
• RM contains the tuple ,t, ,j, 0, q, where ,j specifies a tape cell (in the example again with a 4-tuple), and
• ,
t ′ is the next timestamp and ,
j ′ the next cell [i.e., succ k(,t, ,
t ′) and succ k(,
j , ,
j ′)].

The tuples describing the new configuration of M are
(a) ,
t ′, ,i, x, y if ,i = ,
j , ,i = ,
j ′ and ,t, ,i, x, y ∈ RM;
(b) ,
t ′, ,
j , 1, 0;
(c) ,
t ′, ,
j ′, x, r if ,t, ,
j ′, x, 0 ∈ RM.

In other words, (a) says that the cells other than the j th cell and the next cell remain unchanged; (b) says that the content of cell j changes from 0 to 1, and the head no longer points to the j th cell; finally, (c) says that the head points to the right adjacent cell, the new state is r, and the content of that cell is unchanged. Clearly, (a) through (c) can be expressed by a CALC formula (Exercise 17.23d). One such formula is needed for each move of M, and the formula corresponding to the finite set of possible moves is obtained by their disjunction.

We have outlined queries that realize (α) and (β) (i.e., perform the encoding needed to run M and then simulate the run of M). Using these fixpoint queries and their analog for phase (γ ), it is now easy to construct the fixpoint query qM that carries out the complete computation of q. This completes the proof of (a).

The construction for (b) is similar. The difference lies in the fact that a while computation need not be inflationary, unlike fixpoint computations. This simplifies the simulation.

For instance, only the tuples corresponding to the current configuration of M are kept in RM (Exercise 17.24).

Although ptime is considered synonymous with tractability in many circumstances, complexity classes lower than ptime are most useful in practice in the context of potentially large databases. There are numerous results that extend the logical characterization of qptime to lower complexity classes for ordered databases. For instance, by limiting the fixpoint operator in fixpoint to simpler operators based on various forms of transitive
452
First Order, Fixpoint, and While
closure, one can obtain languages expressing qlogspace and qnlogspace on ordered databases.

Theorem 17.4.2 implies that the presence of order results in increased expressive power for the fixpoint and while queries. For these languages, this is easily seen (for instance, even can be expressed by fixpoint when an order is provided). For weaker languages, the impact of order may be harder to see. For instance, it is not obvious whether the presence of order results in increased expressive power for CALC. The query even is of no immediate help, because it cannot be expressed by CALC even in the presence of order (Exercise 17.8). However, a more complicated query based on even can be used to show that CALC does indeed become more expressive with an order (Exercise 17.27). Because the CALC queries on ordered instances remain in ac0, this shows in particular that there are queries in ac0 that CALC cannot express.

From Chaos to Order: A Normal Form for While
We next discuss informally a normal form for the while queries that provides a bridge between computations without order and computations with order. This helps us understand the impact of order and the cost of computation without order.

The normal form says, intuitively, that each while query on an unordered instance can be reduced to a while query over an ordered instance via a fixpoint query. More precisely, a while program in the normal form consists of two phases. The first is a fixpoint query that performs an analysis of the input. It computes an equivalence relation on tuples that is a congruence with respect to the rest of the computation, in that equivalent tuples are treated identically throughout the computation. Thus each equivalence class is treated as an indivisible block of tuples that is never split later in the computation. The fixpoint query outputs the equivalence classes in some order, so that each class can be thought of abstractly as an integer. The second phase consists of a while query that can be viewed as computing on an ordered database obtained by replacing each equivalence class produced in the analysis phase by its corresponding integer.

The normal form also allows the clarification of the relationship between fixpoint and while. Because on ordered databases the two languages express qptime and qpspace, respectively, the languages are equivalent on ordered databases iff ptime = pspace. What about the relationship of these languages without the order assumption? It turns out that the normal form can be used to extend this result to the general case when no order is present.

We do not describe the normal form in detail, but we provide some intuition on how a query on an unordered database reduces to a query on an ordered database.

Consider a while program q and a particular instance. There are only finitely many CALC queries that are used in q, and the number of their variables is bounded by some integer, say k. To simplify, assume that the input instance consists of a single relation I of arity k and that all relations used in q also have arity k. We can further assume that all queries used in assignment statements are either conjunctive queries or the single algebra operations −, ∪, and that no relation name occurs twice in a query. For a query ϕ in q, ϕ(R1, . . . , Rn) indicates that R1, . . . , Rn are the relation names occurring in ϕ.

Consider the set J of k-tuples formed with the constants from I . First we can distinguish between tuples based on their presence in (or absence from) I . This yields a first par-
17.4 The Impact of Order
453
tition of J . Now using the conjunctive queries occurring in q, we can iteratively refine this partition in the following way: If for some conjunctive query ϕ(R1, . . . , Rn) occurring in q and some blocks B1, . . . , Bn of the current partition ϕ(B1, . . . , Bn) and ¬ϕ(B1, . . . , Bn) have nonempty intersection with some block B′ of the current partition, we refine the partition by splitting the block B′ into B′ ∩ ϕ(B1, . . . , Bn) and B′ ∩ ¬ϕ(B1, . . . , Bn). This is repeated until no further refinement occurs, yielding a final partition of J . Furthermore, the blocks can be numbered as they are produced, which provides an ordering J1, . . . , Jm of the blocks of the partition. The entire computation can be performed by a fixpoint query constructed from q.

It is important to note that two tuples u, v in one block of the final partition cannot be separated by the computation of q on input I (i.e., at each step of this computation, each relation either contains both u and v or none). In other words, each relation contains a union of blocks of the final partition. Then one can reduce the original computation to an abstract computation q′ on the integers by replacing the ith block of the partition by integer i. Thus the original query q can be rewritten as the composition of a fixpoint query f followed by a while query q′ that essentially operates on an ordered input.

Using this normal form, one can show the following:
Theorem 17.4.3
While = fixpoint iff ptime = pspace.

Crux
The “only if” part follows from Theorem 17.4.2. The normal form is used for the
“if” part as follows. Suppose ptime = pspace. Then qptime = qpspace. Let q be a while query. By the normal form, q = f q′, where f is a fixpoint query and q′ is a while query whose computation is isomorphic to that of a while query on an ordered domain. Because q′ is in pspace and pspace = ptime, q′ is in ptime. By Theorem 17.4.2(a), there exists a fixpoint query f ′ equivalent to q′ on the ordered domain. Thus q is equivalent to ff ′ and is a fixpoint query.

An Alternative to Order: Nondeterminism
Results such as Theorem 17.4.2 show that the presence of order can solve some of the problems of expressiveness of query languages. This can be interpreted as a trade-off between expressiveness and the data independence provided by the abstract interface to the database system. We conclude this section by considering an alternative to order for increasing expressive power. It is based on the use of nondeterminism.

We will use the following terminology. A deterministic query is a classical query that always produces at most one output for each input instance. A nondeterministic query is a query that may have more than one possible outcome on a given input instance. Generally we assume that all possible outcomes are acceptable as answers to the query. For example, the query “Find one cinema showing Casablanca” is nondeterministic.

Consider again the query even, which is not expressible by fixpoint or while. The query even is easily computed by fixpoint in the presence of order (see Exercise 17.25). Another way to circumvent the difficulty of computing even is to relax the determinism of the query language. If one could choose, whenever desired, an arbitrary element from the set, this would provide another way of enumerating the elements of the set and computing even.

454
First Order, Fixpoint, and While
R
A
B
R
A
B
R
A
B
R
A
B
R
A
B
a
b
a
b
a
b
a
c
a
c
a
c
b
b
b
c
b
b
b
c
b
b
b
c
I
I1
I2
I3
I4
Figure 17.9:
An application of witness
The drawback is that, with such a nondeterministic construct in the language, determinism of queries can no longer be guaranteed.

The trade-offs based on order and nondeterminism are not unrelated, as it may seem at first. Suppose that an order is given. As argued earlier, this comes down to suspending the data independence principle and accessing the internal representation. In general, the computation may depend on the particular order accessed. Then at the conceptual level, where the order is not visible, the mapping defined by the query appears as nondeterministic. Different outcomes are possible for the same conceptual-level view of the input. Thus the trade-offs based on order and on relaxing determinism are intimately connected.

To illustrate this, we exhibit nondeterministic versions of the while(+) and CALC+µ(+) queries. In both cases we obtain exactly the (deterministic and nondeterministic) queries computable in polynomial space (time). Analogous results can be shown for lower complexity classes of queries.

Consider first the algebraic setting. We introduce a new operator called witness that provides the nondeterminism. To illustrate the use of this operator, consider the relation I in Fig. 17.9. An application of witness B to I may lead to several results [i.e., witness B(I ) is either I1, I2, I3 or I4]. Intuitively, for each x occurring in the A column, witness B
selects some tuple x, y in I , thus choosing nondeterministically a B value y for x.

More generally, for each relation J over some schema U = XY , X ∩ Y = ∅, witness Y (I ) selects one tuple ,
x, ,
y for each ,
x occurring in GX(J ). Observe that from this definition,
witness U (J ) selects one tuple in J (if any).

It is also possible to describe the semantics of the witness operator using functional dependencies: For each instance J over some schema XY , X ∩ Y = ∅, a possible result of witness Y (J ) is a maximal subinstance J ′ of J satisfying X → Y (i.e., such that the attributes in X form a key).

The witness operator provides, more generally, a uniform way of obtaining nondeterministic counterparts for traditional deterministic languages.

The extension of while(+) with witness is denoted by while(+)+W . Following is a useful example that shows that an arbitrary order can be constructed using the witness operator.

Example 17.4.4
Consider an input instance over some unary relation schema R. The
following while+W query defines all possible successor relations on the constants from
17.4 The Impact of Order
455
R
succ
max
b
c
a
a
d
(a)
R
succ
max
b
c
a
d
a
d
(b)
R
succ
A
B
max
c
a
b
a
d
d
b
(c)
Figure 17.10:
Some steps in the computation of an ordering
the input (i.e., each run constructs some ordering of the constants from the input; we use the unnamed perspective):
succ := witness 12(σ1=2(R × R));
max := π2( succ); R := R − (π1( succ) ∪ π2( succ)); while change do
begin
succ := succ ∪ witness 12( max × R); max := π2( succ) − π1( succ);
R := R − max
end
The result is constructed in a binary relation succ. A unary relation max contains the current maximum element in succ. Some steps of a possible computation on input R = {a, b, c, d}
are shown in Fig. 17.10: (a) shows the state before the loop is first entered, (b) the state after the first execution of the loop, and (c) the final state. Note that the output is empty if R contains fewer than two constants. It is of interest to observe that the program uses only the ability of witness to pick an arbitrary tuple from a relation.

This query can also be expressed in while++W . (See Exercise 17.31.) To continue with the nondeterministic languages, we next consider the language
456
First Order, Fixpoint, and While
CALC+µ(+). The nondeterminism is again provided by a logical operator called witness 4 and denoted W . Suppose ϕ(,
x, ,
y) is a formula with free variables ,
x, ,
y. Intuitively,
W ,
yϕ(,
x, ,
y) indicates that one “witness” ,
yx is chosen for each ,
x satisfying ∃ ,
y ϕ(,
x, ,
y).

For example, if R consists of the relation I in Fig. 17.9, the formula WyR(x, y) defines the possible answers I1, I2, I3, I4 in the same figure. [Thus WyR(x, y) is equivalent to witness B(R).] More precisely, for each formula ϕ(,
x, ,
y) (where ,
x and ,
y are vectors of the
variables that are free in ϕ), W ,
yϕ(,
x, ,
y) is a formula (where the ,
y remain free) defining the
set of relations I such that for some J defined by ϕ: I ⊆ J; and for each , x for which ,
x, ,
y
is in J for some ,
y, there exists a unique ,
yx such that ,
x, ,
yx is in I.

The extension of CALC+µ(+) with the witness operator is denoted by CALC+µ(+)+W . Following is a useful example that shows that an arbitrary order can be constructed using CALC+µ++W .

Example 17.4.5
Consider the (unary) relation schema R of Example 17.4.4. The following CALC+µ++W query defines, on each instance I of R, all possible successor relations on the constants in I. (The output is empty if I contains fewer than two constants.) The query uses a binary relation schema succ, which is used to construct the successor relation iteratively. The query is µ+
succ(ϕ( succ))(x, y), where ϕ = ϕ1 ∨ ϕ2 and
ϕ1(x, y) = ¬∃x∃y( succ(xy)) ∧ Wxy(R(x) ∧ R(y) ∧ x = y), ϕ2(x, y) = Wy(R(y) ∧ ¬∃z( succ(yz) ∨ succ(zy))) ∧ ∃z( succ(zx)) ∧ ¬∃z( succ(xz)).

The formula ϕ1 initializes the iteration when succ is empty; ϕ2 adds to succ a tuple x, y, where y is an arbitrarily chosen element of I(R) not yet in succ and x is the current maximum element in succ.

The ability of while++W and CALC+µ++W to define nondeterministically a successor relation on the constants suggests that the impact of nondeterminism on expressive power is similar to that of order. This is confirmed by the following result.

Theorem 17.4.6
The set of deterministic queries that are expressed by while++W or CALC+µ++W is qptime.

Proof
It is easy to verify that each deterministic query expressed by while+ + W is in qptime. Conversely, let q be a query in qptime. By Theorem 17.4.2, there exists a while+
query w that expresses q if a successor relation succ on the constants is given. Then the while++W query expressing q consists of the following:
(i) construct a successor relation succ on the constants, as in Example 17.4.5; (ii) apply query w to the input instance together with succ.

4 The witness operator is related to Hilbert’s ε-symbol [Lei69], but its semantics is different. In particular, the ε-symbol does not yield nondeterminism.

Bibliographic Notes
457
An analogous result holds for while+W and CALC+µ+W . Specifically, the set of deterministic queries expressible by these languages is precisely qpspace.

Note that Theorem 17.4.6 does not provide a language that expresses precisely qptime, because nondeterministic queries can also be expressed and it is undecidable if a while++W or CALC+µ++W query defines a deterministic query (Exercise 17.32). Instead the result shows the power of nondeterministic constructs and so points to a trade-off between expressive power and determinism.

Bibliographic Notes
The sequential data complexity of CALC was investigated by Vardi [Var82a], who showed that CALC is included in logspace. The parallel complexity of CALC, specifically the connection with ac0, was studied by Immerman [Imm87a]. In [DV91], a database model for parallel computation is defined, and CALC is shown to coincide exactly with its restriction to constant time and polynomial size. This differs from ac0 in that the match is precise.

Intuitively, this is due to the fact that the model in [DV91] is generic and does not assume an ordered encoding of the input.

The first results on the expressiveness and complexity of fixpoint and while were obtained by Chandra and Harel, Vardi, and Immerman. In [CH80b] it is shown by a direct proof that fixpoint cannot express even. The result is extended to while in [Cha81a].

The fundamental result that fixpoint expresses qptime on ordered instances was obtained independently by Immerman [Imm86] and Vardi [Var82a]. The fact that while on ordered instances expresses qpspace is shown in [Var82a].

Languages expressing complexity classes of queries below qptime are investigated in [Imm87b]. They are based on augmenting CALC with operators providing limited recursion, such as various forms of transitive closure. The classes of queries expressed by the resulting languages on ordered databases include deterministic logspace, denoted logspace, nondeterministic logspace, denoted nlogspace, and symmetric logspace, denoted slogspace.

There has been a long quest for a language expressing precisely qptime on arbitrary (unordered) databases. The problem is formalized in a general setting in [Gur88], where it is also conjectured that no such language exists. The issue is further investigated in
[Daw93], where, in particular, it is shown that there exists a language for qptime iff there exists some problem complete in p via an extended kind of first-order reductions. To date, the problem of the existence of a language for qptime remains open.

In the absence of a language for qptime, there have been several proposals to extend the fixpoint queries to capture more of qptime. Recall that queries involving counting (such as even) are not in fixpoint. Therefore it is natural to consider extensions of fixpoint with counting constructs. An early proposal by Chandra [Cha81a] is to add a bounded looping construct of the form For |R| do, which iterates the body of the loop |R| times. Clearly, this construct allows us to express even. However, it has been shown that bounded looping is not sufficient to yield all of qptime, because tests |R1| = |R2| cannot be expressed (see [Cha88]). More recently, extensions of fixpoint with counting constructs have been considered and studied in [CFI89, GO93]. They allow access to the cardinality of relations as well as limited integer manipulation. These languages are more powerful than fixpoint
458
First Order, Fixpoint, and While
but, as shown in [CFI89], still fall short of expressing all of qptime. Other results of this flavor are proven in [Daw93, Hel92]. They show that extending fixpoint with a finite set of polynomial-time computable constructs of certain forms (generalized quantifiers acting much like oracles) cannot yield a language expressing exactly qptime (see Exercise 17.35
for a simplified version of this result).

The normal form for while was proven in [AV91b, AV94]. It was also shown there, using the normal form, that fixpoint and while are equivalent iff ptime = pspace. The cost of computing without an order is also investigated in [AV91b, AV94]. This is formalized using an alternative model of computation called generic machine (GM). Unlike Turing machines, GMs do not require an ordered encoding of the input and use only the information provided by the input instance. Based on GM, generic complexity classes of queries are defined. For example, gen-ptime and gen-pspace are obtained by taking polynomial time and space restrictions of GM. As a typical result, it is shown that even is not in gen-pspace, which captures the intuition that this query is hard to compute without order. Another more restricted device, also operating without encodings, is the relational machine, also considered in [AV91b, AV94]. There is a close match between complexity classes defined using this device, called relational complexity classes, and various languages. For example, relational polynomial time coincides with fixpoint and relational polynomial space with while. Further connections between languages and relational complexity classes are shown in [AVV92].

Nondeterministic languages and their expressive power are investigated in [ASV90, AV91a, AV91c]. The languages include nondeterministic extensions of CALC+µ+ and CALC+µ and of rule-based languages such as datalog¬. Strong connections between these languages are shown (see Exercise 17.33). Nondeterministic languages that can express all the qptime queries are exhibited.

A construct related to the witness operator described in this chapter is the choice operator, first presented in [KN88]. This construct has been included in the language LDL, an implementation of datalog¬ [NT89] (see also Chapter 15). Variations of the choice operator, and its connection with stable models of datalog¬ programs, are further studied in [SZ90, GPSZ91]. The expressive power of the choice operator in the context of datalog is investigated in [CGP93] (see Exercise 17.34).

The Ehrenfeucht-Fraissé games are due to Ehrenfeucht [Ehr61] and Fraissé [Fra54].

Since their work, extensions of the games have been proposed and related to various languages such as datalog [LM89], fragments of infinitary logic [KV90c], fixpoint queries, and second-order logic [Fag75, AF90, dR87]. In [Imm82, CFI89], games are used to prove lower bounds on the number of variables needed to express certain graph properties. Typically, in the extensions of Ehrenfeucht-Fraissé games, choosing a constant in an instance is thought of as placing a pebble over that constant (the games are often referred to as pebble games). Like the Ehrenfeucht-Fraissé games, these are two-player games in which one player attempts to prove that the instances are not the same and the other attempts to prove the contrary by placing the pebbles such that the corresponding subinstances are isomorphic. The games differ in the rules for taking turns among players and instances, the number of pebbles placed in one move, whether the pebbles are colored, etc. In games corresponding to languages with recursion, players have more than one chance for achieving
Exercises
459
G[00#01][10#00][10#01][01#01]#[10]
Figure 17.11:
Encoding of an instance and tuple
their objective by removing some of the pebbles and restarting the game. Our presentation of Ehrenfeucht-Fraissé games was inspired by Kolaitis’s excellent lecture notes [Kol83].

The study of 0-1 laws was initiated by Fagin and Glebski˘i. The 0-1 law for CALC
was proven in [Fag72, Fag76] and independently by Glebski˘i et al. [GKLT69]. The 0-1 law for fixpoint was shown by Blass, Gurevich, and Kozen [BGK85] and Talanov and Knyazev [TK84]. This was extended to while by Kolaitis and Vardi, who proved further extensions of 0-1 laws for certain fragments of second-order logic [KV87, KV90b] and for infinitary logic with finitely many variables [KV92], both of which subsume while.

For instance, 0-1 laws were proven for existential second-order sentences ∃Q1 . . . ∃Qkσ , where the Qi are relation variables and σ is a CALC formula in prenex form, whose quantifier portion has one of the shapes ∃∗∀∗ or ∃∗∀∃∗. It is known that arbitrary existential second-order sentences do not have a 0-1 law (see Exercise 17.21). Infinitary logic is an extension of CALC that allows infinite disjunctions and conjunctions. Kolaitis and Vardi proved that the language consisting of infinitary logic sentences that use only finitely many variables has a 0-1 law. Note that this language subsumes while (Exercise 17.22). Another aspect of 0-1 laws that has been studied involves the difficulty of deciding whether a sentence in a language that has a 0-1 law is almost surely true or whether it is almost surely false. For instance, Grandjean proved that the problem is pspace complete for CALC
[Gra83]. The problem was investigated for other languages by Kolaitis and Vardi [KV87].

A comprehensive survey of 0-1 laws is provided by Compton [Com88].

Fagin [Fag93] presents a survey of finite model theory including 0-1 laws that inspired our presentation of this topic.

Exercises
Exercise 17.1
Consider the CALC query on a database schema with one binary relation G: ϕ = {x | ∃y∀z(G(x, y) ∧ ¬G(z, x))}.

Consider the instance I over G and tuple encoded on a Turing input tape, as shown in Fig. 17.11.

Describe in detail the computation of the Turing machine Mϕ, outlined in the proof of Theorem 17.1.1, on this input.

♠ Exercise 17.2 Prove Theorem 17.1.2.

Exercise 17.3
Prove that ≡r is an equivalence relation on instances.

Exercise 17.4
Outline the crux of Theorem 17.2.2 for the case where
ϕ = ∀x (∃y (R(xy)) ∨ ∀z (R(zx))).

(Note that the quantifier depth of ϕ is 2, so this case involves games with two moves.)

⋆ Exercise 17.5 Provide a complete description of the winning strategy outlined in the crux of Proposition 17.2.3. Hint: For the game with r moves, choose cycles of size at least r(2r+1 − 1).

460
First Order, Fixpoint, and While
Exercise 17.6
Extend Proposition 17.2.3 by showing that connectivity of graphs is not first-order definable even if an order ≤ on the constants is provided. More precisely, let R be the database schema consisting of two binary relations G and ≤. Let I≤ be the family of instances I over R such that I(≤) provides a total order on the constants of I(G). Outline a proof that there is no CALC sentence σ such that, for each I ∈ I≤,
σ (I) is true iff I(G) is a connected graph.

♠ Exercise 17.7 [Kol83] Use Ehrenfeucht-Fraissé games to show that the following properties of graphs are not first-order definable:
(i) the number of vertexes is even;
(ii) the graph is 2-colorable;
(iii) the graph is Eulerian (i.e., there exists a cycle that passes through each edge exactly once).

⋆ Exercise 17.8 Show that the property that the number of elements in a unary relation is even is not first-order definable even if an order on the constants is provided.

The following two exercises lead to a proof of the converse of Theorem 17.2.2. It states that instances that are undistinguishable by CALC sentences of quantifier depth r are equivalent with respect to ≡r. This is shown by proving that each equivalence class of ≡r is definable by a special CALC sentence of quantifier depth r, called the r-type of the equivalence class.

Intuitively, the r-type sentence describes all patterns that can be detected by playing games of length r on pairs of instances in the equivalence class.

To define the r-types, one first defines formulas with m free variables, called (m, r)-types.

An r-type is defined as a (0, r)-type. The set of (m, r)-types is defined by backward induction on m as follows.

An (r, r)-type consists of all satisfiable formulas ϕ with variables x1, . . . , xr such that ϕ is a conjunction of literals over R and for each i1, . . . , ik, either R(xi , . . . , x ) or ¬R(x , . . . , x ) 1
ik
i1
ik
is in ϕ. Suppose the set of (m + 1, r)-types has been defined. Each set S of (m + 1, r)-types gives rise to one (m, r)-type defined by


{ ∃xm+1 ϕ | ϕ ∈ S} ∨
{∀xm+1 (¬(ϕ)) | ϕ ∈ S}.

♠ Exercise 17.9 [Kol83] Let r and m be positive integers such that 0 ≤ m ≤ r. Prove that (a) every (m, r)-type is a CALC formula with free variables x1, . . . , xm and quantifier depth (r − m);
(b) there are only finitely many distinct (m, r)-types; and
(c) for every instance I and sequence a1, . . . , am of constants in I, there is exactly one (m, r)-type ϕ such that I satisfies ϕ(a1, . . . , am).

♠ Exercise 17.10 [Kol83] Prove that each equivalence class of ≡r is definable by a CALC
sentence of quantifier depth r. Hint: For a given equivalence class of ≡r, consider an instance in the class and the unique r-type satisfied by the instance.

Exercise 17.11
Complete the proof of Theorem 17.3.1; specifically show that
(a) fixpoint ⊆ qptime and while ⊆ qpspace, and
Exercises
461
(b) fixpoint is complete in ptime and while is complete in pspace.

Exercise 17.12
In the proof of Proposition 17.3.2, the case of assignments of the form T :=
Q1 × Q2 was discussed. Describe the constructions needed for the other algebra operators. Point out where the assumption that the size of I is greater than N is used.

⋆ Exercise 17.13 Prove that the while queries collapse to CALC on unary relation inputs. More precisely, let R be a database schema consisting of unary relations. Show that for each while query w on R there exists a CALC query ϕ equivalent to it. Hint: Use the same approach as in the proof of Proposition 17.3.2 to show that there is a constant bound on the length of runs of a given while program on unary inputs.

⋆ Exercise 17.14 Describe how to generalize the proof of Proposition 17.3.2 so that it handles while queries that have constants. In particular, describe how the notion of hyperplanes needs to be generalized.

Exercise 17.15
Recall the technique of hyperplanes used in the proof of Proposition 17.3.2.

(a) Let D ⊆ dom be finite. For a relation schema R, the cross-product instance of R over D is I R =
×
D × · · · × D (arity of R times). The cross-product instance of database D
schema R over D is the instance IR
× , where IR (R) = I R
for each R ∈ R. Let P
D
×D
×D
be a datalog¬ program with no constants, input schema R, and output schema S with arity k. Prove that there is an N > 0 and a set EP of equivalence relations over [1, k]
such that for each set D ⊆ dom: if |D| ≥ N then

P (IR
× ) =
{H
D
≃(D) |≃ ∈ EP }.

(b) Prove (a) for datalog¬¬ programs.

(c) Generalize your proofs to permit constants in P .

Exercise 17.16
In the proof of Lemma 17.3.6, prove more formally the bound on µn(¬σk).

Prove that its limit is 0 when n goes to ∞.

Exercise 17.17
Determine whether the following properties of graphs are almost surely true or whether they are almost surely false.

(a) Existence of a cycle of length three
(b) Connectivity
(c) Being a tree
Exercise 17.18
Prove that there is a finite number of equivalence classes of k-tuples induced by automorphisms of the Rado graph. Hint: Each class is completely characterized by the pattern of connection and equality among the coordinates of the k-tuple. To see this, show that for all tuples u and v satisfying this property, one can construct an automorphism ρ of the Rado graph such that ρ(u) = v. The automorphism is constructed using the extension axioms, similar to the proof of Lemma 17.3.5.

♠ Exercise 17.19 Describe how to generalize the development of 0-1 laws for arbitrary input and for queries involving constants.

Exercise 17.20
Prove or disprove: The properties expressible in fixpoint are exactly the ptime properties that have a 0-1 law.

462
First Order, Fixpoint, and While
Exercise 17.21
The language existential second-order logic, denoted (∃SO), consists of sentences of the form ∃Qi . . . ∃Qkσ , where Qi are relations and σ is a first-order sentence using the relations Qi (among others). Show that ∃SO does not have a 0-1 law. Hint: Exhibit a property expressible in ∃SO that is neither almost surely true nor almost surely false.

⋆ Exercise 17.22 Infinitary logic with finitely many variables, denoted Lω∞ , is an extension of ω
CALC that allows formulas with infinitely long conjunctions and disjunctions but using only a finite number of variables. Show that each while query can be expressed in Lω
∞ .

ω Hint: Start
with a specific example, such as transitive closure.

Exercise 17.23
The following refer to the proof of Theorem 17.4.2.

(a) Describe a fixpoint query that, given a successor relation succ on constants, constructs a 2k-ary successor relation succ k on k-tuples of constants, in the lexicographical order induced on k-tuples by succ.

(b) Show that the relation constant _ coding can be defined from succ using a fixpoint query.

(c) Complete the details of the construction of RM by a fixpoint query.

(d) Describe in detail the CALC formula corresponding to the move of M considered in the proof of Theorem 17.4.2.

(e) Describe in detail the CALC formula used to perform phase γ in the computation of qM.

(f) Show where the proof of Theorem 17.4.2 breaks down if it is not assumed that the input instance is ordered.

Exercise 17.24
Spell out the differences in the proofs of (a) and (b) in Theorem 17.4.2.

Exercise 17.25
Write a fixpoint query that computes the parity query even on ordered databases.

Exercise 17.26
Consider queries of the form
Does the diameter of G have property P?

where P is an exptime property of the integers (i.e., a property that can be checked, for integer n, in time exponential in log n, or polynomial in n). Show that each query as above is a fixpoint query.

♠ Exercise 17.27 [Gur] This exercise shows that there is a query expressible in CALC in the presence of order that is not expressible in CALC without order. Let R = {D, S}, where D is unary and S is binary. Consider an instance I of R. Suppose the second column of I(S) contains only constants from I(D). Then one can view each constant s in the first column of I(S) as denoting a subset of I(D), namely {x | S(s, x)}. Call an instance I of R good if for each subset of I(D), there exists a constant representing it. In other words, for each subset T of I(D), there exists a constant s such that
T = {x | S(s, x)}.

Consider the query q defined by q(I) = true iff I is a good input and |I(D)| is even.

(a) Show that q is not expressible by CALC.

Exercises
463
(b) Show that q is expressible on instances extended with an order relation ≤ on the constants.

(c) Note that in (b), an order is used instead of the usual successor relation on constants.

Explain the difficulty of proving (b) if a successor relation is used instead of ≤.

Hint: For (a), use Ehrenfeucht-Fraissé games. Consider (b). To check that the input is good, check that (1) all singleton subsets of I(D) are represented, and (2) if T1 and T2 are represented, so is T1 ∪ T2. To check evenness of |I(D)| on good inputs, define first from ≤ a successor relation succ D on the constants in I(D); then check that there exists a subset T of I(D) consisting of the even constants according to succ D and that the last element in succ D is in T .

♠ Exercise 17.28 (Expression complexity [Var82a])
(a) Show that the expression complexity of CALC is within pspace. That is, consider a fixed instance I and tuple u, and a TM MI,u depending on I and u that, given as input some standard encoding of a query ϕ in CALC, decides if u ∈ ϕ(I). Show that there is such a TM MI,u whose complexity is within pspace with respect to | enc(ϕ)|, when ϕ ranges over CALC.

(b) Prove that in terms of expression complexity, CALC is complete in pspace. Hint: Use a reduction to quantified propositional calculus (see Chapter 2 and [GJ79]).

(c) Let CALC− consist of the quantifier-free queries in CALC. Show that the expression complexity of CALC− is within logspace.

Exercise 17.29
Show that
(a) Wx( Wy R(x, y)) is not equivalent5 to Wxy ϕ(x, y); (b) Wx( Wy R(x, y)) is not equivalent to Wy( Wx R(x, y)).

Exercise 17.30
Write a CALC+µ++W formula defining the query even.

Exercise 17.31
Express the query of Example 17.4.4 in while++W .

♠ Exercise 17.32 [ASV90] Show that it is undecidable whether a given CALC+µ++W formula defines a deterministic query. Hint: Use the undecidability of satisfiability of CALC sentences.

♠ Exercise 17.33 [AV91a, AV91c]. As seen, the witness operator can be used to obtain nondeterministic versions of while(+) and CALC+µ(+). One can obtain nondeterministic versions of datalog¬(¬) as follows. The syntax is the same, except that heads of rules may contain several literals, and equality may be used in bodies of rules. The rules of the program are fired one rule at a time and one instantiation at a time. The nondeterminism is due to the choice of rule and instantiation used in each firing. The languages thus obtained are denoted N - datalog¬(¬).

(a) Prove that N-datalog¬¬ is equivalent to CALC+µ+W and while+W and expresses all nondeterministic queries computable in polynomial space.6
(b) Show that N-datalog¬ cannot compute the query P − πA(Q), where Q is of sort AB
and P of sort A.

5 Two formulas are equivalent iff they define the same set of relations for each given instance.

6 This includes qpspace, the deterministic queries computable in polynomial space.

464
First Order, Fixpoint, and While
(c) Let N-datalog¬∀ be the language obtained by extending N-datalog¬ with universal quantification in bodies of rules. For example, the program
answer(x) ← ∀y[P (x), ¬Q(x, y)]
computes the query P − πA(Q). Prove that N-datalog¬∀ is equivalent to CALC+µ++W and while++W and expresses all nondeterministic queries computable in polynomial time.

(d) Prove that N-datalog¬ and N-datalog¬∀ are equivalent on ordered databases.

♠ Exercise 17.34 (Dynamic choice operator [CGP93]) The following extension of datalog=
with a variation of the choice operator (see Bibliographic Notes) is introduced in [CGP93].

Datalog= programs are extended by allowing atoms of the form choice(X,Y) in rules of bodies, where X and Y are disjoint sets of variables occurring in regular atoms of the rule. Several choice atoms can appear in one rule. The language obtained is called datalog=+ choice. The semantics is the following. The choice atoms render the immediate consequence operator of a datalog=+ choice program P nondeterministic. In each application of TP , a subset of the applicable valuations is chosen so that for each rule containing an occurrence choice(X,Y), the functional dependency X → Y holds. That is, one instantiation for the Y variables is chosen for each instantiation of the X variables. Moreover, the nondeterministic choices operated at each application of TP for a given occurrence of a choose atom extend the choices made in previous applications of TP for that atom. (Thus choose has a more global nature than the witness operator.) Although negation is not used in datalog=+ choice, it can be simulated. The following datalog=+ choice program computes in ¯
P the complement of a nonempty relation P
with respect to a universal relation T of the same arity [CGP93]:
TAG(X, 0)
← P (X)
TAG(X, 1)
← T (X), COMP(Y, 0)
COMP(X, I ) ← TAG(X, I ), choose(X, I )
¯
P (X)
← COMP(X, 1)
The role of choose in the preceding program is simple. When first applied, it associates with each X in P the tag I = 0. At the second application, it chooses a tag of 0 or 1 for all tuples in T . However, tuples in P have already been tagged by 0 in the previous application of choose, so the tuples tagged by 1 are precisely those in the complement.

(a) Exhibit a datalog=+ choice program that, given as input a unary relation P , defines nondeterministically the successor relations on the constants in P .

(b) Show that every N-datalog¬ query is expressible in datalog=+ choice (see Exercise 17.33).

(c) Prove that datalog=+ choice expresses exactly the nondeterministic queries computable in polynomial time.

♠ Exercise 17.35 [Daw93, Hel92] As shown in this chapter, the fixpoint queries fall short of expressing all of qptime. For example, they cannot express even. A natural idea is to enrich the fixpoint queries with additional constructs in the hope of obtaining a language expressing exactly qptime. This exercise explores one (unsuccessful) possibility, which consists of adding some finite set of ptime oracles to the fixpoint queries.

Exercises
465
A property of instances over some database schema R is a subset of inst(R) closed under isomorphisms of dom. Let Q be a finite set of properties, each of which can be checked in ptime.

Let while+(Q) be the extension of while+ allowing loops of the form while q(R1, . . . , Rn) do, where q ∈ Q and R1, . . . , Rn are relation variables compatible with the schema of q. Intuitively, this allows us to ask whether R1, . . . , Rn have property q. Clearly, while+(Q) generally has more power than while+. For example, the query even is trivially expressible in while+({ even}).

One might wonder if there is choice of Q such that while+(Q) expresses exactly qptime.

(a) Show that for every finite set Q of ptime properties, there exists a single ptime property q such that while+(Q) ≡ while+({q}).

(b) Let while+({q}) denote all while+({q}) programs whose input is one unary relation.

1
Let ptime[k] denote the set of properties whose time complexity is bounded by some polynomial of degree k. Show that, for each ptime property q, the properties of unary relations definable in while+({q}) are in ptime[k] for some k depending only on 1
q. Hint: Show that for each while+({q}) program there exist N > 0 and properties 1
q1, . . . , qm of integers where each qi(n) can be checked in time polynomial in n, such that the program is equivalent to a Boolean combination of tests n ≥ j, n = j, qi(n), where n is the size of the input, 0 ≤ j ≤ N and 1 ≤ i ≤ m. Use the hyperplane technique developed in the proof of Proposition 17.3.2.

(c) Prove that there is no finite set Q of ptime properties such that while+(Q) expresses qptime. Hint: Use (a), (b), and the fact that ptime[k] ⊂ ptime by the time hierarchy theorem.

18 HighlyExpressive
Languages
Alice:
I still cannot check if I have an even number of shoes.

Riccardo:
This will not stand!

Sergio:
We now provide languages that do just that.

Vittorio:
They can also express any query you can think of.

In previous chapters, we studied a number of powerful query languages, such as the fixpoint and while queries. Nonetheless, there are queries that these languages cannot express. As pointed out in the introduction to Chapter 14, fixpoint lies within ptime, and while within pspace. The complexity bound implies that there are queries, of complexity higher than pspace, that are not expressible in the languages considered so far. Moreover, we showed simple, specific queries that are not in fixpoint or while, such as the query even.

In this chapter, we exhibit several powerful languages that have no complexity bound on the queries they can express. We build up toward languages that are complete (i.e., they express all queries). Recall that the notion of query was made formal in Chapter 16.

Basically, a query is a mapping from instances of a fixed input schema to instances of a fixed answer schema that is computable and generic. Recall that, as a consequence, answers to queries contain only constants from the input (except possibly for some fixed, finite set of new constants).

We begin with a language that extends while by providing arbitrary computing power outside the database; this yields a language denoted while N , in the style of embedded relational languages like C+SQL. This would seem to provide the simplest cure for the computational limitations of the languages exhibited so far. There is no complexity bound on the queries while N can express. Surprisingly, we show that, nonetheless, while N is not complete. In fact, while N cannot express certain simple queries, including the infamous query even. Intuitively, while N is not complete because the external computation has limited interaction with the database. Complete languages are obtained by overcoming this limitation. Specifically, we present two ways to do this: (1) by extending while with the ability to create new values in the course of the computation, and (2) by extending while with an untyped version of relational algebra that allows relations of variable arity.

For conciseness, in this chapter we do not pursue the simultaneous development of languages in the three paradigms—algebraic, logic, and deductive. Instead we choose to focus on the algebraic paradigm. However, analogous languages could be developed in the other paradigms (see Exercise 18.22).

466
18.1 WhileN—while with Arithmetic
467
18.1
WhileN— while with Arithmetic
The language while is the most powerful of the languages considered so far. We have seen that it lies within pspace. Thus it does not have full computing power. Clearly, a complete language must provide such power. In this section, we consider an extension of while that does provide full computing power outside the database. Nonetheless, we will show that the resulting language is not complete; it is important to understand why this is so before considering more exotic ways of augmenting languages.

The extension of while that we consider allows us to perform, outside the database, arbitrary computations on the integers. Specifically, the following are added to the while language:
(i) integer variables, denoted i, j, k, . . . ;
(ii) the integer constant 0 (zero);
(iii) instructions of the form increment(i), decrement(i), where i is an integer variable; (iv) conditional statements of the form if i = 0 then s else s′, where i is an integer variable and s, s′ are statements in the language;
(v) loops of the form while i > 0 do s, where i is an integer variable and s a program.

The semantics is straightforward. All integer variables are initialized to zero. The semantics of the while change construct is not affected by the integer variables (i.e., the loop is executed as long as there is a change in the content of a relational variable).

The resulting language is denoted by while N.

Because the language while N can simulate an arbitrary number of counters, it is computationally complete on the integers (see Chapter 2). More precisely, the following holds:
Fact
For every computable function f (i1, . . . , ik) on integers, there exists a while N program wf that computes f (i1, . . . , ik) for every integer initialization of i1, . . . , ik. In particular, wf stops on input i1, . . . , ik iff f is defined on (i1, . . . , ik).

In view of this fact, one can use in while N programs, whenever convenient, statements of the form n := f (i1, . . . , ik), where n, i1, . . . , ik are integer variables and f is a computable function on the integers. This is used in the following example.

Example 18.1.1
Let G be a binary relation with attributes AB. Consider the query on the graph G:
square(G) = ∅ if the diameter of G is a perfect square, and G otherwise.

The following while N program computes square(G) (the output relation is answer; it is assumed that G = ∅):
i := 0; T := G;
468
Highly Expressive Languages
while change do
begin
T := T ∪ πAB(δB→C(T ) ⊲⊳ δA→C(G));
increment(i);
end;
j := f (i);
answer := G;
if j > 0 then answer := ∅.

where f is the function such that f (x) = 1 if x is a perfect square and f (x) = 0 otherwise.

(Clearly, f is computable.) Note that, after execution of the while loop, the value of i is the diameter of G.

It turns out that the preceding program can been expressed in while alone, and even fixpoint, without the need for arithmetic (see Exercise 18.2). However, this is clearly not the case in general. For instance, consider the while N program obtained by replacing f in the preceding program by some arbitrary computable function.

Despite its considerable power, while N cannot express certain simple queries, such as even. There are several ways to show this, just as we did for while. Recall that, in Chapter 17, it was shown that while has a 0-1 law. It turns out that while N also has a 0-1 law, although proving this is beyond the scope of this book. Thus there are many queries, including even, that while N cannot express. One can also give a direct proof that even cannot be expressed by while N by extending straightforwardly the hyperplane technique used in the direct proof that while cannot express even (Proposition 17.3.2, see Exercise 18.3).

As in the case of other languages we considered, order has a significant impact on the expressiveness of while N. Indeed, while N is complete on ordered databases.

Theorem 18.1.2
The language while N expresses all queries on ordered databases.

Crux
Let q be a query on an ordered database with schema R. Let I denote an input instance over R and α the enumeration of constants in I given by the relation succ. By the definition of query, there exists a Turing machine Mq that, given as input encα(I), produces as output encα(q(I)) (whenever q is defined on I). Because while N manipulates integers, we wish to encode I as an integer rather than a Turing machine tape. This can be done easily because each word over some finite alphabet with k symbols (with some arbitrary order among the symbols) can be viewed as an integer in base k. For any instance J, let enc∗α(J) denote the integer encoding of J obtained by viewing encα(J) as an integer. It is easy to see that there is a computable function fq on the integers such that fq(enc∗α(I)) = enc∗α(q(I)) whenever q is defined on I. Furthermore, because while N can express any computable function over the integers (see the preceding Fact), there exists a while N program wf (i) q
that computes fq. It is left to show that while N can compute enc∗α(I) and can decode q(I) from enc∗α(q(I)). Recall that, in the proof of Theorem 17.4.2, it was shown that while can compute a relational representation of encα(I) and, conversely, it can decode q(I) from the representation of encα(q(I)). A slight modification of that construction can be used to
18.2 Whilenew — while with New Values
469
S
R
a
b
a
b
α
a
c
a
c
β
c
a
c
a
γ
Figure 18.1:
An application of new
show that while N can compute the desired integer encoding and decoding. Thus a while N
program computes q in three phases:
1. compute enc∗α(I);
2. compute fq(enc∗α(I)) = enc∗α(q(I));
3. compute q(I) from enc∗α(q(I)).

18.2
Whilenew — while with New Values
Recall that, as discussed in the introduction to Chapter 14, while cannot go beyond pspace because (1) throughout the computation it uses only values from the input, and (2) it uses relations of fixed arity. The addition of integers as in while N is one way to break the space barrier. Another is to relax (1) or (2). Relaxing (1) is done by allowing the creation of new values not present in the input. Relaxing (2) yields an extension of while with untyped algebra (i.e., an algebra of relations with variable arities). In this and the next section, we describe two languages obtained by relaxing (1) and (2) and prove their completeness.

We first present the extension of while denoted whilenew, which allows the creation of new values throughout the computation. The language while is modified as follows: (i) There is a new instruction R := new(S), where R and S are relational variables and arity(R) = arity(S) + 1;
(ii) The looping construct is of the form while R do s, where R is a relational variable.

The semantics of (i) is as follows: Relation R is obtained by extending each tuple of S
by one distinct new value from dom not occurring in the input, the current state, or in the program. For example, if the value of S is the relation in Fig. 18.1, then R is of the form shown in that figure. The values α, β, γ are distinct new values1 in dom.

The semantics of while R do s is that statement s is executed while R is nonempty.

We could have used while change instead because each looping construct can simulate the other. However, in our context of value invention, it is practical to have the more direct control on loops provided by while R.

1 If arity(S) = 0, then R is unary and contains one new value if S = {} and is empty if S = ∅. This allows the creation of values one by one. One might wonder if this kind of one-by-one value creation is sufficient. The answer is negative. The language with one-by-one value creation is equivalent to while N (see Exercise 18.6).

470
Highly Expressive Languages
Note that the new construct is, strictly speaking, nondeterministic. The new values are arbitrary, so several possible outcomes are possible depending on the choice of values.

However, the different outcomes differ only in the choice of new values. This is formalized by the following:
Lemma 18.2.1
Let w be a whilenew program with input schema R, and let R be a relation variable in w. Let I be an instance over R, and let J, J ′ be two possible values of R at the same point during the execution of w on I. Then there exists an isomorphism ρ from J to J ′ that is the identity on the constants occurring in I or w.

The proof of Lemma 18.2.1 is done by a straightforward induction on the number of steps in a partial execution of w on I (Exercise 18.7).

Recall that our definition of query requires that the answer be unique (i.e., the query must be deterministic). Therefore we must consider only whilenew programs whose answer never contains values introduced by the new statements. Such programs are called well-behaved whilenew programs. It is possible to give a syntactic restriction on whilenew programs that guarantees good behavior, can be checked, and yields a class of programs equivalent to all well-behaved whilenew programs (see Exercises 18.8 and 18.9).

We wish to show that well-behaved whilenew programs can express all queries. First we have to make sure that well-behaved whilenew programs do in fact express queries. This is shown next.

Lemma 18.2.2
Each well-behaved whilenew program with input schema R and output schema answer expresses a query from inst(R) to inst(answer).

Proof
We need to show that well-behaved whilenew programs define mappings from inst(R) to inst(answer) (i.e., they are deterministic with respect to the final answer). Computability and genericity are straightforward. Let w be a well-behaved whilenew program with input schema R and output answer. Let I, I ′ be two possible values of answer after the execution of w on an instance I of R. By Lemma 18.2.1, there exists an isomorphism ρ from I to I ′ that is the identity on values in I or w. Because w is well behaved, answer contains only values from I or w. Thus ρ is the identity and I = I ′.

Note that although well-behaved programs are deterministic with respect to their final answer, they are not deterministic with respect to intermediate results that may contain new values.

We next show that well-behaved whilenew programs express all queries. The basic idea is simple. Recall that while N is complete on ordered databases. That is, for each query q, there is a while N program w that, given an enumeration of the input values in a relation succ, computes q. If, given an input, we were able to construct such an enumeration, we could then simulate while N to compute any desired query. Because of genericity, we cannot hope to construct one such enumeration. However, constructing all enumerations of values in the input would not violate genericity. Both whilenew and the language with variable arities considered in the next section can compute arbitrary queries precisely in this fashion: They first compute all possible enumerations of the input values and then
18.2 Whilenew — while with New Values
471
simulate a while N program on the ordered database corresponding to each enumeration.

These computations yield the same result for all enumerations because queries are generic, so the result is independent of the particular enumeration used to encode the database (see Chapter 16).

Before proving the result, we show how we can construct all the possible enumerations of the elements in the active domain of the input.

Representation
Let I be an instance over R. Let Success be the set of all binary relations defining a successor relation over adom(I). We can represent all the enumerations in Success with a 3-ary relation:

succ =
I × {αI },
I ∈ Success
where {αI | I ∈ Success} is a set of distinct new values. [Each such αI is used to denote a particular enumeration of adom(I).] For example, Fig. 18.2 represents an instance I and the corresponding succ.

Computation of succ
We now argue that there exists a whilenew program w that, given I, computes succ. Clearly, there is a whilenew program that, given I, produces a unary relation D containing all values in I. Following is a whilenew program w succ that computes the relation succ starting from D (using a query q explained next):
I
succ

succ
a
b
a
b
α1
a
b
a
b
c
a
c
b
c
α1
b
c
a
b
c
c
a
a
c
α2
a
c
a
c
b
c
b
α2
c
b
a
c
b
b
a
α3
b
a
b
a
c
a
c
α3
a
c
b
a
c
b
c
α4
b
c
b
c
a
c
a
α4
c
a
b
c
a
c
a
α5
c
a
c
a
b
a
b
α5
a
b
c
a
b
c
b
α6
c
b
c
b
a
b
a
α6
b
a
c
b
a
Figure 18.2:
An example of succ and
succ
472
Highly Expressive Languages
succ := new(σ1=2(D × D));
8
:= q;
while 8 do
begin
S := new(8);


∃α, x′, y′[S(x′, y′, α, α′) ∧ succ(x, y, α)]
succ :=
x, y, α′
;

∨ ∃α[S(x, y, α, α′)]
8 := q;
end
The intuition is that we construct in turn enumerations of subsets of size 2, 3, etc., until we obtain the enumerations of D. (To simplify, we assume that D contains more than two elements.) An enumeration of a subset of D consists of a successor (binary) relation over that subset. As mentioned earlier, the program associates a marking (invented value) with each such successor relation.

During the computation, succ contains the successor relation of subsets of size i computed so far. A triple a, b, α indicates that b follows a in enumeration denoted α.

The first instruction computes the enumerations of subsets of size 2 (i.e., the distinct pairs of elements of D) and marks them with new values. At each iteration, 8 indicates for each enumeration the elements that are missing in this enumeration. More precisely, relation 8 must contain the following set of triples:


b does not occur in the successor relation corresponding to α


a, b, α
and the last element of α is a.

The relational query q computes the set 8 given a particular relation succ. If 8 is not empty, for each α a new value α′ is created for each element missing in α (i.e., the enumeration α is extended in all possible ways with each of the missing elements). This yields as many new enumerations from each α as missing elements.

This is iterated until 8 becomes empty, at which point all enumerations are complete.

Note that if D contains n elements, the final result succ contains n! enumerations.

Theorem 18.2.3
The well-behaved whilenew programs express all queries.

Crux
Let q be a query from inst(R) to inst( answer). Assume the query is generic (i.e., C-generic with C = ∅). The proof is easily modified for the case when the query is C-generic with C = ∅. It is sufficient to observe that
for each while N program,
(*)
there exists an equivalent well-behaved whilenew program.

Suppose that (*) holds. Let w succ be the whilenew program computing succ from given I over R. By Theorem 18.1.2 and (*), there exists a whilenew program w( succ) that computes q using a successor relation succ. We construct another whilenew program w( succ) that computes q given I and succ. Intuitively, w( succ) is run in parallel for all possible
18.2 Whilenew — while with New Values
473
enumerations succ provided by succ. All computations produce the same result and are placed in answer. The computations for different enumerations in succ are identified by the α marking the enumeration in succ. To this end, each relation R of arity k in w( succ) is replaced by a relation R of arity k + 1. The extended database relations are first initialized by statements of the form R := R × π3( succ). Next the instructions of w( succ) are modified as follows:
• R := {u | φ(u)} becomes R := {u, α | ∃y∃z succ(y, z, α) ∧ φ(u, α)}, where φ(u, α) is obtained from φ(u) by replacing each atom S(v) by S(v, α);
• while change do remains unchanged.

Finally the instruction answer := π1..n( answer), where n = arity( answer), is appended at the end of the program. The following can be shown by induction on the steps of a partial execution of w( succ) on I (Exercise 18.10):
(**) At each point in the computation of w( succ) on I, the set of tuples in relation R
marked with α coincides with the value of R at the same point in the computation when w( succ) is run on I and succ is the successor relation corresponding to α.

In particular, at the end of the computation of w( succ) on I, answer =
w(α)(I) × {α},
α
where α ranges over the enumeration markers. Because w(α)(I) = q(I) for each α, it follows that answer contains q(I) at the end of the computation. Thus query q is computable by a well-behaved whilenew program.

Thus it remains to show (*). Integer variables are easily simulated as follows. An integer variable i is represented by a binary variable Ri. If i contains the integer n, then Ri contains a successor relation for n + 1 distinct new values:
{αj, αj+1 | 0 ≤ j < n}.

(The integer 0 is represented by an empty relation and the integer 1 by a singleton
{α0, α1}.) It is easy to find a whilenew program for increment and decrement of i.

We showed that well-behaved whilenew programs are complete with respect to our definition of query. Recall that whilenew programs that are not well behaved can compute a different kind of query that we excluded deliberately, which contains new values in the answer. It turns out, however, that such queries arise naturally in the context of object-oriented databases, where new object identifiers appear in query results (see Chapter 21).

This requires extending our definition of query. In particular, the query is nondeterministic but, as discussed earlier, the different answers differ only in the particular choice of new values. This leads to the following extended notion of query:
Definition 18.2.4
A determinate query is a relation Q from inst(R) to inst(answer) such that
474
Highly Expressive Languages
ψ3
{ a, b} ⇒
ψ0
b
ψ2
a
ψ1
Figure 18.3:
A query not expressible in whilenew
• Q is computable;
• if I, J ∈ Q and ρ is a one-to-one mapping on constants, then ρ(I ), ρ(J ) ∈ Q; and
• if I, J ∈ Q and I, J ′ ∈ Q, then there exists an isomorphism from J to J ′ that is the identity on the constants in I .

A language is determinate complete if it expresses only determinate queries and all determinate queries.

Let Q be a determinate query. If I, J ∈ Q and ρ is a one-to-one mapping on constants leaving I fixed, then I, ρ(J ) ∈ Q.

The question arises whether whilenew remains complete with respect to this extended notion of query. Surprisingly, the answer is negative. Each whilenew query is determinate. However, we exhibit a simple determinate query that whilenew cannot express. Let q be the query with input schema R = {S}, where S is unary, and output G, where G is binary. Let q be defined as follows: For each input I over S, if I = {a, b}
then q(I ) = {ψ0, ψ1, ψ1, ψ2, ψ2, ψ3, ψ3, ψ0, ψ0, b, ψ1, a, ψ2, b, ψ3, a} for some new elements ψ0, ψ1, ψ2, ψ3, and q(I ) = ∅ otherwise (Fig. 18.3).

Theorem 18.2.5
The query q is not expressible in whilenew.

Proof
The proof is by contradiction. Suppose w is a whilenew program expressing q.

Consider the sequence of steps in the execution of w on an input I = {a, b}. We can assume without loss of generality that no invented value is ever deleted from the database (otherwise modify the program to keep all invented values in some new unary relation). For each invented value occurring in the computation, we define a trace that records how the value was invented and uniquely identifies it. More precisely, trace(α) is defined inductively as follows. If α is a constant, then trace(α) = α. Suppose α is a new value created at step i with a new statement associating it with tuple x1, . . . , xk. Then trace(α) = i, trace(x1), . . . , trace(xk). Clearly, one can extend trace to tuples and rela-
18.3 Whileuty—An Untyped Extension of while
475
tions in the natural manner. It is easily shown (Exercise 18.11) by induction on the number of steps in a partial execution of w on I that
(†) trace(α) = trace(β) iff α = β;
(‡) for each instance J computed during the execution of w on input I , trace(J ) is closed under each automorphism ρ of I . In particular, for each α occurring in J , ρ( trace(α)) equals trace(β) for some β also occurring in J .

Consider now trace(q(I )) and the automorphism ρ of I [and therefore of trace(q(I ))]
defined by ρ(a) = b, ρ(b) = a. Note that ρ2 = id (the identity) and ρ = ρ−1. Consider ρ( trace(ψ0)). Because ψ0, b ∈ q(I ), it follows that trace(ψ0), b ∈ trace(q(I )). Because ρ(b) = a, it further follows that ρ( trace(ψ0)), a ∈ trace(q(I )) so ρ( trace(ψ0)) is either trace(ψ1) or trace(ψ3). Suppose ρ( trace(ψ0)) = trace(ψ1) (the other case is similar). From the fact that ρ is an automorphism of trace(q(I )) it follows that ρ( trace(ψ3)) =
trace(ψ0), ρ( trace(ψ2)) = trace(ψ3), and ρ( trace(ψ1)) = trace(ψ2). Consider now ρ2.

First, because ρ2 = id, ρ2( trace(ψi)) = trace(ψi), 0 ≤ i ≤ 3. On the other hand, ρ2( trace(ψ0)) = ρ(ρ( trace(ψ0))) = ρ( trace(ψ1)) = trace(ψ2). This is a contradiction.

Hence q cannot be computed by whilenew.

The preceding example shows that the presence of new values in the answer raises interesting questions with regard to completeness. There exist languages that express all queries with invented values in answers (see Exercise 18.14 for a complex construct that leads to a determinate-complete language). Value invention is common in object-oriented languages, in the form of object creation constructs (see Chapter 21).

18.3
Whileuty—
An Untyped Extension of
while
We briefly describe in this section an alternative complete language obtained by relaxing the fixed-arity requirement of the languages encountered so far. This relaxation is done using an untyped version of relational algebra instead of the familiar typed version. We will obtain a language allowing us to construct relations of variable, data-dependent arity in the course of the computation. Although strictly speaking they are not needed, we also allow integer variables and integer manipulation, as in while N. Intuitively, it is easy to see why this yields a complete language. Variable arities allow us to construct all enumerations of constants in the input, represented by sufficiently long tuples containing all constants. The ability to construct the enumerations and manipulate integers yields a complete language.

The first step in defining the untyped version of while is to define an untyped version of relational algebra. This means that operations must be defined so that they work on relations of arbitrary, unknown arity. Expressions in the untyped algebra are built from relation variables and constants and can also use integer variables and constants. Let i, j be integer variables, and for each integer k, let ∅k denote the empty relation of arity k.

Untyped algebra expressions are built up using the following operations:
• If e, e′ are expressions, then e ∩ e′ and e ∪ e′ are expressions; if arity(e) = arity(e′) the semantics is the usual; otherwise the result is ∅0.

476
Highly Expressive Languages
• If e is an expression, then ¬e is an expression; the complement is with respect to the active domain (not including the integers).

• If e, f are expressions, then e × f is an expression; the semantics is the usual cross-product semantics.

• If e is an expression, then σi=j (e) is an expression, where i, j are integer variables or constants; if arity(e) ≥ max{i, j } the semantics is the usual; otherwise the result is ∅0.

• If e is an expression, then πij (e) is an expression, where i, j are integer variables or constants; if i ≤ j and arity(e) ≥ max{i, j }, this projects e on columns i through j ; otherwise the result is ∅|j−i|.

• If e is an expression, then exij (e) is an expression; if arity(e) ≥ max{i, j }, this exchanges in each tuple in the result of e the i and j coordinates; otherwise the result is ∅0.

We may also consider an untyped version of tuple relational calculus (see Exercise 18.15).

We can now define whileuty programs. They are concatenations of statements of the form
• i := j , where i is an integer variable and j an integer variable or constant.

• increment(i), decrement(i), where i is an integer variable.

• while i > 0 do t, where i is an integer variable and t a program.

• R := e, where R is a relational variable and e an untyped algebra expression; the semantics here is that R is assigned the content and arity of e.

• while R do t, where R is a relational variable and t a program; the semantics is that the body of the loop is repeated as long as R is nonempty.

All relational variables that are not database relations are initialized to ∅0; integer variables are initialized to 0.

Example 18.3.1
Following is a whileuty program that computes the arity of a nonempty relation R in the integer variable n:
S0 := {}; S1 := S0 ∪ R; S2 := ¬S1;
while S2 do
begin
n := n + 1;
S0 := S0 × D;
S1 := S0 ∪ R;
S2 := ¬S1;
end
where D abbreviates an algebra expression computing the active domain [e.g., π11(R) ∪
¬π11(R)]. The program tries out increasing arities for R starting from 0. Recall that
18.3 Whileuty—An Untyped Extension of while
477
whenever R and S0 have different arities, the result of S0 ∪ R is ∅0. This allows us to detect when the appropriate arity has been found.

Remark 18.3.2
There is a much simpler set of constructs that yields the same power as whileuty. In general, programs are much harder to write in the resulting language, called QL, than in whileuty. One can show that the set of constructs of QL is minimal. The language QL
is described next; it does not use integer variables. QL expressions are built from relational variables and constant relations as follows (D denotes the active domain):
• equal is an expression denoting {a, a | a ∈ D}.

• e ∩ e′ and ¬e are defined as for whileuty; the complement is with respect to the active domain.

• If e is an expression, then e ↓ is an expression; this projects out the last coordinate of the result of e (and is ∅0 if the arity is already zero).

• If e is an expression, then e ↑ is an expression; this produces the cross-product of e with D.

• If e is an expression, then e ∼ is an expression; if arity(e) ≥ 2, then this exchanges the last two coordinates in each tuple in the result of e. Otherwise the answer is ∅0.

Programs are built by concatenations of assignment statements (R := e) and while statements ( while R do s). The semantics of the while is that the loop is iterated as long as R is nonempty.

We leave it to the reader to check that QL is equivalent to whileuty (Exercise 18.17).

We briefly describe the simulation of integers by QL. Let Z denote the constant 0-ary relation {}. We can have Z represent the integer 0 and Z ↑n represent the integer n. Then increment(n) is simulated by one application of ↑, and decrement(n) is simulated by one application of ↓. A test of the form x = 0 becomes e ↓= ∅, where e is the untyped algebra expression representing the value of x. Thus we can simulate arbitrary computations on the integers.

Recall that our definition of query requires that both the input and output be instances over fixed schemas. On the other hand, in whileuty relation arities are variable, so in general the arity of the answer is data dependent. This is a problem analogous to the one we encountered with whilenew, which generally produces new values in the result. As in the case of whilenew, we can define semantic and syntactic restrictions on whileuty programs that guarantee that the programs compute queries. Call a whileuty program well behaved if its answer is always of the same arity regardless of the input. Unfortunately, it can be shown that it is undecidable if a whileuty program is well behaved (Exercise 18.19). However, there is a simple syntactic condition that guarantees good behavior and covers all well-behaved programs. A whileuty program with answer relation answer is syntactically well behaved if the last instruction of the program is of the form answer := πmn(R), where m, n are integer constants. Clearly, syntactic good behavior guarantees good behavior and can be checked.

Furthermore, it is obvious that each well-behaved whileuty program is equivalent to some syntactically well-behaved program (Exercise 18.19).

478
Highly Expressive Languages
We now prove the completeness of well-behaved whileuty programs.

Theorem 18.3.3
The well-behaved whileuty programs express all queries.

Crux
It is easily verified that all well-behaved whileuty programs define queries. The proof that every query can be expressed by a well-behaved whileuty program is similar to the proof of Theorem 18.2.3. Let q be a query with input schema R. We proceed in two steps: First construct all orderings of constants from the input. Next simulate the while N program computing q on the ordered database corresponding to each ordering. The main difference with whilenew lies in how the orderings are computed. In whileuty, we use the arbitrary arity to construct a relation R< containing sufficiently long tuples each of which provides an enumeration of all constants. This is done by the following whileuty program, where D
stands for an algebra expression computing the active domain:
R< := ∅0;
C := D; arity C := 1;
while C do
begin
R< := C;
C := C × D; increment( arity C);
for i := 1 to ( arity C − 1) do
C := C ∩ ¬σi= arity(C)(C);
end
Clearly, the looping construct f or i := 1 to . . . can be easily simulated. If the size of D
is n, the result of the program is the set of n-tuples with distinct entries in adom(D). Note that each such tuple t in R< provides a complete enumeration of the constants in D. Next one can easily construct a whileuty program that constructs, for each such tuple t in R<, the corresponding successor relation. More precisely, one can construct succ =
succ t × {t},
t ∈R<
where succ t = {t (i), t (i + 1) | 1 ≤ i < n} (see Fig. 18.2 and Exercise 18.20).

Untyped languages allow us to relax the restriction that the output schema is fixed.

This may have a practical advantage because in some applications it may be necessary to have the output schema depend on the input data. However, in such cases one would likely prefer a richer type system rather than no typing at all.

The overall results on the expressiveness and complexity of relational query languages are summarized in Figs. 18.4 and 18.5. The main classes of queries and their inclusion structure are represented in Fig. 18.4 (solid arrows indicate strict inclusion; the dotted arrow indicates strict inclusion if ptime = pspace). Languages expressing each class of queries are listed in Fig. 18.5, which also contains information on complexity (first without assumptions, then with the assumption of an order on the database). In Fig. 18.5,
Bibliographic Notes
479
All queries
While
Fixpoint
Stratified datalog¬
Semipositive datalog¬
First order
Datalog
Positive-existential
Conjunctive queries
Figure 18.4:
Main classes of queries
CALC(∃, ∧) denotes the conjunctive calculus and CALC(∃, ∧, ∨) denotes the positive-existential calculus.

Bibliographic Notes
The first complete language proposed was the language QL of Chandra and Harel [CH80b].

Chandra also considered a language equivalent to while N, which he called LC [Cha81a].

It was shown that LC cannot compute even. Several other primitives are considered in
[Cha81a] and their power is characterized. The language whilenew was defined in [AV90], where its completeness was also shown.

The languages considered in this chapter can be viewed as formalizing practical languages, such as C+SQL or O2C, used to develop database applications. These languages combine standard computation (C) with database computation (SQL in the relational world or O2 in the object-oriented world). In this direction, several computing devices were defined in [AV91b], and complexity-theoretic results are obtained using the devices. First an extension of Turing machines with a relational store, called relational machine, was shown to be equivalent to while N. A further extension of relational machines equivalent to whilenew and whileuty, called generic machine, was also defined. In the generic machine,
480
Highly Expressive Languages
Class of
Complexity
queries
Languages
Complexity
with order
conjunctive
CALC(∃, ∧)
⊂ logspace
⊂ logspace
SPJR algebra
⊂ ac0
⊂ ac0
positive-
CALC(∃, ∧, ∨)
existential
SPJUR algebra
⊂ logspace
⊂ logspace
nr-datalog
⊂ ac0
⊂ ac0
datalog
datalog
⊂ monotonic
⊂ monotonic
ptime
ptime
semipositive
semipositive datalog¬
⊂ ptime
= ptime
datalog¬
(with min, max)
first order
CALC
ALG
⊂ logspace
⊂ logspace
nr-stratified datalog¬
⊂ ac0
⊂ ac0
stratified
stratified datalog¬
⊂ ptime
= ptime
datalog¬
fixpoint
CALC+µ+
while+
datalog¬ (fixpoint and
well-founded semantics)
⊂ ptime
= ptime
while
CALC+µ
while
datalog¬¬ (fixpoint semantics)
⊂ pspace
= pspace
all queries
whileuty
no bound
no bound
whilenew
Figure 18.5:
Languages and complexity
parallelism is used to allow simultaneous computations with all possible successor relations.

Queries with new values in their answers were first considered in [AK89], in the context of an object-oriented deductive language with object creation, called IQL. The notion of determinate query [VandBGAG92] is a recasting of the essentially equivalent notion of db transformation, formulated in [AK89]. In [AK89], the query in Theorem 18.2.5 is also exhibited, and it is shown that IQL without duplicate elimination cannot express it. Because IQL is more powerful than whilenew, their result implies the result of Theorem 18.2.5. The issue of completeness of languages with object creation was further investigated in [AP92, VandBG92, VandBGAG92, VandBP95, DV91, DV93].

Exercises
481
Finally it is easy to see that each (determinate) query can be computed in some natural nondeterministic extension of whilenew (e.g., with the witness operator of Chapter 17)
[AV91c]. However, such programs may be nondeterministic so they do not define only determinate queries.

Exercises
Exercise 18.1
Let G be a graph. Consider a query “Does the shortest path from a to b in G
have property P? ” where G is a graph, P is a recursive property of the integers, and a, b are two particular vertexes of the graph. Show that such a query can be expressed in while N.

Exercise 18.2
Prove that the query in Example 18.1.1 can be expressed (a) in while; (b) in fixpoint.

Exercise 18.3
Sketch a direct proof that even cannot be expressed by while N by extending the hyperplane technique used in the proof of Proposition 17.3.2.

♠ Exercise 18.4 [AV94] Consider the language L augmenting while N by allowing mixing of integers with data. Specifically, the following instruction is allowed in addition to those of while N : R := {i1, . . . , ik}, where R is a k-ary relation variable and i1, . . . , ik are integer variables. It is assumed that the domain of input values is disjoint from the integers. Complement (or negation) is taken with respect to the domain formed by all values in the database or program, including the integer values present in the database. The well-behaved L programs are those whose outputs never contain integers. Show that well-behaved L and while N are equivalent.

Exercise 18.5
Complete the proof of Theorem 18.1.2.

♠ Exercise 18.6 [AV90] Consider a variation of the language whilenew where the R := new(S) instruction is replaced by the simpler instruction “R := new” where R is unary. The semantics of this instruction is that R is assigned a singleton {α}, where α is a new value. Denote the new language by while unary- new.

(a) Show that each query expressible in while N is also expressible in while unary- new.

Hint: Use new values to represent integers. Specifically, to represent the integers up to n, construct a relation succ int containing a successor relation on n new values. The value of rank i with respect to succ represents integer i.

(b) Show that each query expressible in while unary- new is also expressible in while N.

Hint: Again establish a correspondence between new values and integers. Then use Exercise 18.4.

Exercise 18.7
Prove Lemma 18.2.1.

Exercise 18.8
Prove that it is undecidable if a given whilenew program is well behaved.

⋆ Exercise 18.9 In this exercise we define a syntactic restriction on whilenew programs that guarantees good behavior. Let w be a whilenew program. Without loss of generality, we can assume that all instructions contain at most one algebraic operation among ∪, −, π, ×, σ . Let the not-well-behaved set of w, denoted Bad(w), be the smallest set of pairs of the form R, i, where R is a relation in w and 1 ≤ i ≤ arity(R), such that
482
Highly Expressive Languages
(a) if S := new(R) is an instruction in w and arity(S) = k, then S, k ∈ Bad(w); (b) if S := T ∪ R is in w and T , i ∈ Bad(w) or R, i ∈ Bad(w), then S, i ∈ Bad(w); (c) if S := T − R is in w and T , i ∈ Bad(w), then S, i ∈ Bad(w); (d) if S := T × R is in w and T , i ∈ Bad(w), then S, i ∈ Bad(w); and if R, j ∈
Bad(w), then S, arity(T ) + j ∈ Bad(w);
(e) if S := πi
(T ) is in w and T , i
1...ik
j ∈ Bad(w), then S, j ∈ Bad(w);
(f) if S := σ cond(T ) is in w and T , i ∈ Bad(w), then S, i ∈ Bad(w).

A whilenew program w is syntactically well behaved if
{ answer, i | 1 ≤ i ≤ arity( answer)} ∩ Bad(w) = ∅.

(a) Outline a procedure to check that a given whilenew program is syntactically well behaved.

(b) Show that each syntactically well-behaved whilenew program is well behaved.

(c) Show that for each well-behaved whilenew program, there exists an equivalent syntactically well-behaved whilenew program.

Exercise 18.10
Prove (*) in the proof of Theorem 18.2.3.

Exercise 18.11
Prove (†) and (‡) in the proof of Theorem 18.2.5.

Exercise 18.12
Consider the query q exhibited in the proof of Theorem 18.2.5. Let q2 be the query that, on input I = {a, b}, produces as answer two copies of q(I ). More precisely, for each ψi in q(I ), let ψ′ be a distinct new value. Let q′(I ) be obtained from q(I ) by replacing ψ
i
i by
ψ ′, and let q
i
2(I ) = q(I ) ∪ q ′(I ). Prove that q2 can be expressed by a whilenew program.

♠ Exercise 18.13 [DV91, DV93] Consider the instances I, J of Fig. 18.6. Consider a query q that, on input of the same pattern as I , returns J (up to an arbitrary choice of distinct β, θi) and otherwise returns the empty instance. Show that q is not expressible in whilenew.

♠ Exercise 18.14 ( Choose [AK89]) Let whilechoose be obtained by augmenting new
whilenew with the
following (determinate) choose construct. A program w may contain the instruction choose(R) for some unary relation R. On input I, when choose(R) is applied in a state J, the next state J′
is defined as follows:
(a) if for each a, b in J(R), there is an automorphism of J that is the identity over adom(I, w) and maps a to b, J′ is obtained from J by eliminating one arbitrary element in J(R);
(b) otherwise J′ is just J.

Show that whilechoose is determinate complete.

new
Exercise 18.15
One may consider an untyped version of tuple relational calculus. Untyped relations are used just like typed relations, except that terms of the form t (i) are allowed, where t is a tuple variable and i an integer variable. Equivalence of queries now means that the queries yield the same answers given the same relations and values for the integer variables. Show that untyped relational calculus and untyped relational algebra are equivalent.

Exercise 18.16
Show that exij is not redundant in the untyped algebra.

Exercises
483
α1
a
ψ1
α1
b
ψ1
α1
b
ψ2
α1
c
ψ2
α1
c
ψ3
β
a
θ1
α1
d
ψ3
β
b
θ1
α1
d
ψ4
β
b
θ2
α1
a
ψ4
β
c
θ
3⇒
2
α2
a
ψ5
β
c
θ3
α2
b
ψ5
β
d
θ3
α2
b
ψ6
β
d
θ4
α2
c
ψ6
β
a
θ4
α2
c
ψ7
α2
d
ψ7
α2
d
ψ8
α2
a
ψ8
I
J
Figure 18.6:
Another query not expressible in whilenew
♠ Exercise 18.17 Sketch a proof that whileuty and the language QL described in Remark 18.3.2
are equivalent.

Exercise 18.18
Write a QL program computing the transitive closure of a binary relation.

♠ Exercise 18.19 This exercise concerns well-behaved whileuty programs. Show the following: (a) It is undecidable whether a given whileuty program is well behaved.

(b) Each syntactically well-behaved whileuty program is well behaved.

(c) For each well-behaved whileuty program, there exists an equivalent syntactically well-behaved whileuty program.

Exercise 18.20
Write a whileuty program that constructs the relation
succ from R< in the proof
of Theorem 18.3.3.

♠ Exercise 18.21 [AV91b] Prove that any query on a unary relation computed by a whilenew or whileuty program in polynomial space is in FO. (For the purpose of this exercise, define the space used in a program execution as the maximum number of occurrences of constants in some instance produced in the execution of the program.) Note that, in particular, even cannot be computed in polynomial space in these languages.

♠ Exercise 18.22 [AV91a] Consider the following extension of datalog¬¬ with the ability to create new values. The rules are of the same form as datalog¬¬ rules, but with a different semantics than the active domain semantics used for datalog¬¬. The new semantics is the following. When rules are fired, all variables that occur in heads of rules but do not occur positively in the body are assigned distinct new values, not present in the input database, program, or any of the other relations in the program. A distinct value is assigned for each
484
Highly Expressive Languages
applicable valuation of the variables positively bound in the body in each firing. This is similar to the new construct in whilenew. For example, one firing of the rule R(x, y, α) ← P (x, y)
has the same effect as the R := new(P ) instruction in whilenew. The resulting extension of datalog¬¬ is denoted datalog¬¬ . The
programs are those that never
new
well-behaved datalog¬¬
new
produce new values in the answer. Sketch a proof that well-behaved datalog¬¬ programs ex-new
press all queries.

P A R T
F Finale
Inthispart,weconsiderfouradvancedtopics.Twoofthem(incompleteinformationand dynamic aspects) have been studied for a while, but for some reason (perhaps their difficulty) they have never reached the maturity of more established areas such as dependency theory. Interest in the other two topics (complex values and object databases) is more recent, and our understanding of them is rudimentary. In all cases, no clear consensus has yet emerged. Our choice of material, as well as our presentation, are therefore unavoidably more subjective than in other parts of this book. However, the importance of these issues for practical systems, as well as the interesting theoretical issues they raise, led us to incorporate a discussion of them in this book.

In Chapter 19, we address the issue of incomplete information. In many database applications, the knowledge of the real world is incomplete. It is crucial to be able to handle such incompleteness and, in particular, to be able to ask queries and perform updates.

Chapter 19 surveys various models of incomplete databases, research directions, and some results.

In Chapter 20, we present an extension of relations called complex values. These are obtained from atomic elements using tuple and set constructors. The richer structure allows us to overcome some limitations of the relational model in describing complex data. We generalize results obtained for the relational model; in particular, we present a calculus and an equivalent algebra.

Chapter 21 looks at another way to enrich the relational model by introducing a number of features borrowed and adapted from object-oriented programming, such as objects, classes, and inheritance. In particular, objects consist of a structural part (a data reposi-tory) and a behavioral part (pieces of code). Thus the extended framework encompasses behavior, a notion conspicuously absent from relational databases.

Chapter 22 deals with dynamic aspects. This is one of the less settled areas in databases, and it raises interesting and difficult questions. We skim through a variety of issues: languages and semantics for updates; updating views; updating incomplete information; and active and temporal databases.

A comprehensive vision of the four areas discussed in Part F is lacking. The reader should therefore keep in mind that some of the material presented is in flux, and its importance pertains more to the general flavor than the specific results.

485
19 IncompleteInformation
Somebody:
What are we doing next?

Alice:
Who are we ? Who are you ?

Somebody:
We are you and the authors of the book, and I am one of them. This is an instance of incomplete information.

Somebody:
It’s not much, but we can still tell that surely one of us is Alice and that there are possibly up to three “Somebodies” speaking.

In the previous parts, we have assumed that a database always records information that is completely known. Thus a database has consisted of a completely determined finite instance. In reality, we often must deal with incomplete information. This can be of many kinds. There can be missing information, as in “John bought a car but I don’t know which one.” In the case of John’s car, the information exists but we do not have it. In other cases, some attributes may be relevant only to some tuples and irrelevant to others. Alice is single, so the spouse field is irrelevant in her case. Furthermore, some information may be imprecise: “Heather lives in a large and cheap apartment,” where the values of large and cheap are fuzzy. Partial information may also arise when we cannot completely rely on the data because of possible inconsistencies (e.g., resulting from merging data from different sources).

As soon as we leave the realm of complete databases, most issues become much more intricate. To deal with the most general case, we need something resembling a theory of knowledge. In particular, this quickly leads to logics with modalities: Is it certain that John lives in Paris? Is it possible that he may? What is the probability that he does? Does John know that Alice is a good student? Does he believe so? etc.

The study of knowledge is a fascinating topic that is outside the scope of this book.

Clearly, there is a trade-off between the expressivity of the model for incomplete information used and the difficulty of answering queries. From the database perspective, we are primarily concerned with identifying this trade-off and understanding the limits of what is feasible in this context. The purpose of this chapter is to make a brief foray into this topic.

We limit ourselves mostly to models and results of a clear database nature. We consider simple forms of incompleteness represented by null values. The main problem we examine is how to answer queries on such databases. In relation to this, we argue that for a representation system of incomplete information to be adequate in the context of a query language, it must also be capable of representing answers to queries. This leads to a desirable closure property of representations of incomplete information with respect to query languages. We observe the increase of complexity resulting from the use of nulls.

We also consider briefly two approaches closer to knowledge bases. The first is based 487
488
Incomplete Information
on the introduction of disjunctions in deductive databases, which also leads to a form of incompleteness. The second is concerned with the use of modalities. We briefly mention the language KL, which permits us to talk about knowledge of the world.

19.1
Warm-Up
As we have seen, there are many possible kinds of incomplete information. In this section, we will focus on databases that partially specify the state of the world. Instead of completely identifying one state of the world, the database contents are compatible with many possible worlds. In this spirit, we define an incomplete database simply as a set of possible worlds (i.e., a set of instances). What is actually stored is a representation of an incomplete database. Choosing appropriate representations is a central issue.

We provide a mechanism for representing incomplete information using null values.

The basic idea is to allow occurrences of variables in the tuples of the database. The different possible values of the variables yield the possible worlds.

The simplest model that we consider is the Codd table (introduced by Codd), or table for short. A table is a relation with constants and variables, in which no variable occurs twice. More precisely, let U be a finite set of attributes. A table T over U is a finite set of free tuples over U such that each variable occurs at most once. An example of a table is given in Fig. 19.1. The figure also illustrates an alternative representation (using @) that is more visual but that we do not adopt here because it is more difficult to generalize.

The preceding definition easily extends to database schemas. A database table T over a database schema R is a mapping over R such that for each R in R, T(R) is a table over sort (R). For this generalization, we assume that the sets of variables appearing in each table are pairwise disjoint. Relationships between the variables can be stated through R
A
B
C
R
A
B
C
0
1
x
0
1
@
y
z
1
@
@
1
2
0
v
2
0
@
Table T
Alternative representation of T
R
A
B
C
R
A
B
C
R
A
B
C
R
A
B
C
0
1
2
0
1
2
0
1
2
0
1
1
2
0
1
3
0
1
2
0
1
2
0
1
2
0
0
2
0
5
2
0
0
I1
I2
I3
I4
Figure 19.1:
A table and examples of corresponding instances
19.1 Warm-Up
489
global conditions (which we will introduce in the next section). In this section, we will focus on single tables, which illustrate well the main issues.

To specify the semantics of a table, we use the notion of valuation (see Chapter 4). The incomplete database represented by a table is defined as follows:
rep(T ) = {ν(T ) | ν a valuation of the variables in T }.

Consider the table T in Fig. 19.1. Then I1, . . . , I4 all belong to rep(T ) (i.e., are possible worlds).

The preceding definition assumes the Closed World Assumption (CWA) (see Chapter 2). This is because each tuple in an instance of ref (T ) must be justified by the presence of a particular free tuple in T . An alternative approach is to use the Open World Assumption (OWA). In that case, the incomplete database of T would include all instances that contain an instance of rep(T ). In general, the choice of CWA versus OWA does not substantially affect the results obtained for incomplete databases.

We now have a simple way of representing incomplete information. What next? Naturally, we wish to be able to query the incomplete database. Exactly what this means is not clear at this point. We next look at this issue and argue that the simple model of tables has serious shortcomings with respect to queries. This will naturally lead to an extension of tables that models more complicated situations.

Let us consider what querying an incomplete database might mean. Consider a table T
and a query q. The table T represents a set of possible worlds rep(T ). For each I ∈ rep(T ), q would produce an answer q(I ). Therefore the set of possible answers of q is q( rep(T )).

This is, again, an incomplete database. The answer to q should be a representation of this incomplete database.

More generally, consider some particular representation system (e.g., tables). Such a system involves a language for describing representations and a mapping rep that associates a set of instances with each representation. Suppose that we are interested in a particular query language L (e.g., relational algebra). We would always like to be capable of representing the result of a query in the same system. More precisely, for each representation T
and query q, there should exist a computable representation q(T ) such that rep(q(T )) = q( rep(T )).

In other words, q(T ) represents the possible answers of q [i.e., {q(I ) | I ∈ rep(T )}].

If some representation system τ has the property described for a query language L, we will say that τ is a strong representation system for L. Clearly, we are particularly interested in strong representation systems for relational algebra and we shall develop such a system later.

Let us now return to tables. Unfortunately, we quickly run into trouble when asking queries against them, as the following example shows.

Example 19.1.1
Consider T of Fig. 19.1 and the algebraic query σA=3(T ). There is no table representing the possible answers to this query. A possible answer (e.g., for I1) is the empty relation, whereas there are nonempty possible answers (e.g., for I2). Suppose
490
Incomplete Information
that there exists a table T ′ representing the set of possible answers. Either T ′ is empty and σA=3(I2) is not in rep(T ′); or T ′ is nonempty and the empty relation is not in rep(T ′). This is a contradiction, so no such T ′ can exist.

The problem lies in the weakness of the representation system of tables; we will consider richer representation systems that lead to a complete representation system for all of relational algebra. An alternative approach is to be less demanding; we consider this next and present the notion of weak representation systems.

19.2
Weak Representation Systems
To relax our expectations, we will no longer require that the answer to a query be a representation of the set of all possible answers. Instead we will ask which are the tuples that are surely in the answer (i.e., that belong to all possible answers). (Similarly, we may ask for the tuples that are possibly in the answer (i.e., that belong to some possible answer).

We make this more precise next.

For a table T and a query q, the set of sure facts, sure(q, T ), is defined as sure(q, T ) = ∩{q(I ) | I ∈ rep(T )}.

Clearly, a tuple is in sure(q, T ) iff it is in the answer for every possible world. Observe that the sure tuples in a table T [i.e., the tuples in every possible world in rep(T )] can be computed easily by dropping all free tuples with variables. One could similarly define the set poss(q, T ) of possible facts.

One might be tempted to require of a weak system just the ability to represent the set of tuples surely in the answer. However, the definition requires some care due to the following subtlety. Suppose T is the table in Fig. 19.1 and q the query σA=2(R), for which sure(q, T ) = ∅. Consider now the query q′ = π AB(R) and the query q ◦ q′.

Clearly, q′( sure(q, T )) = ∅; however, sure(q′(q( rep(T ))) = {2, 0}. So q ◦ q′ cannot be computed by first computing the tuples surely returned by q and then applying q′. This is rather unpleasant because generally it is desirable that the semantics of queries be compositional (i.e., the result of q ◦ q′ should be obtained by applying q′ to the result of q). The conclusion is that the answer to q should provide more information than just sure(q, T ); the incomplete database it specifies should be equivalent to q( rep(T )) with respect to its ability to compute the sure tuples of any query in the language applied to it.

This notion of equivalence of two incomplete databases is formalized as follows.

If L is a query language, we will say that two incomplete databases I, J are L
equivalent, denoted I ≡L J , if for each q in L we have
∩{q(I ) | I ∈ I} = ∩{q(I ) | I ∈ J }.

In other words, the two incomplete databases are undistinguishable if all we can ask for is the set of sure tuples in answers to queries in L.

We can now define weak representation systems. Suppose L is a query language. A
19.2 Weak Representation Systems
491
representation system is weak for L if for each representation T of an incomplete database, and each q in L, there exists a representation denoted q(T ) such that rep(q(T )) ≡L q( rep(T )).

With the preceding definition, q(T ) does not provide precisely sure(q, T ) for tables T . However, note that sure(q, T ) can be obtained at the end simply by eliminating from the answer all rows with occurrences of variables.

The next result indicates the power of tables as a weak representation system.

Theorem 19.2.1
Tables form a weak representation system for selection-projection (SP)
[i.e., relational algebra limited to selection (involving only equalities and inequalities) and projection]. If union or join are added, tables no longer form a weak representation system.

Crux
It is easy to see that tables form a weak representation system for SP queries.

Selections operate conservatively on tables. For example,
σ cond(T ) = {t | t ∈ T and cond(ν(t)) holds
for all valuations ν of the variables in t}.

Projections operate like classical projections. For example, if T is again the table in Fig. 19.1, then
σA=2(T ) = {2, 0, v}
and
(π AB(R) ◦ σA=2(R))(T ) = {2, 0}.

Let us show that tables are no longer a weak representation system if join or union are added to SP. Consider join first. So the query language is now SPJ. Let T be the table R
A
B
C
a
x
c
a′
x′
c′
where x, x′ are variables and a, a′, c, c′ are constants.

Let q = π AC(R) ⊲⊳ πB(R). Suppose there is table W such that rep(W ) ≡ SPJ q( rep(T )),
and consider the query q′ = π AC(π AB(R) ⊲⊳ π BC(R)). Clearly, sure(q ◦ q′, T ) is
492
Incomplete Information
A
C
a
c
a′
c
a
c′
a′
c′
Therefore sure(q′, W ) must be the same. Because a′, c ∈ sure(q′, W ), for each valuation ν of variables in W there must exist tuples u, v ∈ W such that u(A) = a′, v(C) =
c, ν(u)(B) = ν(v)(B). Let ν be a valuation such that ν(z) = ν(y) for all variables z, y, z =
y. If u = v, then u(A) = a′ and u(C) = c so a′, c ∈ sure(π AC(R), W ). This cannot be because, clearly, a′, c ∈ sure(π AC(R), q( rep(T ))). So, u = v. Because ν(u)(B) = ν(v)(B) and W has no repeated variables, it follows that u(B) and v(B) equal some constant k. But then a′, k ∈ sure(π AB(R), W ), which again cannot be because one can easily verify that sure(π AB(R), q( rep(T ))) = ∅.

The proof that tables do not provide a weak representation system for SPU follows similar lines. Just consider the table T
R
A
B
x
b
and the query q outputting two relations: σA=a(R) and σA=a(R). It is easily seen that there is no pair of tables W1, W2 weakly representing q( rep(T )) with respect to SPU. To see this, consider the query q′ = πB(W1 ∪ W2). The details are left to the reader (Exercise 19.7).

Naive Tables
The previous result shows the limitations of tables, even as weak representation systems.

As seen from the proof of Theorem 19.2.1, one problem is the lack of repeated variables.

We next consider a first extension of tables that allows repetitions of variables. It will turn out that this will provide a weak representation system for a large subset of relational algebra.

A naive table is like a table except that variables may repeat. A naive table is shown in Fig. 19.2. Naive tables behave beautifully with respect to positive existential queries (i.e., conjunctive queries augmented with union). Recall that, in terms of the algebra, this is SPJU.

Theorem 19.2.2
Naive tables form a weak representation system for positive relational algebra.

Crux
Given a naive table T and a positive query q, the evaluation of q(T ) is extremely simple. The variables are treated as distinct new constants. The standard evaluation of q is then performed on the table. Note that incomplete information yields no extra cost in this case. We leave it to the reader to verify that this works.

19.3 Conditional Tables
493
R
A
B
C
0
1
x
x
z
1
2
0
v
Figure 19.2:
A naive table
Naive tables yield a nice representation system for a rather large language. But the representation system is weak and the language does not cover all of relational algebra. We introduce in the next section a representation that is a strong system for relational algebra.

19.3
Conditional Tables
We have seen that Codd tables and naive tables are not rich enough to provide a strong representation system for relational algebra. To see what is missing, recall that when we attempt to represent the result of a selection on a table, we run into the problem that the presence or absence of certain tuples in a possible answer is conditioned by certain properties of the valuation. To capture this, we extend the representation with conditions on variables, which yields conditional tables. We will show that such tables form a strong representation system for relational algebra.

A condition is a conjunct of equality atoms of the form x = y, x = c and of inequality atoms of the form x = y, x = c, where x and y are variables and c is a constant. Note that we only use conjuncts of atoms and that the Boolean true and false can be respectively encoded as atoms x = x and x = x.

If formula P is a condition, we say that a valuation ν satisfies P if its assignment of constants to variables makes the formula true.

Conditions may be associated with table T in two ways: (1) A global condition PT is associated with the entire table T ; (2) a local condition ϕt is associated with one tuple t of table T . A conditional table ( c-table for short) is a triple (T , PT , ϕ), where
• T is a table,
• PT is a global condition,
• ϕ is a mapping over T that associates a local condition ϕt with each tuple t of T .

A c-table is shown in Fig. 19.3. If we omit listing a condition, then it is by default the atom true. Note also that conditions PT and ϕt for t in T may contain variables not appearing respectively in T or t.

For our purposes, the global conditions in c-tables could be distributed at the tuple level as local conditions. However, they are convenient as shorthand and when dependencies are considered.

For brevity, we usually refer to a c-table (T , PT , ϕ) simply as T . A given c-table T
represents a set of instances as follows (again adopting the CWA):
494
Incomplete Information
T′
A
B
x ≠ 2, y ≠ 2
0
1
z = z
1
x
y = 0
y
x
x ≠ y
J
J
J
J
1
A
B
2
A
B
3
A
B
4
A
B
0
1
0
1
0
1
0
1
0
0
1
0
0
3
Figure 19.3:
A c-table and some possible instances
rep(T ) = {I | there is a valuation ν satisfying PT such that relation I consists exactly of those facts ν(t) for which ν satisfies ϕt}.

Consider the table T ′ in Fig. 19.3. Then J1, J2, J3, J4 are obtained by valuating x, y, z to (0,0,0), (0,1,0), (1,0,0), and (3,0,0), respectively.

The next example illustrates the considerable power of the local conditions of c-tables, including the ability to capture disjunctive information.

Example 19.3.1
Suppose we know that Sally is taking math or computer science (CS)
(but not both) and another course; Alice takes biology if Sally takes math, and math or physics (but not both) if Sally takes physics. This can be represented by the following c-table:
Student
Course
(x = math) ∧ (x = CS)
Sally
math
(z = 0)
Sally
CS
(z = 0)
Sally
x
Alice
biology
(z = 0)
Alice
math
(x = physics) ∧ (t = 0)
Alice
physics
(x = physics) ∧ (t = 0)
19.3 Conditional Tables
495
Observe that there may be several c-table representations for the same incomplete database. Two representations T , T ′ are said to be equivalent, denoted T ≡ T ′, if rep(T ) =
rep(T ′). Testing for equivalence of c-tables is not a trivial task. Just testing membership of an instance in rep(T ), apparently a simpler task, will be shown to be np-complete. To test equivalence of two c-tables T and T ′, one must show that for each valuation ν of the variables in T there exists a valuation ν′ for T ′ such that ν(T ) = ν′(T ′), and conversely.

Fortunately, it can be shown that one need only consider valuations to a set C of constants containing all constants in T or T ′ and whose size is at most the number of variables in the two tables (Exercise 19.11). This shows that equivalence of c-tables is decidable.

In particular, finding a minimal representation can be hard. This may affect the computation of the result of a query in various ways: The complexity of computing the answer may depend on the representation of the input; and one may require the result to be somewhat compact (e.g., not to contain tuples with unsatisfiable local conditions).

It turns out that c-tables form a strong representation system for relational algebra.

Theorem 19.3.2
For each c-table T over U and relational algebra query q over U , one can construct a c-table q(T ) such that rep(q(T )) = q( rep(T )).

Crux
The proof is straightforward and is left as an exercise (Exercise 19.13). The example in Fig. 19.4 should clarify the construction.1 For projection, it suffices to project the columns of the table. Selection is performed by adding new conjuncts to the local conditions. Union is represented by the union of the two tables (after making sure that they use distinct sets of variables) and choosing the appropriate local conditions. Join and intersection involve considering all pairs of tuples from the two tables. For difference, we consider a tuple in the first table and add a huge conjunct stating that it does not match any tuple from the second table (disjunctions may be used as shorthand; they can be simulated using new variables, as illustrated in Example 19.3.1).

To conclude this section, we consider (1) languages with recursion, and (2) dependencies. In both cases (and for related reasons) the aforementioned representation system behaves well. The presentation is by examples, but the formal results can be derived easily.

Languages with Recursion
Consider an incomplete database and a query involving fixpoint. For instance, consider the table in Fig. 19.5. The representation tc(T ) of the answer to the transitive closure query tc is also given in the same figure. One can easily verify that
rep( tc(T )) = tc( rep(T )).

This can be generalized to arbitrary languages with iteration. For example, consider a c-table T and a relational algebra query q that we want to iterate until a fixpoint is reached.

1 The representations in the tables can be simplified; they are given in rough form to illustrate the proof technique.

496
Incomplete Information
T 1
B
C
T 2
B
C
π B( T 2) B
x
c
y
c
( y = b)
y
( y = b)
z
w
z
T 3
A
B
σ B=b( T 1 T 3) A
B
C
a
y
a
y
c
( y = x) ∧ ( y = b)
T 1 ∪ T 2
B
C
T 1 T 3 A
B
C
x
c
a
y
c
( y = x)
y
c
( y = b)
z
w
T 1 – T 2
B
C
x
c
( y ≠ b) ∧ ( x ≠ z)
x
c
( y ≠ b) ∧ ( w ≠ c)
x
c
( y = b) ∧ ( x ≠ b) ∧ ( x ≠ z) x
c
( y = b) ∧ ( x ≠ b) ∧ ( w ≠ c) Figure 19.4:
Computing with c-tables
Then we can construct the sequence of c-tables:
q(T ), q2(T ), . . . , qi(T ), . . . .

Suppose now that q is a positive query. We are guaranteed to reach a fixpoint on every single complete instance. However, this does not a priori imply that the sequence of representations {qi(T )}i>0 converges. Nonetheless, we can show that this is in fact the case. For some i,
rep(qi(T )) = rep(qi+1(T )).

19.3 Conditional Tables
497
T
A
B
t c(T )
A
B
a
b
a
b
x
c
x
c
c
d
c
d
a
c
x = b
x
d
c
c
x = d
a
d
x = b
Figure 19.5:
Transitive closure of a table
(See Exercise 19.17.) It can also be shown easily that for such i, every I ∈ rep(qi(T )) is a fixpoint of q. The proof is by contradiction: Suppose there is I ∈ rep(qi(T )) such that q(I ) = I , and consider one such I with a minimum number of tuples. Because rep(qi(T )) = rep(qi+1(T )), I = q(J ) for some J ∈ rep(qi(T )). Because q is positive, J ⊆ I ; so because q(I ) = I , J ⊂ I . This contradicts the minimality of I . So qi(T )) is indeed the desired answer.

Thus to find the table representing the result, it suffices to compute the sequence
{qi(T )}i>0 and stop when two consecutive tables are equivalent.

Dependencies
In Part B, we studied dependencies in the context of complete databases. We now reconsider dependencies in the context of incomplete information. Suppose we are given an incomplete database (i.e., a set I of complete databases) and are told, in addition, that some set $ of dependencies is satisfied. The question arises: How should we interpret the combined information provided by I and by $?

The answer depends on our view of the information provided by an incomplete database. Dependencies should add to the information we have. But how do we compare incomplete databases with respect to information content? One common-sense approach, in line with our discussion so far, is that more information means reducing further the set of possible worlds. Thus an incomplete database I (i.e., a set of possible worlds) is more informative than J iff I ⊂ J . In this spirit, the natural use of dependencies would be to eliminate from I those possible worlds not satisfying $. This makes sense for egd’s (and in particular fd’s).

A different approach may be more natural in the context of tgd’s. This approach stems from a relaxation of the CWA that is related to the OWA. Let I be an incomplete database, and let $ be a set of dependencies. Recall that tgd’s imply the presence of certain tuples based on the presence of other tuples. Suppose that for some I ∈ I, a tuple t implied by a tgd in $ is not present in I . Under the relaxation of the CWA, we conclude that t should be viewed as present in I , even though it is not represented explicitly. More generally, the chase (see Chapter 8), suitably generalized to operate on instances rather than tableaux,
498
Incomplete Information
I1
I2
I3
J1
J2
A
B
C
A
B
C
A
B
C
A
B
C
A
B
C
a
b
c
e
f
g
a
b
c
a
b
c
e
f
g
a
b′
c′
e
f ′
g′
g
b
h
a
b′
c′
e
f ′
g′
e
f
g′
a
b
c′
e
f
g
e
f ′
g
a
b′
c
e
f ′
g
Figure 19.6:
Incomplete databases and dependencies
can be used to complete the instance by adding all missing tuples implied by the tgd’s in $. (See Exercise 19.18.)

In fact, the chase can be used for both egd’s and tgd’s. In contrast to tgd’s, the effect of chasing with egd’s (and, in particular, fd’s) may be to eliminate possible worlds that violate them. Note that tuples added by tgd’s may lead to violations of egd’s. This suggests that an incomplete database I with a set $ of dependencies represents
{ chase(I, $) | I ∈ I and the chase of I by $ succeeds}.

For example, consider Fig. 19.6, which shows the incomplete database I = {I1, I2, I3}.

Under this perspective, the incorporation of the dependencies $ = {A →
→ B, B → A} in
this incomplete database leads to J = {J1, J2}.

Suppose now that the incomplete database I is represented as a c-table T . Can the effect of a set $ of full dependencies on T be represented by another c-table T ′? The answer is yes, and T ′ is obtained by extending the chase to c-tables in the straightforward way. For example, a table T1 and its completion T2 by $ = {A →
→ B, C → D} are given
in Fig. 19.7. The reader might want to check that
chase$( rep(T1)) = rep(T2).

T1
A
B
C
D
T2
A
B
C
D
a
b
c
d
a
b
c
d
x
e
y
g
x
e
y
g
a
b
c
z
a
b
y
g
(x = a)
a
e
c
d
(x = a)
Figure 19.7:
c-tables and dependencies
19.4 The Complexity of Nulls
499
19.4
The Complexity of Nulls
Conditional tables may appear to be a minor variation from the original model of complete relational databases. However, we see next that the use of nulls easily leads to intractability.

This painfully highlights the trade-off between modeling power and resources.

We consider some basic computational questions about incomplete information databases. Perhaps the simplest question is the possibility problem: “Given a set of possible worlds (specified, for instance, by a c-table) and a set of tuples, is there a possible world where these tuples are all true?” A second question is the certainty problem: “Given a set of possible worlds and a set of tuples, are these tuples all true in every possible world?”
Natural variations of these problems involve queries: Is a given set of tuples possibly (or certainly) in the answer to query q?

Consider a (c-) table T , a query q, a relation I , and a tuple t. Some typical questions include the following:
(Membership) Is I a possible world for T [i.e., I ∈ rep(T )]?

(Possibility) Is t possible [i.e., ∃I ∈ rep(T )(t ∈ I )]?

(Certainty) Is t certain [i.e., ∀I ∈ rep(T )(t ∈ I )]?

(q-Membership) Is I a possible answer for q and T [i.e., I ∈ q( rep(T ))]?

(q-Possibility) Is t possibly in the answer [i.e., ∃I ∈ rep(T )(t ∈ q(I ))]?

(q-Certainty) Is t certainly in the answer [i.e., ∀I ∈ rep(T )(t ∈ q(I ))]?

Finally we may consider the following generalizations of the q-membership problem: (q-Containment) Is T contained in q(T ′) [i.e., rep(T ) ⊆ q( rep(T ′))]?

(q, q′-Containment) Is q(T ) contained in q′(T ) [i.e., rep(q(T )) ⊆ rep(q′(T ))]?

The crucial difference between complete and incomplete information is the large number of possible valuations for the latter case. Because of the finite number of variables in a set of c-tables, only a finite number of valuations are nonisomorphic (see Exercise 19.10).

However, the number of such valuations may grow exponentially in the input size. By simple reasoning about all valuations and by guessing particular valuations, we have some easy upper bounds. For a query q that can be evaluated in polynomial time on complete databases, deciding whether I ∈ q( rep(T )), or whether I is a set of possible answers, can be answered in np; checking whether q( rep(T )) = {I }, or if I is a set of certain tuples, is in co-np.

To illustrate such complexity results, we demonstrate one lower bound concerning the q-membership problem for (Codd) tables.

Proposition 19.4.1
There exists a positive existential query q such that checking, given a table T and a complete instance I , whether I ∈ q( rep(T )) is np-complete.

Proof
The proof is by reduction of graph 3-colorability. For simplicity, we use a query mapping a two-relation database into another two-relation database. (An easy modification of the proof shows that the result also holds for databases with one relation. In particular,
500
Incomplete Information
increase the arity of the largest relation, and use constants in the extra column to encode several relations into this one.)

We will use (1) an input schema R with two relations R, S of arity 5 and 2, respectively; (2) an output schema R′ with two relations R′, S′ of arity 3 and 1, respectively; and (3) a positive existential query q from R to R′. The query q [returning, on each input I over R, two relations q1(I) and q2(I) over R′ and S′] is defined as follows: q1 = {x, z, z′ | ∃y([∃vw(R(x, y, v, w, z) ∨ R(v, w, x, y, z))]
∧ [∃vw(R(x, y, v, w, z′) ∨ R(v, w, x, y, z′))])}
q2 = {z | ∃xyvw(R(x, y, v, w, z) ∧ S(y, w))}.

For each input G = (V , E) to the graph 3-colorability problem, we construct a table T over the input schema R and an instance I′ over the output schema R′, such that G is 3-colorable iff I′ ∈ q( rep(T)).

Without loss of generality, assume that G has no self-loops and that E is a binary relation, where we list each edge once with an arbitrary orientation.

Let V = {ai | i ∈ [1..n]} and E = {(bj , cj ) | j ∈ [1..m]}. Let {xj | j ∈ [1..m]} and
{yj | j ∈ [1..m]} be two disjoint sets of distinct variables. Then T and I′ are constructed as follows:
(a) T(R) = {tj | j ∈ [1..m]}, where tj is the tuple bj , xj , cj , yj , j ; (b) T(S) = {i, j | i, j ∈ {1, 2, 3}, i = j };
(c) I′(R′) = {a, j, k | a ∈ {bj , cj } ∩ {bk, ck}, where each (b, c) pair is an edge in E }; and
(d) I′(S′) = {j | j ∈ [1..m]}.

Intuitively, for each tuple in I(R), the second column contains the color of the vertex in the first column, and the fourth column contains the color of the vertex in the third column.

The edges are numbered in the fifth column. The role of query q2 is to check whether this provides an assignment of the three colors {1, 2, 3} to vertexes such that the colors of the endpoints of each edge are distinct. Indeed, q2 returns the edges z for which the colors y, w of its endpoints are among {1, 2, 3}. So if q(I)(S′) = I′(S′), then all edges have color assignments among {1, 2, 3} to their endpoints. Next query q1 checks whether a vertex is assigned the same color consistently in all edges where it occurs. It returns the x, z, z′, where x is a vertex, z and z′ are edges, x occurs as an endpoint, and x has the same color assignment y in both z and z′. So if q1(I)(R′) = I′(R′), it follows that the color assignment is consistent everywhere for all vertexes.

For example, consider the graph G given in Fig. 19.8; the corresponding I′ and T
are exhibited in Fig. 19.9. Suppose that f is a 3-coloring of G. Consider the valuation σ
defined by σ (xj ) = f (bj ) and σ (yj ) = f (cj ) for all j . It is easily seen that I′ = q(σ (T )).

Moreover, it is straightforward to show that G is 3-colorable iff I′ is in q( rep(T)).

19.5 Other Approaches
501
1
2
2
3
3
4
4
1
3
1
Figure 19.8:
Graph G
T(R)
T(S)
I′(R′)
I′(S′)
1
x1
2
y1
1
1
2
1
1
1
1
2
x2
3
y2
2
1
3
1
1
4
2
3
x3
4
y3
3
2
1
1
1
5
3
4
x4
1
y4
4
2
3
1
4
1
4
3
x5
1
y5
5
3
1
1
4
4
5
3
2
1
4
5
2
1
1
2
1
2
2
2
1
2
2
2
...

4
3
3
4
3
4
4
4
3
4
4
4
Figure 19.9:
Encoding for the reduction of 3-colorability
19.5
Other Approaches
Incomplete information often arises naturally, even when the focus is on complete databases. For example, the information in a view is by nature incomplete, which in particular leads to problems when trying to update the view (as discussed in Chapter 22); and we already considered relations with nulls in the weak universal relations of Chapter 11.

In this section, we briefly present some other aspects of incomplete information. We consider some alternative kinds of null values; we look at disjunctive deductive databases; we mention a language that allows us to address directly in queries the issue of incompleteness; and we briefly mention several situations in which incomplete information arises naturally, even when the database itself is complete. An additional approach to representing incomplete information, which stems from using explicit logical theories, will be presented in connection with the view update problem in Chapter 22.

502
Incomplete Information
Other Nulls in Brief
So far we have focused on a specific kind of null value denoting values that are unknown.

Other forms of nulls may be considered. We may consider, for instance, nonexisting nulls.

For example, in the tuple representing a CEO, the field DirectManager has no meaning and therefore contains a nonexisting null. Nonexisting nulls are at the core of the weak universal model that we considered in Chapter 11.

It may also be the case that we do not know for a specific field if a value exists. For example, if the database ignores the marital status of a particular person, the spouse field is either unknown or nonexisting. It is possible to develop a formal treatment of such no-information nulls. An incomplete database consists of a set of sets of tuples, where each set of tuples is closed under projection. This closure under projection indicates that if a tuple is known to be true, the projections of this tuple (although less informative) are also known to be true. (The reader may want to try, as a nontrivial exercise, to define tables formally with such nulls and obtain a closure theorem analogous to Theorem 19.3.2.) For each new form of null values, the game is to obtain some form of representation with clear semantics and try to obtain a closure theorem for some reasonable language (like we did for unknown nulls). In particular, we should focus on the most important algebraic operations for accessing data: projection and join. It is also possible to establish a lattice structure with the different kinds of nulls so that they can be used meaningfully in combination.

Disjunctive Deductive Databases
Disjunctive logic programming is an extension of standard logic programming with rules of the form
A1 ∨ · · · ∨ Ai ← B1, . . . , Bj , ¬C1, . . . , ¬Ck.

In datalog, the answer to a query is a set of valuations. For instance, the answer to a query
← Q(x) is a set of constants a such that Q(a) holds. In disjunctive deductive databases, an answer may also be a disjunction Q(a) ∨ Q(b).

Disjunctions give rise to new problems of semantics for logic programs. Although in datalog each program has a unique minimal model, this is no longer the case for datalog with disjunctions. For instance, consider the database consisting of a single statement
{Q(a) ∨ Q(b)}. Then there are clearly two minimal models: {Q(a)} and {Q(b)}. This leads to semantics in terms of sets of minimal models, which can be viewed as incomplete databases. We can develop a fixpoint theory for disjunctive databases, extending naturally the fixpoint approach for datalog. To do this, we use an ordering over sets of minimal interpretations (i.e., sets I of instances such that there are no I, J in I with I ⊂ J ).

Definition 19.5.1
Let I, J be sets of minimal interpretations. Then
J ⊑ I iff ∀I ∈ I (∃J ∈ J (J ⊆ I )).

19.5 Other Approaches
503
Consider the following immediate consequence operator. Let P be a datalog program with disjunctions, and let I be a set of minimal interpretations. A new set J of interpretations is obtained as follows. For each I in I, state P (I ) is the set of disjunctions of the form A1 ∨ · · · ∨ Ai that are immediate consequences of some facts in I using P . Then J
is the set of of instances J such that for some I ∈ I, J is a model of state P (I ) containing I . Clearly, J is not a set of minimal interpretations. The immediate consequence of I, denoted TP (I), is the set of minimal interpretations in J . Now consider the sequence I0 = ∅
Ii = TP (Ii−1).

It is easy to see that the sequence {Ii}i≥0 is nondecreasing with respect to the ordering ⊑, so it becomes constant at some point. The semantics of P is the limit of the sequence.

When negation is introduced, the situation, as usual, becomes more complicated. However, it is possible to extend semantics, such as stratified and well founded, to disjunctive deductive databases.

Overall, the major difficulty in handling disjunction is the combinatorial explosion it entails. For example, the fixpoint semantics of datalog with disjunctions may yield a set of interpretations exponential in the input.

Logical Databases and KL
The approach to null values adopted here is essentially a semantic approach, because the meaning of an incomplete database is a set of possible instances. One can also use a syntactic, proof-theoretic approach to modeling incomplete information. This is done by regarding the database as a set of sentences, which yields the logical database approach.

As discussed in Chapter 2, in addition to statements about the real world, logical databases consider the following:
1. Uniqueness axioms: State that distinct constants stand for distinct elements in the real world.

2. Domain closure axiom: Specify the universe of constants.

3. Completion axiom: Specify that no fact other than recorded holds.

Missing in both the semantic and syntactic approaches is the ability to make more refined statements about what the database knows. Such capabilities are particularly important in applications where the real world is slowly discovered through imprecise data.

In such applications, it is general impossible to wait for a complete state to answer queries, and it is often desirable to provide the user with information about the current state of knowledge of the database.

To overcome such limitations, we may use languages with modalities. We briefly mention one such language: KL. The language KL permits us to distinguish explicitly between the real world and the knowledge the database has of it. It uses the particular modal symbol K. Intuitively, whereas the sentence ϕ states the truth of ϕ in the real world, Kϕ states that the database knows that ϕ holds.

For instance, the fact that the database knows neither that Alice is a student nor that
504
Incomplete Information
she is not is expressed by the statement
¬K Student( Alice) ∧ ¬K(¬ Student( Alice)).

The following KL statement says that there is a teacher who is unknown:
∃x( Teacher( x) ∧ ¬K( Teacher( x))).

This language allows the database to reason and answer queries about its own knowledge of the world.

Incomplete Information in Complete Databases
Incomplete information often arises naturally even when the focus is on complete databases. The following are several situations that naturally yield incomplete information:
• Views: Although a view of a database is usually a complete database, the information it contains is incomplete relative to the whole database. For a user seeing the view, there are many possible underlying databases. So the view can be seen as a representation for the set of possible underlying databases. The incompleteness of the information in the view is the source of the difficulty in view updating (see Chapter 22).

• Weak universal relations: We have already seen how relations with nulls arise in the weak universal relations of Chapter 11.

• Nondeterministic queries: Recall from Chapter 17 that nondeterministic languages have several possible answers on a given input. Thus we can think of nondeterministic queries as producing as an answer a set of possible worlds (see also Exercise 19.20).

• Semantics of negation: As seen in Chapter 15, the well-founded semantics for datalog¬ involves 3-valued interpretations, where some facts are neither true nor false but unknown. Clearly, this is a form of incomplete information.

Bibliographic Notes
It was accepted early on that database systems should handle incomplete information
[Cod75]. After some interesting initial work on the topic (e.g., [Cod75, Gra77, Cod79, Cod82, Vas79, Vas80, Bis81, Lip79, Lip81, Bis83]), the landmark paper [IL84] laid the formal groundwork for incomplete databases with nulls of the unknown kind and introduced the notion of representation system. That paper assumed the OWA, as opposed to the CWA that was assumed in this chapter. Since then, there has been considerable work on querying incomplete information databases. The focus of most of this work has been a search for the correct semantics for queries applied to incomplete information databases (e.g., [Gra84, Imi84, Zan84, AG85, Rei86, Var86b]).

Much of the material presented in this chapter is from [IL84] (although it was presented there assuming the OWA), and we refer the reader to it for a detailed treatment.

Bibliographic Notes
505
Tables form the central topic of the monograph [Gra91]. Examples in Section 19.1 are taken from there. The naive tables have been called “V-tables” and “e-tables” in [AG85, Gra84, IL84]. The c-tables with local conditions are from [IL84]; they were augmented with global conditions in [Gra84]. The fact that c-tables provide a strong representation system for relational algebra is shown in [IL84]. That this strong representation property extends to query languages with fixpoint on positive queries is reported in [Gra91]. Chasing is applied to c-tables in [Gra91].

There are two main observations in the literature on certainty semantics. The first observation follows from the results of [IL84] (based on c-tables) and [Rei86, Var86b]
(based on logical databases). Namely, under particular syntactic restrictions on c-tables and using positive queries, the certainty question can be handled exactly as if one had a complete information database. The second observation deals with the negative effects of the many possible instantiations of the null values (e.g., [Var86b]).

Comprehensive data-complexity analysis of problems related to representing and querying databases with null values is provided in [IL84, Var86b, AKG91]. The program complexity of evaluation is higher by an exponential than the data complexity [Cos83, Var82a]. Such problems were first noted in [HLY80, MSY81] as part of the study of nulls in weak universal instances.

Early investigations suggesting the use of orderings in the spirit of denotational semantics for capturing incomplete information include [Vas79, Bis81]. The first paper to develop this approach is [BJO91], which focused on fd’s and universal relations. This has spawned several papers, including an extension to complex objects (see Chapter 20)
[BDW88, LL90], mvd’s [Lib91], and bags [LW93b]. An important issue in this work concerns which power domain ordering is used (Hoare, Smyth, or Plotkin); see [BDW91, Gun92, LW93a].

The logical database approach has been largely influenced by the work of Reiter
[Rei78, Rei84, Rei86] and by that of Vardi [Var86a, Var86b]. The extension of the fixpoint operator of logic programs to disjunctive logic programs is shown in [MR90]. Disjunctive logic programming is the topic of [LMR92]. A survey on deductive databases with disjunctions can be found in [FM92]. The complexity of datalog with disjunction is investigated in [EGM94].

A related but simpler approach to incomplete information is the use of “or-sets.” As a simple example, a tuple Joe, {20, 21} might be used to indicate that Joe has age either 20
or 21. This approach is introduced in [INV91a, INV91b] in the context of complex objects; subsequent works include [Rou91, LW93a].

One will find in [Lev84b, Lev84a] entry points to the interesting world of knowledge bases (from the viewpoint of incompleteness of information), including the language KL. A related, active area of research, called reasoning about knowledge, extends modal operators to talk about the knowledge of several agents about facts in the world or about each other’s knowledge. This may be useful in distributed databases, where sites may have different knowledge of the world. The semantics of such statements is in terms of an extension of the possible worlds semantics, based on Kripke structures. An introduction to reasoning about knowledge can be found in [Hal93, FHMV95].

Finally, nonapplicable nulls are studied in [LL86]; open nulls are studied in [GZ88]; and weak instances with nonapplicable nulls are studied in [AB87b].

506
Incomplete Information
Exercises
Exercise 19.1
Consider the c-table in Example 19.3.1. Give the c-tables for the answers to these queries: (1) Which students are taking Math? (2) Which students are not taking Math? (3) Which students are taking Biology? In each case, what are the sets of sure and possible tuples of the answer?

Exercise 19.2
Consider the c-table T ′ in Fig. 19.3. Show that each I in rep(T ′) has two tuples.

Is T ′ equivalent to some 2-tuple c-table?

Exercise 19.3
Consider the naive table in Fig. 19.2. In the weak representation system described in Section 19.1, compute the naive tables for the answers to the queries σA=C(R), π AB(R) ⊲⊳ π AC(R). What are the tuples surely in the answers to these queries?

Exercise 19.4
A ternary c-table T represents a directed graph with blue, red, and yellow edges. The first two columns represent the edges and the last the colors. Some colors are unknown. The local conditions are used to enforce that a blue edge cannot follow a red one on a path. Give a datalog query q stating that there is a cycle with no two consecutive edges of the same color. Give c-tables such that (1) there is surely such a cycle; and (2) there may be one but it is not sure. In each case, compute the table strongly representing the answer to q.

Exercise 19.5
Let T be the Codd table in Fig. 19.1. Compute strong representations of the results of the following queries, using c-tables: (a) σA=3(R); (b) q1 = δ BC→ AB(π BC(R)); (c) q1 ∪ π AB(R); (d) q1 ∩ π AB(R); (e) q1 − π AB(R); (f) q1 ⊲⊳ π BC(R).

Exercise 19.6
Consider the c-table T4 = T1 ∪ T2 of Fig. 19.4. Compute a strong representation of the transitive closure of T4.

Exercise 19.7
Complete the proof that Codd tables are not a weak representation system with respect to SPU, in Theorem 19.2.1.

Exercise 19.8
Example 19.1.1 shows that one cannot strongly represent the result of a selection on a table with another table. For which operations of relational algebra applied to tables is it possible to strongly represent the result?

Exercise 19.9
Prove that naive tables are not a weak representation system for relational algebra.

Exercise 19.10
Prove that, given a c-table T without constants, rep(T ) is the closure under isomorphism of a finite set of instances. Extend the result for the case with constants.

Exercise 19.11
Provide an algorithm for testing equivalence of c-tables.

⋆ Exercise 19.12 Show that there exists a datalog query q such that, given a naive table T and a tuple t, testing whether t is possibly in the answer is np-complete.

Exercise 19.13
Prove Theorem 19.3.2.

Exercise 19.14
Prove that for each c-table T1 and each set of fd’s and mvd’s, there exists a table T2 such that chase( rep(T1)) = rep(T2). Hint: Use the chase on c-tables.

⋆ Exercise 19.15 Show that there is a query q in polynomial time for which deciding, given I and a c-table T , (a) whether I ∈ q( rep(T )), or whether I is possible, are np-complete; and (b) whether q( rep(T )) ⊆ {I }, or whether I is certain, are co-np-complete.

Exercises
507
Exercise 19.16
Give algorithms to compute, for a c-table T and a relational algebra query q, the set of tuples sure(q, T ) surely in the answer and the set of tuples poss(q, T ) possibly in the answer. What is the complexity of your algorithms?

Exercise 19.17
Let T be a c-table and q a positive existential query of the same arity as T .

Show that the sequence qi(T ) converges [i.e., that for some i, qi(T ) ≡ qi+1(T )]. Hint: Show that the sequence converges in at most m stages, where m = max{i | qi(I ) = qi+1(I ), I ∈ I}
and where I is a finite set of relations representing the nonisomorphic instances in rep(T ).

Exercise 19.18
Describe how to generalize the technique of chasing by full dependencies to apply to instances rather than tableau. If an egd can be applied and calls for two distinct constants to be identified, then the chase ends in failure. Show that for instance I , if the chase of I by succeeds, then chase(I, ) |= .

Exercise 19.19
Show that for datalog programs with disjunctions in heads of rules, the sequence {Ii}i≥0 of Section 19.5 converges. What can be said about the limit in model-theoretic terms?

♠ Exercise 19.20 [ASV90] There is an interesting connection between incomplete information and nondeterminism. Recall the nondeterministic query languages based on the witness operator W , in Chapter 17. One can think of nondeterministic queries as producing as an answer a set of possible worlds. In the spirit of the sure and possible answers to queries on incomplete databases, one can define for a nondeterministic query q the deterministic queries sure(q) and poss(q) as follows:
sure(q)(I ) = ∩{J | J ∈ q(I )}
poss(q)(I ) = ∪{J | J ∈ q(I )}
Consider the language FO + W , where a program consists of a finite sequence of assignment statements of the form R := ϕ, where ϕ is a relational algebra expression or an application of W
to a relation. Let sure( FO + W ) denote all deterministic queries that can be written as sure(q) for some FO + W query q, and similarly for poss( FO + W ). Prove that (a) poss( FO + W ) =np, and
(b) sure( FO + W ) =co-np.

20 ComplexValues
Alice:
Complex values?

Riccardo:
We could have used a different title: nested relations, complex objects, structured objects . . .

Vittorio:
. . . N1NF, NFNF, NF 2 , NF2, V-relation . . . I have seen all these names and others as well.

Sergio:
In a nutshell, relations are nested within relations; something like Matriochka relations.

Alice:
Oh, yes. I love Matriochkas.

Although we praised the simplicity of the data structure in the relational model, this simplicity becomes a severe limitation when designing many practical database applications. To overcome this problem, the complex value model has been proposed as a significant extension of the relational one. This extension is the topic of this chapter.

Intuitively, complex values are relations in which the entries are not required to be atomic (as in the relational model) but are allowed to be themselves relations. The data structure in the relational model (the relation) can be viewed as the result of applying to atomic values two constructors: a tuple constructor to make tuples and a set constructor to make sets of tuples (relations). Complex values allow the application of the tuple and set constructor recursively. Thus they can be viewed as finite trees whose internal nodes indicate the use of the tuple and finite set constructors. Clearly, a relation is a special kind of complex value: a set of tuples of atomic values.

At the schema level, we will specify a set of complex sorts (or types). These indicate the structure of the data. At the instance level, sets of complex values corresponding to these sorts are provided. For example, we have the following:
Sort
Complex Value
dom
a
{dom}
{a, b, c}
A : dom, B : dom
A : a, B : b
{A : dom, B : dom}
{A : a, B : b, A : b, B : a}
{{dom}}
{{a, b}, {a}, { }}
An example of a more involved complex value sort and of a value of that sort is shown in Fig. 20.1(a). The tuple constructor is denoted by × and the set constructor by ∗. An 508
Complex Values
509
*
*
×
×
×
A
B
C
A
B
C
A
B
C
dom
dom
*
a
b
*
e
f
*
×
×
×
A
E
A
E
A
E
dom
c
*
*
d
*
dom
(a) A sort and a value of that sort
A
B
C
A
E
a
b
c
d
A
E
e
f
(b) Another representation of the same value
Figure 20.1:
Complex value
alternative representation more in the spirit of our representations of relations is shown in Fig. 20.1(b). Another complex value (for a CINEMA database) is shown in Fig. 20.2.

We will see that, whereas it is simple to add the tuple constructor to the traditional relational data model, the set constructor requires a number of interesting new ideas. There are similarities between this set construct and the set constructs used in general-purpose programming languages such as Setl.

In this chapter, we introduce complex values and present a many-sorted algebra and an equivalent calculus for complex values. The focus is on the use of the two constructors of complex values: tuples and (finite) sets. (Additional constructors, such as list, bags, and
510
Complex Values
Director
Movies
Title
Actors
Forsythe
Gwenn
The Trouble with Harry
MacLaine
Hitchcock
Hitchcock
Hedren
Taylor
The Birds
Pleshette
Hitchcock
Perkins
Psycho
Leigh
Hitchcock
Title
Actors
Andersson
Sylwan
Cries and Whispers
Thulin
Ullman
Bergman
von Sydow
Björnstrand
The Seventh Seal
Ekerot
Poppe
Figure 20.2:
The CINEMA database revisited (with additional data shown)
union, have also been incorporated into complex values but are not studied here.) After introducing the algebra and calculus, we present examples of these interesting languages. We then comment on the issues of expressive power and complexity and describe equivalent languages with fixpoint operators, as well as languages in the deductive paradigm. Finally we briefly examine a subset of the commercial query language O2SQL that provides an elegant SQL-style syntax for querying complex values.

The theory described in this chapter serves as a starting point for object-oriented databases, which are considered in Chapter 21. However, key features of the object-oriented paradigm, such as objects and inheritance, are still missing in the complex value framework and are left for Chapter 21.

20.1 Complex Value Databases
511
20.1
Complex Value Databases
Like the relational model, we will use relation names in relname, attributes in att, and constants in dom. The sorts are more complex than for the relational model. Their abstract syntax is given by
τ = dom | B1 : τ, . . . , Bk : τ | {τ },
where k ≥ 0 and B1, . . . , Bk are distinct attributes. Intuitively, an element of dom is a constant; an element of B1 : τ1, . . . , Bk : τk is a k-tuple with an element of sort τi in entry Bi for each i; and an element of sort {τ } is a finite set of elements of sort τ .

Formally, the set of values of sort τ (i.e., the interpretation of τ ), denoted [τ] , is defined by
1. [dom] = dom,
2. [{τ }] = {{v1, . . . , vj } | j ≥ 0, vi ∈ [τ], i ∈ [1, j ]}, and 3. [B1 : τ1, . . . , Bk : τk] = {B1 : v1, . . . , Bk : vk | vj ∈ [τj], j ∈ [1, k]}.

An element of a sort is called a complex value. A complex value of the form B1 : a1, . . . , Bk : ak is said to be a tuple, whereas a complex value of the form
{a1, . . . , aj} is a set.

Remark 20.1.1
For instance, consider the sort
{A : dom, B : dom, C : {A : dom, E : {dom}}}
and the value
{ A : a, B : b, C : { A : c, E : {},
A : d, E : {}},
A : e, B : f, C : { } }
of that sort. This is yet again the value of Fig. 20.1. It is customary to omit dom and for instance write this sort {A, B, C : {A, E : {}}}.

As mentioned earlier, each complex value and each sort can be viewed as a finite tree. Observe the tree representation. Outgoing edges from tuple vertexes are labeled; set vertexes have a single child in a sort and an arbitrary (but finite) number of children in a value.

Finally note that (because of the empty set) a complex value may belong to more than one sort. For instance, the value of Fig. 20.1 is also of sort
{A : dom, B : dom, C : {A : dom, E : {{dom}}}}.

Relational algebra deals with sets of tuples. Similarly, complex value algebra deals with sets of complex values. This motivates the following definition of sorted relation (this
512
Complex Values
definition is frequently a source of confusion):
A (complex value) relation of sort τ is a finite set of values of sort τ .

We use the term relation for complex value relation. When we consider the classical relational model, we sometimes use the phrase flat relation to distinguish it from complex value relation. It should be clear that the flat relations that we have studied are special cases of complex value relations.

We must be careful in distinguishing the sort of a complex value relation and the sort of the relation viewed as one complex value. For example, a complex value relation of sort A, B, C is a set of tuples over attributes ABC. At the same time, the entire relation can be viewed as one complex value of sort {A, B, C}. There is no contradiction between these two ways of viewing a relation.

We now assume that the function sort (of Chapter 3) is from relname to the set of sorts. We also assume that for each sort, there is an infinite number of relations having that sort.

Note that the sort of a relation is not necessarily a tuple sort (it can be a set sort). Thus relations do not always have attributes at the top level. Such relations whose sort is a set are essentially unary relations without attribute names.

A (complex value) schema is a relation name; and a (complex value) database schema is a finite set of relation names. A (complex value) relation over relation name R is a finite set of values of sort sort(R)—that is, a finite subset of [sort (R)] . A (complex value database) instance I of a schema R is a function from R such that for each R in R, I(R) is a relation over R.

Example 20.1.2
To illustrate this definition, an instance J of {R1, R2, R3} where sort(R1) = sort(R3) = A : dom, B : {A1 : dom, A2 : dom} and sort(R2) = A : dom, A1 : dom, A2 : dom
is shown in Fig. 20.3.

Variations
To conclude this section, we briefly mention some variations of the complex value model.

The principal one that has been considered is the nested relation model. For nested relations, set and tuple constructors are required to alternate (i.e., set of sets and tuple with a tuple component are prohibited). For instance,
τ1 = A, B, C : {D, E : {F, G}} and
τ2 = A, B, C : {E : {F, G}}
are nested relation sorts whereas
20.1 Complex Value Databases
513
A
B
A
A 1 A 2
A
B
d 1 d 1 d 2
A 1 A 2
d
A
1
d 3 d 4
1
A 2
d 1
d
d
1
d 2
1
d 5 d 6
d
d 1 d 2
1
d
d
3
d 4
2
d 1 d 3
d 3 d 4
d 2 d 2 d 4
d 5 d 6
A 1 A 2
d
A 1 A 2
1
d 3 d 4
d
d
5
d 6
2
d 1 d 3
d 2 d 4
A 1 A 2
d 2
d 1 d 3
d 2 d 4
J( R 1)
J( R 2)
J( R 3)
Figure 20.3:
A database instance
τ3 = A, B, C : D, E : {F, G} and
τ4 = A, B, C : {{F, G}}
are not. (For τ3, observe two adjacent tuple constructors; there are two set constructors for τ4.)

The restriction imposed on the structure of nested relations is mostly cosmetic. A more fundamental constraint is imposed in so-called Verso-relations (V-relations).

As with nested relations, set and tuple constructors in V-relations are required to alternate. A relation is defined recursively to be a set of tuples, such that each component may itself be a relation but at least one of them must be atomic. The foregoing sort τ1 would be acceptable for a V-relation whereas sort τ2 would not because of the sort of tuples in the C component.

A further (more radical) assumption for V-relations is that for each set of tuples, the atomic attributes form a key. Observe that as a consequence, the cardinality of each set in a V-relation is bounded by a polynomial in the number of atomic elements occurring in the V-relation. This bound certainly does not apply for a relation of sort {dom} (a set of sets) or for a nested relation of sort
A : {B : dom},
which is also essentially a set of sets. The V-relations are therefore much more limited data structures. (See Exercise 20.1.) They can be viewed essentially as flat relational instances.

514
Complex Values
20.2
The Algebra
We now define a many-sorted algebra, denoted ALG cv (for c omplex values). Like relational algebra, ALG cv is a functional language based on a small set of operations. This section first presents a family of core operators of the algebra and then an extended family of operators that can be simulated by them. At the end of the section we introduce an important subset of ALG cv, denoted ALG cv−.

The Core of ALG cv
Let I, I1, I2, . . . be relations of sort τ, τ1, τ2, . . . respectively. It is important to keep in mind that a relation of sort τ is a set of values of sort τ .

Basic set operations: If τ1 = τ2, then I1 ∩ I2, I1 ∪ I2, I1 − I2, are relations of sort τ1, and their values are defined in the obvious manner.

Tuple operations: If I is a relation of sort τ = B1 : τ1, . . . , Bk : τk, then
• σγ (I ) is a relation of sort τ .

The selection condition γ is (with obvious restrictions on sorts) of the form Bi = d, Bi = Bj , Bi ∈ Bj or Bi = Bj .C, where d is a constant, and it is required in the last case that τj be a tuple sort with a C field. Then
σγ (I ) = {v | v ∈ I, v |= γ },
where |= is defined by
. . . , Bi : vi, . . . |= Bi = d if vi = d,
. . . , Bi : vi, . . . , Bj : vj, . . . |= Bi = Bj if vi = vj, and
. . . , Bi : vi, . . . , Bj : vj, . . . |= Bi ∈ Bj if vi ∈ vj.

. . . , Bi : vi, . . . , Bj : . . . , C : vj, . . ., . . . |= Bi = Bj.C if vi = vj.

• πB
(I ), l ≤ k is a relation of sort B
1,...,Bl
1 : τ1, . . . , Bl : τl with
πB
(I ) = { B
1,...,Bl
1 : v1, . . . , Bl : vl |
∃vl+1, . . . , vk(B1 : v1, . . . , Bk : vk ∈ I )}.

Constructive operations
• powerset(I ) is a relation of sort {τ } and
powerset(I ) = {v | v ⊆ I }.

• If A1, . . . , An are distinct attributes, tup _ create A (I
1...An
1, . . . , In) is of sort A1 :
τ1, . . . , An : τn, and
tup _ create A
(I
1,...,An
1, . . . , In) = {A1 : v1, . . . , An : vn | ∀i (vi ∈ Ii)}.

20.2 The Algebra
515
• set _ create(I ) is of sort {τ }, and set _ create(I ) = {I }.

Destructive operations
• If τ = {τ ′}, then set _ destroy(I ) is a relation of sort τ ′ and set _ destroy(I ) = ∪I = {w | ∃v ∈ I, w ∈ v}.

• If I is of sort A : τ ′, tup _ destroy(I ) is a relation of sort τ ′, and tup _ destroy(I ) = {v | A : v ∈ I }.

We are now prepared to define the (core of the) language ALG cv. Let R be a database schema. A query returns a set of values of the same sort. By analogy with relations, a query of sort τ returns a set of values of sort τ . ALG cv queries and their answers are defined as follows. There are two base cases:
Base values: For each relation name R in R, R is an algebraic query of sort sort(R). The answer to query R is I(R).

Constant values: For each element a, {a} is a (constant) algebraic query of sort dom. The answer to query {a} is simply {a}.

Other queries of ALG cv are obtained as follows. If q1, q2, . . . are queries, γ is a selection condition, and A1, . . . are attributes,
q1 ∩ q2,
q1 ∪ q2,
q1 − q2,
σγ (q1),
πA
(q
(q
1,...,Ak
1),
tup _ create A1,...,Ak 1, . . . , qk),
powerset(q1),
tup _ destroy(q1),
set _ destroy(q1),
set _ create(q1)
are queries if the appropriate restrictions on the sorts apply. (Note that because of the sorting constraints, tup _ destroy and set _ destroy cannot both be applicable to a given q1.) The sort of a query and its answer are defined in a straightforward manner.

To illustrate these definitions, we present two examples. We then consider other algebraic operators that are expressible in the algebra. In Section 20.4 we provide several more examples of algebraic queries.

Example 20.2.1
Consider the instance J of Fig. 20.3. Then one can find in Fig. 20.4
J1 = [σA=d (R
2
1)](J),
J2 = πB(J1),
J3 = tup _ destroy(J2),
J4 = set _ destroy(J3),
J5 = powerset(J4),
J6 = tup _ create C(J4).

Also observe that
J5 = [ powerset( set _ destroy( tup _ destroy(πB(σA=d (R
2
1))))](J).

516
Complex Values
A
B
B
A 1 A 2
A
d
1
A 2
A 1 A 2
1
d 3
d
d
2
d 4
2
d 1 d 3
d 1 d 3
d 2 d 4
d 2 d 4
J 1
J 2
J 3
A 1 A 2
C
A 1 A 2
d 1 d 3
A 1 A 2
d 2 d 4
d 1 d 3
A 1 A 2
d 1 d 3
C
A
A
1
A 2
1
A 2
d
d
2
d 4
2
d 4
A 1 A 2
d 1 d 3
d 2 d 4
J 4
J 5
J 6
Figure 20.4:
Algebraic operations
Example 20.2.2
In this example, we illustrate the destruction and construction of a complex value. Consider the relation
I = {A : a, B : {b, c}, C : A : d, B : {e, f }}.

Then
[(πA ◦ tup _ destroy)
∪ (πB ◦ tup _ destroy ◦ set _ destroy)
∪ (πC ◦ tup _ destroy ◦ πA ◦ tup _ destroy)
∪ (πC ◦ tup _ destroy ◦ πB ◦ tup _ destroy ◦ set _ destroy)](I )
= {a, b, c, d, e, f }.

20.2 The Algebra
517
We next reconstruct I from singleton sets:
I = tup _ create A,B,C({a}, set _ create({b} ∪ {c}), tup _ create A,B({d}, set _ create({e} ∪ {f }))).

Additional Algebraic Operations
There are infinite possibilities in the choice of algebraic operations for complex values.

We chose to incorporate in the core algebra only a few basic operations to simplify the formal presentation and the proof of the equivalence between the algebra and calculus.

However, making the core too reduced would complicate that proof. (For example, the operator set _ create can be expressed using the other operations but is convenient in the proof.) We now present several additional algebraic operations. It is important to note that all these operations can be expressed in complex value algebra. (In that sense, they can be viewed as macro operations.) Furthermore, all but the nest operator can be expressed without using the powerset operator.

We first generalize constant queries.

Complex constants: It is easy to see that the technique of Example 20.2.2 can be generalized. So instead of simply {a} for a atomic, we use as constant queries arbitrary complex value sets.

We also generalize relational operations.

Renaming: Renaming can be computed using the other operations, as illustrated in Section 20.4 (which presents examples of queries).

Cross-product: For i in [1,2], let Ii be a relation of sort τi = Bi

1 : τ i1, . . . , Bi : τ i
ji
ji
and let the attribute sets in τ1, τ2 be disjoint. Then I1 × I2 is the relation defined by sort(I1 × I2) = B1

1 : τ 1
1 , . . . , B1 :
:
j
τ 1 , B2
τ 2
1
j1
1 : τ 2
1 , . . . , B2
j2
j2
and
I1 × I2 = { B1
|
1 : x1
1 , . . . , B1 :
:
j
x1 , B2
x2
1
j1
1 : x2
1 , . . . , B2
j2
j2
Bi
∈
1 : xi1, . . . , Bi : xi
I
j
i for i ∈ [1, 2] }.

i
ji
It is easy to simulate cross-product using the operations of the algebra. This is also illustrated in Section 20.4.

Join: This can be defined in the natural manner and can be simulated using cross-product, renaming, and selection.

It should now be clear that complex value algebra subsumes relational algebra when applied to flat relations. We also have new set-oriented operations.

518
Complex Values
N-ary set _ create: We introduced tup _ create as an n-ary operation. We also allow n-ary set _ create with the meaning that
set _ create(I1, . . . , In) ≡ set _ create(I1) ∪ · · · ∪ set _ create(In).

Singleton: This operator transforms a set of values {a1, . . . , an} into a set {{a1}, . . . , {an}}
of singletons.

Nest, unnest: Less primitive interesting operations such as nest, unnest can be considered.

For example, for J of Fig. 20.3 we have
unnest B(J(R1)) = J(R2)
and
nest B=(A1A2)(J(R2)) = J(R3).

More formally, suppose that we have R and S with sorts
sort(R) = A1 : τ1, . . . , Ak : τk, B : {Ak+1 : τk+1, . . . , An : τn}
sort(S) = A1 : τ1, . . . , Ak : τk, Ak+1 : τk+1, . . . , An : τn.

Then for instances I of R and J of S, we have
unnest B(I ) = {A1 : x1, . . . , An : xn | ∃y
A1 : x1, . . . , Ak : xk, B : y ∈ I and Ak+1 : xk+1, . . . , An : xn ∈ y}
nest B=(Ak+1,...,An)(J ) = {A1 : x1, . . . , Ak : xk, B : y |
∅ "= y = {Ak+1 : xk+1, . . . , An : xn | A1 : x1, . . . , An : xn ∈ J }}.

Observe that
unnest B( nest B=(A1A2)(J(R2))) = J(R2).

nest B=(A1A2)( unnest B(J(R1))) "= J(R1).

This is indeed not an isolated phenomenon. Unnest is in general the right inverse of nest ( nest B=α ◦ unnest B is the identity), whereas unnest is in general not information preserving (one-to-one) and so has no right inverse (see Exercise 20.8).

Relational projection and selection were filtering operations in the sense that intuitively they scan a set and keep only certain elements, possibly modifying them in a uniform way. The filters in complex value algebra are more general. Of course, we shall allow Boolean expressions in selection conditions. More interestingly, we also allow set comparators in addition to ∈, such as ∋, ⊂, ⊆, ⊃, ⊇ and negations of these comparators (e.g.,
"∈). The inclusion comparator ⊆ plays a special role in the calculus. We will see in Section 20.4 how to simulate selection with ⊆.

Selection is a predicative filter in the sense that a predicate allows us to select some elements, leaving them unchanged. Other filters, such as projection, are map filters. They transform the elements. Clearly, one can combine both aspects and furthermore allow more complicated selection conditions or restructuring specifications. For instance, suppose I is
20.3 The Calculus
519
a set of tuples of sort
A : dom, B : C : E : {dom}, E′ : dom, C′ : {dom}.

We could use an operation that first filters all the values matching the pattern A : x, B : C : E : y, E′ : z, C′ : {x};
and then transforms them into
A : (y ∪ {x}), B : y, C : z.

This style of operations is standard in functional languages (e.g., apply-to-all in fp).

Remark 20.2.3
As mentioned earlier, all of the operations just introduced are expressible in ALG cv. We might also consider an operation to iterate over the elements of a set in some order. Such an operation can be found in several systems. As we shall see in Section 20.6, iteration is essentially expressible within ALG cv. On the other hand, an iteration that depends on a specific ordering of the underlying domain of elements cannot be simulated using ALG cv unless the ordering is presented as part of the input.

In the following sections, we (informally) call extended algebra the algebra consisting of the operations of ALG cv and allowing complex constants, renaming, cross-product, join, n-ary set _ create, singleton, nest, and unnest.

An important subset of ALG cv, denoted ALG cv−, is formed from the core operators of ALG cv by removing the powerset operator and adding the nest operator. As will be seen in Section 20.7, although the nest operator has the ability to construct sets, it is much weaker than powerset. When restricted to nested relations, the language ALG cv− is usually called nested relation algebra.

20.3
The Calculus
The calculus is modeled after a standard, first-order, many-sorted calculus. However, as we shall see, calculus variables may denote sets, so the calculus will permit quantification over sets (something normally considered to be a second-order feature). For complex value calculus, the separation between first and second order (and higher order as well) is somewhat blurred. As with the algebra, we first present a core calculus and then extend it. The issues of domain independence and safety are also addressed.

For each sort, we assume the existence of a countably infinite set of variables of that sort. A variable is atomic if it ranges over the sort dom. Let R be a schema. A term is an atomic element, a variable, or an expression x.A, where x is a tuple variable and A is an attribute of x. We do not consider (yet) fancier terms. A positive literal is an expression of the form
520
Complex Values
R(t ),
t = t ′,
t ∈ t ′,
or
t ⊆ t ′,
where R ∈ R, t, t′ are terms and the appropriate sort restrictions apply.1 Formulas are defined from atomic formulas using the standard connectives and quantifiers: ∧, ∨, ¬, ∀, ∃.

A query is an expression {x | ϕ}, where formula ϕ has exactly one free variable (i.e. x). We sometimes denote it by ϕ(x). The calculus is denoted CALC cv.

The following example illustrates this calculus.

Example 20.3.1
Consider the schema and the instance of Fig. 20.3. We can verify that J(R2) is the answer on instance J to the query
{x | ∃y, z, z′, u, v, w (R1(y) ∧ y.A = u ∧ y.B = z
∧ z′ ∈ z ∧ z′.A1 = v ∧ z′.A2 = w
∧ x.A = u ∧ x.A1 = v ∧ x.A2 = w) },
where the sorts of the variables are as follows:
sort(x) = A, A1, A2,
sort(y) = A, B : {A1, A2},
sort(u) = sort(v) = sort(w) = dom,
sort(z′) = A1, A2,
sort(z) = {A1, A2}.

We could also have used an unsorted alphabet of variables and sorted them inside the formula, as in
{x : A, A1, A2 | ∃y : A, B : {A1, A2},
z : {A1, A2}, z′ : A1, A2,
u : dom, v : dom, w : dom
(R1(y) ∧ y.A = u ∧ y.B = z
∧ z′ ∈ z ∧ z′.A1 = v ∧ z′.A2 = w
∧ x.A = u ∧ x.A1 = v ∧ x.A2 = w) }.

The key difference with relational calculus is the presence of the predicates ∈ and ⊆, which are interpreted as the standard set membership and inclusion. Another difference (of a more cosmetic nature) is that we allow only one free variable in relation atoms and in query formulas. This comes from the stronger sorts: A variable may represent an n-tuple.

The answer to a query q on an instance I, denoted q(I), is defined as for the relational model. As in the relational case, we may define various interpretations, depending on the underlying domain of base values used. As with relational calculus, the basis for defining the semantics is the notion
I satisfies ϕ for ν relative to d.

1 Strictly speaking, the symbols =, ⊆ and ∈ are also many sorted.

20.3 The Calculus
521
[Recall that ν is a valuation of the free variables of ϕ and d is an arbitrary set of elements containing adom(ϕ, I).]
Consider the definition of this notion in Section 5.3. Cases (a) through (g) remain valid for the complex object calculus. We have to consider two supplementary cases. Recall that for equality, we had case (b):
(b)
I |=d ϕ[ν] if ϕ = (s = s′) and ν(s) = ν(s′).

In the same spirit, we add
(h-1)
I |=d ϕ[ν] if ϕ = (s ∈ s′) and ν(s) ∈ ν(s′)
(h-2)
I |=d ϕ[ν] if ϕ = (s ⊆ s′) and ν(s) ⊆ ν(s′).

This formally states that ∈ is interpreted as set membership and ⊆ as set inclusion (in the same sense that as = is interpreted as equality).

The issues surrounding domain independence for relational calculus also arise with CALC cv. We develop a syntactic condition ensuring domain independence, but we also occasionally use an active domain interpretation.

Extensions
As in the case of the algebra, we now consider extensions of the calculus that can be simulated by the core syntax just given.

The standard abbreviations used for relational calculus, such as the logical connectives
→, ←, ↔, can be incorporated into CALC cv. Using these connectives, it is easy to see the nonminimality of the calculus: Each literal x ⊆ y can be replaced by ∀z(z ∈ x → z ∈ y), where z is a fresh variable.

Arity
In the core calculus, only relation atoms of the form R(t) are permitted. Suppose that the sort of R is A1 : τ1, . . . , An : τn for some n. Then R(u1, . . . , un) is a shorthand for
∃y(R(y) ∧ y.A1 = u1 ∧ · · · ∧ y.An = un),
where y is a new variable. In particular, if R0 is a relation of sort (n = 0), observe that the only value of that sort is the empty tuple. Thus a variable y of that sort has only one possible value, namely . Thus for such y, we can use the following expression: R0( )
for
∃y(R0(y)).

Constructed Terms
Next we allow constructed terms in the calculus such as
{x, b},
x.A.C,
B1 : a, B2 : y.

More formally, if t1, . . . , tk are terms and B1, . . . , Bk are distinct attributes, then B1 : t1, . . . , Bk : tk is a term. Furthermore, if the ti are of the same sort, {t1, . . . , tk} is a term;
522
Complex Values
and if t1 is a tuple term with attribute C, then t1.C is a term. The sorts of terms are defined in the obvious way. Note that a term may have several sorts because of the empty set. (We ignore this issue here.)

The use of constructed terms can be viewed as syntactic sugaring. For instance, suppose that the term {a, y} occurs in a formula ψ. Then ψ is equivalent to
∃x(ψ′ ∧ ∀z(z ∈ x ↔ (z = a ∨ z = y))),
where ψ′ is obtained from ψ by replacing the term {a, y} by x (a fresh variable).

Complex Terms
We can also view relations as terms. For instance, if R is a relation of sort A, B, then R can be used in the language as a term of sort {A, B}. We may then consider literals such as x ∈ R, which is equivalent to R(x); or more complex ones such as S ∈ T , which essentially means
∃y(T (y) ∧ ∀x(x ∈ y ↔ S(x))).

The previous extension is based on the fact that a relation (in our context) can be viewed as a complex value. This is again due to the stronger sort system. Now the answer to a query q is also a complex value. This suggests considering the use of queries as terms of the language. We consider this now: A query q ≡ {y | ψ(y)} is a legal term that can be used in the calculus like any other term. More generally, we allow terms of the form
{y | ψ(y, y1, . . . , yn)},
where the free variables of ψ are y, y1, . . . , yn. Intuitively, we obtain queries by providing bindings for y1, . . . , yn. We will call such an expression a parameterized query and denote it q(y1, . . . , yn) (where y1, . . . , yn are the parameters).

For instance, suppose that a formula liked(x, y) computes the films y that person x liked; and another one saw(x, y) computes those that x has seen. The set of persons who liked all the films that they saw is given by
{ x | {y | liked(x, y)} ⊆ {y | saw(x, y)} }.

The following form of literals will play a particular role when we study safety for this calculus:
x = {y | ψ (y, y1, . . . , yn)},
x′ ∈ {y | ψ (y, y1, . . . , yn)}, and
x′′ ⊆ {y | ψ (y, y1, . . . , yn)},
where y is a free variable of ψ. Like the previous extensions, the parameterized queries can be viewed simply as syntactic sugaring. For instance, the three last formulas are, respectively, equivalent to
20.4 Examples
523
∀y(y ∈ x ↔ ψ),
∃y(x′ = y ∧ ψ), and
∀y(y ∈ x′′ → ψ).

In the following sections, we (informally) call extended calculus the calculus consisting of CALC cv extended with the abbreviations described earlier (such as constructed and complex terms and, notably, parameterized queries).

20.4
Examples
We illustrate the previous two sections with a series of examples. The queries in the examples apply to schema {R, S} with
sort(R) = A : dom, A′ : dom,
sort(S) = B : dom, B′ : {dom}.

For each query, we give an algebraic and a calculus expression.

Example 20.4.1
The union of R and a set of two constant tuples is given by
{r | R(r) ∨ r = A : 3, A′ : 5 ∨ r = A : 0, A′ : 0}
or
R ∪ {A : 3, A′ : 5, A : 0, A′ : 0}.

Example 20.4.2
The selection of the tuples from S, where the first component is a
member of the second component, is obtained with
{s | S(s) ∧ s.B ∈ s.B′} or σB∈B′(S).

Example 20.4.3
The (classical) cross-product of R and S is the result of
{t | ∃r, s(R(r) ∧ S(s) ∧ t = A : r.A, A′ : r.A′, B : s.B, B′ : s.B′)}
or
π AA′ BB′(σA=A′′.A(σA′=A′′.A′(σB=B′′.B(σB′=B′′.B′(q))))), where q is
524
Complex Values
tup _ createAA′ BB′A′′B′′( tup _ destroy(πA(R)), tup _ destroy(πA′(R)),
tup _ destroy(πB(S)),
tup _ destroy(πB′(S)), R, S).

Example 20.4.4
The join of R and S on A = B. This query is the composition of the
cross-product of Example 20.4.3, with a selection. In Example 20.4.3, let the formula describing the cross-product be ϕ3 and let (R × S) be the algebraic expression. Then the (A = B) join of R and S is expressed by
{t | ϕ3(t) ∧ t.A = t.B} or σA=B(R × S).

Example 20.4.5
The renaming of the attributes of R to A1, A2 is obtained in the calculus by
{t | ∃r(R(r) ∧ t.A1 = r.A ∧ t.A2 = r.A′)}
with t of sort A1 : dom, A2 : dom. In the algebra, it is given by πA
(σ
(σ
( tup _ create
1A2
A0.A=A1
A0.A′=A2
A0A1A2
(R, tup _ destroy(πA(R)), tup _ destroy(πA′(R)))))).

Example 20.4.6
Flattening S means producing a set of flat tuples, each of which contains the first component of a tuple of S and one of the elements of the second component.

This is the unnest operation unnest B′(·) in the extended algebra, or in the calculus
{t | ∃s(S(s) ∧ t.B = s.B ∧ t.C ∈ s.B′)},
where t is of sort B, C. In the core algebra, this is slightly more complicated. We first obtain the set of values occurring in the B′ sets using
E1 = tup _ create C( set _ destroy( tup _ destroy(πB′(S)))).

We can next compute (E1 × S) (using the same technique as in Example 20.4.3). Then the desired query is given by
π BC(σC∈B′(E1 × S)).

Flattening can be extended to sorts with arbitrary nesting depth.

Example 20.4.7
The next example is a selection using ⊆. Consider a relation T of sort C : {dom}, C′ : {dom}. We want to express the query
20.4 Examples
525
{t | T (t) ∧ t.C ⊆ t.C′}
in the algebra. We do this in stages:
F1 = σC′′∈C(T × tup _ create C′′( set _ destroy( tup _ destroy(πC(T ))))), F2 = σC′′∈C′(F1),
F3 = F1 − F2,
F4 = T − πCC′(F3).

Observe that
1. A tuple C : U, C′ : V , C′′ : u is in F1 if C : U, C′ : V is in T and u is in U .

2. A tuple C : U, C′ : V , C′′ : u is in F2 if C : U, C′ : V is in T and u is in U and V .

3. A tuple C : U, C′ : V , C′′ : u is in F3 if C : U, C′ : V is in T and u is in U − V .

4. A tuple C : U, C′ : V is in F4 if it is in T and there is no u in U − V (i.e., U ⊆ V ).

Example 20.4.8
This example illustrates the use of nesting and of sets. Consider the algebraic query
nest C=(A) ◦ nest C′=(A′) ◦ σC=C′ ◦ unnest C ◦ unnest C′(R).

It is expressed in the calculus by
{x, y | ∃u(x ∈ u ∧ y ∈ u
∧ u = {x′ | R(x′, y)}
∧ u = {y′ | {x′ | R(x′, y′)} = u})}.

A consequence of Theorem 20.7.2 is that this query is expressible in relational calculus or algebra. It is a nontrivial exercise to obtain a relational query for it. (See Exercise 20.24.) Example 20.4.9
Our last example highlights an important difference between the flat relational calculus and CALC cv. As shown in Proposition 17.2.3, the flat calculus cannot express the transitive closure of a binary relation. In contrast, the following CALC cv query does:
{y | ∀x( closed(x) ∧ contains _R(x) → y ∈ x)},
where
• closed(x) ≡
∀u, v, w(A : u, A′ : v ∈ x ∧ A : v, A′ : w ∈ x → A : u, A′ : w ∈ x);
526
Complex Values
• contains _R(x) ≡ ∀z(R(z) → z ∈ x);
• sort(x) = { sort(R)}, sort(y) = sort(z) = sort(R); and sort(u) = sort(v) = sort(w) = dom.

Intuitively, the formula specifies the set of pairs y such that y belongs to each binary relation x containing R and transitively closed. This construction will be revisited in Section 20.6.

20.5
Equivalence Theorems
This section presents three results that compare the complex value algebra and calculus.

First we establish the equivalence of the algebra and the domain-independent calculus.

Next we develop a syntactic safeness condition for the calculus and show that it does not reduce expressive power. Finally we develop a natural syntactic condition on CALC cv that yields a subset equivalent to ALG cv−.

Our first result is as follows:
Theorem 20.5.1
The algebra and the domain independent calculus for complex values
are equivalent.

In the sketch of the proof, we present a simulation of the core algebra by the extended calculus and the analogous simulation in the opposite direction. An important component of this proof—namely, that the extended algebra (calculus) is no stronger than the core algebra (calculus)—is left for the reader (see Exercises 20.6, 20.7, 20.8, 20.10, and 20.11).

From Algebra to Calculus
We now show that for each algebra query, there is a domain-independent calculus query equivalent to it.

Let q be a named algebra query. We construct a domain-independent query {x | ϕq}
equivalent to q. The formula ϕq is constructed by induction on subexpressions of q. For a subexpression E of q, we define ϕE as follows:
(a) E is R for some R ∈ R: ϕE is R(x).

(b) E is {a}: ϕE is x = a.

(c) E is σγ (E1): ϕE is ϕE (x) ∧ Ŵ, where Ŵ is
1
x.Ai = x.Aj if γ ≡ Ai = Aj ;
x.Ai = a if γ ≡ Ai = a;
x.Ai ∈ x.Aj if γ ≡ Ai ∈ Aj ;
x.Ai = x.Aj .C if γ ≡ Ai = Aj .C.

(d) E is πA
(E
i ,...,A
1): ϕE is
1
ik
∃y(x = Ai : y.A , . . . , A : y.A ∧ ϕ (y)).

1
i1
ik
ik
E1
20.5 Equivalence Theorems
527
(e) For the basic set operations, we have
ϕE
(x) = ϕ (x) ∧ ϕ
(x),
1∩E2
E1
E2
ϕE
(x) = ϕ (x) ∨ ϕ
(x),
1∪E2
E1
E2
ϕE
(x) = ϕ (x) ∧ ¬ϕ
(x).

1−E2
E1
E2
(f) E is powerset(E1): ϕE is x ⊆ {y | ϕE (y)}.

1
(g) E is set _ destroy(E1): ϕE is ∃y(x ∈ y ∧ ϕE (y)).

1
(h) E is tup _ destroy(E1): ϕE is ∃y(A : x = y ∧ ϕE (y)), where A is the name of 1
the field (of y).

(i) E is tup _ create A
(E
1,...,An
1, . . . , En): ϕE is
∃y1, . . . , yn(x = A1 : y1, . . . , An : yn ∧ ϕE (y
(y
1
1) ∧ · · · ∧ ϕEn
n)).

(j) E is set _ create(E1): x = {y | ϕE (y)}.

1
We leave the verification of this construction to the reader (see Exercise 20.13). The domain independence of the obtained calculus query follows from the fact that algebra queries are domain independent.

From Calculus to Algebra
We now show that for each domain-independent query, there is a named algebra query equivalent to it.

Let q = {x | ϕ} be a domain-independent query over R. As in the flat relational case, we assume without loss of generality that associated with each variable x occurring in q (and also variables used in the following proof) is a unique, distinct attribute Ax in att. We use the active domain interpretation for the query, denoted as before with a subscript adom.

The crux of the proof is to construct, for each subformula ψ of ϕ, an algebra formula Eψ that has the property that for each input I,
Eψ(I) = {y | ∃x1, . . . , xn(y = Ax : x
: x
1
1, . . . , Axn
n ∧ ψ (x1, . . . , xn))} adom(I),
where x1, . . . , xn is a listing of free(ψ).

This construction is accomplished in three stages.

Computing the Active Domain
The first step is to construct an algebra query E adom
having sort dom such that on input instance I, E adom(I) = adom(q, I). The construction of E adom is slightly more intricate than the similar construction for the relational case. We prove by induction that for each sort τ , there exists an algebra operation Fτ that maps a set I of values of sort τ to adom(I ). This induction was not necessary in the flat case because the base relations had fixed depth. For the base case (i.e., τ = dom), it suffices to use for Fτ an identity operation (e.g., tup _ create A ◦ tup _ destroy). For the induction, the following cases occur:
528
Complex Values
1. τ is A1 : τ1, . . . , An : τn for n ≥ 2. Then Fτ is
FA
) ∪ · · · ∪ F
).

1:τ1(πA1
An:τn(πAn
2. τ is A1 : τ1. Then Fτ is Fτ ( tup _ destroy).

1
3. τ is {τ1}. Then Fτ is Fτ ( set _ destroy).

1
Now consider the schema R. Then for each R in R, F sort(R) maps a relation I over R to adom(I ). Thus adom(q, I) can be computed with the query E adom = F sort(R1)(R1) ∪ · · · ∪ F sort(Rm)(Rm) ∪ {a1} ∪ · · · ∪ {ap}, where R1, . . . , Rm is the list of relations in R and a1, . . . , ap is the list of elements occurring in q.

Constructing Complex Values
In the second stage, we prove by induction that for each
sort τ , there exists an algebra query Gτ that constructs the set of values I of sort τ such that adom(I ) ⊆ adom(q, I). For τ = dom, we can use E adom. For the induction, two cases occur:
1. τ is A1 : τ1, . . . , An : τn. Then Gτ is tup _ create A (G , . . . , G ).

1,...,An
τ1
τn
2. τ is {τ1}. Then Gτ is powerset(Gτ ).

1
Last Stage
We now describe the last stage, an inductive construction of the queries Eψ
for subformulas ψ of ϕ. We assume without loss of generality that the logical connectives
∨ and ∀ do not occur in ϕ. The proof is similar to the analogous proof for the flat case.

We also assume that relation atoms in ϕ do not contain constants or repeated variables. We only present the new case (the standard cases are left as Exercise 20.13). Let ψ be x ∈ y.

Suppose that x is of sort τ , so y is of sort {τ }. The set of values of sort τ (or {τ }) within the active domain is returned by query Gτ , or G{τ}. The query
σA
( tup _ create
(G
x ∈Ay
Ax,Ay
τ , G{τ }))
returns the desired result.

Observe that with this construction, Eϕ returns a set of tuples with a single attribute Ax. The query q is equivalent to tup _ destroy(Eϕ).

As we did for the relational model, we can define a variety of syntactic restrictions of the calculus that yield domain-independent queries. We consider such restrictions next.

Safe Queries
We now turn to the development of syntactic conditions, called safe range, that ensure domain independence. These conditions are reminiscent of those presented for relational calculus in Chapter 5. As we shall see, a variant of safe range, called strongly safe range, will yield a subset of CALC cv, denoted CALC cv−, that is equivalent to ALG cv−.

20.5 Equivalence Theorems
529
We could define safe range on the core calculus. However, such a definition would be cumbersome. A much more elegant definition can be given using the extended calculus.

In particular, we consider here the calculus augmented with (1) constructed terms and (2) parameterized queries.

Recall that intuitively, if a formula is safe range, then each variable is bounded, in the sense that it is restricted by the formula to lie within the active domain of the query or the input. We now define the notions of safe formulas and safe terms. To give these definitions, we define the set of safe-range variables of a formula using the following procedure, which returns either the symbol ⊥ (which indicates that some quantified variable is not bounded) or the set of free variables that are bounded. In this discussion, we consider only formulas in which universal quantifiers do not occur.

In the following procedure, if several rules are applicable, the one returning the largest set of safe-range variables (which always exists) is chosen.

procedure safe-range (sr)
input: a calculus formula ϕ
output: a subset of the free variables of ϕ or ⊥. (In the following, for each Z, ⊥ ∪ Z =
⊥ ∩ Z = ⊥ − Z = Z − ⊥ = ⊥.)

begin
( pred is a predicate in {=, ∈, ⊆})
if for some parameterized query {x | ψ} occurring as a term in ϕ, x "∈ sr(ψ) then return ⊥
case ϕ of
R(t )
: sr(ϕ) = free(t);
(t pred t ′ ∧ ψ )
: if ψ is safe and free(t′) ⊆ free(ψ)
then sr(ϕ) = free(t) ∪ free(ψ);
t pred t ′
: if free(t′) = sr(t′) then sr(ϕ) = free(t′) ∪ free(t); else sr(ϕ) = ∅;
ϕ1 ∧ ϕ2
: sr(ϕ) = sr(ϕ1) ∪ sr(ϕ2);
ϕ1 ∨ ϕ2
: sr(ϕ) = sr(ϕ1) ∩ sr(ϕ2);
¬ϕ1
: sr(ϕ) = ∅;
∃xϕ1
: if x ∈ sr(ϕ1)
then sr(ϕ) = sr(ϕ1) − {x}
else return ⊥
end;
We say that a formula ϕ is safe if sr(ϕ) = free(ϕ); and a query q is safe if its associated formula is safe.

It is important to understand how new sets are created in a safe manner. The next example illustrates two essential techniques for such creation.

530
Complex Values
Example 20.5.2
Let R be a relation of sort A, B. The powerset of R can be obtained in a safe manner with the query
{x | x ⊆ {y | R(y)}}.

For {y | R(y)} is clearly a safe query (by the first case). Now letting t ≡ x, t′ ≡ {y | R(y)}, the formula is safe (by the third case).

Now consider the nesting of the B column of R. It is achieved by the following query:
{x | x = z, {y | R(z, y)} ∧ ∃y′(R(z, y′))}.

Let t ≡ x, t′ ≡ z, {y | R(z, y)} and ψ ≡ ∃y′(R(z, y′)). First note that sr(R(z, y)) contains y, so the parameterized query {y | R(z, y)} can be used safely. Next the formula ψ is safe. Finally the only free variable in t′ is z, which is also free in ψ. Thus x is safe range (by the second case) and the query is safe.

As detailed in Section 20.7, the complex value algebra and calculus can express mappings with complexity corresponding to arbitrarily many nestings of exponentiation.

In contrast, as discussed in that section, the nested relation algebra ALG cv−, which uses the nest operator but not powerset, has complexity in ptime. Interestingly, there is a minor variation of the safe-range condition that yields a subset of the calculus equivalent to ALG cv−. Specifically, a formula is strongly safe range if it is safe range and the inclusion predicate does not occur in it. In the previous example, the nesting is strongly safe range whereas powerset is not.

We now have the following:
Theorem 20.5.3
(a) The safe-range calculus, the domain-independent calculus, and ALG cv coincide.

(b) The strongly safe-range calculus and ALG cv− coincide.

Crux
Consider (a). By inspection of the construction in the proof that ALG cv ⊑ CALC cv, each algebra query is equivalent to a safe-range calculus query. Clearly, each safe-range calculus query is a domain-independent calculus query. We have already shown that each domain-independent calculus query is an algebra query.

Now consider (b). Observe that in the proof that ALG cv ⊑ CALC cv, ⊆ is used only for powerset. Thus each query in ALG cv− is a strongly safe-range query. Now consider a strongly safe-range query; we construct an equivalent algebra query. We cannot use the construction from the proof of the equivalence theorem, because powerset is crucial for constructing complex domains. However, we can show that this can be avoided using the ranges of variables. (See Exercise 20.16.) More precisely, the brute force construction of the domain of variables using powerset is replaced by a careful construction based on the strongly safe-range restriction. The remainder of the proof stays unchanged.

20.6 Fixpoint and Deduction
531
Because of part (b) of the previous result, we denote the strongly safe-range calculus by CALC cv−.

20.6
Fixpoint and Deduction
Example 20.4.9 suggests that the complex value algebra and calculus can simulate iteration. In this section, we examine iteration in the spirit of both fixpoint queries and datalog.

In both cases, they do not increase the expressive power of the algebra or calculus. However, they allow us to express certain queries more efficiently.

Fixpoint for Complex Values
Languages with fixpoint semantics were considered in the context of the relational model to overcome limitations of relational algebra and calculus. In particular, we observed that transitive closure cannot be computed in relational calculus. However, as shown by Example 20.4.9, transitive closure can be expressed in the complex value algebra and calculus. Although transitive closure can be expressed in that manner, the use of powerset seems unnecessarily expensive. More precisely, it can be shown that any query in the complex value algebra and calculus that expresses transitive closure uses exponential space (assuming the straightforward evaluation of the query). In other words, the blowup caused by the powerset operator cannot be avoided. On the other hand, a fixpoint construct allows us to express transitive closure in polynomial space (and time). It is thus natural to develop fixpoint extensions of the calculus and algebra.

We can provide inflationary and noninflationary extensions of the calculus with recursion. As in the relational case, an inflationary fixpoint operator µ+ allows the iteration of a T
CALC cv formula ϕ(T ) up to a fixpoint. This essentially permits the inductive definition of relations, using calculus formulas. The calculus CALC cv augmented with the inflationary fixpoint operator is defined similarly to the flat case (Chapter 14) and yields CALC cv + µ+.

We only consider the inflationary fixpoint operator. (Exercise 20.19 explores the noninflationary version.)

Theorem 20.6.1
CALC cv + µ+ is equivalent to ALG cv and CALC cv.

The proof of this theorem is left for Exercise 20.18. It involves simulating a fixpoint in a manner similar to Example 20.4.9.

Before leaving the fixpoint extension, we show how powerset can be computed by iterating a ALG cv− formula to a fixpoint. (We will see later that powerset cannot be computed in ALG cv− alone.)

Example 20.6.2
Consider a relation R of sort dom (i.e., a set of atomic elements). The powerset of R is computed by {x | µT (ϕ(T ))(x)}, where T is of sort {dom} and ϕ(T )(y) ≡ [y = ∅ ∨ ∃x′, y′(R(x′) ∧ T (y′) ∧ y = y′ ∪ {x′}.]
532
Complex Values
This formula is in fact equivalent to a query in ALG cv−. (See Exercise 20.15.) For example, suppose that R contains {2, 3, 4}. The iteration of ϕ yields
J0
= ∅
J1
= ϕ(∅)
= {∅}
J2
= ϕ(J1) = J1 ∪ {{2}, {3}, {4}}
J3
= ϕ(J2) = J2 ∪ {{2, 3}, {2, 4}, {3, 4}}
J4
= ϕ(J3) = J3 ∪ {{2, 3, 4}},
and J4 is a fixpoint and coincides with powerset({2, 3, 4}).

Datalog for Complex Values
We now briefly consider an extension of datalog to incorporate complex values. The basic result is that the extension is equivalent to the complex value algebra and calculus. We also consider a special grouping construct, which can be used for set construction in this context.

In the datalog extension considered here, the predicates ⊆ and ∈ are permitted. A rule is safe range if each variable that appears in the head also appears in the body, and the body is safe (i.e., the conjunction of the literals of the body is a safe formula). We assume henceforth that rules are safe. Stratified negation will be used. The language is illustrated in the following example.

Example 20.6.3
The input is a relation R of sort A, B : {C, C′}. Consider the query defining an idb relation T , which contains the tuples of R, with the B-component replaced by its transitive closure. Let us assume that we have a ternary relation ins, where ins(w, y, z) is interpreted as “z is obtained by inserting w into y.” We show later how to define this relation in the language. The program consists of the following rules: (r1)
S(x, y) ← R(x, y)
(r2)
S(x, z) ← S(x, y), u ∈ y, v ∈ y, u.C′ = v.C, ins(u.C, v.C′, y, z) S′(x, z) ← S(x, z), S(x, z′), z ⊆ z′, z "= z′
(r3)
(r4)
T (x, z) ← S(x, z), ¬S′(x, z).

The first two rules compute in S pairs corresponding to pairs from R, such that the second component of a pair contains the corresponding component from the pair in R and possibly additional elements derived by transitivity. Obviously, for each pair x, y of R, there is a pair x, z in S, such that z is the transitive closure of y, but there are other tuples as well.

To answer the query, we need to select for each x the unique tuple x, z of S, where z is maximal.2 The third rule puts into S′ tuples x, z such that z is not maximal for that x. The last rule then selects those that are maximal, using negation.

2 We assume, for simplicity, that the first column of R is a key. It is easy to change the rules for the case when this does not hold.

20.6 Fixpoint and Deduction
533
We now show the program that defines ins for some given sort τ (the variables are of sort {τ } except for w, which is of sort τ ):
super(w, y, z)
← w ∈ z, y ⊆ z
not- min- super(w, y, z) ← super(w, y, z), super(w, y, z′), z′ ⊆ z, z′ "= z ins(w, y, z)
← super(w, y, z), ¬ not- min- super(w, y, z) Note that the program is sort specific only through its dependence on the sorts of the variables. The same program computes ins for another sort τ ′, if we assume that the sort of w is τ ′ and that of the other variables is {τ ′}. Note also that the preceding program is not safe. To make it safe, we would have to use derived relations to range restrict the various variables.

We note that although we used ⊆ in the example as a built-in predicate, it can be expressed using membership and stratified negation.

The proof of the next result is omitted but can be reconstructed reasonably easily using the technique of Example 20.6.3.

Theorem 20.6.4
A query is expressible in datalogcv with stratified negation if and only if it is expressible in CALC cv.

The preceding language relies heavily on negation to specify the new sets. We could consider more set-oriented constructs. An example is the grouping construct, which is closely related to the algebraic nest operation. For instance, in the language LDL, the rule: S(x, y) ← R(x, y)
groups in S, for each x, all the y’s related to it in R (i.e., S is the result of the nesting of R
on the second coordinate).

The grouping construct can be used to simulate negation. Consider a query q whose input consists of two unary relations R, S not containing some particular element a and that computes R − S. Query q can be answered by the following LDL program: Temp(x, a) ← R(x)
Temp(x, x) ← S(x)
T (x, y) ← Temp(x, y)
Res(x)
← T (x, {a})
Note that for an x in R − S, we derive T (x, {a}); but for x in R ∩ S, we derive T (x, {x, a}) "= T (x, {a}) because a is not in R.

From the previous example, it is clear that programs with grouping need not be monotone. This gives rise to semantic problems similar to those of negation. One possiblity, adopted in LDL, is to define the semantics of programs with grouping analogously to stratification for negation.

534
Complex Values
20.7
Expressive Power and Complexity
This section presents two results. First the expressive power and complexity of ALG cv/
CALC cv is established—it is the family of queries computable in hyperexponential time.

Second, we consider the expressive power of ALG cv−/CALC cv− (i.e., in algebraic terms the expressive power of permitting the nest operator, but not powerset). Surprisingly, we show that the nest operator can be eliminated from ALG cv− queries with flat input/ouput.

Complex Value Languages and Elementary Queries
We now characterize the queries in ALG cv in terms of the set of computable queries in a certain complexity class. First the notion of computable query is extended to the complex value model in the straightforward manner. The complexity class of interest is the class of elementary queries, defined next.

The hyperexponential functions hyp i for i in N are defined by 1. hyp 0(m) = m; and
2. hyp i+1(m) = 2 hyp i(m) for i ≥ 0.

A query is an elementary query if it is a computable query and has hyperexponential time data complexity3 w.r.t. the database size. By database size we mean the amount of space it takes to write the content of the database using some natural encoding. Note that, for complex value databases, size can be very different from cardinality. For example, the database could consist of a single but very large complex value.

It turns out that a query is in ALG cv/CALC cv iff it is an elementary query.

Theorem 20.7.1
A query is in ALG cv/CALC cv iff it is an elementary query.

Crux
It is trivial to see that each query in ALG cv/CALC cv is elementary. All operations can be evaluated in polynomial time in the size of their arguments except for powerset, which takes exponential time.

Conversely, let q be of complexity hyp n. We show how to compute it in CALC cv.

Suppose first that an enumeration of adom(I) is provided in some binary relation succ.

(We explain later how this is done.) We prove that q can then be computed in CALC cv+µ+.

Let X0 = adom(I ) and for each i, Xi = powerset(Xi−1). Observe that for each Xi, we can provide an enumeration as follows: First succ provides the enumeration for X0; and for each i, we define V <i U for U, V in Xi if there exists x in U − V such that each element larger than x (under <i−1) is in both or neither of U, V . Clearly, there exists a query in CALC cv+µ+ that constructs Xn and a binary relation representing <n.

Now we view each element of Xn as an atomic element. The input instance together with Xn and the enumeration can be seen as an ordered database with size the order of hyp n. Query q is now polynomial in this new (much larger) instance. Finally we can easily 3 We are concerned exclusively with the data complexity. Observe that when considering the union of hyperexponential complexities, time and space coincide.

20.7 Expressive Power and Complexity
535
extend to complex values the result from the flat case that CALC+µ+ can express qptime on ordered databases (Theorem 17.4.2). Thus CALC cv+µ+ can also express all qptime queries on ordered complex value databases, so q can be computed in CALC cv+µ+ using
<n on Xn. By Theorem 20.6.1, CALC cv+µ+ is equivalent to CALC cv, so there exists a CALC cv query ϕ computing q if an (arbitrary) enumeration of the active domain is given in some binary relation succ.

To conclude the proof, it remains to remove the restriction on the existence of an enumeration of the active domain. Let ϕ′ be the formula obtained from ϕ by replacing 1. succ by some fresh variable y (the sort of y is set of pairs); and 2. each literal succ(t, t′) by t, t′ ∈ y.

Then q can be computed by
∃y(ϕ′ ∧ ψ).

where ψ is the CALC cv formula stating that y is the representation in a binary relation of an enumeration of the active domain. (Observe that it is easy to state in CALC cv that the content of a binary relation is an enumeration.)

On the Power of the nest Operator
The set-height of a complex sort is the maximum number of set constructors in any branch of the sort. We can exhibit hierarchies of classes of queries in CALC cv based on the set-height of the sorts of variables used in the query. For example, consider all queries that take as input a flat relational schema and produce as output a flat relation. Then for each n > 0, the family of CALC cv queries using variables that have sorts with set-height ≤ n is strictly weaker than the family of CALC cv queries using variables that have sorts with set-height ≤ n + 1. A similar hierarchy exists for ALG cv, based on the sorts of intermediate types used. Intuitively, these results follow from the use of the powerset operator, which essentially provides an additional exponential amount of scratch paper for each additional level of set nesting.

The bottom of this hierarchy is simply relational calculus. Recall that ALG cv− can use the nest operator but not the powerset operator. It is thus natural to ask, Where do ALG cv−/
CALC cv− (assuming flat input and output) lie relative to the relational calculus and the first level of the hierarchy? Rather surprisingly, it turns out that the nest operator alone does not increase expressive power. Specifically, we show now that with flat input and output, ALG cv−/CALC cv− is equivalent to relational calculus.

Theorem 20.7.2
Let ϕ be a CALC cv−/ALG cv− query over a relational database schema R with output of relational sort S. Then there exists a relational calculus query ϕ′ equivalent to ϕ.

Crux
The basic intuition underlying the proof is that with a flat input in CALC cv− or ALG cv−, each set constructed at an intermediate stage can be identified by a tuple of atomic
536
Complex Values
values. In terms of ALG cv−, the intuitive reason for this is that sets can be created only in two ways:
• by nest, which builds a relation whose nonnested coordinates form a key for the nested one, and
• by set _ create, which can build only singleton sets.

Thus all created sets can be identified using some flat key of bounded length. The sets can then be simulated in the computation by their flat representations. The proof consists of
• providing a careful construction of the flat representation of the sets created in the computation, which reflects the history of their creation; and
• constructing a new query, equivalent to the original one, that uses only the flat representations of sets.

The details of the proof are omitted.

Observe that an immediate consequence of the previous result is that transitive closure or powerset are not expressible in ALG cv−.

Remark 20.7.3
The previous results focus on relational queries. The same technique can be used for nonflat inputs. An arbitrary input I can be represented by a flat database If of size polynomial in the size of the input. Now an arbitrary ALG cv− query on I can be simulated by a relational query on If to yield a flat database representing the result. Finally the complex object result is constructed in polynomial time. This shows in particular that ALG cv− is in ptime.

20.8
A Practical Query Language for Complex Values
We conclude our discussion of languages for complex values with a brief survey of a fragment of the query language O2SQL supported by the commercial object-oriented database system O2 (see Chapter 21). This fragment provides an elegant syntax for accessing and constructing deeply nested complex values, and it has been incorporated into a recent in-dustrial standard for object-oriented databases.

For the first example we recall the query
(4.3) What are the address and phone number of the Le Champo?

Using the CINEMA database (Fig. 3.1), this query can be expressed in O2SQL as element select tuple ( t.address, t.phone )
from t in Location
where t.name = “Le Champo”
20.8 A Practical Query Language for Complex Values 537
The select- from- where clause has semantics analogous to those for SQL. Unlike SQL, the select part can specify an essentially arbitrary complex value, not just tuples. A select-
from- where clause returns a set4; the keyword element here is a desetting operator that returns a runtime error if the set does not have exactly one element.

The next example illustrates how O2SQL can work inside nested structures. Recall the complex value shown in Fig. 20.2, which represents a portion of the CINEMA database.

Let the full complex value be named Films. The following query returns all movies for which the director does not participate as an actor.

select m.Title
from f in Films
m in f.Movies
where f.Director not in select a
from a in m.Actors
O2SQL also provides a mechanism for collapsing nested sets. Again using the complex value Films of Fig. 20.2, the following gives the set of all directors that have not acted in any Hitchcock film.

select f.Director
from f in Films
where f.Director not in flatten select m.Actors
from g in Films
m in g.Movies
where g.Director = “Hitchcock”
Here the inner select- from- where clause returns a set of sets of actors. The keyword flatten has the effect of forming the union of these sets to yield a set of actors.

We conclude with an illustration of how O2SQL can be used to construct a deeply nested complex value. The following query builds, from the complex value Films of Fig. 20.2, a complex value of the same type that holds information about all movies for which the director does not serve as an actor.

select tuple ( Director: f.Director,
Movies: select tuple ( Title: m.Title,
Actors: select a
from a in m.Actors )
from m in f.Movies
where f.Director not in m.Actors )
from f in Films
4 In the full language O2SQL, a list or bag might also be returned; we do not discuss that here.

Furthermore, we do not include the keyword unique in our queries, although technically it should be included to remove duplicates from answer sets.

538
Complex Values
Bibliographic Notes
The original proposal for generalizing the relational model to allow entries in relations to be sets is often attributed to Makinouchi [Mak77]. Our presentation is strongly influenced by [AB88]. An extensive coverage of the field can be found in [Hul87]. The nested relation model is studied in [JS82, TF86, RKS88]. The V-relation model is studied in [BRS82, AB86, Ver89], and the essentially equivalent partition normal form (PNF) nested relation model is studied in [RKS88]. The connection of the PNF nested relations with dependencies has also been studied (e.g., in [TF86, OY87]). References [DM86a, DM92] develop a while-like language that expresses all computable queries (in the sense of [CH80b]) over
“directories”; these are database structures that are essentially equivalent to nested relations.

There have been many proposals of algebras. In general, the earlier ones have essentially the power of ALG cv− (due to obvious complexity considerations). The powerset operation was first proposed for the Logical Data Model of [KV84, KV93b].

The calculus presented in this chapter is based on Jacobs’s calculus [Jac82]. This original proposal allowed noncomputable queries [Var83]. We use in this chapter a computable version of that calculus that is also used (with minor variations) in [KV84, KV93b, AB88, RKS88, Hul87].

Parameterized queries are close to the commonly used mathematical concept of set comprehension.

The equivalence of the algebra and the calculus has been shown in [AB88]. An equivalence result for a more general model had been previously given in [KV84, KV93b]. The equivalence result is preserved with oracles. In particular, it is shown in [AB88] that if the algebra and the calculus are extended with an identical set of oracles (i.e., sorted functions that are evaluated externally), the equivalence result still holds.

The strongly safe-range calculus, and the equivalence of ALG cv− and CALC cv−, are based on [AB88].

The fact that transitive closure can be computed in the calculus was noted in [AB88].

The result that any algebra query computing transitive closure requires exponential space (with the straightforward evaluation model) was shown in [SP94]. The equivalence between the calculus and various rule-based languages is from [AB88]. In the rule-based paradigm, nesting can be expressed in many ways. A main difference between various proposals of logic programming with a set construct is in their approach to nesting: grouping in LDL [BNR+87], data functions in COL [AG91], and a form of universal quantification in [Kup87]. In [Kup88], equivalence of various rule-based languages is proved. In [GG88], it is shown that various programming primitives are interchangeable: powerset, fixpoint, various iterators.

The correspondence between ALG cv/CALC cv queries and elementary queries is studied in [HS93, KV93a]. Hierarchies of classes of queries based on the level of set nesting are considered in [HS93, KV93a]. Related work is presented in [Lie89a]. Exact complexity characterizations are obtained with fixpoint, which is no longer redundant when the level of set nesting is bounded [GV91].

Theorem 20.7.2 is from [PG88], which uses a proof based on a strongly safe calculus.

Exercises
539
The proof of Theorem 20.7.2 outlined in this chapter suggests a strong connection between ALG cv− and the V-relation model.

Reference [BTBW92] introduces a rich family of languages for complex objects, extended to include lists and bags, that is based on structural recursion. One language in this family corresponds to the nested algebra presented in this chapter. Using this, an elegant family of generalizations of Theorem 20.7.2 is developed in [Won93].

An extension of complex values, called formats [HY84], includes a marked union construct in addition to tuple and finitary set. Abstract notions of relative information capacity are developed there; for example, it can be shown that two complex value types have equivalent information capacity iff they are isomorphic.

Exercises
Exercise 20.1
(V-relations) Consider the schema R of sort
A, B : {C, D}.

Furthermore, we impose the fd A → B (more precisely, the generalization of a functional dependency). (a) Prove that for each instance I of R, the size of I is bounded by a polynomial in adom(I ). (b) Show how the same information can be naturally represented using two flat relations. (One suffices with some coding.) (c) Formalize the notion of V-relation of Section 20.1
and generalize the results of (a) and (b).

Exercise 20.2
Consider a (flat) relation R of sort
name age address car child _ name child _ age
and the multivalued dependency name age address →
→ car. Prove that the same information
can be stored in a complex value relation of sort
name, age, address, cars : {dom}, children : { child _ name, child _ age}
Discuss the advantages of this alternative representation. (In particular, show that for the same data, the size of the instance in the second representation is smaller. Also consider update anomalies.)

Exercise 20.3
Consider the value
{ A : a, B : A : {a, b}, B : A : a, C : ,
A : a, B : A : {}, B : A : a, C : }.

Show how to construct it in the core algebra from {a} and {b}.

Exercise 20.4
Prove that for each complex value relation I , there exists a constant query in the core algebra returning I .

540
Complex Values
Exercise 20.5
Let R be a database schema consisting of a relation R of sort A : dom, B : A : {dom}, B : A : dom, C : ;
and let τ = {A : dom, B : {{dom}}}.

(a) Give a query computing for each I over R, adom(I).

(b) Give a query computing the set of values J of sort τ such that adom(J ) ⊆ adom(I).

Exercise 20.6
Prove that set _ create can be expressed using the other operations of the core algebra. Hint: Use powerset.

Exercise 20.7
Formally define the following operations: (a) renaming, (b) singleton, (c) cross-product, and (d) join. In each case, prove that the operation is expressible in ALG cv.

Which of these can be expressed without powerset?

Exercise 20.8
(Nest,unnest)
(a) Show that nest is expressible in ALG cv.

(b) Show that unnest is expressible in ALG cv without using the powerset operator.

(c) Prove that unnest A is a right inverse of nest A=(A1...Ak) and that unnest A has no right inverse.

Exercise 20.9
(Map) The operation map C,q is applicable to relations of sort τ where τ is of the form {C : {τ ′}, . . .} and q is a query over relations of sort τ ′. For instance, let I = {C : I1, C′ : J1, C : I2, C′ : J2, C : I3, C′ : J3}.

Then
map C,q(I ) = {C : q(I1), C′ : J1, C : q(I2), C′ : J2, C : q(I3), C′ : J3}.

(a) Give an example of map and show how the query of this example can be expressed in ALG cv.

(b) Give a formal definition of map and prove that the addition of map does not change the expressive power of the algebra.

Exercise 20.10
Show how to express
{x | {y | liked(x, y)} = {y | saw(x, y)}}
in the core calculus.

Exercise 20.11
The calculus is extended by allowing terms of the form z ∪ z′ and z − z′ for each set term z, z′ of identical sort. Prove that this does not modify the expressive power of the language. More generally, consider introducing in the calculus terms of the form q(t1, . . . , tn), where q is an n-ary algebraic operation and the ti are set terms of appropriate sort.

Exercise 20.12
Give five queries on the CINEMA database expressed in ALG cv. Give the same queries in CALC cv.

Exercises
541
Exercise 20.13
Complete the proof that ALG cv ⊑ CALC cv for Theorem 20.5.1. Complete the proof of “Last Stage” for Theorem 20.5.1.

Exercise 20.14
This exercise elaborates the simulation of CALC cv by ALG cv presented in the proof of Theorem 20.5.1. In particular, give the details of
(a) the construction of E adom
(b) the construction of Gτ for each τ
(c) the last stage of the construction.

Exercise 20.15
Show that the query in Example 20.6.2 is strongly safe range (e.g., give a query in ALG cv− or CALC cv− equivalent to it).

Exercise 20.16
Show that every strongly safe-range query is in ALG cv− [one direction of (b) of Theorem 20.5.3].

Exercise 20.17
Sketch a program expressing the query even in CALC cv+µ+.

Exercise 20.18
Prove that CALC cv+µ+ =ALG cv.

Exercise 20.19
Define a while language based on ALG cv. Show that it does not have more power than ALG cv.

Exercise 20.20
Consider a query q whose input consists of two relations blue, red of sort A, B (i.e., consists of two graphs). Query q returns a relation of sort A, B : {dom} with the following meaning. A tuple x, X is in the result if x is a vertex and X is the set of vertexes y such that there exists a path from x to y alternating blue and red edges. Prove in one line that q is expressible in ALG cv. Show how to express q in some complex value language of this chapter.

Exercise 20.21
Generalize the construction of Example 20.6.2 to prove Theorem 20.6.1.

Exercise 20.22
Datalog with stratified negation was shown to be weaker than datalog with inflationary negation. Is the situation similar for datalog cv with negation?

Exercise 20.23
Exhibit a query that is not expressible in CALC cv− but is expressible in CALC cv, and one that is not expressible in CALC cv.

Exercise 20.24
Give a relational calculus formula or algebra expression for the query in Example 20.4.8.

⋆ Exercise 20.25 Recall the language while N from Chapter 18. The language allows assignments of relational algebra expressions to relational variables, looping, and integer arithmetic.

Let whilecv be like while
N
N , except that the relational algebra expressions are in ALG cv. Prove that whilecv can express all queries from flat relations to flat relations.

N
21 ObjectDatabases
Minkisi are complex objects clearly not the product of a momentary im-pulse. . . . To do justice to objects, a theory of them must be as complex as them. 1
— Wyatt MacGaffey in Astonishment and Power
Alice:
What is a Minkisi?

Sergio:
It is an African word that translates somewhat like “things that do things.”
Vittorio:
It is art, religion, and magic.

Riccardo:
Oh, this sounds to me very object oriented!

Inthischapter,weprovideabriefintroductiontoobject-orienteddatabases(OODBs).A complete coverage of this new and exciting area is beyond the scope of this volume; we emphasize the new modeling features of OODBs and some of the preliminary theoretical research about them. On the one hand, we shall see that some of the most basic issues concerning OODBs, such as the design of query languages or the analysis of their expressive power, can be largely resolved using techniques already developed in connection with the relational and complex value models. On the other hand, the presence of new features (such as object identifiers) and methods brings about new questions and techniques.

As mentioned previously, the simplicity of the data structure in the relational model often hampers its use in many database applications. A relational representation can obscure the intention and intricate semantics of a complex data structure (e.g., for holding the design of a VLSI chip or an airplane wing). As we shall see, OODBs remedy this situation by borrowing a variety of data structuring constructs from the complex value model (Chapter 20) and from semantic data models (considered in Chapter 11). At a more fundamental level, the relational data model and all of the data models presented so far impose a sharp distinction between data storage and data processing: The DBMS provides data storage, but data processing is provided by a host programming language with a relatively simple language such as SQL embedded in it. OODBs permit the incorporation of behavioral portions of the overall data management application directly into the database schema, using methods in the sense of object-oriented programming languages.

This chapter begins with an informal presentation of the underlying constructs of OODBs. Next a formal definition for a particular OODB model is presented. Two directions of theoretical research into OODBs are then discussed. First a family of languages 1 Reprinted with permission. Smithsonian Institution Press ©1993.

542
21.1 Informal Presentation
543
for data access is presented, with an emphasis on how the languages interact with the novel modeling constructs (of particular interest is the impact of generalizing the notion of complete query language to accommodate the presence of object identifiers, OIDs). Next two languages for methods are described. The first is an imperative language allowing us to specify methods with side effects.2 The second language brings us to a functional perspective on methods and database languages and allows us to specify side-effect-free methods.

In both cases, we present some results on type safety and expressive power. Checking type safety is generally undecidable; we identify a significant portion of the functional language, monadic method schemas, for which type safety is decidable. With respect to expressive power, the imperative language is complete in an extended sense formalized in this chapter.

The functional language expresses precisely qptime on ordered inputs and so turns out to express the by-now-famous fixpoint queries. The chapter concludes with a brief survey of additional research issues raised by OODBs.

21.1
Informal Presentation
Object-oriented database models stem from a synthesis of three worlds: the complex value model, semantic database models, and object-oriented programming concepts. At the time of writing, there is not widespread agreement on a specific OODB model, nor even on what components are required to constitute an OODB model. In this section, we shall focus on seven important ingredients of OODB models:
1. objects and object identifiers;
2. complex values and types;
3. classes;
4. methods;
5. ISA hierarchies;
6. inheritance and dynamic binding;
7. encapsulation.

In this section, we describe and illustrate these interrelated notions informally; a more formal definition is presented in the following section. We will also briefly discuss alternatives.

As a running example for this discussion, we shall use the OODB schema specified in Fig. 21.1. This schema is closely related to the semantic data model schema of Fig. 11.1, which in turn is closely related to the CINEMA example of Chapter 3.

As discussed in Chapter 11, a significant shortcoming of the relational model is that it must use printable values, often called keys, to refer to entities or objects-in-the-world.

As a simple example, suppose that the first and last names of a person are used as a key to identify that person. From a physical point of view, it is then cumbersome to refer to a person, because the many bytes of his or her name must be used. A more fundamental 2 Methods are said to have side-effects if they cause updates to the database.

544
Object Databases
(* schema and base definitions *)
create schema PariscopeSchema ;
create base PariscopeBase;
(* class definitions *)
class Person
type tuple ( name: string, citizenship: string, gender: string );
class Director inherit Person
type tuple ( directs: set ( Movie ) );
class Actor inherit Person
type tuple ( acts_in: { Movie },
award: { tuple ( prize: string, year: integer ) } );
class Actor _ Director inherit Director, Actor class Movie
type tuple ( title: string, actors: set ( Actor );
director: Director );
class Theater
type tuple ( name: string, address: string, phone: string );
(* name definitions *)
name Pariscope: set ( tuple ( theater: Theater, time: string, price: integer, movie: Movie ) );
name Persons _ I _ like: set ( Person ); name Actors _ I _ like, Actors _ you _ like: set ( Actor ); name My _ favorite _ director : Director
(* method definitions *)
method get _ name in class Person : string
{ if (gender = “male”)
return “Mr.” + self.name;
else
return “Ms.” + self.name }
method get _ name in class Director : string
{ return ( “Director” + self.name ) };
method get _ name in class Actor _ Director : string
{ return ( “Director” + self.name ) };
(* we assume here that ‘+’ denotes a string concatenation operator *) Figure 21.1:
An OODB Schema
21.1 Informal Presentation
545
problem arises if the person changes his or her name (e.g., as the result of marriage). When performing this update, conceptually there is a break in the continuity in the representation of the person. Furthermore, care must be taken to update all tuples (typically arising in a number of different relations) that refer to this person, to reflect the change of name.

Following the spirit of semantic data models, OODB models permit the explicit representation of physical and conceptual objects through the use of object identifiers (OIDs).

Conceptually, a unique OID is assigned to each object that is represented in the database, and this association between OID and object remains fixed, even as attributes of the object (such as name or age) change in value. The use of objects and OIDs permits OODBs to share information gracefully; a given object o is easily shared by many other objects simply by referencing the OID of o. This is especially important in the context of updates; for example, the name of a person object o need be changed in only one place even if o is shared by many parts of the database.

In an OODB, a complex value is associated with each object. This complex value may involve printables and/or OIDs (i.e., references to the same or other objects). For example, each object in the class Movie in Fig. 21.1 has an associated triple whose second coordinate contains a set of OIDs corresponding to actors. In this section, we focus on complex values constructed using the tuple and set construct. In practical OODB models, other constructs are also supported (including, for example, bags and lists). Some commercial OODBs are based on an extension of C++ that supports persistence; in these models essentially any C++ structure can serve as the value associated with an object.

Objects that have complex values with the same type may be grouped into classes, as happens in semantic data models. In the running example, these include Person, Director, and Movie. Classes also serve as a natural focal point for associating some of the behavioral (or procedural) components of a database application. This is accomplished by associating with each class a family of methods for that class. Methods might be simple (e.g., producing the name of a person) or arbitrarily complex (e.g., displaying a representation of an object to a graphical interface or performing a stress analysis of a proposed wing design).

A method has a name, a signature, and an implementation. The name and signature serve as an external interface to the method. The implementation is typically written in a (possibly extended) programming language such as C or C++. The choice of implementation language is largely irrelevant and is generally not considered to be part of the data model.

As with semantic models, OODB models permit the organization of classes into a hierarchy based on what have been termed variously ISA, specialization, or class-subclass relationships. The term hierarchy is used loosely here: In many cases any directed acyclic graph (DAG) is permitted. In Fig. 21.1 the ISA hierarchy has Director and Actor as (immediate) specializations of Person and Actor _ Director as a specialization of both Director and Actor. Following the tradition of object-oriented programming languages, a virtual class any is included that serves as the unique root of the ISA hierarchy.

In OODB models, there are two important implications of the statement that class c′
is a subclass of c. First it is required that the complex value type associated with c′ be a subtype (in the sense formally defined later) of the complex value type associated with c.

Second it is required that if there is a method with name m associated with c, then there is also a method with name m associated with c′. In some cases, the implementation (i.e., the actual code) of m for c′ is identical to that for c; in this case the code of m for c′ need not
546
Object Databases
be explicitly specified because it is inherited from c. In other cases, the implementation of m for c′ is different from that for c; in which case we say that the implementation of m for c′ overrides the implementation of m for c. (See the different implementations for method get _ name in Fig. 21.1.) The determination of what implementation is associated with a given method name and class is called method resolution. A method is invoked with respect to an object o, and the class to which o belongs determines which implementation is to be used. This policy is called dynamic binding. As we shall see, the interaction of method calls and dynamic binding in general makes type checking for OODB schemas undecidable. (It is undecidable to check whether such a schema would lead to a runtime type error; on the other hand, it is clearly possible to find decidable sufficient conditions that will guarantee that no such error can arise.)

In the particular OODB model presented here, both values (in the style of complex values) and objects are supported. For example, in Fig. 21.1 a persistent set of triples called Pariscope is supported (see also Fig. 11.1). The introduction of values not directly associated with OIDs is a departure from the tradition of object-oriented programming, and not all OODBs in the literature support it. However, in databases the use of explicit values often simplifies the design and use of a schema. Their presence also facilitates expressing queries in a declarative manner.

The important principle of encapsulation in object orientation stems from the field of abstract data types. Encapsulation is used to provide a sharp boundary between how information about objects is accessed by database users and how that information is actually stored and provided. The principle of encapsulation is most easily understood if we distinguish two categories of database use: dba mode, which refers to activities unique to database administrators (including primarily creating and modifying the database schema), and user mode, which refers to activities such as querying and updating the actual data in the database. Of course, some users may operate in both of these modes on different occasions. In general, application software is viewed as invoked from the user mode.

Encapsulation requires that when in user mode, a user can access or modify information about a given object only by means of the methods defined for that object; he or she cannot directly examine or modify the complex value or the methods associated with the object. In particular, then, essentially all application software can access objects only through their methods. This has two important implications. First, as long as the same set of methods is supported, the underlying implementation of object methods, and even of the complex value representation of objects, can be changed without having to modify any application software. Second, the methods of an object often provide a focused and abstracted interface to the object, thus making it simpler for programmers to work with the objects.

In object-oriented programming languages, it is typical to enforce encapsulation except in the special case of rewriting method implementations. In some OODB models, there is an important exception to this in connection with query languages. In particular, it is generally convenient to permit a query language to examine explicitly the complex values associated with objects.

The reader with no previous exposure to object-oriented languages may now be utterly overwhelmed by the terminology. It might be helpful at this point to scan through a book or manual about an object-oriented programming language such as C++, or an OODB such
21.2 Formal Definition of an OODB Model
547
as O2 or ObjectStore. This will provide numerous examples and the overall methodology of object-oriented programming, which is beyond the scope of this book.

21.2
Formal Definition of an OODB Model
This section presents a formal definition of a particular OODB model, called the generic OODB model. (This model is strongly influenced by the IQL and O2 models. Many features are shared by most other OODB models. While presenting the model, we also discuss different choices made in other models.) The presentation essentially follows the preceding informal one, beginning with definitions for the types and class hierarchy and then introducing methods. It concludes with definitions of OODB schema and instance.

Types and Class Hierarchy
The formal definitions of object, type, and class hierarchy are intertwined. An object consists of a pair ( identifier, value). The identifiers are taken from a specific sort containing OIDs. The values are essentially standard complex values, except that OIDs may occur within them. Although some of the definitions on complex values and types are almost identical to those in Chapter 20, we include them here to make precise the differences from the object-oriented context. As we shall see, the class hierarchy obeys a natural restriction based on subtyping.

To start, we assume a number of atomic types and their pairwise disjoint corresponding domains: integer, string, bool, float. The set dom of atomic values is the (disjoint) union of these domains; as before, the elements of dom are called constants. We also assume an infinite set obj = {o1, o2, . . .} of object identifiers (OIDs), a set class of class names, and a set att of attribute names. A special constant nil represents the undefined (i.e., null) value.

Given a set O of OIDs, the family of values over O is defined so that (a) nil, each element of dom, and each element of O are values over O; and (b) if v1, . . . , vn are values over O, and A1, . . . , An distinct attributes names, the tuple [A1 : v1, . . . , An : vn] and the set {v1, . . . , vn} are values over O.

The set of all values over O is denoted val(O). An object is a pair (o, v), where o is an OID and v a value.

In general, object-oriented database models also include constructors other than tuple and set, such as list and bag; we do not consider them here.

Example 21.2.1
Letting oid 7, oid 22, etc. denote OIDs, some examples of values are as follows:
[ theater : oid 7, time : “16:45”, price : 45, movie : oid 22]
{“H. Andersson”, “K. Sylwan”, “I. Thulin”, “L. Ullman”}
[ title : “The Trouble with Harry”, director : oid 77, actors : { oid 81, oid 198, oid 265, oid 77}]
548
Object Databases
An example of an object is
( oid 22 , [ title :“The Trouble with Harry”, director : oid 77, actors : { oid 81, oid 198, oid 265, oid 77}]) As discussed earlier, objects are grouped in classes. All objects in a class have complex values of the same type. The type corresponding to each class is specified by the OODB
schema.

Types are defined with respect to a given set C of class names. The family of types over C is defined so that
1. integer, string, bool, float, are types;
2. the class names in C are types;
3. if τ is a type, then3 {τ } is a (set) type;
4. if τ1, . . . , τn are types and A1, . . . , An distinct attribute names, then [A1 : τ1, . . . , An : τn] is a (tuple) type.

The set of types over C together with the special class name any are denoted types(C).

(The special name any is a type but may not occur inside another type.) Observe the close resemblance with types used in the complex value model.

Example 21.2.2
An example of a type over the classes of the schema in Fig. 21.1 is
[ name : string, citizenship : string, gender : string]
One may want to give a name to this type (e.g., Person _ type). Other examples of types (with names associated to them) include
Director _ type = [ name : string, citizenship : string, gender : string, directs : { Movie}]
Theater _ type
= [ name : string, address : string, phone : string]
Pariscope _ type = [ theater : Theater, time : string, price : integer, movie : Movie]
Movie _ type
= [ title : string, actors : { Actor}, director : Director]
Award _ type
= [ prize : string, year : integer]
In an OODB schema we associate with each class c a type σ (c), which dictates the type of objects in this class. In particular, for each object (o, v) in class c, v must have the exact structure described by σ (c).

3 In Fig. 21.1 we use keywords set and tuple as syntactic sugar when specifying the set and tuple constructors.

21.2 Formal Definition of an OODB Model
549
Recall from the informal description that an OODB schema includes an ISA hierarchy among the classes of the schema. The class hierarchy has three components: (1) a set of classes, (2) the types associated with these classes, and (3) a specification of the ISA relationships between the classes. Formally, a class hierarchy is a triple (C, σ, ≺), where C is a finite set of class names, σ a mapping from C to types(C), and ≺ a partial order on C.

Informally, in a class hierarchy the type associated with a subclass should be a refinement of the type associated with its superclass. For example, a class Student is expected to refine the information on its superclass Person by providing additional attributes. To capture this notion, we use a subtyping relationship (≤) that specifies when one type refines another.

Definition 21.2.3
Let (C, σ, ≺) be a class hierarchy. The subtyping relationship on types(C) is the smallest partial order ≤ over types(C) satisfying the following conditions: (a) if c ≺ c′, then c ≤ c′;
(b) if τi ≤ τ ′ for each i ∈ [1, n] and n ≤ m, then
i
[A1 : τ1, . . . , An : τn, . . . , Am : τm] ≤ [A1 : τ ′, . . . , A
];
1
n : τ ′n
(c) if τ ≤ τ ′, then {τ } ≤ {τ ′}; and
(d) for each τ , τ ≤ any (i.e., any is the top of the hierarchy).

A class hierarchy (C, σ, ≺) is well formed if for each pair c, c′ of classes, c ≺ c′ implies σ (c) ≤ σ (c′).

By way of illustration, it is easily verified that
Director _ type ≤ Person _ type
Director _ type "≤ Movie _ type.

Thus the schema obtained by adding the constraint Director ≺ Movie would not be well formed.

Henceforth we consider only well-formed class hierarchies.

Example 21.2.4
Consider the class hierarchy (C, σ, ≺) of the schema of Fig. 21.1. The set of classes is
C = { Person, Director, Actor, Actor _ Director, Theater, Movie}
with Actor ≺ Person, Director ≺ Person, Actor _ Director ≺ Director, Actor _ Director ≺
Actor, and (referring to Example 21.2.2 for the definitions of Person _ type, Theater _ type, etc.)

550
Object Databases
σ ( Person)
= Person _ type,
σ ( Theater)
= Theater _ type,
σ ( Movie)
= Movie _ type,
σ ( Director)
= Director _ type,
σ ( Actor)
= [ name : string, citizenship : string, gender : string, acts _ in : { Movie}, award : { Award _ type}]
σ ( Actor _ Director) = [ name : string, citizenship : string, gender : string, acts _ in : { Movie}, award : { Award _ type}, directs : { Movie}]
The use of type names here is purely syntactic. We would obtain the same schema if we replaced, for instance, Person _ type with the value of this type.

Observe that σ ( Director) ≤ σ ( Person) and σ ( Actor) ≤ σ ( Person), etc.

The Structural Semantics of a Class Hierarchy
We now describe how values can be associated with the classes and types of a class hierarchy. Because the values in an OODB instance may include OIDs, the semantics of classes and types must be defined simultaneously. The basis for these definitions is the notion of OID assignment, which assigns a set of OIDs to each class.

Definition 21.2.5
Let (C, σ, ≺) be a (well-formed) class hierarchy. An OID assignment is a function π mapping each name in C to a disjoint finite set of OIDs. Given OID
assignment π , the disjoint extension of c is π(c), and the extension of c, denoted π ∗(c), is ∪{π(c′) | c′ ∈ C, c′ ≺ c}.

If π is an OID assignment, then π ∗(c′) ⊆ π ∗(c) whenever c′ ≺ c. This should be understood as a formalization of the fact that an object of a subclass c′ may be viewed also as an object of a superclass c of c′. From the perspective of typing, this suggests that operations that are type correct for members of c are also type correct for members of c′.

Unlike the case for many semantic data models, the definition of OID assignment for OODB schemas implies that extensions of classes of an ISA hierarchy without common subclasses are necessarily disjoint. In particular, extensions of all leaf classes of the hierarchy are disjoint (see Exercise 21.2). This is a simplifying assumption that makes it easier to associate objects to classes. There is a unique class to whose disjoint extension each object belongs.

The semantics for types is now defined relative to a class hierarchy (C, σ, ≺) and an OID assignment π . Let O = ∪{π(c) | c ∈ C}, and define π(any) = O. The disjoint interpretation of a type τ , denoted dom(τ ), is given by (a) for each atomic type τ , dom(τ ) is the usual interpretation of that type; (b) dom(any) is val(O);
21.2 Formal Definition of an OODB Model
551
(c) for each c ∈ C, dom(c) = π ∗(c) ∪ {nil};
(d) dom({τ }) = {{v1, . . . , vn} | n ≥ 0, and vi ∈ dom(τ ), i ∈ [1, n]}; and (e) dom([A1 : τ1, . . . , Ak : τk]) = {[A1 : v1, . . . , Ak : vk] | vi ∈ dom(τi), i ∈ [1, k]}.

Remark 21.2.6
In the preceding interpretation, the type determines precisely the structure of a value of that type. It is interesting to replace (e) by
dom([A1 : τ1, . . . , Ak : τk]) =
(e′)
{[A1 : v1, . . . , Ak : vk, Ak+1 : vk+1, . . . Al : vl] |
vi ∈ dom(τi), i ∈ [1, k], vj ∈ val(O), j ∈ [k + 1, l]}.

Under this alternative interpretation, for each τ, τ ′ in types(C), if τ ′ ≤ τ then dom(τ ′) ⊆
dom(τ ). This is why this is sometimes called the domain-inclusion semantics. From a data model viewpoint, this presents the disadvantage that in a correctly typed database instance, a tuple may have a field that is not even mentioned in the database schema. For this reason, we do not adopt the domain-inclusion semantics here. On the other hand, from a linguistic viewpoint it may be useful to adopt this more liberal semantics in languages to allow variables denoting tuples with more attributes than necessary.

Adding Behavior
The final ingredient of the generic OODB model is methods. A method has three components:
(a) a name
(b) a signature
(c) an implementation (or body).

There is no problem in specifying the names and signatures of methods in an OODB
schema. To specify the implementation of methods, a language for methods is needed.

We do not consider specific languages in the generic OODB model. Therefore only names and signatures of methods are specified at the schema level in this model. In Section 21.4, we shall consider several languages for methods and shall therefore be able to add the implementation of methods to the schema.

Without specifying the implementation of methods, the generic OODB model specifies their semantics (i.e., the effect of each method in the context of a given instance). This effect, which is a function over the domains of the types corresponding to the signature of the method, is therefore specified at the instance level.

We assume the existence of an infinite set meth of method names. Let (C, σ, ≺) be a class hierarchy. For method name m, a signature of m is an expression of the form m : c × τ1 × · · · × τn−1 → τn, where c is a class name in C and each τi is a type over C. This signature is associated with the class c; we say that method m applies to objects of class c and to objects of classes that inherit m from c. It is common for the same method name to have different signatures in connection with different classes. (Some restrictions shall be specified later.) The notion of signature here generalizes the one typically found in
552
Object Databases
object-oriented programming languages, because we permit the τi’s to be types rather than only classes.

It is easiest to describe the notions of overloading, method inheritance, and dynamic binding in terms of an example. Consider the methods defined in the schema of Fig. 21.1.

All three share the name get _ name. The signatures are given by get _ name : Person → string
get _ name : Director → string
get _ name : Actor _ Director → string Note that get _ name has different implementations for these classes; this is an example of overloading of a method name.

Recall that Actor is a subclass of Person. According to the informal discussion, if get _ name applies to elements of Person, then it should also apply to members of Actor.

Indeed, in the object-oriented paradigm, if a method m is defined for a class c but not for a subclass c′ of c (and it is not defined anywhere else along a path from c′ to c), then the definition of m for c′ is inherited from c. In particular, the signature of m on c′ is identical to the one of m for c, except that the first c is replaced by c′. The implementation of m for c′ is identical to that for c. In the schema of Fig. 21.1, the signature of get _ name for Actor is
get _ name : Actor → string
and the implementation is identical to the one for Person. The determination of the correct method implementation to use for a given method name m and class c is called method resolution; the selected implementation is called the resolution of m for c.

Suppose that π is an OID assignment, that oid 25 is in the extension π ∗( Person) of Person, and that get _ name is called on oid 25. What implementation of get _ name will be used? In our OODB model we shall use dynamic binding (also called late binding, or value-dependent binding). This means that the specific implementation chosen for get _ name on oid 25 depends on the most specific class that oid 25 belongs to, that is, the class c such that oid 25 ∈ π(c).

(An alternative to dynamic binding is static binding, or context-dependent binding.

Under this discipline, the implementation used for get _ name depends on the type associated with the variable holding oid 25 at the point in program where get _ name is invoked.

This can be determined at compile time, and so static binding is generally much cheaper than dynamic binding. In the language C++, the default is static binding, but dynamic binding can be obtained by using the keyword virtual when specifying the method.) Consider a call m(o, v1, . . . , vn−1) to method m. This is often termed a message, and o is termed the receiver. As described here, the implementation of m associated with this message depends exclusively on the class of o. To emphasize the importance of the receiver for finding the actual implementation, in some languages the message is denoted o → m[v1, . . . vn−1]. In some object-oriented programming languages, such as CommonLoops (an object-oriented extension of LISP), the implementation depends on
21.2 Formal Definition of an OODB Model
553
m
c′
c′′
m
c′′′
m
c
Figure 21.2:
Unambiguous definition
all of the parameters of the call, not just the first. This is also the approach of the method schemas introduced in Section 21.4.

The set of methods applicable to an object is called the interface of the object. As noted in the informal description of OODB models, in most cases objects are accessed only via their interface; this philosophy is called encapsulation.

As part of an OODB schema, a set M of method signatures is associated to a class hierarchy (C, σ, ≺). Note that a signature m : c × τ1 × · · · × τn−1 → τn can be viewed as giving a particular meaning to m for class c, at least at a syntactic level. Because of inheritance, a meaning for method m need not be given explicitly for each class of C nor even for subclasses of a class for which m has been given a meaning. However, we make two restrictions on the family of method signatures: The set M is well formed if it obeys the following two rules:
Unambiguity: If c is a subclass of c′ and c′′ and there is a definition of m for c′ and c′′, then there is a definition of m for a subclass of c′ and c′′ that is either c itself, or a superclass of c. (See Fig. 21.2.)

Covariance 4 : If m : c × τ1 × · · · × τn → τ and m : c′ × τ ′ × · · · × τ ′ → τ ′ are two defi-1
m
nitions and c ≺ c′, then n = m for each i, τi ≤ τ ′ and τ ≤ τ ′.

i
The first rule prevents ambiguity resulting from the presence of two method implementations both applicable for the same object. A primary motivation for the second rule is intuitive: We expect the argument and result types of a method on a subclass to be more refined than those of the method on a superclass. This also simplifies the writing of type-correct programs, although type checking leads to difficulties even in the presence of the covariance assumption (see Section 21.4).

Database Schemas and Instances
We conclude this section by presenting the definitions of schemas and instances in the generic OODB model. An important subtlety here will be the role of OIDs in instances 4 In type theory, contravariance is used instead. Contravariance is the proper notion when functions are passed as arguments, which is not the case here.

554
Object Databases
as placeholders; as will be seen, the specific OIDs present in an instance are essentially irrelevant.

As indicated earlier, a schema describes the structure of the data that is stored in a database, including the types associated with classes and the ISA hierarchy and the signature of methods (i.e., the interfaces provided for objects in each class).

In many practical OODBs, it has been found convenient to allow storage of complex values that are not associated with any objects and that can be accessed directly using some name. This also allows us to subsume gracefully the capabilities of value-based models, such as relations and complex values. It also facilitates writing queries. To reflect this feature, we allow a similar mechanism in schemas and instances. Thus schemas may include a set of value names with associated types. Instances assign values of appropriate type to the names. Method implementations, external programming languages, and query languages may all use these names (to refer to their current values) or a class name (to refer to the set of objects currently residing in that class). In this manner, named values and class names are analogous to relation names in the relational model and to complex value relation names in the complex value model.

In the schema of Fig. 21.1, examples of named values are Pariscope (holding a set of triples); Persons _ I _ like, Actors _ I _ like, and Actors _ you _ like (referring to sets of person objects and actor objects; and, finally, My _ favorite _ director (referring to an individual object as opposed to a set). These names can be used explicitly in method implementations and in external query and programming languages.

We now have the following:
Definition 21.2.7
A schema is a 5-tuple S = (C, σ, ≺, M, G) where
• G is a set of names disjoint from C;
• σ is a mapping from C ∪ G to types(C);
• (C, σ, ≺) is a well-formed class hierarchy5; and
• M is a well-formed set of method signatures for (C, σ, ≺).

An instance of an OODB schema populates the classes with OIDs, assigns values to these OIDs, gives meaning to the other persistent names, and assigns semantics to method signatures. The semantics of method signatures are mappings describing their effect. From a practical viewpoint, the population of the classes, the values of objects, and the values of names are kept extensionally; whereas the semantics of the methods are specified by pieces of code (intensionally). However, we ignore the code of methods for the time being.

Definition 21.2.8
An instance of schema (C, σ, ≺, M, G) is a 4-tuple I = (π, ν, γ , µ), where
(a) π is an OID assignment (and let O = ∪{π(c) | c ∈ C});
(b) ν maps each OID in O to a value in val(O) of correct type [i.e., for each c and o ∈ π(c), ν(o) ∈ dom(σ (c))];
5 By abuse of notation, we use here and later σ instead of σ |C.

21.2 Formal Definition of an OODB Model
555
(c) γ associates to each name in G of type τ a value in dom(τ ); (d) µ assigns semantics to method names in agreement with the method signatures in M. More specifically, for each signature m : c × *
α → τ ,
µ(m : c × *
α → τ ) : dom(c × *
α) → dom(τ );
that is, µ(m : c × *
α → τ ) is a partial function from dom(c × *
α) to dom(τ ).

Recall that a method m can occur with different signatures in the same schema. The mapping µ can assign different semantics to each signature of m. The function µ(m : c × *
α → τ ) is only relevant on objects associated with c and subclasses of c for which m is not redefined.

In the preceding definitions, the assignment of semantics to method signatures is included in the instance. As will be seen in Section 21.4, if method implementations are included in the schema, they induce the semantics of methods at the instance level (this is determined by the semantics of the particular programming language used in the implementation).

Intuitively, it is generally assumed that elements of the atomic domains have universally understood meaning. In contrast, the actual OIDs used in an instance are not relevant.

They serve essentially as placeholders; it is only their relationship with other OIDs and constants that matters. This arises in the practical perspective in two ways. First, in most practical systems, OIDs cannot be explicitly created, examined, or manipulated. Second, in some object-oriented systems, the actual OIDs used in a physical instance may change over the course of time (e.g., as a result of garbage collection or reclustering of objects).

To capture this aspect of OIDs in the formal model, we introduce the notion of OID
isomorphism. Two instances I, J are OID isomorphic, denoted I ≡ OID J, if there exists a bijection on dom ∪ obj that maps obj to obj, is the identity on dom, and transforms I into J.

To be precise, the term object-oriented instance should refer to an equivalence class under OID isomorphism of instances as defined earlier. However, it is usually more convenient to work with representatives of these equivalence classes, so we follow that convention here.

Remark 21.2.9
In the model just described, a class encompasses two aspects:
1. at the schema level, the class definition (its type and method signatures); and 2. at the instance level, the class extension (the set of objects currently in the class).

It has been argued that one should not associate explicit class extensions with classes. To see the disadvantage of class extensions, consider object deletion. To be removed from the database, an object has to be deleted explicitly from its class extension. This is not convenient in some cases. For instance, suppose that the database contains a class Polygon and polygons are used only in figures. When a polygon is no longer used in any figure of the current database, it is no longer of interest and should be deleted. We would like this deletion to be implicit. (Otherwise the user of the database would have to search all possible places in which a reference to a polygon may occur to be able to delete a polygon.) To capture this, some OODBs use an integrity constraint, which states that
556
Object Databases
every object should be accessible from some named value.

This integrity constraint is enforced by an automatic deletion of all objects that become unreachable from the named values. In the polygon example, this approach would allow defining the class Polygon, thus specifying the structure and methods proper to polygons.

However, the members of class Polygon would only be those polygons that are currently relevant. Relevance is determined by membership in (or accessibility from) the named values (e.g., My-Figures, Your-Figures) that refer to polygons. From a technical viewpoint, this involves techniques such as garbage collection.

In these OODBs, the set of objects in a class is not directly accessible. For this reason, the corresponding models are sometimes called models without class extension.

Of course, it is always possible, given a schema, to compute the class extensions or to adapt object creation in a given class to maintain explicitly a named value containing that class extension. In these OODBs, the named values are also said to be roots of persistence, because the persistence of an object is dependent on its accessibility from these named values.

21.3
Languages for OODB Queries
This section briefly introduces several languages for querying OODBs. These queries are formulated against the database as a whole; unlike methods, they are not associated with specific classes. In the next section, we will consider languages intended to provide implementations for methods.

In describing the OODB query languages, we emphasize how OODB features are incorporated into them. The first language is an extension of the calculus for complex values, which incorporates such object-oriented components as OIDs, different notions of equality, and method calls. The second is an extension of the while language, initially introduced in Chapter 14. Of primary interest here is the introduction of techniques for creating new OIDs as part of a query. At this point we examine the notion of completeness for OODB access languages. We also briefly look at a language introducing a logic-based approach to object creation. Finally, we mention a practical language, O2SQL. This is a variant of SQL for OODBs that provides elegant object-oriented features.

Although the languages discussed in this section do provide the ability to call methods and incorporate the results into the query processing and answer, we focus primarily on access to the extensional structural portion of the OODB. The intensional portion, provided by the methods, is considered in the following section. Also, we largely ignore the important issue of typing for queries and programs written in these languages. The issue of typing is considered, in the context of languages for methods, in the next section.

An Object-Oriented Calculus
The object-oriented calculus presented here is a straightforward generalization of the complex value calculus of Chapter 20, extended to incorporate objects, different notions of equality, and methods.

21.3 Languages for OODB Queries
557
Let (C, σ, ≺, M, G) be an OODB schema, and let us ignore the object-oriented features for a moment. Each name in G can be viewed as a complex value; it is straightforward to generalize the complex value calculus to operate on the values referred to by G. (The fact that in the complex value model all relations are sets whereas some names in G might refer to nonset values requires only a minor modification of the language.) Let us now consider objects. OIDs may be viewed as elements of a specific sort.

If viewed in isolation from their associated values, this suggests that the only primitive available for comparing OIDs is equality. Recall from the schema of Fig. 21.1 the names Actors _ I _ like and Actors _ you _ like. The query6
(21.1)
∃x, y(x ∈ Actors _ I _ like ∧ y ∈ Actors _ you _ like ∧ x = y) asks whether there is an actor we both like. To obtain the names of such actors, we need to introduce dereferencing, a mechanism to obtain the value of an object. Dereferencing is denoted by ↑. The following query yields the names of actors we both like: (21.2)
{y | ∃x(x ∈ Actors _ I _ like ∧ x ∈ Actors _ you _ like ∧ x ↑ . name = y)}
In the previous query, x ↑ denotes the value of x, in this case, a tuple with four fields. The dot notation (.) is used as before to obtain the value of specific fields.

In query (21.1), we tested two objects for equality, essentially testing whether they had the same OID. Although it does not increase the expressive power of the language, it is customary to introduce an alternative test for equality, called value equality. This tests whether the values of two objects are equal regardless of whether their OIDs are distinct.

To illustrate, consider the three objects having Actor _ type: ( oid 50, [ name : “Martin”, citizenship : “French”, gender : “male”, award : { }, acts _ in : { oid 33}])
( oid 51, [ name : “Martin”, citizenship : “French”, gender : “male”, award : { }, acts _ in : { oid 33}])
( oid 52, [ name : “Martin”, citizenship : “French”, gender : “male”, award : { }, acts _ in : { oid 34}])
Then oid 50 and oid 51 are value equal, whereas oid 50 and oid 52 are not. Yet another form of equality is deep equality. If oid 33 and oid 34 are value equal, then oid 50 and oid 52 are deep equal. Intuitively, two objects are deep equal if the (possibly infinite) trees obtained by recursively replacing each object by its value are equal. The infinite trees that we obtain are called the expansions. They present some regularity; they are regular trees (see Exercise 21.10).

The notion of deep equality highlights a major difference between value-based and object-based models. In a value-based model (such as the relational or complex value 6 In this example, if name is a key for Actor, then one can easily obtain an equivalent query not using object equality; this may not be possible if there is no key for Actor.

558
Object Databases
models), the database can be thought of as a collection of (finite) trees. The connections between trees arise as a result of the contents of atomic fields. That is, they are implicit (e.g., the same string may appear twice). In the object-oriented world, a database instance can be thought of as graph. Paths in the database are more explicit. That is, one may view an ( oid, value) pair as a form of logical pointer and a path as a sequence of pointer dereferencing.

This graph-based perspective leads naturally to a navigational form of data access (e.g., using a sequence such as o ↑ . director ↑ . citizenship to find the citizenship of the director of a given movie object o). This has led some to view object-oriented models as less declarative than value-based models such as the relational model. This is inaccurate, because declarativeness is more a property of access languages than models. Indeed, the calculus for OODBs described here illustrates that a highly declarative language can be developed for the OODB model.

We conclude the discussion of the object-oriented calculus by incorporating methods. For this discussion, it is irrelevant how the methods are specified or evaluated; this evaluation is external to the query. The query simply uses the method invocations as oracles. Method resolution uses dynamic binding. The value of an expression of the form m(t1, . . . , tn) under a given variable assignment ν is obtained by evaluating (externally) the implementation of m for the class of ν(t1) on input ν(t1, . . . , tn). In this context, it is assumed that m has no side-effects. Although not defined formally here, the following illustrates the incorporation of methods into the calculus:
(21.3)
{y | ∃x(x ∈ Persons _ I _ like ∧ y = get _ name(x))}
If the set Persons_I_like contains Bergman and Liv Ullman, the answer would be
{“Ms. Ullman”, “Liv Ullman”}
The use of method names within the calculus raises a number of interesting typing and safety issues that will not be addressed here.

Object Creation and Completeness
Relational queries take relational instances as input and produce relational instances as output. The preceding calculus fails to provide the analogous capability because the output of a calculus query is a set of values or objects. Two features are needed for a query language to produce the full-fledged structural portion of an object-oriented instance: the ability to create OIDs, and the ability to populate a family of named values (rather than producing a single set).

We first introduce an extension of the while language of Chapter 14 that incorporates both of these capabilities. This language leads naturally to a discussion of completeness of OODB access languages. After this we mention a second approach to object creation that stems from the perspective of logic programming.

The extension of while introduced here is denoted while obj . It will create new OIDs in a manner reminiscent of how the language while new of Chapter 18 invented new constants.

21.3 Languages for OODB Queries
559
The language while obj incorporates object-oriented features such as dereferencing and method calls, as in the calculus. To illustrate, we present a while obj program that collects all actors reachable from an actor I like—Liv Ullman. In this query, v_ movies and v_ directors serve as variables, and reachable serves as a new name that will hold the output.

reachable := {x | x ∈ Actors _I _ like ∧ x ↑ . name = “Liv Ullman”}; v_ movies := { }; v_ directors := { };
while change do
begin
reachable := reachable ∪ {x | ∃y(y ∈ v_ movies ∧ x ∈ y ↑ . actors)}; v_ directors := v_ directors
∪ {x | ∃y(y ∈ v_ movies ∧ x ∈ y ↑ . director)};
v_ movies := v_ movies
∪{x | ∃y(y ∈ reachable ∧ x ∈ y ↑ . acts _ in)}
∪{x | ∃y(y ∈ v_ directors ∧ x ∈ y ↑ . directs)};
end;
We now introduce object creation. The operator new works as follows. It takes as input a set of values (or objects) and produces one new OID for each value in the set. As a simple example, suppose that we want to objectify the quadruples in the named value Pariscope of the schema of Fig. 21.1. This may be accomplished with the commands add _ class Pariscope _ obj
type tuple ( theater : Theater, time : string, price : integer, movie : Movie); Pariscope _ obj := new( Pariscope)
Of course, the new operator can be used in conjunction with arbitrary expressions that yield a set of values, not just a named value.

The new operator used here is closely related to the new operator of the language while new of Chapter 18. Given that while obj has iteration and the ability to create new OIDs, it is natural to ask about the expressive power of this language. To set the stage, we introduce the following analogue of the notion of (computable) query, which mimics the one of Chapter 18. The definition focuses on the structural portion of the OODB model; methods are excluded from consideration.

Definition 21.3.1
Let R and S be two OODB schemas with no method signatures. A determinate query is a relation Q from inst(R) to inst(S) such that (a) Q is computable;
(b) (Genericity) if I, J ∈ Q and ρ is a one-to-one mapping on constants, then ρ(I), ρ(J) ∈ Q;
(c) (Functionality) if I, J ∈ Q, and I, J′ ∈ Q, then J and J′ are OID isomorphic; and
(d) (Well defined) if I, J ∈ Q and I′, J′ is OID isomorphic to I, J, then I′, J′ ∈
Q.

A language is determinate complete (for OODBs) if it expresses exactly the determinate queries.

560
Object Databases
The essential difference between the preceding definition and the definition of determinate query in Chapter 18 is that here only OIDs can be created, not constants. Parts (c) and (d) of the definition ensure that a determinate query Q can be viewed as a function from OID equivalence classes of instances over R to OID equivalence classes of instances over S. So OIDs serve two purposes here: (1) They are used to compute in the same way that invented values were used to break the polynomial space barrier; and (2) they are now essential components of the data structure and in particular of the result. With respect to (2), an important aspect is that we are not concerned with the actual value of the OIDs, which motivates the use of the equivalence relation. (Two results are viewed as identical if they are the same up to the renaming of the OIDs.)

Like whilenew, whileobj is not determinate complete. There is an elegant characterization of the determinate queries expressible in whileobj. This result, which we state next, uses a local characterization of input-output pairs of whileobj programs. That characterization is in the spirit of the notion of bp-completeness, relating input-output pairs of relational calculus queries (see Exercise 16.11). For each input-output pair I, J , the characterization of whileobj queries requires a simple connection between the automorphism group of I and that of J . For an instance K, let Aut(K) denote the set of automorphisms of K. For a pair of instances K, K′, Aut(K, K′) denotes the bijections on adom(K ∪ K′) that are automorphisms of both K and K′.

Theorem 21.3.2
A determinate query q is expressible in whileobj iff for each input-output pair I, J in q there exists a mapping h from Aut(I ) to Aut(I, J ) such that for each τ, µ ∈ Aut(I ),
(i) τ and h(τ ) coincide on I ;
(ii) h(τ ◦ µ) = h(τ ) ◦ h(µ); and
(iii) h(idI ) = idI,J .

The “only if” part of the theorem is proven by an extension of the trace technique developed in the proof of Theorem 18.2.5 (Exercise 21.14). The “if” part is considerably more complex and is based on a group-theoretic argument.

A mapping h just shown is called an extension homomorphism from Aut(I ) to Aut(I, J ). To see an example of the usefulness of this characterization, consider the query q in Fig. 21.3. Recall that q was shown as not expressible in the language whilenew by Theorem 18.2.5. The language whileobj is more powerful than whilenew, so in principle it may be able to express that query. However, we show that this is not the case, so whileobj is not determinate complete.

Proposition 21.3.3
Query q (of Fig. 21.3) is not expressible in whileobj.

Proof
Let I, J be the input-output pair of Fig. 21.3. The proof is by contradiction.

Suppose there is a whileobj query that produces J on input I . By Theorem 21.3.2, there is an extension homomorphism h from Aut(I ) to Aut(I, J ). Let µ be the automorphism of I exchanging a and b. Note that µ−1 = µ, so µ ◦ µ = idI . Consider h(µ)(ψ0). Clearly, h(µ)(ψ0) ∈ {ψ1, ψ3}. Suppose h(µ)(ψ0) = ψ1 (the other case is similar). Then clearly,
21.3 Languages for OODB Queries
561
ψ3
{ a, b} ⇒
ψ0
b
ψ2
a
ψ1
Figure 21.3:
A query not expressible in whileobj
h(µ)(ψ1) = ψ2. Consider now h(µ ◦ µ)(ψ0). We have, on one hand,
h(µ ◦ µ)(ψ0) = (h(µ) ◦ h(µ))(ψ0)
= h(µ)(ψ1)
= ψ2
and on the other hand
h(µ ◦ µ)(ψ0) = h(idI )(ψ0)
= idI,J(ψ0)
= ψ0,
which is a contradiction because ψ0 "= ψ2. So q is not expressible in whileobj.

It is possible to obtain a language expressing all determinate queries by adding to whileobj a choose operator that allows the selection (nondeterministically but in a determinate manner) of one object out of a set of objects that are isomorphic (see Exercise 18.14).

However, this is a highly complex construct because it requires the ability to check for isomorphism of graphs. The search for simpler, local constructs that yield a determinate-complete language is an active area of research.

A Logic-Based Approach to Object Creation
We now briefly introduce an alternative approach for creating OIDs that stems from the perspective of datalog and logic programming. Suppose that a new OID is to be created for each pair t, m, where movie m is playing at theater t according to the current value of Pariscope. Consider the following dataloglike rule:
1. create _ tm _ object(x, t, m ) ← Pariscope(t, s, m ) Note that x occurs in the rule head but not in the body, so the rule is not safe. Intuitively, we would like to attach semantics to this rule so that a new OID is associated to x for each
562
Object Databases
distinct pair of (t, m) values. Using the symbol ∃! to mean “exists a unique,” the following versions of (1) intuitively captures the semantics.

2. ∀t∀m∃!x∀s[ create _ tm _ object(x, t, m ) ← Pariscope(t, s, m )]
3. ∀t∀m∃!x[ create _ tm _ object(x, t, m ) ← ∃s( Pariscope(t, s, m ))]
This suggests that Skolem functions might be used. Specifically, let ftm be a function symbol associated with the predicate create _ tm _ object. We rewrite (2) as
∀t∀m∀s[ create _ tm _ object(ftm(t, m), t, m) ← Pariscope(t, s, m )]
or, leaving off the universal quantifiers as traditional in datalog, 4. create _ tm _ object(ftm(t, m), t, m) ← Pariscope(t, s, m ) Under this approach, the Skolem terms resulting from rule (4) are to be interpreted as new, distinct OIDs. Under some formulations of the approach, syntactic objects such as ftm( oid 7, oid 22) (where oid 7 is the OID of some theater and oid 22 the OID of some movie) serve explicitly as OIDs. Under other formulations, such syntactic objects are viewed as placeholders during an intermediate stage of query evaluation and are (nondeterministically) replaced by distinct new OIDs in the final stage of query evaluation (see Exercise 21.13).

The latter approach to OID creation, incorporated into complex value datalog extended to include also OID dereferencing, yields a language equivalent to while obj . As with while obj , this language is not determinate complete.

A Practical Language for OODBs
We briefly illustrate some object-oriented features of the language O2SQL, which was introduced in Section 20.8. Several examples are presented there, that show how O2SQL
can be used to access and construct deeply nested complex values. We now indicate how the use of objects and methods is incorporated into the language. It is interesting to note that methods and nested complex values are elegantly combined in this language, which has the appearance of SQL but is essentially based on the functional programming paradigm.

For this example, we again assume the complex value Films of Fig. 20.2, but we assume that Age is a method defined for the class Person (and thus for Director).

select tuple (f.Director, f.Director.Age)
from f in Films
where f.Director not in flatten select m.Actors
from g in Films,
m in g.Movies
where g.Director = “Hitchcock”
(Recall that here the inner select- from- where clause returns a set of sets of actors. The keyword flatten has the effect of forming the union of these sets to yield a set of actors.)

21.4 Languages for Methods
563
21.4
Languages for Methods
So far, we have used an abstraction of methods (their signature) and ignored their implementations. In this section, we present two abstract programming languages for specifying method implementations. Method implementations will be included in the specification of methods in OODB schemas. In studying these languages, we emphasize two important issues: type safety and expressive power. This focus largely motivates our choice of languages and the particular abstractions considered.

The first language is an imperative programming language. The second, method schemas, is representative of a functional style of database access. In the first language, we will gather a number of features present in practical object-oriented database languages (e.g., side-effect, iteration, conditionals). We will see that with these features, we get (as could be expected) completeness, and we pay the obvious price for it: the undecidability of many questions, such as type safety. With method schemas, we focus on the essence of inheritance and methods. We voluntarily consider a limited language. We see that the undecidability of type safety is a consequence of recursion in method calls. (We obtain decidability in the restricted case of monadic methods.) With respect to expressiveness, we present a surprising characterization of qptime in terms of a simple language with methods.

For both languages, we study type safety and expressive power. We begin by discussing briefly the meaning of these notions in our context, and then we present the two languages and the results.

An OODB schema S (with method implementations assigned to signatures) is type safe if for each instance I of S and each syntactically correct method call on I, the execution of this method does not result in a runtime type error (an illegal method call). When the imperative programming language is used in method implementations, type safety is undecidable. (It is possible, however, to obtain decidable sufficient conditions for type safety.) For method schemas, type safety remains undecidable. Surprisingly, type safety is decidable for monadic method schemas.

To evaluate the expressive power of OODB schemas using a particular language for method implementation, a common approach is to simulate relational queries and then ask what family of relational queries can be simulated. If OID creation is permitted, then all computable relational queries can be simulated using the imperative language. The expressive power of imperative methods without OID creation depends on the complex types permitted in OODB schemas. We also present a result for the expressive power of method schemas, showing that the family of method schemas using an ordered domain of atomic elements expresses exactly qptime.

A Model with Imperative Methods
To consider the issue of type safety in a general context, we present the imperative (OODB) model, which incorporates imperative method implementations. This model simplifies the OODB model presented earlier by assuming that the type of each class is a tuple of values and OIDs. However, a schema in this model will include an assignment of implementations to method signatures.

564
Object Databases
The syntax for method implementations is
par: u1, . . . , un;
var: x1, . . . , xl;
body: s1; . . . ; sq;
return x1
where the ui’s are parameters (n ≥ 1), the xj ’s are internal variables (l ≥ 1), and for each p ∈ [1, q], sp is a statement of one of the following forms (where w, y, z range over parameters and internal variables):
Basic operations
(i) w := self.

(ii) w := self. a for some field name a.

(iii) w := y.

(iv) w := m (y, . . . , z), for some method name m.

(v) self. a := w, for some field name a.

Class operations
(vi) w := new(c), where c is a class.

(vii) delete(c, w), where c is a class.

(viii) for each w in c do s′ ; . . . ; s′ end, where c is a class and s′ , . . . , s′ are statements 1
t
1
t
having forms from this list.

Conditional
(ix) if yθ z then s, where θ is = or "= and s is a statement having a form in this list except for the conditional.

It is assumed that all internal variables are initialized before used to some default value depending on their type. The intended semantics for the forms other than (viii) should be clear. (Here clear does not mean “easy to implement.” In particular, object deletion is complex because all references to this object have to be deleted.) The looping construct executes for each element of the extension (not disjoint extension) of class c. The execution of the loop is viewed as nondeterministic, in the sense that the particular ordering used for the elements of c is not guaranteed by the implementation. In general, we focus on OODB
schemas in which different orders of execution of the loops yield OID-equivalent results (note, however, that this property is undecidable, so it must be ensured by the programmer).

An imperative schema is a 6-tuple S = (C, σ, ≺, M, G, µ), where (C, σ, ≺, M, G) is a schema as before; where the range of σ is tuples of atomic and class types; and where µ
is an assignment of implementations to signatures. The notion of instance for this model is defined in the natural fashion.

It is straightforward to develop operational semantics for this model, where the execution of a given method call might be successful, nonterminating, or aborted (as the result of a runtime type error) (Exercise 21.15a).

21.4 Languages for Methods
565
Type Safety in the Imperative Model
There are two ways that a runtime type error can
arise: (1) if the type of the result of an execution of method m does not lie within the type specified by the relevant method signature of m; or (2) if a method is called on a tuple of parameters that does not satisfy the domain part of the appropriate signature of m. We assume that the range of all method signatures is any, and thus we focus on case (2).

A schema S is type safe if for each instance over S and each m(o, v1, . . . , vn) method call that satisfies the signature of m associated with the class of o, execution of this call is either successful or nonterminating.

Given a Turing machine M, it is easy to develop a schema S in this model that can simulate the operation of M on a suitable encoding of an input tape (Exercise 21.15c). This shows that such schemas are computationally powerful and implies the usual undecidability results. With regard to type safety, it is easy to verify the following (Exercise 21.16): Proposition 21.4.1
It is undecidable, given an imperative schema S, whether S is type safe. This remains true, even if in method implementations conditional statements and the new operator are prohibited and all methods are monadic (i.e., have only one argument).

A similar argument can be used to show that it is undecidable whether a given method terminates on all inputs. Finally, a method m′ on class c′ is reachable from method m on class c in OODB schema S if there is some instance I of S and some tuple o, v1, . . . with o in c such that the execution of m(o, v1, . . .) leads to a call of m′ on some object in c′.

Reachability is also undecidable for imperative schemas.

Expressive Power of the Imperative Model
As discussed earlier, we measure the expressive power of OODB schemas in terms of the relational queries they can simulate. A relational schema R = {R1, . . . , Rn} is simulated by an OODB schema S of this model if there are leaf classes c1, . . . , cn in S, where the number of attributes of ci is the arity of Ri for i ∈ [1, n] and where the type of each of these attributes is atomic. We focus on instances in which no null values appear for such attributes. Let R be a relational schema and S be an OODB schema that simulates R. An instance I of R is simulated by instance J of S if for each tuple *
v ∈ I(Ri) there is exactly
one object o in the extension of ci such that the value associated with o is *v and all other classes of S are empty. Following this spirit, it is straightforward to define what it means for a method call in schema S to simulate a relational query from R to relation schema R.

We consider only schema S for which different orders of evaluation of the looping construct yield the same final result (i.e., generic mappings). We now have the following (see Exercise 21.20):
Theorem 21.4.2
The family of generic queries corresponding to imperative schemas
coincides with the family of all relational queries.

The preceding result relies on the presence of the new operator. It is natural to ask about the expressive power of imperative schemas that do not support new. As discussed in Exercise 21.21, the expressive power depends on the complex types permitted for objects.

566
Object Databases
Note also that imperative schemas can express all determinate queries. This uses the nondeterminism of the for each construct. Naturally, nondeterministic queries that are not determinate can also be expressed.

Method Schemas
We now present an abstract model for side-effect-free methods, called method schemas.

In this model, we focus almost exclusively on methods and their implementations. Two kinds of methods are distinguished: base and composite. The base methods do not have implementations: Their semantics is specified explicitly at the instance level. The implementations of composite methods consist of a composition of other methods.

We now introduce method schemas. In the next definition, we make the simplifying assumption that there are no named values (only class names) in database schemas. In fact, data is only stored in base methods. In the following, σ[ ] denotes the type assignment σ[ ](c) = [ ] for every class c. Because the type assignment provides no information in method schemas (it is always σ[ ]), this assignment is not explicitly specified in the schemas.

Definition 21.4.3
A method schema is a 5-tuple S = (C, ≺, M base, M comp, µ), where (C, σ[ ], ≺) is a well-formed class hierarchy, M base ∪ M comp is a well-formed set of method signatures for (C, σ[ ], ≺), and
• no method name occurs in both M base and M comp;
• each method signature in M comp is of the form m : c1, . . . , cn → any (method signatures for M base are unrestricted, i.e., can have any class as range);
• µ is an assignment of implementations to the method signatures of M comp, as follows: For a signature m : c1, . . . , cn → any in M comp, µ(m : c1, . . . , cn → any) is a term obtained by composing methods in M base and M comp.

An example of an implementation for a method m : c1, c2 → any is m(x, y) ≡ m1(m2(x), m1(x, y)).

The semantics of methods is defined in the obvious way. For instance, to compute m(o, o′), one computes first o1 = m2(o) and then o2 = m1(o, o′); the result is m1(o1, o2). The range of composite methods is left unspecified (it is any) because it is determined by the domain and the method implementation as a composition of methods. Because the range of composite methods is always any, we will sometimes only specify their domain.

Let S = (C, ≺, M base, M comp, µ) be a method schema. An instance of S is a pair I = (π, ν), where π is an OID assignment for (C, ≺) and where ν assigns a semantics to the base methods. Note the difference from the imperative schemas of the previous section, where π together with the method implementations was sufficient to determine the semantics of methods. In contrast, the semantics of the base methods must be specified in instances of method schemas.

21.4 Languages for Methods
567
Inheritance of method implementations for method schemas is defined slightly differently from that for the OODB model given earlier. Specifically, given an n-ary method m and invocation m(o1, . . . , on), where oi is in disjoint class ci for i ∈ [1, n], the implementation for m is inherited from the implementation of signature m : c′ , . . . , c′ → c′, where this 1
n
is the unique signature that is pointwise least above c1, . . . , cn. [Otherwise m is undefined on input (o1, . . . , on).]
An important special case is when methods take just one argument. Method schemas using only such methods are called monadic. To emphasize the difference, unrestricted method schemas are sometimes called polyadic.

Example 21.4.4
Consider the following monadic method schema. The classes in the
schema are
class c
class c′ ≺ c
The base method signatures are
method m1 : c → c′
method m2 : c → c
method m2 : c′ → c′
method m3 : c′ → c
The composite method definitions are
method m : c = m2(m2(m1(x)))
method m′ : c = m3(m′(m2(x)))
method m′ : c′ = m1(x)
Note that m′ is recursive and that calls to m′ on elements in c′ break the recursion.

Type Safety for Method Schemas
As before, a method schema S is type safe if for each instance I of S no method call on I leads to a runtime type error.

The following example demonstrates that the schema of Example 21.4.4 is not type safe. Note how the interpretation ν for base methods can be viewed as an assignment of values for objects.

Example 21.4.5
Recall the method schema of Example 21.4.4. An instance of this is
I = (π, ν), where7
π(c) = {p, q}
π(c′) = {r}
7 We write ν(m1)(p) rather than ν(m1, c)(p) to simplify the presentation.

568
Object Databases
and
ν(m1)(p) = r
ν(m2)(p) = q
ν(m1)(q)l = ⊥
ν(m2)(q) = r
ν(m3)(r) = p.

ν(m1)(r) = r
ν(m2)(r) = r
Consider the execution of m(p). This calls for the computation of m2(m2(m1(p))) =
m2(m2(r)) = r. Thus the execution is successful. On the other hand, m′(p) leads to a runtime type error: m′(p) = m3(m′(m2(p))) = m3(m′(q)) = m3(m3(m′(m2(q)))) =
m3(m3(m′(r))) = m3(m3(m1(r))) = m3(m3(r)) = m3(p), which is undefined and raises a runtime type error. Thus the schema is not type safe.

It turns out that type safety of method schemas permitting polyadic methods is undecidable (Exercise 21.19). Interestingly, type safety is decidable for monadic method schemas. We now sketch the proof of this result.

Theorem 21.4.6
It is decidable in polynomial time whether a monadic method schema
is type safe.

Crux
Let S = (C, ≺, M base, M comp, µ) be a monadic method schema. We construct a context-free grammar (see Chapter 2) that captures possible executions of a method call over all instances of S. The grammar is GS = (Vn, Vt, A, P ), where the set Vt of terminals is the set of base method names (denoted N base) along with the symbols { error, ignore}, and the set Vn of nonterminals includes start symbol A and
{[c, m, c′] | c, c′ are classes, and m is a method name}
The set P of production rules includes
(i) A → [c, m, c′], if m is a composite method name and it is defined at c or a superclass of c.

(ii) [c, m, c′] → error, if m is not defined at c or a superclass of c.

(iii) [c, m, c′] → m, if m is a base method name, the resolution of m for c is m : c1 →
c2, and c′ ≺ c2. (Note that c′ = c2 is just a particular case.)

(iv) [c, m, c] → ǫ, if m is a composite method name and the resolution of m for c is the identity mapping.

(v) [c, m, cn] → [c, m1, c1][c1, m2, c2] . . . [cn−1, mn, cn], if m is a composite method, m on c resolves to a method with implementation mn(mn−1(. . . (m2
(m1(x))) . . .)), and c1, . . . , cn are arbitrary classes.

(vi) [c, m, c′] → ignore, for all classes c, c′ and method names m.

Given a successful execution of a method call m(o), it is easy to construct a word in L(GS) of the form m1 . . . mn, where the mi’s list the sequence of base methods called during the execution. On the other hand, if the execution of m(o) leads to a runtime error, a word of the form m1 . . . mi error . . . can be formed. The terminal ignore can be used in cases where
21.4 Languages for Methods
569
a nonterminal [c, m, c′] arises, such that m is a base method name and c′ is outside the range of m for c. The productions of type (vi) are permitted for all nonterminals [c, m, c′], although they are needed only for some of them.

It can be shown that S is type safe iff
L(GS) ∩ N ∗ error V ∗ = ∅.

base
t
Because it can be tested if the intersection of a context-free language with a regular language is empty, the preceding provides an algorithm for checking type safety. However, a modification of the grammar GS is needed to obtain the polynomial time test (see Exercise 21.18).

Expressive Power of Method Schemas
We now argue that method schemas (with or-
der) simulate precisely the relational queries in qptime. The object-oriented features are not central here: The same result can be shown for functional data models without such features.

As for imperative schemas, we show that method schemas can simulate relational queries. The encoding of these queries assumes an ordered domain, as is traditional in the world of functional programming.

A relational database is encoded as follows:
(a) a class elem contains objects representing the elements of the domain, and it has zero as a subclass containing a unique element, say 0;
(b) a function pred, which is included as a base method,8 provides the predecessor function over elem ∪ zero [ pred(0) is, for instance, 0]; a base method 0 returns the least element and another base method N the largest object in elem; (c) to have the Booleans, we think of 0 as the value false and all objects in elem as representations of true;
(d) an n-ary relation R is represented by an n-ary base method mR of signature mR : elem, . . . , elem → elem, the characteristic function of R. [For a tuple t, mR(t) is true iff t is in R.]
Next we represent queries by composite methods. A query q is computed by method mq if mq(t) is true (not in zero) iff t is in the answer to query q.

The following illustrates how to compute with this simple language.

Example 21.4.7
Consider relation R with R = {R(1, 1), R(1, 2)}. The class zero is populated with the object 0 and the class elem with 1, 2. The base method pred is defined by pred(2) = 1, pred(0) = pred(1) = 0. The base method mR is defined by mR(1, 1) =
mR(1, 2) = 1 and mR(x, y) = 0 otherwise.

8 The function pred is a functional analog of the relation succ, which we have assumed is available in every ordered database (a successor function could also have been used).

570
Object Databases
Recall that each object in class elem is viewed as true and object 0 as false. We can code the Boolean function and as follows:
for x, y in
zero, zero
and(x, y) ≡ 0
for x, y in
elem, zero
and(x, y) ≡ 0
for x, y in
zero, elem
and(x, y) ≡ 0
for x, y in
elem, elem
and(x, y) ≡ N.

The other standard Boolean functions can be coded similarly. We can code the intersection between two binary relations R and S with and(mR(x, y), mS(x, y)). As a last example, the projection of a binary relation R over the first coordinate can be coded by a method πR,1 defined by
πR,1 ≡ m(x, N ),
where m is given by
for x, y in
elem, zero
m(x, y) ≡ mR(x, y)
for x, y in
elem, elem
m(x, y) ≡ or(mR(x, y), m(x, pred(y))).

We now state the following:
Theorem 21.4.8
Method schemas over ordered databases express exactly qptime.

Crux
As indicated in the preceding example, we can construct composite methods for the Boolean operations and, or, and not. For each k, we can also construct k k-ary functions pred i for i ∈ [1, k] that compute for each k tuple u the k components of the predecessor (in k
lexicographical ordering) of u. Indeed, we can simulate an arbitrary relational operation and more generally an arbitrary inflationary fixpoint. To see this, consider the transitive closure query. It is computed with a method tc defined (informally) as follows. Intuitively, a method tc(x, y) asks, “Is x, y in the transitive closure?” Execution of tc(x, y) first calls a method m1(x, y, N), whose intuitive meaning is “Is there a path of length N from x to y?”
This will be computed by asking whether there is a path of length N − 1 (a recursive call to m1), etc. This can be generalized to a construction that simulates an arbitrary inflationary fixpoint query. Because the underlying domain is ordered, we have captured all qptime queries. The converse follows from the fact that there are only polynomially many possible method calls in the context of a given instance, and each method call in this model can be answered in qptime. Moreover, loops in method calls can be detected in polynomial time; calls giving rise to loops are assumed to output some designated special value. (See Exercise 21.25.)

We have presented an object-oriented approach in the applicative programming style.

There exists another important family of functional languages based on typed λ calculi.

It is possible to consider database languages in this family as well. These calculi present
21.5 Further Issues for OODBs
571
additional advantages, such as being able to treat functions as objects and to use higher-order functions (i.e., functions whose arguments are functions).

21.5
Further Issues for OODBs
As mentioned at the beginning of this chapter, the area of OODB is relatively young and active. Much research is needed to understand OODBs as well as we understand relational databases. A difficulty (and richness) is that there is still no well-accepted model. We conclude this chapter with a brief look at some current research issues for OODBs. These fall into two broad categories: advanced modeling features and dynamic aspects.

Advanced Modeling Features
This is not an exhaustive list of new features but a sample of some that are being studied: Views: Views are intended to increase the flexibility of database systems, and it is natural to extend the notion of relational view to the OODB framework. However, unlike relational views, OODB views might redefine the behavior of objects in addition to restructuring their associated types. There are also significant issues raised by the presence of OIDs. For example, to maintain incrementally a materialized view with created OIDs, the linkage between the base data and the created OIDs must be maintained.

Furthermore, if the view is virtual, then how should virtual OIDs be specified and manipulated?

Object roles: The same entity may be involved in several roles. For instance, a director may also be an actor. It is costly, if not infeasible, to forecast all cases in which this may happen. Although not as important in object-oriented programming, in OODBs it would be useful to permit the same object to live in several classes (a departure from the disjoint OID assignment from which we started) and at least conceptually maintain distinct repositories, one for each role. This feature is present in some semantic data models; in the object-oriented context, it raises a number of interesting typing issues.

Schema design: Schema design techniques (e.g., based on dependencies and normal forms) have emerged for the relational model (see Chapter 11). Although the richer model in the OODB provides greater flexibility in selecting a schema, there is a concomitant need for richer tools to facilitate schema design. The scope of schema design is en-larged in the OODB context because of the interaction of methods within a schema and application software for the schema.

Querying the schema: In many cases, information may be hidden in an OODB schema.

Suppose, for example, that movies were assigned categories such as “drama,” “west-ern,” “suspense,” etc. In the relational model, this information would typically be represented using a new column in the Movies relation. A query such as “list all categories of movie that Bergman directed” is easily answered. In an OODB, the category information might be represented using different subclasses of the Movie class. Answering this query now requires the ability of the query language to return class names, a feature not present in most current systems.

572
Object Databases
Classification: A related problem concerns how, given an OODB schema, to classify new data for this schema. This may arise when constructing a view, when merging two databases, or when transforming a relational database into an OODB one by objectifying tuples. The issue of classification, also called taxonomic reasoning, has a long history in the field of knowledge representation in artificial intelligence, and some research in this direction has been performed for semantic and object-oriented databases.

Incorporating deductive capabilities: The logic-programming paradigm has offered a tremendous enhancement of the relational model by providing an elegant and (in many cases) intuitively appealing framework for expressing a broad family of queries.

For the past several years, researchers have been developing hybrids of the logic-programming and object-oriented paradigms. Although it is very different in some ways (because the OO paradigm has fundamentally imperative aspects), the perspective of logic programming provides alternative approaches to data access and object creation.

Abstract data types: As mentioned earlier, OODB systems come equipped with several constructors, such as set, list, or bag. It is also interesting to be able to extend the language and the system with application-specific data types. This involves language and typing issues, such as how to gracefully incorporate access mechanisms for the new types into an existing language. It also involves system issues, such as how to introduce appropriate indexing techniques for the new type.

Dynamic Issues
The semantics of updates in relational systems is simple: Perform the update if the result complies with the dependencies of the schema. In an OODB, the issue is somewhat trickier.

For instance, can we allow the deletion of an object if this object is referred to somewhere in the database (the dangling reference problem)? This is prohibited in some systems, whereas other systems will accept the deletion and just mark the object as dead. Semantically, this results in viewing all references to this object as nil.

Another issue is object migration. It is easy to modify the value of an object. But changing the status of an object is more complicated. For example, a person in the database may act in a movie and overnight be turned into an actor. In object-oriented programming languages, objects are often not allowed to change classes. Although such limitations also exist in most present OODBs, object migration is an important feature that is needed in many database applications. One approach, followed by some semantic data models, is to permit objects to be associated with multiple classes or roles and also permit them to migrate to different classes over time. This raises fundamental issues with regard to typing.

For example, how do we treat a reference to the manager of a department (that should be of type Employee) when he or she leaves the company and is turned into a “normal” person?

Finally, as with the relational model, we need to consider evolution of the schema itself. The OODB context is much richer than the relational, because there are many more kinds of changes to consider: the class hierarchy, the type of a class, additions or deletions of methods, etc.

Bibliographic Notes
573
Bibliographic Notes
Collections of papers on object-oriented databases can be found in [BDK92, KL89, ZM90].

The main characteristics of object-oriented database systems are described in [ABD+89].

An influential discussion of some foundational issues around the OODB paradigm is
[Bee90]. An important survey of subtyping and inheritance from the perspective of programming languages, including the notion of domain-inclusion semantics, is [CW85].

Object-oriented databases are, of course, closely related to object-oriented programming languages. The first of these is Smalltalk [GR83], and C++ [Str91] is fast becoming the most widely used object-oriented programming language. Several commercial OODBs are essentially persistent versions of C++. Several object-oriented extensions of Lisp have been proposed; the article [B+86] introduces a rich extension called CommonLoops and surveys several others.

There have been a number of approaches to provide a formal foundation [AK89, Bee90, HTY89, KLW93] for OODBs. We can also cite as precursors attempts to formalize semantic data models [AH87] and object-based models [KV84, HY84]. Recent graph-oriented models, although they do not stress object orientation, are similar in spirit (e.g.,
[GPG90]).

The generic OODB model used here is directly inspired from the IQL model [AK89]
and that of O2 [BDK92, LRV88]. The model and results on imperative method implementations are inspired by [HTY89, HS89a]. A similar model of imperative method implementation, which avoids nondeterminism and introduces a parallel execution model, is developed in [DV91]. Method schemas and Theorem 21.4.6 are from [AKRW92]; the functional perspective and Theorem 21.4.8 are from [HKR93].

OIDs have been part of many data models. For example, they are called surrogates in
[Cod79], l-values in [KV93a], or object identifiers in [AH87]. The notion of object and the various forms of equalities among objects form the topic of [KC86]. Type inheritance and multiple inheritance are studied in [CW85, Car88].

Since [KV84], various languages for models with objects have been proposed in the various paradigms: calculus, algebra, rule based, or functional. Besides standard features found in database languages without objects, the new primitives are centered around object creation. Language-theoretic issues related to object creation were first considered in the context of IQL [AK89]. Object creation is an essential component of IQL and is the main reason for the completeness of the language. The need for a primitive in the style of copy elimination to obtain determinate completeness was first noticed in [AK89]. The IQL
language is rule based with an inflationary fixpoint semantics in the style of datalog¬ of Chapter 14.

The logic-based perspective on object creation based on Skolem was first informally discussed in [Mai86] and refined variously in [CW89a, HY90, KLW93, KW89]. In particular, F-logic [KLW93] considers a different approach to inheritance. In our framework, the classification of objects is explicit; in particular, when an object is created, it is within an explicit class. In [KLW93], data organization is also specified by rules and thus may depend on the properties of the objects involved. For instance, reasoning about the hierarchy becomes part of the program.

Algebraic and imperative approaches to object creation are developed in [Day89].

574
Object Databases
Since then, object creation has been the center of much interesting research (e.g., [DV93, HS89b, HY92, VandBG92, VandBGAG92, VandB93]). The characterization of queries expressible in whileobj (Theorem 21.3.2) is from [VandBG92]; this extends a previous result from [AP92]. The proof of Proposition 21.3.3 is also from [VandBGAG92]. In [VandBGAG92, VandB93], it is argued that the notion of determinate query may not be the most appropriate one for the object-based context, and alternative notions, such as semide-terministic queries, are discussed. A tractable construct yielding a determinate-complete language is exhibited in [DV93]. However, the construct proposed there is global in nature and is involved. The search for simpler and more natural local constructs continues.

As mentioned earlier, the OODB calculus and algebra presented here are mostly variations of languages for non object-based models and, in particular, of the languages for complex values of Chapter 20. There have been several proposals of SQL extensions.

In particular, as indicated in Section 21.3, O2SQL [BCD89] retains the flavor of SQL but incorporates object orientation by adopting an elegant functional programming style. This approach has been advanced as a standard in [Cat94].

Functional approaches to databases have been considered rather early but attracted only modest interest in the past [BFN82, Shi81]. The functional approach has become more popular recently, both because of the success of object-oriented databases and due to recent results of complex objects and types emphasizing the functional models [BTBN92, BTBW92]. The use of a typed functional language similar to λ calculus as a formalism to express queries is adapted from [HKM93]. Characterizations of qptime in functional terms are from [HKM93, LM93]. The work in [AKRW92, HKM93, HKR93] provides interesting bridges between (object-oriented) databases and well-developed themes in computer science: applicative program schemas [Cou90, Gre75] and typed λ calculi [Chu41, Bar84, Bar63].

This chapter presented both imperative and functional perspectives on OODB methods. A different approach (based on rules and datalog with negation) has been used in
[ALUW93] to provide semantics to a number of variations of schemas with methods. The connection between methods and rule-based languages is also considered in [DV91].

Views for OODBs are considered in [AB91, Day89, HY90, KKS92, KLW93]. The merging of OODBs is considered in [WHW90]. Incremental maintenance of materialized object-oriented views is considered in [Cha94]. The notion of object roles, or sharing objects between classes, is found in some semantic data models [AH87, HK87] and in recent research on OODBs [ABGO93, RS91]. A query language that incorporates access to an OODB schema is presented in [KKS92]. Classification has been central to the field of knowledge representation in artificial intelligence, based on the central notion of taxonomic reasoning (e.g., see [BGL85, MB92], which stem from the KL-ONE framework of
[BS85]); this approach has been carried to the context of OODBs in, for example, [BB92, BS93, BBMR89, DD89]. Deductive object-oriented database is the topic of a conference (namely, the Intl. Conf. on Deductive and Object-Oriented Databases). Properties of object migration between classes in a hierarchy are studied in [DS91, SZ89, Su92].

Exercises
575
Exercises
Exercise 21.1
Construct an instance for the schema of Fig. 21.1 that corresponds to the CINEMA instance of Chapter 3.

Exercise 21.2
Suppose that the class Actor_Director were removed from the schema of Fig. 21.1. Verify that in this case there is no OID assignment for the schema such that there is an actor who is also a director.

Exercise 21.3
Design an OODB schema for a bibliography database with articles, book chapters, etc. Use inheritance where possible.

Exercise 21.4
Exhibit a class hierarchy that is not well formed.

Exercise 21.5
Add methods to the schema of Fig. 21.1 so that the resulting family of methods violates rules unambiguous and covariance.

Exercise 21.6
Show that testing whether I ≡ OID J is in np and at least at hard as the graph isomorphism problem (i.e., testing whether two graphs are isomorphic).

Exercise 21.7
Give an algorithm for testing value equality. What is the data complexity of your algorithm?

Exercise 21.8
In this exercise, we consider various forms of equality. Value equality as discussed in the text is denoted =1. Two objects o, o′ are 2-value equal, denoted o =2 o′, if replacing each object in ν(o) and ν(o′) by its value yields values that are equal. The relations =i for each i are defined similarly. Show that for each i, =i+1 refines =i. Let n be a positive integer.

Give a schema and an instance over this schema such that for each i in [1, n], =i and =i+1 are different.

Exercise 21.9
Design a database schema to represent information about persons, including males and females with names and husbands and wives. Exhibit a cyclic instance of the schema and an object o that has an infinite expansion. Describe the infinite tree representing the expansion of o.

⋆ Exercise 21.10 Consider a database instance I over a schema S. For each o in I, let expand(o) be the (possibly infinite) tree obtained by replacing each object by its value recursively. Show that expand(o) is a regular tree (i.e., that it has a finite number of distinct subtrees). Derive from this observation an algorithm for testing deep equality of objects.

Exercise 21.11
In this exercise, we consider the schema S with a single class c that has type σ (c) = [A : c, B : string]. Exhibit an instance I over S and two distinct objects in I that have the same expansion. Exhibit two distinct instances over S with the same set of object expansions.

Exercise 21.12
Sketch an extension of the complex value algebra to provide an algebraic simulation of the calculus of Section 21.3. Give algebraic versions of the queries of that section.

♠ Exercise 21.13 Recall the approach to creating OIDs by extending datalog to use Skolem function symbols. Consider the following programs:
T (f1(x, y), x) ← S(x, y)
T (f3(x, y), x) ← S(x, y)
T (f2(x, y), x) ← S(x, y)
T (f3(y, x), x) ← S(x, y)
T (f1(x, y), y) ← S(x, y), S(y, x)
T (f4(x, y), x) ← S(x, y), S(y, x)
P
Q
576
Object Databases
(a) Two programs P1, P2 involving Skolem terms such as the foregoing are exposed equivalent, denoted P1 ∼ exp P2, if for each input instance I having no OIDs, P1(I) =
P2(J). Show that P ∼ exp Q does not hold.

(b) Following the ILOG languages [HY92], given an instance J possibly with Skolem terms, an obscured version of J is an instance J′ obtained from J by replacing each distinct nonatomic Skolem term with a new OID, where multiple occurrences of a given Skolem term are replaced by the same OID. (Intuitively, this corresponds to hiding the history of how each OID was created.) Two programs P1, P2 are obscured equivalent, denoted P1 ∼ obs P2, if for each input instance I having no OIDs, if J1 is an obscured version of P1(I) and J2 is an obscured version of P2(I), then J1 ≡ OID J2.

Show that P ∼ obs Q.

(c) Let P and Q be two nonrecursive datalog programs, possibly with Skolem terms in rule heads. Prove that it is decidable whether P ∼ exp Q. Hint: Use the technique for testing containment of unions of conjunctive queries (see Chapter 4).

⋆ (d) A nonrecursive datalog program with Skolem terms in rule heads has isolated OID
invention if in each target relation at most one column can include nonatomic Skolem terms (OID). Give a decision procedure for testing whether two such programs are obscured equivalent. (Decidability of obscured equivalence of arbitrary nonrecursive datalog programs with Skolem terms in rule heads remains open.)

♠ Exercise 21.14 [VandBGAG92] Prove the “only if” part of Theorem 21.3.2. Hint: Associate traces to new object id’s, similar to the proof of Theorem 18.2.5. The extension homomorphism is obtained via the natural extension to traces of automorphisms of the input.

Exercise 21.15
[HTY89]
(a) Define an operational semantics for the imperative model introduced in Section 21.4.

(b) Describe how a method in this model can simulate a while loop of arbitrary length.

Hint: Use a class c with associated type tuple(a : c, . . .), and let c′ ≺ c. Construct the implementation of method m on c so that on input o if the loop is to continue, then it creates a new object o′ in c, sets o.a = o′, and calls m on o′. To terminate the loop, create o′ in c′, and define m on c′ appropriately.

(c) Show how the computation of a Turing machine can be simulated by this model.

Exercise 21.16
Prove Proposition 21.4.1. Hint: Use a reduction from the PCP problem, similar in spirit to the one used in the proof of Theorem 6.3.1. The effect of conditionals can be simulated by putting objects in different classes and using dynamic binding.

Exercise 21.17
Describe how monadic method schemas can be simulated in the imperative model.

Exercise 21.18
[AKRW92]
(a) Verify that the grammar GS described in the proof of Theorem 21.4.6 has the stated property.

(b) How big is GS in terms of S?

(c) Find a variation of GS that has size polynomial in the size of S. Hint: Break production rules having form (v) into several rules, thereby reducing the overall size of the grammar.

Exercises
577
(d) Complete the proof of the theorem.

Exercise 21.19
[AKRW92]
⋆ (a) Show that it is undecidable whether a polyadic method schema is type safe. Hint: You might use undecidability results for program schemas (see Bibliographic Notes), or you might use a reduction from the PCP.

⋆ (b) A schema is recursion free if there are no two methods m , m ′ such that m occurs in some code for m′ and conversely. Show that type safety is decidable for recursion-free method schemas.

Exercise 21.20
(a) Complete the formal definition of an imperative schema simulating a relational query.

(b) Prove Theorem 21.4.2.

♠ Exercise 21.21
(a) Suppose that the imperative model were extended to include types for classes that have one level of the set construct (so tuple of set of tuple of atomic of class types is permitted) and that the looping construct is extended to the sets occurring in these types. Assume that the new command is not permitted. Prove that the family of relational queries that this model can simulate is qpspace. Hint: Intuitively, because the looping operates object at a time, it permits the construction of a nondeterministic ordering of the database.

(b) Suppose that n levels of set nesting are permitted in the types of classes. Show that this simulates qexpn−1space.

Exercise 21.22
(a) Describe how the form of method inheritance used for polyadic method schemas can be simulated using the originally presented form of method inheritance, which is based only on the class of the first argument.

(b) Suppose that a base method mR in an instance of a polyadic method schema is used to simulate an n-ary relation R. In a simulation of this situation by an instance of a conventional OODB schema, how many OIDs are present in the class on which mR
is simulated?

Exercise 21.23
Show how to encode or, not, and equal using method schemas.

Exercise 21.24
Show how to encode pred i and the join operation using method schemas.

k
♠ Exercise 21.25 [HKR93] Prove Theorem 21.4.8. Hint: Show first that method schemas can simulate relational algebra and then inflationary fixpoint. For the fixpoint, you might want to use pred k. For the other direction, you might want to simulate method schemas over ordered databases by inflationary fixpoint.

22 DynamicAspects
Alice:
How come we’ve waited so long to talk about something so important?

Riccardo:
Talking about change is hard.

Sergio:
We’re only starting to get a grip on it.

Vittorio:
And still have a long way to go.

At a fundamental level, updating a database is essentially imperative programming.

However, the persistence, size, and long life cycle of a database lead to perspectives somewhat different from those found in programming languages. In this chapter, we briefly examine some of these differences and sketch some of the directions that have been explored in this area. Although it is central to databases, this area has received far less attention from the theoretical research community than other topics addressed in this book.

The discussion in this chapter is intended primarily to give an overview of the important issues raised concerning the dynamic aspects of databases. It therefore emphasizes examples and intuitions much more than results and proofs.

This chapter begins by examining database update languages, including a simple language that corresponds to the update capabilities of practical languages such as SQL, and more complex ones expressed within a logic-based framework. Next optimization and semantic properties of transactions built from simple update commands are considered, including a discussion of the interaction of transactions and static integrity constraints.

The impact of updates in richer contexts is then considered. In connection with views, we examine the issue of how to propagate updates incrementally from base data to views and the much more challenging issue of propagating an update on a view back to the base data. Next updates for incomplete information databases are considered. This includes both the conditional tables studied in Chapter 19 and more general frameworks in which databases are represented using logical theories.

The emerging field of active databases is then briefly presented. These incorporate mechanisms for automatically responding to changes in the environment or the database, and they often use a rule-based paradigm of specifying the responses.

This chapter concludes with a brief discussion of temporal databases, which support the explicit representation of the time dimension and thus historical information.

A broad area related to dynamic aspects of databases (namely, concurrency control) will not be addressed. This important area concerns mechanisms to increase the throughput of a database system by interleaving multiple transactions while guaranteeing that the semantics of the individual transactions is not lost.

579
580
Dynamic Aspects
22.1
Update Languages
Before embarking on a brief excursion into update languages, we should answer the following natural question: Why are update languages necessary? Could we not use query languages to specify updates?

The difference between query and update languages is subtle but important. To specify an update, we could indeed define the new database as the answer to a query posed against the old database. However, this misses an essential characteristic of updates: Most often, they involve small changes to the current database. Query languages are not naturally suited to speak explicitly about change. In contrast, update languages use as building blocks simple statements expressing change, such as insertions, deletions, and modifications of tuples in the database.

In this section, we outline several formal update languages and point to some theoretical issues that arise in this context.

Insert-Delete-Modify Transactions
We begin with a simple procedural language to specify insertions, deletions, and modifications. Most commercial relational systems provide at least these update capabilities.

To simplify the presentation, we suppose that the database consists of a single relation schema R. Everything can be extended to the multirelational case. An insertion is an expression ins(t), where t is a tuple over att(R). This inserts the tuple t into R. [We assume set-based semantics, under which ins(t) has no effect if t is already present in R.] A deletion removes from R all tuples satisfying some stated set of conditions. More precisely, a condition is an (in)equality of the form A = c or A "= c, where A ∈ att(R) and c is a constant. A deletion is an expression del(C), where C is a finite set of conditions.

This removes from R all tuples satisfying each condition in C. Finally, a modification is an expression mod(C → C′), where C, C′ are sets of conditions, with C′ containing only equalities A = c. This selects all tuples in R satisfying C and then, for each such tuple and each A = c in C′, sets the value of A to c. An update over R is an insertion, deletion, or modification over R. An IDM transaction (for insert, delete, modify) over R is a finite sequence of updates over R. This is illustrated next.

Example 22.1.1
Consider the relation schema Employee with attributes N (Name), D
(Department), R (Rank). The following IDM transaction fires the manager of the parts department, transfers the manager of the sales department to the parts department, and hires Moe as the new manager for the sales department:
del({D = parts, R = manager});
mod({D = sales, R = manager} → {D = parts}); ins( Moe, sales, manager)
The same update can be expressed in SQL as follows:
delete from Employee
22.1 Update Languages
581
where D = “parts” and R = “manager”;
update Employee
set D = “parts”
where D = “sales” and R = “manager”;
insert into Employee values “Moe”,“sales”,“manager”
As for queries, a question of central interest to update languages is optimization. To see how IDM transactions can be optimized, it is useful to understand when two such transactions are equivalent. It turns out that equivalence of IDM transactions has a sound and complete axiomatization. Following are some simple axioms:
mod(C → C′); del(C′)
≡ del(C); del(C′)
ins(t ); mod(C → C′)
≡ mod(C → C′); ins(t′)
where t satisfies C and {t′} = mod(C → C′)({t})
and a slightly more complex one:
del(C3); mod(C1 → C3); mod(C2 → C1); mod(C3 → C2)
≡ del(C3); mod(C2 → C3); mod(C1 → C2); mod(C3 → C1), where C1, C2, C3 are mutually exclusive sets of conditions.

We can define criteria for the optimization of IDM transactions along two main lines: Syntactic: We can take into account the length of the transaction as well as the kind of operations involved (for example, it may be reasonable to assume that insertions are simpler than modifications).

Semantic: This can be based on the number of tuple operations actually performed when the transaction is applied.

Various definitions are possible based on the preceeding criteria. It can be shown that there exists a polynomial-time algorithm that optimizes IDM transactions, with respect to a reasonable definition based on syntactic and semantic criteria. The syntactic criteria involve the number of insertions, deletions, and modifications. The semantic criteria are based on the number of tuples touched at runtime by the transaction. We omit the details here.

Example 22.1.2
Consider the IDM transaction over a relational schema R of sort AB: mod({A "= 0, B = 1} → {B = 2}); ins(0, 1); ins(3, 2); mod({A = 0, B = 1} → {B = 2}); mod({A "= 0, B = 0} → {B = 1}); mod({A = 0, B = 0} → {B = 1}); mod({A "= 0, B = 2} → {B = 0}); mod({A = 0, B = 2} → {B = 0}); del({A "= 0, B = 0}).

Assuming that insertions are less expensive than deletions, which are less expensive than modifications, an optimal IDM transaction equivalent to the foregoing is
582
Dynamic Aspects
del({A "= 0, B = 1}); del({A "= 0, B = 2}); mod({A = 0, B = 1} → {B = 2});
mod({B = 0} → {B = 1});
mod({A = 0, B = 2} → {B = 0});
ins(0, 0).

Thus the six modifications, one deletion, and two insertions of the original transaction were replaced by three modifications, two deletions, and one insertion.

Another approach to optimization is to turn some of the axioms of equivalence into simplification rules, as in
mod(C → C′); del(C′) ⇒ del(C); del(C′).

It can be shown that such a set of simplification rules can be used to optimize a restricted set of IDM transactions that satisfy a syntactic acyclicity condition. For the other transactions, applications of the simplification rules yield a simpler, but not necessarily optimal, transaction. The simplification rules have the advantage that they are local and can be easily applied even online, whereas the complete optimization algorithm is global and has to know the entire transaction in advance.

Rule-Based Update Languages
The IDM transactions provide a simple update language of limited power. This can be extended in many ways. One possibility is to build another procedural language based on tuple insertions, deletions, and modifications, which includes relation variables and an iterative construct. Another, which we illustrate next, is to use a rule-based approach.

For example, consider the language datalog¬¬ described in Chapter 17, with its fixpoint semantics. Recall that rules allow for both positive and negative atoms in heads of rules; consistently with the fixpoint semantics, the positive atoms can be viewed as insertions of facts and the negative atoms as deletions of facts. For example, the following program removes all cycles of length one or two from the graph G:
¬G(x, y) ← G(x, y), G(y, x).

In the usual fixpoint semantics, rules are fired in parallel with all possible instantiations for the variables. This yields a deterministic semantics. Some practical rule-based update languages take an alternative approach, which yields a nondeterministic semantics: The rules are fired one instantiation at a time. With this semantics, the preceeding program provides some orientation of the graph G. Note that generally there is no way to obtain an orientation of a graph deterministically, because a nondeterministic choice of edges to be removed may be needed.

A deterministic language expressing all updates can be obtained by extending datalog¬¬ with the ability to invent new values, in the spirit of the language while new
22.1 Update Languages
583
in Chapter 18. This can be done in the manner described in Exercise 18.22. The same language with nondeterministic semantics can be shown to express all nondeterministic updates.

The aforementioned languages yield a bottom-up evaluation procedure. The body of the rule is first checked, and then the actions in the head are executed. Another possibility is to adopt a top-down approach, in the spirit of the assert in Prolog. Here the actions to be taken are specified in rule bodies. A good example of this approach is provided by Dynamic Logic Programming (DLP). Interestingly, this language allows us to test hypothetical conditions of the form “Would ϕ hold if t was inserted?” This, and the connection of DLP with Prolog, is illustrated next.

Example 22.1.3
Consider a database schema with relations ES of sort Emp,Sal (employees and their salaries), ED of sort Emp,Dep (employees and their departments), and DA of sort Dep,Avg (average salary in each department).

Suppose that an update is intended to hire John in the toys department with a salary of 200K, under the condition that the average salary of the department stays below 50K. In the language DLP, this update is expressed by
hire( emp 1, sal 1, dep 1) ←
+ ES( emp 1, sal 1)(+ ED( emp 1, dep 1)( DA( dep 1, avg 1) & avg 1 < 50k)).

(Other rules are, of course, needed to define DA.) A call hire(John,200K,Toys) hires John in the toys department only if, after hiring him, the average salary of the department remains below 50K. The + symbol indicates an insertion. Here the conditions in parentheses should hold after the two insertions have been performed; if not, then the update is not realized.

Testing a condition under the assumption of an update is a form of hypothetical reasoning.

It is interesting to contrast the semantics of DLP with that of Prolog. Consider the following Prolog program:
: −
assert( ES( john, 200)), assert( ED( john, toys)), DA( toys, Avg 1), Avg 1 < 50.

In this program, the insertions into ES and ED will be performed even if the conditions are not satisfied afterward. (The reader familiar with Prolog is encouraged to write a program that has the desired semantics.)

A similar top-down approach to updates is adopted in Logical Data Language (LDL).

Updates concern not only instances of a fixed schema. Sometimes the schema itself needs to be changed (e.g., by adding an attribute). Some practical update languages include constructs for schema change. The main problem to be resolved is how the existing data can be fit to the new schema.

In deductive databases, some relations are defined using rules. Occasionally these definitions may have to be changed, leading to updates of the “rule base.” There are languages that can be used to specify such updates.

584
Dynamic Aspects
22.2
Transactional Schemas
Typically, database systems restrict the kinds of updates that users can perform. There are three main ways of doing this:
(a) Specify constraints (say, fd’s) that the database must satisfy and reject any update that leads to a violation of the constraints.

(b) Restrict the updates themselves by only allowing the use of a set of prespecified, valid updates.

(c) Permit users to request essentially arbitrary updates, but provide an automatic mechanism for detecting and repairing constraint violations.

Object-oriented databases essentially embrace option (b); updates are performed only by methods specified at the schema level, and it is assumed that these will not violate the constraints (see Chapter 21). Both options (a) and (b) are present in the relational model.

Several commercial systems can recognize and abort on violation of simple constraints (typically key and simple inclusion dependencies). However, maintenance of more complex constraints is left to the application software. Option (c) is supported by the emerging field of active databases, which is discussed in the following section.

We now briefly explore some issues related to approach (b) in connection with the relational model. To illustrate the issues, we use simple procedures based on IDM transactions. The procedures we use are parameterized IDM transactions, obtained by allowing variables in addition to constants in conditions of IDM transactions. The variables are used as parameters. A database schema R together with a finite set of parameterized IDM transactions over R is called an IDM transactional schema.

Example 22.2.1
Consider a database schema R with two relations, TA (Teaching Assis-tant) of sort Name, Course, and PHD (Ph.D. student) of sort Name, Address. The following IDM-parameterized transactions allow the hiring and firing of TAs (subscripts indicate the relation to which each update applies):
hire( x, y, z) = delTA( Name = x); insTA(x, y) delPHD( Name = x); insPHD(x, z)
fire( x)
= delTA( Name = x)
The pair T = R, { hire, fire} is an IDM transactional schema. Note in this simple example that once a name n is incorporated into the PHD relation, it can never be removed.

Clearly, we could similarly define transactional schemas in conjunction with any update language.

Suppose T is an IDM transactional schema. To apply the parameterized transactions, values must be supplied to the variables. A transaction obtained by replacing the variables of a parameterized transaction t in T by constants is a call to t. The only updates allowed by an IDM transactional schema are performed by calls to its parameterized transactions.

22.2 Transactional Schemas
585
The set of instances that can be generated by such calls (starting from the empty instance) is denoted Gen(T).

Transactional schemas offer an approach for constraint enforcement, essentially by preventing updates that violate them. So it is important to understand to what extent they can do so. First we need to clarify the issue. Suppose T is an IDM transactional schema and is a set of constraints over a database schema R; Sat() denotes all instances over R satisfying . If T is to replace , we would expect the following properties to hold:
• soundness of T with respect to : Gen(T) ⊆ Sat(); and
• completeness of T with respect to : Gen(T) ⊇ Sat().

Thus T is sound and complete with respect to iff it generates precisely the instances satisfying .

Example 22.2.2
Consider again the IDM transactional schema T in Example 22.2.1. Let be the following constraints:
TA : Name
→ Course
PHD : Name → Address
TA[ Name]
⊆ PHD[ Name]
It is easily seen that T in Example 22.2.1 is sound and complete with respect to . That is, Gen(T) = Sat() (Exercise 22.7).

This example also highlights a limitation in the notion of completeness: It can be seen that there are pairs I and J of instances in Sat() where I cannot be transformed into J
using T. In other words, there are valid database states I and J such that when in state I, J is never reachable. Such forbidden transitions are also a means of enriching the model, because we can view them as temporal constraints on the database evolution. We will return to temporal constraints later in this chapter.

Of course, the ability of transaction schemas to replace constraints depends on the update language used. For IDM transactional schemas, we can show the following (Exercise 22.8):
Theorem 22.2.3
For each database schema R and set of fd’s and acyclic inclusion dependencies over R, there exists an IDM transactional schema T that is sound and complete with respect to .

Thus IDM transactional schemas are capable of replacing a significant set of constraints. The kind of difficulty that arises with more general constraints is illustrated next.

Example 22.2.4
Consider a relation R of sort ABC and the following set of constraints:
586
Dynamic Aspects
• the embedded join dependency
∀xyzx′y′z′(R(xyz) ∧ R(x′y′z′) ⇒ ∃z′′R(xy′z′)),
• the functional dependency AB → C,
• the inclusion dependency R[A] ⊆ R[C],
• the inclusion dependency R[B] ⊆ R[A],
• the inclusion dependency R[A] ⊆ R[B].

It is easy to check that, for each relation satisfying the constraints, the number of constants in the relation is a perfect square (n2, n ≥ 0). Thus there are unbounded gaps between instances in Sat(). There is no IDM transactional schema T such that Sat() =
Gen(T), because the gaps cannot be crossed using calls to parameterized transactions with a bounded number of parameters. Moreover, this problem is not specific to IDM transactional schemas; it arises with any language in which procedures can only introduce a bounded number of new constants into the database at each call.

Another natural question relating updates and constraints is, What about checking soundness and/or completeness of IDM transactional schemas with respect to given constraints? Even in the case of IDM transactional schemas, such questions are generally undecidable. There is one important exception: Soundness of IDM transactional schemas with respect to fd’s is decidable. These questions are explored in Exercise 22.12.

22.3
Updating Views and Deductive Databases
We now turn to the impact of updates on views. Views are an important aspect of databases.

The interplay between views and updates is intricate. We can mention in particular two important issues. One is the view maintenance problem: A view has been materialized and the problem is to maintain it incrementally when the database is updated. An important variation of this is in the context of deductive databases when the view consists of idb relations. The other is known as the view update problem: Given a view and an update against a view, the problem is to translate the update into a corresponding update against the base data. This section considers these two issues in turn.

View Maintenance
Suppose that a base schema B and view schema V are given along with a (total) view mapping f : Inst(B) → Inst(V). Suppose further that a materialized view is to be maintained
[i.e., whenever the base database holds an instance IB, then the view schema should be holding f (IB)].

For this discussion, an update for a schema R is considered to be a mapping from Inst(R) to Inst(R). If constraints are present, it is assumed that an update cannot map to instances violating the constraints. The updates considered here might be based on IDM
transactions or might be more general. We shall often speak of “the” update µ that maps
22.3 Updating Views and Deductive Databases
587
v
I V
I′ V
f
f
I B
I′ B
µ
Figure 22.1:
Relationship of views and updates
instance I to instance I′, and by this we shall mean the set of insertions and deletions that need to be made to I to obtain I′.

Suppose that the base database B is holding IB and that update µ maps this to I′ (see B
Fig. 22.1). A naive way to keep the view up to date is to simply compute f (I′ ). However, B
I′ is typically large relative to the difference between I
. It is thus natural to search
B
V and I′V
for more efficient ways to find the update ν that maps IV to I′ = f (µ(I V
B )). This is the
view maintenance problem.

There are generally two main components to solutions of the view maintenance problem. The first involves developing algorithms to test whether an update to the base data can affect the view. Given such an algorithm, an update is said to be irrelevant if the algorithm certifies that the update cannot affect the view, and it is said to be relevant otherwise.

Example 22.3.1
Let the base database schema be B = (R[AB], S[BC]), and consider the following views:
V1 = (R ⊲⊳ σC>50S)
V2 = πAR
V3 = R ⊲⊳ S
V4 = πAC(R ⊲⊳ S).

Inserting b, 20 into S cannot affect views V1 or V2. On the other hand, whether or not this insertion affects V3 or V4 depends on the data already present in the database.

Various algorithms have been developed for determining relevance with varying degrees of precision. A useful technique involves maintaining auxiliary information, as illustrated next.

Example 22.3.2
Recall view V2 of Example 22.3.1, and suppose that R currently holds
588
Dynamic Aspects
R
A
B
a
20
a
30
a′
80
Deleting a, 20 has no impact on the view, whereas deleting a′, 80 has the effect of deleting a′ from the view. One way to monitor this is to maintain a count on the number of distinct ways that a value can arise; if this count ever reaches 0, then the value should be deleted from the view.

The other main component of solutions to the view maintenance problem concerns the development of incremental evaluation algorithms. This is closely related to the seminaive algorithm for evaluating datalog programs (see Chapter 13).

Example 22.3.3
Recall view V3 from Example 22.3.1, and let I+ and I+ denote sets
R
S
of tuples that are to be inserted into R and S, respectively. It is easily verified that (R ∪ I+) ⊲⊳ (S ∪ I+) = (R ⊲⊳ S) ∪ (R ⊲⊳ I+) ∪ (I+ ⊲⊳ S) ∪ (I+ ⊲⊳ I+).

R
S
S
R
R
S
Thus the new join can be found by performing three (typically smaller) joins followed by some unions.

It is relatively straightforward to develop incremental evaluation expressions, such as in the preceeding example, for all of the relational algebra operators (see Exercise 22.13).

In some cases, these expressions can be refined by using information about constraints, such as key and functional dependencies, on the base data.

Incremental Update of Deductive Views
The view maintenance problem has also been studied in connection with views constructed with (stratified) datalog(¬). In general, the techniques used are analogous to those discussed earlier but are generalized to incorporate recursion. In the context of stratified datalog¬, various heuristics have been adapted from the field of belief revision for incrementally maintaining supports (i.e., auxiliary information that holds the justifications for the presence of a fact in the materialized output of the program).

An interesting research direction that has recently emerged focuses on the ability of first-order queries to express incremental updates on views defined using datalog. The framework for these problems is as follows. The base schema B and view schema V are as before, except that V contains only one relation and the view f is defined in terms of a datalog program P . A basic question is, Given P , is there a first-order query ϕ such that ϕ(IB, IV , +R(t)) = P (IB ∪ {R(t)}) for each choice of IB, IV = P (IB) and insertion
+R(t) where R ∈ B? If this holds, then P is said to be first-order incrementally definable (FOID) (without auxiliary relations).

22.3 Updating Views and Deductive Databases
589
Example 22.3.4
Consider a binary relation G[AB] and the usual datalog program P that computes the transitive closure of G in T [AB]. Suppose that I is an instance of G, and J
is P (I ). Suppose that tuple a, b is inserted into I . Then a tuple a′, b′ will be inserted into J iff one of the following occurs:
(a) a′ = a and b = b′;
(b) a′ = a and b, b′ ∈ J ;
(c) a′, a ∈ J and b = b′; or
(d) a′, a ∈ J and b, b′ ∈ J .

The preceeding conditions can clearly be specified by a first-order query. It easily follows that P is FOID (see Exercise 22.21).

Several variations of FOIDs have been studied. These include FOIDs with auxiliary relations (i.e., that permit the maintenance of derived relations not in the original datalog program) and FOIDs that support incremental updates for sets of insertions and/or deletions. FOIDs have been found for a number of restricted classes of datalog programs.

However, it remains open whether there is a datalog program that is not FOID with auxiliary relations.

Basic Issues in View Update
The view update problem is essentially the inverse of the view maintenance problem.

Referring again to Fig. 22.1, the problem now is, Given IB, IV , and update ν on IV , find an update µ so that the diagram commutes.

The first obvious problem here is the potential for ambiguity.

Example 22.3.5
Recall the view V2 of Example 22.3.1. Suppose that the base value of R is {a, b} (and the base value of S is ∅). Thus the view holds {a}. Now consider an update ν to the view that inserts a′. Some possible choices for µ include (a) Insert a′, b into R.

(b) Insert a′, b′ into R for some b′ ∈ dom.

(c) Insert {a′, b′ | b′ ∈ X} into R, where X is a finite subset of dom.

(d) Insert a′, b′ into R for some b′ ∈ dom, and replace a, b by a, b′.

Possibility (d) seems undesirable, because it affects a tuple in a base relation that is, intuitively speaking, independent of the view update. Possibilities (a) and (b) seem more appealing than (c), but (c) cannot be ruled out. In any case, it is clear that there are a large number of updates µ that correspond to ν.

The fundamental problem, then, is how to select one update µ to the base data given that many possibilities may exist. One approach to resolving the ambiguity involves examining the intended semantics of the database and the view.

590
Dynamic Aspects
Example 22.3.6
Consider a schema Employee[ Name, Department, Team_position], which records an employee’s department and the position he or she plays in the corporate baseball league. It is assumed that Name is a key. The value “no” indicates that the employee does not play in the league. It is assumed that Name is a key. Consider the views defined by
Sales
= σ Department=“Sales”( Employee)
Baseball = π Employee, Team _ position(σ Team _ position"=“no”( Employee)) Typically, if tuple “Joe”, “Sales”, “shortstop” is deleted from the Sales view, then this tuple should also be deleted from the underlying Employee relation. In contrast, if tuple “Joe”, “shortstop” is deleted from the Baseball view, it is typically most natural to replace the underlying tuple “Joe”, d, “shortstop” in Employee by “Joe”, d, “no” (i.e., to remove Joe from the baseball league rather than forcing him out of the company).

As just illustrated, the correct translation of a view update can easily depend on the semantics associated with the view as well as the syntactic definition. Research in this area has developed notions of update translations that perform a minimal change to the underlying database. Algorithms that generate families of acceptable translations of views have been developed, so that the database administrator may choose at view definition time the most appropriate one.

Another issue in view update is that a requested update may not be permitted on the view, essentially because of constraints implicit to the view definition and algorithm for choosing translations of updates.

Example 22.3.7
Recall the view V4 of Example 22.3.1, and suppose that the base data is
R
A
B
S
B
C
a
20
20
c
a′
20
20
c′
In this case the view contains {a, c, a, c′, a′, c, a′, c′}.

Suppose that the user requests that a, c be deleted. Typically, this deletion is mapped into one or more deletions against the base data. However, deleting R(a, 20) results in a side-effect (namely, the deletion of a, c′ from the view). Deletion of S(20, c) also yields a side-effect.

Formal issues surrounding such side-effects of view updates are largely unexplored.

22.3 Updating Views and Deductive Databases
591
Complements of Views
We now turn to a more abstract formulation of the view update problem. Although it is relatively narrow, it provides an interesting perspective.

In this framework, a view over a base schema B is defined to be a (total) function f from Inst(B) into some set. In practice this set is typically Inst(V) for some view schema V; however, this is not required for this development. [The proof of Theorem 22.3.10, which presents a completeness result, uses a view whose range is not Inst(V) for any schema V.]
A binary relation ≤ on views is defined so that f ≤ g if for all base instances I and I′, g(I) = g(I′) implies f (I) = f (I′). Intuitively, f ≤ g if g can distinguish more instances that f . For view f , let ≡f be the equivalence relation on Inst(B) defined by I ≡f I′ iff f (I) = f (I′). It is clear that f ≤ g iff ≡g is a refinement of ≡f and thus ≤ can be viewed as a partial order on the equivalence relations over Inst(B).

Two views f, g are equivalent, denoted f ≡ g, if f ≤ g and g ≤ f . This is an equivalence relation on views. In the following, the focus is primarily on the equivalence classes under ≡. Let ⊤ denote the view that is simply the identity, and let ⊥ denote a view that maps every base instance to ∅. It is clear that (the equivalence classes represented by)
⊤ and ⊥ are the maximal and minimal elements of the partial order ≤. We use cross-product as a binary operator to create views: The product of views f and g is defined so that (f × g)(I) = (f (I), g(I)). View g is a complement of view f if f × g ≡ ⊤. Intuitively, this means that the base relations can be completely identified if both f and g are available. Clearly, each view f has a trivial complement: ⊤.

Example 22.3.8
(a) Let B = {R[ ABC]} along with the fd R : A → B, and consider the view f = πABR. Let g = πACR. It follows from Proposition 8.2.2 that g is a complement of f .

(b) Let B = {R[AB]} and f = πAR. As mentioned earlier, ⊤ is a complement of f .

It turns out that there are other complements of f , but they cannot be expressed using the relational algebra (see Exercise 22.25).

(c) Let B = { Employee( Name, Salary, Bonus, Total_pay)}, with the constraints that Name is a key and that for each tuple n, s, b, t in Employee we have s + b = t. Consider the view f = π Name, Salary( Employee). Consider the views g1 = π Name, Bonus( Employee)
g2 = π Name, Total _ pay( Employee).

Both g1 and g2 are complements of f .

Thus each view has at least one complement (namely, ⊤) and may have more than one minimal complement.

In some cases, complements can be used to resolve ambiguity in the view update problem in the following way. Suppose that view f has complement g, and suppose that IV = f (IB) and update ν on IV are given. An update µ is a g- translation of ν if f (µ(IB)) = ν(f (IB)) and g(µ(IB)) = g(IB) (see Fig. 22.2). Intuitively, a g-translation
592
Dynamic Aspects
v
( f(I B), g(I B))
( v( f(I B)), g(I B)) f × g
( f × g)–1
I B
I′ B
µ
Figure 22.2:
Properties of a g-translation µ of view update ν on view f
accomplishes the update but leaves g(IB) fixed. By the properties of complements, for an update ν there is at most one g-translation of ν.

Example 22.3.9
(a) Recall the base schema {R[ ABC]}, view f , and complement g of Example 22.3.8(a). Suppose that a, b is in the view, and consider the update ν on the view that modifies a, b to a, b′. The update µ defined to modify all tuples a, b, c of R into a, b′, c is a g-translation of ν. On the other hand, given an insertion or deletion ν
to the view, there is no g-translation of ν.

(b) Recall the base schema, view f , and complementary views g1 and g2 of Example 22.3.8(c). Suppose that Joe, 200, 50, 250 is in Employee. Consider the update ν that replaces Joe, 200 by Joe, 210 in the view. Consider the updates µ1 = replace Joe, 200, 50, 250 by Joe, 210, 50, 260
µ2 = replace Joe, 200, 50, 250 by Joe, 210, 40, 250.

Then µ1 is the g1-translation of ν, and µ2 is the g2-translation of ν.

Finally, we state a result showing that a restricted class of view updates can be translated into base updates using complementary views. To this end, we focus on updates of a schema R that are total functions from Inst(R) to Inst(R). A family U of updates on R is said to be complete if
(a) it is closed under composition (i.e., if µ and µ′ are in U , then so is µ ◦ µ′); (b) it is closed under inverse in the following sense: ∀I ∈ inst(R) ∀µ ∈ U ∃µ′ ∈ U
such that µ′(µ(I)) = I.

Intuitively, condition (b) says that a user can always undo an update just made. It is certainly natural to focus on complete sets of updates.

Let base schema B and view f be given, and let Uf be a family of updates on the view. Let UB denote the family of all updates on the base schema. A translator for Uf is a mapping t : Uf → UB such that for each base instance IB and update ν ∈ Uf , f (t (ν)(IB)) = ν(f (IB)). Clearly, solving the view update problem consists of coming up with a translator.

22.4 Updating Incomplete Information
593
If g is a complement for f , then a translator t is a g- translator if t (ν) is a g-translation of ν for each ν ∈ Uf .

We can now state the following (see Exercise 22.26):
Theorem 22.3.10
Let base schema B and view f be given, and let Uf be a complete set of updates on the view. Suppose that t is a translator for Uf . Then there is a complement g of f such that t is a g-translator for Uf .

Thus to find a translator for a complete set of view updates, it is sufficient to specify an appropriate complementary view g and take the corresponding g-translator. The theorem says that one can find such g if a translator exists at all.

The preceeding framework provides an abstract, elegant perspective on the view update problem. Forming bridges to the more concrete frameworks in which views are defined by specific languages (e.g., relational algebra) remains largely unexplored.

22.4
Updating Incomplete Information
In a sense, an update to a view is an incompletely specified update whose completion must be determined or selected. In this section, we consider more general settings for studying updates and incomplete information.

First we return to the conditional tables of Chapter 19 and show a system for updating such databases. We then introduce formulations of incomplete information that use theories (i.e., sets of propositional or first-order sentences) to represent the (partial) knowledge about the world. Among other benefits, this approach offers an interesting alternative to resolving the view update problem. This section concludes by comparing these approaches to belief revision.

Updating Conditional Tables
The problems posed by updating a c-table are similar to those raised by queries. A representation T specifies a set of possible worlds rep(T ). Given an update u, the possible outcomes of the update are
u( rep(T )) = {u(I) | I ∈ rep(T )}.

As for queries, it is desirable to represent the result in the same representation system. If the representation system is always capable of representing the answer to any update in a language L, it is a strong representation system with respect to L.

Let us consider c-tables and simple insertions, deletions, and modifications, as in the language of IDM transactions. We know from Chapter 19 that c-tables form a strong representation system for relational algebra; and it is easily seen that IDM transactions can be expressed in the algebra (see Exercise 22.3). It follows that c-tables are a strong representation system for IDM transactions. In other words, for each c-table T and IDM
transaction t, there exists a c-table t(T ) such that rep(t(T )) = t ( rep(T )).

594
Dynamic Aspects
Example 22.4.1
Consider the c-table in Example 19.3.1. Insertions ins(t) are straightforward: t is simply inserted in the table. Consider the deletion d = del({ Student =
Sally, Course = Physics}). The c-table t(T ) representing the result of the deletion is Student
Course
( x ≠ Math) ∧ ( x ≠ CS)
Sally
Math
( z = 0)
Sally
CS
( z ≠ 0)
Sally
x
( x ≠ Physics)
Alice
Biology
( z = 0)
Alice
Math
( x = Physics) ∧ ( t = 0)
Alice
Physics
( x = Physics) ∧ ( t ≠ 0)
Consider again the original c-table T in Example 19.3.1 and the modification m = mod({ Student = Sally, Course = Music} → { Course = Physics}).

The c-table m(T ) representing the result of the modification is
Student
Course
( x ≠ Math) ∧ ( x ≠ CS)
Sally
Math
( z = 0)
Sally
CS
( z ≠ 0)
Sally
Physics
( x = Music)
Sally
x
( x ≠ Music)
Alice
Biology
( z = 0)
Alice
Math
( x = Physics) ∧ ( t = 0)
Alice
Physics
( x = Physics) ∧ ( t ≠ 0)
In the context of incomplete information, it is natural to consider updates that themselves have partial information. For c-tables, it seems appropriate to define updates with the same kind of incomplete information, using tuples with variables subject to conditions.

We can define extensions of insertions, deletions, and modifications in this manner. It can be shown that c-tables remain a strong representation system for such updates.

Representing Databases Using Logical Theories
Conditional tables provide a stylized, restricted framework for representing incomplete information and are closed under a certain class of updates. We now turn to more general frameworks for representing and updating incomplete information. These are based on representing databases as logical theories.

Given a logical theory T (i.e., set of sentences), the set of models of T is denoted
22.4 Updating Incomplete Information
595
by Mod(T). In our context, each model corresponds to a different possible instance. If
| Mod(T)| > 1, then T can be viewed as representing incomplete information.

In general, these approaches use the open world assumption (OWA). Recall from Chapter 2 that under the closed world assumption (CWA), a fact is viewed as false unless it can be proved from explicitly stated facts or sentences. In contrast, under the OWA if a fact is not implied or contradicted by the underlying theory, then the fact may be true or false.

As a simple example, consider the theory T = {p} over a language with two propositional constants p and q. Under the CWA, there is only one model of T (namely, {p}), but under the OWA, there are two models (namely, {p} and {p, q}).

Model-Based Approaches to Updating Theories
One natural approach to updating a logical theory T is model based; it focuses on how proposed updates affect the elements of Mod(T). Given an update u and instance I, let u(I) denote the set of possible instances that could result from applying u to I. We use a set for the result to accommodate the case in which u itself involves incomplete information.

Now let T be a theory and u an update. Under the model-based approach, the result u(T) of applying u to T should be a theory T′ such that Mod(T′) = ∪{u(I) | I ∈ Mod(T)}.

Example 22.4.2
(a) Consider the theory T = {p ∧ q}, where p and q are propositional constants, and the update [ insert ¬p]. There is only one model of T (namely, {p, q}). If we take the meaning of insert ¬p to be “make p false and leave other things unchanged,”
then updating this model yields the single model {q}. Thus the result of applying
[ insert ¬p] to T yields the theory {q}.

(b) Consider T′ = {p ∨ q} and the update [ insert ¬p]. The models of T′ and the impact of the update are given by
{p}
/−→ ∅
{q}
/−→ {q}
{p, q} /−→ {q}.

Thus the result of applying the update to T′ is {¬p}.

The approach to updating c-tables presented earlier falls within the model-based paradigm (see Exercise 22.14). A family of richer model-based frameworks that supports null values and disjunctive updates has also been developed. An interesting dimension of variation in this approach concerns how permissive or restrictive a given update semantics is.

This essentially amounts to considering how many models are associated with u(I) for given update u and instance I. As a simple example, consider starting with an empty database I∅ and the update [ insert (p ∨ q)]. Under a restrictive semantics, only {p} and {q}
596
Dynamic Aspects
are in u(I∅), but under a permissive semantics, {p, q} might also be included. The update semantics for c-tables given earlier is very permissive: All possible models corresponding to an update are included in the result.

Formula-Based Approaches to Updating Theories
Another approach to updating theories is to apply updates directly to the theories themselves. As we shall see, a disadvantage of this approach is that the same update may have a different effect on equivalent but distinct theories. On the other hand, this approach does allow us to assign priorities to different sentences (e.g., so that constraints are given higher priority than atomic facts).

We consider two forms of update: [ insert ϕ] and [ delete ϕ], where ϕ is a sentence (i.e., no free variables). Given theory T, a theory T′ accomplishes the update [ insert ϕ] for T if ϕ ∈ T′, and it accomplishes [ delete ϕ] for T if1 ϕ "∈ T′∗. Observe that there is a difference between [ insert ¬ϕ] and [ delete ϕ]: In the former case ¬ϕ is true for all models of T′, whereas in the latter case ϕ may hold in some model of T′.

In general, we are interested in accomplishing an update for T with minimal impact on T. Given theory T, we define a partial order ≤T on theories with respect to the degree of change from T. In particular, we define T′ ≤T T′′ if T − T′ ⊂ T − T′′, or if T − T′ =
T − T′′ and T′ − T ⊆ T′′ − T. Intuitively, T′ ≤T T′′ if T′ has fewer deletions (from T) than T′′, or both T′ and T′′ have the same deletions but T′ has no more insertions than T′′.

(Exercise 22.16 considers the opposite ordering, where insertions are given priority over deletions.)

Intuitively, we are interested in theories T′ that accomplish a given update u for T and are minimal under ≤T. We say that such theories T′ accomplish u for T minimally. The following characterizes such theories (see Exercise 22.15):
Proposition 22.4.3
Let T, T′ be theories and ϕ a sentence. Then
(a) T′ accomplishes [ delete ϕ] for T minimally iff T′ is a maximal subset of T that is consistent with ¬ϕ.

(b) T′ ∪ ϕ accomplishes [ insert ϕ] for T minimally iff T′ is a maximal subset of T
that is consistent with ϕ.

Thus T′ accomplishes [ delete ϕ] for T minimally iff T′ ∪ ¬ϕ accomplishes [ insert ¬ϕ]
for T minimally.

The following example shows that equivalent but distinct theories can be affected differently by updates.

Example 22.4.4
(a) Consider the theory T0 = {p, q} and the update [ insert ¬p]. Then
{¬p, q} is the unique minimal theory that accomplishes this update.

1 For a theory S, the ( logical) closure of S, denoted S∗, is the set of all sentences implied by S.

22.4 Updating Incomplete Information
597
(b) Let T1 = {p ∧ q} and consider [ insert ¬p]. The unique minimal theory that accomplishes this update for T1 is {¬p} [i.e., (∅ ∪ {¬p})]. Note how this differs from the model-based update in Example 22.4.2(a).

A problem at this point is that, in general, there are several theories that minimally accomplish a given update. Thus an update to a theory may yield a set of theories, and so the framework is not closed under updates. Given a set T1, T2, . . . , we would like to find a theory T whose models are exactly the union of all models of the set of theories. In general, it is not clear that there is a theory that has this property. However, if there is only a finite number of theories that are possible answers, then we can use the disjunction operator defined by
{Ti | i ∈ [1, n]} = {τ1 ∨ · · · ∨ τn | τi ∈ Ti for i ∈ [1, n]}.

It is easily verified that Mod({Ti | i ∈ [1, n]}) = ∪{ Mod(Ti) | i ∈ [1, n]}. Of course, there is a great likelihood of a combinatorial explosion if the disjunction operator is applied repeatedly.

Assigning Priorities to Sentences
We now explore a mechanism for giving priority to some sentences in a theory over other sentences. Let n ≥ 0 be fixed. A tagged sentence is a pair (i, ϕ), where i ∈ [0, n] and ϕ
is a sentence. A tagged theory is a set of tagged sentences. Given tagged theory T and i ∈ [1, n], Ti denotes {ϕ | (i, ϕ) ∈ T}.

The partial order for comparing theories is extended in the following natural fashion.

Given tagged theories T, T′ and T′′, define T′ ≤T T′′ if for some i ∈ [1, n] we have Tj − T′ = T
j
j − T′′
j , for each j ∈ [1, i − 1]
and
Ti − T′ ⊂ T
i
i − T′′
i
or we have
Tj − T′ = T
j
j − T′′
j , for each j ∈ [1, n]
and
T′ − T ⊂ T′′ − T.

Intuitively, T′ ≤T T′′ if the deletions of T′ and T′′ agree up to some level i and then T′
has fewer deletions at level i; or if the deletions match and T′ has fewer insertions. In this manner, higher priority is given to the sentences having lower numbers.

598
Dynamic Aspects
Example 22.4.5
Consider a relation R[ ABC] that satisfies the functional dependency A → B, and consider the instance
R
A
B
C
a
b
c
a
b
c′
a′
b′
c′′
a′′
b′
c′′′
We now construct a tagged theory T to represent this situation and show how changing a B value of a tuple is accomplished.

We assume three tag values and describe the contents of T0, T1, and T2 in turn. T0
holds the functional dependency and the unique name axiom (see Chapter 2). That is, (0, ∀x, y, y′, z, z′(R(x, y, z) ∧ R(x, y′, z′) → y = y′)),
(0, a "= a′), (0, a "= a′′), . . . , (0, a "= b), . . . , (0, c′′ "= c′′′) T1 holds the following existential sentences:

(1, ∃x(R(a, x, c))), 


 (1, ∃x(R(a, x, c′))), 
(1, ∃x(R(a′, x, c′′))),


 (1, ∃x(R(a′′, x, c′′′))) 
Finally, T2 holds

(2, R(a, b, c)), 



(2, R(a, b, c′)), 
(2, R(a′, b′, c′′)),


 (2, R(a′′, b′, c′′′)) 
Consider now the update u = [ insert ϕ], where ϕ = ∃yR(a, b′′, y). Intuitively, this insertion should replace all a, b pairs occurring in πABR by a, b′′. More formally, it is easy to verify that the unique tagged theory (up to choice of i) that accomplishes u is (see Exercise 22.17)

(2, R(a, b′′, c)) 



(2, R(a, b′′, c′)) 
{(i, ϕ)} ∪ T0 ∪ T1 ∪
(2, R(a′, b′, c′′))


 (2, R(a′′, b′, c′′′)) 
Thus the choice of sentences and tags included in the theory can influence the result of an update.

22.4 Updating Incomplete Information
599
The approach of tagged theories can also be used to develop a framework for accomplishing view updates. The underlying database and the view are represented using a tagged theory, and highest priority is given to ensuring that the complement of the view remains fixed. Exercise 22.18 explores a simple example of this approach.

In the approach described here, a set of theories is combined using the disjunction operator. In this case, multiple deletions can lead to an exponential blowup in the size of the underlying theory, and performing insertions is np-hard (see Exercise 22.19). This provided one motivation for developing a generalization of the approach, in which families of theories, called flocks, are used to represent a database with incomplete information.

Update versus Revision
The idea of representing knowledge using theories is not unique to the field of databases.

The field of belief revision takes this approach and considers the issue of revising a knowledge base. Here we briefly compare the approaches to updating database theories described earlier with those found in belief revision.

A starting point for belief revision theory is the set of rationality postulates of Alchourrón, Gärdenfors, and Makinson, often referred to as the AGM postulates. These present a general family of guidelines for when a theory accomplishes a revision, and they include postulates such as
(R1) If T′ accomplishes [ insert ϕ] for T, then T′ |= ϕ.

(R2) If ϕ is consistent with T, then the result of [ insert ϕ] on T should be equivalent to T ∪ {ϕ}.

(R3) If T ≡ T′ and ϕ ≡ ϕ′, then the result of [ insert ϕ] on T is equivalent to the result of
[ insert ϕ′] on T′.

(This is a partial listing of the eight AGM postulates.) Other postulates focus on maintaining satisfiability, relationships between the effects of different updates, and capturing some aspects of minimal change.

It is clear from postulate (R3) that the formula-based approaches to updating database theories do not qualify as belief revision systems. The relationship of the formula-based approaches and belief revision is largely unexplored.

A key difference between belief revision and the model-based approach to updating database theories stems from different perspectives on what a theory T is intended to represent. In the former context, T is viewed as a set of beliefs about the state of the world.

If a new fact ϕ is to be inserted, this is a modification (and, it is hoped, improvement) of our knowledge about the state of the world, but the world itself is considered to remain unchanged. In contrast, in the model-based approaches, the theory T is used to identify a set of worlds that are possible given the limited information currently available. If a fact ϕ
is inserted, this is understood to mean that the world itself has been modified. Thus T is modified to identify a different set of possible worlds.

Example 22.4.6
Suppose that the world of interest is a room with a table in it. There is an abacus and a (hand-held, electronic) calculator in the room. Let proposition a mean that
600
Dynamic Aspects
the abacus is on the table, and let proposition c mean that the calculator is on the table.

Finally, let T be (a ∧ ¬c) ∨ (¬a ∧ c).

From the perspective of belief revision, T indicates that according to our current knowledge, either the abacus or the calculator is on the table, but not both. Suppose that we are informed that the calculator is on the table (i.e., [ insert c]). This is viewed as additional knowledge about the unchanging world. Combining T with c, we obtain the new theory T1 = ((a ∧ ¬c) ∨ (¬a ∧ c)) ∧ c ≡ (¬a ∧ c). [Note that this outcome is required by postulate (R2).]
From the model-based perspective, T indicates that either the world is {a} or it is {c}.

The request [ insert c] is understood to mean that the world has been modified so that c has become true. This can be envisioned in terms of having a robot enter the room and place the calculator on the table (if it isn’t already there) without reporting on the status of anything except that the robot has been successful. As a result, the world {a} is replaced by {a, c}, and the world {c} is replaced by itself. The resulting theory is T2 = c (which is interpreted under the OWA).

A set of postulates for updates, analogous to the AGM postulates for revision, has been developed. The postulate analogous to (R2) is
(U2) If T implies ϕ, then the result of [ insert ϕ] on T should be equivalent to T.

This is strictly weaker than (R2). Other postulates enforce the intuition that the effect of an update on a possible model is independent of the other possible models of a theory, maintaining satisfiability and relationships between the effects of different updates.

22.5
Active Databases
As we have seen, object orientation provides one paradigm for incorporating behavioral information into a database schema. This has the effect of separating a portion of the behavioral information from the application software and providing a more structured representation and organization for that portion. In this section, we briefly consider a second, essentially orthogonal, paradigm for separating a portion of the behavioral information from the application software. This emerging paradigm, called activeness, stems from a synthesis of techniques from databases, on the one hand, and expert systems and artificial intelligence, on the other.

Active databases generally support the automatic triggering of updates in response to internal or external events (e.g., a clock tick, a user-requested update, or a change in a sensor reading). In a manner reminiscent of expert systems, forward chaining of rules is generally used to accomplish the response. However, there are several differences between classical expert systems and active databases. At the conceptual and logical level, the differences are centered around the expressive power of rule conditions and the semantics of rule application. (Some active database systems, such as POSTGRES, also support a form of backward chaining or query rewriting; this is not considered here.) Active databases have been shown to be useful in a variety of areas, including con-
22.5 Active Databases
601
Suppliers
Sname
Address
Prices
Part
Sname
Price
The Depot
1210 Broadway
nail
The Depot
.02
Builder’s Mart
100 Main
bolt
The Depot
.05
bolt
Builder’s Mart
.04
nut
Builder’s Mart
.03
Figure 22.3:
Sample instance for active database examples
straint maintenance, incremental update of materialized views, mapping view updates to the base data, and supporting database interoperability.

Rules and Rule Application
There are three distinguishing components in an active database: (1) a subsystem for monitoring events, (2) a set of rules, often called a rule base, and (3) a semantics for rule application, typically called an execution model.

Rules typically have the following so-called ECA form:
on event if condition then action.

Depending on the system and application, the event may range over external phenomena and/or over internal events (such as a method call or inserting a tuple to a relation). Events may be atomic or composite, where these are built up from atomic events using, say, regular expressions or a process algebra. Events may be essentially Boolean or may return a tuple of values that indicate what triggered the event.

Conditions typically involve parameters passed in by the events, and the contents of the database. As will be described shortly, several systems permit conditions to look at more than one version of the database state (e.g., corresponding to the state before the event and the state after the event). In some systems, events are not explicitly specified; essentially any change to the database makes the event true and leads to testing of all rule conditions.

In principle, the action may be a call to an arbitrary routine. In many cases in relational systems, the action will involve a sequence of insertions, deletions, and modifications; and in object-oriented systems it will involve one or more method calls. Note that this may in turn trigger other rules.

The remainder of this discussion focuses on the relational model. A short example is given, followed by a brief discussion of execution models.

Example 22.5.1
Suppose that the Inventory database includes the following relations: Suppliers[ Sname, Address]
Prices[ Part, Sname, Price]
602
Dynamic Aspects
Suppliers and the parts they supply are represented in Suppliers and Prices, respectively. It is assumed that Sname is a key of Suppliers and Part, Sname is a key of Prices. An example instance is shown in Fig. 22.3.

We now list some example rules. These rules are written in a pidgin language that uses tuple variables. The variable T ranges over sets of tuples and is used to pass them from the condition to the action. As detailed shortly, both (r1) considered in isolation and the set (r2.a) . . . (r2.d) taken together can be used to enforce the inclusion dependency Prices[ Sname] ⊆ Suppliers[ Sname].

(r1)
on true
if Prices(p) and p. Sname ∈ π Sname( Suppliers) then Prices := Prices − {p}
(r2.a)
on delete Sname(s)
if T := σ Sname= s. Sname( Prices) is not empty then Prices := Prices − T
(r2.b)
on modify Sname(s)
if old( s). Sname = new( s). Sname and T = σ Sname= old( s). Sname( Prices) then set p. Sname = new( s). Sname for each p in Prices
where p ∈ T
(r2.c)
on insert Prices(p)
if p. Sname ∈ π Sname( Suppliers) then issue supplier_warning(p)
(r2.d)
on modify Prices(p)
if new( p). Sname ∈ π Sname( Suppliers) then issue supplier_warning( new(p))
Consider rule (r1). If ever a state arises that violates the inclusion dependency, then the rule deletes violating tuples from the Prices relation. The event of (r1) is always true; in principle the database must check the condition whenever an update is made. It is easy to see in this case that such checking need only be done if the relations Supplies or Prices are updated, and so the event “on Supplies or Prices is updated” could be incorporated into (r1). Although this does not change the effect of the rule, it provides a hint to the system about how to implement it efficiently.

Rules (r2.a) . . . (r2.d) form an alternative mechanism for enforcing the inclusion dependency. In this case, the cause of the dependency violation determines the reaction of the system. Here a deletion from (r2.a) or modification (r2.b) to Suppliers will result in deletions from or modifications to Prices. In (r2.b), variable s ranges over tuples that have been modified, old(s) refers to the original value of the tuple, and new(s) refers to the modified value. On the other hand, changes to Prices that cause a violation [rules (r2.c) and
22.5 Active Databases
603
(r2.d)] call a procedure supplier_warning; this might abort the transaction and warn the user or dba of the constraint violation, or it might attempt to use heuristics to modify the offending Sname value.

Execution Models
Until now, we have considered rules essentially in isolation from each other. A fundamental issue concerns the choice of an execution model, which specifies how and when rules will be applied. As will be seen, a wide variety of execution models are possible. The true semantics of a rule base stems both from the rules themselves and from the execution model for applying them.

We assume for this discussion that there is only one user of the system, or that a concurrency control protocol is enforced that hides the effect of other users.

Suppose that a user transaction t = c1; . . . ; cn is issued, where each of the ci’s is an atomic command. In the absence of active database rules, application of t will yield a sequence
I0, I1, . . . , In
of database states, starting with the original state I0 and where each state Ii+1 is the result of applying ci+1 to state Ii. If rules are present, then a different sequence of states might arise.

One dimension of variation between execution models concerns when rules are fired.

Under immediate firing, a rule is essentially fired as soon as its event and condition become true; under deferred firing, rule application is delayed until after the state In is reached; and under concurrent firing, a separate process is spawned for the rule action and is executed concurrently with other processes. In the most general execution models, each rule is assigned its own coupling mode (i.e., immediate, deferred, or concurrent), which may be further refined by associating a coupling mode between event and condition testing and between condition testing and action execution.

We now examine the semantics of immediate and deferred firing in more detail. We assume for this discussion that the event of each rule is simply true.

To illustrate immediate firing, suppose that a rule r with action d1; . . . ; dm is triggered (i.e., its condition has become true) in state I1 of the preceeding sequence of states. Then the sequence of databases states might start with
I0, I1, I′1, I′2, . . . , I′m, . . . , where I′ is the result of applying d
is the result of applying d
.

1
1 to I1 and I′j+1
j +1 to I′j
After I′ , the command
m
c2 would be applied. The semantics of intermediate rule firing
is in fact more complex, for two reasons. First, another rule might be triggered during the execution of the action of the first triggered rule. In general, this calls for a recursive style of rule application, where the command sequences of each triggered rule are placed onto a stack. Second, several rules might be triggered at the same time. One approach in
604
Dynamic Aspects
this case is to assume that the rules are ordered and that rules triggered simultaneously are considered in that order. Another approach is to fire simultaneously-triggered rules concurrently; essentially this has the effect of firing them in a nondeterministic order.

In the case of deferred firing, the full user transaction is completed before any rules are fired, and each rule action is executed in its entirety before another rule action is initiated.

This gives rise to a sequence of states having the form
I orig, I user, I2, I3, . . . , I curr, where now I orig is the original state, I user is the result of applying the user-requested transaction, and the states I2, I3, . . . , I curr are the results of applying the actions of fired rules. The sequence shown here might be extended if additional rules are to be fired.

Several intricacies arise. As before, the order of rule firing must be considered if multiple rules are triggered at a given state. Recall the (r2) rules of Example 22.5.1, whose events where based on transitions between some former state and some latter state. What states should be used? It is natural to use I curr as the latter state. With regard to the former state, some systems advocate using I orig, whereas other systems support the use of one of the intermediate states (where the choice may depend on a complex condition).

Suppose that two rules r and r′ are triggered at some state I curr = Ii and that r is fired first to reach state Ii+1. The event and/or condition of r′ may no longer be true. This raises the question, Should r′ be fired? A consensus has not emerged in the literature.

As should be clear from the preceeding discussion, there is a wide variety of choices for execution models. A more subtle dimension of flexibility concerns the expressive power of rule events and conditions: In addition to accessing the current state, should they be able to access one or more previous ones? Several prototype active database systems have been implemented; each uses a different execution model, and several permit access to both current and previous states. It has been argued that different execution models may be appropriate for different applications. This has given rise to systems that include a choice of execution models and to languages that permit the specification of customized execution models. An open problem at the time this book was written is to develop a natural syntax that can be used to specify easily a broad range of execution models, including a substantial subset of those described in the literature.

The while languages studied in Part E can serve as the kernel of an active database.

These languages do not use events; restrict rule actions to insertions, deletions, and value creation; and examine only the current state in a rule firing sequence. If value creation is supported, then these languages are complete for database mappings and so in some sense can simulate all active databases. However, richer rules and execution models permit the possibility of developing rule bases that enforce a desired set of policies in a more intuitive fashion than a while program.

An Execution Model That Reaches a Unique Fixpoint
It should be clear that whatever execution model and form for rules is selected, most questions about the behavior of an active database are undecidable. It is thus interesting to consider more restricted execution models that behave in predictable ways. We now present one such execution model, called the accumulating model; this forms a portion of
22.5 Active Databases
605
the execution model of AP5, a main-memory active database system that has been used in research for over a decade.

To describe the accumulating execution model, we first introduce the notion of a delta.

Let R = {R1, . . . , Rn} be a database schema. An atomic update over R is an expression of the form +Ri(t) or −Ri(t), where i ∈ [1, n] and t is a tuple having the arity of Ri. A delta over R is a finite set of atomic updates over R that does not contain both +R(t) and −R(t) for any R and t or the special value fail. (Modifies could also be incorporated into deltas, but we do not consider that here.) A delta not containing the value fail is consistent. For delta , we define
+ = {R(t ) | +R(t ) ∈ }
− = {R(t ) | −R(t ) ∈ }.

Given instance I and consistent delta over R, the result of applying to I is apply(I, ) = (I ∪ +) − − = (I − −) ∪ +.

Finally, the merge of two consistent deltas 1, 2 is defined by 1 ∪ 2
if this is consistent
1&2 =
fail
otherwise.

The accumulating execution model uses deferred rule firing. Each rule action is viewed as producing a consistent delta. The user-requested transaction is also considered to be the delta 0. Thus a sequence of states
I orig = I0, I user = I1, I2, I3, . . . , I curr is produced, where I user = apply(I orig, 0) and, more generally, Ii+1 = apply(Ii, i) for some i produced by a rule firing.

At this point the accumulating model is quite generic. We now restrict the model and develop some interesting theoretical properties. First we assume that rules have only conditions and actions (i.e., that the event part is always true). Second, as noted before, we assume that the action of each rule can be viewed as a delta. Furthermore, we assume that these deltas use only constants from I orig (i.e., there is no invention of constants). Third we insist that for each i ≥ 0, 0& . . . &i is consistent. More precisely, we modify the execution model so that if for some i we have 0& . . . &i = fail, then the execution is aborted. For each i ≥ 0, let ′ =
i
0& . . . &i.

Suppose that we are now in state I curr with delta curr. We assume that rule conditions can access only I orig and curr. (If the rule conditions have the power of, for example, the relational calculus, this means they can in effect access I curr.) Given rule r, state I, and delta , the effect of r on I and , denoted effect(r, I, ), is the delta corresponding to the firing of r on I and , if the condition of r is satisfied, and is ∅ otherwise.

Execution proceeds as follows. The sequence ′ , ′ , . . . is constructed sequentially.

0
1
At the ith step, if there is no rule whose condition is satisfied by I orig and ′ , then execution i
terminates successfully. Otherwise a rule r with condition satisfied by I orig and ′ is i
606
Dynamic Aspects
selected nondeterministically. If ′ & effect(r, I orig, ′ ) is fail, then execution terminates i
i
with an abort; otherwise set ′
= ′ & effect(r, I orig, ′ ) and continue.

i+1
i
i
A natural question at this point is, Will execution always terminate? It is easy to see that it does, because constants are not invented and the sequence of deltas being constructed is monotonically increasing under set containment.

It is also natural to ask, Does the order of rule firing affect the outcome? In general, the answer is yes. We now develop a semantic condition on rules that ensures independence of rule firing order. A rule r is monotonic if for each instance I and pair 1 ⊆ 2 of deltas, effect(r, I, 1) ⊆ effect(r, I, 2). The following can now be shown (see Exercise 22.23): Theorem 22.5.2
If each rule in a rule base is monotonic, then the outcome of the
accumulating execution model on this rule base is independent of rule firing order.

Monitoring Events and Conditions
In Example 22.5.1, the events that triggered rules were primitive, in the sense that each one corresponded to an atomic occurrence of some phenomenon. There has been recent interest in developing languages for specifying and recognizing composite events, which might involve the occurrence of several primitive events. For example, composite event specification is supported by the ODE system, a recently released prototype object-oriented active database system. The ODE system supports a rich language for specifying composite events, which has essentially the power of regular expressions (see also Section 22.6
for examples of composite events specified by regular expressions). An implementation technique based on finite state automata has been developed for recognizing composite events specified in this language.

Other formalisms can also be used for specifying composite events (e.g., using Petri nets or temporal logics). There appears to be a trade-off between the expressiveness of triggers in rules and conditions. For example, some Petri-net-based languages for composite events can be simulated using additional relations and rules based on simple events. The details of such trade-offs are largely unexplored.

22.6
Temporal Databases and Constraints
Classical databases model static aspects of data. Thus the information in the database consists of data currently true in the world. However, in many applications, information about the history of data is just as important as static information. When history is taken into account, queries can ask about the evolution of data through time; and constraints may restrict the way changes occur. We briefly discuss these two aspects.

Temporal Databases
Suppose we are interested in a database over some schema R. Thus we wish to model and query information about the content of the database through time. Conceptually, we can associate to each time t the state It of the database at time t. Thus the database appears as a
22.6 Temporal Databases and Constraints
607
sequence of states— snapshots—indexed by some time domain. Two basic questions come up immediately:
• What is the meaning of It? Primarily two possible answers have been proposed. The first is that It represents the data that was true in the world at time t; this view of time is referred to as valid time. The second possibility is that time represents the moment when the information was recorded in the database; this is called transaction time.

Clearly, using valid time requires including time as a first-class citizen in the data model. In many applications transaction time might be hidden and dealt with by the system; however, in time-critical applications, such as air-traffic control or monitoring a power plant, transaction time may be important and made explicit. A particular database may use valid time, transaction time, or both. In our discussion, we will consider valid time only.

• What is the time domain? This can be discrete (isomorphic to the integers), continuous (isomorphic to the reals), or dense and countable (isomorphic to the rationals).

In databases, time is usually taken to be discrete, with some fixed granularity for the time unit. However, several distinct time domains with different granularities are often used (e.g., years, months, days, hours, etc.). The time domain is usually equipped with a total order and sometimes with arithmetic operations. A temporal variable now may be used to refer to the present time.

To query a temporal database, relational languages must be extended to take into account the time coordinate. To say that a tuple u is in relation R at time t, we could simply extend R with one temporal coordinate and write R(u, t). Then we could use CALC or ALG on the extended relations. This is illustrated next.

Example 22.6.1
Consider the CINEMA database, indexed by a time domain consisting of dates of the form month/day/year. The query
“What were the movies shown at La Pagode in May, 1968?”
is expressed in CALC by
{m | ∃s, t ( Pariscope(La Pagode, m, s, t) ∧ 5/1/68 ≤ t ≤ 5/31/68)}.

The query
“Since when has La Pagode been showing the current movie?”
is expressed by
{t | ∃m[∃s( Pariscope(“La Pagode”, m, s, now))∧
since(t, m) ∧ ∀t ′′( since(t ′′, m) → t ≤ t ′′)]},
where
608
Dynamic Aspects
since(t, m) = ∀t ′[t ≤ t′ ≤ now → ∃s′( Pariscope(“La Pagode”, m, s′, t′))].

Classical logics augmented with a temporal coordinate have been studied extensively, mostly geared toward specification and verification of concurrent programs. Such logics are usually referred to as temporal logics. There is a wealth of mathematical machinery developed around temporal logics; unfortunately, little of it seems to apply directly to databases.

Although the view of a temporal database as a sequence of instances is conceptually clean, it is extremely inefficient to represent a temporal database in this manner. In practice, this information is summarized in a single database in which data is timestamped to indicate the time of validity. The timestamps can be placed at the tuple level or at the attribute level. Typically, timestamps are unions of intervals of the temporal domain. Such representations naturally lead to nested structures, as in the nested relation, semantic, and object-oriented data models.

Example 22.6.2
Figure 22.4 is a representation of temporal information about Pariscope using attribute timestamps with nested relations. It would also be natural to represent this using a semantic or object-oriented model.

The same information can be represented by timestamping at the tuple level, as follows:
Pariscope
Theater
Title
Schedule
La Pagode
Sleeper
19:00
[5/1/68–5/31/68]
La Pagode
Sleeper
19:00
[7/15/74–7/31/74]
La Pagode
Sleeper
19:00
[12/1/93–now]
La Pagode
Sleeper
22:00
[8/1/74–8/14/75]
La Pagode
Sleeper
22:00
[10/1/93–11/30/93]
La Pagode
Psycho
19:00
[8/1/93–11/30/93]
La Pagode
Psycho
22:00
[2/15/78–10/14/78]
La Pagode
Psycho
22:00
[12/1/93–now]
Kinopanorama
Sleeper
19:30
[4/1/90–10/31/90]
Kinopanorama
Sleeper
19:30
[2/1/92–8/31/92]
In this representation, the time intervals are more fragmented. This may have some drawbacks. For example, retrieving the information about when “Sleeper” was playing at La Pagode (using a selection and projection) yields time intervals that are more fragmented than needed. To obtain a more concise representation of the answer, we must merge some of these intervals.

Note also the difference between the timestamps and the attribute Schedule, which also conveys some temporal information. The value of Schedule is user defined, and the database may not know that this is temporal information. Thus from the point of view of
22.6 Temporal Databases and Constraints
609
Pariscope Theater
Title
Schedule
[5/1/68–5/31/68]
19:00
[7/15/74–7/31/74]
[5/1/68–5/31/68]
[12/1/93–now]
Sleeper
[7/15/74–8/14/75]
[10/1/93–now]
[8/1/74–8/14/75]
22:00
[10/1/93–11/30/93]
La Pagode
19:00
[8/1/93–11/30/93]
[2/15/78–10/14/78]
Psycho
[8/1/93–now]
[2/15/78–10/14/78]
22:00
[12/1/93–now]
[4/1/90–10/31/90]
[4/1/90–10/31/90]
Kinopanorama
Sleeper
19:30
[2/1/92–8/31/92]
[2/1/92–8/31/92]
Figure 22.4:
A representation of temporal information using attribute timestamps with nested relations
the temporal database, the value of Schedule is treated just like any other nontemporal value in the database.

Much of the research in temporal databases has been devoted to finding extensions of SQL and other relational languages suitable for temporal queries. Most proposals assume some representation based on tuple timestamping by intervals and introduce intuitive linguistic constructs to compare and manipulate these temporal intervals. Sometimes this is done without explicit reference to time, in the spirit of modal operators in temporal logic.

One such operator is illustrated next.

Example 22.6.3
Several temporal extensions of SQL use a when clause to express a temporal condition. For example, consider the query on the CINEMA database:
“Find the pairs of theaters that have shown some movie at the same date and hour.”
This can be expressed using the when clause as follows:
610
Dynamic Aspects
select t1. theater, t2. theater
from Pariscope t1 t2
where t1. title = t2. title and t1. schedule = t2. schedule when t1. interval overlaps t2. interval
The when clause is true for tuples t1, t2 iff the intervals indicating their validity have nonempty intersection. Other Boolean tests on intervals include before, after, during, follows, precedes, etc., with the obvious semantics. The expressive power of such constructs is not always well elucidated in the literature, beyond the fact that they can clearly be expressed in CALC. A review of the many constructs proposed in the literature on temporal databases is beyond the scope of this book. For the time being, it appears that a single well-accepted temporal language is far from emerging, although there are several major prototypes.

Temporal Deductive Databases
An interesting recent development involves the use of deductive databases in the temporal framework, yielding temporal extensions of datalog. This can be used in two main ways.

• As a specification mechanism: Datalog-like rules allow the specification of some temporal databases in a concise fashion. In particular, this allows us to specify infinite temporal databases, with both past and future information.

• As a query mechanism: Rules can be used to express recursive temporal queries.

Example 22.6.4
We first illustrate the use of rules in the specification of an infinite temporal database. The database holds information on a professor’s schedule—more precisely, the times she meets her two Ph.D. students. The facts
meets- first( Emma, 0), follows( Emma, John), follows( John, Emma) say that the professor’s first meeting is with Emma, and then John and Emma take turns.

Consider the rules
meets(x, t )
← meets- first(x, t)
meets(y, t + 1) ← meets(x, t), follows(x, y) The rules define the following infinite sequence of facts providing the professor’s schedule: meets( Emma, 0)
meets( John, 1)
meets( Emma, 2)
meets( John, 3)
...

22.6 Temporal Databases and Constraints
611
Another way to use temporal rules is for querying. Consider the query
“Find the times t such that La Pagode showed ‘Sleeper’ on date t and continued to show it at least until the Kinopanorama started showing it.”
The answer (given in the unary relation until) is defined by the following stratified program: date(x, y, t ) ← Pariscope(x, y, s, t )
until(t )
← date(“Kinopanorama”, “Sleeper”, t + 1),
¬ date(“Kinopanorama”, “Sleeper”, t),
date(“La Pagode”, “Sleeper”, t)
until(t )
← date(“La Pagode”, “Sleeper”, t), until(t + 1)
The expressiveness of several datalog-like temporal languages and the complexity of query evaluation using such languages are active areas of research.

Temporal Constraints
Classical constraints in relational databases are static: They speak about properties of the data seen at some moment in time. This does not allow modeling the behavior of data.

Temporal (or dynamic) constraints place restrictions on how the data changes in time. They can arise in the context of classical databases as well as in temporal databases. In temporal databases, we can specify restrictions on the sequence of time-indexed instances using temporal logics (extensions of CALC, or modal logics). These are essentially Boolean (yes/no) temporal queries. For example, we might require that “La Pagode” not be a first-run theater (i.e., every movie shown there must have been shown in some other theater at some earlier time). An important question is how to enforce such constraints efficiently. A step in this direction is suggested by the following example.

Example 22.6.5
Suppose that Pariscope is extended with a time domain ranging over days, as in Example 22.6.1. The constraint that “La Pagode” is not a first-run theater can be expressed in CALC as
∀m, s, t ( Pariscope(“La Pagode”, m, s, t)
→ ∃x, s′, t ′( Pariscope(x, m, s′, t′) ∧ x = “La Pagode” ∧ t′ < t)) A naive way to enforce this constraint involves maintaining the full history of the relation Pariscope; this would require unbounded storage. A more efficient way involves storing only the current value of Pariscope and maintaining a unary relation Shown_
Before[ Title], which holds all movie titles that have been shown in the past at a theater other than “La Pagode.” Note that the size of Shown_Before is bounded by the number of titles that have occurred through the history of the database but is independent of how long the database has been in existence. (Of course, if a new title is introduced each day, then Shown_Before will have size comparable to the full history.)

612
Dynamic Aspects
A systematic approach has been developed to maintain temporal constraints in this fashion.

For classical databases, in which no history is kept, temporal constraints can only involve transitions from the current instance to the next; this gives rise to a subset of temporal constraints, called transition constraints
For instance, a transition constraint can state that “salaries do not decrease” or that
“the new salary of an employee is determined by the old salary and the seniority.” Such transition constraints are by far the most common kind of temporal constraint considered for databases. We discuss some ways to specify transition constraints. Clearly, these can be stated using a temporal version of CALC that can refer to the previous and next state. A notion of identity similar to object identity is useful here; otherwise we may have difficulty speaking about the old and new versions of some tuple or entity. Such identity may be provided by a key, assuming that it does not change in time.

Besides CALC, transition constraints may be stated in various other ways, including
• pre- and postconditions associated with transitions;
• extensions of classical static constraints, such as dynamic fd’s;
• computational constraints on sequences of consecutive versions of tuples.

Restrictions on updates—say, by transactional schemas—also induce temporal constraints. For instance, consider again the transactional schema in Example 22.2.1. It can be verified that all possible sequences of instances obtained by calls to the transactions of that schema satisfy the temporal constraint:
“Nobody can be a PhD student without having been a TA at some point.”
The following less desirable temporal constraint is also satisfied:
“Once a PhD student, always a PhD student.”
Overall, the connection between canned updates and temporal constraints remains largely unexplored.

A related means of specifying temporal constraints is to identify a set of update events and impose restrictions on valid sequences of events. This can be done using regular expressions. For example, suppose that the events concerning an employee are hire, transfer, promote, raise, fire, retire The valid sequences of events are all prefixes of sequences specified by the regular expression
hire[(transfer) + (promote + ǫ)(raise)]∗[(retire) + (fire)]
Thus an employee is first hired, receives some number of promotions and raises, may be transferred, and finally either retires or is fired. Everybody who is promoted must also
Bibliographic Notes
613
receive a raise, but raises may be received even without promotion. Such constraints appear to be particularly well suited to object-oriented databases, in which events can naturally be associated with method invocations. Some active databases (Section 22.5) can also enforce constraints on sequences of events.

Bibliographic Notes
The properties of IDM transactions were formally studied in [AV88b]. The sound and complete axiomatization for IDM transactions is provided in [KV91]. The results on simplification rules are also presented there. The language datalog¬¬ and other rule-based and imperative update languages are studied in [AV88c]. Dynamic Logic Programming is discussed in [MW88b]. In particular, Example 22.1.3 is from there. The language LDL, including its update capabilities, is presented in [NT89].

IDM transactional schemas are investigated in [AV89]. Transactional schemas based on more powerful languages are discussed in [AV87, AV88a]. Patterns of object migration in object-oriented databases are studied in [Su92], using results on IDM transactional schemas. A simple update language is shown there to express the family of migration patterns characterized by regular languages; richer families of patterns are obtained by permitting conditionals in this language.

One of the earliest works on the view maintenance problem is [BC79], which focuses on determining whether an update is relevant or not. References [KP81, HK89] study the maintenance of derived data in the context of semantic data models, and [SI84] studies the maintenance of a universal relation formed from an acyclic database family. Additional works that use the approach of incremental evaluation include [BLT86, GKM92, Pai84, QW91]. Heuristics for maintaining the materialized output of a stratified datalog¬ program are developed in [AP87b, Küc91]. A comprehensive approach, which handles views defined using the stratified datalog and aggregate operators, is developed in [GMS93].

Reference [Cha94] addresses the issue of incremental update to materialized views in the presence of OIDs.

Testing for relevance of updates in connection with view maintenance is related to the problem of incremental maintenance of integrity constraints. References [BBC80, HMN84] develop general techniques for this problem, and approaches for deductive databases include [BDM88, LST87, Nic82].

The issue of first-order incremental definability of datalog programs was first raised in [DS92] and [DS93]. Additional research in this area includes [DT92, DST94]. A more general perspective on these kinds of problems is presented in [PI94].

An informative survey of research on the view update problem is [FC85]. One practical approach to the view update problem is to consider the underlying database and the view to be abstract data types, with the updating operations predefined by the dba [SF78, RS79].

The other practical approach is to perform a careful analysis of the syntax and semantics of a view definition to determine a unique or a small set of update translation(s) that satisfy a family of natural properties. This approach is pioneered in [DB82] and further developed in [Kel85, Kel86]. Example 22.3.6 is inspired by [Kel86]. Reference [Kel82] considers the issue of unavoidable side-effects from view updates.

The discussion of view complements and Theorem 22.3.10 is from [BS81]. Reference
614
Dynamic Aspects
[CP84] studies complexity issues in this area; for example, in the context of projective views over a single relation possibly having functional dependencies, finding a minimal complement is np-complete. Reference [KU84] examines some of the practical shortcomings of the approach based on complementary views.

The semantics of updates on incomplete databases is investigated in [AG85] and
[Gra91].

The idea of representing a database as a logical theory, as opposed to a set of atomic facts, has roots in [Kow81, NG78, Rei84]. A survey of approaches to updating logical theories, which articulates the distinction between model-based and formula-based approaches, is [Win88]. Reference [Win86] develops a model-based approach for updating theories that extends the framework of [Rei84]. Complexity and expressiveness issues related to this approach are studied in [GMR92, Win86]. A model-based approach has recently been applied in connection with supporting object migration in object-oriented databases in [MMW94].

An early formula-based approach to updating is discussed in [Tod77]. This chapter’s discussion of the formula-based approach is inspired largely by [FUV83]. The notion of using flocks (i.e., families of theories) to describe incomplete information databases is developed in [FKUV86]. Reference [Var85] investigates the complexity of querying databases that are logical theories and shows that even in restricted cases, the complexity of, for example, the relational calculus goes from logspace to co-np-complete.

References on belief revision include [AGM85], where the AGM postulates are developed, and [Gär88, Mak85]. The contrast between belief revision and knowledge update was articulated informally in [KW85] and formally in [KM91a], where postulates for updating theories under the model-based perspective were developed; see also [GMR92, KM91b].

The discussion in this chapter is inspired by [KM91a].

Active databases generally support the automatic triggering of updates as a response to user-requested or system-generated updates. Most active database systems (e.g.,
[CCCR+90, Coh86, MD89, Han89, SKdM92, SJGP90, WF90]) use a paradigm of rules to specify the actions to be taken, in a manner reminiscent of expert systems.

Active databases and techniques have been shown to be useful for constraint maintenance [Mor83, CW90, CTF88], incremental update of materialized views [CW91], and database security [SJGP90]; and they hold the promise of providing a new family of solutions to the view and derived data update problem [CHM94] and issues in database interoperability [CW93, Cha94, Wie92]. Another functionality associated with some active databases is query rewriting [SJGP90], whereby a query q might be transformed into a related query q′ before being executed.

As discussed in Section 22.5 (see also [HJ91b, HW92, Sto92]), each of the active database systems described in the literature uses a different approach for event specification and a different execution model. The execution models of several active database systems are specified using deltas, either implicitly or explicitly [Coh86, SKdM92, WF90]. The Heraclitus language [HJ91a, JH91, GHJ+93] elevates deltas to be first-class citizens in a database programming language based on C and the relational model, thereby enabling the specification, and thus implementation, of a wide variety of execution models. Execution models that support immediate, deferred, and concurrent firing include [BM91, HLM88, MD89].

Exercises
615
The accumulating execution model forms part of the semantics of the AP5 active database model [Coh86, Coh89] (see also [HJ91a]). Theorem 22.5.2 is from [ZH90], which goes on to present syntactic conditions on rules that ensure the Church-Rosser property for rule bases that are not necessarily monotonic.

An early investigation of composite events in connection with active databases is
[DHL91]. Reference [GJS92c] describes the event specification language of the ODE
active database system [GJ91]. Reference [GJS92b] presents the equivalence of ODE’s composite event specification language and regular expressions, and [GJS92a] develops an implementation technique based on finite state automata for recognizing composite events in the case where parameters are omitted. Reference [GD94] uses an alternative formalism for composite events based on Petri nets and can support parameters.

A crucial issue with regard to efficient implementation of active databases is determining incrementally when a condition becomes true. Early work in this area is modeled after the RETE algorithm from expert systems [For82]. Enhancements of this technique biased toward active database applications include [WH92, Coh89]. Reference [CW90] describes a mechanism for analyzing rule conditions to infer triggers for them.

There is a vast amount of literature on temporal databases. The volume [TCG+93]
provides a survey of current research in the area. In particular, several temporal extensions of SQL can be found there. Bibliographies on temporal databases are provided in
[Sno90, Soo91]. A survey of temporal database research, emphasizing theoretical aspects, is provided in [Cho94]. Deductive temporal databases are presented in [BCW93]. Example 22.6.4 is from [BCW93].

Specification of transition constraints by pre- and postconditions is studied in [CCF82, CF84]. Transition constraints based on a dynamic version of functional dependencies are investigated in [Via87], where the interaction between static and dynamic fd’s is discussed.

Constraints of a computational flavor on sequences of objects ( object histories) are considered in [Gin93]. Temporal constraints specified by regular languages of events (where the events refer to object migration in object-oriented databases) are studied in [Su92].

References [Cho92a, LS87] develop the approach of “history-less” checking of temporal constraints, as illustrated in Example 22.6.5. This technique is applied to testing real-time temporal constraints in [Cho92b], providing one approach to monitoring complex events in an active database system.

Temporal databases are intimately related to temporal logic. Informative overviews of temporal logic can be found in [Eme91, Gal87].

A survey of dynamic aspects in databases is provided in [Abi88].

Exercises
Exercise 22.1
Show that there are updates expressible by IDM transactions that are not expressible by ID transactions (i.e., transactions with just insertions and deletions).

Exercise 22.2
Prove the soundness of the equivalence axioms
616
Dynamic Aspects
mod(C → C′) del(C′) ≡ del(C) del(C′)
ins(t ) mod(C → C′)
≡ mod(C → C′) ins(t′)
where t satisfies C and {t′} = mod(C → C′)({t})
and
del(C3) mod(C1 → C3) mod(C2 → C1) mod(C3 → C2)
≡ del(C3) mod(C2 → C3) mod(C1 → C2) mod(C3 → C1), where C1, C2, C3 are mutually exclusive sets of conditions.

Exercise 22.3
Show that, for each IDM transaction, there exists a CALC query defining the same result but that the converse is false. Characterize the portion of CALC (or ALG) expressible by IDM transactions.

Exercise 22.4
[AV88b] Show that for every IDM transaction there exists an equivalent IDM
transaction of the form td; tm; ti, where td is a sequence of deletions, tm is a sequence of modifications, and ti is a sequence of insertions.

♠ Exercise 22.5
[VV92] Let t1, . . . tk be IDM transactions over the same relation R. A schedule s for t1, . . . , tk is an interleaving of the updates in the ti’s, such that the updates of each ti occur in s in the same order as in ti. The schedule s is serializable if it is equivalent to tσ(1) . . . tσ(k) for some permutation σ of {1, . . . , k}.

(a) Prove that checking whether a schedule s for a set of IDM transactions t1, . . . , tk is serializable is np-complete with respect to the size of s.

(b) Show that checking the serializability of a schedule can be done in polynomial time if the transactions contain no modifications.

♠ Exercise 22.6
[KV90a] Suppose m boxes B1, . . . , Bm are given. Initially, each box Bi is either empty or contains some balls. Balls can be moved among boxes by any sequence of moves, m(Bj , Bk), each of which consists of putting the entire contents of box Bj into box Bk. Suppose that the balls must be redistributed among boxes according to a given mapping f from boxes to boxes [f (Bj ) = Bk means that the contents of box Bj must wind up in box Bk after the redistribution].

(a) Show that redistribution according to a given mapping f cannot always be accomplished by a sequence of moves. If it can, the mapping f is called realizable. Characterize realizable redistribution mappings.

(b) A parallel schedule of moves is a partially ordered set of moves (M,≤) such that incomparable moves commute. (Thus incomparable moves are independent and can be executed in parallel.) A parallel schedule takes time t if the depth of the partial order is t. Show that the problem of testing if a parallel schedule of moves accomplishes the redistribution in minimal time (according to a realizable redistribution mapping) is np-complete with respect to m.

(c) Show that testing if a parallel schedule accomplishes the redistribution in time within one unit from the minimal time can be done in time polynomial in m.

(d) What is the connection between moving balls and IDM transactions?

Exercise 22.7
Recall the transaction schema T of Example 22.2.1 and the set of constraints in Example 22.2.2.

Exercises
617
(a) Prove that T is sound and complete with respect to .

(b) Exhibit instances I and J in Sat( ), where I cannot be transformed into J using T.

(c) Write a transactional schema T′ that is sound and complete for , such that whenever I, J are in Sat( ), there is a transformation from I to J using T′. (Do not use a T′
that completely empties the database to make a change involving only one student.) Exercise 22.8
[AV89] Prove Theorem 22.2.3.

Exercise 22.9
Prove the statements in Example 22.2.4.

♠ Exercise 22.10
[AV89]
(a) Prove that it is undecidable whether I ∈ Gen(T) for given IDM transactional schema T and instance I over a database schema. Hint: Reduce the question of whether w ∈ L(M) for a word w and Turing machine M to the preceeding problem.

(b) Show that (a) becomes decidable if T is an ID transactional schema (no modifications). Hint: For I ∈ Gen(T), find a bound on the number of calls to transactions in T needed to reach I and on the number of constants used in these calls.

(c) Prove that it is undecidable whether Gen(T) = Gen(T′) for given IDM transactional schemas T and T′.

♠ Exercise 22.11
[AV89]
(a) Show that there is a relation schema R and a join dependency g over R such that Sat({g}) = Gen(T) for each IDM transactional schema T over R.

(b) Prove that there is a database schema R and a set of inclusion dependencies over R, such that Sat( ) = Gen(T) for each IDM transactional schema T over R.

♠ Exercise 22.12
[AV89] Prove that it is undecidable whether Gen(T) equals all instances over R for given IDM transaction schema T over R. What does this say about the decidability of soundness and completeness of IDM transaction schemas with respect to sets of constraints?

Exercise 22.13
[QW91] Develop expressions for incremental evaluation of the relational algebra operators, analogous to the expression for join in Example 22.3.3. Consider both insertions and deletions from the base relations.

Exercise 22.14
Recast c-tables in terms of first-order theories. Observe that the approach to updating c-tables is model based. Given a theory T corresponding to a c-table and an update, describe how to change T in accordance with the update. Hint: To represent c-tables using a theory, you will need to use variations of the equality, extension, unique name, and closure axioms mentioned at the end of Chapter 2.

Exercise 22.15
Prove Proposition 22.4.3.

Exercise 22.16
[FUV83] Given theory T, define T′ T T′′ if T′ − T ⊂ T′′ − T, or if T′ − T =
T′′ − T and T − T′ ⊆ T − T′′. Thus T is like ≤T, except that insertions are given priority over deletions.

Let T be a closed theory, ϕ a sentence not in T, and T′ a closed theory that accomplishes
[ insert ϕ] for T. Show that {ϕ}∗ T T′.

Exercise 22.17
[FUV83] Verify the claim of Example 22.4.5.

Exercise 22.18
[FUV83] Let R[ ABC] be a relation schema with functional dependency A →
B, and let I be the instance of Example 22.4.5.

618
Dynamic Aspects
Consider the view f over S[AB] defined by πAB(R). A complement of this view is πAC(R). The idea of keeping this complement unchanged while updating the view is captured by the sentences

∃x(R(a, x, c)), 



∃x(R(a, x, c′)) 
∃x(R(a′, x, c′′))


 ∃x(R(a′′, x, c′′′)) 
Let T0 be that set of sentences. Let T1 include the functional dependency and the unique name axioms. Finally, let T2 include the four atoms of I. Verify that there is a unique tagged theory that accomplishes the view update [ insert S(a, b′′)] with minimal change.

Exercise 22.19
[FUV83] Show that under the formula-based approach to updating theories presented in Section 22.4,
(a) A sequence of deletions can lead to an exponential blowup in the size of the theory.

(b) Determining the result of an insertion is np-hard.

Exercise 22.20
[DT92, DS93] Give a formal definition of FOID and of FOID with auxiliary relations. Include the cases in which sets of insertions and/or deletions are permitted.

♠ Exercise 22.21
[DT92]
(a) Verify the claim of Example 22.3.4, that the transitive closure query is FOID.

(b) Consider the datalog program
R(z) ← R(x), S(x, y, z)
R(z) ← R(y), S(x, y, z)
R(x) ← T (x)
An intuitive interpretation of this is that the variables range over nodes in a graph, and the predicate S(a, b, c) indicates that nodes a and b are connected by an or-gate to node c. The relation R contains all nodes that have value true, assuming that the nodes in the input relation T are initially set to true.

Prove that there is a FOID with auxiliary relations for R. Hint: Define a new derived relation Q that holds paths of nodes with value true.

(c) Prove that there is no FOID without auxiliary relations for R.

⋆ (d) A regular chain program consists of a finite set of chain rules of the form R(x, z) ← R1(x, y1), R2(y1, y2), . . . , Rn(yn−1, z),
where the only idb predicate occurring in the body (if any) is Rn. Show that each regular chain program is FOID with auxiliary relations. In particular, describe an algorithm that produces, for each regular chain program defining a predicate R, a first-order query with auxiliary relations that incrementally evaluates the program.

Exercise 22.22
Specify in detail an active database execution model based on immediate rule firing.

Exercise 22.23
[ZH90] Recall the accumulating execution model for active databases.

Exercises
619
(a) Exhibit a rule base for which the outcome of execution depends on the order of rule firing.

(b) Prove Theorem 22.5.2.

⋆ Exercise 22.24 [HJ91a] Recall that in the accumulating semantics, rule conditions can access I orig and curr. Consider an alternative semantics that differs from the accumulating semantics only in that the rule conditions can access only I orig and I curr. Suppose that rule conditions have the expressive power of the relational calculus (and in the case of the accumulating semantics, the ability to access the sets + = {R(t) | +R(t) ∈ } and − = {R(t) | −R(t) ∈ }). Show R
R
that the accumulating semantics is more expressive than the alternative semantics. Hint: It is possible that curr may have “redundant” elements, e.g., an update +R(t), where R(t) ∈ I orig.

Such redundant elements are not accessible to the alternative semantics.

Exercise 22.25
Consider a base schema B = {R[AB]} and a view f = πAR, as in Example 22.3.8(b).

(a) Describe a complement g of f that is not equivalent to ⊤.

(b) Show that each complement g of f expressible in the relational algebra is equivalent to ⊤.

Exercise 22.26
[BS81] Prove Theorem 22.3.10. Hint: Consider the equivalence relation on Inst(B) defined by I ≡ I′ iff ∃ update ν ∈ Uf such that I′ = t (ν)(I). Now define the mapping g : Inst(I) → Inst(I)/ ≡ so that g(I) is the equivalence class of I under ≡.

Bibliography
[57391] ISO/IEC JTC1/SC21 N 5739. Database language SQL, April 1991.

[69392] ISO/IEC JTC1/SC21 N 6931. Database language SQL (SQL3), June 1992.

[A+76] M. M. Astrahan et al. System R: a relational approach to data management. ACM Trans. on Database Systems, 1(2):97–137, 1976.

[AA93] P. Atzeni and V. De Antonellis. Relational Database Theory. Benjamin/Cummings Publishing Co., Menlo Park, CA, 1993.

[AABM82] P. Atzeni, G. Ausiello, C. Batini, and M. Moscarini. Inclusion and equivalence between relational database schemata. Theoretical Computer Science, 19:267–285, 1982.

[AB86] S. Abiteboul and N. Bidoit. Non first normal form relations: An algebra allowing restructuring. Journal of Computer and System Sciences, 33(3):361–390, 1986.

[AB87a] M. Atkinson and P. Buneman. Types and persistence in database programming languages.

ACM Computing Surveys, 19(2):105–190, June 1987.

[AB87b] P. Atzeni and M. C. De Bernardis. A new basis for the weak instance model. In Proc. ACM
Symp. on Principles of Database Systems, pages 79–86, 1987.

[AB88] S. Abiteboul and C. Beeri. On the manipulation of complex objects. Technical Report, INRIA and Hebrew University, 1988. (To appear, VLDB Journal.)

[AB91] S. Abiteboul and A. Bonner. Objects and views. In Proc. ACM SIGMOD Symp. on the Management of Data, 1991.

[ABD+89] M. Atkinson, F. Bancilhon, D. DeWitt, K. Dittrich, D. Maier, and S. Zdonik. The object-oriented database system manifesto. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), pages 40–57, 1989.

[ABGO93] A. Albano, R. Bergamini, G. Ghelli, and R. Orsini. An object data model with roles. In Proc. of Intl. Conf. on Very Large Data Bases, pages 39–51, 1993.

[Abi83] S. Abiteboul. Algebraic analogues to fundamental notions of query and dependency theory.

Technical Report, INRIA, 1983.

[Abi88] S. Abiteboul. Updates, a new frontier. In Proc. of Intl. Conf. on Database Theory, 1988.

[Abi89] S. Abiteboul. Boundedness is undecidable for datalog programs with a single recursive rule. Information Processing Letters, 32(6):281–289, 1989.

621
622
Bibliography
[Abr74] J.R. Abrial. Data semantics. In Data Base Management, pages 1–59. North Holland, Amsterdam, 1974.

[ABU79] A. V. Aho, C. Beeri, and J. D. Ullman. The theory of joins in relational databases. ACM
Trans. on Database Systems, 4(3):297–314, 1979.

[ABW88] K. R. Apt, H. Blair, and A. Walker. Towards a theory of declarative knowledge. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 89–148.

Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[AC78] A. K. Arora and C. R. Carlson. The information preserving properties of relational data base transformations. In Proc. of Intl. Conf. on Very Large Data Bases, pages 352–359, 1978.

[AC89] F. Afrati and S. S. Cosmadakis. Expressiveness of restricted recursive queries. In Proc.

ACM SIGACT Symp. on the Theory of Computing, pages 113–126, 1989.

[ACO85] A. Albano, L. Cardelli, and R. Orsini. Galileo: A strongly-typed, interactive conceptual language. ACM Trans. on Database Systems, 10:230–260, June 1985.

[ACY91] F. Afrati, S. Cosmadakis, and M. Yannakakis. On datalog vs. polynomial time. In Proc.

ACM Symp. on Principles of Database Systems, pages 13–25, 1991.

[ADM85] G. Ausiello, A. D’Atri, and M. Moscarini. Chordality properties on graphs and minimal conceptual connections in semantic data models. In Proc. ACM Symp. on Principles of Database Systems, pages 164–170, 1985.

[AF90] M. Ajtai and R. Fagin. Reachabiliy is harder for directed than for undirected finite graphs.

Journal of Symbolic Logic, 55(1):113–150, 1990.

[AG85] S. Abiteboul and G. Grahne. Update semantics for incomplete databases. In Proc. of Intl.

Conf. on Very Large Data Bases, pages 1–12, 1985.

[AG87] M. Ajtai and Y. Gurevich. Monotone versus positive. J. ACM, 34(4):1004–1015, 1987.

[AG89] M. Ajtai and Y. Gurevich. Datalog versus first order. In IEEE Conf. on Foundations of Computer Science, pages 142–148, 1989.

[AG91] S. Abiteboul and S. Grumbach. A rule-based language with functions and sets. ACM Trans.

on Database Systems, 16(1):1–30, 1991.

[AGM85] C. E. Alchourrón, P. Gärdenfors, and D. Makinson. On the logic of theory change: partial meet contraction and revision functions. Journal of Symbolic Logic, 50:510–530, 1985.

[AGSS86] A. K. Aylamazan, M. M. Gigula, A. P. Stolboushkin, and G. F. Schwartz. Reduction of the relation model with infinite domains to the finite domain case. In Proceedings of USSR
Academy of Science (Dokl. Akad. Nauk. SSSR), vol. 286,(2), pages 308–311, 1986. (In Russian.)

[AH87] S. Abiteboul and R. Hull. IFO: A formal semantic database model. ACM Trans. on Database Systems, 12(4):525–565, 1987.

[AH88] S. Abiteboul and R. Hull. Data functions, datalog and negation. In Proc. ACM SIGMOD
Symp. on the Management of Data, pages 143–153, 1988.

[AH91] A. Avron and Y. Hirshfeld. Safety in the presence of function and order symbols. In Proc.

IEEE Conf. on Logic in Computer Science, 1991.

[AK89] S. Abiteboul and P. C. Kanellakis. Object identity as a query language primitive. In Proc.

ACM SIGMOD Symp. on the Management of Data, pages 159–173, 1989. To appear in J. ACM.

[AKG91] S. Abiteboul, P. Kanellakis, and G. Grahne. On the representation and querying of sets of possible worlds. Theoretical Computer Science, 78:159–187, 1991.

[AKRW92] S. Abiteboul, P. Kanellakis, S. Ramaswamy, and E. Waller. Method schemas. Technical Report CS-92-33, Brown University, 1992. (An earlier version appeared in Proceedings 9th ACM PODS, 1990.)

Bibliography
623
[ALUW93] S. Abiteboul, G. Lausen, H. Uphoff, and E. Waller. Methods and rules. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 32–41, 1993.

[AP82] P. Atzeni and D. S. Parker. Assumptions in relational database theory. In Proc. ACM Symp.

on Principles of Database Systems, pages 1–9, 1982.

[AP87a] F. Afrati and C. H. Papadimitriou. The parallel complexity of simple chain queries. In Proc. ACM Symp. on Principles of Database Systems, pages 210–213, 1987.

[AP87b] K. R. Apt and J. -M. Pugin. Maintenance of stratified databases viewed as a belief revision system. In Proc. ACM Symp. on Principles of Database Systems, pages 136–145, 1987.

[AP92] M. Andries and J. Paredaens. A language for generic graph-transformations. In Proc. Intl.

Workshop WG 91, pages 63–74. Springer-Verlag, Berlin, 1992.

[APP+86] F. Afrati, C. H. Papadimitriou, G. Papageorgiou, A. Roussou, Y. Sagiv, and J. D. Ullman.

Convergence of sideways query evaluation. In Proc. ACM Symp. on Principles of Database Systems, pages 24–30, 1986.

[Apt91] K. R. Apt. Logic programming. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 493–574. Elsevier, Amsterdam, 1991.

[Arm74] W. W. Armstrong. Dependency structures of data base relationships. In Proc. IFIP
Congress, pages 580–583. North Holland, Amsterdam, 1974.

[ASSU81] A. V. Aho, Y. Sagiv, T. G. Szymanski, and J. D. Ullman. Inferring a tree from the lowest common ancestors with an application to the optimization of relational expressions. SIAM J. on Computing, 10:405–421, 1981. Extended abstract appears in Proc. 16th Ann. Allerton Conf. on Communication, Control and Computing, Monticello, Ill., Oct. 1978, pp. 54–63.

[ASU79a] A. V. Aho, Y. Sagiv, and J. D. Ullman. Efficient optimization of a class of relational expressions. ACM Trans. on Database Systems, 4(4):435–454, 1979.

[ASU79b] A. V. Aho, Y. Sagiv, and J. D. Ullman. Equivalence of relational expressions. SIAM J. on Computing, 8(2):218–246, 1979.

[ASV90] S. Abiteboul, E. Simon, and V. Vianu. Non-deterministic languages to express deterministic transformations. In Proc. ACM Symp. on Principles of Database Systems, pages 218–229, 1990.

[AT93] P. Atzeni and R. Torlone. A metamodel approach for the management of multiple models and the translation of schemas. Information Systems, 18:349–362, 1993.

[AU79] A. V. Aho and J. D. Ullman. Universality of data retrieval languages. In Proc. ACM Symp.

on Principles of Programming Languages, pages 110–117, 1979.

[AV87] S. Abiteboul and V. Vianu. A transaction language complete for database update and specification. In Proc. ACM Symp. on Principles of Database Systems, pages 260–268, 1987.

[AV88a] S. Abiteboul and V. Vianu. The connection of static constraints with boundedness and determinism of dynamic specifications. In 3rd Intl. Conf. on Data and Knowledge Bases, pages 324–334, Jerusalem, 1988.

[AV88b] S. Abiteboul and V. Vianu. Equivalence and optimization of relational transactions. J.

ACM, 35(1):130–145, 1988.

[AV88c] S. Abiteboul and V. Vianu. Procedural and declarative database update languages. In Proc.

ACM Symp. on Principles of Database Systems, pages 240–250, 1988.

[AV89] S. Abiteboul and V. Vianu. A transaction-based approach to relational database specification.

J. ACM, 36(4):758–789, October 1989.

[AV90] S. Abiteboul and V. Vianu. Procedural languages for database queries and updates. Journal of Computer and System Sciences, 41:181–229, 1990.

624
Bibliography
[AV91a] S. Abiteboul and V. Vianu. Datalog extensions for database queries and updates. Journal of Computer and System Sciences, 43:62–124, 1991.

[AV91b] S. Abiteboul and V. Vianu. Generic computation and its complexity. In Proc. ACM
SIGACT Symp. on the Theory of Computing, pages 209–219, 1991.

[AV91c] S. Abiteboul and V. Vianu. Non-determinism in logic-based languages. Annals of Math.

and Artif. Int. , 3:151–186, 1991.

[AV94] S. Abiteboul and V. Vianu. Computing with first-order logic. Journal of Computer and System Sciences, 1994. To appear.

[AvE82] K. Apt and M. van Emden. Contributions to the theory of logic programming. J. ACM, 29(3):841–862, 1982.

[AVV92] S. Abiteboul, M. Y. Vardi, and V. Vianu. Fixpoint logics, relational machines, and computational complexity. In Conf. on Structure in Complexity Theory, pages 156–168, 1992.

[AW88] K. R. Apt and H. A. Walker. Arithmetic classification of perfect models of stratified programs. Technical Report TR-88-09, University of Texas at Austin, 1988.

[B+86] D. G. Bobrow et al. CommonLoops: Merging lisp and object-oriented programming. In Proc. ACM Conf. on Object-Oriented Programming Systems, Languages, and Applications, pages 17–29, 1986.

[B+88] D. S. Batory et al. Genesis: An extensible database management system. IEEE Transactions on Software Engineering, SE-14(11):1711–1730, 1988.

[Ban78] F. Bancilhon. On the completeness of query languages for relational data bases. In 7th Symposium on the Mathematical Foundations of Computer Science, pages 112–123.

Springer-Verlag, Berlin, LNCS 64, 1978.

[Ban85] F. Bancilhon. A note on the performance of rule based systems. Technical Report DB-022-85, MCC, 1985.

[Ban86] F. Bancilhon. Naive evaluation of recursively defined relations. In M. L. Brodie and J. L.

Mylopoulos, editors, On Knowledge Base Management Systems—Integrating Database and AI Systems, pages 165–178. Springer-Verlag, Berlin, 1986.

[Bar63] H. Barendregt. Functional programming and lambda calculus. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, vol. B, pages 321–363. Elsevier, Amsterdam, 1990.

[Bar84] H. Barendregt. The Lambda Calculus: Its Syntax and Semantics. North Holland, Amsterdam, 1984.

[BB79] C. Beeri and P. A. Bernstein. Computational problems related to the design of normal form relational schemas. ACM Trans. on Database Systems, 4(1):30–59, March 1979.

[BB91] J. Berstel and L. Boasson. Context-free languages. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 102–163. Elsevier, Amsterdam, 1991.

[BB92] D. Beneventano and S. Bergamaschi. Subsumption for complex object data models. In Proc. of Intl. Conf. on Database Theory, pages 357–375, 1992.

[BBC80] P. A. Bernstein, B. T. Blaustein, and E. M. Clarke. Fast maintenance of semantic integrity assertions using redundant aggregate data. In Proc. of Intl. Conf. on Very Large Data Bases, pages 126–136, 1980.

[BBG78] C. Beeri, P. A. Bernstein, and N. Goodman. A sophisticate’s introduction to database normalization theory. In Proc. of Intl. Conf. on Very Large Data Bases, pages 113–124, 1978.

[BBMR89] A. Borgida, R. J. Brachman, D. L. McGuinness, and L. A. Resnick. CLASSIC: A structural data model for objects. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 58–67, 1989.

Bibliography
625
[BC79] O. P. Buneman and G. K. Clemons. Efficiently monitoring relational databases. ACM Trans.

on Database Systems, 4(3):368–382, September 1979.

[BC81] P. A. Bernstein and D. W. Chiu. Using semi-joins to solve relational queries. J. ACM, 28(1):25–40, 1981.

[BCD89] F. Bancilhon, S. Cluet, and C. Delobel. Query languages for object-oriented database systems: the O2 proposal. In Proc. Second Intl. Workshop on Data Base Programming Languages, 1989.

[BCW93] M. Baudinet, J. Chomicki, and P. Wolper. Temporal deductive databases. In A. U. Tansel et al., editors, Temporal Databases—Theory, Design, and Implementation, pages 294–320.

Benjamin/Cummings Publishing Co., Menlo Park, CA, 1993.

[BDB79] J. Biskup, U. Dayal, and P. A. Bernstein. Synthesizing independent database schemas. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 143–152, 1979.

[BDFS84] C. Beeri, M. Dowd, R. Fagin, and R. Statman. On the structure of Armstrong relations for functional dependencies. J. ACM, 31(1):30–46, 1984.

[BDK92] F. Bancilhon, C. Delobel, and P. Kanellakis, editors. Building an Object-Oriented Database System: The Story of O 2. Morgan Kaufmann, Inc., Los Altos, CA, 1992.

[BDM88] F. Bry, H. Decker, and R. Manthey. A uniform approach to constraint satisfaction and constraint satisfiability in deductive databases. In Proc. of Intl. Conf. on Extending Data Base Technology, pages 488–505, 1988.

[BDW88] P. Buneman, S. Davidson, and A. Watters. A semantics for complex objects and approximate queries. In Proc. ACM Symp. on Principles of Database Systems, pages 302–314, 1988.

[BDW91] P. Buneman, S. Davidson, and A. Watters. A semantics for complex objects and approximate answers. Journal of Computer and System Sciences, 43:170–218, 1991.

[Bee80] C. Beeri. On the membership problem for functional and multivalued dependencies in relational databases. ACM Trans. on Database Systems, 5:241–259, 1980.

[Bee90] C. Beeri. A formal approach to object-oriented databases. Data and Knowledge Engineering, 5(4):353–382, 1990.

[Ber76a] C. Berge. Graphs and Hypergraphs. North Holland, Amsterdam, 1976.

[Ber76b] P. A. Bernstein. Synthesizing third normal form relations from functional dependencies.

ACM Trans. on Database Systems, 1(4):277–298, 1976.

[BF87] N. Bidoit and C. Froidevaux. Minimalism subsumes default logic and circumscription. In Proc. IEEE Conf. on Logic in Computer Science, pages 89–97, 1987.

[BF88] N. Bidoit and C. Froidevaux. General logic databases and programs: Default logic semantics and stratification. Technical Report, LRI, Université de Paris-Sud, Orsay, 1988. To appear in J.

Information and Computation.

[BFH77] C. Beeri, R. Fagin, and J. H. Howard. A complete axiomatization for functional and multivalued dependencies. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 47–61, 1977.

[BFM+81] C. Beeri, R. Fagin, D. Maier, A. O. Mendelzon, J. D. Ullman, and M. Yannakakis.

Properties of acyclic database schemes. In Proc. ACM SIGACT Symp. on the Theory of Computing, pages 355–362, 1981.

[BFMY83] C. Beeri, R. Fagin, D. Maier, and M. Yannakakis. On the desirability of acyclic database schemes. J. ACM, 30(3):479–513, 1983.

626
Bibliography
[BFN82] P. Buneman, R. Frankel, and R. Nikhil. An implementation technique for database query languages. ACM Trans. on Database Systems, 7:164–186, 1982.

[BG81] P. A. Bernstein and N. Goodman. The power of natural semi-joins. SIAM J. on Computing, 10(4):751–771, 1981.

[BGK85] A. Blass, Y. Gurevich, and D. Kozen. A zero-one law for logic with a fixed point operator.

Information and Control, 67:70–90, 1985.

[BGL85] R. J. Brachman, V. P. Gilbert, and H. J. Levesque. An essential hybrid reasoning system: Knowledge and symbol level accounts of KRYPTON. In Intl. Joint Conf. on Artificial Intelligence, pages 532–539, 1985.

[BGW+81] P. A. Bernstein, N. Goodman, E. Wong, et al. Query processing in a system for distributed databases (SDD-1). ACM Trans. on Database Systems, 6:602–625, 1981.

[BHG87] P. A. Bernstein, V. Hadzilacos, and N. Goodman. Concurrency Control and Recovery in Database Systems. Addison-Wesley, Reading, MA, 1987.

[Bid91a] N. Bidoit. Bases de Données Déductives (Présentation de Datalog). Armand Colin, Paris, 1991.

[Bid91b] N. Bidoit. Negation in rule-based database languages: A survey. Theoretical Computer Science, 78:3–83, 1991.

[Bis80] J. Biskup. Inferences of multivalued dependencies in fixed and undetermined universes.

Theoretical Computer Science, 10:93–105, 1980.

[Bis81] J. Biskup. A formal approach to null values in database relations. In H. Gallaire, J. Minker, and J.M. Nicolas, editors, Advances in Data Base Theory, vol. 1, pages 299–341. Plenum Press, New York, 1981.

[Bis83] J. Biskup. A foundation of Codd’s relational maybe-operations. ACM Trans. on Database Systems, 8(4):608–636, 1983.

[BJO91] P. Buneman, A. Jung, and A. Ohori. Using powerdomains to generalize relational databases. Theoretical Computer Science, 91:23–55, 1991.

[BK86] C. Beeri and M. Kifer. An integrated approach to logical design of relational database schemes. ACM Trans. on Database Systems, 11:134–158, 1986.

[BKBR87] C. Beeri, P. C. Kanellakis, F. Bancilhon, and R. Ramakrishnan. Bounds on the propagation of selection into logic programs. In Proc. ACM Symp. on Principles of Database Systems, pages 214–226, 1987.

[BL90] N. Bidoit and P. Legay. Well! an evaluation procedure for all logic programs. In Proc. of Intl. Conf. on Database Theory, pages 335–348. Springer-Verlag, Berlin, LNCS 470, 1990.

[BLN86] C. Batini, M. Lenzerini, and S. B. Navathe. A comparative analysis of methodologies for database schema integration. ACM Computing Surveys, 18:323–364, 1986.

[BLT86] J. A. Blakeley, P.-A. Larson, and F. W. Tompa. Efficiently updating materialized views. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 61–71, 1986.

[BM91] C. Beeri and T. Milo. A model for active object oriented databases. In Proc. of Intl. Conf.

on Very Large Data Bases, pages 337–349, 1991.

[BMG93] J. A. Blakeley, W. J. McKenna, and G. Graefe. Experiences building the open OODB
query optimizer. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 287–296, 1993.

[BMSU81] C. Beeri, A. O. Mendelzon, Y. Sagiv, and J. D. Ullman. Equivalence of relational database schemes. SIAM J. on Computing, 10(2):352–370, 1981.

Bibliography
627
[BMSU86] F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. Magic sets and other strange ways to implement logic programs. In Proc. ACM Symp. on Principles of Database Systems, pages 1–15, 1986.

[BNR+87] C. Beeri, S. Naqvi, R. Ramakrishnan, O. Shmueli, and S. Tsur. Sets and negation in a logic database language (LDL1). In Proc. ACM Symp. on Principles of Database Systems, pages 21–37, 1987.

[Bor85] A. Borgida. Features of languages for the development of information systems at the conceptual level. IEEE Software, 2:63–72, 1985.

[BP83] P. De Bra and J. Paredaens. Conditional dependencies for horizontal decompositions. In Proc. Intl. Conf. on Algorithms, Languages and Programming, pages 67–82. Springer-Verlag, Berlin, LNCS 154, 1983.

[BPR87] I. Balbin, B. S. Port, and K. Ramamohanarao. Magic set computation for stratified databases. Technical Report TR 87/3, Dept. of Computer Science, University of Melbourne, 1987.

[BR80] C. Beeri and J. Rissanin. Faithful representation of relational database schemes. Technical Report RJ2722, IBM Research Laboratory, San Jose, CA, 1980.

[BR87a] C. Beeri and R. Ramakrishnan. On the power of magic. In Proc. ACM Symp. on Principles of Database Systems, pages 269–283, 1987.

[BR87b] I. Balnbin and K. Ramamohanarao. A generalization of the differential approach to recursive query evaluation. In Journal of Logic Programming, 4(3), 1987.

[BR88a] F. Bancilhon and R. Ramakrishnan. An amateur’s introduction to recursive query processing strategies. In M. Stonebraker, editor, Readings in Database Systems, pages 507–
555. Morgan Kaufmann, Inc., Los Altos, CA, 1988. An earlier version of this work appears in Proc. ACM SIGMOD Conf. on Management of Data, pp. 16–52, 1986.

[BR88b] F. Bancilhon and R. Ramakrishnan. Performance evaluation of data intensive logic programs. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 439–517. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[BR91] C. Beeri and R. Ramakrishnan. On the power of magic. J. Logic Programming, 10(3&4):255–300, 1991.

[BRS82] F. Bancilhon, P. Richard, and M. Scholl. On line processing of compacted relations. In Proc. of Intl. Conf. on Very Large Data Bases, pages 263–269, 1982.

[BRSS92] C. Beeri, R. Ramakrishnan, D. Srivastava, and S. Sudarshan. The valid model semantics for logic programs. In Proc. ACM Symp. on Principles of Database Systems, pages 91–104, 1992.

[Bry89] F. Bry. Query evaluation in recursive databases: Bottom-up and top-down reconciled. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), pages 20–39, 1989.

[BS81] F. Bancilhon and N. Spyratos. Update semantics of relational views. ACM Trans. on Database Systems, 6(4):557–575, 1981.

[BS85] R. J. Brachman and J. G. Schmolze. An overview of the KL-ONE knowledge representation system. Cognitive Science, 9:171–216, 1985.

[BS93] S. Bergamaschi and C. Sartori. On taxonomic reasoning in conceptual design. ACM Trans.

on Database Systems, 17:385–422, 1993.

[BST75] P. A. Bernstein, J. R. Swenson, and D. C. Tzichritzis. A unified approach to functional dependencies and relations. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 237–245, 1975.

628
Bibliography
[BTBN92] V. Breazu-Tannen, P. Buneman, and S. Naqvi. Structural recursion as a query language.

In Proc. of Intl. Workshop on Database Programming Languages, pages 9–19. Morgan Kaufmann, Inc., Los Altos, CA, 1992.

[BTBW92] V. Breazu-Tannen, P. Buneman, and L. Wong. Naturally embedded query languages. In Proc. of Intl. Conf. on Database Theory, pages 140–154. Springer-Verlag, Berlin, LNCS, 1992.

[BV80a] C. Beeri and M. Y. Vardi. On the complexity of testing implications of data dependencies.

Technical Report, Department of Computer Science, Hebrew University of Jerusalem, 1980.

[BV80b] C. Beeri and M. Y. Vardi. A proof procedure for data dependencies (preliminary report).

Technical Report, Department of Computer Science, Hebrew University of Jerusalem, August 1980.

[BV81a] C. Beeri and M. Y. Vardi. The implication problem for data dependencies. In Proc. Intl.

Conf. on Algorithms, Languages and Programming, pages 73–85, 1981. Springer-Verlag, Berlin, LNCS 115.

[BV81b] C. Beeri and M. Y. Vardi. On the properties of join dependencies. In H. Gallaire, J. Minker, and J. M. Nicolas, editors, Advances in Data Base Theory, vol. 1, pages 25–72. Plenum Press, New York, 1981.

[BV84a] C. Beeri and M. Y. Vardi. Formal systems for tuple and equality generating dependencies.

SIAM J. on Computing, 13(1):76–98, 1984.

[BV84b] C. Beeri and M. Y. Vardi. On acyclic database decompositions. Inf. and Control, 61(2):75–84, 1984.

[BV84c] C. Beeri and M. Y. Vardi. A proof procedure for data dependencies. J. ACM, 31(4):718–
741, 1984.

[BV85] C. Beeri and M. Y. Vardi. Formal systems for join dependencies. Theoretical Computer Science, 38:99–116, 1985.

[C+76] D. D. Chamberlin et al. Sequel 2: a unified approach to data definition, manipulation and control. IBM J. Research and Development, 20(6):560–575, 1976.

[Cam92] M. Campbell. Microsoft Access – Inside and Out. Osborne McGraw-Hill, New York, 1992.

[Car88] L. Cardelli. A semantics of multiple inheritance. Information and Computation, 76:138–
164, 1988.

[Cat94] R. G. G. Cattell, editor. The Object Database Standard: ODMB-93. Morgan Kaufmann, Inc., Los Altos, CA, 1994.

[CCCR+90] F. Cacace, S. Ceri, S. Crespi-Reghizzi, L. Tanca, and R. Zicari. Integrating object-oriented data modeling with a rule-based programming paradigm. In Proc. ACM SIGMOD
Symp. on the Management of Data, pages 225–236, 1990.

[CCF82] I. M. V. Castillo, M. A. Casanova, and A. L. Furtado. A temporal framework for database specification. In Proc. of Intl. Conf. on Very Large Data Bases, pages 280–291, 1982.

[CF84] M. A. Casanova and A. L. Furtado. On the description of database transition constraints using temporal logic. In H. Gallaire, J. Minker, and J. -M. Nicolas, editors, Advances in Data Base Theory, vol. 2. Plenum Press, New York, 1984.

[CFI89] J. Cai, M. Fürer, and N. Immerman. An optimal lower bound on the number of variables for graph identification. In IEEE Conf. on Foundations of Computer Science, pages 612–617, 1989.

[CFP84] M. A. Casanova, R. Fagin, and C. H. Papadimitriou. Inclusion dependencies and
Bibliography
629
their interaction with functional dependencies. Journal of Computer and System Sciences, 28(1):29–59, 1984.

[CGKV88] S. S. Cosmadakis, H. Gaifman, P. C. Kanellakis, and M. Y. Vardi. Decidable optimization problems for database logic programs. In Proc. ACM SIGACT Symp. on the Theory of Computing, 1988.

[CGP93] L. Corciulo, F. Giannotti, and D. Pedreschi. Datalog with non-deterministic choice computes NDB-PTIME. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), 1993.

[CGT90] S. Ceri, G. Gottlob, and L. Tanca. Logic Programming and Databases. Springer-Verlag, Berlin, 1990.

[CH80a] A. K. Chandra and D. Harel. Structure and complexity of relational queries. In IEEE Conf.

on Foundations of Computer Science, pages 333–347, 1980.

[CH80b] A. K. Chandra and D. Harel. Computable queries for relational data bases. Journal of Computer and System Sciences, 21(2):156–178, 1980.

[CH82] A. K. Chandra and D. Harel. Structure and complexity of relational queries. Journal of Computer and System Sciences, 25(1):99–128, 1982.

[CH85] A. K. Chandra and D. Harel. Horn clause queries and generalizations. J. Logic Programming, 2(1):1–15, 1985.

[Cha81a] A. K. Chandra. Programming primitives for database languages. In Proc. ACM Symp. on Principles of Programming Languages, pages 50–62, 1981.

[Cha81b] C. Chang. On the evaluation of queries containing derived relations in relational databases.

In H. Gallaire, J. Minker, and J.-M. Nicolas, editors, Advances in Database Theory, vol. 1, pages 235–260. Plenum Press, New York, 1981.

[Cha88] A. K. Chandra. Theory of database queries. In Proc. ACM Symp. on Principles of Database Systems, pages 1–9, 1988.

[Cha94] T. -P. Chang. On Incremental Update Propagation Between Object-based Databases.

Ph.D. thesis, University of Southern California, Los Angeles, 1994.

[Che76] P. P. Chen. The entity-relationship model – Toward a unified view of data. ACM Trans. on Database Systems, 1:9–36, 1976.

[CHM94] I-M. A. Chen, R. Hull, and D. McLeod. Local ambiguity and derived data update. In Fourth Intl. Workshop on Research Issues in Data Engineering: Active Database Systems, pages 77–86, 1994.

[Cho92a] J. Chomicki. History-less checking of dynamic integrity constraints. In Proc. IEEE Intl.

Conf. on Data Engineering, 1992.

[Cho92b] J. Chomicki. Real-time integrity constraints. In Proc. ACM Symp. on Principles of Database Systems, 1992.

[Cho94] J. Chomicki. Temporal query languages: A survey. In Proc. 1st Intl. Conf. on Temporal Logic, 1994.

[Chu41] A. Church. The Calculi of Lambda-Conversion. Princeton University Press, Princeton, NJ, 1941.

[CK73] C. C. Chang and H. J. Keisler. Model Theory. North Holland, Amsterdam, 1973.

[CK85] S. S. Cosmadakis and P. C. Kanellakis. Equational theories and database constraints. In Proc. ACM SIGACT Symp. on the Theory of Computing, pages 73–284, 1985.

[CK86] S. S. Cosmadakis and P. C. Kanellakis. Functional and inclusion dependencies: A graph theoretic approach. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing
630
Bibliography
Research, vol. 3: The Theory of Databases, pages 164–185. JAI Press, Inc., Greenwich, CT, 1986.

[CKRP73] A. Colmerauer, H. Kanoui, P. Roussel, and R. Pasero. Un système de communication homme-machine en français. Technical Report, Groupe de Recherche en Intelligence Artificielle, Université Aix-Marseille, 1973.

[CKS86] S. S. Cosmadakis, P. C. Kanellakis, and S. Spyratos. Partition semantics for relations.

Journal of Computer and System Sciences, 32(2):203–233, 1986.

[CKV90] S. S. Cosmadakis, P. C. Kanellakis, and M. Y. Vardi. Polynomial-time implications problems for unary inclusion dependencies. J. ACM, 37:15–46, 1990.

[CL73] C. L. Chang and R. C. T. Lee. Symbolic Logic and Mechanical Theorem Proving. Academic Press, New York, 1973.

[CL94] D. Calvanese and M. Lenzerini. Making object-oriented schemas more expressive. In Proc.

ACM Symp. on Principles of Database Systems, 1994.

[Cla78] K. L. Clark. Negation as failure logic and databases. In H. Gallaire and J. Minker, editors, Logic and Databases, pages 293–322. Plenum Press, New York, 1978.

[CLM81] A. K. Chandra, H. R. Lewis, and J. A. Makowsky. Embedded implicational dependencies and their inference problem. In Proc. ACM SIGACT Symp. on the Theory of Computing, pages 342–354, 1981.

[CM77] A. K. Chandra and P. M. Merlin. Optimal implementation on conjunctive queries in relational data bases. In Proc. ACM SIGACT Symp. on the Theory of Computing, pages 77–90, 1977.

[CM90] M. Consens and A. Mendelzon. GraphLog: A visual formalism for real life recursion. In Proc. ACM Symp. on Principles of Database Systems, pages 404–416, 1990.

[CM93a] M. Consens and A. Mendelzon. The hy+ hygraph visualization system. In Proc. ACM
SIGMOD Symp. on the Management of Data, 1993.

[CM93b] M. Consens and A. Mendelzon. Low complexity aggregation in GraphLog and Datalog.

Theoretical Computer Science, 116(1):95–116, 1993. A preliminary version was published in the Proceedings of the Third International Conference on Database Theory, Springer-Verlag, Berlin, LNCS 470, 1990.

[Cod70] E. F. Codd. A relational model of data for large shared data banks. Comm. of the ACM, 13(6):377–387, 1970.

[Cod71] E. F. Codd. Normalized database structure: A brief tutorial. In ACM SIGFIDET Workshop on Data Description, Access and Control, November 1971.

[Cod72a] E. F. Codd. Further normalization of the data base relational model. In R. Rustin, editor, Courant Computer Science Symposium 6: Data Base Systems, pages 33–64. Prentice-Hall, Englewood Cliffs, NJ, 1972.

[Cod72b] E. F. Codd. Relational completeness of database sublanguages. In R. Rustin, editor, Courant Computer Science Symposium 6: Data Base Systems, pages 65–98. Prentice-Hall, Englewood Cliffs, NJ, 1972.

[Cod74] E. F. Codd. Recent investigations in relational data base systems. In Information Processing 74, pages 1017–1021. North Holland, Amsterdam, 1974.

[Cod75] T. Codd. Understanding relations (installment #7). In FDT Bull. of ACM Sigmod 7, pages 23–28, 1975.

[Cod79] E. F. Codd. Extending the data base relational model to capture more meaning. ACM Trans.

on Database Systems, 4(4):397–434, 1979.

Bibliography
631
[Cod82] E. F. Codd. Relational databases: A practical foundation for productivity. Comm. of the ACM, 25(2):102–117, 1982.

[Coh86] D. Cohen. Programming by specification and annotation. In Proc. of AAAI, 1986.

[Coh89] D. Cohen. Compiling complex database transition triggers. In Proc. ACM SIGMOD Symp.

on the Management of Data, pages 225–234, 1989.

[Coh90] J. Cohen. Constraint logic programming languages. Comm. of the ACM, 33(7):69–90, 1990.

[Com88] K. Compton. 0-1 laws in logic and combinatorics. In 1987 NATO Adv. Study Inst. on Algorithms and Order, pages 353–383, 1988.

[Coo74] S. A. Cook. An observation on a time-storage trade-off. Journal of Computer and System Sciences, 9:308–316, 1974.

[Cos83] S. S. Cosmadakis. The complexity of evaluating relational queries. Inf. and Control, 58:101–112, 1983.

[Cos87] S. S. Cosmadakis. Database theory and cylindric lattices. In IEEE Conf. on Foundations of Computer Science, pages 411–420, 1987.

[Cou90] B. Courcelle. Recursive applicative program schemes. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, vol. B, pages 459–492. Elsevier, Amsterdam, 1990.

[CP84] S. S. Cosmadakis and C. H. Papadimitriou. Updates of relational views. J. ACM, 31(4):742–
760, 1984.

[CRG+88] S. Ceri, S. Crespi Reghizzi, G. Gottlob, F. Lamperti, L. Lavazza, L. Tanca, and R. Zicari.

The algres project. In Proc. of Intl. Conf. on Extending Data Base Technology. Springer-Verlag, Berlin, 1988.

[CT48] L. H. Chin and A. Tarski. Remarks on projective algebras. Bulletin AMS, 54:80–81, 1948.

[CT87] S. Ceri and L. Tanca. Optimization of systems of algebraic equations for evaluating datalog queries. In Proc. of Intl. Conf. on Very Large Data Bases, 1987.

[CTF88] M. A. Casanova, L. Tucherman, and A. L. Furtado. Enforcing inclusion dependencies and referential integrity. In Proc. of Intl. Conf. on Very Large Data Bases, pages 38–49, 1988.

[CV81] T. Connors and V. Vianu. Tableaux which define expression mappings. Technical Report, Computer Science Department, University of Southern California, 1981. Presented at XP2
Conf. on Theory of Relational Databases, Pennsylvania State University, June 1981.

[CV83] M. A. Casanova and V. M. P. Vidal. Towards a sound view integration methodology. In Proc. ACM Symp. on Principles of Database Systems, pages 36–47, 1983.

[CV85] A. K. Chandra and M. Y. Vardi. The implication problem for functional and inclusion dependencies is undecidable. SIAM J. on Computing, 14(3):671–677, 1985.

[CV92] S. Chaudhuri and M. Y. Vardi. On the equivalence of datalog programs. In Proc. ACM
Symp. on Principles of Database Systems, pages 55–66, 1992.

[CV93] S. Chaudhuri and M. Y. Vardi. Optimization of real conjunctive queries. In Proc. ACM
Symp. on Principles of Database Systems, pages 59–70, 1993.

[CV94] S. Chaudhuri and M. Y. Vardi. On the complexity of equivalence between recursive and nonrecursive datalog programs. In Proc. ACM Symp. on Principles of Database Systems, pages 107–116, 1994.

[CW85] L. Cardelli and P. Wegner. On understanding types, data abstraction and polymorphism.

ACM Computing Surveys, 17:471–522, December 1985.

[CW89a] W. Chen and D. S. Warren. C-Logic of complex objects. In Proc. ACM Symp. on Principles of Database Systems, pages 369–378, 1989.

632
Bibliography
[CW89b] S. R. Cohen and O. Wolfson. Why a single parallelization strategy is not enough in knowledge bases. In Proc. ACM Symp. on Principles of Database Systems, pages 200–216, 1989.

[CW90] S. Ceri and J. Widom. Deriving production rules for constraint maintenance. In Proc. of Intl. Conf. on Very Large Data Bases, pages 566–577, 1990.

[CW91] S. Ceri and J. Widom. Deriving production rules for incremental view maintenance. In Proc. of Intl. Conf. on Very Large Data Bases, pages 577–589, 1991.

[CW92] W. Chen and D. S. Warren. A goal oriented approach to computing well founded semantics.

In Proc. of the Joint Intl. Conf. and Symp. on Logic Programming, pages 589–606, 1992.

[CW93] S. Ceri and J. Widom. Managing semantic heterogeneity with production rules and persistent queues. In Proc. of Intl. Conf. on Very Large Data Bases, pages 108–119, 1993.

[DA83] C. Delobel and M. Adiba. Bases de Données et Systèmes Relationnels. Dunod Informatique, Paris, 1983.

[Dal87] E. Dalhaus. Skolem normal forms concerning the least fixpoint. In E. Börger, editor, Computation Theory and Logic, vol. 270, pages 101–106. Springer-Verlag, Berlin, LNCS, 1987.

[Dat81] C. J. Date. Referential integrity. In Proc. of Intl. Conf. on Very Large Data Bases, pages 2–12, 1981.

[Dat86] C. J. Date. An Introduction to Database Systems. Addison-Wesley, Reading, MA, 1986.

[Daw93] A. Dawar. Feasible Computation through Model Theory. Ph.D. thesis, University of Pennsylvania, 1993.

[Day89] U. Dayal. Queries and views in an object-oriented data model. In Proc. of Intl. Workshop on Database Programming Languages, pages 80–102, 1989.

[DB82] U. Dayal and P. A. Bernstein. On the correct translation of update operations on relational views. ACM Trans. on Database Systems, 8(3):381–416, 1982.

[DC72] C. Delobel and R. C. Casey. Decomposition of a database and the theory of boolean switching functions. IBM J. Research and Development, 17(5):370–386, 1972.

[DD89] L. M. L. Delcambre and K. C. Davis. Automatic validation of object-oriented database structures. In Proc. IEEE Intl. Conf. on Data Engineering, pages 2–9, 1989.

[Dec86] H. Decker. Extending and restricting deductive databases. Technical Report KB-21, ECRC, Munich, 1986.

[Del78] C. Delobel. Normalization and hierarchical dependencies in the relational data model. ACM
Trans. on Database Systems, 3(3):201–222, 1978.

[Dem82] R. Demolombe. Syntactical characterization of a subset of domain independent formulas.

Technical Report, ONERA–CERT, Toulouse, 1982.

[DF92] C. J. Date and R. Fagin. Simple conditions for guaranteeing higher normal forms in relational databases. ACM Trans. on Database Systems, 17:465–476, 1992.

[DG79] B. S. Dreben and W. D. Goldfarb. The Decision Problem: Solvable Classes of Qualificational Formulas. Addison-Wesley, Reading, MA, 1979.

[DH84] U. Dayal and H. Y. Hwang. View definition and generalization for database integration in a multidatabase system. IEEE Trans. on Software Engineering, SE-10(6):628–644, 1984.

[DHL91] U. Dayal, M. Hsu, and R. Ladin. A transaction model for long-running activities. In Proc.

of Intl. Conf. on Very Large Data Bases, pages 113–122, 1991.

[DiP69] R. A. DiPaola. The recursive unsolvability of the decision problem for a class of definite formulas. J. ACM, 16(2):324–327, 1969.

Bibliography
633
[DM86a] E. Dahlhaus and J. A. Makowsky. Computable directory queries. In 11th CAAP 86, pages 254–265, Springer-Verlag, Berlin, LNCS 214, 1986.

[DM86b] A. D’Atri and M. Moscarini. Recognition algorithms and design methodologies for acyclic database. In P. C. Kanellakis and F. Preparata, editors, Schemes Advances in Computing Research, vol. 3, pages 164–185. JAI Press, Inc., Greenwich, CT, 1986.

[DM92] E. Dalhaus and J. A. Makowsky. Query languages for hierarchic databases. Information and Computation, 101(1):1–32, November 1992.

[DMP93] M. A. Derr, S. Morishita, and G. Phipps. Design and implementation of the Glue-Nail database system. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 147–156, 1993.

[dMS88] C. de Maindreville and E. Simon. Modelling non-deterministic queries and updates in deductive databases. In Proc. of Intl. Conf. on Very Large Data Bases, 1988.

[Don92] G. Dong. Datalog expressiveness of chain queries: Grammar tools and characterizations.

In Proc. ACM Symp. on Principles of Database Systems, pages 81–90, 1992.

[DP84] P. DeBra and J. Paredaens. Horizontal decompositions for handling exceptions to functional dependencies. In H. Gallaire, J. Minker, and J. -M. Nicolas, editors, Advances in Database Theory, vol. 2, pages 123–144. Plenum Press, New York, 1984.

[dR87] M. de Rougemont. Second-order and inductive definability of finite structures. Zeitschr.

Math. Logik und Grundlagen d. Math. , 33:47–63, 1987.

[DS91] G. Dong and J. Su. Object behaviors and scripts. In Proc. of Intl. Workshop on Database Programming Languages, pages 27–30, 1991.

[DS92] G. Dong and J. Su. Incremental and decremental evaluation of transitive closure by first-order queries. Technical Report TRCS 92-18, University of California, Santa Barbara, 1992. To appear in Information and Computation.

[DS93] G. Dong and J. Su. First-order incremental evaluation of datalog queries (extended abstract).

In Proc. of Intl. Workshop on Database Programming Languages, 1993.

[DST93] G. Dong, J. Su, and R. Topor. Nonrecursive incremental evaluation of datalog queries.

Technical Report, Department of Computer Science, University of Melbourne, Australia, 1993.

To appear in Annals of Mathematics and Artificial Intelligence.

[DT92] G. Dong and R. Topor. Incremental evaluation of datalog queries. In Proc. of Intl. Conf. on Database Theory, pages 282–296, 1992.

[DV91] K. Denninghoff and V. Vianu. The power of methods with parallel semantics. In Proc. of Intl. Conf. on Very Large Data Bases, pages 221–232, 1991.

[DV93] K. Denninghoff and V. Vianu. Database method schemas and object creation. In Proc. ACM
Symp. on Principles of Database Systems, pages 265–275, 1993.

[DW85] S. W. Dietrich and D. S. Warren. Dynamic programming strategies for the evaluation of recursive queries. Technical Report TR 85-31, Computer Science Department, SUNY at Stony Brook, New York, 1985.

[DW87] S. W. Dietrich and D. S. Warren. Extension tables: Memo relations in logic programming.

In Proc. of the Symposium on Logic Programming, 1987.

[DW94] U. Dayal and J. Widom. Active Database Systems. Morgan Kaufmann Publishers, Inc., Los Altos, CA. In preparation, to appear in 1994.

[EFT84] H. D. Ebbinghaus, J. Flum, and W. Thomas. Mathematical Logic. Springer-Verlag, Berlin, 1984.

[EGM94] T. Eiter, G. Gottlob, and H. Mannila. Adding disjunction to Datalog. In Proce. ACM
Symp. on Principles of Database Systems, pages 267–278, 1994.

634
Bibliography
[EHJ93] M. Escobar-Molano, R. Hull, and D. Jacobs. Safety and translation of calculus queries with scalar functions. In Proc. ACM Symp. on Principles of Database Systems, pages 253–264, 1993.

[Ehr61] A. Ehrenfeucht. An application of games to the completeness problem for formalized theories. Fund. Math. , 49:129–141, 1961.

[Eme91] E. A. Emerson. Temporal and modal logic. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 997–1072. Elsevier, Amsterdam, 1991.

[EN89] R. Elmasri and S. B. Navathe. Fundamentals of Database Systems. Benjamin/Cummings Publishing Co., Menlo Park, CA, 1989.

[End72] H. B. Enderton. A Mathematical Introduction to Logic. Academic Press, New York, 1972.

[Esw76] K. P. Eswaran. Aspects of a trigger subsystem in an integrated data base system. In Proceedings of the 2nd International Conference in Software Engineering, San Francisco, CA, pages 243–250, 1976.

[ESW78] R. Epstein, M. Stonebraker, and E. Wong. Distributed query processing in a relational database system. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 169–180, 1978.

[Fag72] R. Fagin. Probabilities on finite models. Notices of the American Mathematical Society, October: A714, 1972.

[Fag75] R. Fagin, Monadic generalized spectra. Zeitschrift für Mathematische Logik und Grundlagen der Mathematik, 21:89–96, 1975.

[Fag76] R. Fagin. Probabilities on finite models. Journal of Symbolic Logic, 41(1):50–58, 1976.

[Fag77a] R. Fagin. The decomposition versus synthetic approach to relational database design. In Proc. of Intl. Conf. on Very Large Data Bases, pages 441–446, 1977.

[Fag77b] R. Fagin. Multivalued dependencies and a new normal form for relational databases. ACM
Trans. on Database Systems, 2:262–278, 1977.

[Fag79] R. Fagin. Normal forms and relational database operators. In Proc. ACM SIGMOD Symp.

on the Management of Data, pages 153–160, 1979.

[Fag81] R. Fagin. A normal form for relational databases that is based on domains and keys. ACM
Trans. on Database Systems, 6(3):387–415, 1981.

[Fag82a] R. Fagin. Armstrong databases. In Proc. IBM Symp. on Mathematical Foundations of Computer Science, 1982.

[Fag82b] R. Fagin. Horn clauses and database dependencies. J. ACM, 29(4):952–985, 1982.

[Fag83] R. Fagin. Degrees of acyclicity for hypergraphs and relational database schemes. J. ACM, 30(3):514–550, 1983.

[Fag93] R. Fagin. Finite-model theory—A personal perspective. Theoretical Computer Science, 116:3–31, 1993.

[FC85] A. L. Furtado and M. A. Casanova. Updating relational views. In W. Kim, D. S. Reiner, and D. S. Batory, editors, Query Processing in Database Systems. Springer-Verlag, Berlin, 1985.

[FHMV95] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi. Reasoning about Knowledge. MIT
Press, Cambridge, MA, 1995.

[Fit85] M. Fitting. A Kripke-Kleene semantics of logic programs. Logic Programming, 4:295–312, 1985.

[FJT83] P. C. Fischer, J. H. Jou, and D. M. Tsou. Succinctness in dependency systems. Theoretical Computer Science, 24:323–329, 1983.

[FKL97] J. Flum, M. Kubierschky, and B. Ludaescher. Total and partial well-founded datalog coincide. To appear, Proc. of Intl. Conf. on Database Theory, 1997.

Bibliography
635
[FKUV86] R. Fagin, G. Kuper, J. D. Ullman, and M. Y. Vardi. Updating logical databases. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing Research, vol. 3, pages 1–18.

JAI Press, Inc., Greenwich, CT, 1986.

[FM92] J. A. Fernandez and J. Minker. Semantics of disjunctive deductive databases. In Proc. of Intl. Conf. on Database Theory, pages 21–50. Springer-Verlag, Berlin, LNCS 646, 1992.

[FMU82] R. Fagin, A. O. Mendelzon, and J. D. Ullman. A simplified universal relational assumption and its properties. ACM Trans. on Database Systems, 7(3):343–360, 1982.

[FNS91] C. Faloutsos, R. Ng, and T. Sellis. Predictive load control for flexible buffer allocation. In Proc. of Intl. Conf. on Very Large Data Bases, pages 265–274, 1991.

[For81] C. L. Forgy. OPS5 user’s manual. Technical Report CMU-CS-81-135, Carnegie-Mellon University, 1981.

[For82] C. L. Forgy. Rete: A fast algorithm for the many pattern/many object pattern match problem.

Artificial Intelligence, 19:17–37, 1982.

[Fra54] R. Fraissé. Sur les classifications des systèmes de relations. Publ. Sci. Univ. Alger, I:1, 1954.

[Fre87] J. C. Freytag. A rule-based view of query optimization. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 173–180, 1987.

[Fri71] H. Friedman. Algorithmic procedures, generalized Turing algorithms, and elementary recursion theory. In R. O.Gangy and C. M. E.Yates, editors, Logic Colloquium ’69, pages 361–
389. North Holland, Amsterdam, 1971.

[FT83] P. C. Fischer and D. -M. Tsou. Whether a set of multivalued dependencies implies a join dependency is np-hard. SIAM J. on Computing, 12:259–266, 1983.

[FUMY83] R. Fagin, J. D. Ullman, D. Maier, and M. Yannakakis. Tools for template dependencies.

SIAM J. on Computing, 12(1):36–59, 1983.

[FUV83] R. Fagin, J. D. Ullman, and M. Y. Vardi. On the semantics of updates in databases. In Proc. ACM Symp. on Principles of Database Systems, pages 352–365, 1983.

[FV86] R. Fagin and M. Y. Vardi. The theory of data dependencies: A survey. In M. Anshel and W. Gewirtz, editors, Mathematics of Information Processing: Proceedings of Symposia in Applied Mathematics, vol. 34, pages 19–71. American Mathematical Society, Providence, RI, 1986.

[Fv89] C. C. Fleming and B. von Halle. Handbook of Relational Database Design. Addison-Wesley, Reading, MA, 1989.

[Gal87] A. Galton. Temporal logics and their applications. Academic Press, New York, 1987.

[Gar70] M. Gardner. The game of life. Sci. American, 223, 1970.

[Gär88] P. Gärdenfors. Knowledge in Flux: Modeling the Dynamics of Epistemic States. MIT Press, Cambridge, MA, 1988.

[GD87] G. Graefe and D. J. DeWitt. The EXODUS optimizer generator. In Proc. ACM SIGMOD
Symp. on the Management of Data, pages 160–172, 1987.

[GD94] S. Gatziu and K. R. Dittrich. Detecting composite events in active database systems using petri nets. In Proc. Fourth Intl. Workshop on Research Issues in Data Engineering: Active Database Systems, pages 2–9, 1994.

[GdM86] G. Gardarin and C. de Maindreville. Evaluation of database recursive logic programs as recurrent function series. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 177–186, 1986.

[GG88] M. Gyssens and D. Van Gucht. The powerset algebra as a result of adding programming
636
Bibliography
constructs to the nested relational algebra. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 225–232, 1988.

[GH83] S. Ginsburg and R. Hull. Characterizations for functional dependency and Boyce-Codd normal form families. Theoretical Computer Science, 27:243–286, 1983.

[GH86] S. Ginsburg and R. Hull. Sort sets in the relational model. J. ACM, 33:465–488, 1986.

[Gin66] S. Ginsburg. The Mathematical Theory of Context-Free Languages. McGraw-Hill, New York, 1966.

[Gin93] S. Ginsburg. Object and spreadsheet histories. In A. U. Tansel et al., editors, Temporal Databases – Theory, Design, and Implementation, pages 272–293. Benjamin/Cummings Publishing Co., Menlo Park, 1993.

[GJ79] M. R. Garey and D. S. Johnson. Computers and Intractibilitiy: A Guide to the Theory of NP-Completeness. Freeman, San Francisco, 1979.

[GJ82] J. Grant and B. E. Jacobs. On the family of generalized dependency constraints. J. ACM, 29(4):986–997, 1982.

[GJ91] N. H. Gehani and H. V. Jagadish. ODE as an active database: Constraints and triggers. In Proc. of Intl. Conf. on Very Large Data Bases, pages 327–336, 1991.

[GHJ+93] S. Ghandeharizadeh, R. Hull, D. Jacobs, et al. On implementing a language for specifying active database execution models. In Proc. of Intl. Conf. on Very Large Data Bases, pages 441–454, 1993.

[GHJ94] S. Ghandeharizadeh, R. Hull, and D. Jacobs. [Alg,C]: Elevating deltas to be first-class citizens in a database programming language. Technical report USC–CS–94–581, Computer Science Dept., University of Southern California, Los Angeles, September, 1994.

[GJS92a] N. H. Gehani, H. V. Jagadish, and O. Shmueli. Composite event specification in active databases: Model & implementation. In Proc. of Intl. Conf. on Very Large Data Bases, pages 327–338, 1992.

[GJS92b] N. H. Gehani, H. V. Jagadish, and O. Shmueli. Event specification in an active object-oriented database. Technical memorandum, Bell Labs, Holmdel, NJ, 1992.

[GJS92c] N. H. Gehani, H. V. Jagadish, and O. Shmueli. Event specification in an active object-oriented database. In Proc. ACM SIGMOD Symp. on the Management of Data, 1992.

[GKLT69] Y. V. Glebski˘i, D. I. Kogan, M. I. Liogonki˘i, and V. A. Talanov. Range and degree of realizability of formulas in the restricted predicate calculus. Kibernetika, 2:17–28, 1969.

[GKM92] A. Gupta, D. Katiyar, and I. S. Mumick. Counting solutions to the view maintenance problem. In K. Ramamohanarao, J. Harland, and G. Dong, editors, Proc. of the JICSLP
Workshop on Deductive Databases, 1992.

[GL82] Y. Gurevich and H. R. Lewis. The inference problem for template dependencies. In Proc.

ACM Symp. on Principles of Database Systems, pages 221–229, 1982.

[GL88] M. Gelfond and V. Lifschitz. The stable model semantics for logic programs. In Intl. Conf.

on Logic Programming, pages 1070–1080, 1988.

[GM78] H. Gallaire and J. Minker. Logic and Databases. Plenum Press, New York, 1978.

[GMN84] H. Gallaire, J. Minker, and J. -M. Nicolas. Logic and databases: A deductive approach.

ACM Computing Surveys, 16(2):153–185, 1984.

[GMR92] G. Grahne, A. O. Mendelzon, and P. Z. Revesz. Knowledgebase transformations. In Proc.

ACM Symp. on Principles of Database Systems, pages 246–260, 1992.

[GMS93] A. Gupta, I. S. Mumick, and V. S. Subrahmanian. Maintaining views incrementally. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 157–166, 1993.

[GMSV87] H. Gaifman, H. Mairson, Y. Sagiv, and M. Y. Vardi. Undecidable optimization
Bibliography
637
problems for database logic programs. In Proc. IEEE Conf. on Logic in Computer Science, pages 106–115, 1987.

[GMSV93] H. Gaifman, H. Mairson, Y. Sagiv, and M. Y. Vardi. Undecidable optimization problems for database logic programs. J. ACM, 40:683–713, 1993.

[GMV86] M. H. Graham, A. O. Mendelzon, and M. Y. Vardi. Notions of dependency satisfaction.

J. ACM, 33(1):105–129, 1986.

[GO93] E. Grädel and M. Otto. Inductive definability with counting on finite structures. In 6th Workshop on Computer Science Logic CSL 92, pages 231–247. Springer-Verlag, Berlin, LNCS
702, 1993.

[Goo70] L. A. Goodman. The multivariate analysis of qualitative data: Interactions among multiple classifications. J. Amer. Stat. Assn. , 65:226–256, 1970.

[Got87] G. Gottlob. Computing covers for embedded functional dependencies. In Proc. ACM Symp.

on Principles of Database Systems, pages 58–69, 1987.

[GPG90] M. Gyssens, J. Paredaens, and D. Van Gucht. A graph-oriented object database model. In Proc. ACM Symp. on Principles of Database Systems, pages 417–424, 1990.

[GPSZ91] F. Giannotti, D. Pedreschi, D. Saccà, and C. Zaniolo. Nondeterminism in deductive databases. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), pages 129–146. Springer-Verlag, Berlin LNCS 566, 1991.

[GR83] A. Goldberg and D. Robson. Smalltalk-80: The Language and Its Implementation.

Addison-Wesley, Reading, MA, 1983.

[GR86] G. Grahne and K.-J. Raiha. Characterizations for acyclic database schemes. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing Research, vol. 3: The Theory of Databases, pages 19–42. JAI Press, Inc., Greenwich, CT, 1986.

[Gra77] J. Grant. Null values in relational databases. In Inf. Proc. Letters, pages 156–157, 1977.

[Gra79] M. H. Graham. On the universal relation. Technical Report, University of Toronto, Toronto, Ontario, Canada, 1979.

[Gra83] E. Grandjean. Complexity of the first-order theory of almost all structures. Information and Control, 52:180–204, 1983.

[Gra84] G. Grahne. Dependency satisfaction in databases with incomplete information. In Proc. of Intl. Conf. on Very Large Data Bases, pages 37–45, 1984.

[Gra91] G. Grahne. The Problem of Incomplete Information in Relational Databases. Springer-Verlag, Berlin, 1991.

[Gra93] G. Graefe. Query evaluation techniques for large databases. ACM Computing Surveys, 25(2):73–170, 1993.

[Gre75] S. Greibach. Theory of Program Structures: Schemes, Semantics, Verification. Springer-Verlag, Berlin, LCNS 36, 1975.

[GS82] N. Goodman and O. Shmueli. Tree queries: A simple class of queries. ACM Trans. on Database Systems, 7(4):653–677, 1982.

[GS84] N. Goodman and O. Shmueli. The tree projection theorem and relational query processing.

Journal of Computer and System Sciences, 28(1):60–79, 1984.

[GS86] Y. Gurevich and S. Shelah. Fixed-point extensions of first-order logic. Annals of Pure and Applied Logic, 32:265–280, 1986.

[GS87] G. Gardarin and E. Simon. Les systèmes de gestion de bases de données deductives.

Technique et Science Informatiques, 6(5), 1987.

638
Bibliography
[GS94] S. Grumbach and J. Su. Finitely representable databases. In Proc. ACM Symp. on Principles of Database Systems, 1994.

[GST90] S. Ganguly, A. Silberschatz, and S. Tsur. A framework for the parallel processing of datalog queries. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 143–152, 1990.

[GT83] N. Goodman and Y. C. Tay. Synthesizing fourth normal form relations from multivalued dependencies. Technical Report, Harvard University , 1983.

[Gun92] C. Gunter. The mixed powerdomain. Theoretical Computer Science, 103:311–334, 1992.

[Gur] Y. Gurevich. Personal communication.

[Gur66] Y. Gurevich. The word problem for certain classes of semigroups (In Russian.). Algebra and Logic, 5:25–35, 1966.

[Gur84] Y. Gurevich. Toward a logic tailored for computational complexity. In M. M. Richter et al., editor, Computation and Proof Theory, pages 175–216. Springer-Verlag, Berlin, LNM 1104, 1984.

[Gur88] Y. Gurevich. Logic and the challenge of computer science. In E. Borger, editor, Trends in Theoretical Computer Science, pages 1–57. Computer Science Press, Rockville, MD, 1988.

[GV84] M. H. Graham and M. Y. Vardi. On the complexity and axiomatizability of consistent database states. Proc. ACM Symp. on Principles of Database Systems, pages 281–289, 1984.

[GV91] S. Grumbach and V. Vianu. Tractable query languages for complex object databases. In Proc. ACM Symp. on Principles of Database Systems, 1991.

[GV92] G. Gardarin and P. Valduriez. ESQL2: An object-oriented SQL with F-logic semantics. In Intl. Conf. on Data Engineering, 1992.

[GW89] G. Graefe and K. Ward. Dynamic query evaluation plans. In Proc. ACM SIGMOD Symp.

on the Management of Data, pages 358–366, 1989.

[GW90] J. R. Groff and P. N. Weinberg. Using SQL. Osborne McGraw-Hill, New York, 1990.

[GZ82] S. Ginsburg and S. M. Zaiddan. Properties of functional dependency families. J. ACM, 29(4):678–698, 1982.

[GZ88] G. Gottlob and R. Zicari. Closed world databases opened through null values. In Proc. of Intl. Conf. on Very Large Data Bases, pages 50–61, 1988.

[Hab70] S. J. Haberman. The general log-linear model. Ph.D. thesis, Department of Statistics, University of Chicago, 1970.

[Hal93] J. Y. Halpern. Reasoning about knowledge: a survey circa 1991. In A. Kent and J. G.

Williams, editors, Encyclopedia of Computer Science and Technology, Vol. 27 (Supplement 12).

Marcel Dekker, New York, 1993.

[Han89] E. H. Hanson. An initial report on the design of ariel: a dbms with an integrated production rule system. In SIGMOD Record, 18(3):12–19, 1989.

[Har78] M. A. Harrison. Introduction to Formal Language Theory. Addison-Wesley, Reading, MA, 1978.

[Har80] D. Harel. On folk theorems. Comm. of the ACM, 23:379–385, 1980.

[HCL+90] L. Haas, W. Chang, G. M. Lohman, J. McPherson, P. F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, and E. Shekita. Starburst midflight: As the dust clears. IEEE Transactions on Knowledge and Data Engineering, 2(1):143–160, 1990.

[Hel92] L. Hella. Logical hierarchies in PTIME. In Proc. IEEE Conf. on Logic in Computer Science, 1992.

Bibliography
639
[Her92] C. Herrmann. On the undecidability of implications between embedded multivalued database dependencies. Technical Report, Technische Hochschule Darmstadt, Germany.

February 24, 1992.

[HH93] T. Hirst and D. Harel. Completeness results of recursive data bases. In Proc. ACM Symp.

on Principles of Database Systems, pages 244–252, 1993.

[HJ91a] R. Hull and D. Jacobs. Language constructs for programming active databases. In Proc. of Intl. Conf. on Very Large Data Bases, pages 455–468, 1991.

[HJ91b] R. Hull and D. Jacobs. On the semantics of rules in database programming languages. In J. Schmidt and A. Stogny, editors, Next Generation Information System Technology: Proc. of the First International East/West Database Workshop, Kiev, USSR, October 1990, pages 59–85.

Springer-Verlag, Berlin, LNCS 504, 1991.

[HK81] M. S. Hecht and L. Kerschberg. Update semantics for the functional data model. Technical Report, Bell Laboratories, Holmdel, NJ, January 1981.

[HK87] R. Hull and R. King. Semantic database modeling: Survey, applications, and research issues. ACM Computing Surveys, 19:201–260, 1987.

[HK89] S. E. Hudson and R. King. Cactis: A self-adaptive, concurrent implementation of an object-oriented database management system. ACM Trans. on Database Systems, 14:291–321, 1989.

[HKM93] G. Hillebrand, P. Kanellakis, and H. Mairson. Database query languages embedded in the typed lambda calculus. In Proc. IEEE Conf. on Logic in Computer Science, pages 332–343, 1993.

[HKR93] G. Hillebrand, P. Kanellakis, and S. Ramaswamy. Functional programming formalisms for OODB methods. In Proc. NATO ASI Summer School on OODBs, Kasadaci, Turkey, 1993.

[HLM88] M. Hsu, R. Ladin, and D. R. McCarthy. An execution model for active data base management systems. In Intl. Conf. on Data and Knowledge Bases: Improving Usability and Responsiveness, pages 171–179, 1988.

[HLY80] P. Honeyman, R. E. Ladner, and M. Yannakakis. Testing the universal instance assumption.

Inf. Proc. Letters, 10(1):14–19, 1980.

[HM81] M. Hammer and D. McLeod. Database description with SDM: A semantic database model.

ACM Trans. on Database Systems, 6(3):351–386, 1981.

[HMN84] L. J. Henschen, W. W. McCune, and S. A. Naqvi. Compiling constraint-checking programs from first-order formulas. In H. Gallaire, J. Minker, and J. -M. Nicolas, editors, Advances in Data Base Theory, vol. 2, pages 145–169. Plenum Press, New York, 1984.

[HMT71] L. Henkin, J. D. Monk, and A. Tarski. Cylindric Algebras. North Holland, Amsterdam, 1971.

[HN84] L. J. Henschen and S. A. Naqvi. On compiling queries in recursive first-order databases. J.

ACM, 31(1):47–85, 1984.

[Hon82] P. Honeyman. Testing satisfaction of functional dependencies. J. ACM, 29(3):668–677, 1982.

[HS89a] R. Hull and J. Su. On accessing object-oriented databases: Expressive power, complexity, and restrictions. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 147–158, 1989.

[HS89b] R. Hull and J. Su. Untyped sets, invention, and computable queries. In Proc. ACM Symp.

on Principles of Database Systems, pages 347–359, March 1989.

640
Bibliography
[HS93] R. Hull and J. Su. Algebraic and calculus query languages for recursively typed complex objects. Journal of Computer and System Sciences, 47:121–156, 1993.

[HS94] R. Hull and J. Su. Domain independence and the relational calculus. Acta Informatica 31:513–524, 1994.

[HTY89] R. Hull, K. Tanaka, and M. Yoshikawa. Behavior analysis of object-oriented databases: Method structure, execution trees and reachability. In Proceedings 3rd International Conference on Foundations of Data Organization and Algorithms, pages 372–388, 1989.

[Hul83] R. Hull. Acyclic join dependency and data base projections. Journal of Computer and System Sciences, 27(3):331–349, 1983.

[Hul84] R. Hull. Finitely specifiable implicational dependency families. J. ACM, 31(2):210–226, 1984.

[Hul85] R. Hull. Non-finite specifiability of projections of functional dependency families. In Theoretical Computer Science, 39:239–265, 1985.

[Hul86] R. Hull. Relative information capacity of simple relational schemata. SIAM J. on Computing, 15(3):856–886, August 1986.

[Hul87] R. Hull. A survey of theoretic research on typed complex database objects. In J. Paredaens, editor, Databases, pages 193–256. Academic Press, London, 1987.

[Hul89] G. Hulin. Parallel processing of recursive queries in distributed architectures. In Proc. of Intl. Conf. on Very Large Data Bases, pages 87–96, 1989.

[HW92] E. N. Hanson and J. Widom. An overview of production rules in database systems.

Technical Report RJ 9023 (80483), IBM Almaden Research, October 1992.

[HY84] R. Hull and C. K. Yap. The Format model: A theory of database organization. Journal of the ACM, 31(3):518–537, 1984.

[HY90] R. Hull and M. Yoshikawa. ILOG: Declarative creation and manipulation of object identifiers (extended abstract). In Proc. of Intl. Conf. on Very Large Data Bases, pages 455–
468, 1990.

[HY92] R. Hull and M. Yoshikawa. On the equivalence of data restructurings involving object identifiers. In J. D. Ullman, editor, Studies in Theoretical Computer Science (a festschrift for Seymour Ginsburg), pages 253–286. Academic Press, New York, 1992. See also article of same title in Proc. ACM Symp. on Principles of Data Base Systems, 1991.

[IK90] Y. E. Ioannidis and Y. C. Kang. Randomized algorithms for optimizing large join queries. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 312–321, 1990.

[IL84] T. Imielinski and W. Lipski. The relational model of data and cylindric algebras. Journal of Computer and System Sciences, 28(1):80–102, 1984.

[Imi84] T. Imielinski. On algebraic query processing in logical databases. In H. Gallaire and J. Minker, editors, Advances in Data Base Theory, vol. 2. Plenum Press, New York, 1984.

[Imm82] N. Immerman. Upper and lower bounds for first-order definability. Journal of Computer and System Sciences, 25:76–98, 1982.

[Imm86] N. Immerman. Relational queries computable in polynomial time. Inf. and Control, 68:86–104, 1986.

[Imm87a] N. Immerman. Expressibility as a complexity measure: Results and directions. Technical Report DCS-TR-538, Yale University, New Haven, CT, 1987.

[Imm87b] N. Immerman. Languages which capture complexity classes. SIAM J. on Computing, 16(4):760–778, 1987.

Bibliography
641
[IN88] T. Imielinski and S. Naqvi. Explicit control of logic programs through rule algebra. In Proc.

ACM Symp. on Principles of Database Systems, pages 103–116, 1988.

[INSS92] Y. E. Ioannidis, R. T. Ng, K. Shim, and T. K. Sellis. Parametric query optimization. In Proc. of Intl. Conf. on Very Large Data Bases, pages 103–114, 1992.

[INV91a] T. Imielinski, S. Naqvi, and K. Vadaparty. Incomplete objects – A data model for design and planning applications. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 288–197, 1991.

[INV91b] T. Imielinski, S. Naqvi, and K. Vadaparty. Querying design and planning databases. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), pages 524–545, 1991.

[Ioa85] Y. E. Ioannidis. A time bound on the materialization of some recursively defined views. In Proc. of Intl. Conf. on Very Large Data Bases, pages 219–226, 1985.

[Jac82] B. E. Jacobs. On database logic. J. ACM, 29(2):310–332, 1982.

[JH91] D. Jacobs and R. Hull. Database programming with delayed updates. In Proc. of Intl.

Workshop on Database Programming Languages, pages 416–428, 1991.

[JK84a] M. Jarke and J Koch. Query optimization in database systems. ACM Computing Surveys, 16(2):111–152, 1984.

[JK84b] D. S. Johnson and A. Klug. Testing containment of conjunctive queries under functional and inclusion dependencies. Journal of Computer and System Sciences, 28:167–189, 1984.

[JL87] J. Jaffar and J. L. Lassez. Constraint logic programming. In Proc. ACM Symp. on Principles of Programming Languages, pages 111–119, 1987.

[Joh91] D. S. Johnson. A catalog of complexity classes. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 67–162. Elsevier, Amsterdam, 1991.

[Joy76] W. H. Joyner Jr. Resolution strategies as decision procedures. J. ACM, 23:398–417, 1976.

[JS82] G. Jaeschke and H. -J. Schek. Remarks on the algebra on non first normal form relations. In Proc. ACM Symp. on Principles of Database Systems, pages 124–138, 1982.

[Kam81] Y. Kambayashi. Database: A Bibliography. Computer Science Press, Rockville, MD, 1981.

[Kan88] P. C. Kanellakis. Logic programming and parallel complexity. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 547–586. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Kan91] P. C. Kanellakis. Elements of relational database theory. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 1074–1156. Elsevier, Amsterdam, 1991.

[KC86] S. Khoshafian and G. Copeland. Object identity. In Proc. OOPSALA, 1986.

[KDM88] A. M. Kotz, K. R. Dittrich, and J. A. Mülle. Supporting semantic rules by a generalized event/trigger mechanism. In Intl. Conf. on Extending Data Base Technology, pages 76–91, 1988.

[Kel82] A. M. Keller. Updates to relational databases through views involving joins. In Peter Scheuermann, editor, Improving Database Usability and Responsiveness. Academic Press, New York, 1982.

[Kel85] A. Keller. Algorithms for translating view updates to database updates for views involving selections, projections and joins. In Proc. ACM Symp. on Principles of Database Systems, pages 154–163, 1985.

[Kel86] A. M. Keller. The role of semantics in translating view updates. IEEE Computer, 19(1):63–
73, January 1986.

642
Bibliography
[Ken78] W. Kent. Data and Reality. North Holland, Amsterdam, 1978.

[Ken79] W. Kent. Limitations of record-based information models. ACM Trans. on Database Systems, 4:107–131, 1979.

[Ken89] W. Kent. The many forms of a single fact. In Proc. of the IEEE Compcon Conf. , 1989.

[Ker88] J-M. Kerisit. La Méthode d’Alexander: Une Technique de Déduction. Ph.D. thesis, Université Paris VII, 1988.

[KG94] P. Kanellakis and D. Goldin. Constraint programming and database query languages.

To appear in Springer-Verlag, Berlin, editor, Proc. 2nd Conference on Theoretical Aspects of Computer Software (TACS), 1994.

[Kif88] M. Kifer. On safety, domain independence, and capturability of database queries. In C. Beeri, J. W. Schmidt, and U. Dayal, editors, Proc. 3rd Intl. Conf. on Data and Knowledge Bases, pages 405–415. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[KKR90] P. Kanellakis, G Kuper, and P. Revesz. Constraint query languages. In Proc. 9th ACM
Symp. on Principles of Database Systems, pages 299–313, Nashville, 1990.

[KKS92] M. Kifer, W. Kim, and Y. Sagiv. Querying object-oriented databases. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 393–402, 1992.

[KL86a] M. Kifer and E. Lozinskii. A framework for an efficient implementation of deductive databases. In Proc. of the Advanced Database Symposium, Tokyo, 1986.

[KL86b] M. Kifer and E. L. Lozinskii. Filtering data flow in deductive databases. In Proc. of Intl.

Conf. on Database Theory, 1986.

[KL89] W. Kim and F. Lochovsky, editors. Object-Oriented Concepts, Databases, and Applications.

Addison-Wesley, Reading, MA, 1989.

[Kle67] S. C. Kleene. Mathematical Logic. North Holland, Amsterdam, 1967.

[Klu80] A. Klug. Caculating constraints on relational tableaux. In ACM Trans. on Database Systems, 5:260–290, 1980.

[Klu82] A. Klug. Equivalence of relational algebra and relational calculus query languages having aggregate functions. J. ACM, 29(3):699–717, 1982.

[Klu88] A. Klug. On conjunctive queries containing inequalities. J. ACM, 35(1):146–160, 1988.

[KLW93] M. Kifer, G. Lausen, and J. Wu. Logical foundations of object-oriented and frame-based languages. Technical Report 93/06, Computer Science Department, SUNY at Stony Brook, NY, 1993.

[KM91a] H. Katsuno and A. O. Mendelzon. On the difference between updating a knowledge base and revising it. In Proc. of the Second Intl. Conf. on Principles of Knowledge Representation and Reasoning, pages 387–394, 1991.

[KM91b] H. Katsuno and A. O. Mendelzon. Propositional knowledgebase revision and minimal change. Artificial Intelligence, 52:263–294, 1991.

[KN88] R. Krishnamurthy and S. A. Naqvi. Nondeterministic choice in datalog. In 5th Intl. Conf.

on Data and Knowledge Bases, pages 416–424. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Kni89] K. Knight. Unification: a multidisciplinary survey. ACM Computing Surveys, 21(1):93–124, 1989.

[Kol83] P. G. Kolaitis. Lecture notes on finite model theory, 1983.

[Kol91] P. G. Kolaitis. The expressive power of stratified logic programs. Information and Computation, 90(1):50–66, 1991.

[Kon88] S. Konolige. On the relation between default and autoepistemic logic. Artificial Intelligence, 35(3):343–382, 1988.

Bibliography
643
[Kow74] R. A. Kowalski. Predicate logic as a programming language. In Proc. IFIP.’74, pages 569–
574, 1974.

[Kow75] R. A. Kowalski. A proof procedure using connection graphs. J. ACM, 22:572–595, 1975.

[Kow81] R. Kowalski. Logic as database language. Unpublished manuscript, Dept. of Computing, Imperial College, London, 1981.

[KP81] S. Koenig and R. Paige. A transformational framework for the automatic control of derived data. In Proc. of Intl. Conf. on Very Large Data Bases, pages 306–318, 1981.

[KP82] A. Klug and R. Price. In determining view dependencies using tableaux. In ACM Trans. on Database Systems, 7:361–381, 1982.

[KP86] P. Kanellakis and C. H. Papadimitriou. Notes on monadic sirups. Unpublished manuscript, 1986.

[KP88] P. G. Kolaitis and C. H. Papadimitriou. Why not negation by fixpoint? In Proc. ACM Symp.

on Principles of Database Systems, pages 231–239, 1988.

[KRS88a] M. Kifer, R. Ramakrishnan, and A. Silberschatz. An axiomatic approach to deciding query safety in deductive databases. In Proc. ACM Symp. on Principles of Database Systems, pages 52–60, 1988.

[KRS88b] R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. A framework for testing safety and effective computability of extended Datalog. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 154–163, 1988.

[KS91] H. F. Korth and A. Silberschatz. Database System Concepts, 2d ed. McGraw-Hill, New York, 1991.

[KT88] D. B. Kemp and R. W. Topor. Completeness of a top-down query evaluation procedure for stratified databases. In Proc. Fifth Intl. Symp. on Logic Programming, pages 195–211, 1988.

[KU84] A. Keller and J. D. Ullman. On complementary and independent mappings. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 143–148, 1984.

[Küc91] V. Küchenhoff. On the efficient computation of the difference between consecutive database states. In Proc. of Intl. Conf. on Deductive and Object-Oriented Databases (DOOD), pages 478–502, 1991.

[Kuh67] J. L. Kuhns. Answering questions by computer: a logical study. Technical Report RM-5428-PR, Rand Corp., 1967.

[Kun87] K. Kunen. Negation in logic programming. Logic Programming, 4:289–308, 1987.

[Kun88] K. Kunen. Some remarks on the completed database. In Intl. Conf. on Logic Programming, pages 978–992, 1988.

[Kup87] G. M. Kuper. Logic programming with sets. In Proc. ACM Symp. on Principles of Database Systems, pages 11–20, 1987.

[Kup88] G. M. Kuper. On the expressive power of logic programming languages with sets. In Proc.

ACM Symp. on Principles of Database Systems, pages 10–14, 1988.

[Kup93] G. M. Kuper. Aggregation in constraint databases. In Proc. First Workshop on Principles and Practice of Constraint Programming, 1993.

[KV84] G. Kuper and M. Y. Vardi. A new approach to database logic. In Proc. ACM Symp. on Principles of Database Systems, pages 86–96, 1984.

[KV87] P. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of higher-order properties. In Proc. ACM SIGACT Symp. on the Theory of Computing, pages 425–435, 1987.

[KV90a] D. Karabeg and V. Vianu. Parallel update transactions. Theoretical Computer Science, 76:93–114, 1990.

644
Bibliography
[KV90b] P. G. Kolaitis and M. Y. Vardi. 0-1 laws and decision problems for fragments of second-order logic. Information and Computation, 87:302–338, 1990.

[KV90c] P. G. Kolaitis and M. Y. Vardi. On the expressive power of Datalog: tools and a case study.

In Proc. ACM Symp. on Principles of Database Systems, pages 61–71, 1990.

[KV91] D. Karabeg and V. Vianu. Simplification rules and axiomatization for relational update transactions. ACM Trans. on Database Systems, 16(3):439–475, 1991.

[KV92] P. G. Kolaitis and M. Y. Vardi. Infinitary logics and 0-1 laws. Information and Computation, 98:258–294, 1992.

[KV93a] G. Kuper and M. Y. Vardi. On the complexity of queries in the logical data model.

Theoretical Computer Science, 116:33–58, 1993.

[KV93b] G. M. Kuper and M. Y. Vardi. The logical data model. ACM Trans. on Database Systems, 18:379–413, 1993.

[KW85] A. M. Keller and M. Winslett Wilkins. On the use of an extended relational model to handle changing incomplete information. IEEE Transactions on Software Engineering, SE-11:620–633, 1985.

[KW89] M. Kifer and J. Wu. A logic for object-oriented logic programming (Maier’s O-logic revisited). In Proc. ACM Symp. on Principles of Database Systems, pages 379–393, 1989.

[Lan88] B. Lang. Datalog automata. In Proc. 3rd Intl. Conf. on Data and Knowledge Bases, pages 389–404. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Lee91] J. Van Leeuwen, editor. Handbook of Theoretical Computer Science. Elsevier, Amsterdam, 1991.

[Lei69] A. C. Leisenring. Mathematical Logic and Hilbert’s ε -symbol. Gordon and Breach, New York, 1969.

[Lei89a] D. Leivant. Descriptive characterization of computational complexity. Journal of Computer and System Sciences, 39:51–83, 1989.

[Lei89b] D. Leivant. Monotonic use of space and computational complexity over abstract structures.

Technical Report CMU-CS-89-212, Carnegie-Mellon University, 1989.

[Lei90] D. Leivant. Inductive definitions over finite structures. Information and Computation, 89:95–108, 1990.

[Lel87] W. Leler. Constraint Programming Languages. Addison-Wesley, Reading, MA, 1987.

[Lev84a] H. J. Levesque. The logic of incomplete knowledge bases. In M. L. Brodie, J. L. Mylopoulos, and J. W. Schmidt, editors, On Conceptual Modeling, pages 165–189.

Springer-Verlag, Berlin, 1984.

[Lev84b] H. J. Levesque. Foundations of a functional approach to knowledge representation. AI J. , 23:155–212, 1984.

[Lib91] L. Libkin. A relational algebra for complex objects based on partial information. In LNCS
495: Proceedings of Symp. on Mathematical Fundamentals of Database Systems, pages 36–41.

Springer-Verlag, Berlin, 1991.

[Lie80] Y. E. Lien. On the semantics of the entity-relationship model. In P. P. Chen, editor, Entity-Relationship Approach to Systems Analysis and Design, pages 155–167, 1980.

[Lie82] E. Lien. On the equivalence of database models. J. ACM, 29(2):333–363, 1982.

[Lif88] V. Lifschitz. On the declarative semantics of logic programs with negation. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 177–192. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

Bibliography
645
[Lin90] S. Lindell. An analysis of fixed-point queries on binary trees. Ph.D. thesis, University of California at Los Angeles, 1990.

[Lin91] S. Lindell. An analysis of fixed-point queries on binary trees. Theoretical Computer Science, 85:75–95, 1991.

[Lip79] W. Lipski. On semantic issues connected with incomplete information databases. ACM
Trans. on Database Systems, 4(3):262–296, 1979.

[Lip81] W. Lipski. On databases with incomplete information. J. ACM, 28(1):41–70, 1981.

[LL86] N. Lerat and W. Lipski. Nonapplicable nulls. Theoretical Computer Science, 46:67–82, 1986.

[LL90] M. Leven and G. Loizou. The nested relation type model: An application of domain theory to databases. The Computer Journal, 33:19–30, 1990.

[Llo87] J. W. Lloyd. Foundations of logic programming, 2d ed., Springer-Verlag, Berlin, 1987.

[LM89] V. S. Lakshmanan and A. O. Mendelzon. Inductive pebble games and the inductive power of Datalog. In Proc. ACM Symp. on Principles of Database Systems, pages 301–311, 1989.

[LM93] D. Leivant and J. -Y. Marion. Lambda calculus characterizations of polytime. In Proceedings of the International Conference on Typed Lambda Calculi and Applications, 1993. (To appear in Fundamenta Informaticae.)

[LMG83] K. Laver, A. O. Mendelzon, and M. H. Graham. Functional dependencies on cyclic database schemes. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 79–91, 1983.

[LN90] R. J. Lipton and J. F. Naughton. Query size estimation by adaptive sampling (extended abstract). In Proc. ACM Symp. on Principles of Database Systems, pages 40–46, 1990.

[LO78] C. L. Lucchesi and S. L. Osborn. Candidate keys for relations. Journal of Computer and System Sciences, 17(2):270–279, 1978.

[Loh88] G. M. Lohman. Grammar-like functional rules for representing query optimization alternatives. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 18–27, 1988.

[Low15] L. Lowenheim. Uber Möglichkeiten im relativekalkul. Math. Ann. , 76:447–470, 1915.

[Loz85] E. Lozinskii. Evaluating queries in deductive databases by generating. In Proc. 11th Intl.

Joint Conf. on Artificial Intelligence, pages 173–177, 1985.

[LP81] H. R. Lewis and C. H. Papadimitriou. Elements of the Theory of Computation. Prentice-Hall, Englewood Cliffs, NJ, 1981.

[LMR92] J. Lobo, J. Minker, and A. Rajasekar. Foundations of Disjunctive Logic Programming.

MIT Press, Cambridge, MA, 1992.

[LRV88] C. Lecluse, P. Richard, and F. Velez. O2, an object-oriented data model. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 424–434, 1988.

[LS87] U. W. Lipeck and G. Saake. Monitoring dynamic integrity constraints based on temporal logic. Information Systems, 12(3):255–269, 1987.

[LST87] J. W. Lloyd, E. A. Sonenberg, and R. W. Topor. Integrity constraint checking in stratified databases. Journal of Logic Programming, 4:331–343, 1987.

[LTK81] T. Ling, F. Tompa, and T. Kameda. An improved third normal form for relational databases.

ACM Trans. on Database Systems, 6(2):326–346, 1981.

[LV87] P. Lyngbaek and V. Vianu. Mapping a semantic database model to the relational model. In Proc. ACM SIGMOD Symp. on the Management of Data, 1987.

[LV89] A. Lefevre and L. Vieille. On deductive query evaluation in the DedGin* system. In Proc.

1st Internat. Conf. on Deductive and Object-Oriented Databases, pages 225–246, 1989.

646
Bibliography
[LW93a] L. Libkin and L. Wong. Semantic representations and query languages for or-sets. In Proc.

ACM Symp. on Principles of Database Systems, pages 37–48, 1993.

[LW93b] L. Libkin and L. Wong. Some properties of query languages for bags. In Proc. of Intl.

Workshop on Database Programming Languages, pages 97–114, 1993.

[Mai80] D. Maier. Minimum covers in the relational database model. J. ACM, 27(4):664–674, 1980.

[Mai83] D. Maier. The Theory of Relational Databases. Computer Science Press, Rockville, MD, 1983.

[Mai86] D. Maier. A logic for objects. From a Workshop on Foundations of Deductive Databases and Logic Programming held in Washington, D.C., pages 6–26, 1986.

[Mak77] A. Makinouchi. A consideration of normal form of not-necessarily-normalized relations in the relational data model. In Proc. of Intl. Conf. on Very Large Data Bases, pages 447–453, 1977.

[Mak81] J. A. Makowsky. Characterizing data base dependencies. In 8th Colloquium on Automata, Languages and Programming. Springer-Verlag, Berlin, 1981.

[Mak85] D. Makinson. How to give it up: A survey of some formal aspects of the logic of theory change. Synthèse, 62:347–363, 1985.

[Mal86] F. M. Malvestuto. Modelling large bases of categorical data with acyclic schemes. In Proc.

of Intl. Conf. on Database Theory, 1986.

[MB92] R. M. MacGregor and D. Brill. Recognition algorithms for the Loom classifier. In Proc.

Natl. Conf. on Artificial Intelligence, 1992.

[MBW80] J. Mylopoulos, P. A. Bernstein, and H. K. T. Wong. A language facility for designing database-intensive applications. ACM Trans. on Database Systems, 5:185–207, June 1980.

[MD89] D. McCarthy and U. Dayal. The architecture of an active database management system. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 215–224, 1989.

[ME92] P. Mishra and M. H. Eich. Join processing in relational databases. ACM Computing Surveys, 24:63–113, 1992.

[MFPR90] I. S. Mumick, S. Finkelstein, H. Pirahesh, and R. Ramakrishnan. Magic is relevant. In Proc. ACM SIGMOD Symp. on the Management of Data, 1990.

[Min88a] J. Minker, editor. Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Min88b] J. Minker. Perspectives in deductive databases. J. Logic Programming, 5(1):33–60, 1988.

[MIR93] R. Miller, Y. Ioannidis, and R. Ramakrishnan. The use of information capacity in schema integration and translation. In Proc. of Intl. Conf. on Very Large Data Bases, pages 120–133, 1993.

[MIR94] R. Miller, Y. Ioannidis, and R. Ramakrishnan. Schema equivalence in heterogeneous systems: bridging theory and practice, in Information Systems, 19:3–31, 1994.

[Mit83a] J. C. Mitchell. The implication problem for functional and inclusion dependencies.

Information and Control, 56:154–173, 1983.

[Mit83b] J. C. Mitchell. Inference rules for functional and inclusion dependencies. In Proc. ACM
Symp. on Principles of Database Systems, pages 58–69, 1983.

[MM79] A. O. Mendelzon and D. Maier. Generalized mutual dependencies and the decomposition of database relations. In Proc. of Intl. Conf. on Very Large Data Bases, pages 75–82, 1979.

[MMS79] D. Maier, A. O. Mendelzon, and Y. Sagiv. Testing implications of data dependencies.

ACM Trans. on Database Systems, 4(4):455–469, 1979.

Bibliography
647
[MMSU80] D. Maier, A. O. Mendelzon, F. Sadri, and J. D. Ullman. Adequacy of decompositions of relational databases. Journal of Computer and System Sciences, 21(3):368–379, 1980.

[MMW94] A. O. Mendelzon, T. Milo, and E. Waller. Object migration. In Proc. ACM Symp. on Principles of Database Systems, 1994.

[MNS+87] K. Morris, J. F. Naughton, Y. Saraiya, J. D. Ullman, and A. Van Gelder. YAWN! (yet another window on NAIL!). Data Engineering, 10(4), 1987.

[Moo85] R. C. Moore. Semantics considerations on non-monotonic logic. Artificial Intelligence, 25:75–94, 1985.

[Mor83] M. Morgenstern. Active databases as a paradigm for enhanced computing environments.

In Proc. of Intl. Conf. on Very Large Data Bases, pages 34–42, 1983.

[Mor88] K. Morris. An algorithm for ordering subgoals in NAIL! In Proc. ACM Symp. on Principles of Database Systems, pages 82–88, 1988.

[Mos74] Y. N. Moschovakis. Elementary Induction on Abstract Structures. North Holland, Amsterdam, 1974.

[MR85] H. Mannila and K. -J. Räihä. Small Armstrong relations for database design. In Proc. ACM
Symp. on Principles of Database Systems, pages 245–250, 1985.

[MR88] H. Mannila and K. -J. Räihä. Generating Armstrong databases for sets of functional and inclusion dependencies. Technical Report A-1988-7, University of Tampere, Department of Computer Science, Tampere, Finland, 1988.

[MR90] J. Minker and A. Rajasekar. A fixpoint semantics for disjunctive logic programs. In J.

Logic Programming, 1990.

[MR92] H. Mannila and K. -J. Räihä. The Design of Relational Databases. Addison-Wesley, Wokingham, England, 1992.

[MRW86] D. Maier, D. Rozenshtein, and D. S. Warren. Window functions. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing Research, vol. 3, pages 213–246. JAI Press, Inc., Greenwich, CT, 1986.

[MS81] D. McKay and S. Shapiro. Using active connection graphs for reasoning with recursive rules. In Proc. 7th Intl. Joint Conf. on Artificial Intelligence, pages 368–374, 1981.

[MS92] V. M. Markowitz and A. Shoshani. Represented extended Entity-Relationship structures in relational databases. ACM Trans. on Database Systems, 17:385–422, 1992.

[MSPS87] A. Marchetti-Spaccamela, A. Pelaggi, and D. Saccà. Worst-case complexity analysis of methods for logic query implementation. In Proc. ACM Symp. on Principles of Database Systems, pages 294–301, 1987.

[MSY81] D. Maier, Y. Sagiv, and M. Yannakakis. On the complexity of testing implications of functional and join dependencies. J. ACM, 28(4):680–695, 1981.

[MUG86] K. Morris, J. D. Ullman, and A. Van Gelder. Design overview of the NAIL! system. In 3rd Int. Conf. on Logic Programming, LNCS 225, pages 554–568, Springer-Verlag, Berlin, 1986.

[MUV84] D. Maier, J. D. Ullman, and M. Y. Vardi. On the foundations of the universal relation model. ACM Trans. on Database Systems, 9(2):283–308, 1984.

[MUV86] K. Morris, J. D. Ullman, and A. Van Gelder. Design overview of the NAIL! system. In Proc. Third Intl. Conf. on Logic Programming, pages 554–568, 1986.

[MV86] J. A. Makowsky and M. Y. Vardi. On the expressive power of data dependencies. Acta Informatica, 23:231–244, 1986.

648
Bibliography
[MW88a] D. Maier and D. S. Warren. Computing with Logic: Logic Programming with Prolog.

Benjamin/Cummings Publishing Co., Menlo Park, CA, 1988.

[MW88b] S. Manchanda and D. S. Warren. A logic-based language for database updates. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 363–
394. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Nau86] J. F. Naughton. Data independent recursion in deductive databases. In Proc. ACM Symp.

on Principles of Database Systems, pages 267–279, 1986.

[NCS91] R. Ng, C. Caloutsos, and T. Sellis. Flexible buffer allocation based on marginal gains. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 387–396, 1991.

[ND82] J. -M. Nicolas and R. Demolombe. On the stability of relational queries. Technical Report, ONERA-CERT, Toulouse, 1982.

[Nej87] W. Nejdl. Recursive strategies for answering recursive queries – The RQA/FQI strategy. In Proc. of Intl. Conf. on Very Large Data Bases, 1987.

[NG78] J. -M. Nicolas and H. Gallaire. Database – Theory vs. interpretation. In H. Gallaire and J. Minker, editors, Logic and Databases, pages 33–54. Plenum Press, New York, 1978.

[Nic78] J -M. Nicolas. First order logic formalization for functional, multivalued, and mutual dependencies. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 40–46, 1978.

[Nic82] J. -M. Nicolas. Logic for improving integrity checking in relational databases. Acta Informatica, 18(3):227–253, 1982.

[Nij76] G. M. Nijssen, editor. Modelling in Data Base Management Systems. North Holland, Amsterdam, 1976.

[NK88] S. Naqvi and R. Krishnamurthy. Database updates in logic programming. In Proc. ACM
Symp. on Principles of Database Systems, 1988.

[NPS91] M. Negri, S. Pelagatti, and L. Sbattella. Formal semantics of SQL queries. ACM Trans. on Database Systems, 16(3):513–535, 1991.

[NRSU89] J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ullman. Argument reduction by factoring. In Proc. of Intl. Conf. on Very Large Data Bases, 1989. To appear in Theoretical Computer Science.

[NS87] J. F. Naughton and Y. Sagiv. A decidable class of bounded recursions. In Proc. ACM Symp.

on Principles of Database Systems, pages 227–236, 1987.

[NT89] S. Naqvi and S. Tsur. A language for data and knowledge bases. Computer Science Press, Rockville, MD, 1989.

[Ora89] SQL Language Reference: ORACLE Server for OS/2. Oracle Corp. Redwood Shores, CA, 1989.

[Osb79] S. L. Osborn. Towards a universal relation interface. In Proc. of Intl. Conf. on Very Large Data Bases, pages 52–60, 1979.

[OW93] G. Özsoyo˘glu and H. Wang. A survey of QBE languages. Computer, 26, 1993.

[OY87] Z. M. Özsoyo˘glou and L. -Y. Yuan. A new normal form for nested relations. ACM Trans.

on Database Systems, 12(1):111–136, 1987.

[Pai84] R. Paige. Applications of finite differencing to database integrity control and query/transaction optimization. In H. Gallaire, J. Minker, and J. -M. Nicolas, editors, Advances in Data Base Theory, vol. 2, pages 171–209. Plenum Press, New York, 1984.

[Pap85] C. P. Papadimitriou. A note on the expressive power of prolog. Bulletin of the EATCS, 26:21–23, 1985.

Bibliography
649
[Pap86] C. H. Papadimitriou. The Theory of Concurrency Control. Computer Science Press, Rockville, MD, 1986.

[Pap94] C. Papadimitriou. Computational Complexity. Addison-Wesley, Reading, MA, 1994.

[Par78] J. Paredaens. On the expressive power of the relational algebra. Inf. Proc. Letters, 7(2):107–111, 1978.

[Par79] J. Paredaens. Transitive dependencies in a database scheme. Technical Report R387, MBLE, Brussels, 1979.

[PBGG89] J. Paredaens, P. De Bra, M. Gyssens, and D. Van Gucht. The Structure of the Relational Database Model. EATCS Monographs on Theoretical Computer Science No. 17. Springer-Verlag, Berlin, 1989.

[Pea88] J. Pearl. Probabilistic Reasoning in Intelligent Systems. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Per91] D. Perrin. Finite automata. In J. Van Leeuwen, editor, Handbook of Theoretical Computer Science, pages 1–58. Elsevier, Amsterdam, 1991.

[Pet89] S. V. Petrov. Finite axiomatization of languages for representation of system properties.

Information Sciences, 47:339–372, 1989.

[PG88] J. Paredaens and D. Van Gucht. Possibilities and limitations of using flat operators in nested algebra expressions. In Proc. ACM Symp. on Principles of Database Systems, pages 29–38, 1988.

[PI94] S. Patnaik and N. Immerman. Dyn-FO: A parallel, dynamic complexity class. In Proc. ACM
Symp. on Principles of Database Systems, 1994.

[PJ81] J. Paredaens and D. Janssens. Decompositions of relations: a comprehensive approach. In H. Gallaire, J. Minker, and J. -M. Nicolas, editors, Advances in Data Base Theory, vol. 1, pages 73–100. Plenum Press, New York, 1981.

[PM88] J. Peckham and F. Maryanski. Semantic data models. ACM Computing Surveys, 20:153–
190, 1988.

[Por86] H. H. Porter. Earley deduction. Technical Report TR CS/E-86-002, Oregon Graduate Center, Beaverton, OR, 1986.

[Pos47] E. L. Post. Recursive unsolvability of a problem of Thue. J. of Symbolic Logic, 12:1–11, 1947.

[PPG80] D. S. Parker and K. Parsaye-Ghomi. Inference involving embedded multivalued dependencies and transitive dependencies. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 52–57, 1980.

[Prz86] T. Przymusinski. On the semantics of stratified deductive databases. In Proc. Workshop on the Foundations of Deductive Databases and Logic Programming, pages 433–443, 1986.

[Prz88] T. Przymusinski. Perfect model semantics. In Intl. Conf. on Logic Programming, pages 1081–1096, 1988.

[Prz89] T. Przymusinski. Every logic program has a natural stratification and an iterated least fixpoint model. In Proc. ACM Symp. on Principles of Database Systems, pages 11–21, 1989.

[Prz90] T. Przymusinski. Well-founded semantics coincides with three-valued stable semantics.

Fundamenta Informaticae, XIII:445–463, 1990.

[PSV92] D. S. Parker, E. Simon, and P. Valduriez. SVP – A model capturing sets, streams, and parallelism. In Proc. of Intl. Conf. on Very Large Data Bases, pages 115–126, 1992.

[PV88] J. Pearl and T. Verma. The logic of representing dependencies by directed graphs. In Proceedings, AAAI Conference, Seattle, WA. July, 1987, pages 374–379, 1988.

650
Bibliography
[PW80] F. C. N. Pereira and D. H. D. Warren. Definite clause grammars for language analysis –
A survey of the formalism and a comparison with augmented transition networks. Artificial Intelligence, 13:231–278, 1980.

[PY92] C. H. Papadimitriou and M. Yannakakis. Tie-breaking semantics and structural totality. In Proc. ACM Symp. on Principles of Database Systems, pages 16–22, 1992.

[QW91] X. Qian and G. Wiederhold. Incremental recomputation of active relational expressions.

IEEE Trans. on Knowledge and Data Engineering, 3:337–341, 1991.

[Rad64] R. Rado. Universal graphs and universal functions. Acta Arith. , 9:331–340, 1964.

[Ram91] R. Ramakrishnan. Magic templates: A spellbinding approach to logic programs. J.

Logic Programming, 11:189–216, 1991. See also Proc. Joint Symp. and Intl. Conf. on Logic Programming, 1988.

[RBS87] R. Ramakrishnan, R. Bancilhon, and A. Silberschatz. Safety of recursive horn clauses with infinite relations (extended abstract). In Proc. ACM Symp. on Principles of Database Systems, pages 328–339, 1987.

[RD75] J. Rissanen and C. Delobel. Decomposition of files, a basis for data storage and retrieval.

Technical Report RJ1220, IBM Res. Lab, San Jose, CA, 1975.

[Rei78] R. Reiter. On closed world databases. In H. Gallaire and J. Minker, editors, Logic and Databases, pages 56–76. Plenum Press, New York, 1978.

[Rei80] R. Reiter. A logic for default reasoning. Artificial Intelligence, 13(1):80–132, 1980.

[Rei84] R. Reiter. Towards a logical reconstruction of relational database theory. In M. L. Brodie, J. L. Mylopoulos, and J. W. Schmidt, editors, On Conceptual Modeling, pages 191–238.

Springer-Verlag, Berlin, 1984.

[Rei86] R. Reiter. A sound and sometimes complete query evaluation algorithm for relational databases with null values. J. ACM, 33(2):349–370, 1986.

[Ris77] J. Rissanen. Independent components of relations. ACM Trans. on Database Systems, 2(4):317–325, 1977.

[Ris78] J. Rissanen. Theory of relations for databases – A tutorial survey. In Proc. 7th Symp. on Mathematical Foundations of Computer Science, pages 536–551. Zadopane, Springer-Verlag, Berlin, LNCS 64, 1978.

[Ris82] J. Rissanen. On equivalence of database schemes. In Proc. ACM Symp. on Principles of Database Systems, pages 23–26, 1982.

[RKS88] M. A. Roth, H. F. Korth, and A. Silberschatz. Extended algebra and calculus for nested relational databases. ACM Trans. on Database Systems 13(4):389–417, 1988.

[RLK86] J. Rohmer, R. Lescoeur, and J. M. Kerisit. The Alexander method – A technique for the processing of recursive axioms in deductive databases. New Generation Computing, 4(3):273–286, 1986.

[Rob65] J. A. Robinson. A machine oriented logic based on the resolution principle. J. ACM, 12(1):23–41, 1965.

[Roe87] D. Roelants. Recursive rules in logic databases. Technical Report R513, Philips Research Laboratories, Bruxelles, 1987.

[Ros89] K. Ross. A procedural semantics for the well-founded negation in logic programs. In Proc.

ACM Symp. on Principles of Database Systems, pages 22–33, 1989.

[Ros91] K. A. Ross. The Semantics of Deductive Databases. Ph.D. thesis, Stanford University, 1991.

Bibliography
651
[Rou91] B. Rounds. Situation-theoretic aspects of databases. In Proc. of Conf. on Situation Theory and Applications; CSLI vol. 26, pages 229–256, 1991.

[RS79] L. Rowe and K. A. Schoens. Data abstractions, views and updates in RIGEL. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 71–81, 1979.

[RS91] J. Richardson and P. Schwartz. Aspects: Extending objects to support multiple independent roles. In Intl. Conf. on Principles of Knowledge Representation and Reasoning, pages 298–307, 1991.

[RSB+87] K. Ramamohanarao, J. Shepherd, I. Balbin, G. Port, L. Naish, J. Thom, J. Zobel, and P. Dart. The NU-Prolog deductive database system. Data Engineering, 10(4):10–19, 1987.

[RSS92] R. Ramakrishnan, D. Srivastava, and S. Sudarshan. CORAL: control, relations and logic.

In Proc. of Intl. Conf. on Very Large Data Bases, 1992.

[RSSS93] R. Ramakrishnan, D. Srivastava, S. Sudarshan, and P. Seshadri. Implementation of the CORAL deductive database system. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 167–176, 1993.

[RSUV89] R. Ramakrishnan, Y. Sagiv, J. D. Ullman, and M. Y. Vardi. Proof-tree transformations and their applications. In Proc. ACM Symp. on Principles of Database Systems, pages 172–182, 1989.

[RSUV93] R. Ramakrishnan, Y. Sagiv, J. D. Ullman, and M. Y. Vardi. Logical query optimization by proof-tree transfomation. J. Computer and System Sciences, 47, pages 222–248, 1993.

[RU94] R. Ramakrishnan and J. D. Ullman. A survey of research on deductive database systems. In J. of Logic Programming, to appear.

[SAC+79] P. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. Access path selection in a relational database management system. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 23–34, 1979.

[Sag81] Y. Sagiv. Can we use the universal assumption without using nulls? In Proc. ACM SIGMOD
Symp. on the Management of Data, pages 108–120, 1981.

[Sag83] Y. Sagiv. A characterization of globally consistent database and their correct access paths.

ACM Trans. on Database Systems, 8(2):266–286, 1983.

[Sag88] Y. Sagiv. Optimizing datalog programs. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 659–698. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Sag90] Y. Sagiv. Is there anything better than magic? In Proc. North American Conf. on Logic Programming, pages 235–254, 1990.

[Sci81] E. Sciore. Real-world MVDs. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 121–132, 1981.

[Sci82] E. Sciore. A complete axiomatization of full join dependencies. J. ACM, 29:373–393, 1982.

[Sci83] E. Sciore. Inclusion dependencies and the universal instance. In Proc. ACM Symp. on Principles of Database Systems, pages 48–57, 1983.

[Sci86] E. Sciore. Comparing the universal instance and relational data models. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing Research, vol. 3: The Theory of Databases, pages 139–163. JAI Press, Inc., Greenwich, CT, 1986.

[SDPF81] Y. Sagiv, C. Delobel, D. S. Parker, Jr., and R. Fagin. An equivalence between relational database dependencies and a fragment of propositional logic. J. ACM, 28:435–453, 1981.

[Sek89] H. Seki. On the power of Alexander templates. In Proc. ACM Symp. on Principles of Database Systems, pages 150–159, 1989.

652
Bibliography
[SF78] K. C. Sevcik and A. L. Furtado. Complete and compatible sets of update operations. In Intl.

Conf. on Management of Data (ICMOD), Milan, Italy, 1978.

[SG85] D. E. Smith and M. R. Genesereth. Ordering conjunctive queries. Artificial Intelligence, 26:171–215, 1985.

[She88] J. Shepherdson. Negation in logic programming. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 19–88. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Shi81] D. Shipman. The functional data model and the data language daplex. ACM Trans. on Database Systems, 6:140–173, 1981.

[Shm87] O. Shmueli. Decidability and expressiveness aspects of logic queries. In Proc. ACM Symp.

on Principles of Database Systems, pages 237–249, 1987.

[SI88] H. Seki and H. Itoh. A query evaluation method for stratified programs under the extended CWA. In Proc. Fifth Intl. Symp. on Logic Programming, pages 195–211, 1988.

[SI84] O. Shmueli and A. Itai. Maintenance of views. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 240–255, 84.

[Sic76] S. Sickel. A search technique for clause interconnectivity graphs. IEEE Trans. on Computers, C-25:72–80, 1976.

[Sie88] J. H. Siekmann. Unification theory. J. Symbolic Computation, 7:207–274, 1988.

[SJGP90] M. Stonebraker, A. Jhingran, J. Goh, and S. Potamianos. On rules, procedures, caching and views in data base systems. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 281–290, 1990.

[SKdM92] E. Simon, J. Kiernan, and C. de Maindreville. Implementing high level active rules on top of a relational dbms. In Proc. of Intl. Conf. on Very Large Data Bases, pages 315–326, 1992.

[SL90] A. P. Sheth and J. A. Larson. Federated database systems for managing distributed, heterogeneous, and autonomous databases. ACM Computing Surveys, 22:184–236, 1990.

[SL91] J. Seib and G. Lausen. Parallelizing datalog programs by generalized pivoting. In Proc.

ACM Symp. on Principles of Database Systems, pages 78–87, 1991.

[SLRD93] W. Sun, Y. Ling, N. Rishe, and Y. Deng. An instant and accurate size estimation method for joins and selection in a retrieval-intensive environment. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 79–88, 1993.

[SM81] A. M. Silva and M. A. Melkanoff. A method for helping discover the dependencies of a relation. In Advances in Data Base Theory, ed. by H. Gallaire, J. Minker, and J. -M. Nicolas, pages 115–133. Plenum Press, New York, 1981.

[Sno90] R. Snodgrass. Temporal databases: status and research directions. ACM SIGMOD Record, 19(4):83–89, December 1990.

[Soo91] M. Soo. Bibliography on temporal databases. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 14–23, 1991.

[SP94] D. Suciu and J. Paredaens. Any algorithm in the complex object algebra with powerset needs exponential space to compute transitive closure. In Proc. ACM Symp. on Principles of Database Systems, pages 171–179, 1994.

[SR86] M. Stonebraker and L. Rowe. The design of Postgres. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 340–355, 1986.

[SR93] S. Sudarshan and R. Ramakrishnan. Optimizations of Bottom-up evaluation with nonground terms. In Proc. of Intl. Logic Programming Symp, 1993.

Bibliography
653
[SS86] Y. Sagiv and O. Shmueli. The equivalence of solving queries and producing tree projections.

In Proc. ACM Symp. on Principles of Database Systems, pages 160–172, 1986.

[Sto81] M. Stonebraker. Operating system support for database management. Comm. of the ACM, 24:412–418, 1981.

[Sto88] M. Stonebraker, editor. Readings in Database Systems. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[Sto92] M. Stonebraker. The integration of rule systems and database systems. IEEE Transactions on Knowledge and Data Engineering, 4:415–423, 1992.

[Str91] B. Stroustrup. The C++ Programming Language, 2d ed. Addison-Wesley, Reading, MA, 1991.

[SU82] U. F. Sadri and J. D. Ullman. Template dependencies: A large class of dependencies in relational database and their complete axiomatization. J. ACM, 29(2):363–372, 1982.

[Su92] J. Su. Dynamic constraints and object migration. Technical Report TRCS-9202, Computer Science Department, University of California, Santa Barbara, 1992. To appear, Theoretical Computer Science; see also Proc. of Intl. Conf. on Very Large Data Bases, 1991.

[SV89] Y. Sagiv and M. Y. Vardi. Safety of datalog queries over infinite databases. In Proc. ACM
Symp. on Principles of Database Systems, pages 160–172, 1989.

[SW82] Y. Sagiv and S. Walecka. Subset dependencies and a completeness result for a subclass of embedded multivalued dependencies. J. ACM, 29(1):103–117, 1982.

[SWKH76] M. Stonebraker, E. Wong, P. Kreps, and G. Held. The design and implementation of Ingres. ACM Trans. on Database Systems, 1(3):189–222, 1976.

[SY80] Y. Sagiv and M. Yannakakis. Equivalence among expressions with the union and difference operators. J. ACM, 27(4):633–655, 1980.

[SZ86] D. Saccà and C. Zaniolo. On the implementation of a simple class of logic queries for databases. In Proc. ACM Symp. on Principles of Database Systems, pages 16–23, 1986.

[SZ88] D. Saccà and C. Zaniolo. The generalized counting method for recursive logic queries.

Theoretical Computer Science, 62:187–220, 1988.

[SZ89] L. A. Stein and S. B. Zdonik. Clovers: The dynamic behavior of type and instances.

Technical Report CS-89-42, Computer Science Department, Brown University, 1989.

[SZ90] D. Saccà and C. Zaniolo. Stable models and non-determinism in logic programs with negation. In Proc. ACM Symp. on Principles of Database Systems, pages 205–217, 1990.

[Tan88] L. Tanca. Optimization of Recursive Logic Queries to Relational Databases. Ph.D. thesis, Politecnico di Milano and Universita’ di Napoli, 1988.

[Tar55] A. Tarski. A lattice theoretical fixpoint theorem and its applications. Pacific J. Math, 5(2):285–309, 1955.

[TCG+93] A. U. Tansel, J. Clifford, S. Gadia, S. Jajodia, A. Segev, and R. Snodgrass. Temporal Databases – Theory, Design, and Implementation. Benjamin/Cummings Publishing Co., Menlo Park, CA, 1993.

[TF82] D. -M. Tsou and P. C. Fischer. Decomposition of a relation scheme into Boyce-Codd normal form. SIGACT News, 14(3):23–29, 1982.

[TF86] S. J. Thomas and P. C. Fischer. Nested relational structures. In P. C. Kanellakis and F. Preparata, editors, Advances in Computing Research, vol. 3, pages 269–307. JAI Press, Inc., Greenwich, CT, 1986.

[Tha91] B. Thalheim. Dependencies in Relational Databases. Teubner Verlagsgesellschaft, Stuttgart and Leipzig, 1991.

654
Bibliography
[TK84] V. A. Talanov and V. V. Knyazev. The asymptotic truth value of infinite formulas. In All-union seminar on discrete mathematics and its applications, pages 56–61, 1984.

[TL82] D. C. Tsichritzis and F. H. Lochovsky. Data Models. Prentice-Hall, Englewood Cliffs, NJ, 1982.

[Tod77] S. Todd. Automatic constraint maintenance and updating defined relations. In B. Gilchrist, editor, Proc. IFIP 77, pages 145–148. North Holland, Amsterdam, 1977.

[Top87] R. Topor. Domain independent formulas and databases. Theoretical Computer Science, 52(3):281–307, 1987.

[Top91] R. Topor. Safe database queries with arithmetic relations. Technical Report, Computer Science Department, University of Melbourne, 1991. Abstract appears as Safe Database Queries with Arithmetic Relations, Proc. 14th Australian Computer Science Conf., Sydney, 1991, pp. 1–13.

[TS88] R. W. Topor and E. A. Sonenberg. On domain independent databases. In J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 217–240. Morgan Kaufmann, Inc., Los Altos, CA, 1988.

[TT52] A. Tarski and F. B. Thompson. Some general properties of cylindric algebras. Bulletin of the AMS, 58:65, 1952.

[TY84] R. E. Tarjan and M. Yannakakis. Simple linear-time algorithms to test chordality of graphs, test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs. SIAM J. on Computing, 13(3):566–579, 1984.

[TYF86] T. J. Teorey, D. Yand, and J. P. Fry. A logical design methodology for relational databases using the extended entity-relationship model. In ACM Computing Surveys, pages 197–222, 1986.

[UG88] J. D. Ullman and A. Van Gelder. Parallel complexity of logical query programs.

Algorithmica, 3(1):5–42, 1988.

[Ull82a] J. D. Ullman. The U.R. strikes back. In Proc. ACM Symp. on Principles of Database Systems, pages 10–22, 1982.

[Ull82b] J. D. Ullman. Principles of Database Systems, 2d ed. Computer Science Press, Rockville, MD, 1982.

[Ull85] J. D. Ullman. Implementation of logical query languages for databases. ACM Trans. on Database Systems, 10(3):289–321, 1985.

[Ull88] J. D. Ullman. Principles of Database and Knowledge Base Systems, vol. I. Computer Science Press, Rockville, MD, 1988.

[Ull89a] J. D. Ullman. Bottom-up beats top-down for datalog. In Proc. ACM Symp. on Principles of Database Systems, pages 140–149, 1989.

[Ull89b] J. D. Ullman. Principles of Database and Knowledge Base Systems, vol. II: The New Technologies. Computer Science Press, Rockville, MD, 1989.

[Van86] A. Van Gelder. A message passing framework for logical query evaluation. In Proc. ACM
SIGMOD Symp. on the Management of Data, pages 155–165, 1986.

[VandB93] J. Van den Bussche. Formal Aspects of Object Identity. Ph.D. thesis, University of Antwerp, 1993.

[VandBG92] J. Van den Bussche and D. Van Gucht. Semi-determinism. In Proc. ACM Symp. on Principles of Database Systems, pages 191–201, 1992. (Full version to appear in Journal of Computer and System Sciences. )
[VandBGAG92] J. Van den Bussche, D. Van Gucht, M. Andries, and M. Gyssens. On the
Bibliography
655
completeness of object-creating query languages. In IEEE Conf. on Foundations of Computer Science, pages 372–379, 1992.

[VandBP95] J. Van den Bussche and J. Paredaens. The expressive power of complex values in object-based data models. In Information and Computation, 120:220–236, August, 1995.

[VanG86] A. Van Gelder. Negation as failure using tight derivations for general logic programs. In IEEE Symp. on Logic Programming, pages 127–139, 1986.

[VanG89] A. Van Gelder. The alternating fixpoint of logic programs with negation. In Proc. ACM
Symp. on Principles of Database Systems, pages 1–11, 1989.

[VanGRS88] A. Van Gelder, K. A. Ross, and J. S. Schlipf. The well-founded semantics for general logic programs. In Proc. ACM Symp. on Principles of Database Systems, pages 221–230, 1988.

[VanGRS91] A. Van Gelder, K. A. Ross, and J. S. Schlipf. The well-founded semantics for general logic programs. J. ACM, 38:620–650, 1991.

[VanGT91] A. Van Gelder and R. Topor. Safety and translation of relational calculus queries. ACM
Trans. on Database Systems, 16:235–278, 1991.

[Var81] M. Y. Vardi. The decision problem for database dependencies. Inf. Proc. Letters, 12(5):251–
254, 1981.

[Var82a] M. Y. Vardi. The complexity of relational query languages. In Proc. ACM SIGACT Symp.

on the Theory of Computing, pages 137–146, 1982.

[Var82b] M. Y. Vardi. On decomposition of relational databases. In IEEE Conf. on Foundations of Computer Science, pages 176–185, 1982.

[Var83] M. Y. Vardi. Inferring multivalued dependencies from functional and join dependencies.

Acta Informatica, 19:305–324, 1983.

[Var84] M. Y. Vardi. The implication and finite implication problems for typed template dependencies. Journal of Computer and System Sciences, 28:3–28, 1984.

[Var85] M. Y. Vardi. Querying logical databases. In Proc. ACM Symp. on Principles of Database Systems, pages 57–65, 1985.

[Var86a] M. Y. Vardi. On the integrity of databases with incomplete information. In Proc. ACM
Symp. on Principles of Database Systems, pages 252–266, 1986.

[Var86b] M. Y. Vardi. Querying Logical Databases. J. Computer and Systems Sciences, 33, pages 142–160, 1986.

[Var87] M. Y. Vardi. Fundamentals of dependency theory. In E. Borger, editor, Trends in Theoretical Computer Science, pages 171–224. Computer Science Press, Rockville, MD, 1987.

[Var88] M. Y. Vardi. Decidability and undecidablity results for boundedness of linear recursive queries. In Proc. ACM Symp. on Principles of Database Systems, pages 341–351, 1988.

[Vas79] Y. Vassiliou. Null values in database management, A denotational semantics approach. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 162–169, 1979.

[Vas80] Y. Vassiliou. A Formal Treatment of Imperfect Information in Data Management. Ph.D.

thesis, University of Toronto, 1980.

[VBKL89] L. Vieille, P. Bayer, V. Kuchenoff, and A. Lefebvre. Eks-v1: A short overview. In Proc.

ACM SIGMOD Symp. on the Management of Data, 1989. Technical exhibition.

[vEK76] M. H. van Emden and R. A. Kowalski. The semantics of predicate logic as a programming language. J. ACM, 23(4):733–742, 1976.

[Ver89] J. Verso. Verso: a database machine based on non-1nf relations. In H. Schek, S. Abiteboul, P. Fisher, editors, Nested Relations and Complex Objects, LNCS, page 361. Springer-Verlag, Berlin, 1989.

656
Bibliography
[Via87] V. Vianu. Dynamic functional dependencies and database aging. J. ACM, 34(1):28–59, 1987.

[Via88] V. Vianu. Database survivability under dynamic constraints. Acta Informatica, 25:55–84, 1988.

[Vie86] L. Vieille. Recursive axioms in deductive databases: The Query/Subquery approach. In L. Kerschberg, editor, Proc. First Intl. Conf. on Expert Database Systems, pages 179–193, 1986.

[Vie87a] L. Vieille. A database-complete proof procedure based on sld-resolution. In Proc. of the Fourth Intl. Conf. on Logic Programming, pages 74–103, 1987.

[Vie87b] L. Vieille. Recursion in deductive databases: DedGin, a recursive query evaluator. In Des Bases de Données aux Bases de Connaissances, Sophia-Antipolis, France, 1987. Also available as Technical Report TR-KB-14, ECRC, Munich.

[Vie88] L. Vieille. From QSQ towards QaSSaQ: Global optimization of recursive queries. In L. Kerschberg, editor, Proc. Second Intl. Conf. on Expert Database Systems, pages 421–436, 1988.

[Vie89] L. Vieille. Recursive query processing: The power of logic. Theoretical Computer Science, 69:1–53, 1989.

[Vos91] G. Vossen. Data Models, Database Languages and Database Management Systems.

Addison-Wesley, Wokingham, England, 1991.

[VV92] V. Vianu and G. Vossen. Conceptual-level concurrency control for relational update transactions. Theoretical Computer Science, 95:1–42, 1992.

[WF90] J. Widom and S. J. Finkelstein. Set-oriented production rules in relational database systems.

In Proc. ACM SIGMOD Symp. on the Management of Data, pages 259–264, 1990.

[WH92] Y. -W. Wang and E. N. Hanson. A performance comparison of the Rete and TREAT
algorithms for testing database rule conditions. In IEEE Conf. on Data Engineering, pages 88–
97, 1992.

[WHW90] S. Widjojo, R. Hull, and D. S. Wile. A specificational approach to merging persistent object bases. In A. Dearle, G. Shaw, and S. Zdonik, editors, Implementing Persistent Object Bases: Proc. of Fourth Intl. Workshop on Persistent Object Systems, pages 267–278. Morgan Kaufmann, Inc., Los Altos, CA, 1990.

[Wie92] G. Wiederhold. Mediators in the architecture of future information systems. IEEE
Computer, 25(3):38–49, March 1992.

[Win86] M. Winslett. A model-theoretic approach to updating logical databases. In Proc. ACM
Symp. on Principles of Database Systems, pages 224–234, 1986.

[Win88] M. Winslett. A framework for comparison of update semantics. In Proc. ACM Symp. on Principles of Database Systems, pages 315–324, 1988.

[WO90] O. Wolfson and A. Ozeri. A new paradigm for parallel and distributed rule-processing. In Proc. ACM SIGMOD Symp. on the Management of Data, pages 133–142, 1990.

[Won93] L. Wong. Normal forms and conservative properties for query languages over collection types. In Proc. ACM Symp. on Principles of Database Systems, pages 26–36, 1993.

[WS88] O. Wolfson and A. Silberschatz. Distributed processing of logic programming. In Proc.

ACM SIGMOD Symp. on the Management of Data, pages 329–336, 1988.

[WW75] C. P. Wang and H. H. Wedekind. Segment synthesis in logical data base design. IBM J.

Res. and Develop. , 19:71–77, 1975.

Bibliography
657
[WY76] E. Wong and K. Youssefi. Decomposition—A strategy for query processing. ACM Trans.

on Database Systems, 1(3):223–241, 1976.

[Yan81] M. Yannakakis. Algorithms for acyclic database schemes. In Proc. of Intl. Conf. on Very Large Data Bases, pages 82–94, 1981.

[YC84] C. T. Yu and C. C. Chang. Distributed query processing. ACM Computing Surveys, 16, 1984.

[YO79] C. T. Yu and M. Z. Özsoyo˘glu. An algorithm for tree-query membership of a distributed query. In Proc. IEEE COMPSAC, pages 306–312, 1979.

[YP82] M. Yannakakis and C. Papadimitriou. Algebraic dependencies. Journal of Computer and System Sciences, 25(2):3–41, 1982.

[Zan76] C. Zaniolo. Analysis and Design of Relational Schemata for Database Systems. Ph.D.

thesis, University of California at Los Angeles, 1976. Technical Report UCLA-Eng-7669, Department of Computer Science.

[Zan82] C. Zaniolo. A new normal form for the design of relational database schemata. ACM Trans.

on Database Systems, 7:489–499, 1982.

[Zan84] C. Zaniolo. Database relations with null values. Journal of Computer and System Sciences, 28(1):142–166, 1984.

[Zan87] C. Zaniolo, editor. IEEE Data Engineering 10(4), 1987. Special issue on databases and logic.

[ZH90] Y. Zhou and M. Hsu. A theory for rule triggering systems. In Intl. Conf. on Extending Data Base Technology, pages 407–421, 1990.

[Zlo77] M. Zloof. Query-by-example: A data base language. IBM Systems Journal, 16:324–343, 1977.

[ZM90] S. B. Zdonik and D. Maier, editors. Readings in Object-Oriented Database Systems.

Morgan Kaufmann, Inc., Los Altos, CA, 1990.

Index
Page numbers in italics indicate the location of definitions of terms.

ac0, 96, 431
adom, 41, 46, 77, 249
Access, 36, 143, 150, 152–153, 155
adorned rule, 318, 321
access plan, 107
adornment, 317, 318
active database, 8, 600–606
A-egd, 218
action, 601
aggregate function, 91–93
composite event, 606
aggregate operator, 97, 153, 154
condition, 601
in query language, 155
coupling mode, 603
AGM postulates, 599
ECA, 601
agreement set, 188
event, 601
Alexander method, 336
execution model, 601, 603–606
ALGcv, 514
accumulating model, 604–606
ALGcv−, 519
concurrent firing, 603
algebra
deferred firing, 603, 604
complex value, 514, 519
immediate firing, 603–604
conjunctive, 52–61
rule, 601
cylindric, 96, 103
rule base, 601
named conjunctive, 56–59, 57
vs. expert system, 600
nested relation, 519
active domain, 41, 46, 249
relational, 28, 35, 36, 64, 70, 71,
interpretation, 79
81
preservation, 249
named, 71
active domain semantics
unnamed, 71
of relational calculus, 74, 79
translation into calculus, 80
vs. domain independence, 79
SPC, 52–56, 54
acyclic
SPCU, 62, 222
vs. dependencies, 137
SPJR, 56–59, 57
distributed databases, 136
SPJRU, 62
hypergraph, 36, 132
SPJU, 492
inclusion dependencies, 208–210, 211
typed restricted SPJ, 64, 67
join, 105, 126, 128–135, 136
unnamed conjunctive, 52–56, 52
join dependency, 169, 182–183, 186
unsorted, 103
and mvd’s, 182
algebraic dependency, 228–233
661
662
Index
algebraic dependency (continued)
for full typed dependencies, 227–228
axiomatization, 231
Gentzen-style for jd’s, 186
ALGRES, 337
IDM transaction for, 581
allowed calculus query, 97, 101–102
for inds, 193–195, 211
alternating fixpoint, 390, 413
k-ary, 202, 204
ancestor program, 63
proof using, 167
nonlinear version, 314
provable using, 167
anomaly
sound, 167
deletion, 162, 254
for typed embedded dependencies, 226, 235
insertion, 162
for uinds, 210, 215
modification, 162
for uinds and fds, 210
update, 162
vs. fds and inds, 192, 202–207, 211
anonymous variable, 39, 44
vs. fds and sort set dependencies, 213
ans, 40
vs. finite implication, 226
ans _Rγ , 321
vs. jd’s, 169, 171, 186
anti-symmetric, 11
any, 548
AP5, 605, 615
B(P , I), 280
APEX, 335
B(PI), 387
arithmetic in query language, 153, 154
B-tree, 107
arity(·), 31
bag, 92, 136
of instance, 32
in SQL, 145, 155
of relation name, 31
BCNF, 250, 251– 252
of tuple, 32
algorithm, 255
Armstrong relation, 168–169, 186, 232
belief revision, 588, 599
for typed dependencies, 233
Berge-acyclic, 131, 137
Armstrong’s axioms for fd’s, 186
Bernays-Schönfinkel class, 219
articulation set, 132
Binary Data Model, 264
artificial intelligence (AI), 97
binary relation, 10
atom, 22, 33
body of rule, 39, 41, 276
constraint, 112
bottom-up datalog evaluation, 324–335
equality, 217
vs. top-down, 311, 327, 336
ground, 34
bound coordinate in datalog evaluation, 318
relation, 112, 217
bound variable occurrence, 23, 45, 75
att, 30
boundedness, 285, 304
attribute, 29
Boyce-Codd normal form (BCNF), 250, 251–252,
in relational model, 30
BP-completeness, 428, 560
in semantic data model, 243
buffering of main memory, 106, 107
attribute renaming, 58
autoepistemic logic, 408
automorphism, 12, 420, 426–428, 461
C-genericity, 419–420
average in SQL, 91, 154
C+SQL, 466
awk, 155
c-table, 493
axiom, 24
and dependencies, 501
vs. inference rule, 167
update, 593–594
axiomatizable, 167
CALC adom, 79, 80, 100
axiomatization, 167, 226
CALCdi, 79, 80
abstract formulation, 203
CALCsr, 81, 86, 100
for algebraic dependencies, 231, 235
CALC+µ, 348–352, 349
complete, 167
normal form, 368
for fd’s, 166, 168, 186
simultaneous induction, 351
for fd’s and mvd’s, 172–173, 186
CALC+µ+, 352–354, 353
finite, 202
normal form, 368
Index
663
CALC+µ(+) + W , 456
well formed, 549
CALC adom, 79
classification, 572, 575
CALCdi, 79
clause, 288
CALCsr, 85
Closed World Assumption (CWA), 27, 283, 489,
CALCcv, 519
497, 599
CALCcv−, 528
clustering, 107
calculus
CNF, 83
complex value, 519, 523
co-r.e., 16
conjunctive, 44–47, 45
Codd, 64
domain, 39, 74
Codd-table
for OODBs, 557
query, 488
positive existential, 68, 91
update, 593–594
relational, 28, 35, 36, 39, 64, 70, 73–91
COL, 538
tuple, 39, 74, 101
compactness theorem, 25
calculus formula, 74–75
complement of views, 591–593
parse tree, 83
complement operator, 103, 104
Cartesian product, 52
complete axiomatization, 167
chain program, 303
complete lattice, 286
chase(T , t, ), 176
completeness, 18
chase, 43, 159, 163, 173–185, 186, 220, 263, 497
object-oriented language, 560–561, 560, 574
Church-Rosser, 183–185
of a query language, 466
complexity, 176, 190
relational, 96, 147, 150, 151
fd rule, 175
update language, 583
generalized to embedded dependencies, 223–225
of whileN , 468
generalized to full dependencies, 220
of while new, 470–473
incomplete database, 498
of while uty, 478
ind rule, 208
completion in Query-Subquery (QSQ), 318
and ind’s, 208
completion of program, 407
jd rule, 175
complex constant, 517
and logical implication, 180–182, 186
complex value, 508–541, 542, 543, 545
query optimization, 163, 177–180
algebra, 514, 519
and tableau minimization, 177–180
calculus, 519, 523
of tableau queries, 173, 186
datalog, 532, 533
tgd-rule, 223
elementary query, 534
uniquely determined, 176
Equivalence Theorem, 526–531
vs. datalog, 186
fixpoint, 531–532
vs. resolution and paramodulation, 186
instance, 512
chase homomorphism, 184
relation, 512
chasing sequence, 175
safe-range, 528
infinite, 208, 223, 225
schema, 512
terminal, 175
semantic data model, 243
vs. dependency satisfaction, 175
sort, 511
choice operator, 458
strongly-safe-range, 530
Church-Rosser property, 175, 176
term, 519
chase, 183–185
complex value model, 97, 548
CINEMA example, 31
complexity, 13–20
circumscription vs. fixpoint operators, 354
data vs. expression, 122
Clark’s completion. See datalog¬, negation as
of query languages, 136
failure.

composition of tableaux, 226–227
class, 543, 545, 547
composition of queries, 37, 48–52
in semantic data model, 243
conjunctive queries, 64
class extension, 556
conjunctive queries with union, 64
class hierarchy, 549
conjunctive query program, 49
664
Index
composition of queries (continued)
with union, 36, 37, 38, 61–64
functional paradigm, 50
unnamed algebra, 52–56, 52
imperative paradigm, 50
vs. expert systems, 135
relational algebra queries, 71
yes-no, 42
and user views, 51–52
connectivity query, not first-order, 436, 460
computability, 13–20
conseq P , 389
condensation, 136
consistent
condition box in QBE, 150
globally, 128, 136
conditional table. See c-table.

pairwise, 128, 136
conjunction, 44
constant in relational model, 30
flatten, 83
constraint, 186
and negation, 74
inequalities over rationals, 96, 98
polyadic, 46
integrity, 28, 185, 236
conjunctive calculus, 64
vs. dependency, 157
with disjunction, 91
polynomial inequalities, 96
with equality, 48
temporal, 611–613
equivalence of formulas, 46
transition, 612
normal form, 46–47
vs. first-order logic, 186, 234
rewrite rule, 46
constraint atom, 112
semantics, 45
constraint database, 36, 71, 94–96, 97–98
with union, 81
constraint programming, 97
conjunctive normal form (CNF), 21, 83
constraint query language, 94–96, 97–98
conjunctive query, 36, 37–64
containment
algebraic, 52–61
conjunctive queries, 105, 118
with arithmetic, 105
decidability, 117
calculus, 44–47, 45, 64
differences of SPCU queries, 140
normal form, 46–47
first-order queries
composition, 48–52, 50
undecidability, 125
containment, 105
queries, 115
complexity, 121–122
tableau queries, complexity of, 121–122
and decidability, 36, 37, 117, 118
containment of queries
with disjunction, 61–64
relative to dependencies, 175, 177
equality, 47–48, 50
relative to family of instances, 174
equivalence, 47, 82, 105
context-free grammar, 19
Equivalence Theorem, 60
context-free language, 20
evaluation, 56
continuous operator, 286
Homomorphism Theorem, 105, 115–118, 117,
conventional perspective on relations, 32, 33
127, 136
CORAL, 337
logic-based perspectives, 40–48
cost model for query evaluation, 106, 108–110
and Microsoft Access, 152
count, 91, 92, 154
monotonic, 42
counter machine, 15
named algebra, 56–59, 57
counting vs. relational calculus, 154
optimization, 36, 56, 105
counting technique, 327, 331–335, 336, 341
in practical systems, 105–115
covariance, 553
using chase, 163
cover, 254
using dependencies, 163
minimal, 257
program, 49
create in SQL, 145
range restricted, with equality, 41, 48, 65
cross product, 52, 54
rule-based, 39, 40–42, 41
physical implementation, 108
satisfiable, 42
in SQL, 144
and SQL, 143–146
vs. equi-join, 108
static analysis, 105, 115–122
vs. join, 58
tableau, 43–44, 43
cumulative assignment, 346
Index
665
CWA. See Closed World Assumption.

adorned rule, 318, 321
cylindric algebra
adornment, 318
vs. relational algebra, 96, 103
Alexander method, 336
algebraic approaches, 336
annotated QSQ, 330
dangling reference, 999, 572
APEX, 335
data complexity, 122, 422–423
bottom-up, 312–316, 324–335
data definition language (DDL), 4, 28
bound coordinate, 318
data function, 306
connected atom, 338
data independence principle, 4, 9
counting, 327, 331–335, 336, 341
data integrity, 162
direct evaluation, vs. pre-compilation, 317
data manipulation language (DML), 4, 28
Earley Deduction, 335
data model. See database model.

extension tables, 335
data storage, 106
factoring, 337
database access functional paradigm, 571
free coordinate, 318
database instance, 29
generalizations to logic programming, 336
conventional perspective, 32
generalized supplementary magic set rewriting,
logic-programming perspective, 32
325, 336
database logic, 97
incremental, 337
database management system, 3
Iterative Query-Subquery (QSQI), 339
database model, 4, 7, 28
left-to-right, 318
complex value, 508–541
magic set rewriting, vs. QSQ, 311, 324–335,
directory, 97
336, 340
Entity-Relationship (ER), 242
memo-ing, 335
functional, 574
naive, 312
Functional Data Model, 264
original magic set rewriting, 340
generic semantic model (GSM), 242
parallel, 337
hierarchy, 28, 97
pre-compilation, vs. direct evaluation, 317
IFO, 242
Query-Subquery (QSQ), 311, 317–324, 335,
Logical Data Model (LDM), 97
341
network, 28, 97
rectified subgoal, 328, 330–331, 336
object-oriented, 28; See object-oriented database.

Recursive Query-Subquery (QSQR), 323–324,
relational, 28–34
324
semantic, 28, 207, 242–250
relevant fact, 317
database schema, 29, 31
rule-goal graph, 335
with dependencies, 241, 251
seminaive, basic algorithm, improved
datalog, 39, 273–310
algorithm, 312–316, 335
bottom-up, 312–316, 324–335
sideways information passing, 318, 336,
vs. top-down, 311, 327, 336
340
boundedness, 285, 304, 309
sip graph, 340
vs. first-order, 306
SLD-AL, 335
chain program, 303, 305, 309
stratification, 337
clause, 288
supplementary relation, 319–320
definite, 288
top-down, 316–324
empty, 288
extensional database (ebb), 279
goal, 288
extensional relation, 277
ground, 288
extensional schema, 277
unit, 288
immediate consequence operator, 282, 375
complex value, 532, 533
intensional database (idb), 279
containment, 301–304
intensional relation, 277
uniform, 304, 305, 309
intensional schema, 277
and domain independence, 97
least fixpoint semantics, 276, 282–286
evaluation, 112, 311–337
Knaster-Tarski’s Theorem, 286
666
Index
datalog (continued)
syntax, 276
linear program, 305, 316
top-down vs. bottom-up, 311, 327, 336
linear rule, 316
and undecidability, 306, 308–311
magic set rewriting, 311, 324–335, 336
vs. logic programming, 35, 278, 298
generalized supplementary, 325, 336
datalog¬, 308, 309, 355–360, 357, 374–414
original, 340
default model semantics, 408
vs. QSQ, 324
inflationary semantics, 356
minimum model semantics, 275, 278–282
locally stratified, 411
Herbrand interpretation, 282
negation as failure, 406–408
Herbrand model, 282
Clark’s completion, 406
monadic programs, 305
finite failure, 406
negative literal, 288
SLDNF resolution, 406
nonrecursive
noninflationary semantics, 357
with negation, 70, 72–73
nonrecursive, 70, 72–73
normal form, 68
range-restricted, 372
nonrecursive (nr) program, 62
rule algebra, 359, 373
optimization, 36, 112, 311–337
semipositive program, 377
parallel evaluation, 337
on ordered databases, 406
positive literal, 288
vs. fixpoint, 405
precedence graph, 315
SLB-resolution, 400
program, 276
stable model semantics, 408, 413
proof tree, 286
vs. choice, 409
proof-theoretic semantics, 275, 286–300
stratified, 374
prototype systems, 337
stratified semantics, 377–385
query, 317
independence of stratification, 382
Query-Subquery (QSQ), 311, 317–324, 335
on infinite databases, 411
annotated, 330
on ordered databases, 406
completion, 318
precedence graph, 379
Iterative (QSQI), 339
SLS resolution, 409
Recursive (QSQR), 323–324
stratifiable program, 379
template, 319–320
stratification, 378
vs. magic set rewriting, 324
stratification mapping, 378
rule, 276
vs. Fermat’s Last Theorem, 411
body, 276
vs. fixpoint queries, 400
head, 276
supported model, 384, 411
instantiation, 277
tie-breaking semantics, 409
satisfiability, 300–301
update language, 582
semipositive, 379
valid model semantics, 409
sirup, 305, 309
well-founded, 374
SLD-resolution, 289–298
well-founded semantics, 385–397, 413
completeness, 297
3-stable model, 389
datalog¬, 400
3-valued instance, 387
derivation, 290
3-valued model, 387
most general unifier (mgu), 293
alternating fixpoint, 390, 408, 413
refutation, 290
global SLS-resolution, 409
resolvent, 289, 295
greatest unfounded set, 413
selection rule, 298
on ordered databases, 406
SLD-derivation, 295
total instance, 387
SLD-refutation, 295
total program, 395
soundness, 296
unfounded set, 413
unifier, 293
vs. default, 412
SLD-tree, 298, 317
vs. fixpoint queries, 400, 401
stratified evaluation, 337
vs. stable, 412
Index
667
datalog¬¬ , 483
general, 234
new
DB2, 155
generalized dependency constraints, 234
DBASE IV, 152, 155
generalized mutual, 234
dbms. 3
implication
DDL, 28; See data definition language.

in view, 221
decidability, 16
implication of, 160, 164, 193, 197
of implication for full dependencies, 220, 234
implicational (id), 233
declarative vs. procedural, 35, 53
implied, 234
decomposition, 162, 251–259, 252, 265–266
inclusion (ind), 161, 192–211, 193, 218, 250
dependency preserving, 254
acyclic, 207, 208–210, 211, 250
and functional dependency, 164, 171
key-based, 250, 260
and join dependency, 169–171
typed, 213
lossless join, 253
unary (uind), 210–211
mapping, 253
inference rule, 166, 172, 193, 227, 231
multi-way join, 106, 114–115
ground, 203
reconstruction mapping, 254
join (jd), 161, 169–173, 170, 218
vs. synthesis, 258, 265
key, 157, 163–169, 163, 267
DedGin, 337
logical implication of, 160, 164
deductive database, 8
finite, 197
disjunctive, 502
unrestricted, 197
deductive object-oriented database, 572, 574, 575
multivalued (mvd), 161, 169–173, 170, 186, 218
deductive temporal query language, 610
mutual, 233
deep equality, 557, 575
named vs. unnamed perspectives, 159
default logic, 408
order, 234
definite clause, 288
partition, 234
definite query, 97
projected join, 233
delete in SQL, 149
and query optimization, 163
deletion, 580
satisfaction, 160
implicit, 556
satisfaction by tableau, 175
deletion anomaly, 162, 254
satisfaction family, 174
dense linear order, 96, 98
and semantic data models, 249–253
dependency, 157
and schema design, 253–262
afunctional, 234
single-head vs. multi-head, 217
algebraic, 228–233
sort set, 191, 213, 234
axiomatization, 166, 171, 172, 186, 193, 202–207,
subset, 233
227, 231
tagged, 164, 221, 241
capturing semantics, 159–163
template, 233, 236
classification, 218
transitive, 234
conditional table, 497
trivial, 220
and data integrity, 162
tuple-generating (tgd), 217–228
and domain independence, 97
typed, 159
dynamic, 234
vs. untyped, 192, 217
embedded, 192, 217, 233
unirelational, 217
embedded implicational (eid), 233
and update anomalies, 162
embedded join (ejd), 218, 233
and views, 221, 222
embedded multivalued (emvd), 218, 220, 233
vs. first-order logic, 159, 234
equality-generating (egd), 217–228
vs. integrity constraint, 157
extended transitive, 234
vs. tableaux, 218, 234
faithful, 232, 233, 239
dependency basis, 172
finiteness, 306
dependency preserving decomposition, 254
full, 217
dependent class, 246
functional (fd), 28, 159, 163–169, 163, 186, 218,
dereferencing, 557, 558
250, 257, 260
derivation, 290
668
Index
derived data, 246
DOOD. See deductive object-oriented database.

determinate-completeness, 474, 561, 574
duplicate elimination, 107
determinate query, 474, 559
distinct, 107
diameter, 12
duplicate tuples, 144
diff, 88
dynamic aspect of object-oriented database, 572
difference, 33, 36, 68
dynamic binding, 543, 546, 552
in relational algebra, 71
dynamic choice operator, 464
and SPCU algebra, 136
Dynamic Logic Programming (DLP), 583, 613
in SQL, 146
vs. negation, 70
direct product, 232, 238
ear of hypergraph, 130
directory model, 97
Earley Deduction, 335
disjunction, 38
edb, 42, 49, 277
in conjunctive queries, 37, 38, 61, 64
edge of hypergraph, 130
flatten, 83
egd, 217–228
and negation, 74
A-egd, 218
in selection formulas, 62
Ehrenfeucht-Fraissé games, 433–437, 460
disjunctive deductive database, 502
eid, 233
disjunctive normal form (DNF), 21, 83
ejd, 218
disk, 106
EKS, 410
distinct in SQL, 107, 145, 154
elementary functions, 18
distributed database
elementary query, 534
query optimization, 128
embedded dependency, 192, 217
division in relational algebra, 99
embedded implicational dependency (eid), 233
DML, 4, 28
embedded join dependency (ejd), 218
DNF, 83
embedded multivalued dependency (emvd), 218,
dom, 30, 72
220, 233
Dom(·), 30
embedding of tableau, 43
domain
empty clause, 288
active, 46
emvd, 218, 220, 233
in relational model, 29, 30
enc α,, 418
scalar, 153
encapsulation, 543, 546, 553
time, 607
entity, 543
underlying, 74
Entity-Relationship (ER) model, 242, 264
domain calculus, 74
equality atom, 217
vs. tuple calculus, 39
equality-generating dependency (egd), 217–228
Domain Closure axiom, 26
A-egd, 218
domain independence, 70, 74, 75–77, 79, 81–97
equi-join, 55, 108
and algebra, 78
physical implementation, 107–108
complex value, 526
in SQL, 144
and datalog, 97
vs. natural join, 57
and dependencies, 97
equivalence
with functions, 97
algebraic, 106
and nr-datalog¬, 78
calculus formulas, 82
with order, 97
conjunctive calculus formulas, 46
practical query languages, 153
conjunctive queries, 47, 60, 64, 82, 105
relational calculus, 81
decidability, 118
syntactic restrictions, 81–91
conjunctive queries with union, 63
undecidability, 97, 125
differences of SPCU queries, 140
vs. active domain semantics, 79
finite and unrestricted implicaton for full
domain-inclusion semantics, 551
dependencies, 220, 234
domain-key normal form, 265
first-order languages, 36, 80, 96
dominance of query languages (⊑), 47
first-order queries, 74
Index
669
undecidability, 125
fd rule in chasing, 175
of full typed and algebraic dependencies, 231
fd-schema, 251
of hypergraph properties, 132
field, real closed, 97
nr-datalog¬ and relational algebras, 73
file systems, 3
queries, 37
filter, 518
relative to dependencies, 176, 177
finitary power set, 10
query languages, 47
finite interpretation, 26
relational algebras, 71
finite logical implication, 197–202, 219
SPC and SPJR algebras, 60
vs. unrestricted, 197
equivalence class, 10
finite model theory, 123, 197
equivalence relation, 10
finite representation of infinite database, 93–96, 97
Equivalence Theorem
finite-state automata, 13
conjunctive query languages, 60
finitely implies, 198
conjunctive query languages with union, 63
finiteness dependency, 306
first-order languages, 80
first normal form, 265
ER model, 242
first-order incremental definability, 588, 613
ESQL, 368, 370
first-order language, 70–98
evaluable query, 97
Equivalence Theorem, 80
evaluation
and undecidability, 122–126
of conjunctive queries, 56
vs. SQL, 147–149, 155
datalog, 112, 311–337
first-order logic, 22, 35
evaluation plan, 107, 108, 110, 135
vs. conjunctive queries, 40
generating, 110–111
vs. constraints, 234
parameterized, 135
vs. dependencies, 159, 234
exact cover problem, 121
vs. integrity constraints, 186
existential quantification, 44
vs. relational calculus, 77, 105, 123, 136
flatten, 83
first-order predicate calculus, 22, 35
vs. universal, 74
first-order queries, 70–98, 70
Exodus
and dependencies in views, 222
and optimization, 135
equivalence, 74
and query evaluation plans, 111
expressiveness, 433–437
expert system vs. conjunctive queries, 135
Ehrenfeucht-Fraissé games, 433–437, 460
expression complexity, 122, 422–423, 463
on ordered databases, 462
expressive power of object-oriented database, 569,
logspace complexity, 430–431
577
parallel complexity, 431–433
extended relational theory, 26
static analysis, 105, 122–126
extension axioms, 26
and undecidability, 105, 122–126
extension tables, 335
fixpoint
extensional database edb, 42, 49, 279
complex value, 531–532
extensional relation, 42, 48, 277
datalog, 276
incomplete database, 495
semantics of datalog¬, 390
F-logic, 574
fixpoint of an operator, 283
fact, 32
fixpoint queries, 342, 367
factoring, 337
on ordered databases, 447
faithful dependency, 232, 233, 239
ptime complexity, 437
vs. typed, 233
vs. while queries, 453
fd, 28, 159, 160, 163–169, 163, 186, 218. See
flatten, 524
functional dependency
FOID, 588
fd closure
format model, 539
algorithm, 165
formula, 22
of set of attributes, 165
conjunctive calculus, 45
of set of fd’s, 165
conjunctive normal form (CNF), 83
670
Index
formula (continued)
GP , 379
disjunctive normal form (DNF), 83
Galileo, 264
interpretable, 77
game-of-life, 343
matrix of, 82
garbage collection, 556
prenex normal form (PNF), 82
Gauss-Seidel algorithm, 335
relational calculus, 74–75
generalized instance, 95
4NF, 252, 252, 259
generalized SPC algebra, 55
fourth normal form (4NF), 252, 252, 259
generalized SPJR algebra, 59
Foxpro, 152
generalized tuple, 94, 95
FQL, 264
generic OODB model, 547–556
free(·), 45, 75
generic semantic model (GSM), 242–250
free coordinate
genericity, 103, 419–421, 419, 425
in datalog evaluation, 318
globally consistent join, 128, 136, 261
free tuple, 33
GLUE-NAIL, 337
free variable occurrence, 23, 45, 75
goal clause, 288
fsa. See finite-state automata.

Gödel Completeness Theorem, 123, 136
full dependency, 217
graph, 11
full reducer, 129, 136
graphical query language, 150–153
full tuple generating dependency, 218
Graphlog, 369, 370
full typed dependencies
ground, 22
axiomatization, 227–228
ground atom, 34
function-based perspective on tuples, 32
ground clause, 288
Functional Data Model, 264
ground inference rule, 203
functional dependency (fd), 28, 163–169, 163, 186,
group by in SQL, 154
218
grouping, 533
agreement set, 188
GSM, 242–250
axiomatization, 166–168
GYO algorithm, 130, 136
with mvd’s, 172–173
GYO reduction, 141
vs. ind’s, 192, 202–207, 211
and chasing, 175
closure, 165
hash index, 107
cover, 254
head of rule, 39, 41, 276
and decomposition, 162, 164, 171, 253–262, 255
Heraclitus, 614
dynamic, 615
Herbrand interpretations, 23
independent of ind’s, 250
Herbrand model
logical implication
datalog, 282
with ind’s, 192, 199–202
hierarchy model, 28, 97
linear time, 165
homomorphism, 12
satisfies, 163
of tableau queries, 117, 127, 136
saturated set, 188
Homomorphism Theorem, 37, 105, 115–118, 117,
and synthesis, 260–261
127, 136, 177, 178
and two-element instances, 189
Horn clause, 279
vs. decomposition, 164, 171
hyp, 18
vs. join dependency, 171, 178
hyperedge, 130
vs. multivalued dependency, 171
hypergraph, 130
vs. propositional logic, 186, 189
acyclic, 132
vs. semantic data model, 249–253
articulation set, 132
vs. unrestricted implication, 199
connected, 132
vs. propositional logic, 189
cyclic, 132
functional paradigm, 569
of database schema, 130
functional query language, 569
ear, 130
edge, 130
GYO algorithm, 130
Index
671
path, 132
implicational dependency (id), 233
reduced, 130
implies. See implication.

hyperplane, 438
finitely, 198
without restriction, 198
inclusion dependency (ind), 161, 192–211, 193, 218,
I1, I1/2, I0, 387
253
I∗, I∗, I∗, 391
acyclic, 208, 210, 211, 250
∗
idb, 42, 49, 277
vs. implication, 210
IDM transaction, 580–582, 613, 615–617
axiomatization, 193–195, 211
axiomatization, 581
vs. fd’s, 192, 202–207, 211
condition, 580
and chasing, 208
deletion, 615
independent of fd’s, 250
insertion, 615
key-based, 250, 260
modification, 615
logical implication, 192, 195–197
optimization, 581
with fd’s, 192, 199–202
parallelization, 616
repeats-permitted, 212
schedule, 616
restricted classes, 192
serializability, 616
satisfies, 193
simplification rules, 582
typed, 211
IDM transactional schema, 584, 613, 617
vs. referential integrity, 211
vs. constraints, 585–586
vs. semantic data model, 207
completeness, 617
vs. unrestricted implication, 199
soundness, 617
incomplete database, 487–507
vs. fd’s, 585
c-table, 493
vs. inclusion dependencies, 585, 617
update, 593–594
vs. jd’s, 617
complexity, 499
IFO, 242, 264
fixpoint, 495
ILOG, 576
logical theory, 594–600
image of calculus query, 78
and nondeterminism, 507
immediate consequence operator, 282
table, 488
imperative method, 564–566, 573
incomplete information
implementation
and update anomalies, 162
cross product, 108
incremental update. See first-order incremental
equi-join, 107–108
definability.

multi-way join, 111–115
ind, 161; See inclusion dependency.

physical, 106–108
ind-rule in chasing, 208
projection, 107
independent component, 265
relational algebra, 107–108
indexing, 106, 107
selection, 107
inequality atom
implication
in selections, 69
and chase, 180–182, 186
inequality in constraint databases, 96
closed under, 204
inference rule, 24, 158
closed under k-ary, 204
ground, 202, 203
of dependencies, 158, 160, 164, 195
schema, 202
in view, 221
substitution, 167
of fd’s and ind’s, 192
inference rules
finite, 197–199, 226
for fd’s and mvd’s, 172–173, 186
finite vs. unrestricted, 202, 219, 234
for functional dependency, 166–168, 186
of functional dependencies, 186
for inclusion dependency, 193–195
of ind’s, 192, 195–197
proof using, 167
for two-element instances, 189
provable using, 167
unrestricted, 197–199
for unary inds, 210, 215
vs. fd’s and ind’s, 199–202
vs. algorithm for testing implication, 166
672
Index
inference rules (continued)
IQL, 573
vs. axiom, 167
irreflexive, 11
infinitary logic, 458, 459, 462
ISA, 543, 545
infinite database, 97
semantic data model, 245
finite representation, 36, 93–96, 97
isomorphic tableau queries, 120
infinite tree, 575
isomorphism, 12
inflationary datalog¬, 356
OID, 555
inflationary fixpoint logic (CALC+µ+), 352,
iterate, 518
353–354
Iterative QSQ (QSQI), 339
inflationary fixpoint operator (µ+), 353
information capacity
relative, 265, 268–269
Jacobi algorithm, 335
INGRES, 34, 111, 155
jd, 161, 169–173, 218. See join dependency
distributed, 135
jd rule, in chasing, 175
query optimizer, 114–115, 127, 135, 137
join, 55,57
inheritance, 546, 552, 553, 567, 573–575, 577
acyclic, 105, 126, 128–135, 136
semantic data model, 245
algorithms for binary join, 135
input schema of query, 37
complex value, 517
insert in SQL, 149
decomposition, 106, 114
insertion, 580
equi-join, 55, 57, 108
insertion anomaly, 162
implementation, 111–115
instance
left-to-right evaluation, 112
complex value, 512
lossless, 164, 253
database, 29
multi-way, 106, 108, 135
conventional perspective, 32
natural, 56, 57, 169
logic-programming perspective, 32
vs. equi-join, 57
generalized, 95
pairwise consistent, 128, 136
GSM, 245
physical implementation, 107–108
object-oriented database, 554, 555
semi-join, 128, 135
relation
in SQL, 144
conventional perspective, 32
tuple substitution, 115, 135
logic-programming perspective, 32
vs. cross product, 58
relativized, 77
vs. intersection, 58
semantic data model, 245
vs. tableau, 64
unrestricted, 197
join decomposition, 114–115
instantiation, 277
join dependency (jd), 161, 169–173, 170, 218
integrity constraint, 6, 28, 157, 186
acyclic, 169, 182–183, 186
vs. first-order logic, 186, 234
and mvd’s, 182
intended model, 279
and chasing, 175
intensional database (id6), 42, 49, 279
complexity of implication, 169
intensional relation, 42, 48, 277
and decomposition, 169–171
interpretable formula, 77
embedded, 233
interpretation, 23
Gentzen-style axiomatization, 186
active domain, 79
n-ary, 170
natural, 78
projected, 233
relativized, 74, 77–78
satisfies, 170
unrestricted, 78
vs. axiomatization, 171, 186
intersection, 33
vs. functional dependency, 169, 171, 178
in relational algebra, 71
vs. multi-valued dependency, 170, 182
and SPC algebra, 55, 69
vs. natural join, 169
in SQL, 146
vs. SPJR algebra, 181
vs. join, 58
vs. unrestricted implication, 199
invented value, 469
Index
673
join detachment, 114, 135
of ind’s, 192, 195–197
join tree, 130, 136
of mvd’s,172–173
unrestricted, 197–199
logical level of three-level architecture, 106
k-ary axiomatization, 202, 204
logical theory and updates, 594
key, 257, 543
logspace complexity
attribute, 257
of first-order queries, 430–431
in semantic data model, 247
lossless join, 164, 253
key dependency, 163
Löwenheim-Skolem theorem, 25
simple, 267
vs. functional dependency, 161
key-based inclusion dependency, 250, 260
magic set rewriting, 311, 324–335
KL, 503
generalized supplementary, 325, 336
Knaster-Tarski’s Theorem, 286
original, 340
vs. QSQ, 324, 327
main-memory buffering, 106, 107
lambda-calculus, 574
many-sorted query language, 153–154
language (formal), 13–20
map, 540
late binding, 552
map filter, 518
LDL, 337, 409, 533, 538, 613
materizialized view, 51
update language, 583
mathematical logic, 20–27
left-to-right evaluation
matrix of formula, 82
datalog, 318
maximum in SQL, 154
join, 112
memo-ing, 335
linear bounded Turing machine, 196
message, 552
linear datalog, 305, 316
method, 543, 551
linear programming, 97
languages, 563–571
Lisp, 573
method resolution, 546, 552
literal, 21
method schema, 563, 566–571
in nr-datalog¬ rule, 72
monadic, 543, 563, 565, 567, 568, 577
local stratification, 411
polyadic, 567, 568, 577
logic. See mathematical logic.

mgu, 295
temporal, 612, 619
Microsoft Access, 36, 143, 150, 152–153, 155
three-valued, 389–391
minimal cover, 257
logic programming, 97
minimal tableau query, 118
constraints, 97
minimization of tableau queries, 105, 119, 136
object-oriented database, 572
minimum in SQL, 154
vs. datalog, 35
minimum model, 275
logic-programming perspective on relations, 32, 33
modal operator, 503
Logical Data Model (LDM), 97
model, 24
logical database, 503
database, 28
logical implication, 21
datalog, 279
and chase, 180–182, 186
relational, 28–34
closed under, 204
semantic data, 243, 245–253, 267
closed under k-ary, 204
modification, 580
of dependencies, 160, 164, 193
modification anomaly, 162
in view, 221
modified RANF, 88
of fd’s, 165, 186
modus ponens, 24
of fd’s and ind’s, 192
monadic datalog program, 305
finite, 197–199
monadic method schema, 543, 563, 565, 567, 568,
vs. unrestricted, 202, 219, 234
577
full dependencies
monoid, 199
complexity, 221
monotone operator, 283
674
Index
monotonic query, 42
negation, 36
monotonicity
in Microsoft Access, 153
and conjunctive queries, 42
pushing, 83
and relational algebra, 71, 98
in QBE, 150
most general unifier (mgu), 293
in selections, 68
multi-head dependency, 217
in SQL, 143
multi-way join
stratified, 49
decomposition, 114–115
vs. set difference, 70
detachment, 114, 135
Negation as Failure, 27, 406
implementation, 106, 108, 111–115, 135
negative literal, 288
left-to-right evaluation, 112
nest, 518
tuple substitution, 115, 135
nested loop implementation of join, 107, 108
multiset, 92, 136, 145
nested relation, 512
multivalued dependency (mvd), 161, 169–173, 170,
algebra, 519
186, 218
nested SQL query, 143, 146–147
and acyclic jd’s, 182
network model, 28, 97
axiomatization with fd’s, 172–173
new, 559
dependency basis, 172
NF2. See nested relation.

embedded, 218, 220, 233
no-information null, 502
original definition, 189
non-existing null, 502
satisfies, 170
nondeterminism, 15
and two-element instances, 189
semantics of negation, 409
vs. functional dependency, 171
nondeterministic query. See query, nondeterministic.

vs. join dependency, 170
noninflationary datalog¬, 357
vs. propositional logic, 189
nonrecursive (nr) datalog
mutual recursion, 315
with negation, 70, 72–73
mvd, See multivalued dependency.

program, 72
nonrecursive datalog program, 62
normal form, 158
N-datalog¬(¬), 463
Boyce-Codd (BCNF), 250, 251
N1NF. See nested relation.

decomposition algorithm, 255
NAIL!, 337, 409
conjunctive (CNF), 83
naive evaluation
conjunctive calculus, 46–47
of datalog, 312
disjunctive (DNF), 83
of SPC query, 109
domain-key, 265
naive table, 492
first, 265
named perspective, 31, 32
fourth (4NF), 252, 252, 259
and dependencies, 159
nr-datalog, 68
projection, 57
prenex (PNF), 82
relational algebra, 71
project-join (PJ/NF), 265, 267
selection, 57
relational algebra (RANF), 86, 97
SPJR algebra, 56–59, 57
relational schema, 251–259, 265
tuple, 32
safe-range (SRNF), 83
vs. unnamed perspective, 32
SPC algebra, 55
named value, 554, 556
SPCU algebra, 62
root of persistence, 556
SPJR algebra, 59
natural interpretation, 78
SPJRU algebra, 62
natural join, 56, 57, 169
third (3NF), 257
polyadic, 58
decomposition algorithm, 257
vs. equi-join, 57
synthesis algorithm, 257
vs. join dependency, 169
now, 607
natural semantics of relational calculus, 78, 79
np, 18
nc, 96, 431
np-complete, 105, 121, 122, 127
Index
675
np-hard, 121
dynamic binding, 543, 546, 552
npspace, 18
encapsulation, 543, 546, 553
nr-datalog, 62
expansion of value, 558
normal form, 68
formal definition, 547–555
nr-datalog¬, 70, 72–73
generic OODB model, 547–556
and domain independence, 78
ILDG, 580
with equality, 72, 73
imperative methods, 564–566, 573
equivalence to first-order languages, 80
expressive power, 565–566, 577
literal, 72
inheritance, 546, 552, 553, 567, 573–575, 577
program, 72
instance, 554, 555
query, 73
IQL, 573
range restricted, 72
ISA, 543, 545
with equality, 72
languages for methods, 563–571
rule, 72
late binding, 552
semantics, 72
logic programming, 572, 574
translation into SQL, 147–149
message, 552
and undecidability, 122–126
method, 551
NU-Prolog, 337
signature, 551
null value, 488
well formed, 553
method resolution, 546, 552
method schema, 563, 566–571
O2, 562, 573
expressive power, 569–571
O2SQL, 510, 536–537, 562
monadic, 543, 563, 565, 567, 568, 577
obj, 547
polyadic, 567, 568, 577
object, 246, 543, 545, 547, 573
named value, 554, 556
object creation, 573; See object-oriented database,
object, 543, 545, 547, 573
object creation.

object creation, 558–562, 573, 574
object equality, 557
object equality, 557
object history, 615
object identifier, 543, 545, 547
object identifier (OID), 473, 543, 545–547
object migration, 572
semantic data model, 243
OID assignment, 550
object migration, 572, 613, 615
OID isomorphism, 555, 560
object-oriented data model, 28, 245, 477, 546
overriding, 546
object-oriented database, 8, 242, 473, 542–578
parallelism, 573
calculus, 557–558
query semi-deterministic, 574
class, 545
query language, 556–563
class hierarchy, 549
querying schema, 572
well formed, 549
reachability, 565
classification, 572, 575
receiver, 552
completeness, 560–561, 560, 574
role, 571
complex value, 545
schema, 554
consistency, See, object-oriented database, type
schema design, 571
safety
specialization, 545
context-dependent binding, 552
static binding, 552
covariance, 553
subtyping relationship, 549
dangling reference, 999, 572
type, 548
dba mode, 546
disjoint interpretation, 550
deductive, 575
semantics, 550
deep equality, 557, 575
type safety, 563, 565, 567, 573
dereferencing, 557, 558, 559
user mode, 546
determinate query, 559
value, 547
domain-inclusion semantics, 551
value equality, 557
dynamic aspect, 572
value-dependent binding, 552
676
Index
object-oriented database (continued)
not in while, 437
view, 571
partial fixpoint logic (CALC+µ), 348, 349–352
object-oriented programming languages, 573
partial fixpoint operator (µ), 349
object-orienteddatabase
partial order, 11
consistency. See object-oriented database,type
partially ordered set, 11
safety.

path in hypergraph, 132
ODE, 615
PCP, 16
OID
and satisfiability of relational calculus, 123
-assignment, 550
permutation, 13
-equivalence, 246
physical implementation, 106–108
-isomorphism, 246, 560
cross product, 108
semantic data model, 243
equi-join, 107–108
OODB, 242; See object-oriented database.

projection, 107
Open World Assumption (OWA), 489, 497, 595
relational algebra, 107–108
operator
selection, 107
continuous, 286
physical level
monotone, 283
of three-level architecture, 106
OPS5, 369, 370
physical model of relational database, 106–107
optimization
PNF, 82
conjunctive queries, 36, 105
polyadic
using chase, 163
conjunction, 46, 75, 83
using dependencies, 163
disjunction, 75, 83
datalog, 36, 112, 311–337
existential quantification, 83
and Exodus, 135
natural join, 58
in practical systems, 105, 106–115
polyadic method schema, 567, 568, 577
relational algebra, 106
polynomial inequalities constraint, 96, 97
transaction, 581
positive existential calculus, 91, 97
using chase, 177–180
decidability, 99
or-sets, 505
positive literal, 288
ORACLE, 34, 155
positive selection formula, 67
ordered database, 397, 447
poss(T ), 490
output schema of query, 37
Post Correspondence Problem (PCP), 16
overriding, 546
and satisfiability of relational calculus, 123
OWA, 489, 497, 595
POSTGRES, 153, 600
powerset, 514
precedence graph
P (I), 280, 378, 383, 387
in datalog evaluation, 315
pg(P , I), 389
in datalog¬, 379
P wf , 390
negative edge, 380
page fetch, 107
positive edge, 380
page size, 106
predicate, 277
paging protocol, 106
prenex normal form (PNF), 82
pairwise consistent join, 128, 136
procedural vs. declarative, 35, 53
Paradox, 152, 155
product
parallel complexity
Cartesian, 52
classes of circuits, 431
cross, 52, 54, 58, 108, 144
of first-order queries, 431–433
direct, 235, 240
parameterized IDM transaction, 584
production rule system, 369
call, 584
program schema, 574
parametrized query, 522
project-join expression
paramodulation vs. chase, 186
extended, 229
parity query
project-join normal form (PJ/NF), 267
not first-order, 460
project-join query, flat, 126
Index
677
projection, 52
conjunctive, 36, 37–64
and aggregate functions, 93
conjunctive calculus, 44–47
named perspective, 57
containment relative to dependencies, 37, 177
physical implementation, 107
definite, 97
pushing, 109
determinate, 474
in SQL, 144
equivalence, 37
unnamed perspective, 54
relative to dependencies, 176, 177
proof, 24
first-order, 70
using inference rules, 167
genericity, 419–421, 419, 425
proof tree, 286
C-genericity, 419–420
propositional calculus, 21
input schema, 37
propositional logic, 21
with invented values, 469
vs. fd’s and mvd’s, 186, 189
monotonic, 42
pspace, 17
nondeterministic, 453–457
pspace complexity
CALC+µ(+) + W , 456
of while queries, 437
choice operator, 458
pspace-complete, 196
dynamic choice operator, 464
PI, 286
N-datalog¬(¬), 463
ptime, 17
while(+) + W , 454, 456
ptime complexity
witness operator, 454–456
of fixpoint queries, 437
nr-datalog¬, 73
pure universal relation assumption (URA), 126, 130,
optimization, 36, 105–115, 112, 313–339
242, 252
output schema, 37
pushing
parametrized, 522
negation, 83
project-join, flat, 126
projection, 109
relational calculus, 75
selection, 109, 335
satisfiable, 42
schema query, 572
semi-deterministic, 574
q adom, 79
statistical properties, 106
qd(·), 78
tableau, 43–44, 43
qnat(·), 78
union-of-tableaux, 139
qc, 422
untyped, 475
QL, 477
vs. implementation, 110
qptime, 406, 422
vs. query mapping, 37
QSQ, 311, 317–324, 335
vs. update, 28
annotated, 330
well-typedness, 417
completion, 318
yes-no, 42
Iterative (QSQI), 339
query composition, 37
Recursive (QSQR), 323–324
query decomposition, 114–115
algorithm, 324
query evaluation
template, 319–320
cost model, 106, 108–110
vs. magic set rewriting, 324, 327
naive, 109
QSQI, 339
in practical systems, 106–115
QSQR, 323–324
query evaluation plan, 107, 108, 110, 135
algorithm, 324
and Exodus, 111
Quel, 74, 112, 155
generating, 110–111
query, 421
parameterized, 135
complexity, 422–423
query language
data complexity, 422–423
aggregate operators, 153, 154, 155
expression complexity, 422–423, 463
with arithmetic, 153, 154
composition, 48–52, 71
associative, 35
computability, 417–421
BP-completeness, 428
678
Index
query language (continued)
query tree, 108–110, 108
completeness, 466
Query-By-Example (QBE), 36, 40, 43, 143,
completeness in a class, 424
150–152, 155
conjunctive queries, 36, 37–64
condition box, 150
with union, 36, 37, 38
and domain independence, 153
constraint, 94–98
and first-order languages, 151
declarative, 29, 558
negation, 150
vs. procedural, 35, 53
relationally complete, 151
determinate-completeness, 474
view definition, 151
disjunction, 37, 38
vs. tableau queries, 150
dominated by (⊑), 47
Query-Subquery (QSQ), 311, 317–324, 335
embedded, 466
annotated, 330
C+SQL, 466
completion, 318
whileN , 467
Iterative (QSQI), 339
equivalence (≡), 47
Recursive (QSQR), 323–324
expressive power, 106, 427
algorithm, 324
graphical, 150–153
template, 319–320
inflationary semantics, 342–344
vs. magic set rewriting, 324, 327
many-sorted, 153–154
navigational, 558
noninflationary semantics, 342–344
R[·], 31
object-oriented, 556–563
r.e.. See recursively enumerable.

practical, 143–155
Rado graph, 442, 461
relational algebra, 28, 35, 36
RANF, 86, 97
relational calculus, 28, 35, 36
algorithm, 88
set-at-a-time, 35
modified, 88
static analysis, 36, 105, 122–126, 306–311
range restricted
temporal, 606–613
algorithm, 84
three paradigms, 35–36
calculus query, 97
Query Management Facility (QMF), 155
calculus variable, 83, 84
query mapping vs. query, 37
conjunctive query, with equality, 41, 48
query optimization, 36, 105
formula, 102
cost model, 106, 108–110
nr-datalog¬, 72
distributed database, 128
with equality, 65, 72
evaluation plan, 107, 108, 110–111, 135
rule, 41
and Exodus, 111
range separable query, 97
in INGRES, 114–115
rank, 402
join detachment, 114, 135
RDL, 369, 370
local vs. global, 115, 117
real closed field, 96, 97
and negation, 106
receiver, 552
in practical systems, 106–115
reconstruction mapping, 254
program transformation, 108
rectangle, representation, 95
query rewriting, 108–110
rectified subgoal in datalog evaluation, 328,
query tree, 108–110, 108
330–331, 336
and relational calculus, 126
recursive (formal) language, 16
rewrite rule, 110
Recursive QSQ (QSQR), 323–324
and sampling, 111
algorithm, 324
in System R, 112–114
recursively enumerable, 16
by tableau minimization, 118–120
reduced hypergraph, 130
tuple substitution, 115, 135
redundancy and update anomalies, 162
using chase, 163, 177–180
referential integrity constraint vs. inclusion
using dependencies, 163
dependency, 161, 213
query rewriting, 108–110
reflexive relation, 10
Index
679
refutation, 290
allowed query, 97, 101–102
regular language, 14
base formula, 74
regular tree, 558, 575
conjunctive, 45
relation
conjunctive normal form (CNF), 83
complex value, 512
and counting, 154
extended, 229
disjunctive normal form (DNF), 83
extensional, 42, 48
domain calculus, 39, 74
intensional, 42, 48
domain independence, 70, 74, 75–77, 79, 81–97
relation (instance), 29
equivalence to first-order languages, 80
conventional perspective, 32
evaluable query, 97
logic-programming perspective, 32, 33
formula, 74–75
over empty attribute set, 32
equivalence, 82
unrestricted, 197
parse tree, 83
relation atom, 112, 217
image of query, 78
relation schema, 31
inequalities constraint, 96, 97
with dependencies, 241
natural semantics, 78, 79
relational algebra, 28, 35, 36, 70, 71, 81
negation, 70–71
aggregate operators, 97
polynomial inequalities constraint, 96
with bags, 136
positive existential, 68, 91, 97
complement operator, 103, 104
prenex normal form (PNF), 82
composition, 71
query, 75
conjunctive, 52–61
and query optimization, 126
division, 99
range restricted
and domain independence, 78
range separable query, 97
equivalence to first-order languages, 80
algorithm, 84
equivalences, 106
formula, 102
implementation, 106, 107–108
query, 97, 102
and monotonicity, 71, 98
variable, 83, 84
named, 64, 71
relational algebra normal form (RANF), 86, 97
named conjunctive, 56–59
relativized interpretation, 74, 77–78
optimization, 106, 126
rewrite rule, 82
in practical systems, 105, 106–115
for RANF, 86–87
physical implementation, 106–115
for SRNF, 83
and satisfiability, 98
safe DRC query, 97
semi-join, 128, 135
safe query, 64, 97
SPC, 52–56, 108, 118
safe-range, 81, 85, 83–85, 97
SPCU, 62, 97, 136
normal form (SRNF), 83
SPJR, 56,–59, 118
safety, 70, 75–77
vs. join dependency, 181
and satisfiability, 123
SPJRU, 62
semantics, relativized, 77
translation into calculus, 80
simulation of PCP, 123
typed restricted SPJ, 156
static analysis, 105, 122–126
and undecidability, 122–126
syntax, 74
unnamed, 71
translation into algebra, 97
unnamed conjunctive, 52–56
active domain case, 80
unrestricted, 103
safe-range case, 81, 86–91
untyped algebra, 475
tuple calculus, 39, 74, 101
relational algebra normal form (RANF), 86, 97
and undecidability, 36, 97, 105, 122–126, 136
algorithm, 88
unrestricted semantics, 78
modified, 88
unsafe, 75
relational calculus, 28, 35, 36, 64, 70, 73–91, 85
vs. first-order logic, 77, 105, 123, 136
active domain semantics, 74, 79
vs. select-from-where clause, 145
aggregate operators, 97
relational completeness, 96
680
Index
relational completeness (continued)
update language, 582
QBE, 151
rule-based conjunctive query, 39, 40–42, 41
SQL, 147
with equality, 48
vs. Turing computability, 96
semantics, 41
relational model, 28–34
with union, 62
relative information capacity, 265, 268–269, 539
rule-goal graph, 335
relativized instance, 77
running intersection property, 141
relativized interpretation, 74, 77–78
relevant fact, 317
relname, 31
safe, 64
renaming
DRC query, 97
attribute, 58
query, 97
complex value, 517, 524
safe-range, 85
operator, 57, 58
and aggregate functions, 93
SPJR algebra, 57
complex value, 528
rep(T ), 489
normal form (SRNF), 83
repeat restricted tableau query, 67
query, 97
representation system
relational calculus, 81, 83–85
strong, 489
and universal quantification, 85
weak, 490
safety, 70, 75–77
representative instance, 263
in SQL, 153
resolution, 186, 552
Same-Generation (SG)
vs. chase, 186
program, 331
resolution theorem proving, 136
query, 331
resolvent, 289, 294
Variant (SGV), 339
RETE, 600
sampling in query optimization, 111
Reverse-Same-Generation (RSG)
sat(R, ), sat( ), 174
program, 312
satisfaction, 24
query, 317
conjunctive calculus formula, 46
revision vs. update, 599–600
relative to a domain, 77
rewrite rule
satisfaction family, 174, 186, 222
conjunctive calculus, 46
satisfiability
normal form vs. query optimization, 110
and conjunctive queries, 42
for optimization, 108, 110
datalog, 300
relational calculus, 82
and first-order queries, 123
SRNF, 83
and relational algebra, 71, 98
sound, 56
and relational calculus, 123
SPC algebra, 55–56, 110
satisfiable formula, 21
SPJR algebra, 110
satisfiable query, 42
SRNF to RANF, 86–87
satisfiable SPC algebra, 56
rewriting, query, 108–110
satisfiable SPJR algebra, 59
role, 571
satisfy
root of persistence, 556
dependency, 160
rule, 41
by tableau, 175
active database, 605
functional dependency, 163
anonymous variable, 39
inclusion dependency, 193
body, 39, 41
join dependency, 170
head, 39, 41
multivalued dependency, 170
nr-datalog¬, 72
saturated set, 188
range restricted, 72
scalar domain, 153
semantics, 72
schema
range-restricted, 41
complex value, 512
semantics, 41
database, 29, 31
Index
681
object-oriented database, 554
nr-datalog¬ rule, 72
query, 572
relational calculus
relation, 31
active domain, 79
schema design
natural, 78, 79
decomposition, 162, 251–259, 252
unrestricted, 78
object-oriented database, 571
rule-based conjunctive query, 41
synthesis, 257–258
SPC algebra, 54
SDD-1, 135
SPJR algebra, 58
select-from-where clause, 112, 144
tableau query, 43
vs. projection, 144
semi-deterministic query, 574
vs. relational calculus, 145
semi-join, 128, 135
selection, 52, 57
program, 129
constant based, 66
seminaive datalog evaluation, 312–316, 335
named perspective, 57
basic algorithm, 315
physical implementation, 107
improved algorithm, 316
positive conjunctive, 55, 58
semipositive datalog, 377
pushing, 109, 335
sentence, 23
in SQL, 144
Sequel, 144
unnamed perspective, 53
set comprehension, 538
selection formula
set constructor, 508, 509
atomic, 53
set difference, 68
disjunction, 62
in relational algebra, 71
inequality atom, 69
and SPCU algebra, 136
with negation, 68
vs. negation, 70
positive, 67
set membership, 514
positive conjunctive, 55, 58, 108
set-at-a-time, 35
selection rule, 298
set _ create, 515
Semantic Binary Data Model, 264
set _ destroy, 515
semantic data model, 28, 157, 192, 240, 242–250,
sideways information passing, 111, 112–114
264, 542
in datalog evaluation, 318, 336, 340
abstract class, 243
graph, 113, 340
attribute, 243
strategy, 113
multi-valued, 243
signature, method, 551
single-valued, 243
simple key dependency, 267
class, 243
simple tableau query, 140
complex value, 243
simultaneous induction, 351
derived data, 246
single rule programs (sirups), 305, 309
Entity-Relationship (ER), 242
single-head dependency, 217
and functional dependencies, 249–253
singleton, 518
generic (GSM), 242
sip graph, 113, 340
inheritance, 245
sip strategy, 113
instance, 245
sirup, 305–309
ISA, 245
SLD datalog evaluation, 289–298
object identifier (OID), 243
SLD-AL, 335
printable class, 243
SLD-resolution, 295; See datalog, SLD-resolution.

and rfelational model, 249–253
datalog¬, 406
and schema design, 247–250
SLD-tree, 298, 317
subclass, 243
SLDNF resolution, 406
vs. inclusion dependencies, 207, 251–253
SLS resolution, 409
semantics
sort
conjunctive calculus, 45
complex value, 511
conjunctive query, 41
of instance, 32
nr-datalog¬ program, 72
of relation name, 31
682
Index
sort (continued)
group by, 154
of tuple, 32
insert, 149
sort(·), 31
and negation, 143
sort set dependency, 191
nested query, 143–147
vs. axiomatization with fds, 213
in personal computer DBMSs, 152
sort-merge implementation of join, 108
relationally complete, 147, 150
sound axiomatization, 167
safety, 153
spatial database, 95
scalar types, 145
SPC algebra, 52–56, 54, 108
select, 144
base query, 54
set operators, 146
generalized, 55
simulation of nr-datalog¬, 147–149
intersection, 55, 69
translation to algebra, 112
normal form, 55
update, 149
rewrite rule, 55–56, 110
update language, 580
satisfiable, 56
views, 149
unary singleton constant, 54
vs. cross product, 144
with union, 62
vs. first-order queries, 147–149, 155
vs. SPJR algebra, 60
vs. relational calculus, 145
vs. tableau queries, 118
vs. Sequel, 144
SPCU algebra, 62, 97
where, 144
and dependencies in views, 222
SRNF, 83
and difference, 136, 140
stable model, 408, 413
normal form, 62
stage(P , I), 285
specialization, 545
Starburst, 368, 370
SPJ algebra,
static analysis
typed restricted, 64, 67
conjunctive queries, 105, 115–122
SPJR algebra, 56–59, 57
datalog queries, 306–311
base query, 58
first-order queries, 105, 122–126
generalized, 59
of queries, 36
natural join, 56
relational calculus, 105, 122–126
normal form, 59
static binding, 552
renaming, 57
stored data, statistical properties, 106
rewrite rule, 110
stratified datalog¬, 378
satisfiable, 59
stratified negation, 49
unary singleton constant, 58
stratified semantics, 377–385. See datalog¬,
with union, 62
stratified semantics
vs. join dependency, 181
stream of tuples, 106, 135
vs. SPC algebra, 60
strongly-safe-range
vs. tableau queries, 118
complex value, 530
SPJRU algebra, 62
structured object. See complex value.

normal form, 62
Structured Query Language (SQL), 143. See SQL
SQL, 2–3, 36, 70, 74, 112, 143–150, 155, 336, 370,
subclass, 545
372, 536, 574
semantic data model, 243
bags, 145, 155
subquery
and conjunctive queries, 143–146
in datalog evaluation, 318
contains, 146
substitution, 24, 116
count, 154
vs. valuation, 116
create, 145
subsumption, 136
delete, 149
subtyping relationship, 549
distinct, 145, 154
succ, 397
and domain independence, 153
sum, 91, 92
duplicate tuples, 144
in SQL, 154
from, 144
summary of tableau query, 43
Index
683
superkey, 257
Tarski’s Algebraization Theorem, 96
supplementary relation, 319–320
Taxis, 264
supported model, 384, 411
taxonomic reasoning, 572, 575
sure(T ), 490
template dependency, 233, 236
surrogate, 247, 573
temporal constraint, 611–613
Sybase, 155
history-less checking, 615
symmetric, 10
temporal database, 95, 606–613
synthesis, 257–258
query language, 607–611
vs. decomposition, 258, 265
deductive, 610
System R, 111
TSQL, 609
query optimizer, 112, 113–114, 122, 127, 135,
representation, 608–609
137
temporal CALC, 607
temporal constraint, 611–613
on events, 612, 615
TP , 375
object histories, 615
table, 488–500; See Codd-table, naive table, c-table.

object migration, 613
tableau, 43
vs. transactional schemas, 612
complexity, 121–122
time domain, 607
composition, 226–227
now, 607
embedding, 43
transaction time, 607
typed, 44
transition constraint, 612
vs. dependencies, 218, 234
dynamic fd’s, 615
vs. join, 64
pre/post conditions, 615
tableau minimization, 105, 118–120, 136
valid time, 607
and chasing, 177–180
temporal logic, 608, 615
vs. condensation, 136
temporal query language, 607–611
vs. local optimization, 117
term, 22, 34
vs. number of joins, 118
complex value, 519
vs. resolution theorem proving, 136
tgd, 217–228
tableau query, 43–44, 43
tgd-rule in chasing, 223
chasing, 173, 186
third normal form (3NF), 257
complexity, 111–122
3-T P , 388
composition, 226
3-satisfiability, 19
containment, 121–122
3NF, 257
difference, 64
3NF Algorithm, 257
with equality, 48
3-valued instance, 386, 387, 388, 389
of an fd, 181
three-level architecture, 3
homomorphism, 117, 127, 136
logical level, 106
isomorphic, 120
physical level, 106
of a jd, 181
3-SAT, 139
minimal, 118
TI Open Object-Oriented Data Base, 135
minimization, 119
timestamp, 401
repeat restricted, 67
top-down datalog evaluation, 316–324
semantics, 43
vs. bottom-up, 311, 327, 336
simple, 140
topological sort, 11
summary, 43
total instance, 387
typed, 64, 121, 136
total order, 11
union-of-tableaux query, 63, 64, 139
total program, 395
vs. dependencies, 64
TP , 283
vs. QBE, 150
transaction time, 607
vs. SPC algebra, 118
transactional schema, 584–586, 584, 617
vs. SPJR algebra, 118
Gen(T), 585
tagged dependency, 164, 221, 241
IDM transactional schema, 584, 613, 617
684
Index
transactional schema (continued)
of implication for embedded dependencies, 220,
parameterized IDM transaction, 584
234
vs. constraints, 585–586
of implication for emvds, 220
completeness, 585
of implication of fds and inds, 199, 211
soundness, 585
underlying domain, 74
vs. methods, 584
unfounded set, 413
vs. temporal constraints, 612
unification, 293
transformation rule.See rewrite rule.

uniform containment, 304
transition constraint, 612
union, 33, 37, 38
transitive, 10
in conjunctive queries, 61–64
transitive closure query
in Microsoft Access, 153
generalized, 310
in relational algebra, 71
not first-order, 436
in rule-based conjunctive queries, 62
tree, 12
in SQL, 146
truth assignment, 21
union-of-tableaux query, 63, 64, 139
TSQL, 609
unique name axioms, 26
tup _ create, 514
unique role assumption, 261
tup _ destroy, 515
unirelational dependency, 217
tuple, 29
unit clause, 288
free, 33
universal quantification
generalized, 94, 95
removing, 83
named perspective, 32
and safe-range, 85
with placeholders, 94
vs. existential quantification, 74
unnamed perspective, 32
universal relation
tuple calculus, 74, 101
assumption (URA), 137, 266
vs. domain calculus, 39
pure, 126, 130, 242, 252
tuple generating dependency (tgd)
weak, 261–264, 262
full, 218
interface, 266
tuple rewriting, 107
scheme assumption (URSA), 260
tuple substitution, 115, 135
unique role assumption, 261
tuple-generating dependency (tgd), 217–228
universe, 23
Turing machine, 15
universe of discourse, 77
linear bounded, 196
Unix, 155
two-element instances
unknown value, 488
vs. fd’s and mvd’s, 189
unnamed perspective
two-way automata, 15
on relations, 32
type in object-oriented database, 548
projection, 54
type safety, 563, 565, 567, 573
relational algebra, 71
typed dependency, 159
selection, 53
vs. faithful, 233
SPC algebra, 52–56, 54
vs. untyped, 217
tuple, 32
typed inclusion dependency, 211
vs. named perspective, 32
typed restricted SPJ algebra, 64, 67, 156
unnest, 518
typed tableau, 44
unrestricted instance, 197
query, 64, 121, 136
unrestricted interpretation, 78
types(C), 548
unrestricted logical implication, 197–202, 219
vs. finite, 197
vs. functional dependency, 199
unary inclusion dependency (uind), 207, 210–211
vs. inclusion dependency, 199
undecidability
vs. join dependency, 199
of properties of datalog queries, 306, 308
unrestricted relational algebra, 103
of properties of first-order queries, 105, 122–126
unrestricted semantics of relational calculus, 78
untyped dependency, 192
Index
685
vs. typed, 217
in QBE, 151
untyped relational algebra, 475
and query composition, 51–52
update
in SQL, 149
in SQL, 149–150
update, 586, 589–593
statistical properties, 106
complement of views, 591–593
vs. revision, 599–600
virtual, 51
vs. query, 28
update in SQL, 149
update anomalies, 162, 241
weak instance, 262
and incomplete information, 162
weak universal model, 502
and redundancy, 162
weak universal relation assumption (URA), 261–
update language, 580–583
264, 262
completeness, 583
well-formed formula
IDM transaction, 580–582, 615–617
conjunctive calculus, 45
deletion, 615
relational calculus, 74–75
insertion, 615
well-founded semantics, 385–397
modification, 615
where in SQL vs. selection, 144
rule-based, 582–583
while, 344–346, 345
datalog¬¬, 582
while queries, 342, 367
Dynamic Logic Programming (DLP), 583, 613
normal form, 452–453
LDL, 583
on ordered databases, 447
SQL, 580
pspace complexity, 437
URA, 126, 130, 137
vs. fixpoint queries, 453
pure, 242, 252
while+, 346, 346–347
weak, 261–264, 262
while(+) + W , 456
URSA, 260
while(+)+W , 454
user view. See view.

whileN , 467
completeness on ordered databases, 468
whilenew, 469
V-relation, 513
completeness, 470–473
val(O), 547
not determinate-complete, 474
valid, 21
well-behaved, 470
valid model semantics, 409
while obj , 559
valid time, 607
whileuty, 475
valuation, 41
completeness, 478
as syntactic expression, 45
well-behaved, 477
of tableau, 43
witness operator, 454–456
vs. substitution, 116
word problem for monoids, 199
value equality, 557
var, 33, 41
variable, 33
yes-no query, 42
anonymous, 39, 44
bound occurrence, 45, 75
free occurrence, 45, 75
0-1 law, 441
variable assignment, 24
for CALC, 441–444
variable substitution
for while, 444–446
rewrite rule, 46, 83
view, 4
complement, 583
and dependencies, 222
maintenance, 586–588, 586
materialized, 51
object-oriented database, 571


Document Outline

The Main Principles
Functionalities
Complexity and Diversity
Past and Future
Ties with This Book
Bibliographic Notes
Some Basics
Languages, Computability, and Complexity
Basics from Logic
The Structure of the Relational Model
Named versus Unnamed Perspectives
Conventional versus Logic Programming Perspectives
Notation
Bibliographic Notes
Getting Started
Logic-Based Perspectives
Query Composition and Views
Algebraic Perspectives
Adding Union
Bibliographic Notes


